<html>
<head>
<title>How To Create Your Own Router In Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建自己的苗条路由器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-router-in-svelte-ce66c10275fe?source=collection_archive---------5-----------------------#2020-09-15">https://javascript.plainenglish.io/how-to-create-a-router-in-svelte-ce66c10275fe?source=collection_archive---------5-----------------------#2020-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="40de" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">苗条的</h2><div class=""/><div class=""><h2 id="6bac" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">我们可以用几行代码避免不必要的包</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/76dc182f460f58fd5bba5b9fb29b993e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vPydtMV8cJF7Q_LQ"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@soymeraki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Javier Allegue Barros</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="73f1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在单页面应用程序中，例如当我们使用JavaScript框架时(就像我们钟爱的Svelte一样)，我们需要为用户提供一种方法，让他们根据需要在网站的各个部分之间导航。</p><p id="d9d6" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">因为在SPA中所有的网页请求都被重定向到根页面，所以我们需要模拟导航页面的“标准”方式。这就是路由库帮助我们的地方，虽然它看起来是一个复杂的任务，但它的基本功能非常简单，只需几行代码就可以完成。</p><p id="5a3e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在文章的最后，我们可以使用自己的路由器，也许是为了我们的下一个项目。</p><h1 id="1711" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">为什么要实施定制路由器</h1><ul class=""><li id="651b" class="mq mr in le b lf ms li mt ll mu lp mv lt mw lx mx my mz na bi translated">我们不需要当前路由器包的所有功能。SPA的捆绑包大小是需要考虑的最重要的事情之一，因为性能与用户下载必要的脚本所需的时间成正比。</li><li id="07bd" class="mq mr in le b lf nb li nc ll nd lp ne lt nf lx mx my mz na bi translated"><strong class="le ix">我们可以定制路由器功能，以适应您的需求。</strong>也许我们想要在页面之间添加一些过渡，或者在页面变化时触发一个功能，嗯……我们拥有代码的控制权，我们正在编写我们自以为是的规则。</li><li id="de39" class="mq mr in le b lf nb li nc ll nd lp ne lt nf lx mx my mz na bi translated"><strong class="le ix">我们可以学习新的Javascript技能。</strong>在本文中，例如，我们将使用<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" rel="noopener ugc nofollow" target="_blank"> <em class="ng"> HTML5历史API </em> </a>，一个本地API来与浏览器的历史进行交互。你会惊讶于有这么多的可能性。</li></ul><h1 id="2037" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">路由器如何工作</h1><p id="6e29" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">让我们开始学习我们最喜欢的路由器是如何工作的。例如，让我们以<em class="ng">细长路由</em> npm包为例。</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="17dc" class="np lz in nl b gy nq nr l ns nt">&lt;Router {url}&gt;<br/>    &lt;Route path="blog/:id" component={Post}/&gt;<br/>    &lt;Route path="blog" component={Blog}/&gt;<br/>    &lt;Route path="about" component={About}/&gt;<br/>    &lt;Route path="/" component={Home} /&gt;<br/>&lt;/Router&gt;</span><span id="f0cd" class="np lz in nl b gy nu nr l ns nt">&lt;script&gt;<br/>  <strong class="nl ix">import </strong>{Router, Route} <strong class="nl ix">from </strong>"svelte-routing";<br/>  <strong class="nl ix">import </strong>Home <strong class="nl ix">from </strong>"./routes/Home.svelte";<br/>  <strong class="nl ix">import </strong>About <strong class="nl ix">from </strong>"./routes/About.svelte";<br/>  <strong class="nl ix">import </strong>Blog <strong class="nl ix">from </strong>"./routes/Blog.svelte";<br/>  <strong class="nl ix">import </strong>Post <strong class="nl ix">from </strong>"./routes/Post.svelte";</span><span id="c7c3" class="np lz in nl b gy nu nr l ns nt">  <strong class="nl ix">export let</strong> url = "";<br/>&lt;/script&gt;</span></pre><p id="b6a8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在这个包中，我们声明初始路径(<em class="ng"> url </em>变量)，将它传递给路由器组件，并声明所有的路由，每个路由都包含要加载的路径和组件。我们将在main <em class="ng"> App.svelte </em>中编写这段代码，因此当用户请求特定页面时，我们总是传入根页面并返回他选择的组件/页面。</p><p id="ae25" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">为此，路由器将读取当前的<em class="ng">窗口。位置</em>并将在声明的路由中搜索匹配相同模式的路由。因此，路由器将呈现正确的组件。</p><h1 id="2a6b" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">我们将构建的定制路由器示例</h1><p id="8d5d" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">在本文中，我们将构建一个路由器组件，您可以这样使用它:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="df08" class="np lz in nl b gy nq nr l ns nt">&lt;Router {routes}/&gt;</span><span id="5e9c" class="np lz in nl b gy nu nr l ns nt">&lt;script&gt;<br/>  <strong class="nl ix">import </strong>Router <strong class="nl ix">from </strong>"@/components/Router.svelte";<br/>  <strong class="nl ix">import </strong>Home <strong class="nl ix">from </strong>"./routes/Home.svelte";<br/>  <strong class="nl ix">import </strong>About <strong class="nl ix">from </strong>"./routes/About.svelte";<br/>  <strong class="nl ix">import </strong>Blog <strong class="nl ix">from </strong>"./routes/Blog.svelte";<br/>  <strong class="nl ix">import </strong>Post <strong class="nl ix">from </strong>"./routes/Post.svelte";</span><span id="a8af" class="np lz in nl b gy nu nr l ns nt">  const routes = {<br/>    "blog/:id": () =&gt; Post,<br/>    "blog": () =&gt; Blog,<br/>    "about": () =&gt; About,<br/>    "/": () =&gt; Home<br/>  };<br/>&lt;/script&gt;</span></pre><h1 id="cb50" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">如何实现路由器</h1><p id="bde7" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">那么让我们开始:创建一个新组件，将其命名为<em class="ng"> Router.svelte </em>。这里我们需要呈现所选的页面并搜索正确的路线。</p><h2 id="5eec" class="np lz in bd ma nv nw dn me nx ny dp mi ll nz oa mk lp ob oc mm lt od oe mo it bi translated">基本路由</h2><p id="8645" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">假设您有以下路线:</p><ul class=""><li id="43eb" class="mq mr in le b lf lg li lj ll of lp og lt oh lx mx my mz na bi translated">/博客</li><li id="f2b7" class="mq mr in le b lf nb li nc ll nd lp ne lt nf lx mx my mz na bi translated">/关于</li><li id="5355" class="mq mr in le b lf nb li nc ll nd lp ne lt nf lx mx my mz na bi translated">/用户/帖子</li><li id="3d07" class="mq mr in le b lf nb li nc ll nd lp ne lt nf lx mx my mz na bi">/</li></ul><p id="3622" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">首先，我们需要一个呈现当前页面的位置:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="f5a1" class="np lz in nl b gy nq nr l ns nt">&lt;<strong class="nl ix">svelte:component</strong> this={<strong class="nl ix"><em class="ng">component</em></strong>}/&gt;</span></pre><p id="ceab" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们还需要声明<em class="ng">组件</em>变量，并接受<em class="ng"> routes </em>对象作为属性:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="3165" class="np lz in nl b gy nq nr l ns nt"><strong class="nl ix">let </strong>component<strong class="nl ix">;<br/>export let</strong> routes = {};</span></pre><p id="bf3a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">然后，我们必须找到我们之间的正确路线。让我们创建一个函数LoadRoute:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="de8c" class="np lz in nl b gy nq nr l ns nt"><strong class="nl ix">const </strong>LoadRoute = <em class="ng">path </em>=&gt; {<br/>  <strong class="nl ix"><em class="ng">component </em></strong>= <strong class="nl ix"><em class="ng">routes</em></strong>[<em class="ng">path</em>]();<br/>};</span></pre><p id="a042" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">最后，在挂载时调用这个函数，传递当前页面:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="d75f" class="np lz in nl b gy nq nr l ns nt"><strong class="nl ix">onMount</strong>(() =&gt; {<br/>  <strong class="nl ix">LoadRoute</strong>(<em class="ng">location.pathname</em>);<br/>});</span></pre><p id="dc51" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">并使用以下函数拦截反向动作:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="5e99" class="np lz in nl b gy nq nr l ns nt"><strong class="nl ix">window.onpopstate</strong> = () =&gt; LoadRoute(<em class="ng">location.pathname</em>);</span></pre><p id="ac64" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">完整代码:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="eb84" class="np lz in nl b gy nq nr l ns nt">&lt;<strong class="nl ix">svelte:component</strong> this={<strong class="nl ix"><em class="ng">component</em></strong>}/&gt;</span><span id="62af" class="np lz in nl b gy nu nr l ns nt">&lt;script&gt;<br/>  <strong class="nl ix">import </strong>{onMount} <strong class="nl ix">from </strong>"svelte";</span><span id="5bd0" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  let </strong>component<strong class="nl ix">;<br/>  export let</strong> routes = {};</span><span id="6fcf" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  onMount</strong>(() =&gt; {<br/>    <strong class="nl ix">LoadRoute</strong>(<em class="ng">location.pathname</em>);<br/>  });<br/>&lt;/script&gt;</span><span id="e9ac" class="np lz in nl b gy nu nr l ns nt">&lt;script context="module"&gt;<br/><strong class="nl ix">  const </strong>LoadRoute = <em class="ng">path </em>=&gt; {<br/>    <strong class="nl ix"><em class="ng">component </em></strong>= <strong class="nl ix"><em class="ng">routes</em></strong>[<em class="ng">path</em>]();<br/>  };</span><span id="6551" class="np lz in nl b gy nu nr l ns nt">  <strong class="nl ix">window.onpopstate</strong> = () =&gt; LoadRoute(<em class="ng">location.pathname</em>);<br/>&lt;/script&gt;</span></pre><h2 id="344d" class="np lz in bd ma nv nw dn me nx ny dp mi ll nz oa mk lp ob oc mm lt od oe mo it bi translated">导航功能</h2><p id="69f9" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">为了在我们的网站中导航，我们需要实现一个将在整个项目中使用的功能，这样我们就可以在不重新加载的情况下更改页面。</p><p id="e584" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">将此添加到您的代码中:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="d2d9" class="np lz in nl b gy nq nr l ns nt">&lt;script context="module"&gt;<br/>  // previous code</span><span id="cb0e" class="np lz in nl b gy nu nr l ns nt">  <strong class="nl ix">export const</strong> navigate = <em class="ng">path </em>=&gt; {<br/>    window.history.pushState(null, null, path);<br/>    LoadRoute(path);<br/>  };<br/>&lt;/script&gt;</span></pre><p id="d33c" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在，您可以在每个组件中以这种方式使用函数:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="c05b" class="np lz in nl b gy nq nr l ns nt">&lt;<strong class="nl ix">button </strong>on:click={() =&gt; <strong class="nl ix">navigate</strong>("/about")}&gt;<br/>  About<br/>&lt;/<strong class="nl ix">button</strong>&gt;</span></pre><h2 id="a2b0" class="np lz in bd ma nv nw dn me nx ny dp mi ll nz oa mk lp ob oc mm lt od oe mo it bi translated">路径变量</h2><p id="f42a" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">我们在路由器中发现的另一个常见的东西是带参数的路径，假设我们有一篇博客文章必须在<em class="ng"> /blog/my-post </em>处响应，其中<em class="ng"> my-post </em>将是动态的。在这种情况下，路由器还必须搜索带有动态分段的路由。</p><p id="be5e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">例如，我们可以将以下路线添加到我们的路线中:</p><ul class=""><li id="940f" class="mq mr in le b lf lg li lj ll of lp og lt oh lx mx my mz na bi translated">/blog/:id</li></ul><p id="fe5b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在我们的路由器中，变量将由一个开始的“:”定义，就像瘦路由一样。</p><p id="8f69" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们必须将所有可用的路径分割成段(<em class="ng"> getRouteSegments </em>函数)，然后将每个段与当前路径进行比较(<em class="ng"> getRoute </em>)。</p><p id="bc09" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们显然需要提取当前路径中的所有变量作为props ( <em class="ng"> getProps </em>函数)。</p><p id="05d6" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">将以下代码添加到我们的<script context="”module”">中:&lt;/root&gt;</script></p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="6149" class="np lz in nl b gy nq nr l ns nt"><strong class="nl ix">let </strong>_routes = {};</span><span id="f8aa" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">const </strong>getRouteSegments = <em class="ng">routes </em>=&gt;<br/>  Object.entries(routes).map(([path, component]) =&gt; ({<br/>    path,<br/>    component,<br/>    segments: path<br/>      .replace(/^\/+|\/+$/g, '')<br/>      .split('/')<br/>      .map(segment =&gt; ({<br/>        name: segment.replace(':', ''),<br/>        variable: segment.startsWith(':')<br/>      }))<br/>  }));</span><span id="460b" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">const </strong>getRoute = <em class="ng">path </em>=&gt; {<br/>  <strong class="nl ix">const </strong>segments = path.replace(/^\/+|\/+$/g, '').split('/');</span><span id="4dce" class="np lz in nl b gy nu nr l ns nt">  <strong class="nl ix">return </strong>_routes.find(route =&gt; {<br/>    if(route.segments.length !== segments.length) return false;</span><span id="5060" class="np lz in nl b gy nu nr l ns nt">    <strong class="nl ix">return </strong>segments.every((<em class="ng">s</em>, <em class="ng">i</em>) =&gt;<br/>      route.segments[i].name === s ||<br/>      route.segments[i].variable<br/>    );<br/>  });<br/>};</span><span id="178f" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">const </strong>getProps = (<em class="ng">path</em>,<em class="ng"> routeSegments</em>) =&gt; {<br/>  <strong class="nl ix">let </strong>props = {};</span><span id="f441" class="np lz in nl b gy nu nr l ns nt">  <strong class="nl ix">const </strong>segments = path.replace(/^\/+|\/+$/g, '').split('/');<br/>  segments.map((<em class="ng">s</em>, <em class="ng">i</em>) =&gt;<br/>    routeSegments[i].variable &amp;&amp;<br/>    (props[routeSegments[i].name] = s)<br/>  );</span><span id="1718" class="np lz in nl b gy nu nr l ns nt">  <strong class="nl ix">return </strong>props;<br/>};</span></pre><p id="f774" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在，我们在&lt;脚本&gt;中声明<em class="ng">道具</em>变量:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="f482" class="np lz in nl b gy nq nr l ns nt"><strong class="nl ix">let </strong>props = {};</span></pre><p id="e90f" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们编辑onMount函数:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="e133" class="np lz in nl b gy nq nr l ns nt">onMount(() =&gt; {<br/>  _routes = getRouteSegments(routes);<br/>  LoadRoute(location.pathname);<br/>});</span></pre><p id="67c1" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们的LoadRoute函数:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="8c8f" class="np lz in nl b gy nq nr l ns nt"><strong class="nl ix">const </strong>LoadRoute = async(path) =&gt; {<br/>  <strong class="nl ix">const </strong>current = getRoute(path);</span><span id="9220" class="np lz in nl b gy nu nr l ns nt">  component = (<strong class="nl ix">await </strong>current.component()).default;<br/>  props = getProps(path, current.segments);<br/>};</span></pre><p id="c5c8" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">最后，我们必须将道具传递给当前组件:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="4749" class="np lz in nl b gy nq nr l ns nt">&lt;<strong class="nl ix">svelte:component</strong> this={<strong class="nl ix"><em class="ng">component</em></strong>} {<strong class="nl ix"><em class="ng">...props</em></strong>}/&gt;</span></pre><h2 id="3715" class="np lz in bd ma nv nw dn me nx ny dp mi ll nz oa mk lp ob oc mm lt od oe mo it bi translated">完整的Router.svelte代码</h2><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="d11a" class="np lz in nl b gy nq nr l ns nt">&lt;<strong class="nl ix">svelte:component</strong> this={<strong class="nl ix"><em class="ng">component</em></strong>} {<strong class="nl ix"><em class="ng">...props</em></strong>}/&gt;</span><span id="5213" class="np lz in nl b gy nu nr l ns nt">&lt;script&gt;<br/>  <strong class="nl ix">import </strong>{onMount} <strong class="nl ix">from </strong>"svelte";</span><span id="c6ad" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  let </strong>component<strong class="nl ix">;<br/>  export let</strong> routes = {};</span><span id="7494" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  onMount</strong>(() =&gt; {<br/>    _routes = getRouteSegments(routes);<br/>    LoadRoute(<em class="ng">location.pathname</em>);<br/>  });<br/>&lt;/script&gt;</span><span id="ae9b" class="np lz in nl b gy nu nr l ns nt">&lt;script context="module"&gt;<br/><strong class="nl ix">  let </strong>_routes = {};<br/>  <strong class="nl ix">let </strong>props = {};</span><span id="eacb" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  const </strong>LoadRoute = async(<em class="ng">path</em>) =&gt; {<br/>    <strong class="nl ix">const </strong>current = getRoute(path);</span><span id="3ed7" class="np lz in nl b gy nu nr l ns nt">    component = (<strong class="nl ix">await </strong>current.component()).default;<br/>    props = getProps(path, current.segments);<br/>  };</span><span id="bb99" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  const </strong>getRouteSegments = <em class="ng">routes </em>=&gt;<br/>    Object.entries(routes).map(([path, component]) =&gt; ({<br/>      path,<br/>      component,<br/>      segments: path<br/>        .replace(/^\/+|\/+$/g, '')<br/>        .split('/')<br/>        .map(segment =&gt; ({<br/>          name: segment.replace(':', ''),<br/>          variable: segment.startsWith(':')<br/>        }))<br/>    }));</span><span id="f6c1" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  const </strong>getRoute = <em class="ng">path </em>=&gt; {<br/>    <strong class="nl ix">const </strong>segments = path.replace(/^\/+|\/+$/g, '').split('/');</span><span id="2de9" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">    return </strong>_routes.find(route =&gt; {<br/>      if(route.segments.length !== segments.length) return false;</span><span id="6f3e" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">      return </strong>segments.every((<em class="ng">s</em>, <em class="ng">i</em>) =&gt;<br/>        route.segments[i].name === s ||<br/>        route.segments[i].variable<br/>      );<br/>    });<br/>  };</span><span id="080d" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  const </strong>getProps = (<em class="ng">path</em>,<em class="ng"> routeSegments</em>) =&gt; {<br/>    <strong class="nl ix">let </strong>props = {};</span><span id="7061" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">    const </strong>segments = path.replace(/^\/+|\/+$/g, '').split('/');<br/>    segments.map((<em class="ng">s</em>, <em class="ng">i</em>) =&gt;<br/>      routeSegments[i].variable &amp;&amp;<br/>      (props[routeSegments[i].name] = s)<br/>    );</span><span id="84ac" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">    return </strong>props;<br/>  };</span><span id="9632" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  export const</strong> navigate = <em class="ng">path </em>=&gt; {<br/>    window.history.pushState(null, null, path);<br/>    LoadRoute(path);<br/>  };</span><span id="365f" class="np lz in nl b gy nu nr l ns nt"><strong class="nl ix">  window.onpopstate</strong> = () =&gt; LoadRoute(<em class="ng">location.pathname</em>);<br/>&lt;/script&gt;</span></pre><h1 id="a359" class="ly lz in bd ma mb mc md me mf mg mh mi kc mj kd mk kf ml kg mm ki mn kj mo mp bi translated">结论</h1><p id="371a" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">这是我写的第一篇关于Medium的文章，希望能写很多其他的文章，对你有所帮助。我将写下我作为一名web开发人员的经历以及我将使用的新技术。</p><p id="7b4f" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果我会犯一些语法错误，我很抱歉，但英语不是我的母语。</p><p id="6201" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果我帮了你，或者你有任何问题，请联系我，或者跟随我获取其他建议。谢谢大家！</p></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><p id="ad22" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">以下是我的一些其他文章:</strong></p><div class="op oq gp gr or os"><a href="https://medium.com/javascript-in-plain-english/diy-multilanguage-in-javascript-project-65f8aa91a506" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ix gy z fp ox fr fs oy fu fw iw bi translated">JavaScript项目中的DIY多语言</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">让我们用这个简单的方法来国际化我们的webapp</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kv os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://medium.com/javascript-in-plain-english/create-reusable-svelte-components-for-your-page-layouts-9593b1a60b08" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ix gy z fp ox fr fs oy fu fw iw bi translated">为你的页面布局创建可重用的苗条组件</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">了解如何构建一个可以跨页面使用的组件</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg kv os"/></div></div></a></div></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><h2 id="3dc2" class="np lz in bd ma nv nw dn me nx ny dp mi ll nz oa mk lp ob oc mm lt od oe mo it bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="a4ba" class="pw-post-body-paragraph lc ld in le b lf ms jx lh li mt ka lk ll nh ln lo lp ni lr ls lt nj lv lw lx ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="le ix">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="le ix">！</strong></p></div></div>    
</body>
</html>