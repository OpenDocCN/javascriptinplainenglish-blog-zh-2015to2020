<html>
<head>
<title>Node.js Tips — Upsert Data, Ciphers, and Parsing Directories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—更新数据、密码和解析目录</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-upsert-data-ciphers-and-parsing-directories-dabdadc9cdfc?source=collection_archive---------11-----------------------#2020-07-14">https://javascript.plainenglish.io/node-js-tips-upsert-data-ciphers-and-parsing-directories-dabdadc9cdfc?source=collection_archive---------11-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7984c261eeb94b5c8ff99f88e885613f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BjTX04NvkTebN-Po"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@murder666?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sveta Golovina</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d1be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="93bd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Express中response.send和response.write的区别</h1><p id="91ed" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">res.send</code>只被调用一次，它将缓冲区大小的数据块发送给客户端。</p><p id="83f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，它返回并向客户端发送更多具有该缓冲区大小的数据，直到发送完成。</p><p id="e1e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">res.write</code>被多次调用，后跟<code class="fe me mf mg mh b">res.end</code>。它创建一个大小基于整个数据的缓冲区。</p><p id="cdd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后通过HTTP发送出去。因此，在数据量巨大的情况下速度更快。</p><h1 id="62a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果不存在，则创建文档，否则用Mongoose更新现有文档</h1><p id="6f21" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果文档不存在，我们可以创建文档，否则用<code class="fe me mf mg mh b">findOneAndUpdate</code>方法进行更新。</p><p id="db2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3086" class="mq lc iq mh b gy mr ms l mt mu">const query = {};<br/>const update = { expire: new Date() };<br/>const options = { <br/>  upsert: true<br/>};</span><span id="1542" class="mq lc iq mh b gy mv ms l mt mu"><br/>Model.findOneAndUpdate(query, update, options, (error, result) =&gt; {<br/>  if (error) return;<br/>});</span></pre><p id="373d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一个属性设置为<code class="fe me mf mg mh b">true</code>的<code class="fe me mf mg mh b">options</code>对象。</p><p id="a9fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">update</code>有我们想要添加或更新的数据。</p><p id="2eb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">query</code>有获取数据的查询。</p><p id="4ecf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当操作完成时，回调被调用。</p><p id="2f7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">result</code>已将数据写入文件。</p><p id="64bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">error</code>有错误对象。</p><h1 id="eed8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Node.js将文件系统中的目录结构转换成JSON</h1><p id="ca33" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">directory-package</code>将文件系统的结构读入JSON。</p><p id="ed31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7e7" class="mq lc iq mh b gy mr ms l mt mu">npm i directory-tree</span></pre><p id="d86a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2b22" class="mq lc iq mh b gy mr ms l mt mu">const dirTree = require("directory-tree");<br/>const tree = dirTree("/foo/bar");</span></pre><p id="587b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">directory-tree</code>包的<code class="fe me mf mg mh b">dirTree</code>功能。</p><p id="a73e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将路径传递给<code class="fe me mf mg mh b">dirTree</code>函数。</p><p id="baa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来限制要枚举的文件类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3be6" class="mq lc iq mh b gy mr ms l mt mu">const dirTree = require("directory-tree");<br/>const filteredTree = dirTree("/some/path", { extensions: /\.txt/ });</span></pre><p id="c779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">extension</code>正则表达式进行过滤。</p><h1 id="cd7d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在HTTP和HTTPS上监听单个Express应用程序</h1><p id="c68d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">http</code>和<code class="fe me mf mg mh b">https</code>包并在两者上调用<code class="fe me mf mg mh b">createServer</code>方法来同时监听HTTP和HTTPS。</p><p id="2d01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a5a" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const https = require('https');<br/>const http = require('http');<br/>const fs = require('fs');<br/>const app = express();</span><span id="81e4" class="mq lc iq mh b gy mv ms l mt mu">const options = {<br/>  key: fs.readFileSync('/path/to/key.pem'),<br/>  cert: fs.readFileSync('/path/to/cert.pem'),<br/>  ca: fs.readFileSync('/path/to/ca.pem')<br/>};</span><span id="2169" class="mq lc iq mh b gy mv ms l mt mu">http.createServer(app).listen(80);<br/>https.createServer(options, app).listen(443);</span></pre><p id="723f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们读取证书文件，并用它们调用<code class="fe me mf mg mh b">createServer</code>来监听HTTPS的请求。</p><p id="058e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且我们还像往常一样使用<code class="fe me mf mg mh b">http</code>监听常规的HTTP请求。</p><h1 id="7004" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js中process.nextTick的用例</h1><p id="4098" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">process.nextTick</code>将回调放到队列中。</p><p id="c185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这和用<code class="fe me mf mg mh b">setTimeout</code>延迟代码执行是一样的。</p><p id="dbc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a96e" class="mq lc iq mh b gy mr ms l mt mu">process.nextTick(() =&gt; {<br/>  console.log('hello');<br/>});</span></pre><h1 id="af57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">加密需要解密的数据</h1><p id="5b6d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">crypto</code>模块加密需要解密的数据。</p><p id="5d8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有<code class="fe me mf mg mh b">createCipher</code>方法让我们创建一个可以被破译的密码。</p><p id="9719" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c507" class="mq lc iq mh b gy mr ms l mt mu">const crypto = require('crypto');</span><span id="2af7" class="mq lc iq mh b gy mv ms l mt mu">const algorithm = 'aes256'; <br/>const key = 'sercetkey';<br/>const text = 'hello world';</span><span id="99b2" class="mq lc iq mh b gy mv ms l mt mu">const cipher = crypto.createCipher(algorithm, key);  <br/>const encrypted = cipher.update(text, 'utf8', 'hex') + cipher.final('hex');</span><span id="7f1d" class="mq lc iq mh b gy mv ms l mt mu">const decipher = crypto.createDecipher(algorithm, key);<br/>const decrypted = decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');</span></pre><p id="d872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">algorithm</code>和<code class="fe me mf mg mh b">key</code>调用<code class="fe me mf mg mh b">createCipher</code>来创建密码。</p><p id="2f72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后为了加密<code class="fe me mf mg mh b">text</code>，我们调用<code class="fe me mf mg mh b">cipher.update</code>并将其与<code class="fe me mf mg mh b">cipher.final('hex')</code>连接起来。</p><p id="84ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">cipher.final</code>只能调用一次，这样文本只能加密一次。</p><p id="face" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想要破译文本时，我们用相同的<code class="fe me mf mg mh b">algorithm</code>和<code class="fe me mf mg mh b">key</code>调用<code class="fe me mf mg mh b">createDecipher</code>方法。</p><p id="5d48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以使用<code class="fe me mf mg mh b">decipher.update</code>来解密加密的文本，并将其与<code class="fe me mf mg mh b">decipher.find('hex')</code>连接来解密文本。</p><p id="9f76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">decipher.final</code>只能调用一次，这样加密的文本只能解密一次。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/866e591cfd2c42882a9ed59e425523fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nrw4rWeh9qDahNlA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alexbeware?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Ware</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ae0d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="dea8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">crypto</code>模块创建密码和破译文本。</p><p id="3421" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">res.send</code>和<code class="fe me mf mg mh b">res.write</code>表达不同。一个适用于小数据，一个适用于大数据。</p><p id="b309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用猫鼬上传数据。</p><p id="d240" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目录结构可以读入JSON。</p></div></div>    
</body>
</html>