<html>
<head>
<title>When is it okay to Unit Test private variables and functions in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候可以在JavaScript中对私有变量和函数进行单元测试？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-testing-private-variables-and-functions-in-javascript-when-is-it-ok-6090bd43c7b5?source=collection_archive---------11-----------------------#2020-10-26">https://javascript.plainenglish.io/unit-testing-private-variables-and-functions-in-javascript-when-is-it-ok-6090bd43c7b5?source=collection_archive---------11-----------------------#2020-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9534" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">问这个问题可能是潜在设计缺陷的标志。解决这些问题的第一步。</h2></div><h2 id="b621" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">为什么你通常不应该测试它们</h2><p id="43c7" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">在她的书<a class="ae lr" href="https://www.poodr.com/" rel="noopener ugc nofollow" target="_blank"><em class="ls">Ruby</em></a>中的实用面向对象设计中，Sandi Metz列举了以下理由<strong class="la io">而不是</strong>在单元测试中包含私有方法:</p><ul class=""><li id="9075" class="lt lu in la b lb lv le lw kl lx kp ly kt lz lq ma mb mc md bi translated"><strong class="la io">冗余</strong>:私有方法隐藏在<em class="ls">已经</em>测试过的公共组件中；现有的测试总是会暴露其中的失败。</li><li id="e874" class="lt lu in la b lb me le mf kl mg kp mh kt mi lq ma mb mc md bi translated"><strong class="la io">不稳定性</strong>:私有方法更容易改变，当它们改变时，测试也会改变。这需要时间。</li><li id="d987" class="lt lu in la b lb me le mf kl mg kp mh kt mi lq ma mb mc md bi translated"><strong class="la io">暴露</strong>:测试私有方法会将它们暴露给更多的受众，这些受众可能会被误导而使用它们，因此通过依赖它们来破坏封装。</li></ul><p id="c211" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">我只能说我完全同意第一点:裁员。尽管这些观点很有道理，但它们更适合于实际的面向对象编程，这是JavaScript还不具备的一个方面。</p><p id="2f5b" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">关于不测试私有变量或方法，我发现书中的另一段摘录更有说服力:</p><p id="9508" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated"><strong class="la io">【单元测试】揭露底层代码中的设计缺陷。如果一个测试需要痛苦的设置，代码会期望太多的上下文。如果测试一个对象会将一堆其他对象拖进来，那么代码就有太多的依赖项。如果测试难以编写，其他对象会发现代码难以重用。</strong></p><p id="0a3b" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">这一点让我重新考虑我在发布的上一个JavaScript包中进行单元测试的方式。我们现在会研究这个问题。</p><h2 id="5dd6" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">…以及如何测试它们</h2><figure class="mn mo mp mq gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mm"><img src="../Images/e7545bad4f574eb45cba40a74e279763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jFw-BMU32WutMYiH"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@austriannationallibrary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Austrian National Library</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1d56" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">考虑来自我的JavaScript模块<a class="ae lr" href="https://www.npmjs.com/package/pending-promise-recycler" rel="noopener ugc nofollow" target="_blank">pending-promise-recycler</a>的以下简化片段:</p><pre class="mn mo mp mq gt nc nd ne nf aw ng bi"><span id="80f7" class="kc kd in nd b gy nh ni l nj nk">const registry = new <strong class="nd io"><em class="ls">Map</em></strong>();</span><span id="78be" class="kc kd in nd b gy nl ni l nj nk">module.exports = function recycle(func, options = {}) {<br/>    // Here, we use the variable <strong class="nd io">registry</strong> to cache promises.<br/>    // The <strong class="nd io">key</strong> of the cached function comes from the <strong class="nd io">options</strong> and the<br/>    // developer can either use a custom function or rely on a       <br/>    // default builder that uses function name and arguments.<br/>    // If the cache is a <strong class="nd io">hit</strong>, return the cached function<br/>    // If it's a <strong class="nd io">miss</strong>, cache the function and return it<br/>});</span></pre><p id="2193" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">对于许多单元测试的实现，我认为最简单的方法是访问<code class="fe nm nn no nd b">registry</code>变量，它不是由模块公开的。这可以通过使用<a class="ae lr" href="https://www.npmjs.com/package/rewire" rel="noopener ugc nofollow" target="_blank"> <strong class="la io">模块</strong> </a>重新布线轻松实现:</p><pre class="mn mo mp mq gt nc nd ne nf aw ng bi"><span id="957d" class="kc kd in nd b gy nh ni l nj nk">const rewire = require('rewire');</span><span id="dea7" class="kc kd in nd b gy nl ni l nj nk">const recycle = rewire('./index');</span><span id="941e" class="kc kd in nd b gy nl ni l nj nk">const registry = <strong class="nd io">recycle.__get__('registry')</strong>;</span></pre><p id="19c1" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">有关更多细节，请查看<a class="ae lr" href="https://github.com/Dunkelheit/pending-promise-recycler/blob/main/index.test.js" rel="noopener ugc nofollow" target="_blank">完整单元测试套件</a>。</p><p id="0a53" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">很好！现在，我可以测试以下三种情况:</p><ol class=""><li id="2e84" class="lt lu in la b lb lv le lw kl lx kp ly kt lz lq np mb mc md bi translated">缓存在注册表中的函数有键，这些键可以由自定义函数生成，也可以由函数名及其参数决定。</li><li id="09dc" class="lt lu in la b lb me le mf kl mg kp mh kt mi lq np mb mc md bi translated">在(promise)函数因为已被解析而不再属于注册表后，注册表将被清空，以防止潜在的内存泄漏。</li><li id="8015" class="lt lu in la b lb me le mf kl mg kp mh kt mi lq np mb mc md bi translated">缓存实际上是工作的，有命中和未命中，这取决于某个函数是否仍在缓存注册表中。</li></ol><p id="f97b" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">但是，等等……我真的需要为此访问私有变量<code class="fe nm nn no nd b">registry</code>吗？该回到我最喜欢的节选了。很明显，在为了容易设置和执行而越过检查之后，我没有从正确的角度来看待单元测试。<strong class="la io">一个失败的私人变量</strong> <code class="fe nm nn no nd b"><strong class="la io">registry</strong></code> <strong class="la io">应该是可以通过肤浅的、公共的行为功能</strong>检测出来的。</p><ul class=""><li id="8dea" class="lt lu in la b lb lv le lw kl lx kp ly kt lz lq ma mb mc md bi translated"><strong class="la io">对于测试1和测试3 </strong>，在不详细讨论实现细节的情况下，我可以很容易地创建一个单元测试，通过使用<a class="ae lr" href="https://sinonjs.org/releases/latest/spies/" rel="noopener ugc nofollow" target="_blank"> sinon间谍</a>断言缓存的函数没有被调用两次，而是被调用一次，来验证缓存中的函数不会被执行两次。这应该适用于自定义或默认的密钥构建功能，如案例1中所述。</li><li id="3b20" class="lt lu in la b lb me le mf kl mg kp mh kt mi lq ma mb mc md bi translated"><strong class="la io">对于情况2 </strong>，我可以验证函数最终被从缓存中移除，因为一旦它们被满足，对缓存函数的任何下一次调用将不是命中，而是未命中。使用sinon间谍也可以很容易地测试这一点。</li></ul></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="246e" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">对私有变量进行单元测试真的很有吸引力，在JavaScript中，由于像重新布线这样的模块，这非常容易。<strong class="la io">如果你发现自己不得不对私有变量进行断言，这可能表明你的实现或者你的单元测试方法应该得到更多的时间和关注</strong>。</p><p id="eaae" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">最后，让常识来决定吧！</p><p id="bed4" class="pw-post-body-paragraph ky kz in la b lb lv jo ld le lw jr lg kl mj li lj kp mk ll lm kt ml lo lp lq ig bi translated">您是否面临过类似的情况？我很想听听进展如何！在下面给我留言！</p></div></div>    
</body>
</html>