<html>
<head>
<title>JavaScript Lazy Evaluation: Generators (Examples Included)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript惰性评估:生成器(包括示例)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-lazy-evaluation-generators-examples-included-f9eaa517f969?source=collection_archive---------2-----------------------#2020-09-28">https://javascript.plainenglish.io/javascript-lazy-evaluation-generators-examples-included-f9eaa517f969?source=collection_archive---------2-----------------------#2020-09-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="08b7" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">JavaScript Alpha指南</h2><div class=""/><div class=""><h2 id="6c4f" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">什么是JavaScript生成器？深入的教程和真实的用例示例。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/8ca5e4692386b2b8b140e66f1eed44dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JESHv5lx7xA1XHSF2dZrNw.png"/></div></div></figure><p id="1667" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在<a class="ae lt" href="https://medium.com/@MelkorNemesis/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f" rel="noopener">之前的文章</a>中，我们看了JavaScript <strong class="kz ix">迭代器</strong>和<strong class="kz ix">迭代器</strong>。它们是<strong class="kz ix">生成器</strong>的先决条件，会让你更好地理解今天的主题。如果你不知道什么是Iterables和Iterators，现在就去读它，然后回到这里。</p><p id="379e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">首先，我们将回顾一些理论，在本文的结尾，我们将看看生成器的真实用例。</p><h1 id="5c53" class="lu lv in bd lw lx ly lz ma mb mc md me kc mf kd mg kf mh kg mi ki mj kj mk ml bi translated">懒惰评估</h1><p id="ecba" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">让我们快速回顾一下<strong class="kz ix">懒评</strong>是什么意思，它的优点是什么。</p><p id="680d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">惰性求值</strong>的意思是将表达式的求值延迟到需要的时候。惰性评估有时被称为<strong class="kz ix">按需调用</strong>。</p><p id="dde4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">惰性评估可以:</p><ul class=""><li id="e2aa" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated">定义潜在的无限数据结构</li><li id="fa05" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated">通过避免不必要的计算来提高性能</li><li id="f44d" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated">为希望其元素可供公众访问的数据结构定制迭代行为</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="a128" class="lu lv in bd lw lx ly lz ma mb mc md me kc mf kd mg kf mh kg mi ki mj kj mk ml bi translated">发电机</h1><h2 id="b37a" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">什么是发电机</h2><p id="a739" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">我发现维基百科的定义非常准确，所以让我们看看它是怎么说的:</p><blockquote class="nr ns nt"><p id="b3e2" class="kx ky nu kz b la lb jx lc ld le ka lf nv lh li lj nw ll lm ln nx lp lq lr ls ig bi translated">在计算机科学中，生成器是一个可以用来控制循环迭代行为的例程。所有生成器也是迭代器。生成器与返回数组的函数非常相似，因为生成器有参数，可以被调用，并生成一系列值。但是，生成器一次生成一个值，而不是构建一个包含所有值的数组并一次返回所有值，这需要较少的内存并允许调用者立即开始处理前几个值。简而言之，生成器看起来像函数，但行为像迭代器。</p><p id="b1d4" class="kx ky nu kz b la lb jx lc ld le ka lf nv lh li lj nw ll lm ln nx lp lq lr ls ig bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Generator_(computer_programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Generator _(计算机编程)</a></p></blockquote><p id="f497" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">换句话说，生成器是类固醇上的迭代器。与迭代器相比，它接受参数，可以作为函数调用。</p><p id="ccdd" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">维基百科的引用没有提到的是，你不仅可以从生成器中获取值，还可以向生成器发送值。也就是说，<strong class="kz ix">生成器不仅是迭代器，还是观测器</strong>。</p><h2 id="4371" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">迭代协议</h2><p id="4d86" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">发电机符合<code class="fe ny nz oa ob b">Iterable</code>和<code class="fe ny nz oa ob b">Iterator</code>两种接口。这意味着调用生成器函数的结果是<code class="fe ny nz oa ob b">Iterable</code>和<code class="fe ny nz oa ob b">Iterator</code>，并使生成器成为<strong class="kz ix">数据生产者</strong>。</p><p id="10b9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">使用类型脚本，我们可以如下定义接口:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/bb0f836814fa263169b19474c21e06c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ExHIUg5jZNWbV880XcSZw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Iterator and Iterable interfaces</figcaption></figure><p id="7c6e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">关于<strong class="kz ix">迭代协议</strong>的更多信息，请参见<a class="ae lt" href="https://medium.com/@MelkorNemesis/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f" rel="noopener">上一篇文章</a>，在那里我详细讨论了它。</p><h2 id="f40d" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">观察者界面</h2><p id="8582" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">生成器遵循的另一个接口是<code class="fe ny nz oa ob b">Observer</code>接口。换句话说，这使得生成器成为数据消费者。当生成器暂停时，它们会等待输入。</p><blockquote class="oh"><p id="1282" class="oi oj in bd ok ol om on oo op oq ls dk translated">生成器每次点击<code class="fe ny nz oa ob b">yield</code>关键字时都会等待输入。</p></blockquote><p id="4900" class="pw-post-body-paragraph kx ky in kz b la or jx lc ld os ka lf lg ot li lj lk ou lm ln lo ov lq lr ls ig bi translated">有三种类型的发电机输入:</p><ul class=""><li id="f190" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">next(value?: any)</code> =向发电机发送一个值</li><li id="a57a" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">return(value?: any)</code> =终止发电机</li><li id="203f" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">throw(error)</code> =在生成器内部抛出异常</li></ul><p id="4121" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">使用类型脚本，我们可以如下定义接口:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/a3607004fd3721074ca9f207b7587c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrCH8m0tIwCGlQuWVu7fCw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Observer interface</figcaption></figure><h2 id="400c" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">句法</h2><p id="31a0" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated"><strong class="kz ix">发电机功能</strong>返回一个<strong class="kz ix">发电机</strong>。对于如何创建生成器函数，有四个选项:</p><p id="8cd4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">发电机功能声明</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/b40f4f5776f1331882904022dc29b768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyKJJZKWmaUR-8YVu5M8Bw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator function declaration</figcaption></figure><p id="1168" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">生成器函数表达式</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/417ff8300f29777a526fded19ed83d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDofPlcxowFsfGwE2Uynqg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator function expression</figcaption></figure><p id="13b6" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">生成器方法(对象文字)</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/f5a9fce9b7f644d1e59555788d566479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kQjHUtzuRrXupzTwB29wA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator method (object literal)</figcaption></figure><p id="3ab6" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">生成器方法(类)</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/3e42ea3d2180956aa87baf4cb1dbd57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orPaOXUlnvfmw20Ao_0BFA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator method (class)</figcaption></figure><p id="5ede" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">注意星号(<code class="fe ny nz oa ob b">*</code>)的位置没有区别。有鉴于此，以下所有内容都是等效的:</p><ul class=""><li id="c0d8" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">function* generator() {}</code></li><li id="7c87" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">function * generator() {}</code></li><li id="6c61" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">function *generator() {}</code></li></ul><p id="2ce4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">发电机功能与发电机</strong></p><p id="9ba4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果我们检查<code class="fe ny nz oa ob b">generator.__proto__</code>和<code class="fe ny nz oa ob b">gen.__proto__</code>，我们可以看到<code class="fe ny nz oa ob b">generator</code>是一个<code class="fe ny nz oa ob b">GeneratorFunction</code>(构造函数)，它编排了一个新的<code class="fe ny nz oa ob b">Generator</code>对象的创建。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/e520897384604066a621fbc290b5f730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLi8I7a6vMiJ4aPvj7SMrA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator function vs. generator</figcaption></figure><h2 id="0cd5" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">动态生成函数创建</h2><p id="0830" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">您也可以动态声明一个生成器函数，尽管我建议您永远不要这样做。我提到这一点只是为了完整。因为我认为这是一种不好的做法，所以我就不再赘述了。</p><p id="dc1a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">你可以在这里阅读更多关于这个话题的内容<a class="ae lt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="cd91" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated"><code class="fe ny nz oa ob b">Run To The Next yield</code></h2><p id="96e0" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">常规功能遵循所谓的<strong class="kz ix">运行到完成</strong>模型。要退出常规功能，您必须:</p><ul class=""><li id="3722" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">return</code>从它</li><li id="b26e" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">throw</code>一个错误</li></ul><p id="cee2" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果一个函数没有<code class="fe ny nz oa ob b">return</code>语句，该函数默认返回<code class="fe ny nz oa ob b">undefined</code>。</p><p id="29b3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果您再次调用该函数，它将从头开始，并一直同步执行到退出点。</p><p id="ed74" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">对于常规函数，您通过参数传递中的值<strong class="kz ix">，通过<code class="fe ny nz oa ob b">return</code>语句传递</strong>中的值<strong class="kz ix">。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="6062" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">发电机</strong>另一方面<strong class="kz ix">可以中途停止</strong>和<strong class="kz ix">暂停自身</strong>。</p><blockquote class="oh"><p id="0b79" class="oi oj in bd ok ol om on oo op oq ls dk translated">产量是每台发电机的核心和灵魂。</p></blockquote><p id="028b" class="pw-post-body-paragraph kx ky in kz b la or jx lc ld os ka lf lg ot li lj lk ou lm ln lo ov lq lr ls ig bi translated">这种暂停机制使<strong class="kz ix">双向信息在发生器及其控制机制之间传递</strong>。每次<code class="fe ny nz oa ob b">yield</code>你发送消息<strong class="kz ix">到</strong>，每次重启你发送消息<strong class="kz ix">到</strong>。</p><blockquote class="oh"><p id="2d3f" class="oi oj in bd ok ol om on oo op oq ls dk translated">生成器将控制权交还给调度程序，以便它可以运行另一个任务。</p></blockquote><p id="3605" class="pw-post-body-paragraph kx ky in kz b la or jx lc ld os ka lf lg ot li lj lk ou lm ln lo ov lq lr ls ig bi translated">我将在本文后面讨论协作式多任务处理时详细阐述这个主题。</p><h2 id="ba5c" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">从生成器中提取值</h2><p id="bef8" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">通过将生成器用作迭代器(和/或可迭代的),您可以从中提取值。</p><p id="c959" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">生成器使用关键字<code class="fe ny nz oa ob b">yield</code>生成一系列值。控制机制(在这种情况下只有我们)可以使用生成器上的<code class="fe ny nz oa ob b">next()</code>方法访问下一个序列值。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/8ba5c9881204822cc361eaa50fd7dd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDyEImRebkuvvvug6F_M_A.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Pulling values from a generator, with a return statement</figcaption></figure><p id="d084" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">之前的生成器有一个显式的<code class="fe ny nz oa ob b">return</code>。注意，当<code class="fe ny nz oa ob b">done</code>为<code class="fe ny nz oa ob b">true</code>时，大多数使用iterables的构造都会忽略<code class="fe ny nz oa ob b">value</code>。<code class="fe ny nz oa ob b">yield*</code>运算符确实考虑了返回值，我们稍后会看到这一点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/10a8e173c9b4b2dad5ec5eb7668f66cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DE23S8w-PgY1_lEEJgu1lQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Pulling values from a generator, without return statement</figcaption></figure><p id="70d4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果不在生成器中使用<code class="fe ny nz oa ob b">return</code>，它会隐式返回<code class="fe ny nz oa ob b">undefined</code>，并且再调用一次<code class="fe ny nz oa ob b">next()</code>来消耗迭代器。这是因为生成器等待传回一个值，在该值中重新启动并完成生成器。看完下一节你就明白了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="8688" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">因为生成器对象是可迭代的，所以您可以将它们与期望可迭代的ES6语言结构一起使用:</p><ul class=""><li id="4c6b" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated"><code class="fe ny nz oa ob b"><strong class="kz ix">for ... of</strong></code>(循环)</li><li id="dd25" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b"><strong class="kz ix">...</strong></code>(传播算子)</li><li id="cb30" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">const <strong class="kz ix">[a, b, ..]</strong> = iterable;</code>(破坏任务)</li><li id="86e6" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b"><strong class="kz ix">yield*</strong></code>(发电机委托)</li></ul><p id="dfe3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">参见<a class="ae lt" href="https://medium.com/javascript-in-plain-english/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f" rel="noopener">上一篇关于迭代器和iterable的文章</a>了解更多信息。</p><h2 id="47b3" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">将值推入生成器</h2><p id="6ffe" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">前面我说过生成器符合<code class="fe ny nz oa ob b">Observer</code>接口。生成器每次点击<code class="fe ny nz oa ob b">yield</code>关键字时都会等待输入。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/0d23aeffbd4fac730be17a3a985846fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDTloUPby8pMCXNaPj-2Og.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Pushing value to a generator</figcaption></figure><p id="c774" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">调用<code class="fe ny nz oa ob b">generator()</code>只会创建一个生成器对象。要真正启动发电机并在第一次<code class="fe ny nz oa ob b">yield</code>暂停，您必须调用<code class="fe ny nz oa ob b">next()</code>。只有这样，它才准备好输入。</p><p id="baaa" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">牢记</strong> <code class="fe ny nz oa ob b"><strong class="kz ix">next()</strong></code> <strong class="kz ix">方法在发电机上是不对称的</strong>。当被调用时，它既向当前挂起的<code class="fe ny nz oa ob b">yield</code>发送一个值，同时又返回后面的<code class="fe ny nz oa ob b">yield</code>的<code class="fe ny nz oa ob b">{ value, done }</code>对。</p><p id="4e92" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">当发生器在<code class="fe ny nz oa ob b">yield</code>处暂停时，调用<code class="fe ny nz oa ob b">next(value)</code>向发生器传递一个值。传递的<code class="fe ny nz oa ob b">value</code>然后在适当的位置替换<code class="fe ny nz oa ob b">yield</code>。所以当生成器运行到第<code class="fe ny nz oa ob b">(C)</code>行时，实际上与您写的一样:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/efdb6154d373314f8a23d8f8518c3415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPoMwtB39EA58Ce-ltw2yA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Pushing value to a generator, yields replaced</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="8b9f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><code class="fe ny nz oa ob b">{ value, done }</code>对被称为<code class="fe ny nz oa ob b">IteratorResult</code>。更多信息见<a class="ae lt" href="https://medium.com/javascript-in-plain-english/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f" rel="noopener">上一篇文章</a>。</p><h2 id="0100" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">发电机委托</h2><p id="2fd0" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">有时你会意识到你的生成器函数太长了。你想把一堆代码提取到不同的生成器中。此外，您需要一种方法来调用这个提取的生成器，并确保从原始生成器生成的所有值仍然被生成，但这一次是从子例程生成的。这就是<code class="fe ny nz oa ob b">yield*</code>介入的地方。</p><p id="f844" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">考虑下面的例子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/3f893d9f2bb18c8a1ac10131f7110a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCGMYAh8HSsPwTpMQkn0Wg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator delegation, before refactoring</figcaption></figure><p id="6778" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">假设您想将线<code class="fe ny nz oa ob b">(A)</code>和<code class="fe ny nz oa ob b">(B)</code>提取到另一个发电机。这不成问题，让我们创建一个<code class="fe ny nz oa ob b">subGenerator</code>生成器函数并将代码放在那里。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/8a361e105eb95cd91656210de3bb80eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ph74znCB6CO-12JGKjIXag.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator delegation, re-yielding values from a subroutine</figcaption></figure><p id="ec8f" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在我们需要迭代新提取的生成器，并在第<code class="fe ny nz oa ob b">(X)</code>行产生我们从中提取的值。那很好，但是…</p><p id="1cff" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们可以更进一步。我们可以用<code class="fe ny nz oa ob b">yield*</code>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/7435b41b22c0d347e5f02ebde11fda7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2xxQKS6gaoQALkZwioJsw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator delegation, using yield*</figcaption></figure><p id="33c4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><code class="fe ny nz oa ob b"><strong class="kz ix">yield*</strong></code> <strong class="kz ix">在进入下一条生产线之前，同步排空传入的发电机。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><blockquote class="oh"><p id="bd57" class="oi oj in bd ok ol ow ox oy oz pa ls dk translated">当用<code class="fe ny nz oa ob b">yield*</code>调用子程序时，你可以捕获从生成器返回的值。</p></blockquote><p id="e393" class="pw-post-body-paragraph kx ky in kz b la or jx lc ld os ka lf lg ot li lj lk ou lm ln lo ov lq lr ls ig bi translated">前面我提到过，当<code class="fe ny nz oa ob b">done</code>是<code class="fe ny nz oa ob b">true</code>时，大多数使用iterables的构造忽略了<code class="fe ny nz oa ob b">value</code>，而<code class="fe ny nz oa ob b">yield*</code>是一个例外，实际上确实考虑到了这一点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/632019456f815da363e69cce6767001b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1SNsXkp1qL_BN1BVC3_DA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator delegation, returning from yield*</figcaption></figure><p id="3bbb" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">当<code class="fe ny nz oa ob b">(A)</code>线上的发电机<code class="fe ny nz oa ob b">subGenerator</code>被消耗后，返回<code class="fe ny nz oa ob b">3</code>。然后在<code class="fe ny nz oa ob b">number</code>变量中捕获。请参见<strong class="kz ix">示例/ DOM事件处理程序</strong>部分，了解这为什么有用。</p><h2 id="43f1" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">清除</h2><p id="8307" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">类似于迭代器，当突然完成时，您可能希望执行清理。为了举例说明什么是突然完成，假设您有一个打开文本文件的生成器。您对生成器进行循环，该生成器逐行向消费者生成文本文件。当没有更多的行产生时，生成器关闭文件。</p><p id="210a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">但是如果你不循环所有的行呢？这将使文件描述符挂起，永远不会关闭。让我们用一个简单的例子来证明这一点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/d079d62685c76725a7e021468479b4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WQ49OhsjfQVqEkS5beQPg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator cleanup after abrupt completion</figcaption></figure><p id="28a2" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">为了能够捕捉第<code class="fe ny nz oa ob b">(A)</code>行的突然结束，您将生成器内部的代码包装到一个<code class="fe ny nz oa ob b">try/finally</code>块中。当在<code class="fe ny nz oa ob b">try</code>块中突然完成时，代码继续在<code class="fe ny nz oa ob b">finally</code>块的第<code class="fe ny nz oa ob b">(B)</code>行执行，在这里你可以执行任何清除。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="92ce" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">请随意通读<a class="ae lt" href="https://medium.com/javascript-in-plain-english/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f" rel="noopener">上一篇文章</a>，该文章也描述了什么构造了没有被消耗的封闭迭代器，或者什么可以提前终止迭代。</p><h2 id="d89b" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">抛出异常并返回值</h2><p id="a13c" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">您不仅可以向生成器传递一个值，还可以让生成器<strong class="kz ix">返回值</strong>或<strong class="kz ix">抛出一个异常</strong>。</p><p id="e13a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">除了<code class="fe ny nz oa ob b">next()</code>方法，生成器上还有另外两种方法可用，来自<code class="fe ny nz oa ob b">Observer</code>接口。</p><ul class=""><li id="eec5" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">return()</code></li><li id="e220" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">throw()</code></li></ul><p id="2ac9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">请注意，只有当您能够控制生成器的前进方式或者使用运行生成器的协程时，您才能使用这些方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="70fe" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">返回值</strong></p><p id="f22a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">当你调用<code class="fe ny nz oa ob b">gen.return(value?)</code>时，发生器不会恢复它正在做的任何事情。它做两件事:</p><ol class=""><li id="efc2" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls pb mx my mz bi translated">执行<code class="fe ny nz oa ob b">finally</code>块(如果存在)</li><li id="dbf4" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">向调用者返回一个<code class="fe ny nz oa ob b">IteratorResult</code>:<code class="fe ny nz oa ob b">{ done: true, value: &lt;undefined|any&gt; }</code></li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/baba698eb8a0ec0b82dc0f519bea7869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QE7lfodLJNF7qoe0FD2T9Q.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator: returning a value</figcaption></figure><p id="47f1" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><code class="fe ny nz oa ob b">gen.next()</code>启动发电机。发电机停在<code class="fe ny nz oa ob b">(A)</code>行。第<code class="fe ny nz oa ob b">(B)</code>行上的<code class="fe ny nz oa ob b">gen.return(false)</code>完成生成器，继续到第<code class="fe ny nz oa ob b">(C)</code>行的<code class="fe ny nz oa ob b">finally</code>阻塞，并将<code class="fe ny nz oa ob b">IteratorResult</code>，更具体地说是<code class="fe ny nz oa ob b">{ done: true, value: false }</code>返回给调用者。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="0d57" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">抛出异常</strong></p><p id="77b9" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">当您调用<code class="fe ny nz oa ob b">gen.throw(err)</code>时，无论发生器正在做什么，它也不会恢复。它做三件事:</p><ol class=""><li id="51c3" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls pb mx my mz bi translated">执行<code class="fe ny nz oa ob b">catch</code>程序块(如果存在)</li><li id="2e98" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">执行<code class="fe ny nz oa ob b">finally</code>程序块(如果存在)</li><li id="abe3" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">向调用者返回一个<code class="fe ny nz oa ob b">IteratorResult</code>:<code class="fe ny nz oa ob b">{ done: true, value: undefined }</code></li></ol><p id="5094" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">例1 </strong>:捕捉生成器内部抛出的异常</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/e210c31673ac5485dae4a23b20e45088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_GKfc5lJKsFLHhVZmKVyw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator: catching a thrown exception inside the generator</figcaption></figure><ol class=""><li id="dc34" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls pb mx my mz bi translated"><code class="fe ny nz oa ob b">gen.next()</code>启动发电机。</li><li id="6f99" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">发电机停在<code class="fe ny nz oa ob b">(A)</code>线上。</li><li id="b50d" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">第<code class="fe ny nz oa ob b">(B)</code>行的<code class="fe ny nz oa ob b">gen.throw(new Error('Invalid firstname'))</code>指示生成器在当前暂停的地方抛出一个错误，这是第<code class="fe ny nz oa ob b">(A)</code>行。</li><li id="47c6" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">在线<code class="fe ny nz oa ob b">(C)</code>上的发生器内部捕捉到异常。</li><li id="0e90" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">然后执行<code class="fe ny nz oa ob b">(D)</code>线上的<code class="fe ny nz oa ob b">finally</code>块。发电机返回<code class="fe ny nz oa ob b">IteratorResult</code>，特别是<code class="fe ny nz oa ob b">{ done: true, value: undefined }</code>。</li></ol><p id="c315" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">示例2 </strong>:在生成器外捕获抛出异常</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/7bd016e3e7e563acb77275a9853477cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0s8FK-Cy0uCQ0i8YiS0kUA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator: catching a thrown exception outside the generator</figcaption></figure><ol class=""><li id="e857" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls pb mx my mz bi translated"><code class="fe ny nz oa ob b">gen.next()</code>启动发电机。</li><li id="2e07" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">发电机停在<code class="fe ny nz oa ob b">(A)</code>线。</li><li id="fd73" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated"><code class="fe ny nz oa ob b">gen.throw(new Error('Invalid firstname'))</code>在线<code class="fe ny nz oa ob b">(B)</code>上指示生成器在当前暂停的地方抛出错误，这是一条线<code class="fe ny nz oa ob b">(A)</code>。</li><li id="8d55" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated">发电机内部没有<code class="fe ny nz oa ob b">catch</code>块，所以发电机跳到<code class="fe ny nz oa ob b">C)</code>线上的<code class="fe ny nz oa ob b">finally</code>块进行清理。</li><li id="0693" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls pb mx my mz bi translated"><strong class="kz ix">错误向呼叫者冒泡。</strong>线上捕捉到异常<code class="fe ny nz oa ob b">(D)</code>。</li></ol><p id="aa64" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">请注意<code class="fe ny nz oa ob b">(B)</code>线上没有<code class="fe ny nz oa ob b">IteratorResult</code>返回给来电者。</p><h2 id="5aae" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">限制</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/2dfa6b272778d8dcc9f951b2f8e7be89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZslLAJa9KuvRQAxd6Td1fQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator function with SyntaxError</figcaption></figure><p id="8805" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我见过很多人问同样的问题:<em class="nu">我如何在回调中使用收益率？</em>事实是，你不能。</p><p id="2263" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">您只能直接在生成器功能内部使用<code class="fe ny nz oa ob b">yield</code>。如果你仔细观察我们传递给<code class="fe ny nz oa ob b">setTimeout</code>的回调函数，你会发现它只是一个箭头函数，而不是一个生成器函数。为此，非发生器功能内部的<code class="fe ny nz oa ob b">yield</code>导致<code class="fe ny nz oa ob b">SyntaxError</code>。</p><p id="ccb0" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">以上示例可以通过<code class="fe ny nz oa ob b">delay()</code>功能和协同多任务来修复。我们稍后将讨论协作多任务处理。固定生成器函数如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/d23cff18954a14c369b6d205231f6a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eREr6jY3NamQoVOmYaDgfA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">Generator function with delay utility</figcaption></figure><p id="cb80" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">参见<strong class="kz ix">示例</strong> / <strong class="kz ix">用于处理承诺的简单协同程序(又名异步/等待)</strong>中的解决方案。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="95c4" class="lu lv in bd lw lx ly lz ma mb mc md me kc mf kd mg kf mh kg mi ki mj kj mk ml bi translated">协同程序</h1><p id="8e89" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">您可以使用生成器的事情之一是coroutines。例如，它们允许您在JavaScript中实现<strong class="kz ix">异步/等待</strong>行为。据我所知，这实际上是如何在JavaScript中实现<strong class="kz ix">异步/等待</strong>的。</p><p id="d0e3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">首先，让我们看看维基百科对死因有什么看法。我再次发现维基百科的描述非常准确。</p><blockquote class="nr ns nt"><p id="8067" class="kx ky nu kz b la lb jx lc ld le ka lf nv lh li lj nw ll lm ln nx lp lq lr ls ig bi translated">协程是计算机程序组件，它通过允许暂停和恢复执行来概括用于非抢占式多任务处理的子例程。协程非常适合于实现常见的程序组件，如协作任务、异常、事件循环、迭代器、无限列表和管道。</p><p id="fe26" class="kx ky nu kz b la lb jx lc ld le ka lf nv lh li lj nw ll lm ln nx lp lq lr ls ig bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Coroutine</a></p></blockquote><p id="7bb7" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">为此，在JavaScript上下文中，协程是围绕着生成器的包装器，用于控制生成器的执行。</p><blockquote class="nr ns nt"><p id="9ceb" class="kx ky nu kz b la lb jx lc ld le ka lf nv lh li lj nw ll lm ln nx lp lq lr ls ig bi translated">协作式多任务处理，也称为非抢占式多任务处理，是计算机多任务处理的一种风格，操作系统从不启动从一个正在运行的进程到另一个进程的上下文切换。相反，进程会定期或在空闲或逻辑阻塞时主动让出控制权，以使多个应用程序能够并发运行。这种类型的多任务被称为“合作的”，因为所有的程序必须合作，整个调度方案才能工作。</p><p id="75f2" class="kx ky nu kz b la lb jx lc ld le ka lf nv lh li lj nw ll lm ln nx lp lq lr ls ig bi translated">【https://en.wikipedia.org/wiki/Cooperative_multitasking T2】号</p></blockquote><p id="0e48" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">换句话说，当JavaScript生成器等待一个任务完成时，比如一个异步请求，它可以将控制权交还给调度程序，以便运行另一个任务。这样，多个进程可以并发运行。</p><h2 id="c636" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">并发性与并行性</h2><p id="4412" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">并发意味着应用程序同时在多个任务上取得进展。</p><p id="1aef" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">并行性意味着应用程序将其任务分解成更小的子任务，这些子任务可以在同一时间并行处理。</p><blockquote class="nr ns nt"><p id="1c0c" class="kx ky nu kz b la lb jx lc ld le ka lf nv lh li lj nw ll lm ln nx lp lq lr ls ig bi translated">并发是指<strong class="kz ix">同时处理很多事情</strong>。并行就是<strong class="kz ix">同时做很多事情</strong>。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="a281" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">礼貌地摘自<a class="pc pd ep" href="https://medium.com/u/5ee12e939c80?source=post_page-----f9eaa517f969--------------------------------" rel="noopener" target="_blank">马德哈万·纳加拉詹</a>的精彩文章<a class="ae lt" href="https://medium.com/@itIsMadhavan/concurrency-vs-parallelism-a-brief-review-b337c8dac350" rel="noopener"> <strong class="kz ix">并发与并行——简评</strong> </a> <strong class="kz ix">。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="f931" class="lu lv in bd lw lx ly lz ma mb mc md me kc mf kd mg kf mh kg mi ki mj kj mk ml bi translated">表演时间</h1><p id="8baf" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">理论说够了，让我们把手弄脏一点，看看有什么大惊小怪的。让我们从简单的开始，一点一点地增加例子的复杂性。</p><p id="8d89" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在<a class="ae lt" href="https://medium.com/javascript-in-plain-english/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f" rel="noopener">上一篇文章</a>中，一些例子也被实现为迭代器。您可以随意查看那里的示例，并比较用生成器实现相同的行为有多容易。</p><h2 id="ead5" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">范围迭代器</h2><p id="a2e4" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">首先，一个简单的范围迭代器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript range Iterator</figcaption></figure><h2 id="7076" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">无限序列迭代器</h2><p id="486f" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">注意这个例子中通常不被认可的<code class="fe ny nz oa ob b">while (true)</code>是如何变得有意义的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript infinite Iterator</figcaption></figure><h2 id="ffd3" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">结束迭代器</h2><p id="498a" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">这段代码演示了突然完成后的清理，在本例中是一个<code class="fe ny nz oa ob b">break</code>语句。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript generator cleanup after abrupt completion</figcaption></figure><h2 id="3f47" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">对正则表达式匹配进行循环</h2><p id="f03c" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">更舒适的正则表达式匹配提取。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript generator for regular expressions</figcaption></figure><h2 id="68d9" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">Zip实用程序</h2><p id="331c" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">Zip是一个迭代器，它聚集了来自每个可迭代对象的元素。</p><p id="2ef4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">它返回元组的迭代器，其中第<em class="nu"> i </em>个元组包含来自每个参数序列或可迭代对象的第<em class="nu"> i </em>个元素。当最短的输入iterable用尽时，迭代器停止。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript Zip utility</figcaption></figure><h2 id="3121" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">组合子</h2><p id="489c" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">组合子是组合现有的可重复项来创建新的可重复项的函数。可重复的组合。</p><p id="2d2d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我举了两个例子。他们证明了:</p><ul class=""><li id="d5d8" class="mr ms in kz b la lb ld le lg mt lk mu lo mv ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">filter</code>和<code class="fe ny nz oa ob b">map</code>在迭代上操作</li><li id="d84f" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">cycle</code>从有限序列生成无限序列的实用程序</li><li id="501a" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><code class="fe ny nz oa ob b">take</code>采用有限或无限序列的<code class="fe ny nz oa ob b">n</code>元素的实用程序</li></ul><p id="ab06" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">例1: </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript generator combinators — map and filter</figcaption></figure><p id="3620" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><strong class="kz ix">例2: </strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript generator combinators — cycle and take</figcaption></figure><p id="40b5" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我想在例子中保持简单，所以我使用了高阶函数(例如<code class="fe ny nz oa ob b">filter</code>函数返回另一个函数)。您通常可能会做的是一个带有两个参数的curried <code class="fe ny nz oa ob b">filter</code>函数。</p><p id="f943" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">另外，注意我使用的是<code class="fe ny nz oa ob b">pipe</code>。通常我更喜欢<code class="fe ny nz oa ob b">compose</code>，但是当使用组合函数时，感觉更自然。纯粹是喜好问题。</p><h2 id="fdee" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">处理承诺的简单协程(又名异步/等待)</h2><p id="08a0" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">所以你知道什么是协程，但是你以前没见过。这个例子展示了处理产生的<code class="fe ny nz oa ob b">Promise</code>的协程的实现。</p><p id="7525" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这使得代码看起来是同步的，并且更容易推理。此外，你能够轻松避免一个<strong class="kz ix">承诺地狱</strong>。</p><p id="ec75" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这个例子相当简单。我只想演示生成器和协程之间双向消息传递的基本思想。为了更容易定位和理解，我将注释直接放在源代码中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pe pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript Coroutine for handling Promises</figcaption></figure><p id="bb67" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">最重要的代码块如下所示。我们必须检查我们是否收到了任何<code class="fe ny nz oa ob b">value</code>，因为<code class="fe ny nz oa ob b">yield</code>隐含地产生了<code class="fe ny nz oa ob b">undefined</code>。如果接收到的值是可解析的(a <code class="fe ny nz oa ob b">Promise</code>)，我们将在获得解析的值后重启生成器。或者如果<code class="fe ny nz oa ob b">Promise</code>被拒绝，则将<code class="fe ny nz oa ob b">Error</code>传播到发电机。</p><p id="9300" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果值是<code class="fe ny nz oa ob b">undefined</code>或者不是一个Thenable，我们就把它反馈给生成器。</p><p id="35f8" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们也不能忘记在<code class="fe ny nz oa ob b">handleYieldedValue()</code>函数中包装<code class="fe ny nz oa ob b">iterator.next()</code>，因为像我之前提到的那样<code class="fe ny nz oa ob b">iterator.next()</code>方法是<strong class="kz ix">非对称的</strong>并返回后续的<code class="fe ny nz oa ob b">IteratorResult</code>给我们处理。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/9530e3c3b6935c0cdff35da220141969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HR6GD0jthJn3jS1KcuWyoA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk">JavaScript Promise Coroutine handling</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="efac" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在<a class="pc pd ep" href="https://medium.com/u/6849951de65c?source=post_page-----f9eaa517f969--------------------------------" rel="noopener" target="_blank">阅读更多关于<strong class="kz ix">无极地狱</strong>罗纳德陈</a>的伟大文章<strong class="kz ix">如何逃离无极地狱</strong>。</p><h2 id="9e2e" class="ng lv in bd lw nh ni dn ma nj nk dp me lg nl nm mg lk nn no mi lo np nq mk it bi translated">DOM事件处理程序</h2><p id="5f2f" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">很久以前，我看到一篇文章，展示了用生成器处理DOM事件的可能性。</p><p id="83ff" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这个解决方案背后的思想是<strong class="kz ix">您将所有的DOM事件提供给生成器</strong>，它反过来检查它当前是否对这样的事件感兴趣。那么它要么相应地采取行动，要么忽略该事件。</p><p id="808a" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我从未在作品中使用过这个，但我喜欢这个想法。这个例子很好地演示了生成器委托(<code class="fe ny nz oa ob b">yield*</code>)的使用和从生成器返回值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pg pf l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk">Handling DOM Events With Generators</figcaption></figure><h1 id="d3b1" class="lu lv in bd lw lx ly lz ma mb mc md me kc mf kd mg kf mh kg mi ki mj kj mk ml bi translated">在你离开之前</h1><p id="8047" class="pw-post-body-paragraph kx ky in kz b la mm jx lc ld mn ka lf lg mo li lj lk mp lm ln lo mq lq lr ls ig bi translated">如果你想不出如何在你的项目中使用发电机，不要难过。并非每个项目都需要发电机。它们是非常特殊的构造，解决特定领域的问题。但是他们处理得很好。</p><p id="b910" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果你是Redux用户，看看<a class="ae lt" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kz ix">Redux Saga</strong></a><strong class="kz ix">。这是一个基于生成器的处理Redux副作用的流行库。</strong></p><blockquote class="oh"><p id="654c" class="oi oj in bd ok ol om on oo op oq ls dk translated">当处理无限值序列时，生成器是一个很好的工具。</p></blockquote><p id="b7bc" class="pw-post-body-paragraph kx ky in kz b la or jx lc ld os ka lf lg ot li lj lk ou lm ln lo ov lq lr ls ig bi translated">我必须学习不同的编程语言来完全理解生成器的用例。比如<strong class="kz ix">哈斯克尔</strong>。Haskell的核心是能够对无限的值序列进行操作。而且在语言中用的很重，你基本上逃不掉。</p><p id="6914" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">下次见。<strong class="kz ix">🐺阿尔法，完毕。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="4fee" class="lu lv in bd lw lx ly lz ma mb mc md me kc mf kd mg kf mh kg mi ki mj kj mk ml bi translated">资源</h1><ul class=""><li id="096c" class="mr ms in kz b la mm ld mn lg ph lk pi lo pj ls mw mx my mz bi translated"><a class="ae lt" href="https://exploringjs.com/es6/ch_generators.html" rel="noopener ugc nofollow" target="_blank">https://exploringjs.com/es6/ch_generators.html</a></li><li id="78d1" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://hacks.mozilla.org/2015/07/es6-in-depth-generators-continued/" rel="noopener ugc nofollow" target="_blank">https://hacks . Mozilla . org/2015/07/es6-深入-生成器-续/ </a></li><li id="5d9d" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Generator</a></li><li id="ffcb" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5" rel="noopener" target="_blank">https://code burst . io/understanding-generators-in-es6-JavaScript-with-examples-6728834016 D5</a></li><li id="6dae" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://medium.com/dailyjs/a-simple-guide-to-understanding-javascript-es6-generators-d1c350551950" rel="noopener">https://medium . com/daily js/a-simple-guide-to-understanding-JavaScript-es6-generators-d1c 350551950</a></li><li id="2eec" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://www.pancompany.com/blog/2020/6/5/does-javascript-need-generators" rel="noopener ugc nofollow" target="_blank">https://www . pan company . com/blog/2020/6/5/does-JavaScript-need-generators</a></li><li id="f1e5" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://davidwalsh.name/es6-generators" rel="noopener ugc nofollow" target="_blank">https://davidwalsh.name/es6-generators</a></li><li id="cf21" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://rileygelwicks.gitbooks.io/you-dont-know-js/content/async%20&amp;%20performance/apB.html" rel="noopener ugc nofollow" target="_blank">https://rileygelwicks . git books . io/you-dont-know-js/content/async % 20&amp;% 20 performance/APB . html</a></li><li id="ba4a" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://www.linkedin.com/pulse/using-javascript-generators-yield-promises-vladim%C3%ADr-gorej/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/using-JavaScript-generators-yield-promises-vladim % C3 % ADr-gorej/</a></li><li id="839d" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://www.aaron-powell.com/posts/2014-01-18-calling-up-callbacks-with-yield/" rel="noopener ugc nofollow" target="_blank">https://www . aaron-Powell . com/posts/2014-01-18-calling-up-callbacks-with-yield/</a></li><li id="f365" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://github.com/isRuslan/learn-generators/tree/master/exercises" rel="noopener ugc nofollow" target="_blank">https://github . com/isRuslan/learn-generators/tree/master/exercises</a></li><li id="950e" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/generator function</a></li><li id="96b5" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://hackernoon.com/javascript-es6-you-dont-really-need-to-learn-generators-96aa2e9114fa" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/JavaScript-es6-you-don-t-really-need-to-learn-generators-96aa 2e 9114 fa</a></li><li id="41da" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://medium.com/javascript-scene/the-hidden-power-of-es6-generators-observable-async-flow-control-cfa4c7f31435" rel="noopener">https://media . com/JavaScript-scene/the-hidden-power-of-es6-generators-observated-async-flow-control-CFA 4c 7f 31435</a></li><li id="066c" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://gist.github.com/elclanrs/45800747e7c2c126594fa1257688bf85" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/elclanrs/45800747 e7c 1c 126594 fa 1257688 BF 85</a></li><li id="2071" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://whistlr.info/2020/async-generators-input/" rel="noopener ugc nofollow" target="_blank">https://whistlr.info/2020/async-generators-input/</a></li><li id="0f50" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://www.smashingmagazine.com/2018/01/rise-state-machines/" rel="noopener ugc nofollow" target="_blank">https://www . smashingmagazine . com/2018/01/rise-state-machines/</a></li><li id="d428" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://dev.to/rfornal/use-cases-for-javascript-generators-1npc" rel="noopener ugc nofollow" target="_blank">https://dev . to/rfornar/JavaScript用例生成器-1npc </a></li><li id="0a7e" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cooperative_multitasking</a></li><li id="b8d6" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Coroutine</a></li><li id="1d18" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://medium.com/@itIsMadhavan/concurrency-vs-parallelism-a-brief-review-b337c8dac350" rel="noopener">https://media . com/@ itimadhavan/concurrency-vs-parallelism-a-brief-review-b 337 c8 DAC 350</a></li><li id="b247" class="mr ms in kz b la na ld nb lg nc lk nd lo ne ls mw mx my mz bi translated"><a class="ae lt" href="https://docs.python.org/3/library/functions.html#zip" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/functions.html#zip</a></li></ul></div></div>    
</body>
</html>