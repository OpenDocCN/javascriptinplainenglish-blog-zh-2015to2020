<html>
<head>
<title>Can You Build Web Components With Svelte?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可以用Svelte构建Web组件吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/can-you-build-web-components-with-svelte-3c8bc3c1cfd8?source=collection_archive---------0-----------------------#2020-10-20">https://javascript.plainenglish.io/can-you-build-web-components-with-svelte-3c8bc3c1cfd8?source=collection_archive---------0-----------------------#2020-10-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="19f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最近看到了Svelte，因为我听到了很多关于它的消息，很好奇它如何与Vue相抗衡，我几乎所有的前端工作都使用Vue。特别是，我很好奇它是否更适合构建web组件，因为与Vue相比，它似乎有一些主要优势。我决定写这篇文章，因为我认为Svelte可能是构建web组件的完美框架，但目前有一些事情阻碍了它的发展，如果您正在考虑使用它，在您决定使用哪个框架之前，您应该了解它们以及可能的解决方法。</p><p id="fd1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">理论上，你需要做的就是把你现有的苗条应用程序转换成一个网络组件，在你的。svelte文件，并启用编译器中的<code class="fe ki kj kk kl b">customElement: true</code>选项。就是这样！编译完成后，您需要做的就是包含构建的包，然后您就可以开始使用全新的web组件了。</p><p id="0ff1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这看起来太容易了，那么问题从哪里开始呢？和往常一样,“Hello World”按预期工作，但是一旦你尝试做其他事情，你就开始遇到问题了。我会在这里列出我到目前为止遇到的所有问题，包括任何解决方法，我会尽可能地链接到相关的Github问题。</p></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h1 id="b359" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">您必须标记您使用的每个组件！</h1><p id="f9d2" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated"><a class="ae lw" href="https://github.com/sveltejs/svelte/issues/3594" rel="noopener ugc nofollow" target="_blank">https://github.com/sveltejs/svelte/issues/3594</a></p><p id="b11b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，您已经完成了“Hello World”web组件，并想开始做一些更高级的东西，您已经创建了另一个苗条的组件。你不想把它作为一个web组件导出，你只想在你的主组件内部使用它，但是那样不行。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="6128" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="9fd3" class="mf ku in kl b gy mk mh l mi mj">&lt;script&gt;<br/>  import OtherComponent from './OtherComponent.svelte';<br/>&lt;/script&gt;</span><span id="ec8f" class="mf ku in kl b gy mk mh l mi mj">&lt;OtherComponent /&gt;</span></pre><p id="f94e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个单独的文件中，我们有:</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="dbab" class="mf ku in kl b gy mg mh l mi mj">// OtherComponent.svelte</span><span id="faf6" class="mf ku in kl b gy mk mh l mi mj">&lt;p&gt;Hello World!&lt;/p&gt;</span></pre><p id="aaec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构建良好，但当您尝试使用它时:</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="d0de" class="mf ku in kl b gy mg mh l mi mj">TypeError: new.target does not define a custom element</span></pre><p id="3f8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决这个问题的方法是在你使用的每个组件中添加<code class="fe ki kj kk kl b">&lt;svelte:options tag="some-name"&gt;</code>。这迫使你从代码中使用的每一个纤细的元素中创建一个web组件。</p><figure class="lx ly lz ma gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ml"><img src="../Images/68b2277799068db9bff5214a94627fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0adFgH4g6F9Aa9eSXvG7g.jpeg"/></div></div></figure><p id="fce4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，看起来我们可以接受…我们只是添加了一个我们从未使用过的标签名。虽然这对于我们自己的组件来说很好，但是尽量使用任何苗条的组件库。它们没有为每个单独的组件指定标签名，所以你不能使用它。羞耻:(</p><p id="b1cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">更新</strong>:这里提到了一个变通方法:<a class="ae lw" href="https://github.com/svelte-society/recipes-mvp/issues/41#issue-638005462" rel="noopener ugc nofollow" target="_blank">https://github . com/svelte-society/recipes-MVP/issues/41 # issue-638005462</a>。它的工作原理是使用一个命名约定来区分我们想要作为web组件使用的组件，以及我们只想在内部使用的普通瘦组件。在本例中，<code class="fe ki kj kk kl b">.wc.svelte</code>中的任何组件eding都将在打开<code class="fe ki kj kk kl b">customElement</code>选项的情况下编译，而其余组件将关闭该选项。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="764e" class="mf ku in kl b gy mg mh l mi mj">// rollup.config.js<br/>svelte({ customElement: true, include: /\.wc\.svelte$/ }),<br/>svelte({ customElement: false, exclude: /\.wc\.svelte$/ }),</span></pre></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h1 id="759a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">嵌套组件中没有CSS，也没有全局CSS</h1><p id="eb71" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">没错，这是一个大的。你看到的所有使用svelet的web组件的例子要么只有一个svelet组件，要么根本不使用css。看看下面，我们的主组件的css将工作，但不会被限定范围，这意味着它将泄漏到所有子组件。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="3bdb" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="584e" class="mf ku in kl b gy mk mh l mi mj">&lt;script&gt;<br/>  import OtherComponent from './OtherComponent.svelte';<br/>&lt;/script&gt;</span><span id="76d9" class="mf ku in kl b gy mk mh l mi mj">&lt;style&gt;<br/>  p {<br/>    background-color: red; // Yes, I work... but everywhere!<br/>  }<br/>&lt;/style&gt;</span><span id="7427" class="mf ku in kl b gy mk mh l mi mj">&lt;p&gt;I'm red!&lt;/p&gt;</span><span id="1892" class="mf ku in kl b gy mk mh l mi mj">&lt;OtherComponent /&gt;</span></pre><p id="8b28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个单独的文件中，我们有:</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="4b28" class="mf ku in kl b gy mg mh l mi mj">// OtherComponent.svelte</span><span id="06c9" class="mf ku in kl b gy mk mh l mi mj">&lt;style&gt;<br/>  p {<br/>    background-color: blue; // useless<br/>  }<br/>&lt;/style&gt;</span><span id="7663" class="mf ku in kl b gy mk mh l mi mj">&lt;p&gt;I'm red too!&lt;/p&gt;</span></pre><p id="d08c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，如果作用域不起作用，我们可以只使用<code class="fe ki kj kk kl b">:global(p)</code>来设计所有的<code class="fe ki kj kk kl b">p</code>标签吗？不，全局修饰符在web组件中不起作用。<a class="ae lw" href="https://github.com/sveltejs/svelte/issues/2969" rel="noopener ugc nofollow" target="_blank">https://github.com/sveltejs/svelte/issues/2969</a>我们不能把所有的css都放在里面吗？不完全是。如果我们从<code class="fe ki kj kk kl b">App.svelte</code>中移除<code class="fe ki kj kk kl b">p</code>标签，我们也会失去子组件的样式。任何“未使用的”css都将在编译时被删除，因为编译器正确地看到我们在<code class="fe ki kj kk kl b">App.svelte</code>中没有<code class="fe ki kj kk kl b">p</code>标签，所以它抛出了那部分css。</p><p id="e34b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么解决办法是什么？我能想到的最好的办法是找到一种方法来禁用对未使用的css的修剪，并依靠作用域不起作用这一事实。不太好，但这是我们最好的了。我仍在试图找出如何实际实现这一点，所以如果你知道如何，留下评论，我会更新文章。</p></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h1 id="640a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">道具不会立即被填充</h1><p id="9890" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated"><a class="ae lw" href="https://github.com/sveltejs/svelte/issues/2227" rel="noopener ugc nofollow" target="_blank">https://github.com/sveltejs/svelte/issues/2227</a></p><p id="0173" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当处理纤细的组件时，我们习惯于在组件渲染时填充道具。如果一个道具有价值，它就已经在那里，随时可供我们使用。如果没有设置，我们可以选择指定一个缺省值或者不定义它。让我们看看这是如何与定制元素一起工作的。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="ca2d" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="d364" class="mf ku in kl b gy mk mh l mi mj">&lt;script&gt;<br/>  export let myProp = "some default value";<br/>&lt;/script&gt;</span><span id="0b39" class="mf ku in kl b gy mk mh l mi mj">My prop is: {myProp}!</span></pre><p id="9466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们开始之前，我们需要做一个改变，因为camel casing props由于一个bug不能与web组件一起工作。我们需要将我们的道具重命名为<code class="fe ki kj kk kl b">myprop</code>，这样我们就可以从一个属性中设置它。<br/><a class="ae lw" href="https://github.com/sveltejs/svelte/issues/3852" rel="noopener ugc nofollow" target="_blank">https://github.com/sveltejs/svelte/issues/3852</a></p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="94e8" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="93cb" class="mf ku in kl b gy mk mh l mi mj">&lt;script&gt;<br/>  export let myprop = "some default value";<br/>  <br/>  $: console.log(myprop); // console.log() every time myprop changes<br/>&lt;/script&gt;</span><span id="2380" class="mf ku in kl b gy mk mh l mi mj">My prop is: {myProp}!</span></pre><p id="a6b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们可以在一个HTML页面中尝试一下。如果我们不指定<code class="fe ki kj kk kl b">myprop</code>属性，它会像预期的那样工作，并采用默认值。但是如果我们为属性指定如下内容:</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="c136" class="mf ku in kl b gy mg mh l mi mj">// foo.html<br/>...<br/>&lt;my-awesome-component myprop="Foo" /&gt;<br/>...</span></pre><p id="65e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看我们的控制台输出:</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="220b" class="mf ku in kl b gy mg mh l mi mj">#: some default value                (App.svelte:4)<br/>#: Foo                               (App.svelte:4)</span></pre><p id="9fef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使我们已经为我们的prop指定了一个值，它在呈现元素时使用缺省值，并且只是在稍后才将其更改为属性值，就好像它只是在稍后才被更改一样。这可能会导致各种各样的问题，但幸运的是，我们有一个方法可以绕过它，尽管它并不漂亮。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="693c" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="b2d3" class="mf ku in kl b gy mk mh l mi mj">&lt;script&gt;<br/>  import { onMount, tick } from 'svelte';</span><span id="d4d2" class="mf ku in kl b gy mk mh l mi mj">  export let myprop = "some default value";</span><span id="c560" class="mf ku in kl b gy mk mh l mi mj">  onMount(async () =&gt; {<br/>    console.log(myprop); // "some default value"<br/>    await tick();<br/>    console.log(myprop); // "Foo"<br/>  });<br/>&lt;/script&gt;</span><span id="4a48" class="mf ku in kl b gy mk mh l mi mj">My prop is: {myProp}!</span></pre><p id="b541" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在等待<code class="fe ki kj kk kl b">tick()</code>之后，我们可以确定所有的属性都有正确的值，并且在这一点上我们可以设置一个变量<code class="fe ki kj kk kl b">ready</code>，我们可以用它来可选地呈现页面，或者做任何其他的逻辑。这是一个额外的不需要的逻辑层，但它解决了问题，直到有一个适当的修复。</p></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h1 id="041f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">老虎机和$ $老虎机</h1><p id="1b07" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated"><a class="ae lw" href="https://github.com/sveltejs/svelte/issues/5594" rel="noopener ugc nofollow" target="_blank">https://github.com/sveltejs/svelte/issues/5594</a></p><p id="607f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mt">更新:这个问题现在已经在3.29.5中修复了，所以</em> <code class="fe ki kj kk kl b"><em class="mt">$$slots</em></code> <em class="mt">应该又可以正常工作了。</em></p><p id="f5c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插槽是一种允许定制web组件的有用方式。我们可以使用它们来允许在我们定义的组件的某些部分嵌入HTML内容。不过，有一个小问题。在<a class="ae lw" href="https://github.com/sveltejs/svelte/blob/master/CHANGELOG.md#3250" rel="noopener ugc nofollow" target="_blank"> svelte 3.25.0 </a>中添加的<code class="fe ki kj kk kl b">$$slots</code>在web组件的顶层不起作用。因此，尽管插槽被正确地呈现，我们不能检查哪些插槽实际上被使用了。如果一个槽没有被使用，这在我们不想呈现组件的某个部分的情况下会很有用。看看下面的例子，它可以很好地工作，但是当用于web组件时<code class="fe ki kj kk kl b">$$slots</code>总是<code class="fe ki kj kk kl b">{}</code>。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="9d4c" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="2e03" class="mf ku in kl b gy mk mh l mi mj">&lt;p&gt;I am always rendered&lt;/p&gt;</span><span id="19b8" class="mf ku in kl b gy mk mh l mi mj">{#if $$slots.default}<br/>  &lt;p&gt;<br/>    I only want to be displayed if the slot is being used. &lt;br /&gt;<br/>    &lt;slot&gt;&lt;/slot&gt;<br/>  &lt;/p&gt;<br/>{/if}</span></pre><p id="b1a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们能找到解决办法吗？让我们利用<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement" rel="noopener ugc nofollow" target="_blank"> HTMLSlotElement </a>来制作我们自己版本的<code class="fe ki kj kk kl b">$$slots</code>。如果我们得到web组件中所有插槽的列表，我们可以使用<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedNodes" rel="noopener ugc nofollow" target="_blank"> assignedNodes </a>来检查是否有任何节点被分配给我们的插槽。我们的默认内容不会显示在这里，只有来自外部的内容。</p><blockquote class="mu mv mw"><p id="f3dd" class="jk jl mt jm b jn jo jp jq jr js jt ju mx jw jx jy my ka kb kc mz ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement" rel="noopener ugc nofollow" target="_blank">HTMLSlotElement</a></code>接口的<code class="fe ki kj kk kl b"><strong class="jm io">assignedNodes()</strong></code>属性返回分配给该槽的节点序列，如果<code class="fe ki kj kk kl b">flatten</code>选项设置为<code class="fe ki kj kk kl b">true</code>，则返回作为该槽后代的任何其他槽的分配节点。如果没有找到分配的节点，它将返回插槽的回退内容。</p></blockquote><p id="8e62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们简单地计算节点数，看看插槽是否被使用。我们可以用这个来准备一个模拟<code class="fe ki kj kk kl b">$$slots</code>的布尔映射。现在剩下的就是跟上DOM中的任何变化。我们可以监听插槽的变化，以响应任何正在使用或未使用的插槽。</p><blockquote class="mu mv mw"><p id="ba50" class="jk jl mt jm b jn jo jp jq jr js jt ju mx jw jx jy my ka kb kc mz ke kf kg kh ig bi translated">当槽中包含的节点改变时，在一个<code class="fe ki kj kk kl b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement" rel="noopener ugc nofollow" target="_blank">HTMLSlotElement</a></code>实例(<code class="fe ki kj kk kl b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot" rel="noopener ugc nofollow" target="_blank">&lt;slot&gt;</a></code>元素)上触发<code class="fe ki kj kk kl b"><strong class="jm io">slotchange</strong></code>事件。</p></blockquote><p id="d231" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于此事件会因任何更改而触发，因此我们添加了一个条件来检查节点数量是否已更改，并且仅在需要时更新。注意我们如何使用<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展语法</a>来触发<a class="ae lw" href="https://svelte.dev/tutorial/updating-arrays-and-objects" rel="noopener ugc nofollow" target="_blank">反应</a>。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="11b2" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="52b8" class="mf ku in kl b gy mk mh l mi mj">&lt;script&gt;<br/>import { onMount } from 'svelte';<br/>import { get_current_component } from "svelte/internal";</span><span id="9140" class="mf ku in kl b gy mk mh l mi mj">const thisComponent = get_current_component();<br/>let slots = {}; // we can use this instead of $$slots<br/>  <br/>onMount(async () =&gt; {<br/>  // get a list of all slots in our webcomponent<br/>  const elements = [<br/>   ...thisComponent.shadowRoot.querySelectorAll('slot')<br/>  ];</span><span id="2de2" class="mf ku in kl b gy mk mh l mi mj">  // create our $$slots replacement<br/>  slots = Object.fromEntries(<br/>    elements.map(e =&gt; ([e.name, !!e.assignedNodes().length]))<br/>  );</span><span id="a057" class="mf ku in kl b gy mk mh l mi mj">  // keep up to date with changes<br/>  elements.forEach(slot =&gt; slot.addEventListener(<br/>   'slotchange', () =&gt; {<br/>    // only update if we need to<br/>    if (slots[slot.name] !== !!slot.assignedNodes().length) {<br/>     slots = {...slots, [slot.name]: !!slot.assignedNodes().length};<br/>    }<br/>   }<br/>  ));<br/>});</span><span id="c124" class="mf ku in kl b gy mk mh l mi mj">&lt;/script&gt;</span><span id="9114" class="mf ku in kl b gy mk mh l mi mj">{#if slots.mySlot}<br/>  Only display me, if slot is used &lt;br /&gt;<br/>{/if}<br/>&lt;slot name="mySlot"&gt;Some default content&lt;/slot&gt;</span></pre><p id="bad4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有用吗？是啊！完事了吗？我希望:(边缘案例来了…让我们看看这个例子。这里，我们将插槽放在if块内部。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="0228" class="mf ku in kl b gy mg mh l mi mj">{#if slots.mySlot}<br/>  Only display me, if slot is used &lt;br /&gt;<br/>  &lt;slot name="mySlot"&gt;Some default content&lt;/slot&gt;<br/>{/if}</span></pre><p id="7d91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然这可以和<code class="fe ki kj kk kl b">$$slots</code>一起工作，但是我们的版本不行。所发生的是我们的槽没有得到渲染，因为条件最初是假的。因此，当我们调用<code class="fe ki kj kk kl b">.shadowRoot.querySelectorAll('slot')</code>时，它会给我们一个空的节点列表。因此，我们要么用css而不是if块隐藏内容，要么找到其他方法来列出组件中的所有道具。不幸的是，我不知道这样的方式，所以现在它的css。</p></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h1 id="a19c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">事件:如果你做对了，就去工作</h1><p id="3afc" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated"><a class="ae lw" href="https://github.com/sveltejs/svelte/issues/3119" rel="noopener ugc nofollow" target="_blank">https://github.com/sveltejs/svelte/issues/3119</a></p><p id="e781" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">能够从您的web组件发送事件无疑是能够与“外部世界”通信的关键部分。用户是否点击了按钮？我们可以发送一个事件吗？当然，让我们看看如何做。</p><p id="9d8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，我们需要做的是创建一个<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent" rel="noopener ugc nofollow" target="_blank"> CustomEvent </a>并从我们的顶级元素调度它。查看文档，我们可以看到我们需要设置<code class="fe ki kj kk kl b">composed</code>来跨越影子DOM边界。</p><blockquote class="mu mv mw"><p id="05e6" class="jk jl mt jm b jn jo jp jq jr js jt ju mx jw jx jy my ka kb kc mz ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/Event" rel="noopener ugc nofollow" target="_blank">Event</a></code>接口的只读<code class="fe ki kj kk kl b"><strong class="jm io">composed</strong></code>属性返回一个<code class="fe ki kj kk kl b"><a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean" rel="noopener ugc nofollow" target="_blank">Boolean</a></code>，指示事件是否会跨越影子DOM边界传播到标准DOM中。</p></blockquote><p id="4b56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这是如何在我们苗条的组成部分。</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="81b3" class="mf ku in kl b gy mg mh l mi mj">// App.svelte<br/>&lt;svelte:options tag="my-awesome-component" /&gt;</span><span id="5e18" class="mf ku in kl b gy mk mh l mi mj">&lt;script&gt;<br/>  import { get_current_component } from "svelte/internal";<br/>  <br/>  const thisComponent = get_current_component();</span><span id="e611" class="mf ku in kl b gy mk mh l mi mj">  // example function for dispatching events<br/>  const dispatchWcEvent = (name, detail) =&gt; {<br/>    thisComponent.dispatchEvent(new CustomEvent(name, {<br/>      detail,<br/>      composed: true, // propagate across the shadow DOM<br/>    }));<br/>  };</span><span id="c672" class="mf ku in kl b gy mk mh l mi mj">&lt;/script&gt;</span><span id="6310" class="mf ku in kl b gy mk mh l mi mj">&lt;button on:click={() =&gt; dispatchWcEvent("foo", "bar")}&gt;<br/>  Click me to dispatch a "foo" event!<br/>&lt;/button&gt;</span></pre><p id="9dab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在我们的HTML中，我们可以这样做:</p><pre class="lx ly lz ma gt mb kl mc md aw me bi"><span id="780c" class="mf ku in kl b gy mg mh l mi mj">// foo.html<br/>...<br/>&lt;script&gt;<br/>  window.addEventListener('DOMContentLoaded', () =&gt; {<br/>    document.getElementById("foobar").addEventListener("foo", e =&gt; {<br/>      alert(`Got foo event with detail: ${e.detail}`);<br/>    });<br/>  });<br/>&lt;/script&gt;<br/>...<br/>&lt;my-awesome-component id="foobar"/&gt;<br/>...</span></pre></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h1 id="d324" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">让我们看一些例子</h1><div class="na nb gp gr nc nd"><a href="https://itnext.io/svelte-web-component-5-4kb-4afe46590d99" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">纤薄的Web组件— 5.4KB</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">让我们来看看如何在现实生活中制作苗条的Web组件，并将其与用…创建的类似Web组件进行比较</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">itnext.io</p></div></div><div class="nm l"><div class="nn l no np nq nm nr mr nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://dev.to/silvio/how-to-create-a-web-components-in-svelte-2g4j" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">如何在Svelte中创建Web组件</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">在这篇文章中，我们将看到如何使用Svelte框架创建一个web组件。在我们开始写之前…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">开发到</p></div></div><div class="nm l"><div class="ns l no np nq nm nr mr nd"/></div></div></a></div></div></div>    
</body>
</html>