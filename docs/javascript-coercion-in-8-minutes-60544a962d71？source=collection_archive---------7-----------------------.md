# 8 分钟 JavaScript 强制

> 原文：<https://javascript.plainenglish.io/javascript-coercion-in-8-minutes-60544a962d71?source=collection_archive---------7----------------------->

## 第一部分

## 钻出来的强制概念！

![](img/36ce71b69ed9dc00c656f4f948fb17ff.png)

Photo by [Tudor Baciu](https://unsplash.com/@baciutudor?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/advanced-javascript-consepts?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

# JavaScript 中的本机函数

> JavaScript 有原生函数。

除了原始值，还有**基础对象**。什么是[的根本对象](https://www.ecma-international.org/ecma-262/#sec-fundamental-objects)？在旧版本的 specs 中你找不到这个名字，因为这是一个相对较新的术语，在过去，我们称它们为**内置对象**(又名**本地函数**)。今天，在现代编程方法中，最好将它们称为基本对象。

**基本对象不是像其他类型一样的类型。这部分可能很难理解，尤其是对初学者来说。在强类型语言(如 C#或 Java)中，我们也有类似的情况，我们有一个原语值的对象表示，以及与原语类型相关的行为。**

**我们可以把原生函数分成两组。**第一组是我们在声明它们时使用“new”关键字的那些(*对象*、*数组*、*函数*、*日期*、 *RegExp* 和*错误*)。第二组是我们使用的没有“new”关键字的那些(*字符串*、*数字*和*布尔*)。

结论:**我们没有实例化*字符串*、*数字*和*布尔*。**

**永远不要将【new】关键字与*布尔*、*数字*和*字符串*一起使用！**事实是，我们可以将它与“new”关键字一起使用，但会出现“错误”——这在我们讨论**强制**时很明显。请认真对待这个警告，不要陷入无法将类型强制转换为原始类型的境地！**只使用它们，而且只使用，而且只使用喜欢的功能！**

我将给出几个使用“新”关键字的例子:

结论:**使用带有*日期的“new”关键字是有意义的，例如*，因为这是声明它的唯一方式。**

# 抽象操作

> 这些操作不是 ECMAScript 语言的一部分…

根据 ECMAScript 的说法，抽象操作不是语言规范的一部分。我们不能避免谈论这些操作- **,它们是 JavaScript 引擎的构建模块。**他们是来帮我们处理[型转换](https://www.ecma-international.org/ecma-262/#sec-type-conversion)的。

传统上，**抽象操作执行类型转换**——强制。很简单，不是吗？那么，转换是如何进行的呢？

## 原始的

> 抽象操作 *ToPrimitive* 接受一个输入参数和一个可选参数 *PreferredType* ，并将其输入参数转换为非对象类型。

ECMAScript 中指出的第一个抽象操作是[*to primitive*](https://www.ecma-international.org/ecma-262/#sec-toprimitive)*。*这个操作很直观，把一个非原语类型强制转换成一个原语类型。**每个非原语类型(对象、数组、函数等。)可以要挟成原语。**

正如我所说，抽象操作不是语言的一部分，所以它们不像我们可以调用的函数。事实上，它们是 JavaScript 引擎内部的方法。我们不能随意称呼它们，所以不能说它们是有形的东西。这就是为什么我们称它们为抽象的原因——它们是 JS 概念的一部分。

让我们一步一步地了解这个概念。我们有一些不是原始的东西，我们需要它变成原始的。为了实现这一点，我们需要一个**算法(一组步骤)**。进行这种类型转换的完美算法是*到本原*运算。*top primitive*就像一个采用可选类型(参数)的函数，称为**提示**。

只有两种可能的暗示。如果我们正在做一个数字运算，并且它调用*来初始化*，猜猜会发生什么？提示是要将*号船*号。记住，这不是保证一个数字，我的想法是在那里使用它。第二种情况是当我们使用字符串时，发生了 *ToPrimitive* 。当然，提示是发送*字符串*。

最后你可以指定你喜欢做数字还是字符串(甚至你什么都不想说——**返回任何你能**的图元)。

让事情变得可靠。算法(本质上)是递归的。那是什么意思？如果一个操作的返回( *ToPrimitive* )不是我们所期望的，那么**将被调用，直到它得到期望的结果**(原始类型)，或者**在某些情况下返回一个错误**。

结论:**在幕后有很多递归操作。**

## valueOf()与 toString()

> *valueOf()* 和 *toString()* 可以改变它们的 presedence。

在幕后，我们还有另外两个方法，它们可以在任何非原语上使用。这两个函数是: *valueOf()* 和 *toString()* 。它是如何融入一个关于*原始*的故事的？让我们找出答案。

首先，我们有两个方法可以在任何非原语(对象、函数、数组等)上使用。).这两种方法是: *valueOf()* 和 *toString()* 。因此，流程是下一步。如果你告诉我**提示是一个数字**，那么我将首先调用 *valueOf()* 。如果这给了我一个原始人，那就是它！如果这没有返回一个原语，我们将调用 *toString()* 。然后我们会得到本原或非本原。如果我们得到一个非原语，那么它将会导致一个错误。

结论:**在决定抛出错误之前，JavaScript 同时调用了 *valueOf()* 和 *toString()* 。**

第二种情况是当我们告诉提示是一个字符串时，那么第一个调用的方法是 *toString()* 。如果给了我们原语，比如 string(这是应该的)，我们将使用它并尝试调用 *valueOf()* 方法。

结论:**如果我们要使用一个不是原语的东西，在原语是强制的地方，它最终会用 *ToPrimitive* 算法强制它。**

## ToString

*ToString* 操作顾名思义。它接受一个值，并以字符串的形式给出这个值的表示。 *ToString* 是一个简单的操作，在 [ECMAScript](https://www.ecma-international.org/ecma-262/#sec-tostring) 中有简单的解释。

让我给你看一些例子，看看它们是什么和产生后的字符串表示:

这些表示大部分都是预期的，预期负零！？负零不知何故变成了零，我们知道这种行为，JS - **胁迫骗子**中的拐角案例之一。其他一切(null、布尔值、未定义、浮点数)都有预期的结果。

结论:**结果如预期，除了一个拐角情况(负零)。**

当我们谈到对象和类对象类型时，事情就有点不同了。如果我们在一个对象上调用 *ToString* ，它将使用 *String* 提示调用 *ToPrimitive* 。我们说过它将最终调用 *toString()* ，如果它存在，它将使用 *valueOf()* 。我们知道那个命令！

**记住**，它将首先调用 *toString* ，如果它存在，那么它将使用的*值。这就是它的顺序。让我们来看一些例子。首先，我们将研究数组:*

数组有它们自己的序列化和 *toString()* ，它们总是产生相同的结果。结果有时会令人困惑。例如， *String()* 将显示与空数组相同的效果。检测类型的唯一方法是猜测。然而，我们有责任接受这个事实。另一个简单的决定是在字符串化 *null* 和 *undefined* 数组成员时返回 nil。现在，我将给出几个对象示例:

对象来了，一堆问题也来了。对象序列化是模糊的和不可理解的。对象和数组一样，都有自己的 *toString()* 方法，这带来了一片模糊。我们在数组中丢失了方括号，但是在对象上添加了(*前往顶部并读取杯子上写的内容，然后返回此处*)。我知道这是个愚蠢的决定。

我们会原谅他们，但是这是什么意思呢？严格类型的语言最有可能影响 JS。于是，采用了这种做法。第一个对象词表示一个类型，第二个表示该类型的名称。

有两种方法可以解决这个问题。第一个是覆盖自定义对象的字符串标签:

如果我们想区分一个空的和非空的对象，我们可以使用 *JSON.stringify()* 方法:

这种方法不是典型的[元编程](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming)(支持 ES6 形式)使用[代理](https://www.ecma-international.org/ecma-262/#sec-proxy-objects)和[反射](https://www.ecma-international.org/ecma-262/#sec-reflect-object)对象，我们一直都是这样做的。

结论:**支持元编程，可以添加自己定制的部件。**

## ToNumber

我们得到了另一个抽象操作- *ToNumber* 。这个更有趣一点，因为有更多的死角案例。每次我们必须做一个数字运算，而我们没有得到数字，我们将调用*来得到数字*。让我们看一些例子:

大多数结果看起来是合理的，但是空字符串("")会发生什么呢？为什么会强制为零？这是 JS 引擎最大的错误之一吗？空字符串表示缺少值。据我所知，这是字符串类型中缺少值的唯一表示。那么，它为什么会变成有效数(0)呢？我们已经有了一个表示无效数字的方法，它就是 *NaN* 。

结论:**除了空字符串之外，数值化工作正常！**

现在让我们看看它是如何处理布尔值的:

有趣的一个！所以，T *rue* 返回 1，F *alse* 返回 0。**我们一直以为 FALSE 是持有 0，TRUE 是持有 1 —** 这大概是大多数人的预期。

为什么他们用 *NaN* 带 *undefined* ，而不用 *null* ？好吧，这是一个不可理解的遗漏。有什么条件？秘密就在于*本原*法。

*ToNumber* 将 null 视为对象类型，并通过 *Number* 提示( [7.1.1](https://www.ecma-international.org/ecma-262/#sec-toprimitive) )调用 *ToPrimitive* 。剩下的我们都知道了。首先是 *valueOf()* 在唤起，然后是 *toString()* 。在对象的情况下， *valueOf()* 会返回自身，然后 *toString()* 会发生。

这个提示是直接输入到 *toString()* 中的数字并不重要。对象的数值化就像它的字符串化一样。那是一个艰难的抉择，但它已经摆在面前，我们必须接受它。最后，它会产生字符串。

结论:**我们想要一个“原始”数字，但我们得到的是一个“原始”字符串。**

我再举几个例子，这样你就能清楚地理解这个逻辑了:

你还记得 *ToString* 是如何工作的吗？哲学也是一样。首先，它强制为一个空字符串，然后空字符串产生零。同*空*和*未定义*。它变成一个空字符串，然后空字符串被强制为零。

对于有数字的数组，情况就很清楚了。它首先强制一个字符串(“3，6，9”)。第二步，**算法会把它强制为一个数字**，结果会是一个 *NaN* 。我们也可以在这里使用一个补丁:

## 托布勒安

*ToBoolean* 是我们要检查的最后一个操作。**顺便说一下，这四个操作正是我们要找的。**还有很多操作，今天就不说了。如果你感兴趣，请访问 specs。

每当我们有一个非布尔值，并且我们在一个需要布尔值的地方使用，这个操作就会发生。**操作与其他的相同。**这个操作算法少，查找多。

我们在规格中有一个查找表。falsy 值为:" "—(空字符串)， *0* ， *-0* ， *null* ， *NaN* ， *false* ，*未定义*。他们总是要挟要假的。很短的名单，是吧？没有列在这个列表上的所有其他值都是真实的。我给你举几个例子来说明问题:

结论:**用 falsy 表判断值是否为假，否则为真。**

## **简明英语团队的笔记**

你知道我们有四份出版物和一个 YouTube 频道吗？你可以在我们的主页[**plain English . io**](https://plainenglish.io/)上找到所有这些信息——关注我们的出版物并 [**订阅我们的 YouTube 频道**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw) **来表达你的爱吧！**