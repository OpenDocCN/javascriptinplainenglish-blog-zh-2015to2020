<html>
<head>
<title>Vue.js Components — Listeners, References, and Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js组件—监听器、引用和模板</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vue-js-components-listeners-references-and-templates-1cd2bc6d5582?source=collection_archive---------3-----------------------#2020-03-29">https://javascript.plainenglish.io/vue-js-components-listeners-references-and-templates-1cd2bc6d5582?source=collection_archive---------3-----------------------#2020-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e5d93431d47f040ced13e0b289b82696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SVbMhRi6yUvg3Kvh"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kymellis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kym Ellis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e1eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue.js是一个易于使用的web应用框架，我们可以用它来开发交互式前端应用。</p><p id="8cb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究编程事件侦听器、递归、循环引用以及定义模板的其他方法。</p><h1 id="0774" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">编程事件侦听器</h1><p id="c263" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了用<code class="fe me mf mg mh b">$emit</code>发射事件，用<code class="fe me mf mg mh b">v-on</code>监听事件，Vue还在其事件接口中提供了其他方法。以下功能可用:</p><ul class=""><li id="4596" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">收听<code class="fe me mf mg mh b">$on(eventName, eventHandler)</code>的事件</li><li id="ae2c" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">使用<code class="fe me mf mg mh b">$once(eventName, eventHandler)</code>只监听一次事件</li><li id="638d" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">停止收听<code class="fe me mf mg mh b">$off(eventName, eventHandler)</code>的事件</li></ul><p id="3a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们需要以编程方式监听事件时，它们是可用的。</p><p id="4745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用它:</p><p id="d8d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="33a4" class="ne lc iq mh b gy nf ng l nh ni">Vue.component("foo-button", {<br/>  template: `&lt;button <a class="ae kc" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>='$root.$emit("toggleFoo")'&gt;Toggle Foo&lt;/button&gt;`<br/>});</span><span id="a944" class="ne lc iq mh b gy nj ng l nh ni">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: ""<br/>  },<br/>  mounted() {<br/>    this.$root.$on("toggleFoo", function() {<br/>      this.foo = this.foo === "foo" ? "" : "foo";<br/>    });<br/>  }<br/>});</span></pre><p id="e17b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="133b" class="ne lc iq mh b gy nf ng l nh ni">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;foo-button&gt;&lt;/foo-button&gt;<br/>      {{foo}}<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们调用了<code class="fe me mf mg mh b">$root.$emit</code>来发出根Vue实例中的事件。然后根Vue实例可以监听事件，就像我们上面提到的那样，它是用<code class="fe me mf mg mh b">this.$root.$on</code>挂载的。</p><p id="78b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当我们单击Toggle Foo时，我们看到单词<code class="fe me mf mg mh b">foo</code>随着我们单击按钮而切换开和关。</p><p id="d918" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue的事件系统不同于浏览器的事件目标API。但是，它们的工作方式仍然相似。</p><p id="761e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">$emit</code>、<code class="fe me mf mg mh b">$on</code>和<code class="fe me mf mg mh b">$off</code>不是<code class="fe me mf mg mh b">dispatchEvent</code>、<code class="fe me mf mg mh b">addEventListener</code>和<code class="fe me mf mg mh b">removeEventListener</code>的别名。</p><h1 id="afca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">循环引用</h1><h2 id="9efd" class="ne lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">递归组件</h2><p id="588a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过向组件添加<code class="fe me mf mg mh b">name</code>属性来递归引用组件。</p><p id="9b14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来显示递归嵌套对象中的数据:</p><p id="ba3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="b152" class="ne lc iq mh b gy nf ng l nh ni">Vue.component("foo-box", {<br/>  name: "foo-box",<br/>  props: ["foo"],<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;p&gt;{{foo.val}}&lt;/p&gt;      <br/>      &lt;foo-box v-if='foo.foo' :foo='foo.foo'&gt;&lt;/foo-box&gt;<br/>    &lt;/div&gt;<br/>  `<br/>});</span><span id="e237" class="ne lc iq mh b gy nj ng l nh ni">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: {<br/>      val: "foo",<br/>      foo: {<br/>        val: "foo",<br/>        foo: {<br/>          val: "foo"<br/>        }<br/>      }<br/>    }<br/>  }<br/>});</span></pre><p id="518a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="cd46" class="ne lc iq mh b gy nf ng l nh ni">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;foo-box :foo="foo"&gt;&lt;/foo-box&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们看到:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="b8dc" class="ne lc iq mh b gy nf ng l nh ni">foo</span><span id="36ca" class="ne lc iq mh b gy nj ng l nh ni">foo</span><span id="64f8" class="ne lc iq mh b gy nj ng l nh ni">foo</span></pre><p id="770b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显示在屏幕上。</p><p id="ee98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须确保我们有一个<code class="fe me mf mg mh b">v-if</code>或另一个条件来在某个点结束递归渲染。否则，我们将得到一个无限循环，并将导致“超出最大堆栈大小”错误</p><h2 id="bfa6" class="ne lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">组件之间的循环引用</h2><p id="6f55" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Vue.component</code>全部自动解析对组件的循环引用。</p><p id="3614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用模块系统，那么我们需要在<code class="fe me mf mg mh b">beforeCreate</code>钩子中明确地<code class="fe me mf mg mh b">require</code>它或者<code class="fe me mf mg mh b">import</code>它。</p><p id="f211" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了要求它，我们可以写:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="20e9" class="ne lc iq mh b gy nf ng l nh ni">beforeCreate() {<br/>  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default<br/>}</span></pre><p id="8fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用的是Webpack的<code class="fe me mf mg mh b">import</code>，我们可以写类似的东西:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="affc" class="ne lc iq mh b gy nf ng l nh ni">components: {<br/>  TreeFolderContents: () =&gt; import('./tree-folder-contents.vue')<br/>}</span></pre><p id="5e3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe me mf mg mh b">Vue.components</code>定义的组件，我们可以使用它们，无需做如下任何更改:</p><p id="457f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="0877" class="ne lc iq mh b gy nf ng l nh ni">Vue.component("tree-folder-contents", {<br/>  props: ["children"],<br/>  template: `<br/>    &lt;ul&gt;<br/>      &lt;li v-for="child in children"&gt;<br/>        &lt;tree-folder v-if="child.children" :folder="child"/&gt;<br/>        &lt;span v-else&gt;{{ child.name }}&lt;/span&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  `<br/>});</span><span id="04ae" class="ne lc iq mh b gy nj ng l nh ni">Vue.component("tree-folder", {<br/>  props: ["folder"],<br/>  template: `<br/>    &lt;p&gt;<br/>      &lt;span&gt;{{ folder.name }}&lt;/span&gt;<br/>      &lt;tree-folder-contents :children="folder.children"/&gt;<br/>    &lt;/p&gt;<br/>  `<br/>});</span><span id="04ba" class="ne lc iq mh b gy nj ng l nh ni">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    folder: {<br/>      name: "folder",<br/>      children: [{ name: "folder2" }]<br/>    }<br/>  }<br/>});</span></pre><p id="b410" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="30c1" class="ne lc iq mh b gy nf ng l nh ni">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;tree-folder :folder="folder"&gt;&lt;/tree-folder&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="5fd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将看到<code class="fe me mf mg mh b">tree-folder-contents</code>和<code class="fe me mf mg mh b">tree-folder</code>分别是一些<code class="fe me mf mg mh b">tree-folder</code>和<code class="fe me mf mg mh b">tree-folder-contents</code>组件的父代。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/adfb470c2d3a2e63d7cee3c723c21547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c1Y3eLqCHq8DMEUU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jsnbrsc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jason Briscoe</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="ffc9" class="ne lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">内嵌模板</h2><p id="383e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当<code class="fe me mf mg mh b">inline-template</code>属性出现在子组件上时，组件将使用其内部内容作为模板，而不是将其视为分布式内容。</p><p id="6cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，内部可用数据的范围会令人困惑，因为我们可以访问子组件的范围，而不是标签中父组件的范围。</p><p id="8ee7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><p id="25c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="a364" class="ne lc iq mh b gy nf ng l nh ni">Vue.component("bar", {<br/>  data() {<br/>    return {<br/>      baz: "bar"<br/>    };<br/>  },<br/>  template: `<br/>    &lt;p&gt;&lt;/p&gt;<br/>  `<br/>});</span><span id="cfaa" class="ne lc iq mh b gy nj ng l nh ni">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: "foo"<br/>  }<br/>});</span></pre><p id="fd96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.js</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="03fa" class="ne lc iq mh b gy nf ng l nh ni">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;bar inline-template&gt;<br/>        &lt;div&gt;<br/>          {{baz}}<br/>        &lt;/div&gt;<br/>      &lt;/bar&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7e19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">则<code class="fe me mf mg mh b">{{bar}}</code>是从<code class="fe me mf mg mh b">bar</code>组件引用<code class="fe me mf mg mh b">baz</code>。它也覆盖了我们在<code class="fe me mf mg mh b">bar</code>中定义的模板。</p><h1 id="4308" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="75b9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过<code class="fe me mf mg mh b">$on</code>、<code class="fe me mf mg mh b">$off</code>和<code class="fe me mf mg mh b">$once</code>以编程方式定义事件侦听器。</p><p id="6cdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要递归引用一个组件，我们必须向组件添加<code class="fe me mf mg mh b">name</code>属性。我们必须小心不要创建无限递归。</p><p id="fac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">Vue.component</code>来定义我们的组件，循环引用会自动解析。然而，如果我们使用单文件组件，那么我们就有了<code class="fe me mf mg mh b">import</code>的<code class="fe me mf mg mh b">require</code>了，这取决于我们使用的构建工具。</p><p id="d97b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">inline-template</code>属性在组件中定义模板。</p><h2 id="bd89" class="ne lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated"><strong class="ak">来自JavaScript的普通英语注释:</strong></h2><p id="9e96" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们一直对帮助推广高质量内容感兴趣。如果您想将某篇文章提交给JavaScript，请用您的中位用户名在<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>发邮件给我们，我们会将您添加为作者。</p></div></div>    
</body>
</html>