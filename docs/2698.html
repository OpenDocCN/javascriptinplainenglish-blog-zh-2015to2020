<html>
<head>
<title>Using an expiry date in JavaScript to create self-destructing data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript中的到期日期创建自毁数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-an-expiry-date-in-javascript-to-create-self-destructing-data-e7e93b050b73?source=collection_archive---------7-----------------------#2020-07-15">https://javascript.plainenglish.io/using-an-expiry-date-in-javascript-to-create-self-destructing-data-e7e93b050b73?source=collection_archive---------7-----------------------#2020-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7ca1" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">创建有保存期限的信息。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/00a82641b31983ef907e79e2580890e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K_mf9nnGNbzMkIjV.png"/></div></div></figure><p id="1b43" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设您已经创建了一个web应用程序，除了它的其余功能之外，它还向用户呈现了一条信息，您希望这条信息只在页面上保留一段时间。这可能是任何范围的事情，从临时笔记中的个人信息，到每天午夜到期的“每日报价”，到从速率受限的外部API提取的数据。</p><p id="0a04" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为一名开发人员，你可以有多种方式来完成这项工作，但一个简单而有趣的方式是给这条信息设定一个<em class="lk">截止日期</em>，在此日期之后，它将自我销毁，回到它原来的数字世界。</p><p id="cbf2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个技巧将探索JavaScript语言中一些不同的内置功能，并证明是一个通用的工具，可以在以后的应用程序中修改或激发其他想法。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="8107" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于本教程，我将使用我用<a class="ae ls" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>构建的一个应用程序的上下文，该应用程序为用户提供一个冥想计时器、一个焦点/番茄闹钟计时器，以及一个主页和登录页面，其中显示了日期和时间、当地天气以及一段鼓舞人心的每日名言。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lt"><img src="../Images/71b4658ab10ebfd0ee6b91a8a8d57091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-gA1W3Bp1xHT4Bc91WLng.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk"><em class="ly">Hosted at </em><a class="ae ls" href="https://focus-timer.app/" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://focus-timer.app/</em></a></figcaption></figure><p id="77f5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个主页中，我知道我想从外部API自动获取报价——但是我遇到了一个问题，为了保留带宽，API受到了速率限制。在我的应用程序被暂时限制之前，我每小时只能打一定数量的电话，报价从页面上完全消失了(取而代之的是难看的控制台错误！)</p><p id="afde" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我知道我可以通过每天只在服务器端获取一次报价来尝试防止这种情况，但是我想我会利用这个机会尝试在客户端保留获取，并尝试在逐个访问者的基础上给数据一个截止日期，因为我知道这可能会在未来的应用程序中对我有利。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="ff3e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这次讨论中，我们将使用现代web开发的两个标准化功能。</p><p id="6a85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个是包含站点DOM文档的窗口的一个方面:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="b116" class="me mf in ma b gy mg mh l mi mj">Window.localStorage</span></pre><p id="79f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个是JavaScript语言的内置对象:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="0538" class="me mf in ma b gy mg mh l mi mj">Date()</span></pre><p id="cdd5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> localStorage </strong> </a>是一个属性，它使您能够访问文档中的<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" rel="noopener ugc nofollow" target="_blank">存储</a>对象，该对象在浏览器会话之间保持不变。可以通过JavaScript代码或直接通过浏览器控制台来访问它。</p><p id="e9e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> Date() </strong> </a>是一个对象，表示创建时的单个时间点，以UTC 1970年1月1日以来的毫秒数为单位。这个Date()对象有许多操作它的内置函数，其中一个我们将在我们的例子中使用。</p><p id="6d27" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我将要展示的要点版本如下:</p><ul class=""><li id="b766" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj mp mq mr ms bi translated">当加载主页时，我们检查用户的localStorage，看看那里是否已经有一个被提取的报价。</li><li id="d5e3" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">如果<em class="lk">没有</em>报价，那么我们从API获取一个新报价，将该报价保存到localStorage，并运行一个函数来保存到期日期/时间，以备我们需要替换该报价时使用。</li><li id="3b22" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">如果<em class="lk">是</em>报价，那么我们将当前日期/时间与到期日期/时间进行比较(在这种情况下，到期日期是报价保存到本地存储的当天午夜)。</li><li id="3178" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">如果当前日期/时间在到期日期/时间的之前<em class="lk">，那么我们将从localStorage中提取报价并将其呈现在页面上。</em></li><li id="cc38" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">如果当前日期/时间是在到期日期/时间的之后的<em class="lk">，那么我们清除本地存储并返回到步骤1，从API获取一个新的报价。</em></li></ul><p id="c994" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们看看代码中的实际情况！</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="20b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我创建了两个助手函数，它们被抽象出来以保持代码整洁和<a class="ae ls" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>。</p><p id="e2a1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个是标记为<em class="lk"> secondsToMidnight() </em>的函数，它接受一个<strong class="kq io"> Date() </strong>对象作为<em class="lk"> n </em>，并使用该对象的内置函数<em class="lk"> getHours() </em>、<em class="lk"> getMinutes() </em>和<em class="lk"> getSeconds() </em>来查找与<strong class="kq io"> Date() </strong>对象相同的当天午夜之前的秒数。这可能看起来有点混乱，但本质上这是一个可以修改的步骤，以找到您想要设置为数据到期日期的未来任意时间量。</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="3d2e" class="me mf in ma b gy mg mh l mi mj">const secondsToMidnight = (n) =&gt; {<br/>    return (<br/>      ((24 - n.getHours() - 1) * 60 * 60) + ((60 - n.getMinutes() - 1) * 60) + (60 - n.getSeconds())<br/>    )<br/>  }</span></pre><p id="9156" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二个辅助函数标记为<em class="lk">assignQuoteToLocalStorage()</em>，它做4件事:</p><ul class=""><li id="e6fd" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj mp mq mr ms bi translated">利用对API(<em class="lk">getQuoteOfTheDay()</em>)的获取来获取报价。</li><li id="721c" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">在变量<em class="lk"> currentTime </em>下创建一个<strong class="kq io"> Date() </strong>对象，并对其执行3项操作以创建到期日期/时间:</li></ul><ol class=""><li id="f7ad" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj my mq mr ms bi translated">使用内置函数<em class="lk"> getTime() </em>获取以毫秒为单位的当前时间(以距离1970年1月1日为单位测量当前时间)。</li><li id="c12b" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj my mq mr ms bi translated">将<em class="lk"> currentTime </em> date对象传递到<em class="lk"> secondsToMidnight() </em>中，然后将其乘以1000以获得午夜前的毫秒数。</li><li id="836b" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj my mq mr ms bi translated">将这两个数字相加，以获得以毫秒为单位的未来日期/时间，该日期/时间正好等于同一天的午夜。</li></ol><ul class=""><li id="e7d4" class="mk ml in kq b kr ks ku kv kx mm lb mn lf mo lj mp mq mr ms bi translated">将quote和expiry作为对象中的键/值对设置到localStorage。</li><li id="b852" class="mk ml in kq b kr mt ku mu kx mv lb mw lf mx lj mp mq mr ms bi translated">在React中将报价设置为要在页面上呈现的状态(<em class="lk"> setQuoteOfTheDay() </em>)。</li></ul><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="6306" class="me mf in ma b gy mg mh l mi mj">const assignQuoteToLocalStorage = () =&gt; {<br/>  getQuoteOfTheDay()<br/>  .then( quote =&gt; {<br/><br/>    const currentTime = new Date()<br/>    const expiry = currentTime.getTime() + (secondsToMidnight(currentTime) * 1000)<br/><br/>    localStorage.quote = JSON.stringify(quote)<br/>    localStorage.expiry = expiry<br/><br/>    setQuoteOfTheDay(quote)<br/><br/>  })<br/>}</span></pre></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="277e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们利用上述两个助手方法在组件挂载中执行以下操作(每次加载页面时都会发生):</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="50a0" class="me mf in ma b gy mg mh l mi mj">if (!!localStorage.quote) {<br/><br/>  let quoteExpiry = parseInt(localStorage.getItem("expiry"))<br/>  let now = new Date()<br/><br/>  if (now.getTime() &gt; quoteExpiry) {<br/><br/>    localStorage.removeItem("quote")<br/>    localStorage.removeItem("expiry")<br/><br/>    assignQuoteToLocalStorage()<br/><br/>  } else {<br/><br/>    let quote = JSON.parse(localStorage.getItem("quote"))<br/>    setQuoteOfTheDay(quote)<br/><br/>  }<br/><br/>} else {<br/><br/>  assignQuoteToLocalStorage()<br/><br/>}</span></pre><p id="7c79" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的第一个<em class="lk"> if </em>语句中，我们检查localStorage中是否有引用。如果有，那么我们从localStorage中取出到期日期，创建一个新的current <strong class="kq io"> Date() </strong>对象，并比较两者。</p><p id="ff84" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们使用嵌套的<em class="lk"> if </em>语句来检查当前时间是否在到期时间之后。如果是这样，我们从本地存储中删除报价和到期时间，并调用我们的助手函数(<em class="lk">assignQuoteToLocalStorage()</em>)来获取新的报价并为其创建新的到期时间。如果当前时间仍在到期之前，我们从localStorage中提取报价，并将其设置为我们的状态，以便在页面上呈现。</p><p id="1d83" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们的第一个<em class="lk"> if </em>语句返回false，并且在localStorage中没有找到报价，那么我们调用<em class="lk">assignQuoteToLocalStorage()</em>并获取一个新报价，然后将它和到期日期分配给LocalStorage。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="1a6c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们完事了。虽然这些都是在我的应用程序的特定上下文中完成的，但同样的原则在任何地方都适用。</p><p id="edcf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以对JavaScript <strong class="kq io"> Date() </strong>对象及其相关函数使用类似的技巧，以您喜欢的任何格式将到期时间保存到本地存储或您的数据库，以创建自毁的数据片段。</p><p id="08d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读！如果你有任何问题或建议，请在评论中告诉我。</p><h1 id="26bb" class="mz mf in bd na nb nc nd ne nf ng nh ni jt nj ju nk jw nl jx nm jz nn ka no np bi translated">简单英语的JavaScript</h1><p id="1dca" class="pw-post-body-paragraph ko kp in kq b kr nq jo kt ku nr jr kw kx ns kz la lb nt ld le lf nu lh li lj ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ls" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kq io">！</strong></p></div></div>    
</body>
</html>