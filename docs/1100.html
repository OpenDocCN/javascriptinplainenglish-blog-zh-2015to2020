<html>
<head>
<title>Type Checking in React &amp; Redux with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript在React &amp; Redux中进行类型检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/type-checking-in-react-redux-with-typescript-834cd75cb7d2?source=collection_archive---------5-----------------------#2020-01-29">https://javascript.plainenglish.io/type-checking-in-react-redux-with-typescript-834cd75cb7d2?source=collection_archive---------5-----------------------#2020-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/563bfcf77af004cd9b9bc96ce0dc9d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWUgGAQuiROzilwG_tEU2Q.png"/></div></div></figure><p id="07e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript在JS社区中的地位越来越强，许多受欢迎的公司开始在基于react的前端使用它进行类型检查。让我们看看如何将TypeScript与React和Redux一起使用。</p><h1 id="25cc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">向现有的create-react-app项目添加TypeScript</strong></h1><p id="7dc5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果要将TypeScript添加到现有应用程序中，请安装TypeScript和其他必需的类型</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="127b" class="mi kx iq me b gy mj mk l ml mm">npm install --save typescript @types/node @types/react @types/react-dom @types/jest</span></pre><p id="9d5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们需要将文件重命名为<code class="fe mn mo mp me b">.ts</code>或<code class="fe mn mo mp me b">.tsx</code>，然后启动服务器。这将自动生成<code class="fe mn mo mp me b">tsconfig.json</code>文件。</p><h1 id="26d8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">使用带动作的类型脚本</strong></h1><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="76cf" class="mi kx iq me b gy mj mk l ml mm">export interface IStartFetchPostsAction extends Action&lt;’StartFetchPosts’&gt; {}</span><span id="f9e7" class="mi kx iq me b gy mq mk l ml mm">export interface IFetchPostsSuccessAction extends Action&lt;’FetchPostsSuccess’&gt; {<br/> posts: IPost[];<br/>}</span><span id="1328" class="mi kx iq me b gy mq mk l ml mm">export type PostActions =<br/> | IStartFetchPostsAction<br/> | IFetchPostsSuccessAction</span></pre><p id="9493" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些动作类型扩展了Redux库附带的通用<code class="fe mn mo mp me b">Action</code>类型。这确保了我们在使用代码中的动作时正确地设置了<code class="fe mn mo mp me b">type</code>属性。</p><p id="8318" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在上面看到的，我们有引用2个动作的<code class="fe mn mo mp me b">PostsActions</code>联合类型。我们稍后将在Posts reducer中使用它来确保我们使用正确的操作。</p><p id="aee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会问，我们从哪里获得IPost[]。嗯，有一个单独的文件，我们在那里为帖子创建了一个类似这样的界面。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="28fb" class="mi kx iq me b gy mj mk l ml mm">export interface IPost {<br/> id: number;<br/> title: string;<br/> description: string;<br/>...<br/>}</span></pre><p id="fdd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至于从后端获取帖子应该是异步操作，这就是Redux-Thunk解决我们问题的地方。然而，在这里使用TypeScript会更有挑战性。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3f7a" class="mi kx iq me b gy mj mk l ml mm">export const fetchPostsActionCreator: ActionCreator&lt;<br/> ThunkAction&lt;<br/> Promise&lt;IFetchPostsSuccessAction&gt;, <br/> &gt;<br/>&gt; = () =&gt; {<br/> return async (dispatch: Dispatch) =&gt; {<br/> const startFetchPostsAction: IStartFetchPostsAction = {<br/> type: ‘StartFetchPosts’,<br/> };<br/> dispatch(startFetchPostsAction);<br/> const posts = await fetch("API URL");<br/> const fetchPostsSuccessAction: IFetchPostsSuccessAction = {<br/> posts,<br/> type: ‘FetchPostsSuccess’,<br/> };<br/> return dispatch(fetchPostsSuccessAction);<br/> };<br/>};</span></pre><p id="8415" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mn mo mp me b">ActionCreator</code>是Redux库中的一个通用类型，它接受动作创建者返回的类型。上面的动作创建器返回一个函数，该函数将返回<code class="fe mn mo mp me b">IFetchPostsSuccessAction</code>。第一次，你可能会感到陌生。但是它是Redux-Thunk库附带的一个泛型。</p><h1 id="d028" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">使用带减速器的打字稿</strong></h1><p id="2b8b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们看看当我们实现TypeScript时，我们的Reducer会是什么样子:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9bf2" class="mi kx iq me b gy mj mk l ml mm">import { Reducer } from "redux";<br/>import {<br/>  IPostsState,<br/>  PostsActions,<br/>} from "./PostsTypes";</span><span id="ec99" class="mi kx iq me b gy mq mk l ml mm">const initialPostState: IPostsState = {<br/>  posts: [],<br/>  isLoading: false<br/>};</span><span id="32da" class="mi kx iq me b gy mq mk l ml mm">const postsReducer: Reducer&lt;IPostsState, PostsActions&gt; = (<br/> state = initialPostsState,<br/> action,<br/>) =&gt; {<br/> switch (action.type) {<br/> case ‘StartFetchPosts’: {<br/> return {<br/> …state,<br/> isloading: true,<br/> };<br/> }<br/> case ‘FetchPostsSuccess’: {<br/> return {<br/> …state,<br/> posts: action.posts,<br/> isloading: false,<br/> };<br/> }<br/> }<br/>return state;<br/>};</span></pre><p id="2a9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要一个减根器</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1160" class="mi kx iq me b gy mj mk l ml mm">import { combineReducers } from 'redux';<br/>import PostsReducer from './reducers/PostsReducer'</span><span id="5477" class="mi kx iq me b gy mq mk l ml mm">const rootReducer = combineReducers&lt;IAppState&gt;({<br/> Posts: postsReducer<br/>});</span><span id="1410" class="mi kx iq me b gy mq mk l ml mm">export default rootReducer;</span></pre><p id="a34e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用Redux库中的泛型<code class="fe mn mo mp me b">Reducer</code>类型，并通过<code class="fe mn mo mp me b">PostsActions</code>联合类型传入我们的状态类型。</p><p id="0d96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mn mo mp me b">switch</code>语句的每个case中的<code class="fe mn mo mp me b">action</code>参数的类型被缩小到与特定case相关的特定动作。</p><h1 id="f719" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">使用TypeScript和Store </strong></h1><p id="67d1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们正在使用Redux库中的通用类型<code class="fe mn mo mp me b">Store</code>,并传入我们的应用程序状态的类型，在这个项目中是<code class="fe mn mo mp me b">IAppState</code>。让我们在我们的<strong class="ka ir"> store.js </strong>内部做出改变</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4804" class="mi kx iq me b gy mj mk l ml mm">export function configureStore(): Store&lt;IAppState&gt; {<br/> const store = createStore(rootReducer, undefined, applyMiddleware(thunk));<br/> return store;<br/>}</span></pre><h1 id="c11d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在组件内部使用TypeScript</h1><p id="16db" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们看看当我们在组件内部实现TypeScript时会是什么样子。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f738" class="mi kx iq me b gy mj mk l ml mm">import * as React from "react";<br/>import { connect } from "react-redux";<br/>import { RouteComponentProps } from "react-router-dom";<br/>import { fetchPosts } from "./PostsActions";<br/>import { IPost } from "./PostsData";<br/>import PostsList from "./PostsList";<br/>import { IAppState } from "./Store";</span><span id="c9aa" class="mi kx iq me b gy mq mk l ml mm">interface IProps extends RouteComponentProps {<br/>  loading: boolean;<br/>  posts: IPost[];<br/>}</span><span id="8351" class="mi kx iq me b gy mq mk l ml mm">class PostsPage extends React.Component&lt;IProps&gt; {<br/>  public componentDidMount() {<br/>    this.props.fetchPosts();<br/>  }</span><span id="f1a0" class="mi kx iq me b gy mq mk l ml mm">public render() {<br/>  ...<br/>    return (<br/>      &lt;div className="page-container"&gt;<br/> <br/>        &lt;PostsList<br/>          posts={this.props.posts}<br/>          loading={this.props.loading}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="a3b8" class="mi kx iq me b gy mq mk l ml mm">const mapStateToProps = (store: IAppState) =&gt; {<br/>  return {<br/>    loading: store.posts.isLoading,<br/>    posts: store.posts.posts<br/>  };<br/>};</span><span id="51a9" class="mi kx iq me b gy mq mk l ml mm">const mapDispatchToProps = (dispatch: any) =&gt; {<br/>  return {<br/>    fetchPosts: () =&gt; dispatch(fetchPosts())<br/>  };<br/>};</span><span id="da72" class="mi kx iq me b gy mq mk l ml mm">export default connect(<br/>  mapStateToProps,<br/>  mapDispatchToProps<br/>)(PostsPage);</span></pre><p id="b409" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mn mo mp me b">mapStateToProps</code>函数使用我们的<code class="fe mn mo mp me b">IAppState</code>类型，因此对商店状态的引用是强类型的。</p><p id="70c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">收尾</strong></p><p id="d7f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在现有的React项目内部集成TypeScript并没有人们想象的那么可怕。当然，当你开始创业公司的开发过程时，最好生成新项目，并在最早阶段使用TypeScript，但无论如何，现在你已经准备好接受挑战了:)</p></div></div>    
</body>
</html>