<html>
<head>
<title>Learning JavaScript by Implementing Lodash Methods — Type Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现Lodash方法学习JavaScript类型检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-type-checks-76f1a8f556d9?source=collection_archive---------14-----------------------#2020-05-13">https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-type-checks-76f1a8f556d9?source=collection_archive---------14-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/53bab168dfdb1ec292e5cd171df8357e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MZ1mw5ZsizJlBhtN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@shscholten?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Simone Scholten</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="58c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="baf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何实现一些Lodash方法来进行类型检查。</p><h1 id="cdc5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">isBoolean</code></h1><p id="20a4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">isBoolean</code>方法检查一个值是否是布尔值。</p><p id="6df4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很容易地用<code class="fe lz ma mb mc b">typeof</code>操作符检查一个值是否是布尔值。例如，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c342" class="mq lc iq mc b gy mr ms l mt mu">const isBoolean = val =&gt; typeof val === 'boolean'</span></pre><p id="45a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们只是使用了<code class="fe lz ma mb mc b">typeof</code>操作符来检查<code class="fe lz ma mb mc b">val</code>是不是布尔型。</p><p id="1b31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="93ef" class="mq lc iq mc b gy mr ms l mt mu">const result = isBoolean(true);</span></pre><p id="d0c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">true</code>，因为<code class="fe lz ma mb mc b">true</code>是布尔值。否则，如果我们运行:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ec1d" class="mq lc iq mc b gy mr ms l mt mu">const result = isBoolean(1);</span></pre><p id="b48f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">false</code>，因为1不是布尔值。</p><h1 id="d4c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">isArrayBuffer</code></h1><p id="8040" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">isArrayBuffer</code>检查一个对象是否是<code class="fe lz ma mb mc b">ArrayBuffer</code>构造函数的实例。我们可以使用对象的<code class="fe lz ma mb mc b">constructor.name</code>属性来进行检查。</p><p id="415e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以编写自己的函数来做同样的事情，如下所示:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c488" class="mq lc iq mc b gy mr ms l mt mu">const isArrayBuffer = val =&gt; val.constructor.name === 'ArrayBuffer'</span></pre><p id="dd09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们只是使用了<code class="fe lz ma mb mc b">constructor.name</code>属性来检查一个对象是否是<code class="fe lz ma mb mc b">ArrayBuffer</code>构造函数的实例。</p><p id="dca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe lz ma mb mc b">instanceof</code>操作符来检查<code class="fe lz ma mb mc b">val</code>是否是<code class="fe lz ma mb mc b">ArrayBuffer</code>的实例，如下所示:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3d21" class="mq lc iq mc b gy mr ms l mt mu">const isArrayBuffer = val =&gt; val instanceof ArrayBuffer</span></pre><p id="0386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="11c6" class="mq lc iq mc b gy mr ms l mt mu">const result = isArrayBuffer(new ArrayBuffer());</span></pre><p id="2442" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe lz ma mb mc b">result</code>应该是<code class="fe lz ma mb mc b">true</code>，因为它是<code class="fe lz ma mb mc b">ArrayBuffer</code>的一个实例。</p><h1 id="3f9f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">isArrayLike</code></h1><p id="d43f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">isArrayLike</code>方法通过检查<code class="fe lz ma mb mc b">length</code>属性是否存在以及其值是否大于或等于0或者小于或等于<code class="fe lz ma mb mc b">Number.MAX_SAFE_INTEGER</code>来检查对象是否是类似数组的对象。</p><p id="6406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据这些标准，我们可以实现自己的<code class="fe lz ma mb mc b">isArrayLike</code>函数，如下所示:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e13f" class="mq lc iq mc b gy mr ms l mt mu">const isArrayLike = val =&gt; typeof val.length === 'number' &amp;&amp; val.length &gt;= 0 &amp;&amp; val.length &lt;= Number.MAX_SAFE_INTEGER</span></pre><p id="5665" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用<code class="fe lz ma mb mc b">typeof</code>操作符检查<code class="fe lz ma mb mc b">val.length</code>是否是一个数字。然后我们检查<code class="fe lz ma mb mc b">val.length</code>是否在0和<code class="fe lz ma mb mc b">Number.MAX_SAFE_INTEGER</code>之间。</p><p id="2ff6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们如下运行我们的<code class="fe lz ma mb mc b">isArrayLike</code>函数:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d0d2" class="mq lc iq mc b gy mr ms l mt mu">const result = isArrayLike('foo');</span></pre><p id="3712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">true</code>，因为一个字符串有一个介于0和<code class="fe lz ma mb mc b">Number.MAX_SAFE_INTEGER</code>之间的<code class="fe lz ma mb mc b">length</code>属性。</p><p id="b032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们用1如下调用<code class="fe lz ma mb mc b">isArrayLike</code>:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="369c" class="mq lc iq mc b gy mr ms l mt mu">const result = isArrayLike(1);</span></pre><p id="aa00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">false</code>，因为1没有<code class="fe lz ma mb mc b">length</code>属性。</p><h1 id="3514" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">isElement</code></h1><p id="a0c7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">方法检查一个对象是否是一个HTML元素。由于所有HTML元素都是<code class="fe lz ma mb mc b">HTMLElement</code>构造函数的实例，我们可以使用<code class="fe lz ma mb mc b">instanceof</code>操作符来检查一个对象是否是该构造函数的实例，如下所示:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d3ff" class="mq lc iq mc b gy mr ms l mt mu">const isElement = obj =&gt; obj instanceof HTMLElement</span></pre><p id="d5c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过检查<code class="fe lz ma mb mc b">obj</code>是否是<code class="fe lz ma mb mc b">HTMLElement</code>的实例来检查它是否是一个元素。</p><p id="bf55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们如下运行它时:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="42eb" class="mq lc iq mc b gy mr ms l mt mu">const result = isElement(document.body);</span></pre><p id="77cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">true</code>，因为<code class="fe lz ma mb mc b">document.body</code>是一个HTML元素，这意味着它是<code class="fe lz ma mb mc b">HTMLElement</code>构造函数的一个实例。</p><p id="dab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们这样称呼它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c7d1" class="mq lc iq mc b gy mr ms l mt mu">const result = isElement('foo');</span></pre><p id="fa4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">false</code>，因为它不是<code class="fe lz ma mb mc b">HTMLElement</code>对象。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/eced2b4e4423a8efc562bf8fb248d53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b5ZT7RSEqlWNbN1r"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@maxsaeling?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Saeling</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a904" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">isEmpty</code></h1><p id="ea5d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash的<code class="fe lz ma mb mc b">isEmpty</code>方法检查对象、集合、映射和集合是否为空对象。</p><p id="2e02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果对象没有可枚举的自身属性，则对象为空。类似于数组的值，如<code class="fe lz ma mb mc b">arguments</code>，数组，字符串等。被认为是空的是<code class="fe lz ma mb mc b">length</code>为0。</p><p id="f115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果地图和集合的<code class="fe lz ma mb mc b">length</code>为0，则认为它们是空的。</p><p id="6155" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">明确定义条件后，我们可以编写自己的函数来执行<code class="fe lz ma mb mc b">isEmpty</code>检查。</p><p id="7e25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现自己的<code class="fe lz ma mb mc b">isEmpty</code>函数:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5413" class="mq lc iq mc b gy mr ms l mt mu">const isEmpty = obj =&gt; {<br/>  if (typeof obj.length === 'number') {<br/>    return obj.length === 0;<br/>  } else if (obj instanceof Map || obj instanceof Set) {<br/>    return obj.size === 0;<br/>  } else {<br/>    return Object.keys(obj).length === 0;<br/>  }<br/>}</span></pre><p id="b989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们检查<code class="fe lz ma mb mc b">length</code>属性是否是一个数字，以检查<code class="fe lz ma mb mc b">obj</code>是否是一个类似数组的对象。如果是，那么我们返回<code class="fe lz ma mb mc b">obj.length === 0</code>。</p><p id="8427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lz ma mb mc b">obj</code>是<code class="fe lz ma mb mc b">Map</code>或<code class="fe lz ma mb mc b">Set</code>构造函数的实例，我们可以检查<code class="fe lz ma mb mc b">size</code>属性而不是<code class="fe lz ma mb mc b">length</code>属性。</p><p id="8583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们使用带有<code class="fe lz ma mb mc b">obj</code>的<code class="fe lz ma mb mc b">Object.keys</code>作为参数，获取<code class="fe lz ma mb mc b">length</code>属性并检查它是否为0。</p><p id="4f3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们这样称呼它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f237" class="mq lc iq mc b gy mr ms l mt mu">const result = isEmpty('');</span></pre><p id="c686" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">true</code>，因为一个空字符串的长度为0。</p><h1 id="6323" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="cc34" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用<code class="fe lz ma mb mc b">typeof</code>操作符对原始值进行类型检查。对于对象，最好使用<code class="fe lz ma mb mc b">instanceof</code>操作符以字符串形式获取构造函数的名称。</p><p id="af0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得类似数组的对象的大小，我们使用了<code class="fe lz ma mb mc b">length</code>属性。否则，我们对<code class="fe lz ma mb mc b">Map</code>和<code class="fe lz ma mb mc b">Set</code>实例使用<code class="fe lz ma mb mc b">size</code>属性。</p><h2 id="f26a" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="140a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="dc87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>并附上您的中级用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>