<html>
<head>
<title>Do You Write Better JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你写的JavaScript更好吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/do-you-write-better-javascript-a75e393d8e09?source=collection_archive---------9-----------------------#2020-11-22">https://javascript.plainenglish.io/do-you-write-better-javascript-a75e393d8e09?source=collection_archive---------9-----------------------#2020-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c67" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">成为一名注重性能的开发人员</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/30ac5b5237fdc98eda25ab93eb36ed0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vfeSJRUfWZGEHmX5"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@krakenimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">krakenimages</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="542d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为开发人员，担心我们构建的应用程序的<em class="ls">性能</em>是必不可少的。<strong class="ky ir">内存管理</strong>是影响应用程序性能的主要因素之一。很多时候，JavaScript开发人员往往不会有意识地考虑内存管理，因为JavaScript会在创建对象时自动分配内存空间，并在不使用时将其作为垃圾收集起来。JavaScript中这些垃圾收集的幕后行为可能会导致很多混乱。进一步阅读可以更好地理解这一点。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="91e7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">内存生命周期</strong></h1><p id="543b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">几乎所有编程语言的内存生命周期都包含三个步骤:</p><ol class=""><li id="d20c" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">分配您需要的内存</li><li id="61e8" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">使用分配的内存(读、写)</li><li id="9c5d" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">当不再需要分配的内存时，释放它</li></ol><p id="6748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果开发人员不明白这些步骤是如何工作的，他们很容易出现糟糕的代码，从而导致<strong class="ky ir">内存泄漏</strong>。内存泄漏是一种即使不再需要某个对象，内存也不会被释放的情况。</p><p id="2454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们仔细看看这些步骤。</p><h2 id="d8da" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated"><strong class="ak">JavaScript中的内存分配</strong></h2><p id="10df" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">内存在以下情况下分配:</p><ul class=""><li id="38b3" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nx nd ne nf bi translated">当值被初始化时</li></ul><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="c354" class="nl mb iq nz b gy od oe l of og">let num = 123;<br/>let st = 'abc';<br/>let arr = [1,2,3];</span></pre><ul class=""><li id="2f39" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nx nd ne nf bi translated">使用函数调用。</li></ul><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="72f4" class="nl mb iq nz b gy od oe l of og">let date = new Date(); // creates a Date object and allocates memory<br/>let element = document.createElement(‘div’); <br/>// allocates a DOM element</span></pre><h2 id="95e6" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated"><strong class="ak">使用分配的内存</strong></h2><p id="7d1c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">每当读取或写入这些值时，就会使用内存。这些值可以是任何变量、函数，甚至是传递给函数的对象。</p><h2 id="e56f" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated"><strong class="ak">释放分配的内存</strong></h2><p id="6899" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">大多数低级语言都有手动分配或释放内存的方法，比如在C语言中我们有<code class="fe oh oi oj nz b">malloc()</code>和<code class="fe oh oi oj nz b">free()</code>。但是，在JavaScript中，这是使用一种叫做<strong class="ky ir">垃圾收集(GC) </strong>的机制自动发生的。垃圾收集器独自完成内存生命周期中的三个步骤。当GC试图判断是否不再需要某个内存时，问题就出现了。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="def7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">垃圾收集</strong></h1><p id="b515" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">每个垃圾收集算法使用的一个基本概念是<strong class="ky ir">引用</strong>。如果一个对象可以访问另一个对象，那么它就可以被称为引用。</p><p id="e5c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是用于垃圾收集的几种算法:</p><h2 id="9df7" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated"><strong class="ak"> 1。引用计数垃圾收集</strong></h2><p id="f2b6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这是最简单和最基本的算法之一，只计算与任何对象相关的引用数。如果一个对象根本没有引用，那么它就作为<strong class="ky ir">垃圾</strong>被收集。这种算法最常见的用法之一是在IE 6和IE 7中，这种算法用于DOM对象。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="be0a" class="nl mb iq nz b gy od oe l of og">let a = {<br/>  b: {<br/>    c: 'Harsha'<br/>  }<br/>};</span><span id="be13" class="nl mb iq nz b gy ok oe l of og">// 2 objects are created. One is referenced by the other as one of // its properties.</span><span id="d826" class="nl mb iq nz b gy ok oe l of og">// The other is referenced by virtue of being assigned to the      // variable 'a'.</span><span id="3046" class="nl mb iq nz b gy ok oe l of og">let z = a.b; // Reference to ‘b’ property of the object.</span><span id="ce8b" class="nl mb iq nz b gy ok oe l of og">// This object now has 2 references: one as a property,<br/>// the other as the ‘z’ variable.</span><span id="6c4b" class="nl mb iq nz b gy ok oe l of og">a = 'HarshaVardhan'; //The object initially had json and now it has // lost all references and it’s garbage collected</span><span id="3b15" class="nl mb iq nz b gy ok oe l of og">z = null; // The ‘b’ property of the object originally in a has zero // references to it. It can be garbage collected.</span></pre><p id="64b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个算法有一个已知的限制——<strong class="ky ir">循环引用</strong>。当两个对象彼此参照创建时，就会出现循环参照，从而形成一个循环。因为每个对象总是有一个引用，所以它永远不会被垃圾收集，从而导致<strong class="ky ir">内存泄漏</strong>。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="a198" class="nl mb iq nz b gy od oe l of og">function CircularRef() {<br/>  let obj_1 = {};<br/>  let obj_2 = {};<br/>  <br/>  // obj_1 references obj_2<br/>  obj_1.object = obj_2;</span><span id="6fb9" class="nl mb iq nz b gy ok oe l of og">  // obj_2 references obj_1<br/>  obj_2.object = obj_1;</span><span id="6b75" class="nl mb iq nz b gy ok oe l of og">  return ‘Memory leak’;<br/>}</span><span id="9ec7" class="nl mb iq nz b gy ok oe l of og">CircularRef();</span></pre><h2 id="de17" class="nl mb iq bd mc nm nn dn mg no np dp mk lf nq nr mm lj ns nt mo ln nu nv mq nw bi translated"><strong class="ak"> 2。标记和清除算法</strong></h2><p id="e705" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">该算法通过仅考虑任何对象的可达性来简化问题。在这个算法中，垃圾收集器从全局对象(又名“根”)开始，然后相应地标记可到达和不可到达的对象。这里，循环引用不再是一个问题。大多数现代浏览器都使用这种算法。唯一的限制是，我们没有办法像在c语言中那样手动释放内存。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8201" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">结论</strong></h1><p id="be02" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">理解如何管理内存至关重要，因为这有助于更好地理解JavaScript如何工作，并帮助您更好地编码，而不必担心应用程序的性能。</p><p id="38fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p><p id="4e1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">愿GC与你同在:)</p><h1 id="87a0" class="ma mb iq bd mc md ol mf mg mh om mj mk jw on jx mm jz oo ka mo kc op kd mq mr bi translated"><strong class="ak">参考</strong></h1><div class="oq or gp gr os ot"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">内存管理</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">像C这样的低级语言有手工内存管理原语，比如malloc()和free()。相比之下…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">developer.mozilla.org</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div></div></div>    
</body>
</html>