<html>
<head>
<title>Rate limiting API calls — sometimes a Bottleneck is a good thing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">速率限制API调用——有时瓶颈是一件好事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rate-limiting-api-calls-sometimes-a-bottleneck-is-a-good-thing-b7fe26e916f1?source=collection_archive---------3-----------------------#2019-10-18">https://javascript.plainenglish.io/rate-limiting-api-calls-sometimes-a-bottleneck-is-a-good-thing-b7fe26e916f1?source=collection_archive---------3-----------------------#2019-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dbbb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是瓶颈，为什么我的编码生涯中需要它？</h2></div><p id="1dc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你曾经使用过第三方API，你会遇到这样的问题:你对一个API进行了大量的调用，但它并没有完成你想要的。您可能会得到一个有用的错误，如429——太多的请求或一些不太有用的错误，如ECONNRESET</p><p id="2b71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管是哪种情况，作为API的消费者，你只能在一定的时间内发出一定数量的请求，或者你可以发出的并发请求的数量是有限的。</p><p id="b217" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，您的代码可能如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b9e6" class="lk ll iq lg b gy lm ln l lo lp">const axios = require('axios');</span><span id="9b7b" class="lk ll iq lg b gy lq ln l lo lp">async function getMyData(data){<br/>  const axiosConfig = {<br/>    url: '<a class="ae lr" href="https://really.important/api'" rel="noopener ugc nofollow" target="_blank">https://really.important/api'</a>,<br/>    method: 'post',<br/>    data<br/>  }<br/>  return axios(axiosConfig)<br/>}</span><span id="bfe4" class="lk ll iq lg b gy lq ln l lo lp">async function getAllResults(){</span><span id="4d9e" class="lk ll iq lg b gy lq ln l lo lp">const sourceIds = []</span><span id="f2dc" class="lk ll iq lg b gy lq ln l lo lp">// Just some code to let us create a big dataset<br/>  const count = 1000000;<br/>  for(let i = 0; i &lt; count; i++){<br/>    sourceIds.push({<br/>      id: i<br/>    });<br/>  }</span><span id="bc30" class="lk ll iq lg b gy lq ln l lo lp">// Map over all the results and call our pretend API, stashing the promises in a new array<br/>  const allThePromises = sourceIds.map(item =&gt; {<br/>    return getMyData(item);<br/>  })</span><span id="df66" class="lk ll iq lg b gy lq ln l lo lp">try{<br/>    const results = await Promise.all(allThePromises);<br/>    console.log(results);<br/>  }<br/>  catch(err){<br/>    console.log(err);<br/>  }</span><span id="75b5" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="0676" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里将要发生的是，代码将尽可能快地调用1000000次，所有请求将在很短的时间内发生(在我的MacBook Pro上是&lt; 700ms)</p><p id="9b56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Understandably, some API owners might be a little upset by this as it’s creating a heavy load.</p><h2 id="fafd" class="lk ll iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">What do we need to do?</h2><p id="db8b" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">We need to be able to limit the number of requests we’re making, potentially both in terms of the number of API calls in a space of time and in terms of the number of concurrent requests.</p><p id="d750" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">I’d encourage you to attempt to roll your own solution as a learning exercise. For example, there is a reasonably simple solution that can get you out of a hole using setInterval. What I think you’ll find is that building a reliable solution that limits rate and concurrency is actually trickier than it looks and requires you to build and manage queues. It’s even more complicated if you’re clustering.</p><p id="435d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">We can instead turn to a gem of a package on NPM — Bottleneck<br/><a class="ae lr" href="https://www.npmjs.com/package/bottleneck" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/bottleneck</a></p><p id="a659" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作者将此描述为:</p><p id="ecb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">瓶颈是Node.js和浏览器的轻量级、零依赖的任务调度器和速率限制器。</em></p><p id="e91a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你要做的是创建一个“限制器”，并用它来包装你想要速率限制的函数。然后，您只需调用受限版本。</p><p id="1251" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们之前的代码变成了:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b39b" class="lk ll iq lg b gy lm ln l lo lp">const axios = require('axios');<br/>const Bottleneck = require('bottleneck');</span><span id="e10e" class="lk ll iq lg b gy lq ln l lo lp">const limiter = Bottleneck({<br/>  minTime: 200<br/>});</span><span id="e905" class="lk ll iq lg b gy lq ln l lo lp">async function getMyData(data){<br/>  const axiosConfig = {<br/>    url: '<a class="ae lr" href="https://really.important/api'" rel="noopener ugc nofollow" target="_blank">https://really.important/api'</a>,<br/>    method: 'post',<br/>    data<br/>  }<br/>  return axios(axiosConfig)<br/>}</span><span id="c066" class="lk ll iq lg b gy lq ln l lo lp">const throttledGetMyData = limiter.wrap(getMyData);</span><span id="b69d" class="lk ll iq lg b gy lq ln l lo lp">async function getAllResults(){</span><span id="0f12" class="lk ll iq lg b gy lq ln l lo lp">const sourceIds = []</span><span id="95d9" class="lk ll iq lg b gy lq ln l lo lp">// Just some code to let us create a big dataset<br/>  const count = 1000000;<br/>  for(let i = 0; i &lt; count; i++){<br/>    sourceIds.push({<br/>      id: i<br/>    });<br/>  }</span><span id="3e8c" class="lk ll iq lg b gy lq ln l lo lp">// Map over all the results and call our pretend API, stashing the promises in a new array<br/>  const allThePromises = sourceIds.map(item =&gt; {<br/>    return throttledGetMyData(item);<br/>  })</span><span id="f884" class="lk ll iq lg b gy lq ln l lo lp">try{<br/>    const results = await Promise.all(allThePromises);<br/>    console.log(results);<br/>  }<br/>  catch(err){<br/>    console.log(err);<br/>  }</span><span id="c37a" class="lk ll iq lg b gy lq ln l lo lp">}</span><span id="e3bd" class="lk ll iq lg b gy lq ln l lo lp">getAllResults()</span></pre><p id="0605" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们已经创建了一个带有minTime属性的限制器。这定义了请求之间必须经过的最小毫秒数。我们有200个，所以我们每秒发出5个请求。</p><p id="1145" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用限制器包装我们的函数，并调用包装版本:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="da8c" class="lk ll iq lg b gy lm ln l lo lp">const throttledGetMyData = limiter.wrap(getMyData);<br/>...<br/>  const allThePromises = sourceIds.map(item =&gt; {<br/>    return throttledGetMyData(item);<br/>  })</span></pre><p id="3411" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的请求有可能花费的时间超过minTime，您也可以通过如下设置来限制并发请求的数量:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="df89" class="lk ll iq lg b gy lm ln l lo lp">const limiter = Bottleneck({<br/> minTime: 200,<br/> maxConcurrent: 1,<br/>});</span></pre><p id="5f18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们将确保一次只有一个请求被提交。</p><h2 id="3a49" class="lk ll iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">它还能做什么？</h2><p id="4862" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">设置瓶颈函数有许多选项。您可以使用库选项在一段时间内限制速率，例如，每60秒最多发送100个请求。或者，发送第一批请求，然后每隔x秒发送一批请求。</p><p id="a4f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NPM的文档非常好，所以我建议你阅读它，以充分了解这个软件包的功能，以及当事情不像你预期的那样运行时的问题。</p><h2 id="a379" class="lk ll iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">包扎</h2><p id="32ed" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">如果您曾经需要一个高度灵活的包来处理如何限制对API的调用，那么瓶颈就是您的朋友。</p><figure class="lb lc ld le gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mp"><img src="../Images/054c91610ccaa528d1c1cc1cfeb349bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-Z6n9-q_2dGU1Gzj.png"/></div></div></figure><h2 id="6878" class="lk ll iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated"><strong class="ak">简明英语团队的一份说明</strong></h2><p id="f8a8" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意:<a class="ae lr" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kh ir">JavaScript in Plain English</strong></a><a class="ae lr" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kh ir">AI in Plain English</strong></a><a class="ae lr" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kh ir">UX in Plain English</strong></a><a class="ae lr" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kh ir">Python in Plain English</strong></a><strong class="kh ir"/>——谢谢，继续学习！我们还推出了一个YouTube，希望你能通过<a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="6c5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae lr" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">submissions @ plain English . io</strong></a><strong class="kh ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>