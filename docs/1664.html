<html>
<head>
<title>Vue.js Render Functions — Functional Components and JSX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js渲染函数-功能组件和JSX</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vue-js-render-functions-functional-components-and-jsx-543a43b5a897?source=collection_archive---------3-----------------------#2020-04-12">https://javascript.plainenglish.io/vue-js-render-functions-functional-components-and-jsx-543a43b5a897?source=collection_archive---------3-----------------------#2020-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6f463c3470de23e5168dd1e9d9bac172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DzvqXKm-H3Lq9q2K"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@monmo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Montse Monmo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="92b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue.js是一个易于使用的web应用框架，我们可以用它来开发交互式前端应用。</p><p id="898a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究功能组件，并使用JSX而不是JavaScript来呈现HTML。</p><h1 id="9a7b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSX</h1><p id="500f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了让我们键入更少的代码，我们可以使用JSX而不是调用<code class="fe me mf mg mh b">createElement</code>来创建渲染函数。</p><p id="6c8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们必须添加使用下面的<code class="fe me mf mg mh b">package.json</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6eae" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  "name": "vanilla",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.html",<br/>  "scripts": {<br/>    "start": "parcel index.html --open",<br/>    "build": "parcel build index.html"<br/>  },<br/>  "dependencies": {<br/>    "<a class="ae kc" href="http://twitter.com/vue/babel-helper-vue-jsx-merg" rel="noopener ugc nofollow" target="_blank">@vue/babel-helper-vue-jsx-merg</a>e-props": "1.0.0",<br/>    "<a class="ae kc" href="http://twitter.com/vue/babel-preset-jsx" rel="noopener ugc nofollow" target="_blank">@vue/babel-preset-jsx</a>": "1.1.2"<br/>  },<br/>  "devDependencies": {<br/>    "<a class="ae kc" href="http://twitter.com/babel/core" rel="noopener ugc nofollow" target="_blank">@babel/core</a>": "7.2.0",<br/>    "parcel-bundler": "^1.6.1"<br/>  },<br/>  "keywords": []<br/>}</span></pre><p id="0d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们运行<code class="fe me mf mg mh b">npm i</code>来安装这些包。</p><p id="9a61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须这样做，因为我们必须添加一些节点包来将JSX转换成浏览器可以呈现的东西。</p><p id="6995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成代码后，我们将通过运行<code class="fe me mf mg mh b">npm start</code>来使用Parcel运行我们的应用程序。</p><p id="2579" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后将下面的预置添加到<code class="fe me mf mg mh b">.babelrc</code>项目的根文件夹中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f8ff" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  "presets": ["@vue/babel-preset-jsx"]<br/>}</span></pre><p id="e174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以创建一个<code class="fe me mf mg mh b">heading</code>组件，让我们改变标题的大小，如下所示:</p><p id="c32e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cd4a" class="mq lc iq mh b gy mr ms l mt mu">Vue.component("heading", {<br/>  render(createElement) {<br/>    return createElement(`h${this.size}`, this.$slots.default);<br/>  },<br/>  props: {<br/>    size: {<br/>      type: Number,<br/>      required: true<br/>    }<br/>  }<br/>});</span><span id="bd8e" class="mq lc iq mh b gy mv ms l mt mu">new Vue({<br/>  el: "#app",<br/>  render() {<br/>    return (<br/>      &lt;heading size={1}&gt;<br/>        &lt;span&gt;Hello&lt;/span&gt; world!<br/>      &lt;/heading&gt;<br/>    );<br/>  }<br/>});</span></pre><p id="d938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a5fb" class="mq lc iq mh b gy mr ms l mt mu">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;&lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="ee96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们运行<code class="fe me mf mg mh b">npm start</code>时，我们看到显示<code class="fe me mf mg mh b">Hello world!</code>。</p><h1 id="c8b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能组件</h1><p id="b1c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">功能组件让我们创建简单的组件，不管理任何状态，也没有生命周期方法。</p><p id="8aab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过传入<code class="fe me mf mg mh b">functional: true</code>来声明一个功能组件。</p><p id="b279" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下定义一个功能组件:</p><p id="c933" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b843" class="mq lc iq mh b gy mr ms l mt mu">Vue.component("functional-component", {<br/>  functional: true,<br/>  props: {<br/>    msg: {<br/>      type: String<br/>    }<br/>  },<br/>  render(createElement, context) {<br/>    return createElement("p", context.props.msg);<br/>  }<br/>});</span><span id="7116" class="mq lc iq mh b gy mv ms l mt mu">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    msg: "foo"<br/>  }<br/>});</span></pre><p id="971e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f89e" class="mq lc iq mh b gy mr ms l mt mu">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;functional-component msg="foo"&gt;&lt;/functional-component&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cf4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过将<code class="fe me mf mg mh b">functional</code>选项设置为<code class="fe me mf mg mh b">true</code>创建了一个名为<code class="fe me mf mg mh b">functional-component</code>的功能组件。</p><p id="2f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获得道具，必须使用<code class="fe me mf mg mh b">context</code>而不是<code class="fe me mf mg mh b">this</code>，因为功能组件是无状态的，所以没有<code class="fe me mf mg mh b">this</code>。</p><p id="813a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们应该会看到<code class="fe me mf mg mh b">foo</code>显示出来。</p><p id="2300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Vue 2.3.0之前，如果我们想在一个功能组件中接受props，就需要<code class="fe me mf mg mh b">props</code>选项。但是，从Vue 2.3.0开始，我们可以省略<code class="fe me mf mg mh b">props</code>，组件节点上的属性将被隐式提取为道具。</p><p id="fa0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从Vue 2.5.0开始，如果我们使用单文件组件，基于模板的功能组件可以用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="68c3" class="mq lc iq mh b gy mr ms l mt mu">&lt;template functional&gt; &lt;/template&gt;</span></pre><p id="efd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切都必须通过上下文传递，上下文是一个具有以下属性的对象:</p><ul class=""><li id="b275" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe me mf mg mh b">props</code> —带有提供道具的对象</li><li id="bbc9" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">children </code>—VNode子节点的数组</li><li id="7dd3" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">slots</code> —返回插槽对象的函数</li><li id="d26c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">scopedSlots</code> —具有作用域槽的对象。从Vue 2.6.0开始提供</li><li id="4386" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">data</code> —传入<code class="fe me mf mg mh b">createElement</code>第二个参数的数据对象</li><li id="a374" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">parent</code> —对父组件的引用</li><li id="9a10" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">listeners</code> —具有父注册侦听器的对象。这是<code class="fe me mf mg mh b">data.on</code>的别名，从Vue 2.3.0开始就有了</li><li id="eb69" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe me mf mg mh b">injections</code> —如果使用了<code class="fe me mf mg mh b">inject</code>。这将有解决的注射。从Vue 2.3.0开始提供</li></ul><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/257d24ea115c21efffd1f60612a17ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hMczfxztQX3yWkuH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matthew Henry</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="3263" class="mq lc iq bd ld nl nm dn lh nn no dp ll ko np nq lp ks nr ns lt kw nt nu lx nv bi translated">将属性和事件传递给子元素或组件</h2><p id="2141" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过<code class="fe me mf mg mh b">context.data</code>将整个选项对象传递给用<code class="fe me mf mg mh b">createElement</code>创建的子元素。</p><p id="9731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来创建一个按钮功能组件:</p><p id="9268" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="26b3" class="mq lc iq mh b gy mr ms l mt mu">Vue.component("functional-button", {<br/>  functional: true,<br/>  render(createElement, context) {<br/>    context.data = { ...context.data, domProps: { innerHTML: "Click Me" } };<br/>    return createElement("button", context.data, context.children);<br/>  }<br/>});</span></pre><p id="a050" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7345" class="mq lc iq mh b gy mr ms l mt mu">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>    &lt;style&gt;<br/>      .button {<br/>        background-color: yellow;<br/>      }<br/>    &lt;/style&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;functional-button class="button"&gt;&lt;/functional-button&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="0a2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe me mf mg mh b">domProps</code>来设置按钮的名称，然后将其合并到现有的<code class="fe me mf mg mh b">context.data</code>中。<code class="fe me mf mg mh b">context.data</code>具有从模板传递过来的属性。于是我们有了<code class="fe me mf mg mh b">class</code>的传承。表示<code class="fe me mf mg mh b">context.data.class</code>就是<code class="fe me mf mg mh b">'yellow'</code>。</p><p id="59a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们得到一个黄色的文本，里面有Click Me。</p><h2 id="c612" class="mq lc iq bd ld nl nm dn lh nn no dp ll ko np nq lp ks nr ns lt kw nt nu lx nv bi translated">插槽()与子插槽</h2><p id="cab8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们需要<code class="fe me mf mg mh b">slots().default</code>来获得没有名字的槽。我们需要<code class="fe me mf mg mh b">slots().name</code>来获得一个命名的槽。</p><p id="5d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="b31b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5bca" class="mq lc iq mh b gy mr ms l mt mu">Vue.component("functional-component", {<br/>  functional: true,<br/>  render(createElement, context) {<br/>    return createElement("div", {}, [<br/>      context.slots().foo,<br/>      context.slots().default<br/>    ]);<br/>  }<br/>});</span><span id="2405" class="mq lc iq mh b gy mv ms l mt mu">new Vue({<br/>  el: "#app"<br/>});</span></pre><p id="02d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3b9a" class="mq lc iq mh b gy mr ms l mt mu">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;functional-component&gt;<br/>        &lt;template v-slot:foo&gt;<br/>          first<br/>        &lt;/template&gt;<br/>        &lt;p&gt;second&lt;/p&gt;<br/>      &lt;/functional-component&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="3873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7e4" class="mq lc iq mh b gy mr ms l mt mu">first</span><span id="30fd" class="mq lc iq mh b gy mv ms l mt mu">second</span></pre><p id="7a99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显示在浏览器中，因为我们创建了一个<code class="fe me mf mg mh b">div</code>元素，数组中的<code class="fe me mf mg mh b">template</code>元素和<code class="fe me mf mg mh b">p</code>元素按此顺序排列。</p><p id="8519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">context.slots().foo</code>获取名为<code class="fe me mf mg mh b">foo</code>的插槽，<code class="fe me mf mg mh b">context.slots().default</code>获取没有名称的插槽。</p><h1 id="10b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3581" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用JSX而不是使用<code class="fe me mf mg mh b">createElement</code>来创建我们的VNodes来呈现HTML。为此，我们必须添加一些节点包来将JSX转换成浏览器可以呈现的东西。</p><p id="e2ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建没有状态的组件，我们可以通过将<code class="fe me mf mg mh b">functional</code>选项设置为<code class="fe me mf mg mh b">true</code>来创建功能组件，然后我们通过<code class="fe me mf mg mh b">render</code>函数中的第二个<code class="fe me mf mg mh b">context</code>参数来获取道具和其他数据。</p><h2 id="3c28" class="mq lc iq bd ld nl nm dn lh nn no dp ll ko np nq lp ks nr ns lt kw nt nu lx nv bi translated">用简单英语写的JavaScript的注释</h2><p id="e737" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">T5T7，我们会把你添加为作者。</a></p><p id="b8fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>