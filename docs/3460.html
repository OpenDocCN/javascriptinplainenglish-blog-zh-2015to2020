<html>
<head>
<title>Node.js Thread Pool Performance Limitations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js线程池性能限制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nodejs-thread-pool-performance-limitations-33e77811ff5b?source=collection_archive---------7-----------------------#2020-09-30">https://javascript.plainenglish.io/nodejs-thread-pool-performance-limitations-33e77811ff5b?source=collection_archive---------7-----------------------#2020-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="67b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点开任何一个在线Node.js教程，首先看到的就是“Node是单线程”的说法。我决定写这篇文章来表明情况并非总是如此。我觉得这句话被一遍又一遍地用来简化和抽象引擎盖下发生的事情。</p><p id="51f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">早在2009年，Ryan Dahl就提出了在浏览器之外执行JavaScript的想法。因此，他采用了当时最快的JavaScript引擎V8，并将其嵌入到一个他称之为Node的C++程序中。在他最初的演示中，他展示了下面这段代码:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="6d09" class="kr ks in kn b gy kt ku l kv kw"><strong class="kn io">var</strong> result = db.<strong class="kn io">query</strong>('SELECT * FROM table');</span><span id="3110" class="kr ks in kn b gy kx ku l kv kw">// Do something with the result</span></pre><p id="fadd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">他接着问道:</p><blockquote class="ky kz la"><p id="8870" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">"当这行代码运行时，你的web框架在做什么？"</p></blockquote><p id="8bfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在任何现代web应用程序中，我们都可以看到这样的代码一直在运行。CRUD请求是几乎所有API的核心，大多数CRUD操作的背后是一个数据库或文件系统。等待I/O需要数亿个CPU时钟周期。所以问题是，当CPU无所事事时，我们如何利用它呢？</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="f26a" class="lm ks in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Web服务器架构</h1><p id="2ac4" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">最初，Apache web服务器通过为每个进程分配一个线程来处理每个web请求。强加在操作系统上的内存指纹过于昂贵，而且这种方法的可扩展性也不好。为了解决这个问题，Apache引入了MPM工人模型，它开始用一个线程处理每个请求。这也不能很好地扩展，因为当在给定的CPU上负载平衡线程执行时，所有的上下文切换都必须发生。随着请求数量的增加，操作系统不得不花费大部分时间来决定10，000多个线程中的哪些应该在硬件上运行，而不是在每个线程中实际运行代码。</p><p id="deeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么Node如何解决这个问题呢？它使用异步事件驱动架构。这个想法是在一个线程中运行一个事件循环。应用程序代码在主线程上执行，所有繁重的工作(对开发人员来说是抽象的)都由操作系统的内核完成，或者在内核不支持的情况下在线程池中完成。Node中几乎所有的繁重工作都是由用<strong class="jm io"> C </strong>编写的<strong class="jm io"> Libuv </strong>库完成的。在这篇文章中，我不想深入Libuv的内部，而是想谈谈开发人员可能会因为线程池而遇到的性能限制。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="2b49" class="lm ks in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Node.js线程池</h1><p id="d1a5" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">为了避免性能问题，我们首先需要确定我们的瓶颈。第一步是弄清楚线程池中运行的是什么。<strong class="jm io"> Node使用线程池来处理操作系统(内核)不支持的高开销任务。</strong></p><p id="779e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如今，Node使用线程池来处理在以下模块中定义的操作:</p><ul class=""><li id="b698" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated"><strong class="jm io"> fs </strong>:文件系统I/O操作</li><li id="fe57" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io"> dns </strong> : DNS操作</li><li id="aabe" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io"> zlib </strong>:压缩操作</li><li id="958e" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io"> crypto </strong>:密码运算</li></ul><p id="5234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们知道了一些会导致瓶颈的模块，是时候找出瓶颈本身了。默认情况下，Libuv的线程池大小限制为4。这是在UV_THREADPOOL_SIZE变量中设置的。</p><p id="0047" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了展示这一点，我对加密库进行了一个小测试。考虑下面的程序，它使用基于密码的密钥派生函数(pbkdf2)。这个版本的程序在主线程上同步运行。</p><figure class="ki kj kk kl gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/6d6a68b73f63e4b88911f180698875dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9AOG1bcmL35nPCcLp2kgQ.png"/></div></div></figure><p id="615a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个程序中，我在主循环的每次迭代中调用pbkdf2Sync函数<em class="lb"> i </em>次。下面是程序的运行时间:</p><figure class="ki kj kk kl gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/aac334768403c452fb0ee7a41745e3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-X_ueDVXtt3Oba7yTXNsVw.png"/></div></div></figure><p id="49a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如所料，运行时间随着每次迭代而线性增长。平均来说，一次迭代需要大约90毫秒，因此20次迭代需要大约1，800毫秒。现在，让我们考虑同一程序的异步版本。</p><figure class="ki kj kk kl gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/4dc9b32739615d4fcb5d67c36d74e9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgN1is7P0RwmT378LwinrA.png"/></div></div></figure><p id="e876" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是异步版本的运行时间:</p><figure class="ki kj kk kl gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nl"><img src="../Images/ad1bd034508e6f01e408c2f964844627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXQsZZ_35F6C8DR3TdTNow.png"/></div></div></figure><p id="667c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这次我们看到了一个完全不同的图表。请注意，这次，运行我们的函数四次所需的时间几乎与运行一次相同。这是通过并行运行不同的函数调用实现的。与同步程序相比，这是一个巨大的性能提升。然而，当我们运行该函数五次时，有趣的事情发生了。请注意，运行该函数五次花费的时间几乎是运行四次的两倍。为什么会出现这种行为？这是因为Libuv强加的线程池大小。事实是Node正在安排五次回调。最初，线程池处于空闲状态，因此，这五个回调中的四个可以被线程获得并并行执行。一旦这四个线程中的任何一个被释放，第五个回调就被它获得并执行。这证明了即使节点代码是异步的，它的性能有时也会受到Libuv中可用线程数量的限制。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="6a1c" class="lm ks in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="a389" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">最后，开发人员需要格外小心如何在Node.js中编写CPU或IO密集型代码，因为尽管代码是异步的，但实际上运行时仅限于四个线程。通过如下方式运行程序，可以微调节点运行时并增加线程池大小:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="2ccf" class="kr ks in kn b gy kt ku l kv kw">SET UV_THREADPOOL_SIZE = 8 &amp;&amp; node server.js</span></pre><p id="8234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在这里访问本文中使用的代码:</p><p id="18c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nm" href="https://github.com/omarchedid95/nodejs_threadpool_performance" rel="noopener ugc nofollow" target="_blank">https://github . com/omarchedid 95/nodejs _ thread pool _ performance</a></p></div></div>    
</body>
</html>