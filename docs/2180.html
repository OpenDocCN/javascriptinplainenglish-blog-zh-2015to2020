<html>
<head>
<title>Object.freeze vs Object.seal — Immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Object.freeze vs Object.seal —不变性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-freeze-vs-object-seal-immutability-7c22f80aa8ae?source=collection_archive---------5-----------------------#2020-05-27">https://javascript.plainenglish.io/object-freeze-vs-object-seal-immutability-7c22f80aa8ae?source=collection_archive---------5-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d0f9" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Java Script语言</h2><div class=""/><div class=""><h2 id="cfeb" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">两个本地方法与不变性相关</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8e3e8f78f7bffe8e066d8f97be54e4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1n-sZ1kdhyX6Wf8_"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@christineashleydonaldson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christine Donaldson</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0646" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数据不变性在编程语言中一直非常重要，在JavaScript中也是如此。这里，有两个JavaScript方法可以部分保证不变性——object . freeze和Object.seal。</p><h1 id="8283" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">对象定义属性</h1><p id="2ecd" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在了解每一个<code class="fe my mz na nb b">freeze</code>和<code class="fe my mz na nb b">seal</code>之前，我们需要先知道Object中的<code class="fe my mz na nb b">defineProperty</code>方法是什么。当您或引擎在初始处理期间创建一个对象时，JavaScript会为新创建的对象提供基本属性，以处理来自外部的请求，例如访问或删除属性。</p><p id="537d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以修改或设置的属性如下。</p><ul class=""><li id="7b6e" class="nc nd iq lh b li lj ll lm lo ne ls nf lw ng ma nh ni nj nk bi translated">值—属性的值</li><li id="8d38" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">可枚举—如果为真，则允许属性可通过<code class="fe my mz na nb b">for-in</code>循环或<code class="fe my mz na nb b">Object.keys()</code>进行搜索。默认为<code class="fe my mz na nb b">false</code>。</li><li id="376f" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">可写-如果为false，则不能修改该属性。它在严格模式下抛出一个错误。默认为<code class="fe my mz na nb b">false</code>。</li><li id="08c0" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">可配置—如果为false，这将使对象的属性不可枚举、不可写、不可删除和不可配置。默认为<code class="fe my mz na nb b">false</code>。</li><li id="8e15" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">get —当您尝试访问属性时提前调用的函数。默认为<code class="fe my mz na nb b">undefined</code>。</li><li id="1c17" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">set —当您尝试为属性设置某个值时提前调用的函数。默认为<code class="fe my mz na nb b">undefined</code>。</li></ul><p id="04ee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我知道你会想我在说什么。所以我们来看一些简单的例子。</p><h2 id="7129" class="nq mc iq bd md nr ns dn mh nt nu dp ml lo nv nw mn ls nx ny mp lw nz oa mr iw bi translated">可列举的</h2><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="524e" class="nq mc iq nb b gy of og l oh oi">const obj = {};</span><span id="448f" class="nq mc iq nb b gy oj og l oh oi">Object.defineProperty(obj, 'a', {<br/>  value: 100,<br/><strong class="nb ja">  enumerable: false</strong><br/>});</span><span id="0393" class="nq mc iq nb b gy oj og l oh oi">for (const key in obj) {<br/>  console.log(key);<br/>}<br/>// undefined</span><span id="3cb2" class="nq mc iq nb b gy oj og l oh oi">Object.keys(obj);<br/>// []</span></pre><h2 id="c520" class="nq mc iq bd md nr ns dn mh nt nu dp ml lo nv nw mn ls nx ny mp lw nz oa mr iw bi translated">可写的</h2><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="d150" class="nq mc iq nb b gy of og l oh oi">const obj = {};</span><span id="fc3e" class="nq mc iq nb b gy oj og l oh oi">Object.defineProperty(obj, 'a', {<br/>  value: 100,<br/><strong class="nb ja">  writable: false</strong><br/>});</span><span id="9bb1" class="nq mc iq nb b gy oj og l oh oi">obj.a = 200;<br/>obj.a === 100; // true</span><span id="cad2" class="nq mc iq nb b gy oj og l oh oi">(() =&gt; {<br/>  'use strict';<br/>  obj.a = 100; <br/>  // TypeError in the strict mode<br/>})()</span></pre><h2 id="99d4" class="nq mc iq bd md nr ns dn mh nt nu dp ml lo nv nw mn ls nx ny mp lw nz oa mr iw bi translated">可配置的</h2><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="8412" class="nq mc iq nb b gy of og l oh oi">const obj = {};</span><span id="cff7" class="nq mc iq nb b gy oj og l oh oi">Object.defineProperty(obj, 'a', {<br/>  value: 100,<br/><strong class="nb ja">  configurable: false</strong><br/>});</span><span id="72aa" class="nq mc iq nb b gy oj og l oh oi">// <strong class="nb ja">1. non-enumerable</strong><br/>for (const key in obj) {<br/>  console.dir(key);<br/>}<br/>// undefined</span><span id="2d90" class="nq mc iq nb b gy oj og l oh oi">Object.keys(obj);<br/>// [</span><span id="9b54" class="nq mc iq nb b gy oj og l oh oi">// <strong class="nb ja">2. non-writable</strong><br/>(() =&gt; {<br/>  'use strict';<br/>  obj.a = 200;<br/>  // TypeError in the strict mode<br/>})()</span><span id="82fc" class="nq mc iq nb b gy oj og l oh oi">// 3. <strong class="nb ja">non-deletable</strong><br/>delete obj.a;<br/>obj.a === 100; // true</span></pre><p id="e14d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是当<code class="fe my mz na nb b">writable</code>或<code class="fe my mz na nb b">enumerable</code>为<code class="fe my mz na nb b">true</code>时，<code class="fe my mz na nb b">configurable: false</code>被忽略。</p><h1 id="560d" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">对象。海豹</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/c7f1b209d76f327f6e392ca8e252b737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8hPZaRH0h2uk2UpX"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@samuelsparkle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戸山 神奈</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a7d9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">听到“海豹”这个词，你会想到什么？“印章”的第一个意思是封闭信件或其他东西的邮票或蜡。在JavaScript中，<code class="fe my mz na nb b">Object.seal</code>也做和“海豹”一样的事情。</p><p id="f66f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe my mz na nb b">Object.seal</code>使传递给它的对象的所有属性不可配置。我们举个例子。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="73f3" class="nq mc iq nb b gy of og l oh oi">const obj = { a: 100 };<br/>Object.getOwnPropertyDescriptors(obj);</span><span id="2381" class="nq mc iq nb b gy oj og l oh oi">/* { <br/> *   a: { <br/> *        configurable: true,<br/> *        enumerable: true,<br/> *        value: 100,<br/> *        writable: true<br/> *      }<br/> * }<br/> * <br/> */</span><span id="e94d" class="nq mc iq nb b gy oj og l oh oi">Object.seal(obj);<br/>Object.getOwnPropertyDescriptors(obj);</span><span id="1455" class="nq mc iq nb b gy oj og l oh oi">/* { <br/> *   a: { <br/> *        <strong class="nb ja">configurable: false,</strong><br/> *        enumerable: true,<br/> *        value: 100,<br/> *        writable: true<br/> *      }<br/> * }<br/> * <br/> */</span><span id="234e" class="nq mc iq nb b gy oj og l oh oi">obj.a = 200;<br/>console.log(obj.a);<br/>// 200</span><span id="cc56" class="nq mc iq nb b gy oj og l oh oi">delete obj.a;<br/>console.log(obj.a);<br/>// 200</span><span id="86c6" class="nq mc iq nb b gy oj og l oh oi">obj.b = 500;<br/>console.log(obj.b);<br/>// undefined</span></pre><p id="ef74" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，对象<code class="fe my mz na nb b">obj</code>有一个属性值为100的属性。而<code class="fe my mz na nb b">obj</code>的初始描述符如上，<code class="fe my mz na nb b">configurable</code>、<code class="fe my mz na nb b">enumerable</code>、<code class="fe my mz na nb b">writable</code>都是<code class="fe my mz na nb b">true</code>。然后我用<code class="fe my mz na nb b">Object.seal</code>密封对象，看看哪些描述符被修改了，哪些没有——只有<code class="fe my mz na nb b">configurable</code>被修改为<code class="fe my mz na nb b">false</code>。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="13b3" class="nq mc iq nb b gy of og l oh oi">obj.a = 200;</span></pre><p id="86b4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">即使密封对象的<code class="fe my mz na nb b">configurable</code>现在为false，现有的属性值也更改为200。正如我前面解释过的，将<code class="fe my mz na nb b">configurable</code>设置为<code class="fe my mz na nb b">false</code>会使属性不可写，但是如果<code class="fe my mz na nb b">writable</code>显式为<code class="fe my mz na nb b">true</code>则不起作用。当你创建一个对象并设置一个新的属性时，默认情况下它有<code class="fe my mz na nb b">writable: true</code>。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="321f" class="nq mc iq nb b gy of og l oh oi">delete obj.a;</span></pre><p id="2be0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">密封对象使每个属性都不可配置，从而防止它们不可删除。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="92c2" class="nq mc iq nb b gy of og l oh oi">obj.b = 500;</span></pre><p id="bf3f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这在密封对象后失败了，但是为什么呢？当调用<code class="fe my mz na nb b">Object.seal</code>或<code class="fe my mz na nb b">Object.freeze</code>时，传递给它们的对象变成一个不可扩展的对象，这意味着你不能从中删除任何属性或向其中添加任何属性。</p><h1 id="40ae" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">对象.冻结</h1><p id="e1b4" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这比<code class="fe my mz na nb b">Object.seal</code>更多地限制了传递的对象。我们也举一个类似的例子。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="cb57" class="nq mc iq nb b gy of og l oh oi">const obj = { a: 100 };<br/>Object.getOwnPropertyDescriptors(obj);</span><span id="340a" class="nq mc iq nb b gy oj og l oh oi">/* { <br/> *   a: { <br/> *        configurable: true,<br/> *        enumerable: true,<br/> *        value: 100,<br/> *        writable: true<br/> *      }<br/> * }<br/> * <br/> */</span><span id="a9b0" class="nq mc iq nb b gy oj og l oh oi">Object.freeze(obj);<br/>Object.getOwnPropertyDescriptors(obj);</span><span id="5e0c" class="nq mc iq nb b gy oj og l oh oi">/* { <br/> *   a: { <br/> *        <strong class="nb ja">configurable: false,</strong><br/> *        enumerable: true,<br/> *        value: 100,<br/> *        <strong class="nb ja">writable: false</strong><br/> *      }<br/> * }<br/> * <br/> */</span><span id="3f66" class="nq mc iq nb b gy oj og l oh oi">obj.a = 200;<br/>console.log(obj.a);<br/>// 100</span><span id="3550" class="nq mc iq nb b gy oj og l oh oi">delete obj.a;<br/>console.log(obj.a);<br/>// 200</span><span id="24a4" class="nq mc iq nb b gy oj og l oh oi">obj.b = 500;<br/>console.log(obj.b);<br/>// undefined</span></pre><p id="713e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以和<code class="fe my mz na nb b">Object.seal</code>的区别在于<code class="fe my mz na nb b">writable</code>也被设置为<code class="fe my mz na nb b">false</code>，冻结后。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="9edc" class="nq mc iq nb b gy of og l oh oi">obj.a = 200;</span></pre><p id="a36b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，修改现有属性总是会失败。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="8ef4" class="nq mc iq nb b gy of og l oh oi">delete obj.a;</span></pre><p id="1e88" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">和<code class="fe my mz na nb b">Object.seal</code>一样，<code class="fe my mz na nb b">Object.freeze</code>也使得传递的对象不可配置，这使得其中的每个属性都不可删除。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="67e9" class="nq mc iq nb b gy of og l oh oi">obj.b = 500;</span></pre><p id="2cde" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">冻结对象还会使对象不可扩展。</p><h1 id="6fb2" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">他们有什么共同点？</h1><ol class=""><li id="3e8f" class="nc nd iq lh b li mt ll mu lo ol ls om lw on ma oo ni nj nk bi translated">传递的对象变得不可扩展，这意味着您不能添加新的属性。</li><li id="b5ce" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma oo ni nj nk bi translated">传递的对象中的每个元素都变得不可配置，这意味着您不能删除它们。</li><li id="4a78" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma oo ni nj nk bi translated">如果在“使用严格”模式下调用操作，例如在严格模式下调用<code class="fe my mz na nb b">obj.a = 500</code>，两种方法都可能抛出错误。</li></ol><h1 id="fdb7" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">比较</h1><p id="af0b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><code class="fe my mz na nb b">Object.seal</code>允许您修改属性，而<code class="fe my mz na nb b">Object.freeze</code>不能。</p><h1 id="badb" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">裂缝</h1><p id="f567" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><code class="fe my mz na nb b">Object.freeze</code>和<code class="fe my mz na nb b">Object.seal</code>在“实用”方面都有“瑕疵”，它们只冻结/封印了物体的第一个深度。</p><p id="5e3e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面是快速对比。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="bafd" class="nq mc iq nb b gy of og l oh oi">const obj = {<br/>  foo: {<br/>    bar: 10<br/>  }<br/>};</span></pre><p id="ed8d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在<code class="fe my mz na nb b">obj</code>里面有了嵌套的对象，<code class="fe my mz na nb b">foo</code>。它里面有<code class="fe my mz na nb b">bar</code>。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="310e" class="nq mc iq nb b gy of og l oh oi">Object.getOwnPropertyDescriptors(obj);<br/>/* { <br/> *   foo: { <br/> *        configurable: true,<br/> *        enumerable: true,<br/> *        value: {bar: 10},<br/> *        writable: true<br/> *      }<br/> * }<br/> */</span><span id="eb76" class="nq mc iq nb b gy oj og l oh oi">Object.getOwnPropertyDescriptors(obj.foo);<br/>/* { <br/> *   bar: { <br/> *        configurable: true,<br/> *        enumerable: true,<br/> *        value: 10,<br/> *        writable: true<br/> *      }<br/> * }<br/> */</span></pre><p id="9269" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">密封或冷冻后，</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="2b4f" class="nq mc iq nb b gy of og l oh oi">Object.seal(obj);<br/>Object.freeze(obj);</span><span id="99c8" class="nq mc iq nb b gy oj og l oh oi">// Either way is fine for this test</span></pre><p id="c3b4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们看看描述符是如何改变的。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="5b16" class="nq mc iq nb b gy of og l oh oi">Object.getOwnPropertyDescriptors(obj);<br/>/* { <br/> *   foo: { <br/> *        <strong class="nb ja">configurable: false</strong>,<br/> *        enumerable: true,<br/> *        value: {bar: 10},<br/> *        <strong class="nb ja">writable: false</strong><br/> *      }<br/> * }<br/> */</span><span id="f927" class="nq mc iq nb b gy oj og l oh oi">Object.getOwnPropertyDescriptors(obj.foo);<br/>/* { <br/> *   bar: { <br/> *        configurable: true,<br/> *        enumerable: true,<br/> *        value: 10,<br/> *        writable: true<br/> *      }<br/> * }<br/> */</span></pre><p id="8bc4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe my mz na nb b">foo</code>的描述符被更改，但<code class="fe my mz na nb b">obj.foo</code>的嵌套对象被更改。这意味着它仍然是可修改的。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="a9b1" class="nq mc iq nb b gy of og l oh oi">obj.foo = { bar: 50 };<br/>// Doesn't work</span></pre><p id="2091" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因为<code class="fe my mz na nb b">obj.foo</code>不允许你改变它的值，因为它被冻结了，</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="7c26" class="nq mc iq nb b gy of og l oh oi">obj.foo.bar = 50;<br/>// It works</span></pre><p id="418a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe my mz na nb b">obj.foo.bar</code>仍然允许你改变它的值，因为它没有被冻结。</p><p id="f0a6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">那么如何将对象冻结/密封到最底层的嵌套对象呢？MDN建议您使用<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#What_is_shallow_freeze" rel="noopener ugc nofollow" target="_blank">解决方法</a>来解决这个问题。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="153c" class="nq mc iq nb b gy of og l oh oi">function deepFreeze(object) {</span><span id="4105" class="nq mc iq nb b gy oj og l oh oi">  // Retrieve the property names defined on object<br/>  var propNames = Object.getOwnPropertyNames(object);</span><span id="c9e8" class="nq mc iq nb b gy oj og l oh oi">  // Freeze properties before freezing self<br/>  <br/>  for (let name of propNames) {<br/>    let value = object[name];</span><span id="efb8" class="nq mc iq nb b gy oj og l oh oi">    if(value &amp;&amp; typeof value === "object") { <br/>      deepFreeze(value);<br/>    }<br/>  }</span><span id="bb8b" class="nq mc iq nb b gy oj og l oh oi">  return Object.freeze(object);<br/>}</span></pre><p id="0ea8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">测试结果如下。</p><pre class="kp kq kr ks gt ob nb oc od aw oe bi"><span id="b3f7" class="nq mc iq nb b gy of og l oh oi">const obj = { foo: { bar: 10 } };<br/>deepFreeze(obj);</span><span id="69ee" class="nq mc iq nb b gy oj og l oh oi">obj.foo = { bar: 50 };<br/>// Doesn't work</span><span id="abf3" class="nq mc iq nb b gy oj og l oh oi">obj.foo.bar = 50;<br/>// Doesn't work</span></pre><h1 id="1d87" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">结论</h1><p id="d1c0" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><code class="fe my mz na nb b">Object.freeze</code>和<code class="fe my mz na nb b">Object.seal</code>绝对是有用的方法。但是你应该考虑到嵌套的对象也应该被冻结，使用<code class="fe my mz na nb b">deepFreeze</code>。</p><h1 id="2797" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="68b0" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae le" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae le" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">订阅我们的YouTube频道</strong> </a> <strong class="lh ja">来表达你的爱吧！</strong></p><h1 id="2c02" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">资源</h1><ul class=""><li id="61dd" class="nc nd iq lh b li mt ll mu lo ol ls om lw on ma nh ni nj nk bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">object . defined property—MDN</a></li><li id="d159" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank"> Object.freeze — MDN </a></li><li id="7081" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" rel="noopener ugc nofollow" target="_blank"> Object.seal — MDN </a></li><li id="28f1" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" rel="noopener ugc nofollow" target="_blank">object . getownpropertysdescriptors—MDN</a></li><li id="f90e" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated"><a class="ae le" href="https://stackoverflow.com/questions/23590502/difference-between-configurable-and-writable-attributes-of-an-object" rel="noopener ugc nofollow" target="_blank">对象的可配置和可写属性之间的差异</a></li></ul></div></div>    
</body>
</html>