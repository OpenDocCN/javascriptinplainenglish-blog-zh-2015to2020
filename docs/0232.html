<html>
<head>
<title>Programming Patterns with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩的编程模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/programming-patterns-with-react-hooks-329c22b96461?source=collection_archive---------0-----------------------#2019-08-31">https://javascript.plainenglish.io/programming-patterns-with-react-hooks-329c22b96461?source=collection_archive---------0-----------------------#2019-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="450f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React Hooks 的引入寻求了一种更具声明性的编程风格，并促进了功能组件的使用。</p><p id="4605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，随着我们应用程序的扩展，我们的代码变得更加难以理解和维护。重复的代码、不同步的数据和难以理解的树形结构很快困扰着我们精心设计的组件。</p><p id="7ca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过引入编程模式，我们可以改进应用程序的架构，并确保我们的组件不会因为无关的逻辑而变得臃肿。</p><h1 id="d743" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">概述</strong></h1><ol class=""><li id="a025" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">什么是编程模式？</li><li id="d1e3" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">为什么要使用编程模式？</li><li id="4301" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">带有反应钩子的观察者模式。</li><li id="74c4" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">带有React挂钩的提供者模式。</li><li id="9045" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">免责声明！</li></ol><h1 id="4069" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">什么是编程模式？</strong></h1><blockquote class="ma mb mc"><p id="142c" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated"><strong class="jp ir"/>软件设计模式是一种通用的、可重用的解决方案，用于解决软件设计中给定环境下的常见问题<strong class="jp ir">——</strong><em class="iq">维基百科</em></p></blockquote><p id="c618" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编程模式只是一个定义良好的解决方案，您可以将它应用到您的代码中，用于各种情况。</p><p id="0b5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编程模式对任何语言都是不可知的——它们不包括您需要编写的代码，而是概述您可以使用什么类/对象以及它们如何相互影响。在前端开发中，有3种主要类型的模式。</p><p id="f8f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">创造</strong>——给你创造对象的灵活性的模式</p><p id="1a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结构化</strong>——帮助我们构建类和对象的模式——什么属于什么？一个对象如何访问另一个对象？</p><p id="d7a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">行为</strong>——与对象之间的交流特别相关的模式</p><p id="40b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a></p><h1 id="c67a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为什么要使用编程模式？</h1><p id="20dd" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">设计模式是已经使用了几十年的久经考验的方法。它们的用例被清晰地强调出来，它们可以帮助你非常快速地解决现存的问题。</p><p id="7b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模式本身也为开发人员的交流提供了坚实的基础。当您在代码中使用熟悉的模式名称时，代码就变成了<strong class="jp ir">自文档化的</strong>。一旦你认识到相关的编程模式术语和接口，阅读第三方包和你同事的代码就变得更容易理解了。</p><p id="691c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，以下术语分布在整个<a class="ae kl" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> React代码库</a>中。</p><ul class=""><li id="5f8e" class="lk ll iq jp b jq jr ju jv jy mk kc ml kg mm kk mn ls lt lu bi translated">提供上下文</li><li id="ea00" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk mn ls lt lu bi translated">事件发射器</li><li id="bc44" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk mn ls lt lu bi translated">听众</li><li id="21d6" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk mn ls lt lu bi translated">签署</li><li id="bf95" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk mn ls lt lu bi translated">处理</li></ul><p id="18c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">熟悉上述范例的开发人员可以快速识别功能的设计和使用，而不必深入代码的细节。</p><h1 id="a4e3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">观察者模式</strong></h1><blockquote class="ma mb mc"><p id="521c" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">“观察者模式在有多个对象(或模块，或组件)依赖于单个状态的情况下很有用”<br/> <a class="ae kl" href="https://medium.com/@NettaB/the-observer-pattern-answering-three-whys-205d2e469798" rel="noopener"> <em class="iq">观察者模式—回答三个为什么</em> </a></p></blockquote><p id="e5c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您有两个断开的组件想要保持彼此同步时，这在React中很有用。</p><p id="9d59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察者模式依赖于真实的来源。我们称之为<strong class="jp ir">主题。</strong></p><p id="8121" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">观察者</strong>会附着在对象身上，耐心等待。</p><p id="e27c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<strong class="jp ir">主题</strong>发生变化时，它会用最新的数据通知所有的观察者。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/6150000386df9d7494c23062751b0da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tXS9fNiM4iyBWMHy"/></div></div></figure><p id="a062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">示例</strong></p><p id="291e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我们将创建一个跟踪足球比分的网站。</p><p id="83d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望我们的应用程序在应用程序的一个部分显示实时目标，同时在另一个部分显示目标的历史。每当进球得分，我们希望应用程序的两个部分同时更新。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/be42c4d741f8f39c08693f120eb8f968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sBXKJ7Uz0bewjyQw"/></div></div></figure><p id="e341" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="md">为了演示的目的，我们可以想象这些组件彼此相距很远。</em></p><p id="5041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们将如何使用观察者模式来构建代码。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nb"><img src="../Images/c007cab63f00ddff83d2ff8040faa7af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KWoMmer0mDbrw340"/></div></div></figure><p id="985b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码使用了<a class="ae kl" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">类型脚本</strong> </a>。然而，同样的概念可以很容易地应用于普通的javascript。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们给游戏主题附加了一个回调函数列表。每当我们<code class="fe ne nf ng nh b">score</code>一个目标时，这些回调函数将使用最新的目标数据一次触发一个。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b370" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉React钩子，可以去<a class="ae kl" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">介绍钩子</a></p><p id="93d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们的记分牌<strong class="jp ir">消费者</strong>最初被渲染时，我们将<code class="fe ne nf ng nh b">onGoalScored</code>回调附加到游戏<strong class="jp ir">主题</strong>上。当进球得分时，回调函数由<strong class="jp ir">主体</strong>触发，该主体运行<strong class="jp ir">消费者</strong>上的<code class="fe ne nf ng nh b">onGoalScored</code>并更新得分。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1ba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，在我们的GoalHistory <strong class="jp ir">消费者</strong>中，我们将自己附在游戏主体<strong class="jp ir">上，耐心地等待任何进球。当进球时，我们用进球的<code class="fe ne nf ng nh b">Team</code>和进球发生的<code class="fe ne nf ng nh b">time</code>更新<code class="fe ne nf ng nh b">goals</code>列表。</strong></p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="bc4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用观察器，我们确保了这两个组件彼此保持同步</p><p id="9633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong></p><p id="b818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="md">组件之间的低耦合</em>—组件不需要在同一个树中保持彼此同步。</p><p id="f585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">促进<em class="md">单向数据流</em> —在一个位置触发更改，易于跟踪。</p><p id="0f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><p id="a482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="md">内存泄漏</em> —当一个组件不再被使用时，我们需要确保从<code class="fe ne nf ng nh b">Subject</code>中<code class="fe ne nf ng nh b">detach</code>出来，以避免未使用的观察器。</p><h1 id="eb73" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">供应商模式</strong></h1><p id="f3c0" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">提供者模式最初用于。NET微软应用程序为一个类提供了一系列用于初始化的“调味品”(道具)。从那以后，它在React的上下文中被重新定义为一种有用的模式，使组件能够与一些“全局”状态保持同步。</p><p id="cf7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你想让一个公共对象对你的应用程序中的多个组件可用，并在对象改变时强制这些组件更新时，这很有用— <a class="ae kl" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank"> React Provider </a></p><p id="ff2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式的主要好处是避免了必须通过React树中每个组件的属性传递值，也就是所谓的<a class="ae kl" href="https://kentcdodds.com/blog/prop-drilling/" rel="noopener ugc nofollow" target="_blank">“属性钻取】</a>。</p><p id="9789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其工作方式是<strong class="jp ir">提供者</strong>在<strong class="jp ir">上下文</strong>对象上设置一些值，该对象设置在组件树的父级上。</p><p id="2f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何被称为<strong class="jp ir">消费者</strong>的子组件都可以直接从上下文中获取这些值，而不必通过每个子组件的道具传递这些值。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi np"><img src="../Images/c4d308ab1e4f07f842e3d009464b06d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vVTI1bxXpk64z22Wc6gK9w.jpeg"/></div></div></figure><p id="0a62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">示例</strong></p><p id="4239" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我们将在我们的足球网站中提供对上一个例子中的小屏幕设备的支持。当屏幕变得一定大的时候，我们会限制可以看到的内容量。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi np"><img src="../Images/e33b0fae0c0081772892deee6c1f65ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_1hmhVcham_5yHL3M1w9Q.jpeg"/></div></div></figure><p id="e229" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一个<code class="fe ne nf ng nh b">DeviceContext</code>对象，该对象包含我们希望与所有<strong class="jp ir">消费者</strong>共享的状态。接下来，我们设置<code class="fe ne nf ng nh b">DeviceProvider</code>,它允许我们将状态注入到应用程序的给定区域。每当我们使用<code class="fe ne nf ng nh b">DeviceProvider</code>，我们所有的孩子(<strong class="jp ir">消费者</strong> ) <strong class="jp ir"> </strong>都将获得<code class="fe ne nf ng nh b">DeviceContext</code>的访问权</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在实践中，你可以将上下文对象和提供者分离到它们各自的文件中。</p><p id="1093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用React <code class="fe ne nf ng nh b">createContext</code>钩子来设置我们想要在整个网站上共享的对象。<code class="fe ne nf ng nh b">DeviceContext</code>是具有屏幕尺寸的对象，可以是<code class="fe ne nf ng nh b">small</code>或<code class="fe ne nf ng nh b">large</code>。在屏幕大小调整事件中，如果宽度低于一定的像素数，我们就改变屏幕的大小。</p><p id="66c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们创建<code class="fe ne nf ng nh b">Provider</code>，它将上下文共享给其中呈现的所有子元素。使用React内置的<code class="fe ne nf ng nh b">Provider</code> API，我们创建一个简单的<a class="ae kl" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，它设置我们的<code class="fe ne nf ng nh b">DeviceContext</code>的<code class="fe ne nf ng nh b">value</code>属性。该值可用于在<code class="fe ne nf ng nh b">DeviceProvider</code>中渲染的所有子元素。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fcf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用<code class="fe ne nf ng nh b">DeviceContext</code>，我们必须将我们的应用程序包装在<code class="fe ne nf ng nh b">Provider</code>组件中。现在记分板和目标历史都可以访问提供的设备对象。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6fc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的GoalHistory组件中，我们现在可以使用React的<code class="fe ne nf ng nh b">useContext</code>钩子来访问从Provider类导入的设备上下文对象。</p><p id="4d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ne nf ng nh b">useContext</code> API确保组件将与被提供的对象和<code class="fe ne nf ng nh b">screenSize.</code>的值保持同步</p><p id="ca9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不需要担心手动更新这些组件，因为“只要提供者的值属性发生变化，作为提供者后代的所有消费者都将重新呈现。”- <a class="ae kl" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Docs </a></p><p id="637a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点</strong></p><p id="58c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">防止<em class="md">支柱钻孔</em> — <em class="md">父子组件之间的耦合</em></p><p id="ffd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">促进<em class="md">单向数据流</em></p><p id="6dd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><p id="4bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="md">不可见的复合体</em> y —很难判断哪个组件是父组件，数据来自哪里</p><p id="9fdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提倡使用全局变量— <em class="md">降低整个应用程序的凝聚力</em>，<a class="ae kl" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React docs </a>建议谨慎使用<code class="fe ne nf ng nh b">Context</code></p><h1 id="ae4f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">免责声明</strong></h1><p id="3326" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">虽然模式对于某些场景很有用，但它们也经常被开发人员滥用。模式的伸缩性不好，它们快速而优雅地解决了小的设计问题，但是随着应用程序的增长，它们变得难以维护。</p><p id="37d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要让模式引导你，只在模式适合手边的问题时才使用它——不明智地使用，它们通常是多余的。</p><p id="e719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反:</p><ol class=""><li id="c28c" class="lk ll iq jp b jq jr ju jv jy mk kc ml kg mm kk lr ls lt lu bi translated">将您的代码分成更小的组件</li><li id="9539" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">保持数据单向流动</li><li id="f009" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">关注“<a class="ae kl" href="https://medium.com/@severinperez/writing-flexible-code-with-the-single-responsibility-principle-b71c4f3f883f" rel="noopener">单一责任</a>规则</li><li id="87ed" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir">保持简单</strong></li></ol><h1 id="d641" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">结论</strong></h1><p id="7557" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">正确使用的话，模式提供了一个直观的解决方案，可以被更大的开发人员社区快速理解。使用模式，尤其是在React中，可以增强组件之间的通信，确保单个状态在整个应用程序中传播，并帮助您避免任何混乱的树结构。</p><p id="1e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向前迈进，学习各种可用的模式。通过理解各种模式，您将增加可供您使用的解决方案的数量，并提高您在组件设计之外的架构能力。</p></div></div>    
</body>
</html>