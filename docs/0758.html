<html>
<head>
<title>How you should not write code | JavaScript Part-II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不应该写代码| JavaScript第二部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-you-should-not-write-code-javascript-part-2-e76d17ad7ded?source=collection_archive---------3-----------------------#2019-12-06">https://javascript.plainenglish.io/how-you-should-not-write-code-javascript-part-2-e76d17ad7ded?source=collection_archive---------3-----------------------#2019-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d12df2d3c42d70cb4bd7fed9bb8116a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VG7iGpkcSysfoVmQ"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@tinaflour?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kristina Flour</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="d649" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写JavaScript代码需要更少的努力。然而，由于其动态特性。很难维护和扩展。为了编写更好的代码，您需要了解它的缺陷。在本文中，我将介绍JavaScript中常见的误导性API和模式。</p><p id="81fb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“我学得越多，就越意识到我有多少知识是不知道的。”——<strong class="kf jh"><em class="lb">阿尔伯特·爱因斯坦</em> </strong></p><p id="977f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">本文是我上一篇文章</em> <a class="ae jd" href="https://medium.com/swlh/how-not-to-write-code-javascript-62a7fa1f819c" rel="noopener"> <em class="lb">如何不应该写代码</em> </a> <em class="lb">的延续。如果你还没有读过，我建议你读一读。</em></p><h2 id="f9aa" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak"> 1。要求(乞求)不好</strong></h2><p id="e2c1" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我在代码里看过一个<strong class="kf jh"> JSON文件，</strong>开发者使用<a class="ae jd" href="https://nodejs.org/api/modules.html#modules_require_id" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">要求</strong> </a>。然而，<strong class="kf jh">要求</strong>并不像你想象的那么好。我们用一个例子来探讨一下。</p><p id="b778" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在文件夹<strong class="kf jh">【require _ files】中创建一个<strong class="kf jh"> user.json </strong>。我正在展示一个大JSON文件的一小段代码。但是，您可以从Github下载更长的版本。</strong></p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="62a7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建主函数:</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="2641" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你注意到<strong class="kf jh">要求</strong>和<strong class="kf jh"> readFileSync </strong>的时序，它是完全不同的。原因是，<strong class="kf jh">需要</strong>这个方法在幕后做很多事情(比如<strong class="kf jh">缓存)</strong>。</p><p id="5238" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看它在循环中的另一个版本。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1d71" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf jh"> for循环</strong>中，我一次又一次地要求相同的文件。由于<strong class="kf jh"> require </strong>是缓存的，<strong class="kf jh"> require </strong>相比我们的<a class="ae jd" href="https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">fs . read file sync</strong></a>版本非常快。让我们创建一个缓存的<strong class="kf jh"> requireJSON </strong>实用程序库。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="2074" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里可以清楚的看到性能差异:<strong class="kf jh"> requireJSON </strong>比<strong class="kf jh"> require </strong>快40倍。</p><p id="574e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong>并不意味着我们不应该停止使用<strong class="kf jh">要求</strong>。<strong class="kf jh">要求</strong>主要是加载<strong class="kf jh"> JS </strong>文件。它有很多功能。但是，每当你在处理<strong class="kf jh"> JSON(static) </strong>文件的时候。我建议创建一个小的实用函数或使用任何库。</p><p id="1546" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">代码</strong>:<a class="ae jd" href="https://github.com/deepakshrma/how-not-to-write-code/tree/master/js/require_files" rel="noopener ugc nofollow" target="_blank">https://github . com/deepakshrma/how-not-write-Code/tree/master/js/require _ files</a></p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/c67012ba1baa3595678977bc3b0b2e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n-87ArhzNbj4O8Eo"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@jodaarba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jose Aragones</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="b99b" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak"> 2。不要使用同步API</strong></h2><p id="0dca" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在上面的例子中，我讲了很多关于<strong class="kf jh">要求</strong>的内容。但是，您不应该在Node.js中使用任何同步I/O。它会大大降低您的应用程序性能。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="c725" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> AB测试基准:</strong>T0】</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/5e1ea3965b15244e06cf905a09a297a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e37lU8e9bgE4K28sPIcXQA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Benchmark: Sync vs Stream</figcaption></figure><p id="9d31" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong>使用缓存<code class="fe mh mi mj mk b">requireFile</code>功能的同步版本</p><p id="ca6e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同步文件版本的性能似乎比createReadStream更好。然而，同步版本使用缓存API和<em class="lb">我们不能缓存2GB的文件像这些</em>。让我们移除缓存。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/d7c89d2495dba6e9331a37ba33aa6cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgalAkFZE7A4XaeuvWeEFA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Benchmark: Sync No Cache vs Sync</figcaption></figure><p id="9cf9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可以看到的那样，通过删除缓存，性能降低了20%，并且文件非常小。想想如果文件太大。它真的会影响你的服务器<code class="fe mh mi mj mk b"><strong class="kf jh">concurrency</strong></code>。</p><p id="6bf5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">代码:</strong><a class="ae jd" href="https://github.com/deepakshrma/how-not-to-write-code/tree/master/js/no_sync" rel="noopener ugc nofollow" target="_blank">https://github . com/deepakshrma/how-not-write-Code/tree/master/js/no _ sync</a></p><h2 id="c5ac" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">3.嘿，下划线，你做错了。</h2><p id="3472" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我很喜欢布莱恩·朗斯多夫(DrBoolean)的<a class="ae jd" href="https://www.youtube.com/watch?v=m3svKOdZijA" rel="noopener ugc nofollow" target="_blank">视频</a>。在这段视频中，他解释了下划线是如何出错的。如果你真的对函数式编程感兴趣，我推荐你观看这个演讲。</p><p id="d807" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从他的演讲中看一个小例子。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="481a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，<code class="fe mh mi mj mk b">firstLetters</code>试图获取一个<code class="fe mh mi mj mk b">Array</code>中单词的第一个字符。如果用一个<code class="fe mh mi mj mk b"><a class="ae jd" href="https://scotch.io/tutorials/javascript-functional-programming-explained-partial-application-and-currying" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">partial function</strong></a></code>(库里)的概念。我们可以减少代码，使其更具可读性。</p><p id="c26b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来看看我自己版本的<code class="fe mh mi mj mk b"><a class="ae jd" href="https://scotch.io/tutorials/javascript-functional-programming-explained-partial-application-and-currying" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">partial function</strong></a></code>。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="daeb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，没有什么是花哨的。<code class="fe mh mi mj mk b">first</code>返回单词的第一个字符，map只是迭代。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8c60" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你注意到了，我刚刚添加了一个小的实用函数<code class="fe mh mi mj mk b">curry</code>,它帮助我们将任何函数作为部分函数。现在使用它，我们可以使我们的<code class="fe mh mi mj mk b">firstLetters</code>函数更加可读/可重用。</p><p id="7ce7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">代码</strong>:<a class="ae jd" href="https://github.com/deepakshrma/how-not-to-write-code/blob/master/js/partial_fun.js" rel="noopener ugc nofollow" target="_blank">https://github . com/deepakshrma/how-not-to-write-Code/blob/master/js/partial _ fun . js</a></p><h2 id="eeb2" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">4.<strong class="ak">对象API不起作用</strong></h2><p id="dfd0" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">对象类API本质上不是功能性的。当我这样说的时候，我们必须意识到事实。我们举一个很基本的例子。假设我们有一个<code class="fe mh mi mj mk b">country code</code>和<code class="fe mh mi mj mk b">name</code>的对象，其中键是代码，值是<code class="fe mh mi mj mk b">name</code>。并且我们想把它转换成一个<code class="fe mh mi mj mk b">country objects</code>的数组。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9c2e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子在这里工作得非常好。需要注意的是，<code class="fe mh mi mj mk b"> Object.entries</code>本身是一个<code class="fe mh mi mj mk b">for-loop</code>，在此之后，我们调用<code class="fe mh mi mj mk b">map</code>函数。也就是说，我们为同一件事循环了两次。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="13a5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码同上，但只有一个时间循环。性能大幅提升。在这个解决方案中，转换逻辑在函数中紧密耦合。我们来解耦一下。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ea4c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与上述函数的工作原理相同。然而，我们已经将转换逻辑解耦为一个<code class="fe mh mi mj mk b"><strong class="kf jh">mapper</strong></code>函数。不知何故，它比旧版本性能更好。</p><p id="47ad" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">我尝试在StackOverflow中回答一个问题。但是似乎开发者更喜欢头脑简单的代码。</em>😂</p><div class="ip iq gp gr ir mn"><a href="https://stackoverflow.com/questions/59190494/how-to-create-an-array-out-of-json/59190684#59190684" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd jh gy z fp ms fr fs mt fu fw jf bi translated">如何用JSON创建数组？</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">我需要将这个JSON文件转换成一个单个国家条目的数组。{ "AT ":"奥地利"，" BE ":"比利时"，" BG"…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">stackoverflow.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ix mn"/></div></div></a></div><p id="b332" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">代码:</strong><a class="ae jd" href="https://github.com/deepakshrma/how-not-to-write-code/blob/master/js/object_apis.js" rel="noopener ugc nofollow" target="_blank">https://github . com/deepakshrma/how-not-to-write-Code/blob/master/js/object _ APIs . js</a></p><h2 id="348e" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak"> 5。让我们保证你不会拒绝我</strong></h2><p id="f876" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我个人非常喜欢<code class="fe mh mi mj mk b"><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code> API。然而，我看到人们在承诺上挣扎了很久。最大的挑战是同时履行多个承诺。</p><p id="eba8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个我们可以解决的常见问题。假设我们必须使用两个不同的异步API，我们想从这两个API中收集数据。</p><p id="6fb1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看解决方案。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="adf8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注:</strong> <code class="fe mh mi mj mk b">deley</code>是模拟<code class="fe mh mi mj mk b">async I/O</code>的小效用函数。</p><p id="88a6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切看起来不错。然而，有一个问题。如果其中一个<code class="fe mh mi mj mk b">call</code>失败了怎么办？？</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5789" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它完全失败了。我们不会得到第二个API调用的输出。</p><p id="ef50" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">根据</strong>的类型定义，如果<strong class="kf jh">拒绝任何承诺，<code class="fe mh mi mj mk b">Promise.all</code>将拒绝。</strong></p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="d46c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们可以创建一个非常基本的效用函数<code class="fe mh mi mj mk b">collectAll</code>。</p><figure class="ma mb mc md gt is"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5b55" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">代码:</strong><a class="ae jd" href="https://github.com/deepakshrma/how-not-to-write-code/blob/master/js/promis_merge.js" rel="noopener ugc nofollow" target="_blank">https://github . com/deepakshrma/how-not-to-write-Code/blob/master/js/promis _ merge . js</a></p><blockquote class="nc nd ne"><p id="2e82" class="kd ke lb kf b kg kh ki kj kk kl km kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated">感谢阅读。如果你喜欢这篇文章，请在评论中告诉我。并请订阅我的饲料更多这样的编码博客。所有代码都可以在我的GitHub上找到:</p></blockquote><div class="ip iq gp gr ir mn"><a href="https://github.com/deepakshrma/how-not-to-write-code" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd jh gy z fp ms fr fs mt fu fw jf bi translated">deepakshrma/如何不写代码</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="ni l my mz na mw nb ix mn"/></div></div></a></div></div></div>    
</body>
</html>