<html>
<head>
<title>Handling CORS (Cross Origin Resource Sharing) in Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Web应用中处理CORS(跨源资源共享)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/https-medium-com-shreyaaatiwari-handling-cors-cross-origin-resource-sharing-in-web-apps-166f670f508a?source=collection_archive---------1-----------------------#2019-09-24">https://javascript.plainenglish.io/https-medium-com-shreyaaatiwari-handling-cors-cross-origin-resource-sharing-in-web-apps-166f670f508a?source=collection_archive---------1-----------------------#2019-09-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5ed2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一步一步的指南，使跨起源的客户端-服务器通信，同时处理CORS错误的方式。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ea89802401c84f6ecc985b651cf54e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-XqMBtbyaz35Ja-HVrJbg.jpeg"/></div></div></figure><h1 id="fc49" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="5a2e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>是一种机制，它使用额外的HTTP报头来通知浏览器允许在一个来源运行的web应用程序访问来自不同来源的选定资源。当web应用程序请求具有不同来源的资源(即域、协议或端口)。</p><p id="dbde" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">在复杂的跨源请求的情况下，例如，对于可能对服务器数据产生副作用的HTTP请求方法(特别是，除GET或POST之外的HTTP方法，带有某些<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types" rel="noopener ugc nofollow" target="_blank"> MIME类型</a>)，浏览器会自动发出一个<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Functional_overview" rel="noopener ugc nofollow" target="_blank"> <strong class="li io">预检</strong> </a>请求。这是OPTIONS请求，它检查服务器是否支持实际的请求。一旦期权请求成功，才进行实际的调用。</p><p id="646f" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">简而言之，预检请求是一种在发出请求之前请求实际请求许可的方式。服务器应该检查头<strong class="li io">Access-Control-Request-Method</strong>和<strong class="li io">Access-Control-Request-Headers</strong>以验证HTTP方法和请求的头都是有效的并且被接受的。</p><h1 id="fdc4" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">处理CORS错误</h1><p id="6e56" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">让我们从使用javascript fetch api逐步实现简单的客户机-服务器通信开始，并在出现错误时处理它们。</p><p id="8e13" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">我有一个运行在<em class="mi"> localhost:3000/ </em>上的react应用程序和一个运行在<em class="mi"> localhost:5000/ </em>上的express服务器</p><h2 id="a47d" class="mj kp in bd kq mk ml dn ku mm mn dp ky lp mo mp la lt mq mr lc lx ms mt le mu bi translated"><strong class="ak"> 1。访问控制允许来源</strong></h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2b67132fbe409c6e46fe0dee7096420c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*9W78c6gePoEoVDcI4cKP0g.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">A simple GET request made from the react app</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/066a7d454962dc906012994df5106221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*tWw6tlr47DA8t8Q4cDBz4Q.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">A text response by the express server. Note that no headers have been set.</figcaption></figure><p id="e53d" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">上面的代码片段看起来都很好，客户机发出GET请求，服务器提供相同的服务，但是它会在浏览器控制台上导致下面的错误:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/19d602426edafbb2664da6f4f7654e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46wPzL33akVnhMA9-UvJsg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">CORS error</figcaption></figure><p id="856e" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">如该错误所示，需要Access-Control-Allow-Origin标头才能从不同域中的服务器获取。让我们将这个头添加到response并继续。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/aa1743cd29d615c148248fd1020c28cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*eAO2SKgb8BG6DOEq23Ec8A.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">with wildcard *, the server is allowing requests from all origin to be able to fetch</figcaption></figure><p id="2bca" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">现在我们已经允许origin " * "从这个服务器获取数据，我们已经成功地使简单的客户端-服务器通信无缝地发生了。</p><h2 id="cafc" class="mj kp in bd kq mk ml dn ku mm mn dp ky lp mo mp la lt mq mr lc lx ms mt le mu bi translated"><strong class="ak"> 2。访问控制允许凭证</strong></h2><p id="edaf" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在让我们对代码做一些调整，这样当调用<em class="mi"> /token </em>时，服务器会在客户端浏览器中设置一个cookie。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1ae7ecf706c26b18857c75fcc61f935a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*5Fo8pC300NdrOKE-E5mXLg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Setting an http-only cookie through the response, while all origins (<em class="nc">ie</em> *) are allowed</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/fbb4e2b518f8a024d1f64bd37036b1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*ZjDq6bsXj9MNs5roUSpmAQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Note the value of credentials is set to include</figcaption></figure><p id="63e2" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">现在我们都设置好了，让我们检查请求是否成功发出。<br/>这里又出现了另一个CORS错误:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/fbc287e26d7d62ec167ac997fc706be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIy9HUZ1G6_FA_GBKHZXWQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">The value of Access-Control-Allow-Origin should not be * when credentials mode is include</figcaption></figure><p id="dc09" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">好吧，这是有道理的。如果您的服务器试图设置一个cookie，这主要是为了安全实现，最好只允许来自某些来源的请求，而不是由通配符“*”指定的所有来源。<br/>同样，根据错误所述，我将允许服务器上的特定来源<em class="mi"> http://localhost:3000 </em>并继续。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cf7a00c7e790593f427e610e004ebb36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*4hI0xFYBfvZDLcPYqAth7w.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Access-Control-Allow-Origin set to “<a class="ae mc" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>”</figcaption></figure><p id="9dcc" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">将Access-Control-Allow-Origin标头从*更改为我们客户端的Origin，解决了这个错误，但我的浏览器控制台上出现了下一个错误:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/62df4c48c8b764f7a185aabe41a56eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bWpja-NGcumSkGfg5AzMOw.png"/></div></div></figure><p id="093d" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">再次听取非常有用的CORS错误消息，我将继续更新我的代码，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/7be8d723997b33e5d2a4cd7b4a97249d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*H5AmUsjHUUwyrLKXq_7qOg.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Setting the Access-Control-Allow-Credentials to true, as the request’s credentials mode is include</figcaption></figure><p id="853b" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">最后，我能够让我的服务器成功地向客户机发送一个文本响应并设置一个cookie。</p><h2 id="2449" class="mj kp in bd kq mk ml dn ku mm mn dp ky lp mo mp la lt mq mr lc lx ms mt le mu bi translated"><strong class="ak"> 3。访问控制允许报头</strong></h2><p id="2593" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">接下来，我将尝试从客户机向服务器发送一个定制的头。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/af47e562882685b65304c78e6099a07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*1EOGVv9GnV7R-dxmLqFW0g.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Sending random_header with the request</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/77df2567780a031eacedd14f4e82f006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRGP2ta6AXmAQZrtm2995Q.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Server logs the received header</figcaption></figure><p id="38eb" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">查看浏览器中的网络选项卡，我们可以看到正在发出选项请求。但是由于以下错误，我们的实际get调用无法通过:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/f23a249e23b307401a7c5ab2aca9a5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mo1lj9F5r8_dKWooWy7SGQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">OPTIONS call made while sending custom headers</figcaption></figure><p id="2a0f" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">同样，按照上面CORS错误的建议更新代码，让我们针对Access-Control-Allow-Headers指定random_header。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/8684e4784f5c7a7ef316ab87b4279541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rM8IicSqdgS-nPcp9J4dug.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">random_header allowed by specifying Access-Control-Allow-Headers</figcaption></figure><p id="3440" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">查看network选项卡，我们可以看到在OPTIONS调用成功后进行了GET调用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/1492c8ce8b19a3228707f77d73e476ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXlVKlI4VINuWNz5Jamokg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">OPTIONS call made before the actual GET request</figcaption></figure><p id="e3a7" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">在那里，我们已经成功地将随机报头从客户端发送到服务器。我们可以使用自定义头作为一些特定的元数据，基于这些元数据，可以在后端代码上应用一个逻辑。</p><h2 id="404b" class="mj kp in bd kq mk ml dn ku mm mn dp ky lp mo mp la lt mq mr lc lx ms mt le mu bi translated"><strong class="ak"> 4。访问控制公开标题</strong></h2><p id="bae4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在让我们尝试与上述场景相反的场景。让我们尝试发送一个带有响应的自定义头，并在浏览器上记录这个值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/5c989d4602eace5ddbbdce9f3fb1093c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbyHs1DhfvsYKufczzqlSw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">custom-token set as response header</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/7a7fcdffecdcdfc4facc47fef4d93d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*KulfuyjtMTUmZdIkuTsALw.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">logging the custom-token value</figcaption></figure><p id="555d" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">现在，我们已经将自定义令牌添加到了响应中，并在客户端读取了相同的内容，让我们在浏览器中对此进行检查。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/b0ce8b3cb7826235c329d2cc036bd3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMtdSOVRyCFUrEj59cJMrQ.png"/></div></div></figure><p id="b309" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">请注意，在接收到的头中可以看到自定义令牌，但是当尝试记录相同的内容时，无法读取值。之所以如此，是因为根据CORS，只有6个CORS- <a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header" rel="noopener ugc nofollow" target="_blank">安全列表</a>响应头作为响应的一部分被暴露，其他的都被过滤了。要公开其他头，应该使用Access-Control-Expose-Headers响应头。现在让我们在响应中公开我们的自定义令牌。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/89bd6f77ac6f40a8b47576ee5a1f4a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUAchD25A4dpO-vsK90c5g.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">custom-token specified under Access-Control-Expose-Headers</figcaption></figure><p id="3f49" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">检查网络调用，我们可以看到自定义令牌现在已经公开，并且可以被我们的javascript代码访问。</p><h2 id="151f" class="mj kp in bd kq mk ml dn ku mm mn dp ky lp mo mp la lt mq mr lc lx ms mt le mu bi translated"><strong class="ak"> 5。访问控制允许方法</strong></h2><p id="f40b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">access-Control-Allow-Methods<strong class="li io"/>response header指定在访问资源以响应预检请求时允许的一种或多种方法。让我们试着做一个卖出请求，如上所述，它将请求一个期权买入。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/52221a4c4b901c27b0b4f1dd7fa5593b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*L2fMfaNgQfox2VdAWniKnQ.png"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/04be5a1286dda94dc868c86d4c60c729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hS08MXiz_tF9i6l7tfA8zQ.png"/></div></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/5ea4195e09d0ad046673887f48a80557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_n4-TB9FQ9Kz8r2q-Ti1A.png"/></div></div></figure><p id="b3db" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">预检请求失败，因为它没有获得上传请求的批准，因此无法发出请求。我们需要我们的客户端使用Access-Control-Allow-Methods头来允许PUT请求。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/9dd47af5361aa0f24c921d0624ca8c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eu3mNK2vhFuEACy__eKopw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Allowing PUT requests using Access-Control-Allow-Methods</figcaption></figure><p id="d7da" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">现在OPTIONS调用成功了，从而允许PUT请求通过。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="62ad" class="ko kp in bd kq kr nq kt ku kv nr kx ky jt ns ju la jw nt jx lc jz nu ka le lf bi translated">TL；博士:</h1><p id="c8c6" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">让我们总结一下这篇文章的要点:</p><p id="968c" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><strong class="li io"> 1。</strong> <strong class="li io">如果服务跨来源请求，则在响应中应设置访问控制允许来源</strong>报头。</p><p id="b817" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><strong class="li io"> 2 </strong>。如果请求需要向服务器发送安全cookie，或者期望响应中有cookie，那么其<strong class="li io">凭证</strong>模式应该设置为<strong class="li io">包含</strong>。只有这样，它才能使用http cookies。</p><p id="6ff0" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><strong class="li io"> 3 </strong>。在复杂的跨源请求的情况下，例如HTTP请求方法会对服务器数据产生副作用，浏览器会自动发出<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Functional_overview" rel="noopener ugc nofollow" target="_blank"> <strong class="li io">预检</strong> </a>请求。</p><p id="52d9" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><strong class="li io"> 4。</strong> <strong class="li io">当凭证模式设置为包含时，Access-Control-Allow-Credentials</strong>头应设置为真。</p><p id="f5bc" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><strong class="li io"> 5。</strong>当请求中需要自定义报头时，该报头应在<strong class="li io">访问控制允许报头</strong>报头下指定。</p><p id="9bd2" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><strong class="li io"> 6。</strong>当自定义标头与响应一起发送时，应在<strong class="li io">Access-Control-Expose-Headers</strong>标头下指定，以便客户端能够访问标头值。</p><p id="9f92" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">7。<strong class="li io">Access-Control-Allow-Methods</strong>头应该指定会对服务器数据产生副作用的方法(如果有的话)。</p></div></div>    
</body>
</html>