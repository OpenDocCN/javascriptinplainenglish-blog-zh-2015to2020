<html>
<head>
<title>More Rxjs Transformation Operators — Scan and Window</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多rjs转换运算符-扫描和窗口</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/more-rxjs-transformation-operators-scan-and-window-191a18e5c4e7?source=collection_archive---------5-----------------------#2020-02-15">https://javascript.plainenglish.io/more-rxjs-transformation-operators-scan-and-window-191a18e5c4e7?source=collection_archive---------5-----------------------#2020-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c47f4ac9a97291b4d3669c9a722faa99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QhwP8wVDWpWgZh6K"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rgeorgelucian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">George Lucian Rusu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">rjs是一个进行反应式编程的库。创建运算符对于从各种数据源生成要由观察者订阅的数据非常有用。</p><p id="1543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用转换运算符<code class="fe lb lc ld le b">scan</code>、<code class="fe lb lc ld le b">switchMap</code>、<code class="fe lb lc ld le b">switchMapTo</code>和<code class="fe lb lc ld le b">window</code>。</p><h1 id="e806" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">扫描</h1><p id="87d2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">scan</code>运算符通过组合发射值对源观测值应用累加器函数。然后，它返回每个中间结果，并带有一个可选的种子值。</p><p id="516c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多包含2个参数。第一个是<code class="fe lb lc ld le b">accumulator</code>函数，它是将到目前为止累积的值与新发射值相结合的函数。</p><p id="0a40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是可选参数，即<code class="fe lb lc ld le b">seed</code>或初始累加值。</p><p id="1b27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以按如下方式使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="deb2" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { scan } from "rxjs/operators";</span><span id="d37e" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3);<br/>const seed = 0;<br/>const count = of$.pipe(scan((acc, val) =&gt; acc + val, seed));<br/>count.subscribe(x =&gt; console.log(x));</span></pre><p id="5db8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码以<code class="fe lb lc ld le b">of</code>可观测值和<code class="fe lb lc ld le b">seed</code>初始值0开始。然后我们<code class="fe lb lc ld le b">pipe</code>将<code class="fe lb lc ld le b">of$</code>可观察到的值传给<code class="fe lb lc ld le b">scan</code>算子，该算子具有累加功能，将累加的值加到新发射的值上。我们还将<code class="fe lb lc ld le b">seed</code>设置为0。</p><p id="97a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们同意由此产生的<code class="fe lb lc ld le b">count</code>可观察值。</p><h1 id="b4b7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">switchMap</h1><p id="fcde" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">switchMap</code>运算符将每个源值投影到一个可观测值，然后该可观测值被合并到一个输出可观测值中。仅发射最近投影的可观测值。</p><p id="343b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多包含2个参数。第一个是<code class="fe lb lc ld le b">project</code>函数，它将源可观测值的发射值作为参数，然后从中返回一个新的可观测值。</p><p id="cc18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是可选的<code class="fe lb lc ld le b">resultSelector</code>参数。这是一个让我们从新的可观测值中选择结果的函数。</p><p id="8ac6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以按如下方式使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="dee0" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { switchMap } from "rxjs/operators";</span><span id="9681" class="mq lg iq le b gy mv ms l mt mu">const switched = of(1, 2, 3).pipe(switchMap(x =&gt; of(x, x * 2, x * 3)));<br/>switched.subscribe(x =&gt; console.log(x));</span></pre><p id="fc0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将<code class="fe lb lc ld le b">of(1, 2, 3)</code>可观察到的值取出后<code class="fe lb lc ld le b">pipe</code>将结果输入<code class="fe lb lc ld le b">switchMap</code>运算符，该运算符具有映射<code class="fe lb lc ld le b">of(1, 2, 3)</code>可观察到的值并返回<code class="fe lb lc ld le b">of(x, x * 2, x * 3)</code>的功能，其中<code class="fe lb lc ld le b">x</code>是从<code class="fe lb lc ld le b">of(1, 2, 3)</code>可观察到的1、2或3。</p><p id="57cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们得到的<code class="fe lb lc ld le b">1</code>、<code class="fe lb lc ld le b">1*2</code>和<code class="fe lb lc ld le b">1*3</code>分别是1、2和3。然后对2做同样的处理，所以我们得到<code class="fe lb lc ld le b">2</code>、<code class="fe lb lc ld le b">2*2</code>和<code class="fe lb lc ld le b">2*3</code>，分别是2、4和6。最后得到<code class="fe lb lc ld le b">3</code>、<code class="fe lb lc ld le b">3*2</code>、<code class="fe lb lc ld le b">3*3</code>，其中3、6、9。</p><p id="cc22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到以下输出:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6a94" class="mq lg iq le b gy mr ms l mt mu">1<br/>2<br/>3<br/>2<br/>4<br/>6<br/>3<br/>6<br/>9</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/3ddd8f7eaadc05159fb458c355ea3c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WiD6eyp3E7n5yVa4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@flaviewxvx?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Flavio Gasperini</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="aacd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">switchMapTo</h1><p id="7fd4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">switchMapTo</code>运算符将每个源值投影到同一个可观察值上。然后，通过输出可观察值中的<code class="fe lb lc ld le b">switchMap</code>,可观察值被平坦化多次。</p><p id="7893" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多需要两个参数。第一个是一个可观测值，我们用它替换源可观测值的每个发射值。</p><p id="f189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是可选参数，即<code class="fe lb lc ld le b">resultSelector</code>函数，它让我们从新的可观察值中选择值。</p><p id="aedb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1a91" class="mq lg iq le b gy mr ms l mt mu">import { of, interval } from "rxjs";<br/>import { switchMapTo, take } from "rxjs/operators";</span><span id="44d0" class="mq lg iq le b gy mv ms l mt mu">const switched = of(1, 2, 3).pipe(switchMapTo(interval(1000).pipe(take(3))));<br/>switched.subscribe(x =&gt; console.log(x));</span></pre><p id="5afd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将把可观察到的<code class="fe lb lc ld le b">of(1, 2, 3)</code>的发射值映射到<code class="fe lb lc ld le b">interval(1000).pipe(take(3))</code>中，后者以1秒的间隔发射从0到3的值。</p><p id="deff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果将是我们得到0、1、2和3作为输出。</p><h1 id="d4f3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">窗户</h1><p id="d4c8" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当<code class="fe lb lc ld le b">windowBoundaries</code>可观察值发出时，<code class="fe lb lc ld le b">window</code>操作符将源可观察值分支为嵌套可观察值。</p><p id="acba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它采用一个参数，即用于完成前一个窗口并开始一个新窗口的<code class="fe lb lc ld le b">windowBoundaries</code>可观察值。</p><p id="836d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe lb lc ld le b">buffer</code>一样，它缓冲发出的值，然后在满足某些条件时一次发出所有的值，但发出的是可观察值而不是数组。</p><p id="015d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3cd6" class="mq lg iq le b gy mr ms l mt mu">import { interval, timer } from "rxjs";<br/>import { window, mergeAll, map, take } from "rxjs/operators";</span><span id="833f" class="mq lg iq le b gy mv ms l mt mu">const timer$ = timer(3000, 1000);<br/>const sec = interval(6000);<br/>const result = timer$.pipe(<br/>  window(sec),<br/>  map(win =&gt; win.pipe(take(2))),<br/>  mergeAll()<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="d5d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有<code class="fe lb lc ld le b">timer(3000, 1000)</code> Observable，它从初始化后的3秒钟开始每秒发出值。</p><p id="b846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还有一个每6秒钟发射一次数字的<code class="fe lb lc ld le b">sec</code>观测器。我们使用<code class="fe lb lc ld le b">window</code>操作符来创建窗口。这意味着来自<code class="fe lb lc ld le b">timer$</code>可观测值的值将发出值，然后这些值将被<code class="fe lb lc ld le b">pipe</code> d到<code class="fe lb lc ld le b">window</code>算子。</p><p id="61d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，这将通过管道传递给<code class="fe lb lc ld le b">map</code>操作符，该操作符将获取从<code class="fe lb lc ld le b">window</code>操作符发出的前2个值。然后所有的结果会用<code class="fe lb lc ld le b">mergeAll</code>合并在一起。</p><p id="3b82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们从每6秒发射的<code class="fe lb lc ld le b">timer$</code>中得到2个数字。</p><p id="4380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">scan</code>操作符通过组合发射值对源观测值应用累加器函数。然后，它返回每个中间结果，并带有一个可选的种子值。</p><p id="61d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">switchMap</code>将每个源值投影到一个可观测值，然后合并成一个输出可观测值。只有来自最近预测的可观测值被发出。</p><p id="98f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe lb lc ld le b">switchMap</code>，<code class="fe lb lc ld le b">switchMapTo</code>项目每个源值一个可观察值。但与<code class="fe lb lc ld le b">switchMap</code>不同的是，它投射到同样的可观察物体上。然后，通过输出可观察值中的<code class="fe lb lc ld le b">switchMap</code>,可观察值被平坦化多次。</p><p id="e14e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用于关闭和打开窗口的<code class="fe lb lc ld le b">windowBoundaries</code>可观察值发出时，<code class="fe lb lc ld le b">window</code>操作符将源可观察值分支为嵌套可观察值。</p></div></div>    
</body>
</html>