<html>
<head>
<title>The Road to Better Abstractions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通向更好抽象的道路</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-road-to-better-abstractions-540620224b7d?source=collection_archive---------12-----------------------#2020-09-15">https://javascript.plainenglish.io/the-road-to-better-abstractions-540620224b7d?source=collection_archive---------12-----------------------#2020-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="23f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重构JavaScript:集合管道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/63226bbbe7faa5be36098c660c658d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u07oJ1Phq3v5jRLcgR-KAg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@foxy619?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jonathan Fox</a> on <a class="ae kv" href="https://unsplash.com/s/photos/road-map?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4be7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/swlh/refactoring-javascript-collection-pipelines-3ebc2e63abee" rel="noopener">我最近开始写</a>关于重构JavaScript使用集合管道而不是循环。我大胆地宣称这将导致更干净的代码，但我还没有做的是为<strong class="ky ir">为什么</strong>我认为这会导致更干净的代码做一个清晰的论证。</p><p id="81fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，获得一个任意对象的集合，通过一系列单独的<em class="ls">转换</em>和<em class="ls">过滤器</em>并从另一端获得一个新的集合，是一件真正令人满意的事情。看到一个工作流被分解成离散的、通常是单行的步骤，没有副作用，是编写代码的好方法。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9c7b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">功能构建模块</h1><p id="e5e4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">map()</code>、<code class="fe mx my mz na b">filter()</code>和<code class="fe mx my mz na b">reduce()</code>是JavaScript中处理集合(数组)的强大高阶函数。我将它们称为功能构建模块，因为:</p><ul class=""><li id="bdde" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">它们都返回新的集合，不会改变原来的集合，</li><li id="94fa" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">他们只做一件事，而且</li><li id="2fc0" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><em class="ls">一般情况下</em>应该不会有副作用。</li></ul><p id="9ee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会惊讶地发现这三个特征可以简化你的代码。</p><p id="1df0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查这三种收集方法中的每一种，并尝试看看为什么它们可以帮助我们清理代码。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="8f85" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">地图()</h2><p id="0d36" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">地图在我看来是最重要的采集方式之一。Map用于<em class="ls">将集合中的每个项目</em>转换成其他项目。给定一些项目集合和一个函数，map会将该函数应用于每个项目，并返回一个相同大小的新的<em class="ls">集合。</em></p><p id="d911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">地图是如此强大的抽象，因为它有非常明确的意图。它获取一个项目集合，然后<em class="ls">将</em>映射到另一个项目集合。每个数组中的项目之间有1:1的映射关系。当你看到一个<code class="fe mx my mz na b">map()</code>被使用时，你可以把它内化为<code class="fe mx my mz na b">transform</code>，事实上，转换数据是我在代码中使用map的第一个地方。考虑下面的代码示例，其中我查询DynamoDB(我最近选择的持久层)并返回一个项目:</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="f9e6" class="np mb iq na b gy of og l oh oi">// src/user/queries/findAllUsers.ts</span><span id="53a6" class="np mb iq na b gy oj og l oh oi">export const findAllUsers = async (tennantId: string): Promise&lt;User[]&gt; =&gt; {<br/>  const params = {<br/>    TableName: process.env.DYNAMODB_TABLE,<br/>    KeyConditionExpression: 'pk = :pk AND begins_with(sk, :sk)',<br/>    ExpressionAttributeValues: {<br/>      ':pk': tennantId,<br/>      ':sk': 'user:',<br/>    },<br/>  };<br/><br/>  const { Items } = await dynamoDBClient.query(params).promise();<br/><br/>  return Items ? Items.map((item: DynamoDBUser) =&gt; userFromDynamoDBItem(item)) : [];<br/>};</span></pre><p id="755d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为开发人员，您可能已经编写过100次这样的查询，如果不是用DynamoDB，那么就是用某种形式的SQL或NoSQL。除非您使用某种形式的<a class="ae kv" href="https://www.martinfowler.com/eaaCatalog/activeRecord.html" rel="noopener ugc nofollow" target="_blank"> ActiveRecord </a>实现，否则您可能不喜欢将数据库模式耦合到数据的域表示。因此，我们想要获取一个数据集合——在本例中是一个<em class="ls">用户</em>的数据库表示，并将它转换成一个不同的表示。这里的<code class="fe mx my mz na b">userFromDynamoDBItem</code>完全按照它所说的去做——它接受一个DynamoDBItem并将其转换成一个用户。</p><p id="5a18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了完整起见，这里是我们的<em class="ls">用户的接口定义— </em>当我们在应用程序逻辑中处理数据时，我们希望数据看起来是这样的。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="6e04" class="np mb iq na b gy of og l oh oi">export interface User {<br/>  id: string;<br/>  givenName: string;<br/>  familyName: string;<br/>  email: string;<br/>}</span></pre><p id="3ecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们的数据库表示的样子——你可以明白为什么我们要在将数据传递给应用程序之前对其进行转换。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="dc44" class="np mb iq na b gy of og l oh oi">export interface DynamoDBUser extends BaseDynamoDBRecord {<br/>  email: string;<br/>  givenName: string;<br/>  familyName: string;<br/>}</span><span id="b572" class="np mb iq na b gy oj og l oh oi">export interface BaseDynamoDBRecord {<br/>  pk: string;<br/>  sk: string;<br/>  __context__: Record&lt;string, string&gt;;<br/>  gsi1pk?: string;<br/>  gsi1sk?: string;<br/>  gsi2pk?: string;<br/>  gsi2sk?: string;<br/>  type: string;<br/>  ttl?: number;<br/>}</span></pre><p id="6847" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">难道我们不能用一个标准的循环来转换这些数据吗？ </p><p id="74db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，我们可以，但是，有一个方法来转换数据，这是一致的和明确的意图，减少认知开销，并提高我们的代码可读性。</p><p id="a42c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个相当自负的例子，但是想象一下，你的代码中有这样的功能，有一天你的产品负责人找到你说“我们想记录我们在任何查询中从数据库中检索的每个用户的userId”。</p><p id="130e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能是一个奇怪的要求，但它不是不可能的。如果我们使用一个循环来完成这个转换，我们可以很容易地在循环中抛出一个语句，记录转换的每次迭代。这听起来很吸引人，但实际上这是一件非常糟糕的事情。通过这样做，我们增加了转换函数的责任。</p><p id="13ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好将这个需求添加到一个新的收集方法中，这次我们将使用一个<code class="fe mx my mz na b">forEach</code></p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="552b" class="np mb iq na b gy of og l oh oi"><em class="ls">const </em>users = Items<br/>  .map((item: DynamoDBUser): User =&gt; userFromDynamoDBItem(item))<br/>  .forEach((user: User) =&gt; console.log(user.id))<br/></span></pre><p id="021a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们已经非常清楚地表达了我们的意图。首先，我们将用户转换成他们的域表示，然后我们遍历集合并记录ID。这清楚地表明，日志记录是一种明确的意图，而不是开发人员留下的调试步骤。</p><p id="32fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管到目前为止我还没有在我的系列中的任何地方提到过<em class="ls"> </em> <code class="fe mx my mz na b">forEach</code>，我还是想用这个例子来说明它在<code class="fe mx my mz na b">map()</code>的世界中仍然有它的位置。一般来说，我们应该只<code class="fe mx my mz na b">map</code>如果我们是<em class="ls">转换</em>和项目。如果不是，那么<code class="fe mx my mz na b">forEach</code>就是正确的选择。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="227d" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">过滤器()</h2><p id="fc79" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">filter()</code>方法用于<em class="ls">过滤掉</em>您不希望包含在集合中的任何元素。您给<code class="fe mx my mz na b">filter()</code>一个谓词(返回<code class="fe mx my mz na b">boolean</code>的表达式)，如果谓词返回<code class="fe mx my mz na b">true</code>，您保留该项，如果它返回<code class="fe mx my mz na b">false</code>，您删除它。</p><p id="2c13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">filter()</code>和<code class="fe mx my mz na b">map()</code>的主要区别在于，filter并不转换或改变集合中的任何单个项目，而是通过从集合中删除项目来改变整个集合。返回的项不仅与原始数组中的项类型相同，而且是相同的项。</p><p id="df32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过滤很容易理解，所以我们的例子看起来有点琐碎，不过:</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="92e0" class="np mb iq na b gy of og l oh oi"><em class="ls">interface Article </em>{<br/>  id: <em class="ls">string</em>;<br/>  title: <em class="ls">string</em>;<br/>  body: <em class="ls">string</em>;<br/>  status: 'PUBLISHED' | 'DRAFT'<br/>}<br/><br/><em class="ls">const </em>publicshedArticles: <em class="ls">Article</em>[] = <br/>  articles.filter((article: <em class="ls">Article</em>) =&gt; article.status === 'PUBLISHED');</span></pre><p id="88dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，我们收集了一些文章，并且只保留那些已经发表的文章。关于<code class="fe mx my mz na b">filter</code>的一个好处是，因为它非常简单，所以它在<a class="ae kv" href="https://stackoverflow.com/questions/944446/what-is-point-free-style-in-functional-programming" rel="noopener ugc nofollow" target="_blank">自由点编程风格</a>中工作得非常好。我们可以将上面的过滤器重写为无点过滤器，如下所示:</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="24c2" class="np mb iq na b gy of og l oh oi"><em class="ls">const </em>isPublished = article =&gt; article.status === 'PUBLISHED'<br/><br/><em class="ls">const </em>publishedArticles: <em class="ls">Article</em>[] = articles.filter(isPublished);</span></pre><p id="248e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，所有这些都可以通过humble循环来实现，但是，我将再次指出，由于更明确的意图声明，可读性得到了提高。我们可以看到单词<code class="fe mx my mz na b">filter</code>，并且知道随后的任何东西都会给我们一个集合，小于或等于原始集合的大小，同时保持我们的单个项目不变。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="1957" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated">减少()</h2><p id="1d43" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mx my mz na b">reduce</code>操作用于获取一些项目集合，然后<em class="ls">将其减少为一个值。它不知道该值是多少；它可以是一个对象、一个数组、一个数字或者一个字符串——这无关紧要。</em></p><p id="b05a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经在这里写了 <code class="fe mx my mz na b"><a class="ae kv" href="https://medium.com/better-programming/the-power-of-reduce-87bfdb7de04" rel="noopener">reduce()</a></code> <a class="ae kv" href="https://medium.com/better-programming/the-power-of-reduce-87bfdb7de04" rel="noopener">的</a><a class="ae kv" href="https://medium.com/better-programming/the-power-of-reduce-87bfdb7de04" rel="noopener">功能——甚至展示了如何通过<code class="fe mx my mz na b">reduce().</code>实现<code class="fe mx my mz na b">map()</code>和<code class="fe mx my mz na b">filter()</code></a></p><p id="a443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我展示了如何使用一个reduce函数来解决Canva的HackerRank算法挑战。</p><p id="fcab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了对值求和，<code class="fe mx my mz na b">reduce()</code>最常见的用例之一是连接字符串。鉴于我已经在这里提到了DynamoDB，我不妨展示一个使用<code class="fe mx my mz na b">reduce()</code>从一个对象动态生成DynamoDB更新表达式的例子</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="f892" class="np mb iq na b gy of og l oh oi"><em class="ls">const </em>ExpressionAttributeNames = {prop1: 'prop1', prop2: 'prop2', prop3: 'prop3'}<br/><br/><em class="ls">const </em>UpdateExpression = <strong class="na ir"><em class="ls">Object</em></strong>.values(ExpressionAttributeNames)<br/>  .reduce((acc, curr) =&gt; `${acc} #${curr} = :${curr},`, 'SET').slice(0, -1);<br/><br/><em class="ls">console</em>.log(UpdateExpression);<br/><em class="ls">// SET #prop1 = :prop1, #prop2 = :prop2, #prop3 = :prop3</em></span></pre><p id="9c6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们获取一个对象，并动态创建一个表示DynamoDB更新表达式语法的字符串。如果对DynamoDB不熟悉，也不用太担心。看看我们如何在一个简单的reduce函数中从<code class="fe mx my mz na b">ExpressionAttributeNames</code>到<code class="fe mx my mz na b">SET #prop1 = :prop1, #prop2 = :prop2, #prop3 = :prop3</code>。您可以使用类似的逻辑来生成任何表达式、csv或您可能需要的任何其他字符串。</p><p id="4aa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用DynamoDB并且想要一个关于如何使用我的动态更新表达式工具的完整例子，你可以查看完整的要点</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然reduce非常强大，但要理解它通常很困难。在大多数情况下，您真正想要的是构建在reduce之上的更高层次的抽象。在上面的要点中，我们将reduce函数包装在一个叫做<code class="fe mx my mz na b">DynamicUpdateExpressionFromObject</code>的更高层次的抽象中。在解决Canva面试问题的例子中，我们将把reduce封装在一个抽象出实现的函数中。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b271" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">包扎</h1><p id="82a3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">一旦你熟悉了<code class="fe mx my mz na b">map()</code>、<code class="fe mx my mz na b">filter()</code>和<code class="fe mx my mz na b">reduce()</code>，我保证你会被你的代码的美丽和简单所吸引。将您的业务逻辑视为数据流经的管道，这是一种非常诱人的思考代码的方式。它帮助您将所有副作用推到代码的边缘，减少测试路径，为开发人员将额外的责任偷偷放入您的函数提供任何缝隙，并极大地提高您代码的<a class="ae kv" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity#:~:text=Cyclomatic%20complexity%20is%20a%20software,in%201976." rel="noopener ugc nofollow" target="_blank"> <em class="ls">圈复杂度</em> </a> <em class="ls"> </em>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="6aaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想学习<strong class="ky ir">如何</strong>实际重构现有代码，请关注我即将出版的电子书，它将详细介绍如何重构，并将包含更多真实世界的例子和应用。你可以在这里以10美元的折扣价预订这本书。</p><h2 id="e4d4" class="np mb iq bd mc nq nr dn mg ns nt dp mk lf nu nv mm lj nw nx mo ln ny nz mq oa bi translated"><strong class="ak">简明英语JavaScript</strong></h2><p id="6432" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">plain English . io</strong></a>找到一切的链接！</p></div></div>    
</body>
</html>