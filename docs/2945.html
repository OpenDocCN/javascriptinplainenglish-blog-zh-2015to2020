<html>
<head>
<title>Why You Should Avoid Abstract Classes in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该避免在TypeScript中使用抽象类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-should-avoid-abstract-classes-in-typescript-bcbdd3a87db6?source=collection_archive---------1-----------------------#2020-08-09">https://javascript.plainenglish.io/why-you-should-avoid-abstract-classes-in-typescript-bcbdd3a87db6?source=collection_archive---------1-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8cbb3f7675604b20d7fd5e87b0e35865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iZk_ocHOLdltGl1W"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Steve Johnson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2e29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript中的抽象类是由关键字<code class="fe lb lc ld le b">abstract</code>定义的。它应该由其他类派生，而不是直接实例化。</p><p id="2401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的例子有BaseLogger，它是一个抽象类，强制派生类实现它的<code class="fe lb lc ld le b">abstract</code>方法。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0a4e" class="ln lo iq le b gy lp lq l lr ls">abstract class BaseLogger {<br/>    abstract log(msg: string): void<br/>}</span><span id="0299" class="ln lo iq le b gy lt lq l lr ls"><strong class="le ir">// Error! Non-abstract class 'DebugLogger' does not implement inherited abstract member 'log' from class 'BaseLogger'.</strong></span><span id="a689" class="ln lo iq le b gy lt lq l lr ls">class DebugLogger extends BaseLogger {<br/>    <strong class="le ir">// log method must be implemented</strong><br/>}</span></pre><p id="2201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抽象类类似于具有方法的接口，但一个不同之处是它也可以包含共享实现。注意，这些方法的方法名前面没有<code class="fe lb lc ld le b">abstract</code>关键字。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e352" class="ln lo iq le b gy lp lq l lr ls">abstract class BaseLogger {<br/>    abstract log(msg: string): void</span><span id="2bdc" class="ln lo iq le b gy lt lq l lr ls">    public formatMessage(msg: string): string {<br/>       return msg.toLowerCase();<br/>    }<br/>}</span><span id="bd3b" class="ln lo iq le b gy lt lq l lr ls">class DebugLogger extends BaseLogger {<br/>   <br/>    public log(msg: string): void {<br/>       const formattedMessage = this.formatMessage(msg);</span><span id="30ad" class="ln lo iq le b gy lt lq l lr ls">       console.log(msg);<br/>    }<br/>}</span></pre><p id="ceb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理论上，这是一种很好的共享代码的方式。然而在实践中，我发现代码共享的好处经常被高估，特别是当抽象类的实现数量随着时间增长时。然后开始花更多的时间去理解抽象，而不仅仅是复制。当有真正可共享的代码时，<strong class="kf ir">更喜欢组合而不是继承</strong>。出于这个原因，我尽量避免抽象类，而更喜欢实用程序和接口，它们更符合单一责任原则。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a58d" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">// Use interfaces to enforce implementation<br/></strong>export interface Logger {<br/>   log(msg: string): void;<br/>}</span><span id="5a2b" class="ln lo iq le b gy lt lq l lr ls"><strong class="le ir">// Use utilities to share code<br/></strong>export const formatMessage = (msg: string) =&gt; msg.toLowerCase()</span><span id="413d" class="ln lo iq le b gy lt lq l lr ls">// <em class="lu">in DebugLogger.ts</em><br/>class DebugLogger implements Logger {<br/>   <br/>   public log(msg): void {<br/>       const formattedMessage = formatMessage(msg);</span><span id="110f" class="ln lo iq le b gy lt lq l lr ls">       console.log(msg);<br/>   }<br/>}</span></pre><p id="c620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然上面的代码实现了相同的目标，但是提取的实用程序具有可测试性的额外好处。记住，你不能实例化抽象类，因此它们是不可独立测试的。虽然你可能认为抽象类是扩展类的实现细节，但这仍然意味着单元测试覆盖的代码量更少，比集成测试更便宜。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="354e" class="ln lo iq le b gy lp lq l lr ls">// Error! Cannot create an instance of an abstract class.<br/>const baseLogger = new BaseLogger();</span></pre><p id="856c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">最后，即使使用VSCode IntelliSense，跟踪实现也需要更长的时间</strong>。使用类而不是接口的一个好处是你的定义和实现都在一个地方，使用“转到定义”功能时只需快速按键。相比之下，如果您试图调试一个依赖于派生类实现的抽象类方法，它通常会让您搜索多个实现，在文件之间跳转。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4eda" class="ln lo iq le b gy lp lq l lr ls">abstract class BaseLogger {<br/>    abstract log(msg: string): void</span><span id="0ea2" class="ln lo iq le b gy lt lq l lr ls">    public logWithInfo(msg: string): string {<br/>       // Where is the implementation of this.log?<br/>       return this.log(`${msg} + 'some extra info'); <br/>    }<br/>}</span></pre><p id="55e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，可读性、可测试性和开发人员工效学都是我尽可能避免抽象类的原因。</p></div></div>    
</body>
</html>