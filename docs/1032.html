<html>
<head>
<title>ES6 — Object vs. Map for storing key value pairs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6 —存储键值对的对象与映射</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/es6-object-vs-map-for-storing-key-value-pairs-9b06a7efece9?source=collection_archive---------2-----------------------#2020-01-18">https://javascript.plainenglish.io/es6-object-vs-map-for-storing-key-value-pairs-9b06a7efece9?source=collection_archive---------2-----------------------#2020-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="c2be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">编辑4月21日:添加时间复杂度基准</em></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="7747" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于各种原因，我们经常需要存储键值对。我发现大多数时候人们(包括我自己)使用<code class="fe le lf lg lh b">Object</code>数据结构来实现这一点，尽管ES6提供了一个<code class="fe le lf lg lh b">Map</code>数据结构，看起来确实像我们应该使用的。</p><p id="21d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着看看这两者之间有什么不同，好吗？</p><p id="0e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">披露:我将调用<code class="fe le lf lg lh b">key</code>的<code class="fe le lf lg lh b">Map</code>键(这是正确的)和<code class="fe le lf lg lh b">Object</code>属性，因为我们在本文中讨论存储键值对。</p><h1 id="fefb" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">基础</h1><p id="85b3" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">当涉及到像添加或获取一个值这样的基本操作时，使用一个或另一个没有太大的区别。</p><h2 id="e138" class="ml lj iq bd lk mm mn dn lo mo mp dp ls kj mq mr lw kn ms mt ma kr mu mv me mw bi translated">目标</h2><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="7d4c" class="ml lj iq lh b gy nf ng l nh ni">// init<br/>const keyValue = {}</span><span id="07a3" class="ml lj iq lh b gy nj ng l nh ni">// add<br/>keyValue['firstname'] = 'tony'</span><span id="1210" class="ml lj iq lh b gy nj ng l nh ni">// get<br/>keyValue['firstname']</span></pre><h2 id="2326" class="ml lj iq bd lk mm mn dn lo mo mp dp ls kj mq mr lw kn ms mt ma kr mu mv me mw bi translated">地图</h2><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="2832" class="ml lj iq lh b gy nf ng l nh ni">// init<br/>const keyValue = new Map()</span><span id="ebbd" class="ml lj iq lh b gy nj ng l nh ni">// add<br/>keyValue.set('firstname', 'tony')</span><span id="3dc6" class="ml lj iq lh b gy nj ng l nh ni">// get<br/>keyValue.get('firstname')</span></pre><p id="0e4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是:当试图从一个不存在的键中获取一个值时，两者都返回<code class="fe le lf lg lh b">undefined</code></p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="c229" class="ml lj iq lh b gy nf ng l nh ni">const o = {}<br/>o['firstname'] // undefined</span><span id="00a5" class="ml lj iq lh b gy nj ng l nh ni">const m = new Map()<br/>m.get('firstanme') // undefined</span></pre><h1 id="fe87" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">重复</h1><p id="9c5b" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">存储和获取值是很好的，但是我们通常还需要遍历集合。</p><p id="3376" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe le lf lg lh b">Map</code>非常简单，因为它是可迭代的。这意味着您可以直接使用内置的<code class="fe le lf lg lh b">forEach</code>函数:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="5080" class="ml lj iq lh b gy nf ng l nh ni">const kv = new Map()<br/>kv.set('firstname', 'tony')<br/>kv.set('lastname', 'stark')</span><span id="7b41" class="ml lj iq lh b gy nj ng l nh ni">kv.forEach((value, key) =&gt; console.log(key, value))</span><span id="48c9" class="ml lj iq lh b gy nj ng l nh ni">// firstname tony<br/>// lastname stark</span></pre><p id="0b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在<code class="fe le lf lg lh b">Object</code>中是不可能的。尽管有很多方法可以解决这个问题。其中两个是:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="fb2d" class="ml lj iq lh b gy nf ng l nh ni">const kv = {}<br/>kv['firstname'] = 'tony'<br/>kv['lastname'] = 'stark'</span><span id="1ae4" class="ml lj iq lh b gy nj ng l nh ni">Object.keys(kv).forEach((key) =&gt; console.log(key, kv[key]))</span><span id="c74d" class="ml lj iq lh b gy nj ng l nh ni">// firstname tony<br/>// lastname stark</span></pre><p id="004c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="d305" class="ml lj iq lh b gy nf ng l nh ni">Object.entries(kv).forEach((entry) =&gt; console.log(entry[0], entry[1]))</span><span id="c2c7" class="ml lj iq lh b gy nj ng l nh ni">// firstname tony<br/>// lastname stark</span></pre><p id="0af9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe le lf lg lh b">Map</code>绝对更容易，更简洁，可读性更强</p><h1 id="271e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">检查是否有钥匙</h1><p id="f8c6" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">在<code class="fe le lf lg lh b">Map</code>中检查一个键非常简单:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="1f01" class="ml lj iq lh b gy nf ng l nh ni">const kv = new Map()<br/>kv.set('firstname', 'tony')<br/>kv.set('lastname', 'stark')</span><span id="3c59" class="ml lj iq lh b gy nj ng l nh ni">kv.has('firstname') // true<br/>kv.has('nickname') // false</span></pre><p id="e311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe le lf lg lh b">Object</code>就没那么简单了:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="052c" class="ml lj iq lh b gy nf ng l nh ni">const kv = {}<br/>kv['firstname'] = 'tony'<br/>kv['lastname'] = 'stark'</span><span id="9280" class="ml lj iq lh b gy nj ng l nh ni">Object.prototype.hasOwnProperty.call(kv, 'firstname') // true<br/>Object.prototype.hasOwnProperty.call(kv, 'nickname') // false</span></pre><p id="0ea8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于检查对象是否有属性的更多细节<a class="ae nk" href="https://medium.com/javascript-in-plain-english/the-right-way-to-check-if-an-object-has-a-property-in-javascript-10da3160a1e4" rel="noopener">在这里</a>。</p><p id="274c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里<code class="fe le lf lg lh b">Map</code>似乎更方便</p><h1 id="a6ac" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">数量/长度/尺寸</h1><p id="245b" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">猜猜看，由于<code class="fe le lf lg lh b">Map</code>有一个内置属性，什么更简单</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="1a8d" class="ml lj iq lh b gy nf ng l nh ni">const kv = new Map()<br/>kv.set('firstname', 'tony')<br/>kv.set('lastname', 'stark')</span><span id="2487" class="ml lj iq lh b gy nj ng l nh ni">kv.size // 2</span></pre><p id="e020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe le lf lg lh b">Object</code>你必须创建一个iterable，然后获得它的长度</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="c280" class="ml lj iq lh b gy nf ng l nh ni">const kv = {}<br/>kv['firstname'] = 'tony'<br/>kv['lastname'] = 'stark'</span><span id="a597" class="ml lj iq lh b gy nj ng l nh ni">Object.keys(kv).length // 2</span></pre><h1 id="1279" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">时间复杂度</h1><p id="cff6" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">哪个表现更好？我根据<a class="ae nk" href="https://stackoverflow.com/questions/31091772/javascript-es6-computational-time-complexity-of-collections/54385459" rel="noopener ugc nofollow" target="_blank">这篇</a> StackOverflow帖子写了一小段代码，然后用<code class="fe le lf lg lh b">size = 1000</code>运行它:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="ea82" class="ml lj iq lh b gy nf ng l nh ni">const benchmarkMap = size =&gt; {<br/> console.time('Map insert')<br/>  const kv = new Map()<br/>  for (let i = 0; i &lt; size; i++) {<br/>   kv.set(i, i)<br/>  }<br/>  console.timeEnd('Map insert')<br/> console.time('Map retrieve')<br/>  for (let i = 0; i &lt; size; i++) {<br/>   kv.get(i)<br/>  }<br/>  console.timeEnd('Map retrieve')<br/>}</span><span id="6432" class="ml lj iq lh b gy nj ng l nh ni">const benchmarkObject = size =&gt; {<br/> console.time('Object insert')<br/>  const kv = {}<br/>  for (let i = 0; i &lt; size; i++) {<br/>   kv[i] = i;<br/>  }<br/>  console.timeEnd('Object insert')<br/>  console.time('Object retrieve')<br/>  for (let i = 0; i &lt; size; i++) {<br/>   kv[i]<br/>  }<br/>  console.timeEnd('Object retrieve')<br/>}</span></pre><p id="783e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我得到的信息:</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="1343" class="ml lj iq lh b gy nf ng l nh ni">Map insert: 0.099853515625ms<br/>Map retrieve: 0.0751953125ms<br/>Map insert: 0.095947265625ms<br/>Map retrieve: 0.093994140625ms<br/>Map insert: 0.076904296875ms<br/>Map retrieve: 0.06005859375ms<br/>Map insert: 0.0869140625ms<br/>Map retrieve: 0.05908203125ms<br/>Map insert: 0.078125ms<br/>Map retrieve: 0.057861328125ms</span><span id="a415" class="ml lj iq lh b gy nj ng l nh ni">Object insert: 0.041015625ms<br/>Object retrieve: 0.028076171875ms<br/>Object insert: 0.035888671875ms<br/>Object retrieve: 0.02783203125ms<br/>Object insert: 0.038818359375ms<br/>Object retrieve: 0.029052734375ms<br/>Object insert: 0.035888671875ms<br/>Object retrieve: 0.031005859375ms<br/>Object insert: 0.035888671875ms<br/>Object retrieve: 0.029052734375ms</span></pre><p id="ed0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe le lf lg lh b">Object</code>看起来更快，但是请注意，我们在这里讨论的是毫秒级，处理1000个键值对。</p><h1 id="b798" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">有趣的事情要知道</h1><ul class=""><li id="6501" class="nl nm iq ka b kb mg kf mh kj nn kn no kr np kv nq nr ns nt bi translated"><code class="fe le lf lg lh b">Object</code>只能将<code class="fe le lf lg lh b">string</code>存储为关键字，而它可能是<code class="fe le lf lg lh b">Map</code>的任何内容。作为一个例子，下面是完全可以的</li></ul><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="a3a0" class="ml lj iq lh b gy nf ng l nh ni">const m = new Map()<br/>m.set(['a', 'b'], true)<br/>m.set(['a', 'c'], false)</span></pre><p id="1060" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使你指定一个数字作为键，它也会被当作一个<code class="fe le lf lg lh b">string</code></p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="52cf" class="ml lj iq lh b gy nf ng l nh ni">const o = {}<br/>o[1] = 'iron man'<br/>o[1] // 'iron man'<br/>o['1'] // 'iron man'</span></pre><ul class=""><li id="3e43" class="nl nm iq ka b kb kc kf kg kj nu kn nv kr nw kv nq nr ns nt bi translated"><code class="fe le lf lg lh b">Object</code>已经有了原型这意味着已经有了一些键集</li></ul><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="9ef6" class="ml lj iq lh b gy nf ng l nh ni">const o = {}<br/>o['constructor'] // ƒ Object() { [native code] }</span><span id="db51" class="ml lj iq lh b gy nj ng l nh ni">const m = new Map()<br/>m.get('constructor') // undefined</span></pre><p id="543b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe le lf lg lh b">Map</code>没有</p><ul class=""><li id="3314" class="nl nm iq ka b kb kc kf kg kj nu kn nv kr nw kv nq nr ns nt bi translated"><code class="fe le lf lg lh b">JSON</code>支持<code class="fe le lf lg lh b">Object</code>但不支持<code class="fe le lf lg lh b">Map</code></li></ul><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="ad53" class="ml lj iq lh b gy nf ng l nh ni">const kv = {}<br/>kv['firstname'] = 'tony'<br/>kv['lastname'] = 'stark'</span><span id="b96e" class="ml lj iq lh b gy nj ng l nh ni">JSON.stringify(kv) // '{"firstname":"tony","lastname":"stark"}'</span></pre><p id="bde2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在哪里</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="8a5c" class="ml lj iq lh b gy nf ng l nh ni">const kv = new Map()<br/>kv.set('firstname', 'tony')<br/>kv.set('lastname', 'stark')</span><span id="74e2" class="ml lj iq lh b gy nj ng l nh ni">JSON.stringify(kv) // '{}'</span></pre><p id="8831" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果您需要序列化数据，通过HTTP调用发送数据，那么<code class="fe le lf lg lh b">Map</code>不是一个好的选择</p><h1 id="a183" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">选哪个？</h1><p id="470b" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">在我看来<code class="fe le lf lg lh b">Map</code>应该是你存储键值对的好方法，除非你需要序列化数据。你不仅可以使用<code class="fe le lf lg lh b">string</code>作为键，事实上它是在<code class="fe le lf lg lh b">has()</code>和<code class="fe le lf lg lh b">size</code>之上的一个iterable，这将使你的生活变得轻松。</p><p id="49ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你想表示某事时，应该使用。因此，您可能会对每个属性使用不同的逻辑。</p><pre class="mx my mz na gt nb lh nc nd aw ne bi"><span id="4cc8" class="ml lj iq lh b gy nf ng l nh ni">const ironman = {<br/>  firstname: 'tony',<br/>  lastname: 'stark',<br/>  hello: function() {<br/>    return `I am ${this.firstname} ${this.lastname}`<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>