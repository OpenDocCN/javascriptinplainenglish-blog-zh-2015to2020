<html>
<head>
<title>Pros &amp; Cons of Local Persistence Strategies for React-Native Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-Native应用程序的本地持久性策略的利弊</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/pros-cons-of-local-persistence-strategies-for-react-native-apps-52dd68b636b6?source=collection_archive---------1-----------------------#2019-12-02">https://javascript.plainenglish.io/pros-cons-of-local-persistence-strategies-for-react-native-apps-52dd68b636b6?source=collection_archive---------1-----------------------#2019-12-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d686" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在React Native中使用本地存储或“伪后端”的一些好处</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/97a436151e160bebacf8e277190ca2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*xlVjTaSJNZGSvIcnSmjSTA.jpeg"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="kk kl l"/></div></figure><p id="aefd" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">使用本地存储或“<strong class="ko io">假后端”</strong>的一些好处包括——改善用户体验、加快加载速度、简化消息传递界面和服务器端功能。下面是3种不同的数据持久性策略的利弊——考虑最佳实践和产品开发阶段(MVP到大规模)。</p><ol class=""><li id="ff20" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh ln lo lp lq bi translated"><strong class="ko io"> AsyncStorage </strong> —内置的本地和会话存储</li></ol><p id="ebd2" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">它只存储字符串数据的键值对，不加密，每个应用程序限制为5MB，并且是异步的。</p><p id="2b9b" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io">优点</strong></p><ul class=""><li id="140a" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">减轻了对服务器和外部数据库的依赖</li><li id="01e8" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">易于使用且简单的一行程序实现</li><li id="30ec" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">不会延迟应用程序的加载，并且比数据读取更快</li><li id="0faf" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated"><strong class="ko io"> MVP考虑事项— </strong>可能是MVP/POC产品的简单解决方案—在转换到生产就绪型解决方案之前可以使用。</li></ul><p id="fd3f" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io"> CONS </strong></p><ul class=""><li id="ba3c" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">悄悄达到5MB限制……—需要了解5MB对于应用程序的需求是否足够？</li><li id="1066" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">自IOS 8 — <em class="lx">起，在设备内存不足的情况下，</em>可以清除5MB的限制😞</li><li id="94d8" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">需要数据类型转换，因为它只保存字符串数据。</li><li id="1cf1" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">出于进一步的安全原因:需要制定序列化/去序列化和内容安全政策，以维护数据的安全。</li></ul><p id="2eca" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io">最佳实践建议</strong></p><ul class=""><li id="cb11" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">广泛使用，但不推荐用于存储敏感数据。不建议依赖数据的<strong class="ko io">持久性</strong>——至于上面的缺点。</li></ul><p id="2a22" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">阅读更多相关信息— <a class="ae ly" href="https://pusher.com/tutorials/persisting-data-react-native" rel="noopener ugc nofollow" target="_blank">在React Native中持久化数据</a>。</p><p id="585d" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io"> 2。REDUX-PERSIST或REDUX-OFFLINE </strong> —保持减少器、动作和状态</p><p id="5777" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">使用现有Redux实现进行全局状态管理的库。</p><p id="7ce3" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io">赞成者</strong></p><ul class=""><li id="2f64" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">可以在严重依赖Redux的应用程序中正常工作</li><li id="bd0c" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">可以保存轻量级数据(比如一系列id ),这些数据将用于在服务器上获取数据。</li></ul><p id="0f94" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io"> CONS </strong></p><ul class=""><li id="4a20" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">对于大容量数据存储来说不是最好的</li><li id="e511" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">这些库正在经历大量的变化和被否决的版本…</li><li id="780a" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">存储缩减器、动作和状态的边缘情况增加了复杂性。</li><li id="4b60" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">android中的“扼流圈”</li><li id="8c47" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">通常强烈反对——因为缺乏简单本地存储实现的优势，并且需要学习管理(如redux-loggers接口)它所提供的功能。</li></ul><p id="30e4" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io">最佳实践建议:</strong></p><ul class=""><li id="174c" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">应该只在很好理解的用例中使用——因为简单的JS对象和本地存储在大多数情况下就足够了。</li></ul><p id="1b39" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">了解更多信息— <a class="ae ly" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener">丹·阿布拉莫夫讨论“为什么要使用Redux？”</a>具体来说，不是用一系列教程的其他简单解决方案。</p><p id="ec8b" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io"> 3。离线第一个移动应用</strong> —带本地数据库</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/7b6c57bf65a60f5132de2c699a2e22b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZV3Zy_uuLXLmrT6sNjvew.png"/></div></div></figure><p id="4ffe" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">离线优先移动应用程序开发—假设用户离线，网络速度慢，服务器不可靠，连接延迟高，公共wifi被代理。那么该架构由三个关键部分组成:</p><ol class=""><li id="c5d6" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh ln lo lp lq bi translated">使用简单的设备数据库(如React Native的<a class="ae ly" href="https://realm.io/docs/javascript/latest/" rel="noopener ugc nofollow" target="_blank">领域</a>)</li><li id="b942" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh ln lo lp lq bi translated">与服务器的通信</li><li id="c2c4" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh ln lo lp lq bi translated">同步数据将驻留的服务器，以便可以将数据分发给任何有权限的人。</li></ol><p id="a272" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io">优点</strong></p><ul class=""><li id="cdd5" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">无缝的在线和离线应用性能</li><li id="d11f" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">尊重用户的电池和网络资源</li></ul><p id="bd59" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io"> CONS </strong></p><ul class=""><li id="e4e7" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">引入了一系列新的应用程序开发模式，如ass发布-订阅流、缓存和同步——传统CRUD应用程序和少量本地存储的附加层将很好地发挥作用。</li><li id="a464" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">这很难😅— <a class="ae ly" href="https://calvium.com/why-most-app-developers-run-a-mile-from-offline-app-development/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko io">为什么大多数应用开发者都远离线下——先开发</strong> </a> <strong class="ko io"> t </strong></li></ul><p id="080b" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">了解更多信息—h<a class="ae ly" href="https://www.simform.com/react-native-database-selection-guide/" rel="noopener ugc nofollow" target="_blank">ttps://www . sim form . com/react-native-database-selection-guide/</a></p><p id="ec27" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated"><strong class="ko io">一些结论</strong></p><ul class=""><li id="4ccb" class="li lj in ko b kp kq ks kt kv lk kz ll ld lm lh lr lo lp lq bi translated">没有一种策略是明显的赢家😟因为每个人都有一些缺点，或者至少有一些值得警惕的地方。</li><li id="8abe" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">AsyncStorage是最直接的解决方案，适合保证使用少于5MB的应用程序，通过添加加密和安全策略小心处理敏感的用户数据。尽管要小心记忆擦拭🤯</li><li id="740d" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">离线优先的本地数据库实现似乎适合一个很好理解的产品，它有大量无缝离线性能的案例。拥有大量资源的非常敏锐的技术团队——因为性能的承诺是巨大的——但潜在的问题也很多…</li><li id="ee5f" class="li lj in ko b kp ls ks lt kv lu kz lv ld lw lh lr lo lp lq bi translated">正在经历巨大变化并与Redux集成的本地持久性库属于灰色地带，没有强烈建议使用那些没有良好用例的库，“只是存储JS对象！”😅</li></ul><p id="1dbb" class="pw-post-body-paragraph km kn in ko b kp kq jo kr ks kt jr ku kv kw kx ky kz la lb lc ld le lf lg lh ig bi translated">如果您遇到了其他优雅的本地持久性策略，请分享！🙌</p></div></div>    
</body>
</html>