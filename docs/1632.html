<html>
<head>
<title>List of MobX Modifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MobX修改器列表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/list-of-mobx-modifiers-d266b9957ec6?source=collection_archive---------10-----------------------#2020-04-08">https://javascript.plainenglish.io/list-of-mobx-modifiers-d266b9957ec6?source=collection_archive---------10-----------------------#2020-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/46f62f7e3a5da1316a9fb3433427c1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wGW40jcc6kmNbDUL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@obkim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Qijin Xu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="77cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MobX有一组装饰器来改变可观察属性的行为。</p><p id="8223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将一个一个地看它们，看看我们如何使用它们。</p><h1 id="32fe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修饰语</h1><p id="32ca" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">MobX附带了以下装饰器，它们定义了可观察属性的行为方式:</p><ul class=""><li id="8c1d" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">observable</code>—<code class="fe mn mo mp mq b">observable.deep</code>的别名</li><li id="442a" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">observable.deep</code> —任何可观察对象使用的默认修饰符。它克隆和转换任何数组，地图或普通对象到它的可观察的对应物</li><li id="aaf0" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">observable.ref</code> —禁用自动可观察转换，改为创建可观察参考</li><li id="a824" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">observable.shallow</code> —只能用于集合。将任何指定的集合转换为可观察的集合，但是值将按原样处理</li><li id="7ee4" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">observable.struct</code> —类似于<code class="fe mn mo mp mq b">ref</code>，但忽略结构上等于当前值的新值</li><li id="ed28" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">computed</code> —创建派生属性</li><li id="c521" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">computed(options)</code> —与<code class="fe mn mo mp mq b">computed</code>相同，但设置了附加选项</li><li id="deaa" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">computed.struct</code> —与<code class="fe mn mo mp mq b">computed</code>相同，但仅当产生的值在结构上不同于之前的值时，才通知任何is观察者。</li><li id="0a2e" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">action</code> —创建一个操作</li><li id="15ce" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">action(name)</code> —创建操作并覆盖名称</li><li id="ffa9" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated"><code class="fe mn mo mp mq b">action.bound</code> —创建操作并将<code class="fe mn mo mp mq b">this</code>绑定到实例。</li></ul><p id="b94e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">装饰者可以使用MobX的<code class="fe mn mo mp mq b">decorate</code>、<code class="fe mn mo mp mq b">observable.object</code>、<code class="fe mn mo mp mq b">extendObservable</code>和<code class="fe mn mo mp mq b">observable</code>来指定对象成员应该如何表现。</p><p id="1238" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，<code class="fe mn mo mp mq b">observable.deep</code>是任何键值对的默认行为，而<code class="fe mn mo mp mq b">computed</code>是getters的默认行为。</p><p id="89fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以定义一个可观察值如下:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="eb3b" class="ne lc iq mq b gy nf ng l nh ni">import { observable, action } from "mobx";</span><span id="7ea8" class="ne lc iq mq b gy nj ng l nh ni">const person = observable(<br/>  {<br/>    firstName: "John",<br/>    lastName: "Smith",<br/>    age: 42,</span><span id="df82" class="ne lc iq mq b gy nj ng l nh ni">  get fullName() {<br/>      return `${this.firstName} ${this.lastName}`;<br/>    },</span><span id="5c81" class="ne lc iq mq b gy nj ng l nh ni">  setAge(age) {<br/>      this.age = age;<br/>    }<br/>  },<br/>  {<br/>    setAge: action<br/>  }<br/>);</span></pre><p id="72b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，除了被我们明确定义为<code class="fe mn mo mp mq b">action</code>的<code class="fe mn mo mp mq b">setAge</code>之外，所有成员都有默认的装饰器。</p><p id="3ee5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe mn mo mp mq b">firstName</code>、<code class="fe mn mo mp mq b">lastName</code>、<code class="fe mn mo mp mq b">age</code>是<code class="fe mn mo mp mq b">observable</code> s，<code class="fe mn mo mp mq b">fullName</code>是<code class="fe mn mo mp mq b">computed</code>字段。</p><p id="9212" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用<code class="fe mn mo mp mq b">decorate</code>功能:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="3b23" class="ne lc iq mq b gy nf ng l nh ni">import { observable, action, decorate } from "mobx";</span><span id="3e0f" class="ne lc iq mq b gy nj ng l nh ni">class Person {<br/>  firstName = "John";<br/>  lastName = "Smith";<br/>  age = 42;</span><span id="1479" class="ne lc iq mq b gy nj ng l nh ni">  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }</span><span id="0c9e" class="ne lc iq mq b gy nj ng l nh ni">  setAge(age) {<br/>    this.age = age;<br/>  }<br/>}</span><span id="064d" class="ne lc iq mq b gy nj ng l nh ni">decorate(Person, {<br/>  firstName: observable,<br/>  lastName: observable,<br/>  age: observable,<br/>  setAge: action<br/>});</span></pre><p id="f661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用类作为第一个参数来调用<code class="fe mn mo mp mq b">decorate</code>，然后用一个包含我们想要修改的字段的对象作为第二个参数。</p><p id="ee9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mn mo mp mq b">firstName</code>、<code class="fe mn mo mp mq b">lastName</code>和<code class="fe mn mo mp mq b">age</code>设为可观察值，将<code class="fe mn mo mp mq b">setAge</code>设为动作。</p><p id="f21f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">fullName</code>是一个计算字段，因为它是getters的默认选项。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/39797147fa92b28bc02095f194b3ecc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cz5dxl34o3qNFYot"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@obkim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Qijin Xu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7722" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">深度可观测性</h1><p id="c32e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当MobX使用<code class="fe mn mo mp mq b">observable</code>、<code class="fe mn mo mp mq b">observable.object</code>或<code class="fe mn mo mp mq b">extendObservable</code>创建一个可观察对象时，它引入了默认使用<code class="fe mn mo mp mq b">deep</code>修饰符的可观察属性。</p><p id="c1c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">深度修饰符递归地调用<code class="fe mn mo mp mq b">observable(newValue)</code>任何使用<code class="fe mn mo mp mq b">deep</code>修饰符的赋值，直到它到达对象的底层。</p><h1 id="1980" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考可观测性</h1><p id="6f8d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在某些情况下，物体不需要转换成可观察的。例如，我们不想为不可变对象或由外部库管理的对象这样做。</p><p id="baf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们可以使用<code class="fe mn mo mp mq b">ref</code>修改器。</p><p id="23af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="e648" class="ne lc iq mq b gy nf ng l nh ni">class Person {<br/>  firstName = "John";<br/>  lastName = "Smith";<br/>  @observable.ref age = 42;<br/>}</span></pre><p id="e22c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们给<code class="fe mn mo mp mq b">age</code>添加了<code class="fe mn mo mp mq b">observable.ref</code>装饰器，这样MobX将只跟踪它的引用，而不会试图转换它的值。</p><p id="2abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用ES5语法，我们可以编写以下代码:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="3187" class="ne lc iq mq b gy nf ng l nh ni">import { observable, extendObservable } from "mobx";</span><span id="6a42" class="ne lc iq mq b gy nj ng l nh ni">function Person() {<br/>  extendObservable(<br/>    this,<br/>    {<br/>      name: "Joe",<br/>      age: 42<br/>    },<br/>    {<br/>      age: observable.ref<br/>    }<br/>  );<br/>}</span></pre><h1 id="740d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浅层可观察性</h1><p id="d1d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe mn mo mp mq b">observable.shallow</code>修改器来应用一级深度的可观察性。我们需要这个来创建一个可观察的引用集合。</p><p id="c0be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不会像<code class="fe mn mo mp mq b">deep</code>那样递归地应用可观测性。</p><p id="a689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="a808" class="ne lc iq mq b gy nf ng l nh ni">class Books {<br/>  @observable.shallow authors = [];<br/>}</span></pre><p id="d21e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">{ deep: false }</code>可以作为选项传递给<code class="fe mn mo mp mq b">observable</code>、<code class="fe mn mo mp mq b">observable.object</code>、<code class="fe mn mo mp mq b">observable.array</code>、<code class="fe mn mo mp mq b">observable.map</code>和<code class="fe mn mo mp mq b">extendObservable</code>来创建浅层集合。</p><h1 id="5bb9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c2db" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用修饰符来改变MobX观察值变化的方式。</p><p id="8257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，它递归地查看值的变化。</p><p id="985d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有用于计算值、浅层观察等的修改器。</p><h2 id="1bd6" class="ne lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">JavaScript用简单的英语写的一个注释:</h2><p id="ea1d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>