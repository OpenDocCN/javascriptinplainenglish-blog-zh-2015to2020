<html>
<head>
<title>Callback vs Promise and Async/Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的回调vs承诺和异步/等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/callback-vs-promise-and-async-await-1e46bc1780f4?source=collection_archive---------0-----------------------#2018-02-12">https://javascript.plainenglish.io/callback-vs-promise-and-async-await-1e46bc1780f4?source=collection_archive---------0-----------------------#2018-02-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/5383d8c68b2e09c9f30b5552d6fd5bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*LC5w61m746VZNBVpEzUT4g.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Callback vs Promise and Async/Await</figcaption></figure><h1 id="81c8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">回调函数</h1><p id="875f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">回调函数是作为参数传递给另一个函数的函数，它在other function内部被调用(或执行)。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lr"><img src="../Images/0e6352bca5af0712793c1fdee27eb024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFwxkr6xutDaR6jBA8xvdQ.jpeg"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Example: callback</figcaption></figure><p id="1f60" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">所以处理异步操作的基本方法是通过回调。但是当处理大量依赖的异步操作时，很快就会陷入回调地狱。</p><h1 id="69b0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">承诺</h1><p id="64e2" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kv io"> Promise </strong>对象表示异步操作的最终完成(或失败)及其结果值。</p><p id="8e22" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">从本质上讲，承诺是一个返回的对象，您可以将回调附加到该对象上，而不是将回调传递到函数中。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/8b5363ea8219c7e2433607f8bf5b5d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*Eg0ZoO6IlHCl5G7PwLSpVQ.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Example: Promise</figcaption></figure><p id="ba11" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">一个<strong class="kv io">承诺</strong>是一个在承诺创建时不一定知道的值的代理。它允许您将处理程序与异步操作的最终成功值或失败原因相关联。这使得异步方法像同步方法一样返回值:异步方法不是立即返回最终值，而是返回一个<em class="mg">承诺</em>在未来的某个时间提供该值。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mh"><img src="../Images/8a44d97bd7f1f5d5c7e5dd4206ec98ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1EZpcctuSoa6Jcwp68SUQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Promise-concept</figcaption></figure><p id="33ed" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">以下部分选项可通过<strong class="kv io">承诺获得。</strong></p><p id="8d51" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated"><strong class="kv io"> 1。Promise.all </strong></p><p id="e592" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated"><strong class="kv io"> Promise.all(iterable) </strong>方法返回单个<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>，当iterable参数中的所有承诺都已解析或iterable参数不包含承诺时，该承诺将解析。它用拒绝的第一个承诺的理由拒绝。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/d369501c922f7eec30197cc781f3ce98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*6wsBSDtCfZpdLfQu69zZcA.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Example: Promise.all</figcaption></figure><p id="f9eb" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated"><strong class="kv io"> 2。承诺.竞赛</strong></p><p id="2c13" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated"><strong class="kv io"> Promise.race(iterable) </strong>方法返回一个承诺，该承诺在iterable中的一个承诺解析或拒绝后立即解析或拒绝，并带有该承诺的值或原因。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c80a96d26a17cb0857183e719dd3e5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*BqOE6jkF2A_y_5ZlZBlZlw.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Example: Promise.race</figcaption></figure><h1 id="eccd" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">异步&amp;等待</strong></h1><p id="fb8a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kv io">异步函数</strong>声明定义了一个<em class="mg">异步函数</em>，它返回一个<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener ugc nofollow" target="_blank">异步函数</a>对象。</p><p id="5046" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">Async/await实际上是建立在承诺之上的。它不能用于普通回调或节点回调。</p><p id="e91b" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">函数前面的单词“async”意味着一件简单的事情:函数总是返回一个承诺。如果代码中有return <non-promise>,那么JavaScript会自动将它包装到一个具有该值的解析承诺中。</non-promise></p><p id="98fe" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">关键字await让JavaScript一直等到承诺完成并返回结果。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ml"><img src="../Images/174030ed78ca92f7f7135cd39ee4e7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIE0ABz-b1DVq0hnDEp1Lw.jpeg"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Example: Async/Await</figcaption></figure><p id="9810" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">我们应该使用哪种方法？</p><p id="4cba" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">我们有以下选项来处理JavaScript中的异步问题。</p><ol class=""><li id="b297" class="mm mn in kv b kw ma la mb le mo li mp lm mq lq mr ms mt mu bi translated">回收</li><li id="ca3e" class="mm mn in kv b kw mv la mw le mx li my lm mz lq mr ms mt mu bi translated">承诺</li><li id="eb30" class="mm mn in kv b kw mv la mw le mx li my lm mz lq mr ms mt mu bi translated">异步/等待</li><li id="f5c4" class="mm mn in kv b kw mv la mw le mx li my lm mz lq mr ms mt mu bi translated">RxJS可观测量</li></ol><p id="3c4a" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">如果你别无选择或者只能处理一个异步操作，就使用<strong class="kv io">回调</strong>。代码仍然是完全可管理和可理解的。回调函数本身并不坏，只是在许多情况下存在更好的替代方法。</p><p id="713d" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">一个这样的例子是多个链接的(或相关的)异步操作。在这种情况下，当你试图使用回调时，你很快就进入了回调地狱。<strong class="kv io">承诺</strong>是以结构化和可预测的方式处理你的运营的伟大工具。</p><p id="a05d" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated"><strong class="kv io"> async/ await </strong>是一个非常棒的工具，适用于那些你并不真的想要或者需要使用可观测量，但是仍然想要使用承诺的情况。您可以使用async/ await编写“同步”代码，并更轻松地处理您的承诺链。</p><p id="f461" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">在所有使用承诺的情况下，你也可以使用<strong class="kv io">可观察到的</strong>。但是RxJS是第三方库，用来处理数据流上的异步操作。</p><h1 id="8e4b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">总结</strong></h1><p id="3f5c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kv io"> 1。回调</strong>有进入回调地狱的危险</p><p id="bb00" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">2.<strong class="kv io">承诺</strong>逃脱回调地狱</p><p id="111e" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">3.<strong class="kv io">异步/等待</strong>编写“同步”代码并承诺</p><p id="dca4" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">4.<strong class="kv io">可观察对象</strong>处理数据流并应用操作员魔法</p><p id="ac09" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">请在以下<a class="ae mi" href="https://gist.github.com/santoshshinde2012/2f9a9a34c8e6523b46c97c0de9d3cf5f" rel="noopener ugc nofollow" target="_blank">要点</a>中找到所有示例源代码。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>