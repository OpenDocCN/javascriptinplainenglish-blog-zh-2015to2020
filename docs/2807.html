<html>
<head>
<title>React Tips — this, Merging States, and Mock Functions in Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React提示——这是测试中的合并状态和模拟功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-this-merging-states-and-mock-functions-in-tests-7f18e8787ed2?source=collection_archive---------10-----------------------#2020-07-25">https://javascript.plainenglish.io/react-tips-this-merging-states-and-mock-functions-in-tests-7f18e8787ed2?source=collection_archive---------10-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/15b127f6c5bc4128b5a07210209c1eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-Ic76888zFmvKo_9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alfi413?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ALFI CANIAGO</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bf35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="8259" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用setState合并状态而不是覆盖</h1><p id="d4bd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们传入一个回调到方法而不是一个对象，我们可以用<code class="fe me mf mg mh b">setState</code>合并状态而不是覆盖。</p><p id="1a0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cb00" class="mq lc iq mh b gy mr ms l mt mu">this.setState({ x: 1 });</span></pre><p id="6117" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c621" class="mq lc iq mh b gy mr ms l mt mu">this.setState((prevState, props) =&gt; ({<br/>  point: {<br/>    ...prevState.point,<br/>    y: 1<br/>  },<br/>));</span></pre><p id="f45c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一个回调，该回调将前一个状态作为第一个参数。</p><p id="eb20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将先前状态的值合并到返回的对象中。</p><p id="27cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在它后面加上<code class="fe me mf mg mh b">y</code>。</p><h1 id="ddc5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何在每个测试中改变Jest模拟函数的返回值</h1><p id="ed91" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过用<code class="fe me mf mg mh b">jest.fn()</code>创建模拟函数来改变模拟函数的实现。</p><p id="2afa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过传入一个返回我们想要的值的回调函数来调用<code class="fe me mf mg mh b">mockImplementation</code>方法。</p><p id="9376" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以将返回值作为参数传递。</p><p id="6ec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c939" class="mq lc iq mh b gy mr ms l mt mu">import { foo, bar } from './module';</span><span id="fae7" class="mq lc iq mh b gy mv ms l mt mu">jest.mock('./module', () =&gt; ({<br/>  foo: jest.fn(),<br/>  bar: jest.fn()<br/>}));</span></pre><p id="6f2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">jest.fn()</code>模拟模块的方法。</p><p id="6e6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在上面写下调用<code class="fe me mf mg mh b">mockImplementation</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e801" class="mq lc iq mh b gy mr ms l mt mu">foo.mockImplementation(() =&gt; true)</span></pre><p id="18fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ce0c" class="mq lc iq mh b gy mr ms l mt mu">foo.mockImplementation(true)</span></pre><p id="6754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的测试中。</p><p id="f92c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在不同的测试中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0286" class="mq lc iq mh b gy mr ms l mt mu">foo.mockImplementation(() =&gt; false)</span></pre><p id="e140" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a805" class="mq lc iq mh b gy mr ms l mt mu">foo.mockImplementation(false)</span></pre><p id="ebd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有我们可以使用的<code class="fe me mf mg mh b">mockReturnValueOnce</code>方法。</p><p id="c184" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3b0f" class="mq lc iq mh b gy mr ms l mt mu">import { foo, bar } from './module';</span><span id="61b7" class="mq lc iq mh b gy mv ms l mt mu">jest.mock('./module', () =&gt; ({<br/>  foo: jest.fn(),<br/>  bar: jest.fn()<br/>}));</span><span id="1b31" class="mq lc iq mh b gy mv ms l mt mu">describe('test suite', () =&gt; {<br/>  it('some test', () =&gt; {<br/>    foo.mockReturnValueOnce(true);<br/>    bar.mockReturnValueOnce(false);<br/>  });<br/>});</span></pre><h1 id="87fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React出错时更换img src</h1><p id="4156" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以向img元素添加一个错误处理程序，以便在出错时加载另一个图像。</p><p id="8df1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ed66" class="mq lc iq mh b gy mr ms l mt mu">import React, { Component } from 'react';<br/>import PropTypes from 'prop-types';</span><span id="564d" class="mq lc iq mh b gy mv ms l mt mu">class Image extends Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="9546" class="mq lc iq mh b gy mv ms l mt mu">    this.state = {<br/>      src: props.src<br/>    };<br/>  }</span><span id="04ce" class="mq lc iq mh b gy mv ms l mt mu">  onError = () =&gt; {<br/>    this.setState({<br/>      src: this.props.fallbackSrc,<br/>    });<br/>  }</span><span id="636c" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    const { src } = this.state;</span><span id="2559" class="mq lc iq mh b gy mv ms l mt mu">    return (<br/>      &lt;img<br/>        src={src}<br/>        onError={this.onError}<br/>        {...props}<br/>      /&gt;<br/>    );<br/>  }<br/>}</span><span id="e8ef" class="mq lc iq mh b gy mv ms l mt mu">Image.propTypes = {<br/>  src: PropTypes.string,<br/>  fallbackSrc: PropTypes.string,<br/>};</span></pre><p id="afd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在错误处理程序中用<code class="fe me mf mg mh b">fallbackSrc</code>替换<code class="fe me mf mg mh b">src</code>状态。</p><p id="6b58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，当带有给定的<code class="fe me mf mg mh b">src</code>字符串的图像无法加载时，我们将它设置为<code class="fe me mf mg mh b">fallbackSrc</code>值，作为img的<code class="fe me mf mg mh b">src</code>属性值。</p><h1 id="73cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用React创建“如果”组件</h1><p id="fd44" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用布尔表达式来创建一个组件，有条件地显示一些东西。</p><p id="f156" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7b4b" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>  {(cond<br/>    ? &lt;div&gt;It's true&lt;/div&gt;     <br/>    : &lt;div&gt;It's false&lt;/div&gt;<br/>  )}<br/>&lt;/div&gt;</span></pre><p id="a80c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">cond</code>为<code class="fe me mf mg mh b">true</code>，则显示<code class="fe me mf mg mh b">&lt;div&gt;It’s true&lt;/div&gt;</code>。</p><p id="0f85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，显示<code class="fe me mf mg mh b">&lt;div&gt;It’s false&lt;/div&gt;</code>。</p><p id="7397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以将<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">false</code>作为不呈现任何内容的空组件。</p><p id="ffbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3f60" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>  {showChild ? &lt;Child /&gt; : false}<br/>&lt;/div&gt;</span></pre><p id="6633" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">showChild</code>是<code class="fe me mf mg mh b">true</code>，我们显示<code class="fe me mf mg mh b">Child</code>组件。</p><p id="c7a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们什么也不显示。</p><p id="fe36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用<code class="fe me mf mg mh b">if</code>来表述:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="138d" class="mq lc iq mh b gy mr ms l mt mu">renderPerson() {<br/>  const personName = '';<br/>  if (personName) {<br/>    return &lt;div&gt;{personName}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="e083" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们显示<code class="fe me mf mg mh b">personName</code>是否存在。</p><p id="0003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">render</code>中，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="925f" class="mq lc iq mh b gy mr ms l mt mu">render() {<br/>  return (<br/>    &lt;div&gt;<br/>      {this.renderPerson()}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="fb03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们渲染<code class="fe me mf mg mh b">personName</code>如果它存在的话。</p><p id="aa1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="269a" class="mq lc iq mh b gy mr ms l mt mu">{cond &amp;&amp; (&lt;div&gt;It's true&lt;/div&gt;)}</span></pre><h1 id="796a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将物体作为道具传递给JSX</h1><p id="bc0d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要用JSX传递一个对象作为道具，我们可以使用spread操作符。</p><p id="09cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a25" class="mq lc iq mh b gy mr ms l mt mu">&lt;Child  {...commonProps} /&gt;</span></pre><p id="7dd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">commonProps</code>是一个对象。</p><p id="2d47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的键都作为道具传入。</p><p id="b0be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的值都作为道具的值传入。</p><h1 id="1ec4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复此问题。状态未定义</h1><p id="f237" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在类方法中使用了<code class="fe me mf mg mh b">this.state</code>，那么我们应该调用<code class="fe me mf mg mh b">bind</code>将类设置为方法中<code class="fe me mf mg mh b">this</code>的值。</p><p id="9147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bc96" class="mq lc iq mh b gy mr ms l mt mu">&lt;Form onClick={this.onClick.bind(this)}/&gt;</span></pre><p id="4b7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，<code class="fe me mf mg mh b">this.onClick</code>方法中的<code class="fe me mf mg mh b">this</code>值将被设置为该类，因为<code class="fe me mf mg mh b">this</code>是该类。</p><p id="2070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe me mf mg mh b">this.onClick.bind(this)</code>放到道具中会在每次渲染时创建一个新函数，所以我们应该将它放在构造函数中以避免这种情况:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0568" class="mq lc iq mh b gy mr ms l mt mu">constructor(props) {<br/>  super(props);<br/>  this.state = {<br/>    users: null<br/>  }<br/>  this.onClick = this.onClick.bind(this);<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/060778bf5a589b20603dc6fc367e335d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cl8RIrll0M0CIW88"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kredekar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kedar Redekar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3178" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d309" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用一些方法模仿Jest方法的返回值。</p><p id="a144" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以合并状态，而不是覆盖它们。</p><p id="80d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以有条件地渲染物品。</p><p id="7e41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须调用<code class="fe me mf mg mh b">bind</code>来将<code class="fe me mf mg mh b">this</code>设置为类。</p><h1 id="38f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="7685" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>