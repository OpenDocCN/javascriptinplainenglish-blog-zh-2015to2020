<html>
<head>
<title>Sortable data tables using pure JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用纯JavaScript的可排序数据表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/sortable-data-tables-using-pure-javascript-3a34f7913478?source=collection_archive---------0-----------------------#2019-10-31">https://javascript.plainenglish.io/sortable-data-tables-using-pure-javascript-3a34f7913478?source=collection_archive---------0-----------------------#2019-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b4c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">写技术文章已经有一段时间了，这就是为什么我决定写一篇新的，但有一个小的不同。我决定用英语写这篇文章。我们开始吧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16e452ebfe947a79af6631d3f4a7ac8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q2zveD94ejFUKPSq.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Credit: <a class="ae ky" href="https://unsplash.com/@_imkiran" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@_imkiran</a></figcaption></figure><p id="457d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我目前的公司中有一个功能请求，产品团队请求一个表组件，当单击列的标题时，它应该以升序或降序的方式对列进行排序。在这篇文章的最后，你会看到工作的概念证明。在代码质量方面可能有很多需要改进的地方，但不要忘记，这只是一个概念验证。我期待着您对该准则的回应。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="e690" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我有一个有固定标题的表格。为了简单起见，我有一个只包含四个元素的对象数组。这个表应该按照这些对象的一些属性排序，而不是全部。我必须在不使用任何视图库的情况下构建这个表，只使用普通的JavaScript！</p><p id="d568" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我通常注意采用单一责任原则来编写我的函数。这种方式为编写和调试提供了极大的便利。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="236b" class="ll lm in lh b gy ln lo l lp lq">&lt;table id="squadTable" class="table table-dark table-striped"&gt;<br/>        &lt;thead&gt;<br/>            &lt;tr&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="no"</strong> class="active"&gt;No&lt;/th&gt;<br/>                &lt;th&gt;Name&lt;/th&gt;<br/>                &lt;th&gt;Position&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="age"</strong>&gt;Age&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="match"</strong>&gt;Match&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="time"</strong>&gt;Min&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="goal"</strong>&gt;Goal&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="assist"</strong>&gt;Ast&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="yellowCard"</strong>&gt;YC&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="doubleYellowCard"</strong>&gt;DYC&lt;/th&gt;<br/>                &lt;th <strong class="lh io">data-filter-value="redCard"</strong>&gt;RC&lt;/th&gt;<br/>            &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;</span><span id="8a31" class="ll lm in lh b gy lr lo l lp lq">&lt;/tbody&gt;<br/>&lt;/table&gt;</span></pre><p id="6df2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在帖子最后分享了Codepen链接。为了更好的外观和感觉，我实现了Bootstrap。这就是上面代码中一些泛型类的用途。</p><p id="cf30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还通过在代码中加粗突出显示了可排序的列。正如我前面提到的，这是一个静态POC，所以我静态地编写了数据过滤器值。你可以将它们转换成模板文字，并使用数组等生成。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="cd2e" class="ll lm in lh b gy ln lo l lp lq">th {<br/>  &amp;[data-filter-value] {<br/>            cursor: pointer;<br/>        }  &amp;.active {<br/>            color: red;<br/>        }<br/>}</span></pre><p id="5529" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我没有任何CSS的顾虑，只是因为我在使用Bootstrap。我只想区分可排序列和活动列。我在上面添加了Scss代码。</p><p id="bf99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是我的对象数据数组:</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="f45f" class="ll lm in lh b gy ln lo l lp lq">const data = [{<br/>            "id": "1233213",<br/>            "no": 17,<br/>            "fullName": "Murat Doğan",<br/>            "position": "CMD",<br/>            "age": 29,<br/>            "match": 12,<br/>            "time": 1080,<br/>            "goal": 12,<br/>            "assist": 4,<br/>            "yellowCard": 3,<br/>            "doubleYellowCard": 0,<br/>            "redCard": 2<br/>        }, {<br/>            "id": "41233213",<br/>            "no": 58,<br/>            "fullName": "Volkan Demirel",<br/>            "position": "GK",<br/>            "age": 28,<br/>            "match": 34,<br/>            "time": 3400,<br/>            "goal": 1,<br/>            "assist": 17,<br/>            "yellowCard": 8,<br/>            "doubleYellowCard": 3,<br/>            "redCard": 5<br/>        }, {<br/>            "id": "51233213",<br/>            "no": 18,<br/>            "fullName": "Soldado",<br/>            "position": "ST",<br/>            "age": 33,<br/>            "match": 5,<br/>            "time": 120,<br/>            "goal": 1,<br/>            "assist": 2,<br/>            "yellowCard": 5,<br/>            "doubleYellowCard": 1,<br/>            "redCard": 4<br/>        }, {<br/>            "id": "61233213",<br/>            "no": 27,<br/>            "fullName": "Hasan Ali Kaldırım",<br/>            "position": "DL",<br/>            "age": 18,<br/>            "match": 2,<br/>            "time": 12,<br/>            "goal": 0,<br/>            "assist": 1,<br/>            "yellowCard": 3,<br/>            "doubleYellowCard": 4,<br/>            "redCard": 5<br/>        }];</span></pre><p id="36b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不使用id属性，但是在将来有一个用于任何目的的唯一键是很好的。</p><p id="ea68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些是用于排序的全局变量:</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="9b05" class="ll lm in lh b gy ln lo l lp lq">let currentFilter = "no",<br/>            prevFilter = "",<br/>            orderAsc = true;</span></pre><ul class=""><li id="5689" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">表格的默认排序值将是玩家的号码(否)。我把它设置为当前过滤器。</li><li id="7189" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">上一个过滤器值保留先前选择的过滤器。保存这些数据以处理应用于同一列的点击事件是很重要的。将其从升序转换为降序，反之亦然。</li><li id="6e26" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">订单升序值保持当前的订单类型。关于点击动作，它将被改变。</li></ul><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="80df" class="ll lm in lh b gy ln lo l lp lq">const toggleOrder = () =&gt; {<br/>            if (currentFilter === prevFilter) {<br/>                orderAsc = !orderAsc; // Get same value and assign its opposite.<br/>            } else { <br/>             orderAsc = true;<em class="mg"> </em><br/>            }<br/>        }</span></pre><p id="f8c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我之前提到的，如果用户反复点击同一个列名，就会改变排序的方向。这里我需要一个else情况，因为如果我将一列按降序排序，其他列需要按升序排序。有点重新排序的意思:)</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="aac0" class="ll lm in lh b gy ln lo l lp lq">const sortTable = (array, sortKey) =&gt; {<br/>           return array.sort((a, b) =&gt; {<br/>                let x = a[sortKey],<br/>                    y = b[sortKey];                return orderAsc ? x - y : y - x; // <a class="ae ky" href="https://medium.com/@muratdogan/javascript-hap-yaz%C4%B1s%C4%B1-ternary-operator-2788782189fb" rel="noopener">ternary operator</a> <br/>            });<br/>        }</span></pre><p id="14fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数将两个参数作为一个数组和一个排序变量。我在这里使用Array.sort方法来捕捉前一个和后一个变量之间的差异。如果想比较字符串值，可以使用大于号或小于号。如果你想按升序排序，它使用x-y或y-x来表示相反的情况。</p><p id="c828" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里涉及到渲染表:</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="934a" class="ll lm in lh b gy ln lo l lp lq">const renderTable = tableData =&gt; {<br/>            return (`${tableData.map(item =&gt; {<br/>                return (<br/>                    `&lt;tr&gt;<br/>                        &lt;td&gt;${item.no}&lt;/td&gt;<br/>                        &lt;td&gt;${item.fullName}&lt;/td&gt;<br/>                        &lt;td&gt;${item.position}&lt;/td&gt;<br/>                        &lt;td&gt;${item.age}&lt;/td&gt;<br/>                        &lt;td&gt;${item.match}&lt;/td&gt;<br/>                        &lt;td&gt;${item.time}&lt;/td&gt;<br/>                        &lt;td&gt;${item.goal}&lt;/td&gt;<br/>                        &lt;td&gt;${item.assist}&lt;/td&gt;<br/>                        &lt;td&gt;${item.yellowCard}&lt;/td&gt;<br/>                        &lt;td&gt;${item.doubleYellowCard}&lt;/td&gt;<br/>                        &lt;td&gt;${item.redCard}&lt;/td&gt;<br/>                    &lt;/tr&gt;`<br/>                )<br/>            }).join('')}`);<br/>        }</span></pre><p id="e5ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数的唯一目的是呈现关于给定数据的tr元素。它使用映射遍历数组，并为每个数组返回字符串输出。如果你对链尾的join方法很好奇，我来解释一下！Map函数返回一个新数组，join方法通过在每个数组项的末尾添加一个空字符串来帮助我们<strong class="jm io">连接</strong>这些数组项。来源:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" rel="noopener ugc nofollow" target="_blank"> Mdn </a></p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="a40f" class="ll lm in lh b gy ln lo l lp lq">const appendTable = (table, destination) =&gt; {<br/>            document.querySelector(destination).innerHTML = table;<br/>        }</span></pre><p id="0cb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数的唯一目的是将给定的元素追加到给定的目的地。这个函数的命名可能更通用，但正如我之前提到的，这只是一个概念验证。您应该将其重命名为append etc。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="20d7" class="ll lm in lh b gy ln lo l lp lq">const handleSortClick = () =&gt; {<br/>            const filters = document.querySelectorAll('#squadTable th');<br/>            Array.prototype.forEach.call(filters, filter =&gt; {<br/>                filter.addEventListener("click", () =&gt; {<br/>                    if (!filter.dataset.filterValue) return false;<br/>                    Array.prototype.forEach.call(filters, filter =&gt; {<br/>                        filter.classList.remove('active');<br/>                    });<br/>                    filter.classList.add('active');<br/>                    currentFilter = filter.dataset.filterValue;<br/>                    toggleOrder();<br/>                    init();<br/>                });<br/>            })<br/>        }</span></pre><p id="5cd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最好把这一节写得更详细些。我硬编码了列标题的选择器，但是您可以将选择器作为参数传递。没那么难。</p><p id="0428" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我正在查询所有th元素，并使用forEach进行循环。如果你对我为什么不使用Array.forEach感到好奇，让我解释一下:<em class="mg">过滤器</em>变量是一个列表，但它只是一个<em class="mg">节点列表。如果你正在处理节点列表，你不能使用数组的每一个方法。它提供了浏览器兼容性和对forEach的访问。</em></p><p id="ec42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我正在检查标题是否有排序属性。如果不是，我在函数的最开始返回false，并且不执行整个函数。</p><p id="bcd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我要提一下这个令人愉快的特性:<strong class="jm io">数据集</strong>。如果想要访问dom元素的所有数据属性，可以使用dataset而不是getAttribute(…)列出所有属性。你应该注意这种用法。数据属性是kemap-case，但是您需要使用camelCase来访问它们。</p><p id="8544" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我正在做一些课堂作业和触发切换功能。我也在触发初始化函数。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="1071" class="ll lm in lh b gy ln lo l lp lq">const init = () =&gt; {<br/>      let newTableData = sortTable(data, currentFilter),<br/>          tableOutput = renderTable(newTableData);appendTable(tableOutput, '#squadTable tbody');<br/>        prevFilter = currentFilter;<br/>        }</span></pre><p id="47fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在这里做所有的短工。让我们来看看是怎么回事:</p><ul class=""><li id="bace" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">我正在使用当前的过滤器参数重新格式化我的球员数据。当我在其他函数中更改当前的过滤器时，它可以帮助我轻松地进行排序。</li><li id="1791" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">为分配给<em class="mg">表输出</em>的表创建字符串Html输出。</li><li id="73d6" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">我把这个输出附加到我声明的地方。</li><li id="a312" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">我可以在整个过程结束时将当前过滤器指定为前一个过滤器。</li></ul><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="03ab" class="ll lm in lh b gy ln lo l lp lq">init();<br/>handleSortClick();</span></pre><p id="6bcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在其他函数中调用init函数，所以我不在init函数中调用handleSortClick。这可以防止将事件重新绑定到选择器。你可以分享更好的方法来改进这些代码。</p><p id="8652" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建这个表只需要大约70行代码。如果我们保持数据对象的分离。这取决于模板，但我认为它很短，很容易实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><div class="mj mk gp gr ml mm"><a href="https://codepen.io/muratdogan17/embed/qozQVr?height=353&amp;theme-id=0&amp;default-tab=js,result" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">CodePen Embed -纯JavaScript可排序表</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">const data = [{ "id": "1233213 "，" no": 17，" full name ":" Murat doan "，" position": "CMD "，" age": 29，" dateOfBirth"…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">codepen.io</p></div></div></div></a></div><p id="fb81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读这篇文章直到这一行。我期待着你的回应，使这个代码更好。</p></div></div>    
</body>
</html>