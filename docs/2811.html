<html>
<head>
<title>Node.js Tips — File Size, Plain Text Request Body, Sending Messages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—文件大小、纯文本请求正文、发送消息</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-file-size-plain-text-request-body-sen-73fd1724d9cb?source=collection_archive---------3-----------------------#2020-07-26">https://javascript.plainenglish.io/node-js-tips-file-size-plain-text-request-body-sen-73fd1724d9cb?source=collection_archive---------3-----------------------#2020-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/17a6f42bf1528c695289fee6a5ccd377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OHxvzmxEZsfegawh"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nxn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nikolay Tchaouchev</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="cb36" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">强制将请求正文解析为纯文本，而不是Express中的JSON</h1><p id="65c4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以移除主体解析器中间件，将请求主体作为原始文本进行解析。</p><p id="39e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ebd5" class="mn lc iq mj b gy mo mp l mq mr">const express = require('express');</span><span id="6fa6" class="mn lc iq mj b gy ms mp l mq mr">const app = express();</span><span id="8a6b" class="mn lc iq mj b gy ms mp l mq mr">const parseRawBody = (req, res, next) =&gt; {<br/>  req.setEncoding('utf8');<br/>  req.rawBody = '';<br/>  req.on('data', (chunk) =&gt; {<br/>    req.rawBody += chunk;<br/>  });<br/>  req.on('end', () =&gt; {<br/>    next();<br/>  });<br/>}</span><span id="2c05" class="mn lc iq mj b gy ms mp l mq mr">app.use(parseRawBody);</span><span id="26d8" class="mn lc iq mj b gy ms mp l mq mr">app.post('/test', (req, res) =&gt; {<br/>  res.send(req.rawBody);<br/>});</span><span id="eac6" class="mn lc iq mj b gy ms mp l mq mr">app.listen(3000);</span></pre><p id="ea9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了自己的<code class="fe mt mu mv mj b">parseRawBody</code>中间件，接受请求、响应对象和<code class="fe mt mu mv mj b">next</code>函数。</p><p id="bca2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">req</code>是请求，是读流。</p><p id="beb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过监听<code class="fe mt mu mv mj b">data</code>事件从中获取数据。</p><p id="a145" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">data</code>事件的处理程序中，我们将文本块连接到<code class="fe mt mu mv mj b">req.rawBody</code>属性。</p><p id="e887" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当发出<code class="fe mt mu mv mj b">end</code>事件时，流就不再有数据要发出，所以我们调用<code class="fe mt mu mv mj b">next</code>来移动到下一个中间件。</p><p id="94e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在随后的路线中访问<code class="fe mt mu mv mj b">req.rawBody</code>。</p><p id="78d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用body-parser包，那么我们可以使用<code class="fe mt mu mv mj b">bodyParser.text()</code>中间件将请求体保持为纯文本。</p><p id="c956" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5b7b" class="mn lc iq mj b gy mo mp l mq mr">app.use(bodyParser.text());</span></pre><p id="f75a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容来访问请求体:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6d2a" class="mn lc iq mj b gy mo mp l mq mr">app.get('/', (req, res) =&gt; {<br/>  res.send(req.body);<br/>})</span></pre><p id="c2c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">req.body</code>具有带请求体的字符串。</p><h1 id="1f48" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Socket.io和空消息队列向特定客户端发送消息</h1><p id="97d2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要向特定的客户端发送消息，并使用socket.io清空消息队列，我们可以监听<code class="fe mt mu mv mj b">connection</code>事件，然后将<code class="fe mt mu mv mj b">socket</code>对象设置为一个对象的属性。</p><p id="a418" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9a03" class="mn lc iq mj b gy mo mp l mq mr">const socketio = require('socket.io');<br/>const clients = {};<br/>const io = socketio.listen(app);</span><span id="2217" class="mn lc iq mj b gy ms mp l mq mr">io.sockets.on('connection', (socket) =&gt; {<br/>  clients[socket.id] = socket;<br/>});</span></pre><p id="663a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性名是套接字的ID，由<code class="fe mt mu mv mj b">socket.id</code>属性表示。</p><p id="519f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们保存了每个客户端的套接字，以便我们稍后可以调用<code class="fe mt mu mv mj b">emit</code>向客户端发送消息。</p><p id="cb86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写下一条信息:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d148" class="mn lc iq mj b gy mo mp l mq mr">const socket = clients[socketId];<br/>socket.emit('show', {});</span></pre><p id="cad0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe mt mu mv mj b">socketId</code>是我们之前设置的套接字的ID。</p><p id="cd29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用自己的事件和想要发送的数据调用<code class="fe mt mu mv mj b">emit</code>。</p><h1 id="a1ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修改快速请求对象</h1><p id="6e83" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要修改Express的请求对象，我们可以在请求对象中分配我们的属性。</p><p id="0991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="da4a" class="mn lc iq mj b gy mo mp l mq mr">app.use((req, res, next) =&gt; {<br/>  req.root = `${req.protocol}://${req.get('host')}`;<br/>  next();<br/>});</span></pre><p id="8b23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">req.root</code>属性设置为URL的协议和主机的组合。</p><p id="2094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调是一个我们可以在任何地方使用的中间件。</p><p id="f9fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">next</code>是调用链中下一个中间件的函数。</p><h1 id="d055" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中查找文件的大小</h1><p id="ad68" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">stateSync</code>找到一个文件的大小。</p><p id="b676" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="01b0" class="mn lc iq mj b gy mo mp l mq mr">function getFileSize(filename) {<br/>  const stats = fs.statSync(filename);<br/>  const fileSizeInBytes = stats.size;<br/>  return fileSizeInBytes;<br/>}</span></pre><p id="36cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe mt mu mv mj b">filename</code>参数上调用<code class="fe mt mu mv mj b">statsSync</code>，这是一个文件的字符串路径。</p><p id="0840" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe mt mu mv mj b">size</code>属性得到字节大小。</p><p id="deb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe mt mu mv mj b">filesize</code>包来获取文件大小。</p><p id="5ca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cebe" class="mn lc iq mj b gy mo mp l mq mr">const filesize = require("filesize");<br/>const stats = fs.statSync("foo.txt");<br/>const fileSizeInMb = filesize(stats.size, {round: 0});</span></pre><p id="a6b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个包的好处是我们可以把尺寸转换成我们喜欢的任何格式。</p><p id="a5b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以改变基底，将其转换为对象，等等。</p><p id="fdb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的示例将大小转换为以兆字节为单位的文件大小。</p><p id="c1ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容进行其他转换:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5e51" class="mn lc iq mj b gy mo mp l mq mr">const filesize = require("filesize");<br/>const stats = fs.statSync("foo.txt");<br/>const fileSizeMb = filesize(stats.size, {round: 0});         <br/>const fileSizeArray = filesize(stats.size, {output: "array"});  <br/>const fileSizeObj = filesize(stats.size, {output: "object"});</span></pre><p id="4464" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组将大小和单位作为数组的单独条目。</p><p id="11c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">object</code>把大小、并集、指数放在自己的属性里。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5dbacb16a8b00ff113d761e9ca89c38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pd5I-zurBUZU-2m-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lightupphotos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cristina Anne Costello</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fb9d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="56ac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用各种方式保存请求正文。</p><p id="232c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一些库可以帮助我们得到我们想要的格式的文件大小。</p><p id="f809" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用Socket.io向特定的客户端发送消息。</p><h2 id="4c2d" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="f111" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>