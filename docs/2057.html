<html>
<head>
<title>Getting started with Augmented Reality using NativeScript Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NativeScript Vue开始增强现实</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-augmented-reality-using-nativescript-vue-6ea434b28e2b?source=collection_archive---------8-----------------------#2020-05-16">https://javascript.plainenglish.io/getting-started-with-augmented-reality-using-nativescript-vue-6ea434b28e2b?source=collection_archive---------8-----------------------#2020-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/993f524bbe5adda1581c3a61abfce5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*BsNPtOoMbk2xhqHS.PNG"/></div></figure></div><div class="ab cl jr js hr jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ig ih ii ij ik"><p id="49df" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">口袋妖怪Go移动游戏成功后，人们对移动设备上的增强现实(AR)应用的兴趣稳步增长。安卓和iOS都有自己的增强现实框架，但是有了NativeScript和可用的增强现实插件，你可以开始学习如何用更低的学习曲线创建自己的跨平台增强现实应用。本文将向您展示使用NativeScript Vue开发一个简单的AR应用程序的基础知识，该应用程序用于放置、动画制作和与3D对象交互。</p><p id="4c48" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated"><a class="ae kw" href="https://www.youtube.com/watch?v=8cMZOnv0M7Y" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=8cMZOnv0M7Y</a></p><h1 id="a4d1" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置空白的NS Vue应用程序</h1><p id="b170" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">首先，让我们使用CLI构建一个名为ns6ar的新NativeScript Vue应用程序(本文使用NativeScript v6.5.o)。出现提示时，选择要开始的Vue.js和Blank模板。完成后，运行CLI诊断以确保您的NS环境没有问题。然后，将<a class="ae kw" href="https://github.com/EddyVerbruggen/nativescript-ar" rel="noopener ugc nofollow" target="_blank"> NativeScript AR插件</a>(本文为v1.1.0)添加到空白应用程序中。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b0dd" class="mj ky in mf b gy mk ml l mm mn">tns create ns6ar<br/>cd ns6ar<br/>tns doctor<br/>tns plugin add nativescript-ar</span></pre><h1 id="fb98" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">警告</h1><p id="31f7" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">在我们开始在安卓和iOS上创建增强现实应用程序之前，有一些重要的事情需要记住。<strong class="ka io">你</strong> <strong class="ka io">不能在iOS模拟器上使用AR</strong>、<strong class="ka io">所以你会</strong>、<a class="ae kw" href="https://www.redmondpie.com/ios-11-arkit-compatibility-check-if-your-device-is-compatible-with-apples-new-ar-platform/" rel="noopener ugc nofollow" target="_blank">、<strong class="ka io">需要一个支持ARkit </strong>、</a>的真正的苹果设备。对于iOS设备，这意味着您将需要一款至少运行iOS 11的iPhone SE/6和iPad Pro/2017或更新版本。<a class="ae kw" href="https://developer.apple.com/documentation/arkit/tracking_and_visualizing_faces" rel="noopener ugc nofollow" target="_blank">如果您想支持面部跟踪</a>，那么您还需要一款正面朝向原深感摄像头的iOS设备，这款设备目前仅在苹果X/XS/XS Max/XR、iPad Pro (11英寸)和iPad Pro (12.9英寸，第三代)上提供。这个插件只支持ARkit v1，所以较新的版本(也需要绝对最新的硬件)和它们的特性在当前版本的插件中不可用。</p><p id="d275" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated"><strong class="ka io">对于Android，你</strong> <a class="ae kw" href="https://developers.google.com/ar/develop/java/emulator#create_a_virtual_device_with_ar_support" rel="noopener ugc nofollow" target="_blank"> <strong class="ka io">可以在某些模拟器配置上使用AR</strong></a>。要使用模拟器进行开发，请进入Android Studio中的AVD(Android虚拟设备)管理器，并使用Pixel 2基本配置创建一个新的虚拟设备(这也包括对Play Store的支持，因为需要用于AR包的Google Play服务)。在下一个屏幕上选择Oreo API 27或更新的操作系统版本，并在最后一个屏幕上打开高级设置，并确保背面摄像头设置为使用VirtualScene，如下所示。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/6d075ab92164046a345ef9f554d2d1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/0*PdVoONkmUTzVJ34o.png"/></div></figure><p id="13b3" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">最后，进入Android ARcore APK发布页面，下载<code class="fe mp mq mr mf b">Google_Play_Services_for_AR_1.16.0_x86_for_emulator.apk</code>。启动模拟器，加载后运行以下命令来安装库。</p><p id="e63d" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated"><code class="fe mp mq mr mf b">adb install -r Google_Play_Services_for_AR_1.16.0_x86_for_emulator.apk</code></p><p id="a95a" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">您可以<a class="ae kw" href="https://developers.google.com/ar/discover/supported-devices" rel="noopener ugc nofollow" target="_blank">查看该页面，了解您的设备是否受支持</a>或者尝试运行其中一个演示应用。不过总的来说，最好使用真实的Android设备而不是模拟器来开发AR应用程序，这样你就可以测试该应用程序在现实世界中的工作情况。</p><p id="d29f" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">最后，在开发和修改AR应用程序代码时，确保禁用热模块重载，因为这通常会导致插件崩溃(使用<code class="fe mp mq mr mf b">tns run &lt;platform&gt; --no-hmr</code>)。</p><h1 id="e031" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置AR视图</h1><p id="9672" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">让我们从修改空白模板应用程序开始，这样我们就可以使用AR插件通过设备摄像头显示增强现实视图。我们首先需要通过在导入声明后向<code class="fe mp mq mr mf b">app/app.js</code>添加下面一行来注册插件:</p><p id="10b4" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated"><code class="fe mp mq mr mf b">Vue.registerElement("AR", () =&gt; require("nativescript-ar").AR);</code></p><p id="2e1a" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">我们将通过将<code class="fe mp mq mr mf b">app/components/Home.vue</code>的内容更改为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="bc4f" class="mj ky in mf b gy mk ml l mm mn">&lt;template&gt;<br/>    &lt;Page&gt;<br/>        &lt;ActionBar title="NS6Vue AR"&gt;&lt;/ActionBar&gt;<br/>        &lt;GridLayout&gt;<br/>            &lt;AR trackingMode="WORLD" debugLevel="FEATURE_POINTS" :planeMaterial="planeMaterial" planeOpacity="0.4" planeDetection="HORIZONTAL" showStatistics="false" @arLoaded="arLoaded" @sceneTapped="sceneTapped" @planeTapped="planeTapped" @planeDetected="planeDetected"&gt;<br/>            &lt;/AR&gt;<br/>        &lt;/GridLayout&gt;<br/>    &lt;/Page&gt;<br/>&lt;/template&gt;</span><span id="b768" class="mj ky in mf b gy ms ml l mm mn">&lt;script&gt;<br/>import { Color } from "tns-core-modules/color";<br/>import { isIOS, isAndroid } from "tns-core-modules/platform";<br/>export default {<br/>    data() {<br/>        return {<br/>            planeMaterial: new Color("white"),          <br/>        }<br/>    },<br/>    methods: {<br/>        arLoaded(arLoadedEventData) {<br/>            console.log("&gt;&gt; AR Loaded!");<br/>            const arView = arLoadedEventData.object;<br/>        },<br/>        planeDetected(ARPlaneDetectedEventData) {<br/>            console.log("&gt;&gt; plane Detected!")            <br/>        },<br/>        planeTapped(arPlaneTappedEventData) {<br/>            console.log("&gt;&gt; plane Tapped!")<br/>            const arPlane = arPlaneTappedEventData.object;<br/>            const position = arPlaneTappedEventData.position  <br/>            console.log(position)<br/>        },<br/>        sceneTapped(ARSceneTappedEventData) {<br/>            console.log("&gt;&gt; scene Tapped!")<br/>            const arScene = ARSceneTappedEventData.object;<br/>            const position = ARSceneTappedEventData.position<br/>            console.log(position)<br/>        }<br/>    },<br/>};<br/>&lt;/script&gt;</span><span id="6a8b" class="mj ky in mf b gy ms ml l mm mn">&lt;style scoped lang="scss"&gt;<!-- --> <br/>&lt;/style&gt;</span></pre><p id="38df" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">该页面只包含动作栏和ar视图标签，配置了一些属性和事件处理程序，以及在<code class="fe mp mq mr mf b">script</code>部分定义的相应处理程序方法。你应该通过<a class="ae kw" href="https://github.com/EddyVerbruggen/nativescript-ar/blob/master/docs/tag-properties.md" rel="noopener ugc nofollow" target="_blank">查看插件的文档</a>和插件附带的各种AR应用程序演示来了解这些属性和事件。</p><p id="36c0" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">让我们更详细地回顾一下我们将在这篇文章中使用的AR标签属性和事件。</p><h1 id="9e30" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">AR视图属性</h1><ol class=""><li id="9992" class="mt mu in ka b kb lv kf lw kj mv kn mw kr mx kv my mz na nb bi translated">跟踪模式——“世界”跟踪是默认模式，也是AR应用中最常用的模式。这种模式扫描相机看到的区域，以检测AR对象要与之交互的平面。在这篇文章中，我们将使用世界追踪模式来展示这个插件在两个平台上支持的大部分功能。另一个选项是“人脸”跟踪，它试图在AR视图中找到人脸，在插件包含的demo-glasses目录中可以找到一个很好的示例应用程序。“图像”跟踪试图在扫描时找到预定义的2D图像(如棋盘图案)进行交互，在demo-pokemon目录中可以找到一个示例。</li><li id="abc5" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">planeDetection告诉插件它是否应该尝试并检测平坦表面(平面)和表面类型(水平或垂直)。<strong class="ka io">垂直面检测是IOS才有的</strong>，所以用这个插件做跨平台app的时候应该只设计基于水平面的app。</li><li id="c1c2" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">debugLevel <strong class="ka io">(仅限iOS)</strong>—指定插件将显示哪种额外的调试相关可视信息。“FEATURE_POINTS”将是最有用的，当您在尝试检测要交互的表面时，它会向您显示扫描结果的可视化表示。</li><li id="25dd" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">showStatistics <strong class="ka io">(仅限iOS)</strong>—在AR窗口的底部显示一些统计数据，如FPS，尽管这对于初始开发来说通常不是很有用，所以你可以禁用它，除非你正在处理更复杂的场景和模型。</li><li id="1ed1" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">planeMaterial <strong class="ka io">(仅适用于iOS)</strong>—使用iOS设备时，当插件检测到平面时，您可以指定应用于平面的NS颜色或材质对象。<strong class="ka io">对于Android设备，当平移相机以找到一个平面时，只会显示默认的白色polkadot图案</strong>。在上面的代码中，你会看到我们为iOS设备上检测到的平面选择了白色NS颜色。如果不指定颜色或材质，那么检测到的平面将不会显示任何东西，这使得开发在视觉上有点困难。</li><li id="24bb" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">planeOpacity <strong class="ka io">(仅iOS)</strong>—指定检测到的平面材料/颜色的不透明度，0表示不可见，1表示实心。</li></ol><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3bd95825d724bd807ef035222ded7f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/0*SNA3B3rHZdMPrHfC.jpeg"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">iOS Feature points and plane detection</figcaption></figure><p id="8cc5" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">如果你现在在iOS设备上运行这个应用，在一个平坦的区域周围平移，你应该会看到类似上面截图的东西。特征点将在扫描该区域以获取3D信息时出现，并在您稳定握住相机时消失。当检测到一个平坦的区域时，它会将其着色为半透明的白色平面，让您了解AR插件在扫描过程中发现了什么。</p><p id="29b3" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">如果你在Android设备上运行该应用，并在一个平坦的区域平移，你应该会看到白色圆点覆盖在检测到的平面上，类似于下面的截图。材质和不透明度属性对显示的内容没有影响。</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/801a2996ae535d2d832f1ac16b2c3b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/0*zA9GFyoZ5ryPBro2.jpg"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Android plane detection</figcaption></figure><h1 id="d565" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">AR视图事件</h1><ol class=""><li id="8c54" class="mt mu in ka b kb lv kf lw kj mv kn mw kr mx kv my mz na nb bi translated">arLoaded —当AR视图已加载并准备好与之交互时发送。如果您使用的是速度较慢的设备，或者您的应用程序有长时间运行的初始化代码，请使用此事件来阻止任何与AR相关的功能运行，直到AR视图准备就绪。</li><li id="49cd" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">planeDetected与arLoaded事件类似，如果要将平面用作ar场景中对象的参考点，可以在此设置一个标志，以防止与视图的任何交互，直到检测到平面。</li><li id="7729" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">planeTapped——这是用于与大多数应用程序的AR视图交互的两个主要<strong class="ka io"> </strong>事件之一。如果你要设计一个依赖于固定在平面上的AR对象的应用程序，那么这将是你用来以可控的方式将它们添加到视图中的工具。例如，您可以将一个对象添加到当前视图，以便当用户点击它时，它看起来像是停留在视图中检测到的平面区域的顶部。</li><li id="1589" class="mt mu in ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">sceneTapped —这是用于与AR视图交互的另一个主事件。对于那些您不关心添加的对象是否需要对应于平面的锚点的情况，这允许您在用户点击视图的任何地方添加对象。例如，如果您想要添加一个漂浮在用户点击屏幕的空白空间中的3D模型，例如应用程序中包含的太阳系演示，您可以使用此功能。</li></ol><h1 id="c1a1" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">放置模型</h1><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/4a088d0db89c5585034124b841ab7de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-TPrxrhE7B96NlOF.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Coordinate system in AR</figcaption></figure><p id="b462" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">运行应用程序，在平坦区域周围平移相机，直到检测到一架飞机，点击飞机上的某个地方，你会看到一条控制台消息，让你知道飞机上点击位置的坐标。上面的插图显示了AR插件使用的坐标系，系统中的每个单位对应于现实生活中大约1米。该插件有内置的球体，盒子和管道三维模型，以及一些其他2D建设，包括图像，视频，UIView和平面对象。它还可以加载DAE、USDZ和GLB格式的更复杂的3D模型，尽管到目前为止，除了演示中包含的那些模型之外，我在任何3D模型上都没有取得什么成功。考虑到这一点，让我们从在检测到的平面上点击球体开始。</p><p id="3104" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">将<code class="fe mp mq mr mf b">app/components/Home.vue</code>中的<code class="fe mp mq mr mf b">planeTapped</code>功能替换为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="ffd9" class="mj ky in mf b gy mk ml l mm mn">        planeTapped(ARPlaneTappedEventData) {<br/>            console.log("&gt;&gt; plane Tapped!")<br/>            const arPlane = ARPlaneTappedEventData.object;<br/>            const position = ARPlaneTappedEventData.position<br/>            console.log(position)<br/>            const sphereRadius = 0.1<br/>            arPlane.addSphere({<br/>                radius: sphereRadius,<br/>                position: {<br/>                    x: position.x,<br/>                    y: position.y + sphereRadius,<br/>                    z: position.z - 0.5<br/>                },<br/>                materials: [new Color("blue")],<br/>                onLongPress: interaction =&gt; {<br/>                    console.log("Sphere was longpressed");<br/>                },<br/>                onTap: interaction =&gt; {<br/>                    console.log("Sphere was tapped at coordinates " + interaction.touchPosition.x + " x " + interaction.touchPosition.y);<br/>                },<br/>                segmentCount: 100,<br/>                draggingEnabled: false, //Android only<br/>                rotatingEnabled: false, //Android only<br/>                scalingEnabled: false, //Android only<br/>                mass: 0, //iOS only<br/>            }).then(arNode =&gt; {<br/>                console.log("Sphere successfully added");<br/>            })<br/>        },</span></pre><p id="40bb" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">使用<code class="fe mp mq mr mf b">arPlane</code>对象作为对AR场景的引用，我们调用带有几个参数和事件处理程序的<code class="fe mp mq mr mf b">addSphere</code>函数来添加一个球体的模型。球体的T2为0.1米。它的<code class="fe mp mq mr mf b">position</code>被设置为平面被点击的坐标，除了我们通过它的半径向上移动球体(y轴),使它正好位于平面上方而不是与平面相交，我们还将它设置为离当前视图稍远一点(z轴)。我们将通过使用一个<code class="fe mp mq mr mf b">Color</code>赋予它一个<code class="fe mp mq mr mf b">material</code>来给这个球体涂上蓝色。当有人点击或长按AR模型时，每个AR模型都支持两个事件处理程序<code class="fe mp mq mr mf b">onTap</code>和<code class="fe mp mq mr mf b">onLongPress</code>，我们稍后会用到。<code class="fe mp mq mr mf b">segmentCount</code>用于定义球体模型的细节级别，对于较小的球体或更复杂的场景，您应该将此设置得更低，以保持较高的渲染速率。本例中使用的接下来三个属性<code class="fe mp mq mr mf b">draggingEnabled</code>、<code class="fe mp mq mr mf b">rotatingEnabled</code>和<code class="fe mp mq mr mf b">scalingEnabled</code>仅适用于Android，因此应该禁用它们，因为它们不会影响iOS设备上的模型交互。如果你在Android上运行这个程序并将它们设置为<code class="fe mp mq mr mf b">true</code>，你可以用两个手指的交互来拖动球体，捏缩，扩大和旋转它。<code class="fe mp mq mr mf b">mass</code>属性仅适用于iOS，您可以为其指定一个正值，使其向下“下降”。但是要小心，如果没有平面或者它越过了平面边缘，那么它将会从视图中消失。</p><h1 id="a8d2" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将材质应用于模型</h1><p id="5e40" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">虽然颜色适用于简单的对象和场景，但更有趣的是能够将图像作为材料应用于AR对象。为了让AR插件能够使用这些图像，您必须将它们放在每个平台的<code class="fe mp mq mr mf b">app\App_Resources</code>文件夹下。我创建了一个简单的图像，有黄色背景和7颗红色星星，类似于流行动漫系列中的龙珠。对于Android，我已经在<code class="fe mp mq mr mf b">app/App_Resources/Android/src/main/assets/SevenStar.fw.png</code>中放置了一个副本。对于iOS，我也给<code class="fe mp mq mr mf b">app/App_Resources/iOS/SevenStar.fw.png</code>加了一份。现在我们可以将<code class="fe mp mq mr mf b">materials</code>赋值改为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7daa" class="mj ky in mf b gy mk ml l mm mn">{<br/>  diffuse: { contents: "SevenStar.fw.png", wrapMode: "Clamp" },<br/>}</span></pre><p id="dc26" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">如果您现在在Android上运行该应用程序，您应该会看到类似于以下内容的内容:</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/03dd37de5279151fb2cb7e9dc2967101.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/0*MIneIbJM0FH_z1A1.jpg"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Android sphere with image material</figcaption></figure><p id="24dc" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">它看起来更好，但是模型和材料方向与我们当前的观点不太一致。为了调整这一点，我们可以向<code class="fe mp mq mr mf b">addSphere</code>函数添加一个<code class="fe mp mq mr mf b">rotation</code>属性。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="bd4d" class="mj ky in mf b gy mk ml l mm mn">rotation:isIOS ? { x: -20, y: 0, z: 0 } : { x: 0, y: 100, z: -20 },</span></pre><p id="bc49" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">在Android上，现在应该添加一个球体，看起来像:</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/68250bf75c628d126ffd136ab2aa935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/0*J0KNOjIn4PuPCdl3.jpg"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Rotated Android sphere placement</figcaption></figure><p id="c4ee" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">在iOS上，它应该是这样的:</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/15393ac065cb0907368b930ddaa5bc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/0*_Uk4w00UolJblEM5.PNG"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Rotated iOS sphere placement</figcaption></figure><p id="c613" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">请记住，iOS和Android在位置、方向、比例和旋转方面会呈现不同的对象和材料，因此您需要针对每个平台微调您的代码。还有许多其他材料属性可以应用，尽管这些属性也依赖于平台，并不总是按预期工作。你会注意到，默认情况下，Android对象会有一个平坦的哑光材质外观并投射阴影。iOS对象将具有光滑的金属材质外观，不会产生阴影。你可以浏览文档和插件演示，看看不同的材料属性，然后在iOS和Android上测试它们，看看哪些是受支持的，哪些是根据每个平台的AR SDK和插件的源代码桥工作的。在某些情况下，您还可以使用本机代码来获得更好的结果。</p><h1 id="7fcc" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">与模型互动</h1><p id="2134" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">每个AR对象都支持两个事件处理器和一些函数调用，这可以在插件文档中看到。使用我们为我们的球体插入的两个事件处理程序，让我们在用户点击并长按球体时使用一些转换函数。将这些函数修改为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="46d7" class="mj ky in mf b gy mk ml l mm mn">                onLongPress: interaction =&gt; {<br/>                    console.log("Sphere was longpressed");<br/>                    interaction.node.remove()<br/>                },<br/>                onTap: interaction =&gt; {<br/>                    console.log("Sphere was tapped at coordinates " + interaction.touchPosition.x + " x " + interaction.touchPosition.y);<br/>                    const scale = 1<br/>                    interaction.node.scaleBy(scale)<br/>                    setTimeout(() =&gt; {<br/>                        interaction.node.scaleBy(-scale)<br/>                    },1000)<br/>                },</span></pre><p id="d806" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">现在，如果你长按一个球体，它将从场景中移除。轻敲一个球体会使其尺寸翻倍，然后在一秒钟后恢复到原始尺寸。同样，除了这两个之外，我们还可以应用许多其他的转换函数，如<code class="fe mp mq mr mf b">moveTo</code>、<code class="fe mp mq mr mf b">moveBy</code>、<code class="fe mp mq mr mf b">scaleBy</code>、<code class="fe mp mq mr mf b">rotateBy</code>和<code class="fe mp mq mr mf b">setVisible</code>。</p><h1 id="84b3" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">制作模型动画</h1><p id="71c8" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">如果你像现在这样测试应用程序，你会发现使用<code class="fe mp mq mr mf b">scaleBy</code>功能会导致比例突然变化，而不是逐渐变化。这可以通过两种方式来解决。对于iOS，我们可以用<code class="fe mp mq mr mf b">if (isIOS) SCNTransaction.animationDuration = .5;</code>设置一个AR场景标志，它将插入比例变化动画以平滑它。对于Android，我们将不得不依靠使用定时器来近似插值步骤。在太阳系演示中可以看到一个使用许多小步骤来制作物体变换动画的例子。</p><p id="c407" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">在这篇文章中，让我们添加以下代码来更改<code class="fe mp mq mr mf b">onTap</code>函数，使模型在被点击时以圆形模式平滑地旋转和移动:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="18e0" class="mj ky in mf b gy mk ml l mm mn">               onTap: interaction =&gt; {<br/>                    console.log("Sphere was tapped at coordinates " + interaction.touchPosition.x + " x " + interaction.touchPosition.y);<br/>                    if (!interaction.node.animTimer) { //start the timer<br/>                        let walkDegrees = 1;<br/>                        const radius = 1;<br/>                        const fps = 120;<br/>                        interaction.node.animTimer = setInterval(() =&gt; {<br/>                            walkDegrees += 1 / fps<br/>                            let newX, newY, newZ<br/>                            newX = interaction.node.position.x - Math.cos(walkDegrees) * radius<br/>                            newY = interaction.node.position.y<br/>                            newZ = interaction.node.position.z - Math.sin(walkDegrees) * radius<br/>                            interaction.node.moveTo({ x: newX, y: newY, z: newZ });<br/>                            interaction.node.rotateBy({<br/>                                x: 0,<br/>                                y: walkDegrees,<br/>                                z: 0<br/>                            });<br/>                        },1000 / fps);<br/>                    } else {<br/>                        clearInterval(interaction.node.animTimer)<br/>                        interaction.node.animTimer = null<br/>                    }<br/>                },</span></pre><p id="0351" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">如果您现在运行代码，点击平面以添加球体，然后点击球体，它将开始旋转并沿圆形路径移动。查看代码，我们检查是否有一个<code class="fe mp mq mr mf b">Timer</code> id已经附加到被点击的对象上，如果没有，那么我们启动一个新的计时器，它将在每次运行时稍微改变位置。我们每百分之几秒运行一次计时器，使用正弦和余弦关系来描述一个圆，并将其旋转一定角度，以实现整体平滑的动画外观。这样做没问题，但是你会注意到，在开始做圆周运动之前，它倾向于从起始位置跳到右边，因为正弦/余弦计算会将它突然移动到一个圆周位置。此外，如果您再次点击它来停止和开始动画，您会看到它倾向于跳跃的位置，因为我们没有保持状态中的最后一个度数值。让我们通过在一个<code class="fe mp mq mr mf b">then =&gt;</code>语句中创建当前位移变量<code class="fe mp mq mr mf b">walkDegree</code>后对其进行初始化，将它存储在对象中来改进这一点。我们还将使用一个常数<code class="fe mp mq mr mf b">rotateDegree</code>来保持恒定的转速，以防止它不断加速。最后，对于动画的前几百帧，我们将慢慢放大移动平移，以避免从圆形路径的中心跳到周边</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3e76" class="mj ky in mf b gy mk ml l mm mn">            arPlane.addSphere({<br/>                radius: sphereRadius,<br/>                position: {<br/>                    x: position.x,<br/>                    y: position.y + sphereRadius,<br/>                    z: position.z - 0.5 //show it further away from camera<br/>                },<br/>                rotation: isIOS ? { x: -20, y: 0, z: 0 } : { x: 0, y: 100, z: -20 },<br/>                materials: [{<br/>                    diffuse: { contents: "SevenStar.fw.png", wrapMode: "Clamp" },<br/>                }],<br/>                onLongPress: interaction =&gt; {<br/>                    console.log("Sphere was longpressed");<br/>                    interaction.node.remove()<br/>                },<br/>                onTap: interaction =&gt; {<br/>                    console.log("Sphere was tapped at coordinates " + interaction.touchPosition.x + " x " + interaction.touchPosition.y);<br/>                    const rotateDegree = 1;<br/>                    const radius = 1;<br/>                    const fps = 120;<br/>                    if (!interaction.node.animTimer) { //start the animation<br/>                        interaction.node.animTimer = setInterval(() =&gt; {<br/>                            interaction.node.walkDegrees += 1 / fps<br/>                            if (interaction.node.walkDegrees &lt;= 10) {<br/>                                interaction.node.newX = interaction.node.position.x - Math.cos(interaction.node.walkDegrees) * radius * interaction.node.walkDegrees / 10<br/>                                interaction.node.newY = interaction.node.position.y<br/>                                interaction.node.newZ = interaction.node.position.z - Math.sin(interaction.node.walkDegrees) * radius * interaction.node.walkDegrees / 10<br/>                            } else {<br/>                                interaction.node.newX = interaction.node.position.x - Math.cos(interaction.node.walkDegrees) * radius<br/>                                interaction.node.newY = interaction.node.position.y<br/>                                interaction.node.newZ = interaction.node.position.z - Math.sin(interaction.node.walkDegrees) * radius<br/>                            }<br/>                            interaction.node.moveTo({ x: interaction.node.newX, y: interaction.node.newY, z: interaction.node.newZ });<br/>                            interaction.node.rotateBy({<br/>                                x: 0,<br/>                                y: rotateDegree,<br/>                                z: 0<br/>                            });<br/>                        }, 1000 / fps);<br/>                    } else { //stop the animation<br/>                        clearInterval(interaction.node.animTimer)<br/>                        interaction.node.animTimer = null                        <br/>                    }<br/>                },<br/>                draggingEnabled: false, //Android only<br/>                rotatingEnabled: false, //Android only<br/>                scalingEnabled: false, //Android only<br/>                segmentCount: 100,<br/>                mass: 0, //iOS only<br/>            }).then(arNode =&gt; {<br/>                console.log("Sphere successfully added");<br/>                arNode.walkDegrees = 0;<br/>            })</span></pre><h1 id="73d4" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">添加用户界面</h1><p id="3c68" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">我们当前的AR视图是全屏显示的，但我们也可以在它上面覆盖一些UI元素，以允许用户以其他方式与场景交互或呈现信息，而不占用设备上的布局空间。对于这篇文章，我们将在顶部添加一些文本，让用户知道他们应该点击平面来添加球体。我们还将添加一个按钮来删除场景中的所有对象，以便它们可以从一个空的AR场景重新开始。为此，我们将首先使用AR标记对GridLayout声明进行排序，然后使用任何其他UI标记，这样NativeScript将显示这些标记(比AR视图更高的z索引)。</p><p id="8ade" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">在文件XML部分的AR标记后添加以下内容:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8d1c" class="mj ky in mf b gy mk ml l mm mn">            &lt;GridLayout rows="auto" columns="*, auto" verticalAlignment="top"&gt;<br/>                &lt;Label row="0" col="0" text="Tap on a plane to start!" class="ar-text" textWrap="true" /&gt;<br/>                &lt;Label row="0" col="1" text="Clear" class="ar-button" @tap="clearModels()" /&gt;<br/>            &lt;/GridLayout&gt;</span></pre><p id="3b5c" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">新的<code class="fe mp mq mr mf b">Label</code>按钮将调用一个新的函数<code class="fe mp mq mr mf b">clearModels</code>从场景中移除所有当前的模型。为此，我们需要通过向页面的数据声明添加一个新的数组变量，开始存储添加到场景中的每个模型的引用，如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="45b5" class="mj ky in mf b gy mk ml l mm mn">    data() {<br/>        return {<br/>            planeMaterial: new Color("white"),<br/>            objects: [],<br/>        }<br/>    },</span></pre><p id="e75c" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">在添加新球体后的代码的<code class="fe mp mq mr mf b">then</code>部分，我们将使用<code class="fe mp mq mr mf b">this.objects.push(arNode)</code>将新的对象引用推送到这个数组。在移除模型<code class="fe mp mq mr mf b">this.objects.splice(this.objects.indexOf(interaction.node), 1)</code>之前，我们将修改长按处理程序，以便每当用户从场景中移除单个球体时，从该数组中移除对象引用。最后，我们将为按钮调用的<code class="fe mp mq mr mf b">clearModels</code>添加函数定义:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="17f3" class="mj ky in mf b gy mk ml l mm mn">        clearModels() {<br/>            this.objects.forEach(model =&gt; {<br/>                model.remove()<br/>            })<br/>        },</span></pre><p id="5971" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated">在iOS设备上运行带有这些更改的应用程序，您现在会看到如下内容:</p><figure class="ma mb mc md gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/88345f4d0ccd54ee79b812ead85c641f.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/0*xoYBDbK_4Kn4HuHE.PNG"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">UI overlay</figcaption></figure><h1 id="91a3" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">搞定了。</h1><p id="597f" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">这个帖子到此为止。如果你想下载最终的源文件，你可以在<a class="ae kw" href="https://github.com/drangelod/ns6arstart" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到它们。</p></div><div class="ab cl jr js hr jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="ig ih ii ij ik"><p id="110c" class="pw-post-body-paragraph jy jz in ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ig bi translated"><em class="nt">原载于2020年5月15日https://blog.angelengineering.com</em><em class="nt">的</em> <a class="ae kw" href="https://blog.angelengineering.com/augmented-reality-intro/" rel="noopener ugc nofollow" target="_blank"> <em class="nt">。</em></a></p><h1 id="2281" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="5690" class="pw-post-body-paragraph jy jz in ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ig bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击<a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka io">点击</strong> </a>查看我们，并确保订阅该频道😎</p></div></div>    
</body>
</html>