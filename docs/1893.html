<html>
<head>
<title>A Nice Way to Iterate Over Collections in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中迭代集合的好方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-nice-way-to-iterate-over-collections-in-javascript-254b6f5d9907?source=collection_archive---------7-----------------------#2020-05-02">https://javascript.plainenglish.io/a-nice-way-to-iterate-over-collections-in-javascript-254b6f5d9907?source=collection_archive---------7-----------------------#2020-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="be89" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用一致的方法减少认知负荷</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d9e6edb100b097ed3596f1045d8563da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z4kJsW8XjEJtsftM"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3920" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="9ca4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有许多方法可以循环集合、<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">对象</a>和<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/array" rel="noopener ugc nofollow" target="_blank">数组</a>。其中许多非常适合特定的用例。我们将讨论一种迭代集合项的“好”方法，这将涵盖大多数用例。</p><h1 id="9d07" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么叫“好看”？</h1><p id="93ce" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我谈论循环集合的方法之前，让我定义一下“好”</p><p id="f721" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">迭代集合的一种“好”方法应该是一致的:</p><ul class=""><li id="fad2" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">支持对象和数组</li><li id="b8e8" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">不会遍历原型链中的所有属性</li><li id="ca68" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">允许使用<code class="fe nd ne nf ng b">async/await</code></li><li id="3beb" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">允许使用关键字<code class="fe nd ne nf ng b">break</code>，或者另一种提前结束循环的方法</li><li id="8983" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">允许使用<code class="fe nd ne nf ng b">continue</code>关键字，或者用另一种方法来退出单个项目的逻辑，并转移到下一个项目</li><li id="f5c9" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">可以访问<code class="fe nd ne nf ng b">index</code>进行<code class="fe nd ne nf ng b">array</code>收藏</li><li id="7302" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">自动管理集合上的迭代</li><li id="abfb" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">适合中等规模数据集的性能</li></ul><p id="bec1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">总而言之,“好”的方式将允许开发人员使用它作为迭代集合的默认方式，而不用考虑太多。</p><h1 id="78f6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">For…Of循环</h1><p id="16ef" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在下面的例子中，我们迭代包含各种搜索引擎的URL的集合。在每一次迭代中，我们调用传递给它的搜索引擎URL并返回结果的函数。如果找到结果，我们<code class="fe nd ne nf ng b">break</code>退出循环。如果给定的URL是<code class="fe nd ne nf ng b">null</code>或者没有定义，我们就<code class="fe nd ne nf ng b">continue</code>到集合中的下一个项目。</p><h2 id="9d33" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated"><strong class="ak">数组</strong></h2><p id="87e6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这里，我们使用以下一般结构迭代数组:</p><pre class="kg kh ki kj gt nt ng nu nv aw nw bi"><span id="424d" class="nh kx iq ng b gy nx ny l nz oa">for(const item of array) {<br/>  // logic<br/>}</span></pre><p id="afb2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">示例:</p><pre class="kg kh ki kj gt nt ng nu nv aw nw bi"><span id="cbe7" class="nh kx iq ng b gy nx ny l nz oa">const array = [<br/>  'www.google.com',<br/>  'www.yahoo.com',<br/>  null,<br/>  'www.bing.com'<br/>];</span><span id="f980" class="nh kx iq ng b gy ob ny l nz oa">for(const searchEngineUrl of array) {<br/>  if(!searchEngineUrl) {<br/>    continue;<br/>  }<br/>  const results = await getSearchEngineResults(searchEngineUrl);<br/>  if(results) {<br/>    break;<br/>  }<br/>}</span></pre><h2 id="89df" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated"><strong class="ak">对象</strong></h2><p id="663f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这里，我们使用以下通用结构迭代对象:</p><pre class="kg kh ki kj gt nt ng nu nv aw nw bi"><span id="2431" class="nh kx iq ng b gy nx ny l nz oa">for(const [key, value] of Object.entries(obj)) {<br/>  // logic<br/>}</span></pre><p id="fa60" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们在目标对象上使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" rel="noopener ugc nofollow" target="_blank"> Object.entries() </a>来使对象可枚举，从而可供for…of循环使用。我们<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">解构</a>每一项以暴露变量“键”和“值”。</p><p id="f529" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">示例:</p><pre class="kg kh ki kj gt nt ng nu nv aw nw bi"><span id="88f5" class="nh kx iq ng b gy nx ny l nz oa">const obj = {<br/>  google: 'www.google.com',<br/>  yahoo: 'www.yahoo.com',<br/>  doesNotExist: null,<br/>  bing: 'www.bing.com',<br/>};</span><span id="3513" class="nh kx iq ng b gy ob ny l nz oa">for(const [key, searchEngineUrl] of Object.entries(obj)) {<br/>  if(!value) { <br/>    console.log(`Skipping ${key}`);<br/>    continue;<br/>  }<br/>  const results = await getSearchEngineResults(searchEngineUrl);<br/>  if(results) {<br/>    break;<br/>  }<br/>}</span></pre><h2 id="2761" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated"><strong class="ak">阵列带</strong>T10】</h2><p id="c6e4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了在迭代数组时获得<code class="fe nd ne nf ng b">index</code>,我们使用以下通用结构:</p><pre class="kg kh ki kj gt nt ng nu nv aw nw bi"><span id="de58" class="nh kx iq ng b gy nx ny l nz oa">for(const [ index, value ] of array.entries()) {<br/>  // logic<br/>}</span></pre><p id="4889" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries" rel="noopener ugc nofollow" target="_blank">。entries() </a>方法在数组上公开了<code class="fe nd ne nf ng b">index</code>。我们<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">解构</a>每一项，以暴露变量“索引”和“值”。</p><p id="82dc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">示例:</p><pre class="kg kh ki kj gt nt ng nu nv aw nw bi"><span id="4871" class="nh kx iq ng b gy nx ny l nz oa">const array = [ 'www.google.com', 'www.yahoo.com', 'www.bing.com' ];</span><span id="a4fd" class="nh kx iq ng b gy ob ny l nz oa">for(const [ index, searchEngineUrl ] of array.entries()) {<br/>  if(!value) { <br/>    console.log(`Skipping index ${index}`);<br/>    continue;<br/>  }<br/>  const results = await getSearchEngineResults(searchEngineUrl);<br/>  if(results) {<br/>    break;<br/>  }<br/>}</span></pre><h2 id="f4be" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">为什么不是为了…在循环中？</h2><p id="ce75" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">循环中的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" rel="noopener ugc nofollow" target="_blank">很棒，除了以下限制:</a></p><ul class=""><li id="a87e" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">它遍历原型链中的所有属性</li></ul><p id="855c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果要迭代对象原型链中的所有属性，请使用for…in循环。</p><h2 id="052c" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">为什么不呢？forEach()循环？</h2><p id="d6a7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">数组。forEach()循环</a>很棒，但是它有以下限制:</p><ul class=""><li id="efc6" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">不能在对象上循环</li><li id="7ba0" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">无法有效使用<code class="fe nd ne nf ng b">async/await</code></li><li id="42e5" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">不能<code class="fe nd ne nf ng b">break</code>过早退出循环</li></ul><p id="c2c5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用。forEach()用于同步逻辑，在那里你不希望<code class="fe nd ne nf ng b">break</code>提前退出。</p><h2 id="820c" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">为什么不是经典的For循环？</h2><p id="c64d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for" rel="noopener ugc nofollow" target="_blank">经典for循环</a>非常棒，除了它们有以下限制:</p><ul class=""><li id="2958" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">不会自动管理集合上的迭代</li></ul><p id="cec4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于传统的for循环，开发人员必须定义一个<code class="fe nd ne nf ng b">index</code>，递增<code class="fe nd ne nf ng b">index</code>，并定义退出循环的条件。此外，在每次迭代中，要获得集合的值，必须手动使用<code class="fe nd ne nf ng b">index</code>来查找值。</p><p id="898a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当需要对<code class="fe nd ne nf ng b">index</code>增量(或减量)进行粒度控制时，使用传统的for循环。此外，当大型数据集的性能很重要时，使用经典的for循环，或<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while" rel="noopener ugc nofollow" target="_blank"> while循环</a>。</p><h2 id="ef67" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">摘要</h2><p id="8149" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有许多方法可以迭代集合。大多数都有特定的用例。for…of循环是遍历集合的“好”方法，因为它缺乏限制和灵活性。这是JavaScript中的一个好去处。</p><p id="b394" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">帕特里克</p><h2 id="9d4f" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="65de" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="lq ir">AI in Plain English</strong></a><a class="ae kv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="lq ir">UX in Plain English</strong></a><a class="ae kv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="lq ir">Python in Plain English</strong></a><strong class="lq ir"/>——谢谢，继续学习！</p><p id="4080" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">submissions @ plain English . io</strong></a><strong class="lq ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>