<html>
<head>
<title>Creating Memory-Optimized Instances with Constructor Functions and Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用构造函数和原型创建内存优化的实例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-memory-optimized-instances-with-constructor-functions-and-prototypes-5249310c96a6?source=collection_archive---------4-----------------------#2020-08-18">https://javascript.plainenglish.io/creating-memory-optimized-instances-with-constructor-functions-and-prototypes-5249310c96a6?source=collection_archive---------4-----------------------#2020-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e99398e6ae6f9f801681dec4b88ad410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_o9-xBSG1jy3su0IY4U0g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Memory-optimized Javascript Object Instances</figcaption></figure><p id="9642" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您使用JavaScript已经有一段时间了，您可能会遇到“构造函数”这个术语，这是一种调用函数的奇特方式，该函数将被用作创建对象实例的蓝图。</p><p id="2571" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Java这样的经典面向对象语言中，这些蓝图将是类。(尽管我们在JavaScript中有了<em class="la"> class </em>关键字，但它与经典的面向对象关键字并不完全相同。但是让我们稍后在另一篇文章中讨论这个问题)。</p><p id="7ff5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，让我们将注意力转移到使用这些构造函数创建内存优化实例的方法上。</p><h2 id="6f07" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">场景:</h2><p id="aa7a" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">为了解释优化的结果并实现可量化的指标，让我们假设以下情况:</p><p id="af20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的web应用程序中，我们必须创建200个car对象实例，它们具有以下属性:</p><ol class=""><li id="b47d" class="lz ma iq ke b kf kg kj kk kn mb kr mc kv md kz me mf mg mh bi translated">品牌</li><li id="7847" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated">最高速度</li><li id="3d2c" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated">流速</li></ol><p id="1c30" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">汽车也应该有两种方法，即:</p><ol class=""><li id="f40b" class="lz ma iq ke b kf kg kj kk kn mb kr mc kv md kz me mf mg mh bi translated">加速</li><li id="d386" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated">刹车</li></ol><h2 id="25c6" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">旁注:</h2><p id="5109" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">为了从chrome开发者工具的“堆快照”中快速收集信息，我们将把汽车实例分配给窗口对象。</p><p id="7045" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，我们选择数字200，因为随着实例数量的增加，优化的效果将在指标上明显可见。</p><h2 id="b5af" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">重型汽车:</h2><p id="e5c0" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">现在，让我们开始写一些代码，让我们将构造函数命名为<em class="la"> HeavyCar </em>，以区别于我们将在本文后面看到的优化版本。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ce22" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行完上面的代码后，让我们拍一个堆快照，看看<em class="la"> HeavyCars </em>消耗了多少内存。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/7351323bca1a60cd2defab538bdf682f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PG5tE9v07FHRRKWA3jEBzw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Heap Snapshot of HeavyCar</figcaption></figure><p id="37ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">查看该报告，我们可以推断出<em class="la"> HeavyCar </em>的每个实例都有一个<strong class="ke ir"> 32字节</strong>的浅层大小，总共200个实例累积到<strong class="ke ir"> 6400字节(6.4千字节)</strong>。</p><h2 id="f6e1" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">深入了解这些实例:</h2><p id="6525" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">如果我们一起看这些实例，我们会意识到，虽然这些实例的属性(如<em class="la"> brand </em>、<em class="la"> topSpeed </em>和<em class="la"> CurrentSpeed </em>)可能包含每个实例的唯一值，但方法(如<em class="la"> accelerate </em>和<em class="la"> brake </em>将总是具有相同的逻辑，而与实例无关。</p><p id="ae3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是这些方法在每个实例中都被复制，增加了每个实例的内存占用，从而增加了累积的内存占用。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f80e0f599dd371be6593138f879dba18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*4JUC_65h-fosLLAs5JG8qw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Methods on every instance</figcaption></figure><h2 id="5e30" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">关于优化的思考:</h2><p id="38f3" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">根据我们的观察，我们可以表示，如果有一种方法可以使这些方法集中化，我们可以节省一些内存，这将大大减少累积的内存占用。</p><p id="a221" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所谓集中化，是指我们将这些方法放在内存中的单一位置，并从实例中引用内存中的该点。</p><p id="e0b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为Javascript是基于原型继承的，所以上面的建议几乎不费吹灰之力就能实现。我们所要做的就是，将那些方法添加到构造函数的<strong class="ke ir"> <em class="la">原型</em> </strong>中，并让实例从它们的<strong class="ke ir"> <em class="la"> __proto__ </em> </strong>对象中引用它。</p><h2 id="733c" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">轻型汽车:</h2><p id="ddd0" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">让我们称我们优化的构造函数为<em class="la"> LightCar。下面是实现我们上面讨论的代码:</em></p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0416" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在使用上述实现获取堆快照时，我们得到以下结果:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8808256b8317d603e1d3c7851751ce04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4o8Shhb_OZ7QIu4t5_whkQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Heap snapshot of LightCar</figcaption></figure><p id="5e54" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我们所看到的，我们已经将每个实例的浅层大小从<strong class="ke ir"> 32字节减少到了</strong>24字节，这有助于显著减少累积内存占用。我们已经设法将200个实例的浅层大小从<strong class="ke ir"> <em class="la"> 6.4 Kb降低到4.8 Kb。</em>T15】</strong></p><p id="bcdd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着实例数量呈指数级增长，我们通过优化节省的内存量也将呈指数级增长。</p><h2 id="58a2" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">看一看优化的实例:</h2><p id="6471" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">现在我们已经通过原型链接优化了方法，让我们看看我们的实例:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8da92e9ea561e8e82c501c42f581eb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*ShkO_oP_Q3dt4wf-0T0-bQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">References to the methods on the Prototype chain</figcaption></figure><p id="87ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以看到，现在每个实例中的方法都在<strong class="ke ir"> <em class="la"> __proto__ </em> </strong>下，需要注意的是<strong class="ke ir"> <em class="la"> __proto__ </em> </strong>中的一个并不是方法本身的实际副本，而是对它们的内存位置的引用。</p><p id="8ba8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我们能够减少实例内存占用的实际原因。</p><h2 id="8d08" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">结论:</h2><p id="275a" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">这类优化通常更容易被忽略，但最终会导致严重的性能问题。尤其是如果一个人正在开发一个数据密集型应用程序，这是目前最突出的一种网络应用程序，他们更有可能在应用程序的生命周期中更快地面临性能障碍。</p><p id="1e6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为一条经验法则，总是考虑将您的方法添加到构造函数的原型中，以避免以后在生产中处理严重瓶颈的麻烦。</p><p id="4b24" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读我的想法，干杯:)</p></div></div>    
</body>
</html>