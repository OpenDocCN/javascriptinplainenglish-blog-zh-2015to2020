<html>
<head>
<title>Microfrontends — when they aren’t the answer (React, Angular, Vue etc)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端—当它们不是答案时(反应、角度、Vue等)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/microfrontends-when-they-arent-the-answer-react-angular-vue-etc-45dcf266f6f9?source=collection_archive---------1-----------------------#2019-08-19">https://javascript.plainenglish.io/microfrontends-when-they-arent-the-answer-react-angular-vue-etc-45dcf266f6f9?source=collection_archive---------1-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7659" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看看使用微前端的潜在缺点，以及何时采用微前端没有意义。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d1e89b8c1750d3eb2f5abf2f4bb3b70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jvgu6f3c9K5YegOdktTjxg.jpeg"/></div></div></figure><p id="ae6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">前端开发已经变得很复杂……在现代web应用开发(React/Angular/Vue等)的世界中，对HTML、CSS和JavaScript的简单认识已经不足以让你过关。</p><p id="9cf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">微前端</strong>的概念引入了<em class="ln">一种将巨大的单块UI分割成更小、更易管理的块的方式</em>。</p><p id="b4cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">想想前端的微服务。</strong></p><p id="1380" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这并不是什么灵丹妙药——在这篇以砖块为主题的文章中，我将看看<strong class="kt ir">什么时候不应该</strong>为您的项目考虑微前端。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="1e26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经发表了很多关于微前端作为一种架构设计模式的文章，并讨论了相对于单一UI的许多优势。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/javascript-in-plain-english/microfrontends-bringing-javascript-frameworks-together-react-angular-vue-etc-5d401cb0072b" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">微前端——整合JavaScript框架(React、Angular、Vue等)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">反应，角，Vue，余烬，骨干，模板，预作用…事实上，现在可能又有一部正在上映！</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm kp ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://medium.com/javascript-in-plain-english/create-micro-frontends-using-web-components-with-support-for-angular-and-react-2d6db18f557a" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">使用Web组件创建微前端(支持Angular和React)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">如果你是React或Angular，Ember或Vue，让我们创建一个地方，让他们都可以生活在一起，在完美的和谐使用…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm kp ly"/></div></div></a></div><p id="6bb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我收到了很多关于微前端作为设计模式的有趣反馈。反馈在很大程度上是积极的，因为许多与微前端试图解决的问题有关。</p><p id="9728" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，正如一些人正确指出的，有些情况下采用这样的架构设计模式是没有意义的——让我们看看本文中的一些例子。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="e821" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">微前端不会增加构建复杂度吗？</h1><p id="71c7" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">复杂性并不是UI开发中的新问题。</p><p id="893f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以NPM ( <em class="ln"> JavaScript包管理器</em>)为例……一个典型的Python项目会有一些依赖项，Angular (UI框架)开箱即用就有1300多个！</p><p id="9940" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了构建一个UI项目，你只需<strong class="kt ir">必须</strong>有大量的工具供你使用，来获取、渲染、测试、更新、构建、优化以及其他一切。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/e19e4ae83e5f43984ed38bbc5e53a911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUx-9TNPXTqeqzQIJLjeJw.jpeg"/></div></div></figure><p id="9e5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">微前端的引入将复杂性提升到了一个全新的水平，现在您必须管理每个微前端的多个实例，<em class="ln">对吗</em>？</strong></p><p id="b6b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，这是真的，但有办法减轻这种复杂性。</p><p id="1ecd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我看来，如果没有强大的CI(持续集成)/ CD(持续交付)流程，你根本无法在微前端上执行。</p><p id="9240" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你的应用程序扩展成几十甚至几百个小前端(<em class="ln">每个都有自己的构建过程</em>)时，你将需要标准化一些围绕它们的工具，否则你将陷入痛苦的世界！</p><p id="c639" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">坚持一个或几个UI框架(例如Angular / React)可能是一个好的开始，所以所有的构建过程都使用相似的步骤。</p><p id="e2d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Docker / Kubernetes等集装箱化工具也在简化这种复杂性方面做了大量工作。</p><p id="8603" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我会暂停一下这个想法，并承诺接下来会写一篇关于微前端的可靠CI/CD流程的文章。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="3fcf" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">我做一个不太可能成长的小应用，采用微前端有意义吗？</h1><p id="9e3d" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">简而言之，这里的答案是明确的<em class="ln">不</em>。</p><p id="0727" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我经常发现成功采用架构设计模式的团队(<em class="ln">像Microfrontends </em>)通过强烈地认同它声称要解决的问题而自然地被它所吸引。</p><p id="0738" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看微前端的品质(<em class="ln">类似于微服务</em>):</p><ul class=""><li id="1dd2" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">高度可维护和可测试</li><li id="d00f" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">松散耦合</li><li id="9482" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">可独立部署</li><li id="e983" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">围绕业务能力组织</li></ul><p id="8842" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了成功地采用微前端，您的应用程序应该通过大部分(如果不是全部)改进。</p><p id="9eaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">例如</em>，如果你独自开发一个没有其他依赖关系的应用程序，那么你就不需要担心松散耦合或独立部署，这样你就不需要战斗了，省下你的精力和热情去做别的事情吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/a2a5d74a9ca3a4c363250fa572266efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIULp38HVzKunYDLmgY3Wg.jpeg"/></div></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="b168" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">组件/库是否会在微前端之间重复，从而增加文件大小并对性能产生负面影响？</h1><p id="808a" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">在您的应用程序可能由单个框架或多个框架的几个实例组成的场景中，在您的整个应用程序中可能会有重复的组件和库，特别是在封装或松散耦合是一个因素的情况下。</p><p id="6b6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以Angular为例，它已经与RxJS库捆绑在一起。如果您有5个基于Angular的微前端，那么您可以为您的用户提供5个RxJS实例。</p><p id="d8fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如何避免这种情况将在很大程度上取决于您的应用程序是如何构建的。在这个例子中，可以延迟加载一些库，并在每个微前端之间共享它们。</p><p id="546a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在其他情况下，你可能只是不得不接受这种情况，并在做出任何决定时考虑到这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/ff3c35a25d5b16e4dcbad3082783afc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9b_sm1XnqhUH14RC3sJOJA.jpeg"/></div></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="23da" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">如果我们所有的微前端都是独立的项目，我们如何能够加强设计外观和感觉的一致性？</h1><p id="4252" class="pw-post-body-paragraph kr ks iq kt b ku ng jr kw kx nh ju kz la ni lc ld le nj lg lh li nk lk ll lm ij bi translated">这是使用微前端最大的顾虑之一。如果用户由于不一致的用户界面设计和/或用户体验(UX)而注意到有多个项目，该怎么办？</p><p id="5f77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谢天谢地，有一些库可以帮助提高一致性。<a class="ae oa" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material UI </a>和<a class="ae oa" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>是两个比较流行的例子。</p><p id="199f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些都为按钮、表格、标题等的外观和行为提供了一致的设计。</p><p id="1626" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从这些中的一个开始作为基线，并在此基础上为您的公司或应用程序构建，这可能是有意义的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/1bb87b420a0fd3e49d9f0065feddd6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6PFb2YiObFhCKzmEhqLxg.jpeg"/></div></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="f57a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像我们在设计和构建软件时所做的每一个决定一样，在您的应用程序环境中会有优势和权衡。对一个人有意义的东西，不一定对另一个人有意义。</p><p id="b13e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们掌握了事实，这些决定就会更有教育意义，在实施时更有可能成功。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><blockquote class="ob oc od"><p id="dc92" class="kr ks ln kt b ku kv jr kw kx ky ju kz oe lb lc ld of lf lg lh og lj lk ll lm ij bi translated">感谢您花时间阅读我的文章。</p></blockquote></div></div>    
</body>
</html>