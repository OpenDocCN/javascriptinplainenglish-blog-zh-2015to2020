<html>
<head>
<title>JavaScript Mistakes — Wrappers and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误——包装器和对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-mistakes-wrappers-and-objects-98d70dd6bb7f?source=collection_archive---------11-----------------------#2020-05-02">https://javascript.plainenglish.io/javascript-mistakes-wrappers-and-objects-98d70dd6bb7f?source=collection_archive---------11-----------------------#2020-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/59f54b7954cda6d6dc240b043d7d9310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nejs1s5FDdRZn8lx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@orrbarone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Orr</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4a98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="8b5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看到我们不应该使用的坏结构，比如手动为原始值、八进制文本创建包装对象，以及将参数赋给不同的值。</p><h1 id="b4f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有原始包装实例</h1><p id="3e19" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于字符串、数字和布尔值，我们不应该用<code class="fe me mf mg mh b">new</code>操作符手动创建包装对象。</p><p id="bd64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要它们来调用原始值的方法，JavaScript解释器会自动创建包装器，然后调用这些方法。一旦调用完我们想要调用的方法，它们就会被自动销毁。</p><p id="95ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，没有理由手动创建它们。它们令人困惑，因为它们有类型<code class="fe me mf mg mh b">'object'</code>。</p><p id="118d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下表达式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="78ec" class="mq lc iq mh b gy mr ms l mt mu">typeof new String("foo");<br/>typeof new Number(3);<br/>typeof new Boolean(false);</span></pre><p id="dad6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它们都将返回类型<code class="fe me mf mg mh b">'object'</code>，即使我们像处理它们的原始对应物一样处理它们。</p><p id="5c9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将它们转换回原始值，我们必须对它们调用<code class="fe me mf mg mh b">valueOf</code>方法，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e12d" class="mq lc iq mh b gy mr ms l mt mu">new String("foo").valueOf();<br/>new Number(3).valueOf();<br/>new Boolean(false).valueOf();</span></pre><p id="74bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来取回这些包装对象的原始版本。</p><p id="7287" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该将它们写成原始值，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="689a" class="mq lc iq mh b gy mr ms l mt mu">"foo"<br/>3<br/>false</span></pre><p id="262c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打字更少，也不会混淆类型。</p><h1 id="fa2f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有八进制文字</h1><p id="07bf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">八进制数字是任何以0开头的数字。JavaScript将任何以0开头的数字都视为八进制数。</p><p id="3acd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe me mf mg mh b">051</code>实际上是十进制的41。</p><p id="08af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个混乱的来源，所以ES5中不赞成使用八进制数字。</p><p id="8714" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们想在代码中写51，那么它前面就不应该有0。</p><h1 id="9ca8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有重新分配函数参数</h1><p id="cf89" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在JavaScript中将函数参数重新赋值给不同的值，因为这会改变<code class="fe me mf mg mh b">arguments</code>对象。这意味着实际参数被修改。</p><p id="c37f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将函数参数重新赋值给一个新值很容易出错。这使得错误难以追踪。</p><p id="de58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该编写这样的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c9bf" class="mq lc iq mh b gy mr ms l mt mu">const foo = (x) =&gt; {<br/>  x = 13;<br/>}</span><span id="7b82" class="mq lc iq mh b gy mv ms l mt mu">const foo = (x) =&gt; {<br/>  for (x of baz) {}<br/>}</span></pre><p id="a366" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该将参数赋给函数体内的一个变量，然后像下面的代码一样操作它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8835" class="mq lc iq mh b gy mr ms l mt mu">const foo = (x) =&gt; {<br/>  let y = x;<br/>}</span><span id="94eb" class="mq lc iq mh b gy mv ms l mt mu">const foo = (x) =&gt; {<br/>  for (const b of baz) {}<br/>}</span></pre><h1 id="cc4b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用<code class="fe me mf mg mh b">__proto__ Property to Access the Prototype of the Given Object</code></h1><p id="2e80" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe me mf mg mh b">__proto__</code>属性来访问我们试图访问该属性的对象的原型。</p><p id="2309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以使用<code class="fe me mf mg mh b">Object.getPrototypeOf</code>方法来访问当前对象的原型。</p><p id="6f2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="44c2" class="mq lc iq mh b gy mr ms l mt mu">const obj = {};<br/>console.log(obj.__proto__)</span></pre><p id="b2de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c62" class="mq lc iq mh b gy mr ms l mt mu">const obj = {};<br/>console.log(Object.getPrototypeOf(obj))</span></pre><h1 id="6f7b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无变量重新声明</h1><p id="dfc2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">重新声明变量是不好的。然而，如果我们使用<code class="fe me mf mg mh b">var</code>关键字来声明我们的变量，这是可能的。我们不希望这种情况发生，因为我们不知道变量实际上有哪些值。</p><p id="beb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f0b1" class="mq lc iq mh b gy mr ms l mt mu">var a = 3;<br/>var a = 2;</span></pre><p id="3cb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在最后一行下面记录<code class="fe me mf mg mh b">a</code>时，我们得到<code class="fe me mf mg mh b">a</code>是2。</p><p id="a978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该用<code class="fe me mf mg mh b">let</code>声明一个变量，如果我们试图用两个不同的名字声明两个变量，我们会得到一个错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8664caaf20d81d507e69e36aea592d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PTgFPRUnAZ8DTPae"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ffkae?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kae Ng</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9888" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">return语句中没有赋值</h1><p id="e8bb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，我们可以在与<code class="fe me mf mg mh b">return</code>语句相同的行中进行赋值操作。</p><p id="d2da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6d29" class="mq lc iq mh b gy mr ms l mt mu">const baz = (bar) =&gt; {<br/>  return foo = bar + 2;<br/>}</span></pre><p id="535d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有了<code class="fe me mf mg mh b">bar</code>参数，我们给它加了2。然后我们把总和赋给<code class="fe me mf mg mh b">foo</code>，然后返回。</p><p id="58fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此<code class="fe me mf mg mh b">foo</code>是5，我们返回了它。然而，这也可能是一个打字错误，因为开发人员可能想写<code class="fe me mf mg mh b">==</code>或<code class="fe me mf mg mh b">===</code>而不是<code class="fe me mf mg mh b">=</code>。</p><p id="73f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使事情更清楚，我们应该将赋值表达式放在与<code class="fe me mf mg mh b">return</code>语句不同的行上。</p><p id="f311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以在赋值表达式两边加上圆括号，让每个人都清楚我们先把值赋给左操作数，然后把左操作数作为值返回。</p><p id="8734" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2fdc" class="mq lc iq mh b gy mr ms l mt mu">const baz = (bar) =&gt; {<br/>  return foo == bar + 2;<br/>}</span><span id="35c3" class="mq lc iq mh b gy mv ms l mt mu">const baz = (bar) =&gt; {<br/>  return foo === bar + 2;<br/>}</span><span id="c5bb" class="mq lc iq mh b gy mv ms l mt mu">const baz = (bar) =&gt; {<br/>  return (foo = bar + 2);<br/>}</span></pre><p id="f033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是我们上面的。</p><h1 id="71dc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="aa8f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该对原始值使用包装对象，因为手动创建它们没有价值。只会给其他开发者带来困惑，需要更多的打字。</p><p id="8594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该在JavaScript代码中使用八进制文字，因为它们已经过时了。</p><p id="1c52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该多次声明同名的变量。</p><p id="e181" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，赋值表达式不应该出现在<code class="fe me mf mg mh b">return</code>语句中，以减少不确定性。</p><h2 id="cd47" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="1925" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的喜爱:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="f764" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>