<html>
<head>
<title>TypeScript Best Practices — Member Access, Loops, and Function Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript最佳实践—成员访问、循环和函数类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-best-practices-member-access-loops-and-function-types-36dce7173b76?source=collection_archive---------5-----------------------#2020-06-11">https://javascript.plainenglish.io/typescript-best-practices-member-access-loops-and-function-types-36dce7173b76?source=collection_archive---------5-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/741e9be150254e02768fc05a6d87fb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HFOFIf2yA9p-Ru7D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@whitney_wright?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Whitney Wright</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript是一个简单易学的JavaScript扩展。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的类型脚本代码。</p><p id="810d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究使用TypeScript编写代码时应遵循的最佳实践，包括禁止成员访问任何类型化变量。</p><p id="6d12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们看看为什么我们要使用<code class="fe lb lc ld le b">const</code>断言。</p><p id="0342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也看看为什么在导入模块时应该使用<code class="fe lb lc ld le b">import</code>而不是<code class="fe lb lc ld le b">require</code>。</p><p id="9069" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们发现如何使用接口来指定函数的类型。</p><p id="6e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来看看为什么for-of循环比普通的for循环更好。</p><h1 id="66ae" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">任何类型化变量都没有成员访问权限</h1><p id="8254" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">any</code>可能会泄漏到我们嵌套实体的代码库中。</p><p id="bff6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可能有具有<code class="fe lb lc ld le b">any</code>类型的类型声明。</p><p id="4b65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们允许访问那些嵌套成员，我们可能会在运行时遇到类型错误。</p><p id="37fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b0bc" class="mq lg iq le b gy mr ms l mt mu">declare const anyObj: { prop: any };<br/>anyObj.prop.a.b;</span></pre><p id="c5ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d4da" class="mq lg iq le b gy mr ms l mt mu">declare const anyObj: { prop: string };<br/>anyObj.prop;</span></pre><p id="bbac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道<code class="fe lb lc ld le b">anyObj.prop</code>一定是一个字符串，我们可以安全地访问它。</p><h1 id="28ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不要从函数中返回任何值</h1><p id="defe" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该在函数中返回任何带有<code class="fe lb lc ld le b">any</code>类型的东西。</p><p id="d2e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该添加一个返回类型注释，这样我们就知道它返回的是什么。</p><p id="9796" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="560b" class="mq lg iq le b gy mr ms l mt mu">function foo() {<br/>  return 1 as any;<br/>}</span></pre><p id="95ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0d25" class="mq lg iq le b gy mr ms l mt mu">function arr() {<br/>  return [] as any[];<br/>}</span></pre><p id="5590" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3a3d" class="mq lg iq le b gy mr ms l mt mu">function arr(): number[] {<br/>  return [1, 2];<br/>}</span></pre><p id="e3d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8b2c" class="mq lg iq le b gy mr ms l mt mu">function foo(): number {<br/>  return 1;<br/>}</span></pre><p id="8098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道函数返回什么了。</p><h1 id="497f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有未使用的变量和参数</h1><p id="39d3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">未使用的变量和参数是无用的，所以我们可能不应该在代码中使用它们。</p><p id="fa7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以删除不使用的变量声明，如<code class="fe lb lc ld le b">var</code>、<code class="fe lb lc ld le b">const</code>或<code class="fe lb lc ld le b">let</code>变量。</p><p id="3ad4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，不用的函数和类也可以删除。</p><p id="3e98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不使用的枚举、接口和类型声明也可以删除。</p><p id="d684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像方法、实例变量、参数这样的类成员如果不用的话都可以删除。</p><p id="d1bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也适用于import语句。</p><h1 id="a454" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">除非在Import语句中，否则不需要语句</h1><p id="89a9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该再使用<code class="fe lb lc ld le b">require</code>语句，因为ES6模块已经成为标准。</p><p id="1c64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，与其写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="269b" class="mq lg iq le b gy mr ms l mt mu">const foo = require('foo');</span></pre><p id="5a09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="06ce" class="mq lg iq le b gy mr ms l mt mu">import foo = require('foo');</span></pre><p id="cfce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="68a0" class="mq lg iq le b gy mr ms l mt mu">import foo from 'foo';</span></pre><h1 id="fea8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在有限类型上用作常量</h1><p id="073c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">const</code>断言比文字类型更好，因为它们使值保持不变。</p><p id="e0e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用<code class="fe lb lc ld le b">const</code>断言，文字类型不能被加宽，对象和数组条目变成<code class="fe lb lc ld le b">readonly</code>。</p><p id="c3c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2e81" class="mq lg iq le b gy mr ms l mt mu">let bar: 2 = 2;</span></pre><p id="7e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="84e9" class="mq lg iq le b gy mr ms l mt mu">let bar = { bar: 'baz' as 'baz' };</span></pre><p id="3088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e442" class="mq lg iq le b gy mr ms l mt mu">let foo = 'bar' as const;</span></pre><p id="c02a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="cf1a" class="mq lg iq le b gy mr ms l mt mu">let foo = { bar: 'baz' };</span></pre><h1 id="5fd7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用for-of循环代替for循环</h1><p id="e0d0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">for-of循环让我们用一个简单的循环来遍历条目，而不是必须设置循环条件和索引变量。</p><p id="f5ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还适用于任何类型的iterable对象，而不是具有index和<code class="fe lb lc ld le b">length</code>属性的对象。</p><p id="a77f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="91c9" class="mq lg iq le b gy mr ms l mt mu">for (let i = 0; i &lt; arr.length; i++) {<br/>  console.log(arr[i]);<br/>}</span></pre><p id="4f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7421" class="mq lg iq le b gy mr ms l mt mu">for (const x of arr) {<br/>  console.log(x);<br/>}</span></pre><p id="839a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，如果我们只想遍历一个iterable对象中的所有项，for-of循环要简单得多。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/9683b3f8290327f915bafe02ffcbe4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gkj5muyjFPH_8NF9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brooke Lark</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f713" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用函数类型而不是带有调用签名的接口</h1><p id="a3d9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用函数类型来代替接口或对象类型文字，只使用一个调用签名。</p><p id="ce67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="05a0" class="mq lg iq le b gy mr ms l mt mu">function foo(bar: { (): number }): number {<br/>  return bar();<br/>}</span></pre><p id="02e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1955" class="mq lg iq le b gy mr ms l mt mu">interface Foo {<br/>  (): void;<br/>  bar: number;<br/>}</span><span id="f5c1" class="mq lg iq le b gy mw ms l mt mu">const foo: Foo = () =&gt; {};<br/>foo.bar = 1;<br/>foo();</span></pre><p id="2563" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个不返回任何内容的函数，它有一个数字属性。</p><h1 id="079e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="2c35" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可能想在文字类型上使用<code class="fe lb lc ld le b">as const</code>来防止变量的类型变宽，并使它们成为只读的。</p><p id="8fb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们想使用<code class="fe lb lc ld le b">import</code>而不是<code class="fe lb lc ld le b">require</code>来导入模块。</p><p id="aed1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还希望使用接口而不是函数来指定函数的类型。</p><p id="a440" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，在大多数情况下，for-of循环比for循环更好。</p></div></div>    
</body>
</html>