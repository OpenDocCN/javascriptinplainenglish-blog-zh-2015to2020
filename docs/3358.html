<html>
<head>
<title>Best Features of ES2017 — Async Functions and Arrays and Shared Buffers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2017的最佳特性—异步功能和阵列以及共享缓冲区</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-features-of-es2017-async-functions-and-arrays-and-shared-buffers-74dace23aa59?source=collection_archive---------4-----------------------#2020-09-22">https://javascript.plainenglish.io/best-features-of-es2017-async-functions-and-arrays-and-shared-buffers-74dace23aa59?source=collection_archive---------4-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43c22f9d1bce1abd1ad40e39fefa4273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Eb7At4j_2a-MLzuS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ecasap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Elaine Casap</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="71da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2017的最佳特性。</p><h1 id="a781" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Async Functions and Array.prototype.forEach()</code></h1><p id="4ea5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Array.prototype.forEach</code>不支持<code class="fe lz ma mb mc b">async</code>和<code class="fe lz ma mb mc b">await</code>语法。</p><p id="6c1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6dda" class="mq lc iq mc b gy mr ms l mt mu">async function downloadContent(urls) {<br/>  urls.forEach(async url =&gt; {<br/>    const content = await makeRequest(url);<br/>    console.log(content);<br/>  });<br/>}</span></pre><p id="ed45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们不会得到所有承诺的结果，因为<code class="fe lz ma mb mc b">forEach</code>不会等待每个承诺完成。</p><p id="74e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们希望使用for-of循环来迭代每个异步函数，以获得我们的结果:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="098e" class="mq lc iq mc b gy mr ms l mt mu">async function downloadContent(urls) {<br/>  for (const url of urls) {<br/>    const content = await makeRequest(url);<br/>    console.log(content);<br/>  }<br/>}</span></pre><p id="ec5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-of循环知道<code class="fe lz ma mb mc b">await</code>操作符，所以我们可以用它来循环运行所有的异步函数。</p><p id="c068" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想并行运行异步函数，我们可以使用<code class="fe lz ma mb mc b">Promise.all</code>:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4820" class="mq lc iq mc b gy mr ms l mt mu">async function downloadContent(urls) {<br/>  await Promise.all(urls.map(<br/>    async url =&gt; {<br/>      const content = await makeRequest(url);<br/>      console.log(content);<br/>    }));<br/>}</span></pre><p id="c912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将URL映射到异步函数，这样我们就可以在承诺数组上调用<code class="fe lz ma mb mc b">Promise.all</code>。</p><p id="e304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回一个承诺，其解析值是承诺解析值的数组。</p><h1 id="62d6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">立即调用异步函数表达式</h1><p id="4d05" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以创建立即运行的异步函数。</p><p id="0ed0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="912b" class="mq lc iq mc b gy mr ms l mt mu">async function foo() {<br/>  console.log(await promiseFunc());<br/>}<br/>foo();</span></pre><p id="85a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="b14f" class="mq lc iq mc b gy mr ms l mt mu">(async function () {<br/>  console.log(await promiseFunc());<br/>})();</span></pre><p id="1a72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也可以是一个箭头函数:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6298" class="mq lc iq mc b gy mr ms l mt mu">(async () =&gt; {<br/>  console.log(await promiseFunc());<br/>})();</span></pre><h1 id="d847" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">未处理的拒绝</h1><p id="2f5c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当我们使用异步函数时，我们不必担心未处理的拒绝。</p><p id="1174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为当我们遇到它们时，浏览器会向我们报告它们。</p><p id="931c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="0ad3" class="mq lc iq mc b gy mr ms l mt mu">async function foo() {<br/>  throw new Error('error');<br/>}<br/>foo();</span></pre><p id="46eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会看到控制台中记录的错误。</p><h1 id="bb93" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">共享数组缓冲区</h1><p id="d949" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">ES2017引入了共享数组缓冲区，让我们可以构建并发应用。</p><p id="339c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们让我们在多个工作线程和主线程之间共享一个<code class="fe lz ma mb mc b">SharedArrayBuffer</code>对象的字节。</p><p id="7d17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缓冲区是共享，并被封装在一个类型化数组中，这样我们就可以访问它们。</p><p id="374d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在工人之间快速共享数据，工人之间的协调也简单快捷。</p><p id="a499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容来创建共享数组缓冲区:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="51e0" class="mq lc iq mc b gy mr ms l mt mu">const worker = new Worker('worker.js');</span><span id="630e" class="mq lc iq mc b gy mv ms l mt mu">const sharedBuffer = new SharedArrayBuffer(<br/>  100 * Int32Array.BYTES_PER_ELEMENT);<br/>  <br/>worker.postMessage({<br/>  sharedBuffer<br/>});</span><span id="0054" class="mq lc iq mc b gy mv ms l mt mu">const sharedArray = new Int32Array(sharedBuffer);</span></pre><p id="a229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe lz ma mb mc b">worker.js</code>中创建了一个工人。</p><p id="726d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe lz ma mb mc b">SharedArrayBuffer</code>创建了一个共享缓冲区。</p><p id="e799" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以包含100个元素。</p><p id="87f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，为了与worker共享缓冲区，我们调用<code class="fe lz ma mb mc b">postMessage</code>将缓冲区传递给worker。</p><p id="846b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了访问缓冲区的数据，我们创建了一个新的<code class="fe lz ma mb mc b">Int32Array</code>实例。</p><p id="c714" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe lz ma mb mc b">worker.js</code> worker中，我们通过写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d04f" class="mq lc iq mc b gy mr ms l mt mu">self.addEventListener('message', (event) =&gt; {<br/>  const {<br/>    sharedBuffer<br/>  } = event.data;<br/>  const sharedArray = new Int32Array(sharedBuffer);<br/>  //...<br/>});</span></pre><p id="2fd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们监听<code class="fe lz ma mb mc b">message</code>事件并获取<code class="fe lz ma mb mc b">event.data</code>的<code class="fe lz ma mb mc b">sharedBuffer</code>属性。</p><p id="408a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以用同样的方法访问它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/dd340cca0234026fd9a0d6ecddadf29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fwSBAfnXl3cfbX0o"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@foodwithaview?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jenn Kosar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="762f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7e4f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">异步函数不能很好地处理现有的数组实例方法。</p><p id="3be0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用共享数组缓冲区在主线程和工作线程之间共享数据。</p><h2 id="8ace" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="b85e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T3【plain English . ioT5】找到一切的链接！</a></p></div></div>    
</body>
</html>