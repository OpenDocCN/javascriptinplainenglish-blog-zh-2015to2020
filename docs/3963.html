<html>
<head>
<title>How to Manage React State with useReducer() and Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用useReducer()和上下文API管理React状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-manage-state-with-usereducer-and-context-api-3f0ea40a3ac3?source=collection_archive---------2-----------------------#2020-11-06">https://javascript.plainenglish.io/how-to-manage-state-with-usereducer-and-context-api-3f0ea40a3ac3?source=collection_archive---------2-----------------------#2020-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/c2869f14a945d6b35c4a65c20fea0dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*zrVLaj8wsakfcqMGWdvCwQ.png"/></div></figure><p id="38f3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">React是2020年最流行的前端开发框架。React成功背后的原因是学习曲线短，以及它可以让你的应用程序快速启动和运行。但是在React中有一个概念是大多数开发人员都很难理解的，也就是状态管理。</p><p id="a763" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">像Redux、MobX这样的库是围绕React构建的，用于处理状态，但是对于一个新的和即将到来的开发人员来说，学习这些库可能是令人生畏的。在本文中，我将解释如何使用React内置的上下文API和钩子来管理状态。一旦你使用React的内置特性掌握了状态管理的概念，当你学习Redux的时候，它会帮你省去很多痛苦。</p><h1 id="62d2" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是国家管理？</h1><p id="6db8" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">从React 16.8开始，每个React组件，包括类组件和函数组件，都可以有一个状态。简单地说，状态是一个JavaScript对象，表示组件的内存。由于用户的操作或事件，它可以随时改变。状态可以在称为props drilling的过程中沿着组件树向下传递。</p><p id="c7c1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">随着应用程序变得越来越大，管理状态变得越来越困难，而props drilling使得跟踪所有依赖关系变得更加困难。更好的解决方案是使用Context API将状态从应用程序中分离出来，然后在需要的地方共享它。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ls"><img src="../Images/f57e310dec434ef338515e0f1da72fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_pRaGwyTZ-sjBzEXLVifQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">State Management using Context API</figcaption></figure><h1 id="bd6a" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是上下文API？</h1><p id="5d0e" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">我在这里的文章中用一个例子解释了上下文API:<a class="ae mf" href="https://karntech.medium.com/how-to-use-context-api-in-react-673260df24d7" rel="noopener"><strong class="jt io">如何在React </strong> </a>中使用上下文API</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/2bb224c8177166a5df294b0af4c92f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*EjDSOqhNOqIJ9wOqqFwKJQ.png"/></div></figure><p id="ef79" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上下文API被设计为在整个React组件树中共享状态。使用上下文API，您可以共享整个“App”组件树的状态，而不必在每一层将它作为道具传递。然后，您可以直接操作“用户信息”组件中的状态，而不必通过中间的“用户”组件。</p><h1 id="29ee" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是useReducer()钩子？</h1><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e273250bcc5cc426f9fe49e53529c828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*x_jFSqEpOnKw1Z7VgSzS_w.png"/></div></figure><p id="533d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一个useReducer()钩子接受一个Reducer和初始状态，并用一个dispatch方法输出当前状态。当前状态是更新后的状态。基本就是这样！！</p><h1 id="d560" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是减速器？</h1><p id="5274" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">Reducer是一个接受两个参数的函数，这两个参数是action和initialstate(有效负载),并根据执行的操作输出新的状态(当前状态)。您可以使用useReducer()钩子来访问您的reducer。</p><figure class="lt lu lv lw gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/683e7d611885fdc32a2692221b985be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*4vIstQBnChwa486Fwn2v8Q.png"/></div></figure><h1 id="526d" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">履行</h1><p id="6d05" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">现在我们对什么是Reducer、useReducer()和上下文API有了基本的了解，让我们构建一个简单的应用程序来巩固这些概念。在这个应用程序中，我们将创建一个简单的计数器，并使用上下文API存储计数器的值。这里重要的是理解状态管理背后的概念，即使你不理解每一行代码。</p><p id="9742" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们用npx <strong class="jt io"> create-react-app </strong>成为我们的建筑。</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="f2d4" class="mo kq in mk b gy mp mq l mr ms"><strong class="mk io">npx create-react-app counterapp</strong></span></pre><h2 id="195a" class="mo kq in bd kr mt mu dn kv mv mw dp kz kc mx my ld kg mz na lh kk nb nc ll nd bi translated">步骤1:构建DataLayer.js</h2><p id="d960" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">DataLayer.js是我们创建上下文的地方，然后将其导出，供App.js树中的其他组件使用。首先，我们将创建一个名为DataLayerContext的上下文。这个上下文存储了我们的状态。我们可以将其导入子组件，以便以后使用和操作状态。</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="677b" class="mo kq in mk b gy mp mq l mr ms">const DataLayerContext = React.createContext();</span></pre><p id="f023" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">接下来将创建一个以initialstate、reducer和children为参数的函数DataLayer。DataLayerContext。提供程序只是一个与所有子组件共享状态的包装。很可能，这段代码现在对您来说没有意义。但是不要气馁，因为一旦你开始识别模式，状态管理就会变得非常简单。目前，只需将此代码复制并粘贴到您的项目中。</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="8e41" class="mo kq in mk b gy mp mq l mr ms">export const DataLayer = ({ initialstate, reducer, children }) =&gt; (</span><span id="2c15" class="mo kq in mk b gy ne mq l mr ms">&lt;DataLayerContext.Provider value={useReducer(reducer, initialstate)}&gt;</span><span id="abe0" class="mo kq in mk b gy ne mq l mr ms">{children}</span><span id="4aaa" class="mo kq in mk b gy ne mq l mr ms">&lt;/DataLayerContext.Provider&gt;</span><span id="0ca1" class="mo kq in mk b gy ne mq l mr ms">);</span></pre><p id="2679" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们的上下文已经创建，是时候导出了，这样其他组件就可以使用它了。</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="6629" class="mo kq in mk b gy mp mq l mr ms">export const useDataLayerValue = () =&gt; useContext(DataLayerContext);</span></pre><h2 id="d563" class="mo kq in bd kr mt mu dn kv mv mw dp kz kc mx my ld kg mz na lh kk nb nc ll nd bi translated">第2步:初始状态和还原剂-还原剂. js</h2><p id="75f4" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">要管理一个国家，首先我们需要创建一个国家。我们将称我们的州为初始州。它将有一个值设置为0的属性“data”。</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="34ef" class="mo kq in mk b gy mp mq l mr ms">export const initialState = {</span><span id="7918" class="mo kq in mk b gy ne mq l mr ms">data: 0</span><span id="dd5d" class="mo kq in mk b gy ne mq l mr ms">};</span></pre><p id="7375" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">接下来，我们创建我们的减速器。如上所述，Reducer只是一个函数，它接受两个参数，即动作和初始状态(有效负载)，并基于执行的动作输出新的状态(当前状态)。</p><p id="26e0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于我们的减速器，如果动作是“INSC”，减速器将更新我们的状态，并将数据属性值增加1。如果操作是“DESC”，它会将数据属性值减少1。非常直截了当！！！</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="cd2a" class="mo kq in mk b gy mp mq l mr ms">export const reducer = (state, action) =&gt; {</span><span id="f1d7" class="mo kq in mk b gy ne mq l mr ms">switch (action.type) {</span><span id="5965" class="mo kq in mk b gy ne mq l mr ms">case "INSC":</span><span id="7838" class="mo kq in mk b gy ne mq l mr ms">return { ...state, data: state.data - 1 };</span><span id="c88a" class="mo kq in mk b gy ne mq l mr ms">case "DESC":</span><span id="26b0" class="mo kq in mk b gy ne mq l mr ms">return { ...state, data: state.data + 1 };</span><span id="1187" class="mo kq in mk b gy ne mq l mr ms">default:</span><span id="e97a" class="mo kq in mk b gy ne mq l mr ms">return state;</span><span id="0792" class="mo kq in mk b gy ne mq l mr ms">}</span><span id="0b39" class="mo kq in mk b gy ne mq l mr ms">};</span></pre><h2 id="36d1" class="mo kq in bd kr mt mu dn kv mv mw dp kz kc mx my ld kg mz na lh kk nb nc ll nd bi translated">第3步:用数据层包装应用组件。</h2><p id="46c5" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">随着reducer、DataLayer和initialstate就绪，是时候将状态传递给应用程序组件树了。我们通过在index.js文件中用DataLayer包装应用组件来实现这一点。现在，App.js组件树中的每个组件都可以访问状态。嘣！！！！</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="9db4" class="mo kq in mk b gy mp mq l mr ms">import React from "react";</span><span id="7220" class="mo kq in mk b gy ne mq l mr ms">import ReactDOM from "react-dom";</span><span id="25c1" class="mo kq in mk b gy ne mq l mr ms">import { DataLayer } from "./Datalayer";</span><span id="1068" class="mo kq in mk b gy ne mq l mr ms">import App from "./App";</span><span id="f018" class="mo kq in mk b gy ne mq l mr ms">import { initialState } from "./Reducer";</span><span id="ab43" class="mo kq in mk b gy ne mq l mr ms">import { reducer } from "./Reducer";</span><span id="f692" class="mo kq in mk b gy ne mq l mr ms">const rootElement = document.getElementById("root");</span><span id="64b9" class="mo kq in mk b gy ne mq l mr ms">ReactDOM.render(</span><span id="62f1" class="mo kq in mk b gy ne mq l mr ms">&lt;React.StrictMode&gt;</span><span id="e6a7" class="mo kq in mk b gy ne mq l mr ms">&lt;DataLayer initialstate={initialState} reducer={reducer}&gt;</span><span id="d6ee" class="mo kq in mk b gy ne mq l mr ms">&lt;App /&gt;</span><span id="dfab" class="mo kq in mk b gy ne mq l mr ms">&lt;/DataLayer&gt;</span><span id="1d26" class="mo kq in mk b gy ne mq l mr ms">&lt;/React.StrictMode&gt;,</span><span id="c760" class="mo kq in mk b gy ne mq l mr ms">rootElement</span><span id="0bd5" class="mo kq in mk b gy ne mq l mr ms">);</span></pre><h2 id="8fa7" class="mo kq in bd kr mt mu dn kv mv mw dp kz kc mx my ld kg mz na lh kk nb nc ll nd bi translated">第4步:访问和修改App.js组件中的状态</h2><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="2016" class="mo kq in mk b gy mp mq l mr ms">App.js component</span><span id="8ee1" class="mo kq in mk b gy ne mq l mr ms">import { useDataLayerValue } from "./Datalayer";</span></pre><p id="1c7c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们可以使用useDataLayerValue()访问状态属性“data”。</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="9144" class="mo kq in mk b gy mp mq l mr ms">const [{ data }, dispatch] = useDataLayerValue();</span></pre><p id="34f7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最后，我们将使用2个按钮修改状态的值。按钮“+1”触发具有动作类型“INSC”的调度——将数据值增加1并更新状态。按钮“-1”触发具有操作类型“DESC”的调度——将数据值减1并更新状态。</p><pre class="lt lu lv lw gt mj mk ml mm aw mn bi"><span id="1a8e" class="mo kq in mk b gy mp mq l mr ms">&lt;button onClick={() =&gt; dispatch({ type: "INSC" })}&gt;-1&lt;/button&gt;</span><span id="1f63" class="mo kq in mk b gy ne mq l mr ms">&lt;button onClick={() =&gt; dispatch({ type: "DESC" })}&gt;+1&lt;/button&gt;</span></pre><p id="0dde" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们的柜台应用程序现已完成。我希望我简单的状态管理教程能帮助你理解反应和网络开发最核心的概念之一。整个代码可以在沙箱<a class="ae mf" href="https://codesandbox.io/s/context-api-example-t7eux?file=/src/App.js:228-359" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io">这里</strong> </a>找到。</p><p id="5fab" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">喜欢应用:<a class="ae mf" href="https://csb-t7eux-qq7eque4t.vercel.app/" rel="noopener ugc nofollow" target="_blank">csb-t7eux-qq7equee4t . vercel . App</a></p><h2 id="2fc7" class="mo kq in bd kr mt mu dn kv mv mw dp kz kc mx my ld kg mz na lh kk nb nc ll nd bi translated">快乐编码！</h2></div></div>    
</body>
</html>