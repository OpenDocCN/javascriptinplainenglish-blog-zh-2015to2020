<html>
<head>
<title>Watching MobX Observables with Intercept and Observe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Intercept和Observe观察MobX可观察性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/watching-mobx-observables-with-intercept-and-observe-f576c9937de2?source=collection_archive---------7-----------------------#2020-04-09">https://javascript.plainenglish.io/watching-mobx-observables-with-intercept-and-observe-f576c9937de2?source=collection_archive---------7-----------------------#2020-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/53cf573d8bc4b89a87c413d6cc6c9d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7YXLUdHOD9fd_kX8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@seteales?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Allef Vinicius</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8608" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe lb lc ld le b">intercept</code>函数观察MobX检测和修改突变，用<code class="fe lb lc ld le b">observe</code>函数观察可观察到的值变化。</p><p id="2745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用<code class="fe lb lc ld le b">intercept</code>来监控变化，在将突变应用到可观察对象之前检测和修改它们，并使用<code class="fe lb lc ld le b">observe</code>来观察变化。</p><h1 id="8e5f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">拦截</h1><p id="639a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以如下调用<code class="fe lb lc ld le b">intercept</code>函数:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2f65" class="mq lg iq le b gy mr ms l mt mu">intercept(target, propertyName?, interceptor)</span></pre><p id="fe21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的签名中，<code class="fe lb lc ld le b">target</code>是要保护的可观察对象，<code class="fe lb lc ld le b">propertyName</code>是一个可选参数，用于指定要拦截的特定属性。</p><p id="0e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">intercept(user.name, interceptor)</code>与<code class="fe lb lc ld le b">intercept(user, "name", interceptor)</code>不同。第一个尝试在<code class="fe lb lc ld le b">user.name</code>中给当前的<code class="fe lb lc ld le b">value</code>添加一个拦截器，后一个拦截器改变了<code class="fe lb lc ld le b">user</code>的<code class="fe lb lc ld le b">name</code>属性。</p><p id="13d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">interceptor</code>是一个回调函数，它将在每次对可观察对象进行更改时运行。</p><p id="e80c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">intercept</code>函数告诉MobX当前的更改需要做什么。</p><p id="fabb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该执行下列操作之一:</p><ul class=""><li id="d024" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">从函数中原样返回接收到的<code class="fe lb lc ld le b">change</code>对象</li><li id="a36a" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">修改<code class="fe lb lc ld le b">change</code>对象并返回</li><li id="31b3" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">返回<code class="fe lb lc ld le b">null</code>表示不应应用更改</li><li id="e4e8" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">抛出异常</li></ul><p id="4bee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">intercept</code>返回一个<code class="fe lb lc ld le b">disposer</code>函数，当拦截器被调用时，这个函数可以用来取消拦截器。</p><p id="88ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以将多个拦截器注册到同一个可观察对象。他们将在注册顺序中被链接。</p><p id="59a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果其中一个拦截器返回<code class="fe lb lc ld le b">null</code>或抛出异常，那么其他拦截器将不再被评估。</p><p id="da0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以在父对象和单个属性上注册一个拦截器。</p><p id="3442" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8612" class="mq lg iq le b gy mr ms l mt mu">import { observable, intercept } from "mobx";</span><span id="f304" class="mq lg iq le b gy nj ms l mt mu">const theme = observable({<br/>  color: "#ffffff"<br/>});</span><span id="f0a6" class="mq lg iq le b gy nj ms l mt mu">const disposer = intercept(theme, "color", change =&gt; {<br/>  if (!change.newValue) {<br/>    return null;<br/>  }<br/>  if (change.newValue.length === 6) {<br/>    change.newValue = `#${change.newValue}`;<br/>    return change;<br/>  }<br/>  if (change.newValue.length === 7) {<br/>    return change;<br/>  }<br/>  if (change.newValue.length &gt; 10) {<br/>    disposer();<br/>  }<br/>  throw new Error(`Invalid color`);<br/>});</span></pre><p id="7225" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们为<code class="fe lb lc ld le b">theme</code>可观察对象的<code class="fe lb lc ld le b">color</code>属性定义了一个拦截器。</p><p id="ed8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拦截器回调接受一个带有传入值的<code class="fe lb lc ld le b">change</code>参数。然后，它运行一些检查，并对<code class="fe lb lc ld le b">newValue</code>属性进行一些更改。</p><h1 id="f5d2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">观察</h1><p id="7034" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">observe</code>功能用于观察可观察值的变化。</p><p id="72e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c351" class="mq lg iq le b gy mr ms l mt mu">observe(target, propertyName?, listener, invokeImmediately?)</span></pre><p id="ddba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的签名中，<code class="fe lb lc ld le b">target</code>是可以观察到的。</p><p id="d90f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">propertyName</code>是一个可选参数，用于指定要观察的属性。<code class="fe lb lc ld le b">observe(user.name, listener)</code>不同于<code class="fe lb lc ld le b">observe(user, "name", listener)</code>。前者在<code class="fe lb lc ld le b">user.name</code>观察当前的<code class="fe lb lc ld le b">value</code>，后者观察用户的<code class="fe lb lc ld le b">name</code>属性。</p><p id="e41a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">listener</code>是一个回调函数，每次对可观察对象进行修改时都会被调用。它接收一个描述突变的change对象，除了boxed observables，它将调用一个带有<code class="fe lb lc ld le b">newValue</code>和<code class="fe lb lc ld le b">oldValue</code>参数的监听器。</p><p id="082d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">invokeImmediately</code>是默认为<code class="fe lb lc ld le b">false</code>的布尔值。如果我们希望<code class="fe lb lc ld le b">observe</code>用可观察的状态直接调用<code class="fe lb lc ld le b">listener</code>，而不是等待第一次变化，则将它设置为<code class="fe lb lc ld le b">true</code>。</p><p id="34f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="66d0" class="mq lg iq le b gy mr ms l mt mu">import { observable, observe } from "mobx";</span><span id="d5f5" class="mq lg iq le b gy nj ms l mt mu">const person = observable({<br/>  firstName: "John",<br/>  lastName: "Smith"<br/>});</span><span id="c461" class="mq lg iq le b gy nj ms l mt mu">const disposer = observe(person, change =&gt; {<br/>  console.log(<br/>    `${change.type} ${change.name} from ${change.oldValue} to ${<br/>      change.object[change.name]<br/>    }`<br/>  );<br/>});</span><span id="c9f6" class="mq lg iq le b gy nj ms l mt mu">person.firstName = "Jane";</span></pre><p id="4115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个回调函数，回调函数中的<code class="fe lb lc ld le b">change</code>对象包含<code class="fe lb lc ld le b">type</code>变更、<code class="fe lb lc ld le b">name</code>变更、<code class="fe lb lc ld le b">oldValue</code>和<code class="fe lb lc ld le b">change.object[change.name]</code>以获取新值。</p><h1 id="4fee" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">事件</h1><p id="fe95" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">intercept</code>和<code class="fe lb lc ld le b">observe</code>的回调将接收一个事件对象，该对象包含触发事件的可观察对象的<code class="fe lb lc ld le b">object</code>和当前事件类型的<code class="fe lb lc ld le b">type</code>字符串。</p><p id="393e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据类型，它们还有其他字段:</p><h2 id="b738" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">对象添加事件</h2><p id="30fc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">add</code>事件为我们提供了<code class="fe lb lc ld le b">name</code>和<code class="fe lb lc ld le b">newValue</code>属性，分别表示添加的属性名称和分配的新值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/fa4fee8e7d6d07ed432ef637b798be3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VhiANPr-xO5pTD1V"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brittanyg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">britt gaiser</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="baa3" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">对象更新事件</h2><p id="4ffb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">update</code>事件为我们提供了<code class="fe lb lc ld le b">name</code>和<code class="fe lb lc ld le b">newValue</code>属性，分别表示添加的属性名称和分配的新值。</p><p id="6cfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它为我们提供了被替换的值的<code class="fe lb lc ld le b">oldValue</code>属性。</p><h2 id="9a88" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">阵列拼接事件</h2><p id="d375" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这为拼接的起始索引提供了<code class="fe lb lc ld le b">index</code>。拼接也可通过其他排列方式进行，如<code class="fe lb lc ld le b">push</code>等。</p><p id="11bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">removedCount</code>给出被移除的物品数量。</p><p id="65f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">added</code>给我们一个正在添加的项目数组。</p><p id="d76b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">removed</code>给出了一个添加了条目的数组。</p><p id="efbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">addedCount</code>给出添加的项目数量。</p><h2 id="1e64" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">数组更新事件</h2><p id="5d31" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">更新事件给了我们<code class="fe lb lc ld le b">index</code>,它拥有被更新的单个条目的索引</p><p id="1bb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给我们被赋值的值。</p><p id="c43a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">oldVale</code>具有被替换的旧值。</p><h2 id="335c" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">映射添加和删除事件</h2><p id="a666" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Map add和delete事件具有分别用于添加的属性名称和分配的新值的<code class="fe lb lc ld le b">name</code>和<code class="fe lb lc ld le b">newValue</code>属性。</p><h2 id="1cdb" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">地图更新事件</h2><p id="73e5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">delete事件为我们提供了与add和delete事件一起发送的属性，还提供了带有被替换值的<code class="fe lb lc ld le b">oldValue</code>。</p><h2 id="578d" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">装箱和计算的可观测量创建事件</h2><p id="4649" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">装箱的和计算的observables的create事件具有<code class="fe lb lc ld le b">newValue</code>属性来获取我们在创建过程中分配的值。</p><h2 id="4cac" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated">装箱和计算的可观测量更新事件</h2><p id="3003" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">除了<code class="fe lb lc ld le b">newValue</code>之外，更新事件还给出了值被替换的<code class="fe lb lc ld le b">oldValue</code>。</p><h1 id="a22f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="e6c4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">intercept</code>函数在可观察状态的突变完成之前做一些事情。</p><p id="ef49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">observe</code>函数可用于观察MobX可观察值的变化。它需要一个回调，给我们状态的新旧值和其他信息。</p><h2 id="06af" class="mq lg iq bd lh nk nl dn ll nm nn dp lp ko no np lt ks nq nr lx kw ns nt mb nu bi translated"><strong class="ak">用简单英语写的JavaScript的注释:</strong></h2><p id="21eb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>