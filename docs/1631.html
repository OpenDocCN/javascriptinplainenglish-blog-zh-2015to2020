<html>
<head>
<title>How to think of API consumption as data contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何看待API消费为数据契约</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-think-of-api-consumption-as-a-data-contract-c5a440f12593?source=collection_archive---------9-----------------------#2020-04-08">https://javascript.plainenglish.io/how-to-think-of-api-consumption-as-a-data-contract-c5a440f12593?source=collection_archive---------9-----------------------#2020-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="7c5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章最初发表在<a class="ae ks" href="https://leandrotk.github.io/tk/2020/04/thinking-in-data-contracts/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="kt"> TK的博客</em> </strong> </a>。</p><p id="53ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在前端开发中，消费API数据并使用它来呈现用户界面是很常见的。但是有时候，API数据并不是我们想要的。所以我们设法将API数据映射到应用程序状态。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/50c9d81ff758b8f95ca7786927231ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zhiWPObXurL-70_s.png"/></div></div></figure><p id="c3c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是不需要很复杂。它可以只是一个简单的映射函数、一个API数据契约和应用程序状态契约。</p><p id="4468" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将在Redux应用程序的上下文中展示一个例子，以及我们如何使状态保持一致。</p><p id="3893" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们从最初的国家契约开始。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="1b88" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">并在初始状态定义中使用合同类型:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="ef1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在app状态定义之后，我们可以想到API契约。我们可以用数据所需的所有类型实现一个类型<code class="fe li lj lk ll b">PersonAPI</code>。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="4aa4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">既然我们已经定义了我们的契约，我们就可以使用数据映射了。它不需要是一个超级复杂的类。它可以是一个简单的纯函数，接收<code class="fe li lj lk ll b">PersonAPI</code>数据并将其转换为<code class="fe li lj lk ll b">Person</code>数据。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="ed5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这很简单！我们如何使用它？</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="631c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">数据进来了。数据出来了。一切纯洁。</p><p id="01b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们有一个非常简单的映射，没有复杂的逻辑。但是如果我们收到的API数据没有<code class="fe li lj lk ll b">name</code>，只有<code class="fe li lj lk ll b">firstName</code>和<code class="fe li lj lk ll b">lastName</code>呢？我们希望将<code class="fe li lj lk ll b">firstName</code>和<code class="fe li lj lk ll b">lastName</code>转换成<code class="fe li lj lk ll b">Person</code>契约中的<code class="fe li lj lk ll b">name</code>属性。</p><p id="7688" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe li lj lk ll b">PersonAPI</code>类型:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="b2b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe li lj lk ll b">Person</code>类型:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="28f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的<code class="fe li lj lk ll b">name</code>中，我们需要连接字符串。基本上是做字符串插值:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="0ea6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们的映射函数应该是这样的:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c5cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">太好了！为用户界面呈现转换数据。</p><p id="391b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一步:假设我们的<code class="fe li lj lk ll b">lastName</code>是一个可选的数据库列。所以API端点可以返回它...还是不要！</p><p id="24a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以使用类型脚本<code class="fe li lj lk ll b">Optional Property</code>。它告诉我们:“它是一个可选属性，它有这个类型，但是数据可以在这里...还是不要！”</p><p id="8dc2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们在API合同中使用它:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="af1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不错！现在我们知道我们需要做某种逻辑来构建<code class="fe li lj lk ll b">name</code>属性。</p><ul class=""><li id="f86f" class="lm ln iq jw b jx jy kb kc kf lo kj lp kn lq kr lr ls lt lu bi translated">它有<code class="fe li lj lk ll b">lastName</code>属性:concat <code class="fe li lj lk ll b">firstName</code>和<code class="fe li lj lk ll b">lastName</code></li><li id="28dc" class="lm ln iq jw b jx lv kb lw kf lx kj ly kn lz kr lr ls lt lu bi translated">它没有<code class="fe li lj lk ll b">lastName</code>:只返回<code class="fe li lj lk ll b">firstName</code>值</li></ul><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="b633" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是我们也可以通过三元运算将这个<code class="fe li lj lk ll b">let</code>语句转换成一个<code class="fe li lj lk ll b">const</code>:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="057d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">或者更好:把它的职责分离成一个建立名字的功能！</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="d9f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将每个职能部门的职责分开。太好了！现在测试我们的功能更容易了。</p><p id="d9ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一阶段:使用API数据构建新的应用程序状态。假设我们想知道这个人是否活跃。业务规则是:人员状态应该是<code class="fe li lj lk ll b">active</code>，最后一次访问应该在本周内(过去7天内)。</p><p id="10d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先是我们的API合同:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="7270" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将使用这些属性:<code class="fe li lj lk ll b">status</code>和<code class="fe li lj lk ll b">lastVisit</code>。</p><p id="036d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的应用状态合同第二:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="43b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在的业务规则是:</p><ul class=""><li id="d3bf" class="lm ln iq jw b jx jy kb kc kf lo kj lp kn lq kr lr ls lt lu bi translated">人员状态应为<code class="fe li lj lk ll b">active</code></li></ul><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><ul class=""><li id="0fa7" class="lm ln iq jw b jx jy kb kc kf lo kj lp kn lq kr lr ls lt lu bi translated">个人最后一次访问应该在过去7天内</li></ul><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c105" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们的映射函数:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="7c73" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们来重构一下吧！我们就从<code class="fe li lj lk ll b">status</code>这件事开始吧。<code class="fe li lj lk ll b">'active'</code>是字符串。为了在数据结构中定义它并实现可重用性，我们可以使用Typescript的Enum。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="8519" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们像这样使用它:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="454f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个特性使人员状态逻辑变得简单:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="9d17" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在是最后一次探访。代替随机数，让它更具描述性怎么样？这是以毫秒为单位的1天:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="8cbd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是以毫秒为单位的7天:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="3342" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一周前:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="9ab7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们的逻辑变得简单了:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="977b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们现在可以用一个名为<code class="fe li lj lk ll b">isActive</code>的函数将所有这些连接在一起，这个函数返回一个布尔值？</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="fe4e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我真想把<code class="fe li lj lk ll b">weekAgo</code>“逻辑”单独成一个新功能。我还想说出这些陈述。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="d2c6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">命名我们的语句，看起来像:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="2a81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们最后的<code class="fe li lj lk ll b">isActive</code>函数看起来很漂亮:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="3318" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的映射函数很简单:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="f45c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">只是做了一些调整:对象属性值简写为<code class="fe li lj lk ll b">id</code>和<code class="fe li lj lk ll b">email</code>。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="lg lh l"/></div></figure><h1 id="da0e" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">学习</h1><p id="249e" class="pw-post-body-paragraph ju jv iq jw b jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">那么我们在这里学到了什么？</p><ul class=""><li id="5372" class="lm ln iq jw b jx jy kb kc kf lo kj lp kn lq kr lr ls lt lu bi translated">数据契约帮助我们更好地定义我们的数据结构，即我们希望在前端正确呈现UI的状态。</li><li id="030d" class="lm ln iq jw b jx lv kb lw kf lx kj ly kn lz kr lr ls lt lu bi translated">它也是很好的文档:更好地理解我们的API响应和我们需要处理的应用程序状态。</li><li id="e9e1" class="lm ln iq jw b jx lv kb lw kf lx kj ly kn lz kr lr ls lt lu bi translated">另一个很酷的好处是当我们定义数据类型并在初始状态下使用它们时。<a class="ae ks" href="https://leandrotk.github.io/tk/2020/04/consistent-state-management-in-react-and-redux/index.html" rel="noopener ugc nofollow" target="_blank">如果我们在整个应用程序中保持状态契约，我们就能使我们的系统真正一致</a>。</li><li id="eeb3" class="lm ln iq jw b jx lv kb lw kf lx kj ly kn lz kr lr ls lt lu bi translated">不需要很复杂。仅简单和纯粹的函数。将每个职能部门的职责分开，我们就万事俱备了。这也有助于我们进行测试。</li></ul><p id="fe2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望我能很好地概述数据契约、简单的功能和单一责任原则。在软件工程中，真的很容易把一切都搞复杂，搞砸。但是如果我们仔细考虑我们的数据，我们正在使用的数据结构，以及我们如何管理复杂性和逻辑，我认为我们有很好的机会构建好的软件。</p><h2 id="f3ba" class="nd mb iq bd mc ne nf dn mg ng nh dp mk kf ni nj mo kj nk nl ms kn nm nn mw no bi translated">JavaScript用简单的英语写的一个注释:</h2><p id="ea1d" class="pw-post-body-paragraph ju jv iq jw b jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ks" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="jw ir">AI in Plain English</strong></a><a class="ae ks" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="jw ir">UX in Plain English</strong></a><a class="ae ks" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="jw ir">Python in Plain English</strong></a><strong class="jw ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>