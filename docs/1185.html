<html>
<head>
<title>JavaScript 002: Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 002:范围</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-002-scope-25dc0d194781?source=collection_archive---------8-----------------------#2020-02-09">https://javascript.plainenglish.io/javascript-002-scope-25dc0d194781?source=collection_archive---------8-----------------------#2020-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7c66" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">以及您如何也能保持对您的变量的标签！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c4ef7dc4b64b8205cf5c9a41d2b2a3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnU4uDeAfgz1P2kP_HnEgw.jpeg"/></div></div></figure><p id="eea9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">这是JavaScript概念迷你系列的一部分。我们的期望是读者对JavaScript的经验很少，所以如果你已经接触过这个领域，那么可以回顾一下。这并不是说更有经验的人会空手而归。我的目标是对一个主题进行足够深入的研究，以便启发那些理解可能很广泛但很肤浅的人。</em></p><p id="5ae5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">TL；DR </strong>:用<code class="fe ll lm ln lo b">let</code>和<code class="fe ll lm ln lo b">const</code>声明的变量是块范围的。用<code class="fe ll lm ln lo b">var</code>声明的变量是函数范围的。不要隐式声明变量，因为这些变量将是全局范围的，并将覆盖任何其他全局范围的值。最后，通过搜索最内部的作用域来找到变量名，如果没有找到匹配的变量，那么将依次搜索外部的作用域。</p><blockquote class="lp lq lr"><p id="3055" class="ko kp lk kq b kr ks jo kt ku kv jr kw ls ky kz la lt lc ld le lu lg lh li lj ig bi translated"><strong class="kq io">“JavaScript的全局范围就像一个公共厕所。你无法避免走进去，但当你走进去的时候，尽量减少与物体表面的接触。”<br/>——德米特里·巴拉诺夫斯基</strong></p></blockquote><p id="70ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，您已经使用var、let和const成功地声明和分配了一个变量社区，是时候使用它们了。让我们试一试。</p><pre class="kd ke kf kg gt lv lo lw lx aw ly bi"><span id="acce" class="lz ma in lo b gy mb mc l md me">let x = 1; </span><span id="adcd" class="lz ma in lo b gy mf mc l md me">function addOne(num){<br/> console.log(num+1);<br/>}</span><span id="7e9f" class="lz ma in lo b gy mf mc l md me">addOne(x); //-&gt; "2"</span></pre><p id="4441" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">太棒了。当我们在页面底部调用变量<code class="fe ll lm ln lo b">x</code>和函数<code class="fe ll lm ln lo b">addOne </code>时，我们成功地访问了它们。但是我们如何确定我们对<code class="fe ll lm ln lo b">addOne</code>和<code class="fe ll lm ln lo b">x</code>的调用会起作用呢？结果是，<strong class="kq io">两者在被调用时都在作用域内。</strong></p><p id="dc16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">scope上的skinny如下:<strong class="kq io"> scope是你的代码中变量的可访问性。</strong></p><p id="b187" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每次我们调用一个变量，就像我们对<code class="fe ll lm ln lo b">addOne(x)</code>所做的那样，JavaScript引擎会检查我们在调用时可以访问的变量目录。因为在进行函数调用时，名字<code class="fe ll lm ln lo b">x</code>和<code class="fe ll lm ln lo b">addOne</code>都可以在作用域中访问，所以上面的代码不会出错。如果任一名称超出范围，我们将收到一个错误。</p><p id="a745" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们稍微修改一下上面的代码，看看它是如何工作的。</p><pre class="kd ke kf kg gt lv lo lw lx aw ly bi"><span id="0c48" class="lz ma in lo b gy mb mc l md me">{<br/>   let b = 2;<br/>   const c = 3;<br/>   var d = 4;<br/>   e = 5;<br/>}</span><span id="3740" class="lz ma in lo b gy mf mc l md me">function addOne(x){<br/> console.log(x+1)<br/>}</span><span id="ed78" class="lz ma in lo b gy mf mc l md me">addOne(b) //-&gt; Reference error, 'b' is not defined<br/>addOne(c) //-&gt; Reference error, 'c' is not defined<br/>addOne(d) //-&gt; "5"<br/>addOne(e) //-&gt; "6"</span></pre><p id="d1b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">哇哦。这里发生了很多事。我使用花括号{}添加了一个<strong class="kq io">块</strong>，它包含了代码顶部的变量声明。当我们试图在对例子底部的<code class="fe ll lm ln lo b">addOne</code>的函数调用中访问变量时，对用<code class="fe ll lm ln lo b">let</code>和<code class="fe ll lm ln lo b">const</code>声明的变量的调用失败了，而其他的调用成功了。<strong class="kq io">这是因为用</strong> <code class="fe ll lm ln lo b"><strong class="kq io">let</strong></code> <strong class="kq io">和</strong> <code class="fe ll lm ln lo b"><strong class="kq io">const</strong></code> <strong class="kq io">声明的变量是块范围的。</strong>它们的值只能在封闭块中访问。如果没有封闭块，那么它们的值可以在全局范围内访问。如果我们对<code class="fe ll lm ln lo b">addOne</code> <strong class="kq io"> </strong>的调用出现在花括号内，代码就工作了！参见:</p><pre class="kd ke kf kg gt lv lo lw lx aw ly bi"><span id="8dfb" class="lz ma in lo b gy mb mc l md me">{<br/>   let b=2;<br/>   const c=3;<br/>   addOne(b) //-&gt; 3<br/>   addOne(c) //-&gt; 4</span><span id="987f" class="lz ma in lo b gy mf mc l md me">}</span><span id="91b3" class="lz ma in lo b gy mf mc l md me">function addOne(x){<br/> console.log(x+1)<br/>}</span></pre><p id="f0a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同时，用<code class="fe ll lm ln lo b">var</code>声明的变量仍然可以在块外访问。那是因为用 <code class="fe ll lm ln lo b"><strong class="kq io">var</strong></code> <strong class="kq io">声明的<strong class="kq io">变量是函数作用域的。在包含它们的函数内部的任何地方都可以访问它们的名字。如果它们是在函数外部声明的，那么它们是全局范围的，可以在代码中的任何地方访问。</strong></strong></p><p id="57a4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看一下下面的代码。注意用<code class="fe ll lm ln lo b">var</code>声明的变量在函数<code class="fe ll lm ln lo b">myFunc</code>中的任何地方都是可访问的，但在<code class="fe ll lm ln lo b">myFunc</code>之外是不可访问的。</p><pre class="kd ke kf kg gt lv lo lw lx aw ly bi"><span id="366a" class="lz ma in lo b gy mb mc l md me">function myFunc(){<br/>  {<br/>    var a = 1; <br/>    let b = 2;<br/>    const c = 3;<br/>    e = 5;</span><span id="479f" class="lz ma in lo b gy mf mc l md me">  }</span><span id="e023" class="lz ma in lo b gy mf mc l md me">  console.log(a); // -&gt; 1<br/>  console.log(b); // -&gt; Reference Error, b is not defined<br/>  console.log(c); // -&gt; Reference Error, c is not defined<br/>  console.log(e); // -&gt; 5<br/>}</span><span id="9c79" class="lz ma in lo b gy mf mc l md me">myFunc(); </span><span id="e7cb" class="lz ma in lo b gy mf mc l md me">console.log(a); // -&gt; Reference Error, a is not defined<br/>console.log(e); // -&gt; 5</span></pre><p id="c36a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个例子概述了JavaScript变量的另一个特征。当在函数内部声明时，JavaScript变量被<strong class="kq io"> <em class="lk">局部</em> </strong> <em class="lk"> </em>到那个函数。这意味着只有当它们的父函数被调用时，它们的名字才是可访问的，并且这些名字的作用域是它们各自的块和函数。</p><p id="f7e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，用<code class="fe ll lm ln lo b">let</code>和<code class="fe ll lm ln lo b">const</code>声明的变量可以在它们的封闭块中的任何地方访问，用<code class="fe ll lm ln lo b">var</code>声明的变量可以在它们的封闭函数中的任何地方访问。如果没有封闭块或函数，这三个变量都是全局范围的。</p><p id="4982" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是未声明的变量<code class="fe ll lm ln lo b">e</code>呢？它也可以在它的封闭块之外被访问，从上面的例子来看，<code class="fe ll lm ln lo b">e</code>甚至可以在它的封闭函数之外被访问！像<code class="fe ll lm ln lo b">e</code>这样的变量通常被称为<strong class="kq io"><em class="lk"/></strong><strong class="kq io">隐式全局变量，它们对开发者来说尤其阴险。</strong></p><p id="a693" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了演示为什么隐式全局变量对我们的代码如此有害，让我们假设我们有一个名为T3的函数，它返回一个随机的游戏控制台。我们的函数创建了一个<code class="fe ll lm ln lo b">console</code>变量，并使用Math.random()方法从游戏控制台列表中随机选择。该变量被隐式创建并赋给随机选择的结果，然后由<code class="fe ll lm ln lo b">randomConsole</code>返回。</p><pre class="kd ke kf kg gt lv lo lw lx aw ly bi"><span id="40d9" class="lz ma in lo b gy mb mc l md me">function randomConsole(){<br/>  let consoles = ['Xbox', 'PlayStation', 'Wii']; <br/>  console = consoles[Math.floor(Math.random()) * 2];<br/>  return console;<br/>}</span><span id="c5c1" class="lz ma in lo b gy mf mc l md me">console.log(randomConsole()); <br/>//-&gt; Type Error: console.log is not a function</span></pre><p id="09b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">粗略地看一下，人们会认为上面的代码能够完整地工作。然而，有趣的是，当我们试图记录<code class="fe ll lm ln lo b">randomConsole</code>的结果时，我们得到一个错误，说“console.log不是一个函数”。这就是隐式全局变量的问题所在。与显式声明的变量不同，隐式变量不是局部变量。它们存在于全局范围内，并将覆盖已经存在于全局范围内的任何其他变量—在本例中是控制台对象。</p><p id="b525" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了演示上述函数的工作原理，让我们使用<code class="fe ll lm ln lo b">alert()</code>方法来显示<code class="fe ll lm ln lo b">randomConsole</code>函数的值。</p><pre class="kd ke kf kg gt lv lo lw lx aw ly bi"><span id="f7db" class="lz ma in lo b gy mb mc l md me">function randomConsole(){<br/>  let consoles = ['Xbox', 'PlayStation', 'Wii']; <br/>  console = consoles[Math.floor(Math.random()) * 2];<br/>  return console;<br/>}</span><span id="8afd" class="lz ma in lo b gy mf mc l md me">console.log('test') // -&gt; 'test'<br/>alert(randomConsole()); //-&gt; 'PlayStation' is alerted!<br/>alert(console); // -&gt; 'PlayStation' is alerted, too!</span></pre><p id="1dd3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意，即使在声明了<code class="fe ll lm ln lo b">randomConsole</code>函数之后，我们仍然可以使用<code class="fe ll lm ln lo b">console.log</code>方法。这是因为在函数内部定义的变量只有在函数被调用时才被声明。在上面的例子中，当我们试图访问最后一个警报中的<code class="fe ll lm ln lo b">console</code>对象时，我们返回‘PlayStation ’,因为调用了<code class="fe ll lm ln lo b">randomConsole</code>函数，并且在调用过程中控制台对象被重新分配。如果显式声明所有变量，这种行为就不必担心了。</p><p id="5a11" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作用域的强大之处在于我们可以控制代码中变量名的可访问性。因为有了局部作用域的变量，我们不必担心一个函数的变量会踩到另一个函数的变量。这大大减轻了跟踪在整个代码中声明的变量名的负担。我们可以愉快地在函数中重用变量名，而不用担心JavaScript引擎会误解我们的变量引用。</p><p id="8fab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这一规则也有一些例外，例如当存在多个级别的功能和块范围时会发生什么。在这些情况下，当在内层块中访问变量时，任何拥有相同变量名的外层块都将被忽略。<strong class="kq io">只访问最内部的变量声明和赋值。</strong>你可以在下面的例子中看到这一点。</p><pre class="kd ke kf kg gt lv lo lw lx aw ly bi"><span id="e5fd" class="lz ma in lo b gy mb mc l md me">let fruit = ['raspberry', 'tomato']; <br/>let vegetables = ['celery', 'spinach']; </span><span id="3272" class="lz ma in lo b gy mf mc l md me">}<br/>  let fruit = ['apple', 'blackberry', 'orange']; <br/>  console.log(fruit); // -&gt; ['apple', 'blackberry', 'orange']<br/>  console.log(vegetables); // -&gt; ['celery', 'spinach'];<br/>}</span></pre><p id="b0bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">全局变量<code class="fe ll lm ln lo b">fruit</code>和<code class="fe ll lm ln lo b">vegetable</code>可以在程序块内部访问。然而，当变量查找发生在<code class="fe ll lm ln lo b">console.log</code>期间时，在块内声明的水果变量优先于全局水果变量。这是因为JavaScript在查找变量时接受名称的协议。JavaScript总是首先在直接作用域中搜索变量名。如果在当前范围内没有找到匹配的名称，JavaScript就会搜索下一级封闭范围。在上面的例子中，当查找<code class="fe ll lm ln lo b">fruit</code>变量时，在直接作用域中找到了块作用域的fruit变量，查找过程终止。当在直接作用域中查找<code class="fe ll lm ln lo b">vegetable</code>变量时，没有找到匹配的变量名。JavaScript然后在下一个包含范围内搜索，在那里找到全局可用的<code class="fe ll lm ln lo b">vegetable</code>变量。这是JavaScript作用域的一个微妙但强大的特性，它允许我们控制嵌入函数和块中变量的名称空间。如果你想知道哪个变量赋值优先，只要记住<strong class="kq io">内部定义优先</strong>。</p><p id="55d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总结一下:用<code class="fe ll lm ln lo b">let</code>和<code class="fe ll lm ln lo b">const</code>声明的变量是块范围的。用<code class="fe ll lm ln lo b">var</code>声明的变量是函数范围的。不要隐式声明变量，因为这些变量将是全局范围的，并将覆盖任何其他全局范围的值。最后，通过搜索最内部的作用域来找到变量名，如果没有找到匹配的变量，那么将依次搜索外部的作用域。</p><p id="bac9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读，乡亲们。接下来:<strong class="kq io">关闭</strong> …</p></div></div>    
</body>
</html>