<html>
<head>
<title>What You Need to Know About ‘this’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于JavaScript中的“this ”,你需要知道什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/this-javascript-bca2b028e5ac?source=collection_archive---------6-----------------------#2020-09-18">https://javascript.plainenglish.io/this-javascript-bca2b028e5ac?source=collection_archive---------6-----------------------#2020-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="909e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">常见问题&amp;一个ES6故事</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be9ea299021afc359a1c90974e5342c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EnfMbur-9niOkLNz"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jamietempleton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jamie Templeton</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0010" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">基础知识—为什么是“这个”？</h1><p id="5f5b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你已经知道，就跳过这个。我希望我警告过你，这个词可能会和混淆。</p><p id="1037" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们建立一个类。这将导致一个错误:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="11f2" class="mv kx iq mr b gy mw mx l my mz">class Car {<br/>  drive() {<br/>    console.log(“driving”, speed, “fast”)<br/>  }<br/>}</span><span id="a01f" class="mv kx iq mr b gy na mx l my mz">const blueCar = new Car()</span><span id="f166" class="mv kx iq mr b gy na mx l my mz">blueCar.speed = “120 mph”<br/>blueCar.drive()</span></pre><h2 id="8d31" class="mv kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated"><strong class="ak">速度无法定义。</strong>为什么？</h2><p id="6c3f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">因为默认情况下，我们要在驱动方法中使用的速度会在外部搜索这个变量。为了说明这一点，下面是一个不会出现错误的示例:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c472" class="mv kx iq mr b gy mw mx l my mz">let speed = "160 mph"<br/>class Car {<br/>  drive() {<br/>    console.log(“driving”, speed, “fast”)<br/>  }<br/>}</span><span id="634e" class="mv kx iq mr b gy na mx l my mz">const blueCar = new Car()</span><span id="65f0" class="mv kx iq mr b gy na mx l my mz">blueCar.speed = “120 mph”<br/>blueCar.drive()</span></pre><p id="13a6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">“<em class="mk">开160 mph快</em>会被打印出来，因为<em class="mk">速度</em>指的是班外的变量。</p><p id="a9ce" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所以，如果我们只想解决我们班上的一些问题，我们不会走得很远。这就是这个关键字的用途。它总是引用它所属的对象——在我们的例子中，是类。</p><p id="8934" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">正如你在下面的例子中看到的，我们也可以在之后为一个类设置属性。我们分配的所有这些属性都将存储在<em class="mk"> this: </em></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2cdb" class="mv kx iq mr b gy mw mx l my mz">class Car {<br/>  drive() {<br/>    console.log(this)  // Car { speed: "120 mph" }<br/>    console.log(“driving”, this.speed, “fast”) <br/>  }<br/>}</span><span id="869c" class="mv kx iq mr b gy na mx l my mz">const blueCar = new Car()</span><span id="c245" class="mv kx iq mr b gy na mx l my mz">blueCar.speed = “120 mph”<br/>blueCar.drive()</span></pre><h2 id="97e1" class="mv kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">构造函数的作用</h2><p id="4bf9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">构造函数是一个任何类都可以拥有的函数——它必须被同样地调用，并且总是在我们创建一个新的实例时被执行——也就是说，当类被使用时。</p><p id="7001" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">顾名思义，它负责构造我们的类。通过构造函数，我们可以赋值，然后我们可以访问这个关键字。</p><p id="390e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">说到底，构造函数只是一个函数，它获取参数并可以处理参数。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="651c" class="mv kx iq mr b gy mw mx l my mz">class Car {<br/>  constructor(speed) {<br/>    console.log(speed) <em class="mk">// 120 mph<br/>  </em>}</span><span id="ef56" class="mv kx iq mr b gy na mx l my mz">  drive() {<br/>    console.log("driving", speed, "fast")<br/>  }<br/>}</span><span id="e0ea" class="mv kx iq mr b gy na mx l my mz">const blueCar = new Car("120 mph")<br/>blueCar.drive()</span></pre><p id="7bfc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">上面的代码将导致一个错误——在驱动方法中，没有定义速度。</p><p id="7693" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这是和以前一样的问题。仅仅因为我们现在有了一个构造函数，并不能改变被搜索的变量是在类外搜索的事实。</p><p id="14e8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">但是多亏了构造函数，我们可以使用this在类中设置有效性:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="dc8c" class="mv kx iq mr b gy mw mx l my mz">class Car {<br/>  constructor(speed) {<br/>    this.speed = speed<br/>  }<br/>  <br/>  drive() {<br/>    console.log(“driving”, this.speed, “fast”)<br/>  }<br/>}</span></pre><p id="600a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在让我们了解更多关于this-关键字的信息。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="e00f" class="kw kx iq bd ky kz nt lb lc ld nu lf lg jw nv jx li jz nw ka lk kc nx kd lm ln bi translated">问题—“这个”丢失了</h1><p id="704f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我给你看一些乍一看非常奇怪的东西。</p><p id="ae29" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这将是我们的又一堂课:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="88dc" class="mv kx iq mr b gy mw mx l my mz">class Car {<br/>    constructor(speed) {<br/>        this.speed = speed<br/>    }<br/>    drive() {<br/>        console.log(this.speed)<br/>    }<br/>}</span></pre><p id="dc8b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们创建一个新实例并执行它的驱动方法:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f80b" class="mv kx iq mr b gy mw mx l my mz">const mercedes = new Car(120)<br/>mercedes.drive()  // 120 - as expected</span></pre><p id="4761" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一切如预期。我们传递一些东西给构造函数，构造函数将它绑定到<em class="mk">这个</em>，当然，drive-method现在可以访问速度<em class="mk">。</em></p><p id="ec2f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这是执行驱动方法的第二种方式，用于打印我们的速度:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="268f" class="mv kx iq mr b gy mw mx l my mz">const driveMethod = mercedes.drive <br/>driveMethod() // error - this.speed is not defined</span></pre><p id="3bc2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">将会出现错误。这是一个完全正确的语法，我们可以在任何地方使用它——但是有一个关于类的问题。</p><p id="07ba" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">函数被执行，但是<em class="mk">这个</em>丢失了——因为<em class="mk">这个</em>是点前面的东西——如果我们只调用函数，它就会丢失。是啊，真奇怪。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="285a" class="kw kx iq bd ky kz nt lb lc ld nu lf lg jw nv jx li jz nw ka lk kc nx kd lm ln bi translated">更多问题—窗口对象折叠</h1><p id="d622" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如前所述，这总是指它所围绕/所属的物体。这可能成为一个问题；让我们看一个例子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="231f" class="mv kx iq mr b gy mw mx l my mz">class Car {<br/>  constructor(speed) {<br/>    this.speed = speed<br/>  }</span><span id="529c" class="mv kx iq mr b gy na mx l my mz">  drive() {<br/>    console.log(“driving”, this.speed, “fast”)<br/>    setTimeout(function() { }, 1000)<br/>  }<br/>}</span><span id="9fdd" class="mv kx iq mr b gy na mx l my mz">const blueCar = new Car(“120 mph”)</span><span id="9b6d" class="mv kx iq mr b gy na mx l my mz">blueCar.drive()</span></pre><p id="a7c7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">上面的代码工作正常。但是当我们把console.log放入setTimeout()时，就像下面这样，我们会得到一个错误:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9122" class="mv kx iq mr b gy mw mx l my mz">drive() {<br/>  setTimeout(function() {<br/>    console.log(“driving”, this.speed, “fast”)<br/>  }, 1000)<br/>}</span></pre><p id="958d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">速度未定义。因为<em class="mk">窗口</em>不提供<em class="mk">速度</em>。</p><p id="c436" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><em class="mk"> setTimeout </em>属于全局窗口对象。我们可以改为编写<em class="mk">window . settimeout()—</em>现在指的是窗口对象。</p><p id="3e45" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当然，这是一个问题——我们的这个也几乎丢失了。但是有两种不同的解决方法。让我们从现在被认为是多余的一个开始:</p><p id="e275" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">我们可以复制正确的<em class="mk">这个</em>。</strong></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b946" class="mv kx iq mr b gy mw mx l my mz">drive() {<br/>  let _this = this<br/>  setTimeout(function() {<br/>    console.log(“driving”, _this.speed, “fast”)<br/>  }, 1000)<br/>}</span></pre><p id="7e85" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这种方法非常有效，但是还有一种更现代的方法。也许你听说过箭头函数。</p><h2 id="9e2f" class="mv kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">Arrow与常规函数——使用“this”示例</h2><p id="24d5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">箭头函数和常规/经典函数有一些不同。一个重要的问题是你如何处理这个问题。</p><p id="6afa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在Arrow函数中，<em class="mk"> this </em>总是表示定义Arrow函数的对象，因此<em class="mk"> this </em>具有封闭上下文中的原始含义——在我们的示例中是我们的drive-method。</p><p id="9141" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e111" class="mv kx iq mr b gy mw mx l my mz">drive() {<br/>  setTimeout(() =&gt; {<br/>    console.log(“driving”, this.speed, “fast”)<br/>  }, 1000)<br/>}</span></pre><p id="1736" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这现在工作没有任何错误。</p><p id="fea1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">以下是JavaScript中箭头函数的更多信息:</p><div class="ny nz gp gr oa ob"><a href="https://medium.com/javascript-in-plain-english/arrow-functions-vs-regular-functions-in-javascript-f98687f23a6d" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">JavaScript中的箭头函数与常规函数</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">旧的常规函数和JavaScript中的ES6箭头函数之间的终极对决。它们的工作方式和时间…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kp ob"/></div></div></a></div></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="3f68" class="kw kx iq bd ky kz nt lb lc ld nu lf lg jw nv jx li jz nw ka lk kc nx kd lm ln bi translated">这在全球范围内</h1><p id="7df4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">基本上，在JavaScript中，默认情况下这是指顶级对象。在浏览器中，它是窗口对象，这是JavaScript中几乎每个对象的起源。不仅<em class="mk">文档</em>而且例如数学。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4b6be10eea63cf24e797f948179bbe1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*Ma-GGSSs8qM46xDqCu3q6Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source: the author, Chrome Devtools</figcaption></figure><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="62f2" class="mv kx iq mr b gy mw mx l my mz">window.document // #document<!-- --> </span><span id="a669" class="mv kx iq mr b gy na mx l my mz">window.Math.PI // 3.141….</span></pre><p id="1097" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所以在JavaScript中，它是窗口对象。但是Node.js中没有浏览器窗口，所以没有窗口对象——最高的对象叫做<em class="mk">全局</em>。</p><p id="5dff" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果您打开Node.js命令行并键入以下内容，您将看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/f9963f01d1d07f86bb660b7bb7f68837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5Kz0dueqJbCfrYagjnoWQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source: the author, Node.js command line</figcaption></figure><p id="d0ce" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您也可以通过以下方式访问全局对象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/37e2899b31fa80d5f1f4daccdf4e6952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIroINjbaKAiueHTgxZfOg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source: the author, Node.js command line</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/582843adbe6381c1b5571ff93a192d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kzvXxu1o9Q0tf_QRX7bVg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source: the author, Node.js command line</figcaption></figure><p id="514c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">尽管如此，当然有交集:在浏览器中，<em class="mk"> setTimeout </em>是window对象的子对象；在Node.js中，<em class="mk"> setTimeout </em>函数会转到全局对象。</p><p id="fdbb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><a class="ae kv" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">加入我的邮件列表保持联系</strong> </a></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h2 id="17c1" class="mv kx iq bd ky nb nc dn lc nd ne dp lg lx nf ng li mb nh ni lk mf nj nk lm nl bi translated">简单英语的JavaScript</h2><p id="d21d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="lq ir">！</strong></p></div></div>    
</body>
</html>