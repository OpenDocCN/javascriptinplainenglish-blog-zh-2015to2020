<html>
<head>
<title>Create 3D Text Meshes in Three.js with React-Three-Fiber</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用反应三纤维在三个js中创建三维文本网格</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-3d-text-meshes-in-three-js-with-react-three-fiber-4679a2cfc3ab?source=collection_archive---------8-----------------------#2020-10-22">https://javascript.plainenglish.io/create-3d-text-meshes-in-three-js-with-react-three-fiber-4679a2cfc3ab?source=collection_archive---------8-----------------------#2020-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f35656242da9f10d26ca58319dbdb19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S_nmNWhCvhN7CCL5"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@ripato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ricardo Gomez Angel</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="8d5b" class="pw-subtitle-paragraph ka jc jd bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">利用您的反应技能来渲染3D文本</h2></div><p id="d134" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我第一次遇到T2的时候，就被吹走了。很难相信我看到的复杂的3D场景不是视频，而是直接在浏览器中渲染的！我想用它做点什么，什么都行，只是想了解这项技术是什么，以及它在HTML、CSS和JS生态系统中的位置。</p><p id="cb9b" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">虽然有一些探索性的尝试将trial . js结合到我网站的早期版本中，但是现在剩下的就是我网站的<a class="ae ja" href="https://ilyameerovich.com" rel="noopener ugc nofollow" target="_blank">主页</a>上旋转的文本网格。在这篇文章中，我将介绍如何使用trial . js和reaction，使用惊人的<a class="ae ja" href="https://github.com/pmndrs/react-three-fiber" rel="noopener ugc nofollow" target="_blank">reaction-三纤维</a>库来复制它。</p><p id="b47d" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将充分利用您在下面的<a class="ae ja" href="https://codesandbox.io/s/recursing-sun-mc2ny" rel="noopener ugc nofollow" target="_blank">和</a>框中看到的内容，所以如果您要继续，您将需要一个空白的反应项目来使用代码。</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="e590" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">背景</h1><h2 id="b126" class="mm lv jd bd lw mn mo dn ma mp mq dp me lb mr ms mg lf mt mu mi lj mv mw mk mx bi translated">三. js</h2><p id="c6e8" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">如果你以前没有遇到过trial . js，它是一个用于创建3D场景的API。它位于大多数现代浏览器附带的WebGL API之上，这反过来使得在浏览器中进行GPU加速的3D图形编程成为可能。</p><p id="fe3b" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就其本身而言，3D图形编程是一个巨大的领域，完全独立于网络开发，这里我们将只关注一个相对简单的例子，您可以稍后进行扩展。</p><p id="e353" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">您可以通过查看他们文档中的<a class="ae ja" href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene" rel="noopener ugc nofollow" target="_blank">教程</a>来品尝trial . js的传统风味。如果你先通读一遍，这篇文章的其余部分会更有意义。</p><h2 id="4c6a" class="mm lv jd bd lw mn mo dn ma mp mq dp me lb mr ms mg lf mt mu mi lj mv mw mk mx bi translated">反应三纤维</h2><p id="2665" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">因为我的网站是用Gatsby构建的，它使用了React，我很高兴发现了<code class="fe nd ne nf ng b">react-three-fiber</code>。这是来自<code class="fe nd ne nf ng b"><a class="ae ja" href="https://www.react-spring.io/" rel="noopener ugc nofollow" target="_blank">react-spring</a></code>的制造商保罗·亨舍尔的一个包，它允许我们以同样的基于组件的方式来声明性地构建三个. js场景，就像我们习惯于使用reaction一样。</p><p id="2e91" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如丹·阿布拉莫夫<a class="ae ja" href="https://overreacted.io/how-does-setstate-know-what-to-do/" rel="noopener ugc nofollow" target="_blank">对</a>的解释:</p><blockquote class="nh ni nj"><p id="9305" class="ks kt nk ku b kv kw ke kx ky kz kh la nl lc ld le nm lg lh li nn lk ll lm ln ig bi translated"><em class="jd">自从React 0.14中的包拆分后，React包有意只公开定义组件的API。React的大部分实现都存在于“渲染器”中。</em><code class="fe nd ne nf ng b"><em class="jd">react-dom</em></code><em class="jd"/><code class="fe nd ne nf ng b"><em class="jd">react-dom/server</em></code><em class="jd"/><code class="fe nd ne nf ng b"><em class="jd">react-native</em></code><em class="jd"/><code class="fe nd ne nf ng b"><em class="jd">react-test-renderer</em></code><em class="jd"/><code class="fe nd ne nf ng b"><em class="jd">react-art</em></code><em class="jd">都是一些渲染器的例子(你也可以</em> <a class="ae ja" href="https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples" rel="noopener ugc nofollow" target="_blank"> <em class="jd">构建自己的</em> </a> <em class="jd"> ) </em></p></blockquote><p id="f7b9" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe nd ne nf ng b">react-three-fiber</code>就是这样一个渲染器——取JSX并将其翻译成用于画布的Three.js代码。</p><p id="033e" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了给出一个快速的说明性比较，如果我们想给我们的场景添加一个网格，下面是我们如何使用传统的Three.js API*来完成的:</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="no lt l"/></div></figure><p id="8beb" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面是我们如何利用react-three-fiber实现同样的目标:</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="no lt l"/></div></figure><p id="511f" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">*要使这些示例成为完全可用的Three.js场景，需要更多代码。</p><h1 id="1f62" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">布置我们的场景</h1><p id="13c2" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">要设置一个可以显示网格的场景，我们需要三样东西——一个场景、一个摄像机和一个渲染器。场景包含了我们所有的网格，灯光等。相机代表感知场景的视点，渲染器接收所有这些信息，然后“决定”在当前帧中应该渲染什么，并将所有内容渲染到画布上。</p><p id="deca" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于我们的示例，您首先需要安装依赖项:</p><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="db2f" class="mm lv jd ng b gy nt nu l nv nw">npm i three react-three-fiber</span></pre><p id="c2ea" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将从<code class="fe nd ne nf ng b">react-three-fiber</code>导入<code class="fe nd ne nf ng b">Canvas</code>组件并渲染它。</p><p id="4429" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe nd ne nf ng b">Canvas</code>组件需要一堆道具来调整渲染器、相机和其他东西，但是<code class="fe nd ne nf ng b">react-three-fiber</code>为我们设置了<a class="ae ja" href="https://inspiring-wiles-b4ffe0.netlify.app/1-canvas" rel="noopener ugc nofollow" target="_blank">默认值</a>，所以我们什么都不用做！</p><p id="7722" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们的代码现在应该是这样的:</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="no lt l"/></div></figure><h1 id="4122" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">添加我们的文本网格</h1><p id="290c" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">Three.js中的网格至少需要两个属性:</p><ol class=""><li id="6e33" class="nx ny jd ku b kv kw ky kz lb nz lf oa lj ob ln oc od oe of bi translated">定义其形状的几何图形，以及</li><li id="f5ae" class="nx ny jd ku b kv og ky oh lb oi lf oj lj ok ln oc od oe of bi translated">一种定义外观的材料——它的颜色，它如何与光线、阴影等相互作用。</li></ol><p id="4530" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们不会为我们的文本网格从头开始雕刻每一个字形，那将会有很多工作要做。</p><p id="7fa7" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">相反，我们将使用<a class="ae ja" href="http://gero3.github.io/facetype.js/" rel="noopener ugc nofollow" target="_blank">facetype . js</a>——一种服务，它获取一个字体文件，并生成一个JSON文件，表示每个字体在3D空间中的坐标。我们将把这个JSON文件传递给Three.js，它将为我们构造一个几何图形。</p><p id="eeaf" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在我的例子中，我使用了Roboto字体文件。在获得JSON文件并将其导入到我的沙箱中之后，我们得到了:</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="no lt l"/></div></figure><p id="4008" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在我们应该在屏幕上看到一些东西！</p><p id="7a62" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">不过，这里有很多新代码要解包，所以让我们来看看组件中发生了什么，然后调整我们的场景，使其看起来更像示例。</p><p id="e26d" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们使用<code class="fe nd ne nf ng b">THREE.FontLoader</code>类解析JSON文件并返回一个<a class="ae ja" href="https://threejs.org/docs/#api/en/extras/core/Font" rel="noopener ugc nofollow" target="_blank">字体</a>对象。</p><p id="f307" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们有一个选项对象，我们在其中指定:</p><ol class=""><li id="5b37" class="nx ny jd ku b kv kw ky kz lb nz lf oa lj ob ln oc od oe of bi translated"><code class="fe nd ne nf ng b">font</code>是指这个新创建的字体对象</li><li id="00a1" class="nx ny jd ku b kv og ky oh lb oi lf oj lj ok ln oc od oe of bi translated">我们的几何图形具有任意的大小5，</li><li id="df3c" class="nx ny jd ku b kv og ky oh lb oi lf oj lj ok ln oc od oe of bi translated">我们的几何体的高度是1，这意味着它被挤出了1。如果这个值是0，我们的网格将完全2D。增加这个值会增加我们字形的“深度”</li></ol><p id="1c52" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在我们的<code class="fe nd ne nf ng b">App</code>组件中，我们返回了之前的<code class="fe nd ne nf ng b">Canvas</code>组件，但是现在它有了一个<code class="fe nd ne nf ng b">mesh</code>子组件，这个子组件又有了一个几何体和一个材质。在<code class="fe nd ne nf ng b">react-three-fiber</code>中，这些属性作为子属性被传入。</p><p id="3034" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">至于<code class="fe nd ne nf ng b">attach</code>道具，文档并没有明确说明在什么情况下我们必须提供它。然而，<a class="ae ja" href="https://github.com/pmndrs/react-three-fiber/blob/300b685c1a92a9a0d5029b7fddef3fe3a83d1adb/src/renderer.tsx#L370" rel="noopener ugc nofollow" target="_blank">这个注释</a>和附带的代码表明这个属性告诉协调器将组件附加到它的父组件，不管<code class="fe nd ne nf ng b">attach</code>的值是多少。我们不必对这些信息做太多，只要我们在创建几何图形和材料时包含这些信息，就应该没问题。</p><p id="05b5" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">您还会注意到<code class="fe nd ne nf ng b">textGeometry</code>组件带有一个<code class="fe nd ne nf ng b">args</code>道具。在这里，我们首先传入我们想要制作成3D网格的字符串，然后传入我们上面创建的options对象。</p><p id="2487" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">确保你的网格的字符串是由JSON字体文件中的字形组成的，否则你会得到一个错误！</p><h1 id="a831" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">调整位置</h1><p id="4314" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">现在，你很可能无法一次看到整个网格。要对此进行调整，您可以:</p><ol class=""><li id="b6bc" class="nx ny jd ku b kv kw ky kz lb nz lf oa lj ob ln oc od oe of bi translated">调整我们的<code class="fe nd ne nf ng b">textOptions</code>对象的<code class="fe nd ne nf ng b">size</code>属性</li><li id="b0b9" class="nx ny jd ku b kv og ky oh lb oi lf oj lj ok ln oc od oe of bi translated">调整摄像机的位置。您可以通过向画布组件传递一个<code class="fe nd ne nf ng b">camera</code>道具来实现这一点，如下所示:</li></ol><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="d8e1" class="mm lv jd ng b gy nt nu l nv nw">...<br/>&lt;Canvas<br/>  camera={{ position: [0, 0, 0] }}<br/>&gt;<br/>...</span></pre><p id="20f2" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里，<code class="fe nd ne nf ng b">position</code>值分别对应于x、y和z坐标。</p><p id="574a" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">3.调整网格的位置。您可以通过将一个<code class="fe nd ne nf ng b">position</code>道具传递给<code class="fe nd ne nf ng b">mesh</code>组件来实现这一点，如下所示:</p><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="cd97" class="mm lv jd ng b gy nt nu l nv nw">&lt;mesh position={[0, 0, 0]}&gt;</span></pre><p id="a3b1" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你可以猜猜这些值指的是什么:)</p><h1 id="9cb9" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">鼓舞</h1><p id="6c0b" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">所以现在我们可以看到我们的网格…但它没有做任何事情。为了让它看起来更有趣，我们可以给它一个简单的动画，让它绕轴旋转。</p><p id="1ca0" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">要做到这一点，我们应该做的第一件事是提取网格到它自己的组件，使它更容易工作。下面是我们的<code class="fe nd ne nf ng b">TextMesh</code>组件的样子:</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="no lt l"/></div></figure><p id="0ac9" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，为了制作动画，我们需要确保WebGL渲染器理解帧与帧之间需要改变的内容。因此，我们将导入并使用来自<code class="fe nd ne nf ng b">react-three-fiber</code>的<code class="fe nd ne nf ng b">useFrame</code>钩子来指定在渲染下一帧之前需要进行哪些更新。</p><p id="5eea" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所有这些都将发生在我们的<code class="fe nd ne nf ng b">TextMesh</code>组件中，所以你可能会想，到底是什么东西将被动画化？网格？几何学？好的，我们将更新对我们网格的引用，我们将通过用另一个React钩子<code class="fe nd ne nf ng b">useRef</code>创建一个引用来获得这个引用。</p><p id="7fc2" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">所以现在，我们更新的组件看起来像这样:</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="no lt l"/></div></figure><p id="e65c" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们已经创建了一个ref，并将其传递给我们的<code class="fe nd ne nf ng b">mesh</code>组件。我们还有一个函数，在我们执行更新的每一帧都会被调用。</p><p id="1378" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果您在<code class="fe nd ne nf ng b">useFrame</code>回调中添加以下内容，您应该会看到一些移动！</p><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="4bac" class="mm lv jd ng b gy nt nu l nv nw">mesh.current.rotation.x += 0.01<br/>mesh.current.rotation.y += 0.01<br/>mesh.current.rotation.z += 0.01</span></pre><p id="cdcc" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">确保还添加了</p><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="d428" class="mm lv jd ng b gy nt nu l nv nw">mesh.current.geometry.center</span></pre><p id="f0ea" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">以确保网格绕轴旋转，而不是绕一个角旋转。</p><h1 id="0686" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">添加纹理</h1><p id="6c38" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">我想做的最后一件事是给我们的网格添加纹理。这意味着，我们将采取一个2D的形象，并拉伸它周围的网格像皮肤。你也可以通过改变颜色和材质来添加不同的效果，这样它会对场景中的光线做出不同的反应。在这里，我们将仅限于改变纹理。</p><p id="d37e" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">一般来说，我们将使用Three.js加载器加载纹理图像，就像我们对字体所做的那样。然后，我们将把纹理应用到材质上。</p><h2 id="68de" class="mm lv jd bd lw mn mo dn ma mp mq dp me lb mr ms mg lf mt mu mi lj mv mw mk mx bi translated">加载纹理</h2><p id="0d0e" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">网上有很多纹理图片。快速搜索会找到数百个。在这个例子中，我使用的是熔岩纹理，但是你可以使用任何你喜欢的纹理。</p><p id="c675" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">首先，我们将纹理导入到我们的项目中。然后我们将使用Three.js纹理加载器类将其转换为纹理对象。</p><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="79b3" class="mm lv jd ng b gy nt nu l nv nw">import texture from 'path/to/texture.jpg'</span><span id="0943" class="mm lv jd ng b gy ol nu l nv nw">// ...</span><span id="0a2f" class="mm lv jd ng b gy ol nu l nv nw">const three_texture = new THREE.TextureLoader().load(texture)</span></pre><p id="f1de" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">根据您选择的纹理，下一步可能会有所不同。在下面的代码中，我们确保纹理在网格上水平和垂直重复缠绕。我们也指定我们想要纹理缠绕多少次。</p><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="b35a" class="mm lv jd ng b gy nt nu l nv nw">three_texture.wrapS = THREE.RepeatWrapping<br/>three_texture.wrapT = THREE.RepeatWrapping<br/>three_texture.repeat.set(0.1, 0.1);</span></pre><p id="4e64" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">关于<code class="fe nd ne nf ng b">Texture</code>属性的更多信息，<a class="ae ja" href="https://threejs.org/docs/#api/en/textures/Texture" rel="noopener ugc nofollow" target="_blank">文档</a>是一个很好的起点。这里还有引人入胜的解释<a class="ae ja" href="https://threejsfundamentals.org/threejs/lessons/threejs-textures.html" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ja" href="https://discoverthreejs.com/book/first-steps/textures-intro/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="97e6" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">应用纹理</h1><p id="3be5" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">使我们的纹理可见的最后一步是将它添加到我们的材质中。我们通过给我们的材质传递一个<code class="fe nd ne nf ng b">args</code>道具来做到这一点，就像我们对几何体所做的一样。道具将包含一个带有<code class="fe nd ne nf ng b">map</code>键的对象，其值就是我们的纹理。</p><p id="fc46" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们的材料现在应该是这样的:</p><pre class="lo lp lq lr gt np ng nq nr aw ns bi"><span id="0188" class="mm lv jd ng b gy nt nu l nv nw">&lt;meshBasicMaterial attach='material' args={{ map: three_texture }}/&gt;</span></pre><p id="b609" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这样，我们现在应该可以在屏幕上看到成品了——一个应用了纹理的动画3D文本网格。最终的代码应该与此类似:</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="no lt l"/></div></figure><h1 id="dfa8" class="lu lv jd bd lw lx ly lz ma mb mc md me kj mf kk mg km mh kn mi kp mj kq mk ml bi translated">结论</h1><p id="f401" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">通过一起构建这个场景，我们引入了<code class="fe nd ne nf ng b">react-three-fiber</code>和它的反应关系。我们已经学习了如何将文本网格添加到一个Three.js场景中并制作动画。我们稍微讨论了一下纹理。</p><p id="8111" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你可能注意到了，上面的代码和开头提到的<a class="ae ja" href="https://codesandbox.io/s/recursing-sun-mc2ny" rel="noopener ugc nofollow" target="_blank">沙箱</a>不一样。与Three.js <em class="nk">本身</em>相比，React的差异更大，因此鼓励读者扩展这个示例，使其成为自己的示例。</p><p id="340b" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">并不是每个项目都需要3D图形来增添趣味。但是通过使用Three.js，您能够实现更大的(几乎是无限的！)文本样式的效果范围比单独使用CSS要大。</p></div><div class="ab cl om on hr oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ig ih ii ij ik"><h1 id="b9be" class="lu lv jd bd lw lx ot lz ma mb ou md me kj ov kk mg km ow kn mi kp ox kq mk ml bi translated">资源</h1><p id="9fcf" class="pw-post-body-paragraph ks kt jd ku b kv my ke kx ky mz kh la lb na ld le lf nb lh li lj nc ll lm ln ig bi translated">Three.js文档:<a class="ae ja" href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene" rel="noopener ugc nofollow" target="_blank">https://three js . org/docs/index . html # manual/en/introduction/Creating-a-scene</a></p><p id="6aec" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">反应三纤维文档:<a class="ae ja" href="https://inspiring-wiles-b4ffe0.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://inspiring-wiles-b4ffe0.netlify.app/</a></p><p id="0714" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">丹·阿布拉莫夫谈React建筑:<a class="ae ja" href="https://overreacted.io/how-does-setstate-know-what-to-do/" rel="noopener ugc nofollow" target="_blank">https://overreacted.io/how-does-setstate-know-what-to-do/</a></p><p id="a4d2" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">facetype . js:<a class="ae ja" href="http://gero3.github.io/facetype.js/" rel="noopener ugc nofollow" target="_blank">http://gero3.github.io/facetype.js/</a></p><p id="fdc1" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">三个JS基础(纹理):<a class="ae ja" href="https://threejsfundamentals.org/threejs/lessons/threejs-textures.html" rel="noopener ugc nofollow" target="_blank">https://three JS Fundamentals . org/three JS/lessons/three JS-Textures . html</a></p><p id="5335" class="pw-post-body-paragraph ks kt jd ku b kv kw ke kx ky kz kh la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Discover Three.js(纹理):<a class="ae ja" href="https://discoverthreejs.com/book/first-steps/textures-intro/" rel="noopener ugc nofollow" target="_blank">https://discover three js . com/book/first-steps/Textures-intro/</a></p></div></div>    
</body>
</html>