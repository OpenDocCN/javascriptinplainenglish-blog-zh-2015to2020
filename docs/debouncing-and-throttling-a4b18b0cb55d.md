# JavaScript 中的去抖动和节流

> 原文：<https://javascript.plainenglish.io/debouncing-and-throttling-a4b18b0cb55d?source=collection_archive---------10----------------------->

![](img/48644acb199638fd60742671c0714ee1.png)

事件侦听器帮助我们绑定当事件被发出时调用的函数，比如滚动或调整大小。

但是，如果在很短的时间内多次调用该事件，该怎么办呢？如果侦听器调用的函数是密集型的，它会严重影响性能。

在这种情况下，去抖动和节流非常有用。

## 节流

节流本质上是让你在给定的时间内只执行一次函数。

如果给定的持续时间是 500 毫秒，无论在这 500 毫秒内事件被发出多少次，事件都将只执行一次。假设一个事件连续触发 3 秒钟，上面的例子将让函数只触发 6 次。

*它的一个关键部分是提供的持续时间是固定的，我们保证函数在给定的时间内至少执行一次。*

在需要及时更新的**连续事件触发器**的情况下，这真的会派上用场。一个很好的例子就是页面的滚动，以及一个监听事件来触发一些 DOM 操作的后续函数。

实现方法如下所示:

## 去抖动

**去抖**是在执行最终功能之前，延迟某次执行以适应所有变化。

它与 throttle 非常相似，只是每次触发事件时都会刷新时间延迟。

假设提供的时间延迟为 500 毫秒，事件触发时间为 3 秒，该函数将在 3.05 秒后只运行一次。

这里重要的一点是，你不能保证函数在给定的延迟时间内至少触发一次，而是每次调用函数时延迟时间都会更新。

这在**函数只需要为最终输出** **触发一次的情况下特别有用，在连续触发的情况下可以忽略之前的调用。**

一个例子是搜索输入触发器。如果您绑定到输入的 change 事件来更新结果，通常不建议为每个输入的字母发送 API 调用。如果在发送最终请求之前，我们宁愿等待 2 秒钟，以确保用户没有进一步的更改，这将大大减少 API 调用的数量。

实现方法如下所示:

对于一个简单的演示来看，触发频率的差异，你可以检查这个小提琴:

在上面的演示中，**油门**和**去抖**都有一个 **1 秒**的延时。

希望这有所帮助！加大油门。

喜欢这篇文章吗？如果是这样，通过 [**订阅解码得到更多类似内容，我们的 YouTube 频道**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw) **！**