<html>
<head>
<title>How to Dockerize a Node Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对节点Web应用程序进行停靠</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-dockerize-a-node-web-app-226db54da17e?source=collection_archive---------7-----------------------#2020-08-19">https://javascript.plainenglish.io/how-to-dockerize-a-node-web-app-226db54da17e?source=collection_archive---------7-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b705c37fb5fe7c56b825ef5ad322acda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jBfK0zGzlmKA23zm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aaron Burden</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5861" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Docker中运行我们的Node web应用程序为我们省去了很多麻烦。</p><p id="a10a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次部署Docker映像时，肯定会部署一个新的容器。</p><p id="a6f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不必担心弄乱容器中的代码。</p><p id="d45d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，Docker映像是用一个映像构建的，因此我们可以重复构建它，而不需要手动做任何事情。</p><p id="6bc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何对一个简单的节点web应用程序进行Dockerize。</p><h1 id="630f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建Node.js应用程序</h1><p id="2e29" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们从创建节点应用程序开始。</p><p id="b072" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们创建一个项目文件夹，并运行<code class="fe me mf mg mh b">npm init --yes</code>来创建<code class="fe me mf mg mh b">package.json</code>。</p><p id="4521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将它们中的所有内容替换为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3c45" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  "name": "my-app",<br/>  "version": "1.0.0",<br/>  "description": "a simple app",<br/>  "author": "",<br/>  "main": "server.js",<br/>  "scripts": {<br/>    "start": "node server.js"<br/>  },<br/>  "dependencies": {<br/>    "express": "^4.16.1"<br/>  }<br/>}</span></pre><p id="1e67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们在同一个文件夹中创建一个<code class="fe me mf mg mh b">server.js</code>文件，并添加:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5627" class="mq lc iq mh b gy mr ms l mt mu">'use strict';<br/><br/>const express = require('express');<br/><br/>const PORT = 8080;<br/>const HOST = '0.0.0.0';<br/><br/>const app = express();<br/>app.get('/', (req, res) =&gt; {<br/>  res.send('Hello World');<br/>});<br/><br/>app.listen(PORT, HOST);<br/>console.log(`Running on http://${HOST}:${PORT}`);</span></pre><p id="f860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只有一条回应“hello world”的路由。</p><h1 id="5300" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建Dockerfile文件</h1><p id="214e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接下来，我们在项目文件夹中创建一个<code class="fe me mf mg mh b">Dockerfile</code>。</p><p id="b2c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们加上:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a16d" class="mq lc iq mh b gy mr ms l mt mu">FROM node:12<br/>WORKDIR /usr/src/app<br/>COPY package*.json ./</span><span id="69a1" class="mq lc iq mh b gy mv ms l mt mu">RUN npm install<br/>COPY . .</span><span id="026f" class="mq lc iq mh b gy mv ms l mt mu">EXPOSE 8080<br/>CMD [ "node", "server.js" ]</span></pre><p id="ce84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获得节点12映像，然后创建一个工作目录来构建映像。</p><p id="eee7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">COPY package*.json ./</code>把<code class="fe me mf mg mh b">package.json</code>和<code class="fe me mf mg mh b">package-lock.json</code>复制到根目录</p><p id="c1fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们运行<code class="fe me mf mg mh b">npm install</code>来安装包。</p><p id="4434" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们把应用的源代码和<code class="fe me mf mg mh b">COPY . .</code>捆绑在一起。</p><p id="5e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">EXPOSE 8080</code>打开Docker镜像的8080端口。</p><p id="a744" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们运行<code class="fe me mf mg mh b">node server.js</code>用<code class="fe me mf mg mh b">CMD [ “node”, “server.js” ]</code>启动app。</p><p id="5260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建<code class="fe me mf mg mh b">.dockerignore</code>文件来阻止Docker将本地模块复制到Docker容器中。</p><p id="fc6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对NPM日志做同样的事情。</p><p id="1bae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此我们在<code class="fe me mf mg mh b">.dockerignore</code>中有以下内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6bde" class="mq lc iq mh b gy mr ms l mt mu">node_modules<br/>npm-debug.log</span></pre><h1 id="73f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">建立形象</h1><p id="9dc4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">然后，我们可以使用以下内容构建图像:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6ed1" class="mq lc iq mh b gy mr ms l mt mu">docker build -t &lt;your username&gt;/my-app .</span></pre><p id="2abf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">&lt;your username&gt;</code>是您帐户的用户名。</p><p id="529c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们应该在运行<code class="fe me mf mg mh b">docker images</code>时看到我们的图像。</p><h1 id="305f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运行图像</h1><p id="f2ed" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">构建完成后，我们可以运行我们的映像:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="31c3" class="mq lc iq mh b gy mr ms l mt mu">docker run -p 8888:8080 -d &lt;your username&gt;/my-app</span></pre><p id="a669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">-d</code>以分离模式运行容器，使其在后台运行。</p><p id="fc05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">-p</code>将容器中的公共端口重定向到私有端口。</p><p id="8bda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以运行<code class="fe me mf mg mh b">docker ps</code>来获取容器ID。</p><p id="dd5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序的输出可以通过以下方式获得:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c277" class="mq lc iq mh b gy mr ms l mt mu">docker logs &lt;container id&gt;</span></pre><p id="c417" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以带着:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5a06" class="mq lc iq mh b gy mr ms l mt mu">docker exec -it &lt;container id&gt; /bin/bash</span></pre><p id="b144" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，为了测试我们的应用程序，我们可以运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="33c4" class="mq lc iq mh b gy mr ms l mt mu">curl -i localhost:8888</span></pre><p id="6348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们应该从应用程序中获得“hello world”响应。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1301ae6acd4b0fde5e7b04335b455428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a79ZPZvbq1abR4i1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rpnickson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Nickson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="af27" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7b7e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用一个简单的Docker文件为一个节点web应用程序创建一个Docker映像。</p><p id="f050" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们不需要做太多工作就可以让它与Docker一起运行。</p><h2 id="9e2b" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简明英语JavaScript</strong></h2><p id="8179" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>