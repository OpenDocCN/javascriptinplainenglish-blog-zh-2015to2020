<html>
<head>
<title>TypeScript on Testosterones — What Is AssemblyScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Testosterones上的TypeScript什么是AssemblyScript？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/assemblyscript-4c68a3c3ecf7?source=collection_archive---------6-----------------------#2020-12-04">https://javascript.plainenglish.io/assemblyscript-4c68a3c3ecf7?source=collection_archive---------6-----------------------#2020-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ba4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松开始使用WebAssembly</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d2d38c466f7bcba3ecf771ab3aa12bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AxH9qQtuEmljCuVtjih7qw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="f681" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> AssemblyScript </strong> —一种用转换成WebAssembly的TypeScript编写代码的方式。名字说明了一切。</p><p id="5e91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是AssemblyScript不仅仅是一个工具或库——它建立在TypeScript语法之上，甚至还扩展了它。</p><p id="df64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WebAssembly允许我们为浏览器和后端开发快速代码，多亏了AssemblyScript，这相当容易。</p><p id="b63f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将了解如何在Node.js和浏览器中使用AssemblyScript。</p><p id="5a28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们看看是什么使AssemblyScript不同于TypeScript，以及它到底有多快。玩得开心！</p><h1 id="2c0f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">安装</h1><p id="ffc6" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">AssemblyScript非常容易使用——比我测试过的同类WebAssembly解决方案都要容易。</p><p id="b2e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个新目录。在里面跑<code class="fe mo mp mq mr b">npm init -y</code>。</p><p id="f192" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，您可以安装依赖项。你可能需要安装带有<code class="fe mo mp mq mr b">npm install -g npx</code>的NPX。</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="9939" class="mw ls iq mr b gy mx my l mz na">npm install --save @assemblyscript/loader<br/>npm install --save-dev assemblyscript</span><span id="d4f0" class="mw ls iq mr b gy nb my l mz na">npx asinit .</span></pre><p id="5c5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以走了！</p><p id="dcb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以打开assembly文件夹中的index.ts并开始编辑该文件。编译后的WebAssembly文件将位于build-folder中。</p><p id="6017" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认情况下，index.ts中有<em class="nc">add</em>-函数——让我们把它编译成WebAssembly。我们可以通过运行<code class="fe mo mp mq mr b">npm run asbuild</code>来做到这一点。</p><p id="2483" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们创建一个Node.js应用程序，它使用这样一个WebAssembly模块——为此，已经有了一个index.js，我们可以使用它来导入所有内容。</p><p id="96b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为Node-App，我在设置的根目录下创建了一个app.js文件。</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="fb60" class="mw ls iq mr b gy mx my l mz na">const add = require('./index.js').add</span><span id="75a3" class="mw ls iq mr b gy nb my l mz na">console.log(add(2, 2))</span></pre><p id="8808" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在用<code class="fe mo mp mq mr b">node app.js</code>运行这段代码时，您应该看到输出为4——我们执行了add-function，它是在index.ts中创建的。</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="2e58" class="mw ls iq mr b gy mx my l mz na"><em class="nc">export</em> function add(a: i32, b: i32): i32 {<br/>  <em class="nc">return</em> a + b;<br/>}</span></pre><p id="37e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但这并不是全部——我们还可以在index.ts中定义和导出其他函数</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="d26f" class="mw ls iq mr b gy mx my l mz na"><em class="nc">export</em> function sub(a: i32, b: i32): i32 {<br/>  <em class="nc">return</em> a — b;<br/>}</span></pre><p id="1545" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们也可以在app.js中导入并执行它——但是首先，我们必须再次执行<code class="fe mo mp mq mr b">npm run asbuild</code>,将代码编译成web程序集。</p><p id="459d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们也可以导入并执行子功能。</p><pre class="kg kh ki kj gt ms mr mt mu aw mv bi"><span id="b81b" class="mw ls iq mr b gy mx my l mz na">const sub = require('./index.js').sub</span></pre><p id="ef89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">/assembly目录中的index.ts是我们的入口点。在同一个文件夹中，我们还可以创建其他类型脚本文件，例如，我们可以从中导出函数。然后，我们可以在我们的index.ts中导入和导出它们，并使它们易于使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="b947" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">浏览器支持</h1><p id="f969" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">但是我们不仅可以在Node.js中使用它，还可以在浏览器中使用它，为此，我在项目的根目录中创建了一个index.html，它导入并执行我们用WebAssembly编译的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9c9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我推荐工具<em class="nc"> serve </em>。可以用NPM: <code class="fe mo mp mq mr b">npm install -g serve</code>安装。您应该立即使用Serve或替代产品。如果在没有实际服务器的浏览器中打开HTML文件，导入WebAssembly时可能会出现问题。</p><p id="57cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以运行<code class="fe mo mp mq mr b">serve -s .</code>,当在端口5000上打开本地主机时，应该会在浏览器中看到我们的index.html——在控制台中，der应该是5 printed，因为我们调用了add-function。</p><h1 id="8231" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">与TypeScript的主要区别是什么？</h1><p id="c843" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">TypeScript扩展了JavaScript —这是显而易见的。顾名思义，它提供了我们在声明变量、参数等时可以使用的类型。<br/>重点是<strong class="kx ir"> <em class="nc">我们可以</em></strong>——因为我们不必在TypeScript中使用类型。</p><p id="498b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重点是TypeScript编译成JavaScript。但是AssemblyScript编译成WebAssembly。对于许多与系统关系更密切的编程语言，如C、C++或Rust，很明显它们是严格类型化的。AssemblyScript也是如此。我们必须使用特定的类型。<br/>TS的<em class="nc"> any </em>型不可用。</p><p id="0ca4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类型本身也不一样。与许多其他编程语言不同，TypeScript只有几种类型。AssemblyScript提供了许多类型，这导致了您可能已经注意到的这些神秘的名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/257d0dff5ce299ac8577b41ed2ec14bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zbVBwYqxOlZuBGGeGTi9A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae ng" href="https://www.assemblyscript.org/types.html#type-rules" rel="noopener ugc nofollow" target="_blank">The official documentation</a></figcaption></figure><p id="39ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nc"> i </em>表示它是一个整数。这个数字表示这个变量有多少内存可用。无符号意味着数值不能为负。有符号意味着它可以是负数。</p><h1 id="9b7f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">表演</h1><p id="7060" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">像无符号整数这样的东西不是你自愿处理的——这样做有什么好处呢？表演。这通常是WebAssembly的商标。</p><p id="a8df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用AssemblyScript，我们还可以根据应用程序显著加快代码的执行。这里有一个例子。</p><p id="e254" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我用AssemblyScript和JavaScript实现了下面的函数。它获取一个数字作为参数，并测试这个数字是否是一个质数。</p><p id="066f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是JavaScript中的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5d47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">AssemblyScript中的相同函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4e2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在函数上释放一个For循环。多亏了<em class="nc"> Date.now() </em>我们可以测量函数检查for循环中的所有数字需要多长时间。</p><p id="a294" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是JavaScript函数的外观。要测试WebAssembly函数，我们只需从index.ts导入该函数，如上所示。然后我们可以调整For循环中的函数调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1a8c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Date.now()输出的毫秒数越低，代码运行得越快。这两个功能我都测试过几次——web assembly更快。</p><p id="dafc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">平均而言，JavaScript函数几乎花费了10.3秒。<br/>assembly script函数只用了8.2秒。</strong></p><p id="f13a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个明显的区别——当然，区别取决于应用程序。</p></div></div>    
</body>
</html>