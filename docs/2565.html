<html>
<head>
<title>Decoding JavaScript context behavior</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解码JavaScript上下文行为</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/decoding-the-behaviour-of-the-javascript-context-88ceba445f54?source=collection_archive---------12-----------------------#2020-07-05">https://javascript.plainenglish.io/decoding-the-behaviour-of-the-javascript-context-88ceba445f54?source=collection_archive---------12-----------------------#2020-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/df7bc26156ec2ab6ffcc728b7b435a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sg51HuYkjI2ohhFG9CuEwQ.jpeg"/></div></div></figure><p id="e76a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript中最重要的两样东西是函数和对象。对象几乎是JavaScript语言的组成部分。JavaScript中的任何东西，从类到函数，除了原语；本质上归结为运行时的JavaScript对象。</p><p id="cf00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">语言中所有面向对象的属性都是通过对象来实现的，比如通过使用原型来继承等等。另一方面，函数是典型JavaScript代码的主要构造，可以根据您的需求做多种事情。</p><p id="2082" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这两个主题中，有一点是最重要的，也是最难理解的，那就是它们内部的背景的性质。在我们的JavaScript代码中，由<strong class="jx io"> this </strong>关键字表示的上下文在不同的场景中显示出非常矛盾的结果，与其他面向对象的编程语言(如Java)不同，您无法做出确定的预测。</p><p id="eb86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好地了解这种不可预测的性质，请参考下面的四个代码块，并尝试在您的控制台中运行。这些程序的输出也在下面给出。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/fe0b9bd70c4821da2e0bb50de6187662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Payvjd85Zxm6PeIn2sxX3w.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Code example 1</figcaption></figure><pre class="ku kv kw kx gt lc ld le lf aw lg bi"><span id="f629" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">// Output for code block 1</strong><br/>Object [global] {<br/>   global: [Circular],<br/>   clearInterval: [Function: clearInterval],<br/>   clearTimeout: [Function: clearTimeout],<br/>   setInterval: [Function: setInterval],<br/>   setTimeout: [Function: setTimeout] {     <br/>    [Symbol(util.promisify.custom)]: [Function] },<br/>     queueMicrotask: [Function: queueMicrotask],<br/>     clearImmediate: [Function: clearImmediate],<br/>     setImmediate: [Function: setImmediate] {<br/>    [Symbol(util.promisify.custom)]: [Function]<br/>  },<br/> name: ‘abc’<br/>}</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/3db52d64858db0ea79d526a703615246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0c4DqWXK9OVQCn8Po4beg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Code example 2</figcaption></figure><pre class="ku kv kw kx gt lc ld le lf aw lg bi"><span id="c71a" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">// Output for code block 2</strong><br/>f { name: ‘abc’ }</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/44ecd74de2be91db3cc211f2dad43dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNK7goq1fosrvxpN4S7L1A.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Code example 3</figcaption></figure><pre class="ku kv kw kx gt lc ld le lf aw lg bi"><span id="d40c" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">// Output for code block 3</strong><br/>{ f: [Function: f], name: ‘abc’ }</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/e4e1448d0dc0d0a2c06649471e4b6fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPxTnVZ9VIAGNOJ4H-M2lQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Code example 4</figcaption></figure><pre class="ku kv kw kx gt lc ld le lf aw lg bi"><span id="33aa" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">// Output for code block 4</strong><br/>Object [global] {<br/>   global: [Circular],<br/>   clearInterval: [Function: clearInterval],<br/>   clearTimeout: [Function: clearTimeout],<br/>   setInterval: [Function: setInterval],<br/>   setTimeout: [Function: setTimeout] {     <br/>    [Symbol(util.promisify.custom)]: [Function] },<br/>     queueMicrotask: [Function: queueMicrotask],<br/>     clearImmediate: [Function: clearImmediate],<br/>     setImmediate: [Function: setImmediate] {<br/>    [Symbol(util.promisify.custom)]: [Function]<br/>  },<br/> name: ‘abc’<br/>}</span></pre><p id="ba23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，有一个非常简单的函数，它捕捉上下文，分配一个新的属性，然后返回上下文。</p><p id="a221" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是当从同一个函数返回时，它们返回的上下文是非常不可预测的。这是因为JavaScript在本质上不是静态的上下文中工作。</p><p id="3029" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与Java等语言中上下文是静态的不同，JavaScript严重依赖于其运行时或脚本中函数的调用点来确定执行实例的上下文。从调用该函数的地方，它简单地获取该对象的上下文并对其进行操作。</p><p id="3ba6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好地理解它，让我们假设背景是你目前所在的房间。房间里有很多东西，比如桌子，椅子，你的包，你的手机。我们会将它们视为房间的不同属性。制造它们的材料就是它的价值。</p><p id="1b57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们的上下文看起来像一个有价值的财产表，木头，椅子，铁等等。当你使用像java这样的静态上下文的编程语言时，这个空间是不能改变的。因此，当你称之为财物袋时，你是在说那个房间里的袋子。但是对于像JavaScript或Self这样具有动态上下文的语言来说，这个空间可以有一些开箱即用的变化。</p><p id="8a6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们知道JavaScript函数内部的上下文依赖于它的调用范围，理解上面的例子变得非常容易。</p><p id="0ef9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第一个例子中，从调用函数的地方没有任何东西，函数位于全局范围内。因此，由函数调用获得的上下文是全局上下文对象，并为其分配一个名称属性。</p><p id="f13d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于第三个示例，从对象obj调用该函数。因此，它简单地选择它的上下文，因此控制台日志打印具有函数<strong class="jx io"> f </strong>和新分配的属性<strong class="jx io">名称的上下文。</strong>然而，对于第四个例子，调用点还是全局的，因为我们已经从对象中提取出了函数。现在，它将再次拾起全球背景。</p><p id="3aec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个例子有些什么不同。这是一个典型的例子，使用new关键字将常规函数作为构造函数执行。这种功能在Java等其他面向对象语言中很少见。然而，它继承了Java的行为，并从中创建了一个新的对象。因此，返回的上下文是一个只有一个属性<strong class="jx io">名的新对象。</strong></p><h2 id="d39e" class="lh li in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated"><strong class="ak">箭头函数内上下文的性质</strong></h2><p id="6045" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">为了理解arrow函数中上下文的工作原理，让我们借助一个例子直接将其与传统函数进行比较。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/071d190ef2676b1f16cad53827b87b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUChfSa6-_twek_ZRj6NFw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">code exmple 5</figcaption></figure><p id="b534" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述代码将输出以下内容。</p><pre class="ku kv kw kx gt lc ld le lf aw lg bi"><span id="ca9e" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">// output code example 5</strong><br/>undefined is a friend of abc<br/>undefined is a friend of pqr</span></pre><p id="1b38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这确实出乎意料，因为我们对传统函数的理解是，函数solve中的<strong class="jx io">名</strong>应该取自我们调用该函数的对象obj。</p><p id="0f0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这里的情况不是这样，因为map方法中的函数有不同的调用范围。Map是JavaScript数组中给定函数，它接受一个函数作为其参数。您真的不知道是谁在调用那个函数，如果调用对象有自己的name属性就更糟了。</p><p id="28b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是为什么我们在那个地方期待字符串“xyz”时，却得到了未定义的结果。这是arrow函数解决的经典问题。现在让我们看另一个例子，这里的传统函数被一个箭头函数代替，看看结果。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/11d65e2dba0c205774fefcc64f5b8af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HKu6Fssi0RXgJwGygytpA.png"/></div></div></figure><p id="211c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代码的输出如下所示。</p><pre class="ku kv kw kx gt lc ld le lf aw lg bi"><span id="540d" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">// output code example 6<br/></strong>xyz depends on abc<br/>xyz depends on pqr</span></pre><p id="9fa8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们所预料的。这是因为arrow函数中的上下文只不过是在它的作用域之外找到的上下文。无论arrow函数在它的块范围之外找到什么，它都将其作为上下文。因此，在示例中，map内部的函数将对象放在它的作用域之外，并找到了所需的name属性。</p><h2 id="f7d7" class="lh li in bd ln lo lp dn lq lr ls dp lt kg lu lv lw kk lx ly lz ko ma mb mc md bi translated"><strong class="ak">结论</strong></h2><p id="8ff3" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">函数内部的JavaScript上下文是不可预测的，因为它是动态的。函数的调用范围主要决定它将选取哪个上下文。然而，在arrow函数的情况下，它更容易预测，因为它选择了在它的函数范围之外找到的上下文。</p></div></div>    
</body>
</html>