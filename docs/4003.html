<html>
<head>
<title>Angular Change Detection Strategy — onPush and Default Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度变化检测策略— onPush和默认策略</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-change-detection-strategy-onpush-and-default-strategy-edd8d41ba9ef?source=collection_archive---------0-----------------------#2020-11-10">https://javascript.plainenglish.io/angular-change-detection-strategy-onpush-and-default-strategy-edd8d41ba9ef?source=collection_archive---------0-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce9a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Angular中的onPush和默认变化检测策略。</h2></div><p id="dbd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TechnoFunnel提供了另一篇关于<strong class="kh ir">角度变化检测策略</strong>的文章。Angular中有两种变化检测策略(<strong class="kh ir">默认和onPush </strong>)。我们将寻找使用这些策略的优点和缺点。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/d663dd896d5bd55a4c95cacef9b501c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*rSKBwKMVP_P8Uw0_AgsamA.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Angular Change Detection Strategies (onPush and Default)</figcaption></figure><h1 id="aa56" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">什么是角度变化检测？</h1><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Change Detection in Angular</figcaption></figure><p id="8928" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">角度变化检测负责使组件动态化。在变化检测周期中，Angular寻找所有的绑定，重新执行所有的表达式，将其与以前的值进行比较，如果检测到变化，它将把变化传播到DOM元素。</p><p id="9111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">角度变化检测</strong>在以下情况下执行:</p><ol class=""><li id="6b87" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">角度状态变量有更新</li><li id="d175" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">在角度组件内部调用事件</li><li id="017c" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">组件的@输入值已更新</li></ol><h1 id="6b9c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Angular中的变化检测策略是什么？</h1><p id="c456" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated"><strong class="kh ir">角度变化检测策略</strong>是跟踪组件更新并触发组件重新渲染的方法。角度主要有<strong class="kh ir"> 2种变化检测策略。我们可以为装饰器内部的组件配置变更检测策略。</strong></p><ol class=""><li id="6275" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">默认策略</li><li id="784b" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">onPush策略</li></ol><h2 id="830d" class="na lo iq bd lp nb nc dn lt nd ne dp lx ko nf ng lz ks nh ni mb kw nj nk md nl bi translated"><strong class="ak">默认变化检测策略</strong></h2><p id="29bf" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">默认的更改检测策略在组件创建时应用于组件。如果未配置组件策略，它将被标记为默认策略。在这种策略中，变更检测周期在组件内部发生的每一个事件上运行。</p><ol class=""><li id="398f" class="mh mi iq kh b ki kj kl km ko mj ks mk kw ml la mm mn mo mp bi translated">元素的点击事件</li><li id="4302" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">通过异步调用接收数据</li><li id="faff" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la mm mn mo mp bi translated">触发setTimeout和setInterval</li></ol><p id="2d0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们寻找与这种默认变更检测策略相关的问题:</p><p id="9f16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面给出了两个组件:ParentComponent和ChildComponent。父组件包含一个属性“<strong class="kh ir"> counter </strong>”，每次用户单击按钮时都会更新该属性。每次“计数器”的值更新时，组件都会重新呈现。该组件还包含一个子组件。子组件独立于“<strong class="kh ir">计数器</strong>”数据，因为我们没有使用@Input将数据传递给子组件。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nm mg l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae nn" href="https://gist.github.com/Mayankgupta688/188168fc729b86d973af0db80d534925" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/188168fc729b86d973af0db80d534925</a></figcaption></figure><p id="9e3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看ChildComponent的实现，ChildComponent是一个静态组件，它不会对父数据的更改产生任何影响。即使父组件的计数器值更新，子组件的视图也应该保持不变。在下面的组件中，我们没有在@Component装饰器中提供任何策略。默认配置为“<strong class="kh ir">默认变化检测策略</strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nm mg l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae nn" href="https://gist.github.com/Mayankgupta688/a96ed64f0150493388981e4caee00245" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/a96ed64f0150493388981e4caee00245</a></figcaption></figure><p id="2c55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir">默认变化检测策略</strong>中，每当我们更新ParentComponent中的计数器时，ChildComponent生命周期也被触发重新渲染，即使计数器的变化对子组件的视图没有影响，这个子组件也被重新渲染。子组件独立于父组件的数据。</p><p id="eec7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，每次子组件渲染时，它的控制台都会记录消息“App Rerendered”。每当我们在控制台窗口中看到该消息时，这意味着子组件也正在被重新呈现。您可以查找下面给出的在线编辑器链接，以测试默认变更检测策略的行为。</p><div class="no np gp gr nq nr"><a href="https://stackblitz.com/edit/default-change-detection-strategy?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">默认-更改-检测-策略-堆栈</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">导出到Angular CLI的Angular应用程序的启动项目</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">stackblitz.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of lh nr"/></div></div></a></div><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="og mg l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae nn" href="https://codesandbox.io/s/default-change-detection-strategy-cspjl?file=/src/main.ts" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/default-change-detection-strategy-cspjl?file=/src/main.ts</a></figcaption></figure><p id="2fa9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<strong class="kh ir">默认策略的性能较差</strong>，因为即使没有影响，子组件也需要额外的渲染周期。</p><h1 id="0550" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">onPush变化检测策略</h1><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oh mg l"/></div></figure><p id="e87f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决上述问题，我们采用了“<strong class="kh ir">on push</strong>”<strong class="kh ir">检测策略</strong>。在这个变化检测策略中，子组件并不总是被脏检查，如果父元素正在更新没有作为“@Input”属性传递给子组件的值，那么子组件不应该被脏检查。</p><h2 id="b9ff" class="na lo iq bd lp nb nc dn lt nd ne dp lx ko nf ng lz ks nh ni mb kw nj nk md nl bi translated">onPush更改检测的优势</h2><ul class=""><li id="f267" class="mh mi iq kh b ki mv kl mw ko oi ks oj kw ok la ol mn mo mp bi translated">在子组件中没有不必要的脏检查</li><li id="f29e" class="mh mi iq kh b ki mq kl mr ko ms ks mt kw mu la ol mn mo mp bi translated">更快的组件重新渲染</li></ul><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nm mg l"/></div></figure><p id="d98d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们更新了子组件的变更检测策略。由于更改检测策略更新为OnPush，因此如果父组件的属性更新，组件将不会刷新/重新呈现。在上面的代码中，因为我们没有更新任何@Input属性，所以组件不会重新呈现，这样性能会更好。</p><h2 id="e13a" class="na lo iq bd lp nb nc dn lt nd ne dp lx ko nf ng lz ks nh ni mb kw nj nk md nl bi translated">小心对象变异:</h2><p id="c7bd" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">作为@Input属性接收的对象不应该变异。当从父组件接收@Input对象时，它作为引用被接收。如果原始对象是从父元素变异而来的，则引用不会在子组件中更新，因此@Input组件不会接收新的引用，也不会被更新，因为@Input属性中的对象仍然是相同的(引用)。</p><p id="a0cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，没有机制可以通知子组件@Input的一个属性已经更新。我们应该用更新的属性创建一个新的对象，这样@Input属性的引用就会更新，子组件会得到组件更新的通知，从而重新呈现组件。</p><div class="no np gp gr nq nr"><a href="https://stackblitz.com/edit/onpush-change-detection-strategy?file=src/main.ts" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">onpush-change-detection-strategy-stack blitz</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">导出到Angular CLI的Angular应用程序的启动项目</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">stackblitz.com</p></div></div><div class="oa l"><div class="om l oc od oe oa of lh nr"/></div></div></a></div><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="og mg l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae nn" href="https://codesandbox.io/s/onpush-change-detection-strategy-rlxhf" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/onpush-change-detection-strategy-rlxhf</a></figcaption></figure><p id="c1d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">OnPush策略的实现参考上面的代码。</p><h2 id="94b7" class="na lo iq bd lp nb nc dn lt nd ne dp lx ko nf ng lz ks nh ni mb kw nj nk md nl bi translated">进一步阅读</h2><div class="no np gp gr nq nr"><a href="https://plainenglish.io/blog/create-an-employee-satisfaction-survey-using-angular-and-store-results-in-a-mongodb-collection" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">使用Angular创建员工满意度调查，并将结果存储在MongoDB集合中</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">一步一步的教程来建立一个员工满意度调查使用Angular和SurveyJS，一个免费的，开源的…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">简明英语. io</p></div></div><div class="oa l"><div class="on l oc od oe oa of lh nr"/></div></div></a></div><p id="e409" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oo">更多内容请看</em><a class="ae nn" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oo">plain English . io</em></strong></a><em class="oo">。报名参加我们的</em> <a class="ae nn" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="oo">免费周报</em> </strong> </a> <em class="oo">。关注我们关于</em><a class="ae nn" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oo">Twitter</em></strong></a><a class="ae nn" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oo">LinkedIn</em></strong></a><em class="oo"/><a class="ae nn" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oo">YouTube</em></strong></a><em class="oo"/><a class="ae nn" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="oo">不和</em> </strong> </a> <strong class="kh ir"> <em class="oo">。</em>T49】</strong></p><p id="5399" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="oo">对缩放您的软件启动感兴趣</em> </strong> <em class="oo">？检查</em> <a class="ae nn" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="oo">电路</em> </strong> </a> <em class="oo">。</em></p></div></div>    
</body>
</html>