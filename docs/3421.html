<html>
<head>
<title>How to Use ES Modules in Browsers with import-maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在带有导入映射的浏览器中使用ES模块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-es-modules-in-browsers-with-import-maps-b1bcccbd58bf?source=collection_archive---------12-----------------------#2020-09-27">https://javascript.plainenglish.io/using-es-modules-in-browsers-with-import-maps-b1bcccbd58bf?source=collection_archive---------12-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0fe857dae9cb03ebc5c51475eb9f40ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OqxONnK23RYk2Z1F"/></div></div></figure><h1 id="f2c7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="c34e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">ES模块很久以来一直是JavaScript社区的话题。他们的主要目标是为JavaScript的模块系统带来一个官方的标准化。当某种东西成为JavaScript中的标准时，涉及到两个主要步骤。首先，规范必须由EcmaScript，<a class="ae lu" href="http://www.ecma-international.org/ecma-262/6.0/index.html" rel="noopener ugc nofollow" target="_blank">批准并最终确定，这已经完成</a>。其次，浏览器应该开始实现它。这一步有点耗时，并且伴随着向后兼容性的所有麻烦。</p><p id="c175" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">好消息是浏览器对ES模块的支持有了很大的进步。下图显示了包括Edge、Chrome、Safari和Firefox (+60)在内的所有主流浏览器都支持ES模块:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d4c496d115df4f242e82550a5318ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OFwzkRkzGFKnkPZ6"/></div></div></figure><p id="9fde" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">说到模块，已经有几次尝试将这种功能引入JavaScript世界。例如:</p><ul class=""><li id="783e" class="me mf iq ky b kz lv ld lw lh mg ll mh lp mi lt mj mk ml mm bi translated">Node.js实现了自己的模块系统</li><li id="6814" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated">捆绑器和构建工具，如Webpack、Babel和Browserify验证集成模块的使用</li></ul><p id="44d4" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以通过这些努力，很少有模块定义被实现。两种较少使用的方法是:</p><ul class=""><li id="1830" class="me mf iq ky b kz lv ld lw lh mg ll mh lp mi lt mj mk ml mm bi translated"><a class="ae lu" href="https://requirejs.org/docs/whyamd.html" rel="noopener ugc nofollow" target="_blank"> AMD </a>或异步模块定义</li><li id="99ad" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated"><a class="ae lu" href="https://github.com/umdjs/umd" rel="noopener ugc nofollow" target="_blank"> UMD </a>或通用模块定义</li></ul><p id="fb6a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然而，最主要的是:</p><ul class=""><li id="872f" class="me mf iq ky b kz lv ld lw lh mg ll mh lp mi lt mj mk ml mm bi translated"><a class="ae lu" href="https://nodejs.org/docs/latest/api/modules.html" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>是模块的Node.js实现</li><li id="7201" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated">ES模块，它是本地JavaScript定义模块的标准</li></ul><p id="ee49" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">有几件事我们不会在本文中讨论:</p><ul class=""><li id="bba6" class="me mf iq ky b kz lv ld lw lh mg ll mh lp mi lt mj mk ml mm bi translated">我们不会关注CommonJS，除非它对ES模块有直接的功能。如果你有兴趣进一步了解这个模块系统，请阅读<a class="ae lu" href="https://blog.risingstack.com/node-js-at-scale-module-system-commonjs-require/" rel="noopener ugc nofollow" target="_blank">这篇文章</a></li><li id="ba79" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated">尽管Node上支持es模块，但本文主要关注的是浏览器中ES模块的使用。如果你有兴趣了解更多关于节点中ES模块支持的信息，我推荐这篇<a class="ae lu" href="https://nodejs.org/api/esm.html#esm_ecmascript_modules" rel="noopener ugc nofollow" target="_blank">官方文档</a>，以及<a class="ae lu" href="https://blog.logrocket.com/es-modules-in-node-today/" rel="noopener ugc nofollow" target="_blank">这篇</a>和<a class="ae lu" href="https://blog.logrocket.com/es-modules-in-node-js-12-from-experimental-to-release/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章</li></ul><h1 id="ea52" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么我们甚至需要ES模块？</h1><p id="0069" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要回答这个问题，我们需要追溯JavaScript的基础知识。在JavaScript中，像许多其他编程语言一样，我们的重点很大一部分是构建、管理和使用变量和函数。您可以将这些视为构建块，它们将一起用于形成向用户交付最终结果的逻辑序列。然而，随着变量、函数和包含它们的文件数量的增加，维护它们的重要性也在增加。例如，您不能让变量的更改意外地影响代码的其他不相关部分，即使它们共享相同的名称。</p><p id="df65" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在文件级，我们已经解决了这个问题。您可以使用变量和函数，但也不能在函数范围之外访问和操作变量。如果你需要一个不同函数共享的公共变量，你可以把它放在文件的顶部，这样所有的函数都可以访问它。下面的代码演示了这一点:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="4c58" class="mx jz iq mt b gy my mz l na nb">// file.js</span><span id="3ed2" class="mx jz iq mt b gy nc mz l na nb">var foo = "I'm global";<br/>var bar = "So am I";</span><span id="2ae4" class="mx jz iq mt b gy nc mz l na nb">function () {<br/>    var foo = "I'm local, the previous 'foo' didn't notice a thing";<br/>    var baz = "I'm local, too";</span><span id="e17e" class="mx jz iq mt b gy nc mz l na nb">    function () {<br/>        var foo = "I'm even more local, all three 'foos' have different values";<br/>        baz = "I just changed 'baz' one scope higher, but it's still not global";<br/>        bar = "I just changed the global 'bar' variable";<br/>        xyz = "I just created a new global variable";<br/>    }<br/>}</span></pre><p id="b3f3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是在不同的文件之间有这样的机制呢？</p><p id="5220" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">嗯，作为第一次尝试，你可能想做一些类似的事情。假设您的代码库中有几个文件需要访问某种类型的库。这个库，像<a class="ae lu" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>，可以是帮助你开发工作流的助手函数的选择。在这种情况下，您需要将库实例放在所有可能需要它的文件都可以访问的地方。处理这个问题的最初步骤之一是将库放在一个全局脚本中。现在您可能会想，既然这些全局脚本是在所有其他文件都可以访问的入口文件中实例化的，那么共享对某些功能或库的访问权的问题就会变得更容易，对吗？不完全是。</p><p id="a2db" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这种方法存在某些问题。不同文件和共享库之间的依赖将变得很重要。如果文件和库的数量增加，这将变得令人头疼，因为您必须始终注意脚本文件的顺序，这是处理依赖关系管理的一种隐含方式。以下面的代码为例:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="f76d" class="mx jz iq mt b gy my mz l na nb">&lt;script src="index1.js"&gt;&lt;/script&gt;<br/>&lt;script src="index2.js"&gt;&lt;/script&gt;<br/>&lt;script src="main.js"&gt;&lt;/script&gt;</span></pre><p id="8125" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在上面显示的代码中，如果您在引用了来自<code class="fe nd ne nf mt b">index2.js</code>的某些内容的<code class="fe nd ne nf mt b">index1.js</code>文件中添加了一些功能，这些功能将不会工作，因为代码执行流在那个时间点还没有到达<code class="fe nd ne nf mt b">index.2</code>。除了这种依赖性管理之外，在使用脚本标签作为共享功能的方式时，还有其他类型的问题，例如:</p><ul class=""><li id="f894" class="me mf iq ky b kz lv ld lw lh mg ll mh lp mi lt mj mk ml mm bi translated">由于每个请求阻塞线程，处理时间变慢</li><li id="8fad" class="me mf iq ky b kz mn ld mo lh mp ll mq lp mr lt mj mk ml mm bi translated">每个脚本启动一个新的HTTP请求时的性能问题</li></ul><p id="cf23" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">你可以想象重构和维护依赖于这种设计的代码是有问题的。每次你想做改变的时候，你都要担心不要破坏其他任何以前的功能。这就是模块来拯救的地方。</p><p id="745a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><a class="ae lu" href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener ugc nofollow" target="_blank"> ES模块，或者一般来说，模块</a>被定义为一组变量和函数，它们被组合在一起并被绑定到一个模块范围。这意味着可以在同一个模块中引用变量，但是也可以显式地导出和导入其他模块。有了这样的架构，如果某个模块被删除，导致部分代码中断，您将能够理解是什么导致了这个问题。</p><p id="c36c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如前所述，已经有过几次将模块设计引入JavaScript的尝试。但到目前为止，本机模块设计的最接近的概念是我们将在本文中研究的ES模块。</p><p id="9bdd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们将看到一些如何使用es模块的基本示例，然后探索在生产现场使用它们的可能性。我们还将看看一些可以帮助我们实现这一目标的工具。</p><h1 id="98f3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">浏览器中的ES模块</h1><p id="91e8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在浏览器中定义一个模块非常容易，因为我们可以访问HTML标签。向脚本标签传递一个<code class="fe nd ne nf mt b">type='module'</code>属性就足够了。当浏览器到达任何带有这个属性的脚本标签时，它知道这个脚本需要被解析为一个模块。它应该是这样的:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="016f" class="mx jz iq mt b gy my mz l na nb">// External Script<br/>&lt;script type="module" src="./index.js"&gt;&lt;/script&gt;</span><span id="bbde" class="mx jz iq mt b gy nc mz l na nb">// Inline Script<br/>&lt;script type="module"&gt;<br/>  import { main } from './index.js';<br/>  // ...<br/>&lt;/script&gt;</span></pre><p id="cf5a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这种情况下，浏览器将获取任何顶级脚本，并把它放在一个名为<code class="fe nd ne nf mt b">module map</code>的地方，并带有唯一的引用。这样，如果它遇到指向相同引用的另一个脚本，它就继续执行下一个脚本，因此每个模块只被解析一次。现在让我们想象一下<code class="fe nd ne nf mt b">index.js</code>的内容看起来是这样的:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="9f97" class="mx jz iq mt b gy my mz l na nb">// index.js<br/>import { something } from './something.js'</span><span id="d853" class="mx jz iq mt b gy nc mz l na nb">export const main = () =&gt; {<br/>  console.log('do something');<br/>}<br/>//..</span></pre><p id="7586" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">当我们查看这个文件时，我们看到了<code class="fe nd ne nf mt b">import</code>和<code class="fe nd ne nf mt b">export</code>语句，它们是使用和公开依赖关系的方式。因此，当浏览器完成获取和解析这些依赖项的异步之旅时，它只是从入口文件开始这个过程，在这种情况下，就是上面的HTML文件，然后继续将主脚本中所有嵌套模块的引用放到<code class="fe nd ne nf mt b">module map</code>中，直到它到达嵌套最多的模块。</p><p id="a5d5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">请记住，获取和解析模块只是在浏览器中加载模块的第一步。如果你有兴趣阅读更多关于下一步的细节，请仔细阅读这篇文章。</p><p id="907a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是对我们来说，我们试图阐明浏览器中ES模块使用的一个方面，即使用<code class="fe nd ne nf mt b"><a class="ae lu" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank">import-maps</a></code>来简化指定模块说明符的过程。</p><h1 id="37f6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么以及如何使用<code class="fe nd ne nf mt b">import-maps</code>？</h1><p id="309d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在加载模块的构建阶段，需要采取两个初始步骤。</p><p id="24fa" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">第一个是<a class="ae lu" href="https://www.codementor.io/@elliotaplant/understanding-javascript-module-resolution-systems-with-dinosaurs-il2oqro6e" rel="noopener ugc nofollow" target="_blank">模块解析</a>，它是关于确定从哪里下载模块。第二步是下载模块。这就是浏览器上下文和Node.js这样的上下文中的模块之间最大的区别之一。因为Node.js可以访问文件系统，所以它处理模块解析的方式与浏览器不同。这就是为什么您可以在Node.js上下文中看到这样的内容:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="16c6" class="mx jz iq mt b gy my mz l na nb">const _lodash = require('lodash');</span></pre><p id="048c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">此外，在使用Webpack等构建工具的浏览器环境中，您可以这样做:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="a5b5" class="mx jz iq mt b gy my mz l na nb">import * as _lodash from 'lodash';</span></pre><p id="ba9b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这个例子中，<code class="fe nd ne nf mt b">'lodash'</code>模块说明符对于Node.js进程是已知的，因为它可以访问<code class="fe nd ne nf mt b">filesystem</code>或者通过npm包管理器分发的包。但是浏览器只能接受模块指定符的URL，因为获取模块的唯一机制是通过网络下载它们。这种情况一直持续到一个叫做<code class="fe nd ne nf mt b">import-maps</code>的关于ES模块的新提议出台，以解决这个问题，并在浏览器和其他工具以及捆绑器中的模块使用之间带来更一致的外观和感觉。</p><p id="b4a3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以<code class="fe nd ne nf mt b">import-maps</code>定义了一个模块导入名称的映射，允许开发者提供<a class="ae lu" href="https://html.spec.whatwg.org/multipage/webappapis.html#resolve-a-module-specifier" rel="noopener ugc nofollow" target="_blank">类似于<code class="fe nd ne nf mt b">import "jquery"</code>的裸导入说明符</a>。如果您在当今的浏览器中使用这样的import语句，它将抛出，因为它们不被视为相对URL，而是被显式保留。让我们看看它是如何工作的。</p><p id="a9d2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">通过在脚本标签上提供属性<code class="fe nd ne nf mt b">type="importmap"</code>，您可以定义这个映射，然后定义一系列简单的导入名称和一个相对或绝对URL。请记住，如果您正在指定一个相对URL，如下例所示，那么该文件的位置应该是相对于定义了<code class="fe nd ne nf mt b">import-maps</code>的文件，在本例中是<code class="fe nd ne nf mt b">index.html</code>:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="5cd9" class="mx jz iq mt b gy my mz l na nb">// index.html</span><span id="a2ac" class="mx jz iq mt b gy nc mz l na nb">&lt;script type="importmap"&gt;<br/>{<br/>  "imports": {<br/>    "lodash": "/node_modules/lodash-es/lodash.js"<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="5166" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">定义这个映射后，您可以在代码中的任何地方直接导入<code class="fe nd ne nf mt b">lodash</code>:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="b6be" class="mx jz iq mt b gy my mz l na nb">import jQuery from 'jquery';</span></pre><p id="0e66" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是如果你没有使用<code class="fe nd ne nf mt b">import-maps</code>，你必须做一些类似下面显示的代码，这是很麻烦的，并且与今天用其他工具定义模块的方式不一致:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="be64" class="mx jz iq mt b gy my mz l na nb">import jQuery from "/node_modules/jQuery/index.js";</span></pre><p id="40c7" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以很明显，使用<code class="fe nd ne nf mt b">import-maps</code>有助于带来与今天模块使用方式的一致性。如果您习惯于在NodeJS或Webpack的上下文中要求或导入模块，那么一些基本的基础工作已经为您做好了。让我们探索其中的一些场景，看看它们是如何通过浏览器中的<code class="fe nd ne nf mt b">import-maps</code>来处理的。</p><p id="8bf7" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">您可能已经看到，在Node.js中使用模块说明符时，有时不带扩展名。例如:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="cbbf" class="mx jz iq mt b gy my mz l na nb">// requiring something.js file<br/>const something = require('something');</span></pre><p id="0b8e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是因为，在幕后，Node.js或其他类似的工具能够为您定义的模块说明符尝试不同的扩展，直到它们找到一个好的匹配。但是当在浏览器中使用ES模块时，这样的功能也可以通过<code class="fe nd ne nf mt b">import-maps</code>实现。这就是你应该如何定义<code class="fe nd ne nf mt b">import-maps</code>来实现这一点:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="4c59" class="mx jz iq mt b gy my mz l na nb">{<br/>  "imports": {<br/>    "lodash/map": "/node_modules/lodash/map.js"<br/>  }<br/>}</span></pre><p id="a3ad" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">正如您所看到的，我们定义了没有<code class="fe nd ne nf mt b">.js</code>扩展名的模块说明符的名称。这样，我们能够以两种方式导入模块:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="d6f1" class="mx jz iq mt b gy my mz l na nb">// Either this<br/>import map from "lodash/map"</span><span id="8b86" class="mx jz iq mt b gy nc mz l na nb">// Or<br/>import map from "lodash/map.js"</span></pre><p id="8f6c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">有人可能会说无扩展名文件导入有点不明确，这是有道理的。我个人更喜欢精确地定义文件扩展名，即使是在Node.js或Webpack上下文中定义模块说明符。此外，如果您想采用<code class="fe nd ne nf mt b">import-maps</code>的无扩展策略，您将会不知所措，因为您必须为包中的每个模块定义额外的无扩展模块说明符，而不仅仅是顶层文件。这很容易失去控制，并降低代码的一致性。</p><p id="e3b5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在通过npm分发的库和包中，包含几个可以导入到代码中的模块是很常见的。比如像<code class="fe nd ne nf mt b"><a class="ae lu" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">lodash</a></code>这样的包就包含了几个模块。有时您想导入顶层模块，有时您可能对包中的特定模块感兴趣。下面是您如何使用<code class="fe nd ne nf mt b">import-maps</code>来指定这样一个功能:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="6540" class="mx jz iq mt b gy my mz l na nb">{<br/>  "imports": {<br/>    "lodash": "/node_modules/lodash/lodash.js",<br/>    "lodash/": "/node_modules/lodash/"<br/>  }<br/>}</span></pre><p id="4d4b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">通过指定一个单独的模块说明符名称为<code class="fe nd ne nf mt b">lodash/</code>并在地址<code class="fe nd ne nf mt b">/node_modules/lodash/</code>中镜像相同的内容，您可以轻松地导入包中的特定模块，如下所示:</p><pre class="ma mb mc md gt ms mt mu mv aw mw bi"><span id="cc60" class="mx jz iq mt b gy my mz l na nb">// You can directly import lodash<br/>import _lodash from "lodash";</span><span id="bd5a" class="mx jz iq mt b gy nc mz l na nb">// or import a specific moodule<br/>import _shuffle from "lodash/shuffle.js";</span></pre><h1 id="81c4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="81cf" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文中，我们一起学习了ES模块。我们讨论了为什么模块是必不可少的，以及社区如何使用标准的方式来处理它们。</p><p id="3d1e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">当谈到今天在浏览器中使用es模块时，一系列问题浮现在脑海中，例如旧浏览器的兼容性、回退处理以及ES模块在bundler和build工具之后的真正位置。我强烈认为ES模块会继续存在，但是它们的存在并没有消除对捆绑器和构建器的需求，因为它们还有其他重要的用途，比如死代码消除、缩小和树抖动。正如我们已经知道的，Node.js等流行工具也在较新版本中采用ES模块。</p><p id="648c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">ES模块目前拥有广泛的浏览器支持。围绕es模块的一些特性，比如<code class="fe nd ne nf mt b"><a class="ae lu" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">dynamic import</a></code>(允许基于函数的导入)以及<code class="fe nd ne nf mt b"><a class="ae lu" href="https://github.com/tc39/proposal-import-meta" rel="noopener ugc nofollow" target="_blank">import.meta</a></code>(支持Node.js案例)现在是JavaScript规范的一部分。正如我们所探索的，<code class="fe nd ne nf mt b">import-maps</code>是另一个伟大的特性，它可以让我们消除Node.js和浏览器之间的差异。</p><p id="8632" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我可以充满信心地说，ES模块及其在JavaScript社区中的地位前景光明。</p><h1 id="06d1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">资源</h1><div class="ng nh gp gr ni nj"><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">ES模块:卡通深潜- Mozilla黑客-网络开发者博客</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">ES模块为JavaScript带来了一个官方的、标准化的模块系统。随着5月份Firefox 60的发布，所有…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">hacks.mozilla.org</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://github.com/WICG/import-maps" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">GitHub - WICG/import-maps:如何控制JavaScript导入的行为</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">如何控制JavaScript导入的行为？通过在…上创建帐户，为WICG/import-maps开发做出贡献</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jw nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://www.sitepoint.com/understanding-es6-modules/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">了解ES6模块-站点点</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">几乎每种语言都有模块的概念——一种将一个文件中声明的功能包含在另一个文件中的方法…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.sitepoint.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx jw nj"/></div></div></a></div><p id="d877" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><em class="oa">更多内容看</em> <a class="ae lu" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oa">说白了. io </em> </strong> </a> <strong class="ky ir"> <em class="oa">。</em> </strong> <em class="oa">报名参加我们的</em> <a class="ae lu" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="oa">免费每周简讯</em> </strong> </a> <strong class="ky ir"> <em class="oa">。</em> </strong></p></div></div>    
</body>
</html>