<html>
<head>
<title>Generators in JavaScript: When should I use yield, and yield*?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的生成器:什么时候应该使用yield，和yield*？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/generators-in-javascript-when-should-i-use-yield-and-yield-a5dbea6ad625?source=collection_archive---------4-----------------------#2020-08-26">https://javascript.plainenglish.io/generators-in-javascript-when-should-i-use-yield-and-yield-a5dbea6ad625?source=collection_archive---------4-----------------------#2020-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5757b1d4bfb00fca40498a833026e0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svZ2D_mxiAEqmtqX73eG2g.jpeg"/></div></div></figure><p id="1eb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使在ES6发布五年后，仍然有一些方面不是每个JavaScript开发人员都熟悉的。这些通常是日常代码中不使用的方面。那很好。但是，即使是看似无用的知识，实际上也从来不是无用的。这个无人知晓的ES6特性可能是一个让你头疼的棘手问题的完美解决方案。</p><p id="e159" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中一个功能是生成器。尽管功能非常强大，但生成器大多隐藏在有用的库中，很少在日常编程中使用。尽管如此，我们大多数人至少对关键字<code class="fe kw kx ky kz b">yield</code>有一个模糊的概念。<code class="fe kw kx ky kz b">yield*</code>能说那么多吗？</p><h1 id="f0fa" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">发电机</h1><p id="b63a" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><code class="fe kw kx ky kz b">yield</code>和<code class="fe kw kx ky kz b">yield*</code>这两个关键词，出现在生成器的语境中，在它之外是无法理解的。</p><p id="2d7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成器是一个可以产生一系列值的对象，但也可以像数组一样被迭代。更准确地说，生成器是实现迭代器和可迭代协议的对象。</p><p id="828d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具体地说，因为生成器是迭代器，我们可以这样做:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="9576" class="ml lb iq kz b gy mm mn l mo mp">const generator = ... // we will see later how to create a generator</span><span id="b5bf" class="ml lb iq kz b gy mq mn l mo mp">generator.next();<br/>generator.next();<br/>generator.next();<br/>generator.next();</span></pre><p id="e9ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为它们也是可重复的，我们可以这样做:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="8165" class="ml lb iq kz b gy mm mn l mo mp">const generator = ... // a bit of patience</span><span id="1a84" class="ml lb iq kz b gy mq mn l mo mp">for (const value of generator) {<br/>  // ...<br/>}</span></pre><p id="fa9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你可能已经从我漏掉的部分猜到的，<code class="fe kw kx ky kz b">yield</code>介入了一个发电机的创造。</p><h1 id="4f9d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">发电机功能</h1><p id="6c29" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">发生器是使用发生器函数创建的。使用<code class="fe kw kx ky kz b">function*</code>或<code class="fe kw kx ky kz b">function *</code>声明这些功能。</p><p id="be15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在生成器函数中，您定义了在生成器上调用<code class="fe kw kx ky kz b">next</code>函数时将要返回的值。为此，您可以使用关键字<code class="fe kw kx ky kz b">yield</code>:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="7ff0" class="ml lb iq kz b gy mm mn l mo mp">function* generatorFunction() {<br/>  yield 1;<br/>  yield 2;<br/>  yield 3;<br/>}</span><span id="8aea" class="ml lb iq kz b gy mq mn l mo mp">const generator = generatorFunction();</span><span id="83b7" class="ml lb iq kz b gy mq mn l mo mp">generator.next(); // { value: 1, done: false }<br/>generator.next(); // { value: 2, done: false }<br/>generator.next(); // { value: 3, done: false }<br/>generator.next(); // { value: undefined, done: true }</span></pre><p id="4f61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当调用<code class="fe kw kx ky kz b">next</code>方法时，生成器执行到下一个<code class="fe kw kx ky kz b">yield</code>表达式，并返回指定的值。</p><p id="9983" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">yield</code>其实是一条双行道。您还可以使用它来将<em class="mr">值传递给您的生成器。假设您想要一个生成器，它可以接收一些值作为输入，然后在每次调用<code class="fe kw kx ky kz b">next</code>方法时返回这个值。你可以这样使用<code class="fe kw kx ky kz b">yield</code>:</em></p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="13cd" class="ml lb iq kz b gy mm mn l mo mp">function* generatorFunction() {<br/>  const a = yield;</span><span id="0b78" class="ml lb iq kz b gy mq mn l mo mp">  while(true) {<br/>   yield a;<br/>  }<br/>}</span><span id="480b" class="ml lb iq kz b gy mq mn l mo mp">const generator = generatorFunction();</span><span id="a71a" class="ml lb iq kz b gy mq mn l mo mp">generator.next();<br/>generator.next(1); // { value: 1, done: false }<br/>generator.next(); // { value: 1, done: false }<br/>generator.next(); // { value: 1, done: false }</span></pre><p id="a0ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会觉得第一个电话很奇怪，但这不是一个错误。如前所述，当调用<code class="fe kw kx ky kz b">next</code>函数时，生成器一直执行到下一个<code class="fe kw kx ky kz b">yield</code>表达式。我们第一次在我们全新的发电机上调用它，它一直运行到第一个<code class="fe kw kx ky kz b">yield</code>，没有任何返回，所以在那里等待。第二次，我们用一个值调用它，它将变量<code class="fe kw kx ky kz b">a</code>初始化为这个值，并转到下一个<code class="fe kw kx ky kz b">yield</code>，在这里它返回<code class="fe kw kx ky kz b">a</code>，在我们的例子中是<code class="fe kw kx ky kz b">1</code>。对于之后的每次调用，它都会产生值<code class="fe kw kx ky kz b">a</code>。</p><h1 id="8bbf" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">产量*</h1><p id="fb89" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">那<code class="fe kw kx ky kz b">yield*</code>呢？<code class="fe kw kx ky kz b">yield*</code>也被用于生成器功能，但当然是为了实现一些不同的东西。</p><p id="7b3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您想要创建一个返回斐波那契数列的生成器。提醒一下，斐波那契数列的定义如下:</p><ul class=""><li id="0be4" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">第一个是0</li><li id="24f1" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">第二个是1</li><li id="ab16" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">之后的每一个数字都是前两个数字的和</li></ul><p id="98e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说:<code class="fe kw kx ky kz b">F(0) = 0; F(1) = 1; ... F(n) = F(n-1) + F(n-2);</code></p><p id="b713" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将如何创建一个生成这些值的生成器？你可能想递归地做这件事。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="1658" class="ml lb iq kz b gy mm mn l mo mp">function* fibonacciGeneratorFunction() {<br/>  yield 0;<br/>  yield 1;<br/>  ???<br/>}</span><span id="60bd" class="ml lb iq kz b gy mq mn l mo mp">const fibonacciGenerator = fibonacciGeneratorFunction();</span></pre><p id="41dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，我们希望在我们的生成器中产生另一个生成器的值。这就是<code class="fe kw kx ky kz b">yield*</code>的用武之地:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="ec30" class="ml lb iq kz b gy mm mn l mo mp">function* fibonacciGeneratorFunction(a = 0, b = 1) {<br/>  yield a;   <br/>  yield* fibonacciGeneratorFunction(b, b + a);<br/>}</span><span id="0acb" class="ml lb iq kz b gy mq mn l mo mp">const fibonacciGenerator = fibonacciGeneratorFunction();</span><span id="2214" class="ml lb iq kz b gy mq mn l mo mp">fibonacciGenerator.next(); // { value: 1, done: false }<br/>fibonacciGenerator.next(); // { value: 1, done: false }<br/>fibonacciGenerator.next(); // { value: 2, done: false }<br/>fibonacciGenerator.next(); // { value: 3, done: false }<br/>fibonacciGenerator.next(); // { value: 5, done: false }</span></pre><p id="71df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">yield*</code>不仅仅用于递归情况。它通常使您能够委托给另一个生成器。来自<a class="ae ng" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>的一个简单示例是:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="c3d7" class="ml lb iq kz b gy mm mn l mo mp">function* g1() {<br/>  yield 2;<br/>  yield 3;<br/>  yield 4;<br/>}<br/><br/>function* g2() {<br/>  yield 1;<br/>  yield* g1();<br/>  yield 5;<br/>}<br/><br/>const iterator = g2();<br/><br/>console.log(iterator.next()); // {value: 1, done: false}<br/>console.log(iterator.next()); // {value: 2, done: false}<br/>console.log(iterator.next()); // {value: 3, done: false}<br/>console.log(iterator.next()); // {value: 4, done: false}<br/>console.log(iterator.next()); // {value: 5, done: false}<br/>console.log(iterator.next()); // {value: undefined, done: true}</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="c0fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇文章揭开<code class="fe kw kx ky kz b">yield</code>和<code class="fe kw kx ky kz b">yield*</code>的神秘面纱。虽然两者都在生成器的上下文中使用，但是<code class="fe kw kx ky kz b">yield</code>和<code class="fe kw kx ky kz b">yield*</code>使您能够以不同的方式生成值。第一种允许您直接返回值或将它们提供给生成器。第二种方法允许您将值生成委托给另一个生成器。</p></div></div>    
</body>
</html>