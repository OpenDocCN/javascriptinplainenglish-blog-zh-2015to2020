<html>
<head>
<title>JavaScript’s Sort Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的排序方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascripts-sort-method-8f625fa4c20c?source=collection_archive---------7-----------------------#2019-11-06">https://javascript.plainenglish.io/javascripts-sort-method-8f625fa4c20c?source=collection_archive---------7-----------------------#2019-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8bd2214965ffbac774c420ac3ee1d91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgbUwHp6EgUjPBLzYvu6CQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Farm-fresh beans sorted by type/color</figcaption></figure><p id="e16b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在学JavaScript之前，我学过Ruby。Ruby有那种开箱即用的感觉。JavaScript有这样一个<em class="kx">,指令在哪里？</em>感觉。Ruby有非常方便的内置方法，这些方法使编码变得精彩，但也创造了一种情况，在这种情况下它们的功能可以被认为是理所当然的。最常见和最常用的内置方法之一(在许多语言中)是sort方法。自然如此。数据本质上是以集合的形式存储和组织的，通常需要以不同的方式对数据进行排序，以获得不同的输出。为了对数据数组进行排序，Ruby有直观的<code class="fe ky kz la lb b">sort()</code>方法和<code class="fe ky kz la lb b">sort_by()</code>方法。Javascript有:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="e041" class="lk ll in lb b gy lm ln l lo lp">Array.prototype.sort()</span></pre><p id="2f3d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">已经让人不安了，对吧？那么，让我们解决它。第一步是不要担心原型。它与从ethereal JS plain继承属性的数组对象本身有关，这个词通常不与方法调用一起使用，您可以在这里了解原型<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype" rel="noopener ugc nofollow" target="_blank"><em class="kx"/></a>。</p><p id="3a85" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">sort方法用于对<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">数组</a>进行排序。在JavaScript中，sort方法最擅长的是按字母顺序(默认情况下是升序)对字符串数组进行排序。像这样:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="7016" class="lk ll in lb b gy lm ln l lo lp">const beansArray = ['yellow', 'purple', 'speckled', 'green']</span><span id="a6af" class="lk ll in lb b gy lr ln l lo lp">beansArray.sort()</span><span id="4c28" class="lk ll in lb b gy lr ln l lo lp">console.log(beansArray)</span><span id="0eea" class="lk ll in lb b gy lr ln l lo lp">=&gt; ['green', 'purple', 'speckled', 'yellow']</span></pre><p id="a370" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这很好，但是为什么排序方法做得最好呢？为什么会有更多的欲望？sort方法将数组中的元素转换成字符串(在前面的例子中领先一步并大获全胜)，然后根据它们的<a class="ae lq" href="https://en.wikipedia.org/wiki/UTF-16" rel="noopener ugc nofollow" target="_blank"> UTF-16 </a>字符代码值依次比较每对相邻的元素。在按字母顺序排列的情况下，字符‘a’的值小于‘b’，因此被移动到前面的位置，而‘b’被移动到后面的位置。</p><p id="1df4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">其他数据类型呢？让我们尝试对一组数字进行排序。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="5bbc" class="lk ll in lb b gy lm ln l lo lp">const numbers = [1, 300, 5, 20, 40]</span><span id="9835" class="lk ll in lb b gy lr ln l lo lp">numbers.sort()</span><span id="2814" class="lk ll in lb b gy lr ln l lo lp">console.log(numbers)</span><span id="2df1" class="lk ll in lb b gy lr ln l lo lp">=&gt; [1, 20, 300, 40, 5]</span></pre><p id="72eb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里我们很快揭示了排序的局限性。上一个示例的结果没有按照预期的升序排列。由于数组的元素在比较之前被转换为字符串，<code class="fe ky kz la lb b">300</code>中的<code class="fe ky kz la lb b">3</code>将<code class="fe ky kz la lb b">300</code>放置在<code class="fe ky kz la lb b">20</code>和<code class="fe ky kz la lb b">40</code>之间。当对字符串以外的数据类型进行排序时，这不是一个可靠的方法。虽然一开始看起来有点不方便，但是这个问题的解决方案是有力量的:<em class="kx">回调</em>。</p><p id="c6b1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">回调是JavaScript不可或缺的。回调本质上是一个在执行时被另一个函数调用的函数。如何与<code class="fe ky kz la lb b">.sort()</code>一起使用是通过将一个定制的比较函数作为参数传递给排序方法，即回调。大概是这样的:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="39af" class="lk ll in lb b gy lm ln l lo lp">Array.sort(comparisonFunction(elementArg1, elementArg2))</span></pre><p id="dc1f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们来探讨一下比较函数的作用以及它是如何支持排序方法的。假设我们要对一个对象数组进行排序，每个对象有两个键值对，分别代表类型和数量。要按类型排序:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="da34" class="lk ll in lb b gy lm ln l lo lp">const beansArray = [<br/>  {type: 'yellow', qty: 200}, <br/>  {type: 'purple', qty: 30}, <br/>  {type: 'speckled', qty: 100}, <br/>  {type: 'green', qty: 4000}<br/>]</span><span id="0268" class="lk ll in lb b gy lr ln l lo lp">function compareType(a, b) {<br/>  if (a.type &gt; b.type) {<br/>    return 1<br/>  } else if (a.type &lt; b.type) {<br/>    return -1<br/>  } else {<br/>    return 0<br/>  }<br/>}</span><span id="5fd1" class="lk ll in lb b gy lr ln l lo lp">beansArray.sort(compareType)</span><span id="37c2" class="lk ll in lb b gy lr ln l lo lp">console.log(beansArray)</span><span id="205e" class="lk ll in lb b gy lr ln l lo lp">=&gt; [<br/>  {type: 'green', qty: 4000},<br/>  {type: 'purple', qty: 30}, <br/>  {type: 'speckled', qty: 100}, <br/>  {type: 'yellow', qty: 200}<br/>]</span></pre><p id="db2a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有用多了。由于回调函数<code class="fe ky kz la lb b">compareType</code>，这个数组的对象成功地按照每个对象的类型值按字母升序排序。假设理解了数组的语法、它包含的对象和基本的排序方法，让我们来理解一下<code class="fe ky kz la lb b">compareType</code>函数。当<code class="fe ky kz la lb b">.sort()</code>调用<code class="fe ky kz la lb b">compareType</code>时，它从<code class="fe ky kz la lb b">beansArray</code>获取元素对的顺序比较，并将它们作为两个参数传递。本案:<code class="fe ky kz la lb b">(a, b)</code>。在<code class="fe ky kz la lb b">compareType</code>函数中完成的工作是通过一个条件语句传递这些元素对。在这种情况下:一个<code class="fe ky kz la lb b">if/else if/else</code>语句。由于<code class="fe ky kz la lb b">a</code>和<code class="fe ky kz la lb b">b</code>代表对象，在这种情况下，要比较的查找值可以分别由<code class="fe ky kz la lb b">a.type</code>和<code class="fe ky kz la lb b">b.type</code>访问。根据对每个条件的评估，<code class="fe ky kz la lb b">compareType</code>将返回一个<code class="fe ky kz la lb b">-1</code>、<code class="fe ky kz la lb b">0</code>或<code class="fe ky kz la lb b">1</code>，并将其传递回排序方法。</p><ul class=""><li id="62d9" class="ls lt in kb b kc kd kg kh kk lu ko lv ks lw kw lx ly lz ma bi translated">当返回<code class="fe ky kz la lb b">-1</code>时(较小的值):<code class="fe ky kz la lb b">a</code>在<code class="fe ky kz la lb b">b</code>之前。</li><li id="cedd" class="ls lt in kb b kc mb kg mc kk md ko me ks mf kw lx ly lz ma bi translated">当<code class="fe ky kz la lb b">0</code>返回(相等值)时:<code class="fe ky kz la lb b">a</code>和<code class="fe ky kz la lb b">b</code>保持命令。</li><li id="fc3b" class="ls lt in kb b kc mb kg mc kk md ko me ks mf kw lx ly lz ma bi translated">当返回<code class="fe ky kz la lb b">1</code>时(较大值):<code class="fe ky kz la lb b">b</code>在<code class="fe ky kz la lb b">a</code>之前。</li></ul><p id="2c7c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此时，<code class="fe ky kz la lb b">.sort()</code>拿起滚轮，根据<code class="fe ky kz la lb b">compareType</code>函数的返回值对数组进行排序。有一种速记方法可以代替<code class="fe ky kz la lb b">if/else if/else statement</code>:</p><p id="5e90" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe ky kz la lb b">string.prototype.localeCompare()</code></p><p id="3094" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare" rel="noopener ugc nofollow" target="_blank">语言环境比较方法</a>比较一对字符串，并通过上面列出的逻辑确定它们的排序顺序。利用<code class="fe ky kz la lb b">.localeCompare()</code>和一些箭头函数简写，前面例子中带有比较回调的排序方法也可以写成这样:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="7f99" class="lk ll in lb b gy lm ln l lo lp">const beansArray = [<br/>  {type: 'yellow', qty: 200}, <br/>  {type: 'purple', qty: 30}, <br/>  {type: 'speckled', qty: 100}, <br/>  {type: 'green', qty: 4000}<br/>]</span><span id="9e39" class="lk ll in lb b gy lr ln l lo lp">beansArray.sort((a, b) =&gt; a.type.localeCompare(b.type))</span><span id="50c0" class="lk ll in lb b gy lr ln l lo lp">console.log(beansArray)</span><span id="9f0d" class="lk ll in lb b gy lr ln l lo lp">=&gt; [<br/>  {type: 'green', qty: 4000},<br/>  {type: 'purple', qty: 30}, <br/>  {type: 'speckled', qty: 100}, <br/>  {type: 'yellow', qty: 200}<br/>]</span><span id="9705" class="lk ll in lb b gy lr ln l lo lp">//Cool beans!</span></pre><p id="4b8a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">*请注意，虽然像</em> <code class="fe ky kz la lb b"><em class="kx">if/else</em></code> <em class="kx">语句这样的条件语句允许改变排序顺序(例如，降序而不是升序)，但语言环境比较方法通常会生成升序排序顺序。</em> <code class="fe ky kz la lb b"><em class="kx">.localeCompare()</em></code> <em class="kx">可以采取附加的、可选的自变量来确定其行为。或者，附加方法如</em> <code class="fe ky kz la lb b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" rel="noopener ugc nofollow" target="_blank"><em class="kx">.reverse()</em></a></code> <em class="kx">可以与</em> <code class="fe ky kz la lb b"><em class="kx">.localeCompare()</em></code> <em class="kx">链接。</em></p><p id="6b48" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">由于<code class="fe ky kz la lb b">.sort()</code>将值转换为字符串以便进行比较，所有J <a class="ae lq" href="https://javascript.info/types" rel="noopener ugc nofollow" target="_blank"> avaScript数据类型</a>都可以使用(有些有用，有些没用)。借助回调函数的力量，<code class="fe ky kz la lb b">.sort()</code>可以用来对对象数组、数组、嵌套对象、嵌套数组等进行排序。</p><p id="8f3e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当按数值排序时，sort方法的回调函数可以通过从第一个元素中减去比较对中的第二个元素来产生它的返回。这有效地复制了较小、相等或较大值标记的返回。让我们按数量对上一个示例中的数组进行排序:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="d527" class="lk ll in lb b gy lm ln l lo lp">const beansArray = [<br/>  {type: 'yellow', qty: 200}, <br/>  {type: 'purple', qty: 30}, <br/>  {type: 'speckled', qty: 100}, <br/>  {type: 'green', qty: 4000}<br/>]</span><span id="bbd2" class="lk ll in lb b gy lr ln l lo lp">beansArray.sort((a, b) =&gt; a.qty - b.qty) //ascending sort by default</span><span id="c787" class="lk ll in lb b gy lr ln l lo lp">//  sort sequence:</span><span id="d065" class="lk ll in lb b gy lr ln l lo lp">//  200 - 30 = 170 | positive (return 1) | b precedes a <br/>//  =&gt; 30, 200</span><span id="b7ea" class="lk ll in lb b gy lr ln l lo lp">//  200 - 100 = 100 | positive (return 1) | b precedes a<br/>//  =&gt; 30, 100, 200</span><span id="31f5" class="lk ll in lb b gy lr ln l lo lp">//  200 - 4000 = -3800 | negative (return -1) | a precedes b<br/>//  =&gt; 30, 100, 200, 4000</span><span id="1e28" class="lk ll in lb b gy lr ln l lo lp">console.log(beansArray)</span><span id="dd2f" class="lk ll in lb b gy lr ln l lo lp">=&gt; [<br/>  {type: 'purple', qty: 30}, <br/>  {type: 'speckled', qty: 100}, <br/>  {type: 'yellow', qty: 200},<br/>  {type: 'green', qty: 4000}<br/>]</span></pre><p id="eeff" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然可以对字符串或数字数组执行简单的排序，例如</p><p id="0219" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe ky kz la lb b">['c', 'a', 'b'].sort() returns ['a', 'b', 'c']</code></p><p id="7d8e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe ky kz la lb b">[2, 1, 3].sort((a, b) =&gt; a — b) returns [1, 2, 3]</code></p><p id="57d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">回调允许许多条件逻辑，这些条件逻辑可以通过多个属性对复杂对象的数组进行排序。最后一个例子，让我们假设前面例子中的<code class="fe ky kz la lb b">beansArray</code>有相同数量的不同类型。对象可以先按数量分类，然后再按类型分类:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="6eeb" class="lk ll in lb b gy lm ln l lo lp">const beansArray = [<br/>  {type: 'yellow', qty: 200},<br/>  {type: 'purple', qty: 200},<br/>  {type: 'speckled', qty: 100},<br/>  {type: 'green', qty: 4000}<br/>]</span><span id="633b" class="lk ll in lb b gy lr ln l lo lp">function compareQtyAndType(a, b) {<br/>  if (a.qty &gt; b.qty) return 1<br/>  if (a.qty &lt; b.qty) return -1<br/>  if (a.type &gt; b.type) return 1<br/>  if (a.type &lt; b.type) return -1<br/>}<br/>//note use of shorthand if statements</span><span id="31ef" class="lk ll in lb b gy lr ln l lo lp">beansArray.sort(compareQtyAndType)</span><span id="0563" class="lk ll in lb b gy lr ln l lo lp">console.log(beansArray)</span><span id="f2f1" class="lk ll in lb b gy lr ln l lo lp">const beansArray = [<br/>  {type: 'speckled', qty: 100},  <br/>  {type: 'purple', qty: 200},<br/>  {type: 'yellow', qty: 200},<br/>  {type: 'green', qty: 4000}<br/>]</span></pre><p id="d15d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe ky kz la lb b">compareQtyAndType</code>函数首先评估代表数量的值的比较。每个对象的排序位置根据返回的<code class="fe ky kz la lb b">1</code>或<code class="fe ky kz la lb b">-1</code>进行移动。如果值相等并且评估为返回<code class="fe ky kz la lb b">0</code>，则对象不会基于数量移动排序位置，而是基于表示类型的值进行比较评估，然后按字母顺序排序。</p></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><p id="8b48" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望这篇文章<em class="kx"> sort </em>能让你更好地理解JavaScript的排序方法，并激发你对其可能性的好奇心，或者至少让你更喜欢Ruby。</p><p id="313d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae lq" href="https://github.com/dangrammer" rel="noopener ugc nofollow" target="_blank">github.com/dangrammer</a>T8<a class="ae lq" href="https://www.linkedin.com/in/danieljromans/" rel="noopener ugc nofollow" target="_blank">linked.com/in/danieljromans</a>T11】T12】danromans.com</p></div></div>    
</body>
</html>