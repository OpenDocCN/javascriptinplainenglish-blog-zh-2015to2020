<html>
<head>
<title>How To Create a Dynamic AWS ECS Cluster With Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Terraform创建动态AWS ECS集群</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-dynamic-ecs-cluster-with-terraform-86d6b11d0db9?source=collection_archive---------0-----------------------#2020-11-17">https://javascript.plainenglish.io/how-to-create-a-dynamic-ecs-cluster-with-terraform-86d6b11d0db9?source=collection_archive---------0-----------------------#2020-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4c3b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可根据您的需求扩展的ECS群集</h2></div><p id="5108" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文旨在为如何使用Terraform开发动态ECS ( <a class="ae lb" href="https://aws.amazon.com/ecs/?whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc&amp;ecs-blogs.sort-by=item.additionalFields.createdDate&amp;ecs-blogs.sort-order=desc" rel="noopener ugc nofollow" target="_blank">弹性容器服务</a>)模块提供<strong class="kh ir">清晰的示例和说明</strong>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/c116b0786b0b758c2cd44076dbf77c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*ljl_9cEUM1I22abUDb0--A.png"/></div></figure><p id="f721" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“动态”是因为Terraform可以<strong class="kh ir">轻松</strong>扩展以处理更多需要的服务和任务。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/efb6c6f0d071bcf5125aaa523674b990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*s4A5dG6C7ntvKAMgVCzZZA.png"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">ECS Architecture (<a class="ae lb" href="https://aws.amazon.com/blogs/containers/developers-guide-to-using-amazon-efs-with-amazon-ecs-and-aws-fargate-part-1/" rel="noopener ugc nofollow" target="_blank">source</a>)</figcaption></figure><p id="fcf9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文假设对Terraform有一个基本的了解。如果你正在寻找一个项目向你介绍Terraform，<a class="ae lb" href="https://medium.com/python-in-plain-english/how-to-engineer-spotify-data-with-terraform-aws-fd80feb73b1b" rel="noopener">看看我的文章，这篇文章展示了如何建立一个<strong class="kh ir"> Spotify数据管道</strong> </a>。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="f14a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">0.建立工作关系网</h1><p id="4676" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">实际ECS群集的定义没有任何网络要求。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="aca9" class="my lx iq mu b gy mz na l nb nc">resource "aws_ecs_cluster" "cluster" {<br/>  name = "${var.environment}-cluster"<br/>  tags = var.tags<br/>}</span></pre><p id="2029" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为网络功能是在服务级别定义的，因为这些是托管任务的弹性组件。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">ECS overview</figcaption></figure><p id="a7db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的网络需求在<a class="ae lb" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecs_service" rel="noopener ugc nofollow" target="_blank">服务定义</a>中指定:</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="18e0" class="my lx iq mu b gy mz na l nb nc">resource "aws_ecs_service" "fargate-microservices" {<br/>  for_each      = var.create_microservices == true ? var.fargate_microservices : {}<br/>  name          = each.value["name"]<br/>  cluster       = aws_ecs_cluster.cluster.id<br/>  desired_count = each.value["desired_count"]<br/>  launch_type   = each.value["launch_type"]<br/>  depends_on = [aws_ecs_cluster.cluster,<br/>  aws_ecs_task_definition.ecs_tasks]<br/>  task_definition = each.value["task_definition"]<br/><br/>  network_configuration {<br/>    subnets         = var.ecs_service_subnets<br/>    security_groups = [aws_security_group.ecs_security_groups[each.value["security_group_mapping"]].id]<br/>  }<br/><br/>  lifecycle {<br/>    ignore_changes = [<br/>      task_definition<br/>    ]<br/>  }<br/>}</span></pre><p id="49a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有很多内容需要解释，我将从网络配置开始。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="716d" class="my lx iq mu b gy mz na l nb nc">network_configuration {<br/>    subnets         = var.ecs_service_subnets<br/>    security_groups = [aws_security_group.ecs_security_groups[each.value["security_group_mapping"]].id]<br/>  }</span></pre><p id="6850" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下,(私有)子网继承自定义VPC的模块，在创建动态集群时，我们只需参考VPC模块中的子网列表，以便将服务构建到所需的VPC中。</p><p id="a70b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安全组利用Terraform中的‘for _ each’函数，该函数支撑了该模块的许多机制。</p><h2 id="1cfa" class="my lx iq bd ly nf ng dn mc nh ni dp mg ko nj nk mi ks nl nm mk kw nn no mm np bi translated"><a class="ae lb" href="https://www.terraform.io/docs/configuration/resources.html#for_each-multiple-resource-instances-defined-by-a-map-or-set-of-strings" rel="noopener ugc nofollow" target="_blank"> for_each </a></h2><p id="52d6" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">这个功能允许我们构建共享相同参数的多个资源。该模块只需要在资源中定义for_each，然后将一个“map”变量传递给指定的参数。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="8bb3" class="my lx iq mu b gy mz na l nb nc">for_each      = var.create_microservices == true ? var.fargate_microservices : {}</span></pre><p id="a53c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们已经指定create_microservices必须为true，以便创建我们的服务。然后，fargate_microservices变量是一个映射，它包含我们的服务所需的所有参数(在“动态服务”一章中可以找到一个例子)。</p><h2 id="3347" class="my lx iq bd ly nf ng dn mc nh ni dp mg ko nj nk mi ks nl nm mk kw nn no mm np bi translated"><a class="ae lb" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">安全组</strong> </a></h2><p id="6d89" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">现在我们已经理解了for_each循环，下面是模块中的代码，它允许您定义任意数量的安全组。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="c20a" class="my lx iq mu b gy mz na l nb nc">resource "aws_security_group" "ecs_security_groups" {<br/>  vpc_id = var.vpc_id<br/><br/>  for_each = var.security_groups<br/>  name     = "${var.environment}-${each.value["ingress_port"]}"<br/><br/>  ingress {<br/>    from_port   = each.value["ingress_port"]<br/>    to_port     = each.value["ingress_port"]<br/>    protocol    = each.value["ingress_protocol"]<br/>    cidr_blocks = each.value["ingress_cidr_blocks"]<br/>  }<br/><br/>  egress {<br/>    from_port   = each.value["egress_port"]<br/>    to_port     = each.value["egress_port"]<br/>    protocol    = each.value["egress_protocol"]<br/>    cidr_blocks = each.value["egress_cidr_blocks"]<br/>  }<br/><br/>  tags = var.tags<br/>}</span></pre><p id="818f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该资源块将迭代在模块外部定义的“var.security_groups”对象，并将为每个以“each.value”为前缀的变量选取一个变量。</p><p id="0a85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是在模块外部定义单个安全组的方法:</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="cf75" class="my lx iq mu b gy mz na l nb nc">"ecs_security_groups": {<br/>    "prod-ecs-sg": {<br/>        "ingress_port": "redacted",<br/>        "ingress_protocol": "redacted",<br/>        "ingress_cidr_blocks": [<br/>            "redacted"<br/>        ],<br/>        "egress_port": "redacted",<br/>        "egress_protocol": "redacted",<br/>        "egress_cidr_blocks": [<br/>            "redacted"<br/>        ]<br/>    }<br/>}</span></pre><p id="9566" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，使用服务内部的“security_group_mapping”变量将它们映射到各自的服务，该变量将该安全组(prod-ecs-sg)的id与指定的服务相匹配。从这里开始，通过追加这个map对象来添加另一个安全组就很简单了。</p><p id="b439" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将重新访问服务定义，看看security_group_mapping变量是如何与其他动态变量结合使用的。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="6549" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">1.动态服务</h1><p id="1cf5" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">现在我们已经了解了如何配置我们的网络，让我们再看一看<a class="ae lb" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecs_service" rel="noopener ugc nofollow" target="_blank">服务定义</a>。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="62ce" class="my lx iq mu b gy mz na l nb nc">resource "aws_ecs_service" "fargate-microservices" {<br/>  for_each      = var.create_microservices == true ? var.fargate_microservices : {}<br/>  name          = each.value["name"]<br/>  cluster       = aws_ecs_cluster.cluster.id<br/>  desired_count = each.value["desired_count"]<br/>  launch_type   = each.value["launch_type"]<br/>  depends_on = [aws_ecs_cluster.cluster,<br/>  aws_ecs_task_definition.ecs_tasks]<br/>  task_definition = each.value["task_definition"]<br/><br/>  network_configuration {<br/>    subnets         = var.ecs_service_subnets<br/>    security_groups = [aws_security_group.ecs_security_groups[each.value["security_group_mapping"]].id]<br/>  }</span><span id="2dfc" class="my lx iq mu b gy nq na l nb nc">}</span></pre><p id="8c8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经注意到了“depends_on”变量，这个变量列表是为了确保任务和集群都在服务之前构建。没有这些资源，服务将无法构建。</p><p id="bccc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，为了创建任何服务，我们需要将create_microservices变量设置为true。如果启用了此切换，那么我们必须传入一个变量映射来定义我们的服务:</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="fce8" class="my lx iq mu b gy mz na l nb nc">"fargate_microservices": {<br/>    "prod-service-one": {<br/>        "name": "prod-service-one",<br/>        "task_definition": "prod-task-one",<br/>        "desired_count": "1",<br/>        "launch_type": "FARGATE",<br/>        "security_group_mapping": "prod-ecs-sg"<br/>    },<br/>    "prod-service-two": {<br/>        "name": "prod-service-two",<br/>        "task_definition": "prod-task-two",<br/>        "desired_count": "1",<br/>        "launch_type": "FARGATE",<br/>        "security_group_mapping": "prod-ecs-sg"<br/>    }<br/>}</span></pre><p id="ffe5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这才是真正的神奇之处，因为现在只需在地图中添加另一个元素就可以创建新的服务了！</p><p id="3ed1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变量定义如下:</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="1df2" class="my lx iq mu b gy mz na l nb nc">variable "fargate_microservices" {<br/>  description = "Map of variables to define a Fargate microservice."<br/>  type = map(object({<br/>    name                   = string<br/>    task_definition        = string<br/>    desired_count          = string<br/>    launch_type            = string<br/>    security_group_mapping = string<br/>  }))</span></pre><p id="aff2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“launch_type”通过使用AWS Fargate或EC2指定您希望您的集群如何运行您的容器。为了更好地了解哪种发布类型适合您的要求，请查看此<a class="ae lb" href="https://containersonaws.com/introduction/ec2-or-aws-fargate/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="f013" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们如何制作动态任务呢？</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/651fcfb58e8fa4654eb3481356c3f730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*trpCcnOHNa3sgrs2xH1bCQ.jpeg"/></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Summary of tasks, services and clusters (<a class="ae lb" href="https://www.slideshare.net/AmazonWebServices/container-networking-deep-dive-with-amazon-ecs-con401-reinvent-2017" rel="noopener ugc nofollow" target="_blank">source</a>)</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="9e81" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">2.动态任务</h1><p id="6569" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">下面是动态<a class="ae lb" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecs_task_definition" rel="noopener ugc nofollow" target="_blank">任务</a>的完整定义:</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="ed30" class="my lx iq mu b gy mz na l nb nc">resource "aws_ecs_task_definition" "ecs_tasks" {<br/>  for_each = var.create_tasks == true ? var.ecs_tasks : {}<br/>  family   = each.value["family"]<br/>  container_definitions = templatefile(each.value["container_definition"], "${merge("${var.extra_template_variables}",<br/>    {<br/>      container_name        = each.value["family"],<br/>      docker_image          = "${var.docker_image}:${var.docker_tag}",<br/>      aws_logs_group        = "/aws/fargate/${aws_ecs_cluster.cluster.name}/${each.value["family"]}/${var.environment}",<br/>      aws_log_stream_prefix = each.value["family"],<br/>      aws_region            = var.region,<br/>      container_port        = each.value["container_port"]<br/>  })}")<br/><br/>  task_role_arn            = aws_iam_role.ecs_task_role.arn<br/>  network_mode             = var.task_definition_network_mode<br/>  cpu                      = each.value["cpu"]<br/>  memory                   = each.value["memory"]<br/>  requires_compatibilities = [var.ecs_launch_type == "FARGATE" ? var.ecs_launch_type : null]<br/>  execution_role_arn       = aws_iam_role.ecs_execution_role.arn<br/><br/>  tags = merge({<br/>    "Name"        = "${each.value["family"]}-${var.environment}"<br/>    "Description" = "Task definition for ${each.value["family"]}"<br/>    }, var.tags<br/>  )<br/>}</span></pre><p id="93c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此定义的最顶端，您可以再次看到“for_each”的使用，它要求“var.create_tasks”为真，以便读取“var.ecs_tasks”映射对象。</p><p id="a71a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发这个项目最困难的部分是创建动态container_definitions，这些变量定义了运行任务的图像。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="b514" class="my lx iq mu b gy mz na l nb nc">container_definitions = templatefile(each.value["container_definition"], "${merge("${var.extra_template_variables}",<br/>    {<br/>      container_name        = each.value["family"],<br/>      docker_image          = "${var.docker_image}:${var.docker_tag}",<br/>      aws_logs_group        = "/aws/fargate/${aws_ecs_cluster.cluster.name}/${each.value["family"]}/${var.environment}",<br/>      aws_log_stream_prefix = each.value["family"],<br/>      aws_region            = var.region,<br/>      container_port        = each.value["container_port"]<br/>  })}")</span></pre><p id="eb98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“container _ defintions”参数接受一个JSON对象，该对象定义运行哪个docker映像以及所需的任何其他环境变量。</p><p id="57f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与资源的其余部分放在同一个动态for_each循环中，并将“extra_template_variables”合并到JSON对象中，以便允许动态分配环境变量。</p><p id="b956" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递到模块中的任务的映射对象看起来非常类似于服务对象。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="e5a7" class="my lx iq mu b gy mz na l nb nc">"azure_ecs_tasks": {<br/>    "prod-task-one": {<br/>        "family": "prod-task-one",<br/>        "container_definition": "./templates/task-definition-one.json",<br/>        "cpu": "1024",<br/>        "memory": "4096",<br/>        "container_port": "redacted"<br/>    },<br/>    "prod-task-two": {<br/>        "family": "prod-task-two",<br/>        "container_definition": "./templates/task-definition-two.json",<br/>        "cpu": "1024",<br/>        "memory": "4096",<br/>        "container_port": "redacted"<br/>    }<br/>}</span></pre><p id="fb29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，通过向这个map对象添加另一个元素，添加一个新任务并将其映射回相关的服务(family name)也很简单。</p><p id="d4b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务的地图对象以与动态服务非常相似的方式在变量中定义:</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="94f3" class="my lx iq mu b gy mz na l nb nc">variable "ecs_tasks" {<br/>  description = "Map of variables to define an ECS task."<br/>  type = map(object({<br/>    family               = string<br/>    container_definition = string<br/>    cpu                  = string<br/>    memory               = string<br/>    container_port       = string<br/>  }))<br/>}</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="f9d8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">3.动态日志</h1><p id="1fba" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">您可能已经注意到，定义我们任务的资源块包含一个“log_group”参数。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="a3db" class="my lx iq mu b gy mz na l nb nc">aws_logs_group        = "/aws/fargate/${aws_ecs_cluster.cluster.name}/${each.value["family"]}/${var.environment}",</span></pre><p id="9514" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表示日志应该发送到相应任务的何处。为了确保正确设置这些日志组，我们还需要定义一个动态Cloudwatch资源。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="d782" class="my lx iq mu b gy mz na l nb nc">resource "aws_cloudwatch_log_group" "cw" {<br/>  name              = "/aws/fargate/${aws_ecs_cluster.cluster.name}/${var.environment}"<br/>  retention_in_days = var.cw_logs_retention<br/>  tags = merge({<br/>    "name"        = "${aws_ecs_cluster.cluster.name}-${var.environment}"<br/>    "description" = "Task definition for ${aws_ecs_cluster.cluster.name}"<br/>    }, var.tags<br/>  )<br/>}</span></pre><p id="b214" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要这些资源的名称与我们的任务定义中的aws_log_group键的值相匹配，那么我们就会像预期的那样在Cloudwatch中收到日志。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="7ca1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">4.InternationalAssociationofMachinists国际机械师协会</h1><p id="c106" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">如果这是一个全新的设置，此解决方案将要求您定义两个新的IAM角色。这些是动态任务的“任务角色”和“执行角色”。</p><p id="1d1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务角色指定了您的任务可以与哪些(如果有)AWS资源进行交互。下面是相关的数据和资源块。</p><p id="9656" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据(策略):</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="9219" class="my lx iq mu b gy mz na l nb nc">data "aws_iam_policy_document" "ecs_task_policy" {<br/>  statement {<br/>    effect = "Allow"<br/><br/>    principals {<br/>      type        = "Service"<br/>      identifiers = ["ecs-tasks.amazonaws.com"]<br/>    }<br/><br/>    actions = ["sts:AssumeRole"]<br/>  }<br/>}</span></pre><p id="e4d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">资源(角色):</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="4ba2" class="my lx iq mu b gy mz na l nb nc">resource "aws_iam_role" "ecs_task_role" {<br/>  name = "${var.environment}-ecs-task-role"<br/><br/>  assume_role_policy   = data.aws_iam_policy_document.ecs_task_policy.json<br/>  permissions_boundary = "arn:aws:iam::&lt;account&gt;:policy/&lt;policy&gt;"<br/>  tags = merge({<br/>    "name" = "${var.environment}"<br/>    }, var.tags<br/>  )<br/>}</span></pre><p id="9b66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还允许任务通过安全令牌服务调用AssumeRole，以便允许任务使用临时凭证来访问其他服务。</p><p id="2a27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行角色指定对ECS容器代理和Docker守护程序的访问权限。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="be78" class="my lx iq mu b gy mz na l nb nc">resource "aws_iam_role" "ecs_execution_role" {<br/>  name                 = "${var.environment}-exec-task-role"<br/>  assume_role_policy   = data.aws_iam_policy_document.ecs_task_policy.json<br/>  permissions_boundary = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:policy/ccoe/developer"<br/>  tags = merge({<br/>    "name" = "${var.environment}"<br/>    }, var.tags<br/>  )<br/>}</span></pre><p id="254d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此角色已通过相同的数据对象(ecs_task_policy)被授予与前一个角色相同的权限。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="4681" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">摘要</h1><p id="afd0" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">该模块使我的团队能够快速部署新的ECS任务和服务，而无需通过GUI手动重新配置所有设置。</p><p id="dec6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模块本身大量使用Terraform中的for_each参数来按需扩展，这种设计风格在考虑大规模Terraform解决方案时非常有用。</p><p id="ea4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案相对复杂，如果有任何不合理的地方，请给我发消息或给我留言。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="2d48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多Terraform内容请查看我的YouTube频道！</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ns ne l"/></div></figure></div></div>    
</body>
</html>