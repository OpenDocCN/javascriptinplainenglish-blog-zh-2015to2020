<html>
<head>
<title>Learn JavaScript Design Patterns in 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5分钟学会JavaScript设计模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-javascript-design-patterns-in-5-minutes-cf3945d6ef37?source=collection_archive---------9-----------------------#2020-07-13">https://javascript.plainenglish.io/learn-javascript-design-patterns-in-5-minutes-cf3945d6ef37?source=collection_archive---------9-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ded9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript设计模式的类别</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="ab gu cl kk"><img src="../Images/a42baa3277f0d1af3a2379fa5a43b4fc.png" data-original-src="https://miro.medium.com/v2/0*vdKMHqZog2VJ58VS"/></div></figure><h2 id="abea" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">学习JavaScript设计模式的难度</h2><p id="959d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">如此多的JavaScript设计模式和丰富的设计模式让开发人员很难熟悉设计模式。此外，大部分关于JavaScript设计模式的文章只是简单地改写了<a class="ae mc" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">学习JavaScript设计模式</strong> </a> <strong class="ll ir">中的句子。</strong></p><p id="c45c" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">这篇文章是<strong class="ll ir"> JavaScript设计模式101类</strong>，它将用简单的英语解释设计模式，以有效地传递概念。</p><h2 id="6a8d" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">TLDR；</h2><pre class="kf kg kh ki gt mi mj mk ml aw mm bi"><span id="c975" class="kn ko iq mj b gy mn mo l mp mq">Creational --&gt; focus on the concept of creating an object<br/>Structural --&gt; focus on building blocks of object<br/>Behavioral --&gt; focus on the way objects play and work together</span></pre><p id="ecbb" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><strong class="ll ir">创造设计模式</strong>专注于处理对象创造。</p><p id="7f2d" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><em class="mr">示例包括:构造函数、工厂、单例等</em></p><p id="7cf5" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><strong class="ll ir">结构设计模式</strong>关注不同对象之间的关系。(物体构成)。</p><p id="3469" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><em class="mr">示例包括:装饰者、门面、代理等</em></p><p id="0a9b" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><strong class="ll ir">行为设计模式</strong>专注于改善或简化系统中不同对象之间的交流。</p><p id="9a9f" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><em class="mr">例子包括:迭代器、中介器、观察器等</em></p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="b2aa" class="mz ko iq bd kp na nb nc ks nd ne nf kv jw ng jx kz jz nh ka ld kc ni kd lh nj bi translated">创造性的设计模式</h1><p id="1dc9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">JavaScript是关于对象的，而创建对象是JavaScript中最重要的组成部分。</p><p id="0215" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">同样，创造性设计模式关注于创建一个对象的概念。</p><h2 id="1011" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">由构造函数解释设计模式</strong></h2><p id="2e72" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">JavaScript不支持类的概念，但是它支持处理对象<code class="fe nk nl nm mj b">new</code>的特殊构造函数。通过简单地在对构造函数的调用前加上关键字<code class="fe nk nl nm mj b">new</code>，我们可以告诉JavaScript我们希望这个函数表现得像一个构造函数，并用这个函数定义的成员实例化一个新对象。</p><p id="cf79" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">提醒:在基于类的面向对象语言中，如Java、C++和C#，类是用户定义的蓝图或原型，从中创建对象</p><p id="b744" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">换句话说:</p><pre class="kf kg kh ki gt mi mj mk ml aw mm bi"><span id="e15c" class="kn ko iq mj b gy mn mo l mp mq">JavaScript is object-oriented, but is not class-based object-oriented language like Java, C++, and C#. <br/>But, JavaScript <strong class="mj ir">Constructor</strong> helps us to create object efficiently</span></pre><p id="5fa4" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">例如，<strong class="ll ir">定义了具有<code class="fe nk nl nm mj b">model</code>、<code class="fe nk nl nm mj b">year</code>和<code class="fe nk nl nm mj b">miles</code>属性的类</strong>，并将其用于共享属性(型号、年份和英里数是所有汽车共有的属性)。</p><h2 id="901d" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">由工厂模式解释</strong></h2><p id="219e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated"><strong class="ll ir">好用</strong></p><ul class=""><li id="b857" class="nn no iq ll b lm md lp me kw np la nq le nr mb ns nt nu nv bi translated">当我们需要根据所处的环境轻松生成不同的对象实例时。</li><li id="533f" class="nn no iq ll b lm nw lp nx kw ny la nz le oa mb ns nt nu nv bi translated">当我们处理许多具有相同属性的小对象或组件时。</li></ul><p id="ecfa" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">工厂模式是<strong class="ll ir">创建对象的另一种模式。</strong>工厂模式不同于其他创建模式，它不明确要求使用构造函数。相反，工厂可以提供一个通用的<strong class="ll ir">接口</strong>来创建对象(很好的可重用性)。</p><p id="efc7" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">比如<strong class="ll ir"> Car </strong> &amp; <strong class="ll ir"> Truck </strong>函数可以通过名为<code class="fe nk nl nm mj b">vehicleType</code>的原型来区分自己，从而重用<strong class="ll ir"> VehicleFactory </strong>函数。</p><pre class="kf kg kh ki gt mi mj mk ml aw mm bi"><span id="a38a" class="kn ko iq mj b gy mn mo l mp mq">if ( options.vehicleType === "car") {<br/>  this.vehicleClass = Car;</span><span id="3afb" class="kn ko iq mj b gy ob mo l mp mq">} else {</span><span id="6d9d" class="kn ko iq mj b gy ob mo l mp mq">this.vehicleClass = Truck;<br/>}</span></pre></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="2f19" class="mz ko iq bd kp na nb nc ks nd ne nf kv jw ng jx kz jz nh ka ld kc ni kd lh nj bi translated">结构设计模式</h1><p id="e59f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated"><em class="mr">结构模式有助于确保当系统的一部分发生变化时，系统的整个结构不需要做同样的事情。</em></p><p id="bf6f" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">同样，结构设计模式<strong class="ll ir"> </strong>关注不同对象之间的关系。(物体构成)。</p><h2 id="e702" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">由装饰图案解释</strong></h2><p id="1a28" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">装饰者提供了向系统中现有的类动态添加行为的能力。换句话说，装饰模式与对象的创建方式没有太大的联系，而是关注于扩展其功能的问题。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi oc"><img src="../Images/2c38a46f7a07bfd47b0b7db7b571d900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a-IPRihMIHf4q936"/></div></div></figure><p id="8a0b" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">比如形象制作一个<strong class="ll ir">指环王</strong>游戏。</p><p id="fe32" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">一个<em class="mr">指环王</em>游戏可能需要<strong class="ll ir">霍比特人、精灵、兽人、巫师、山巨人、石巨人、</strong>等等的构造器，但是很容易就有上百个这样的构造器。</p><p id="2b77" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">如果我们考虑功能，想象一下必须为每种功能类型的组合创建子类——例如，<strong class="ll ir"> HobbitWithRing，HobbitWithSword，HobbitWithRingAndSword，</strong>等等。</p><p id="bf4d" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">这不太实际，而且当我们把越来越多的不同能力考虑在内时，这肯定是不可管理的。</p><p id="22e2" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">比如我们来想想<strong class="ll ir"> Macbook购买</strong>型号。</p><pre class="kf kg kh ki gt mi mj mk ml aw mm bi"><span id="4465" class="kn ko iq mj b gy mn mo l mp mq">In the example, <strong class="mj ir">Decorators </strong>are overriding the <strong class="mj ir">MacBook() </strong>superclass object's <strong class="mj ir">.cost()</strong> function to return the current price of the <strong class="mj ir">Macbook</strong> plus the cost of the upgrade being specified</span><span id="13c6" class="kn ko iq mj b gy ob mo l mp mq">Different decorators to update the <strong class="mj ir">.cost </strong>function</span></pre></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="07ff" class="mz ko iq bd kp na nb nc ks nd ne nf kv jw ng jx kz jz nh ka ld kc ni kd lh nj bi translated">行为设计模式</h1><p id="db9e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">同样，行为设计模式专注于改进或简化系统中不同对象之间的通信</p><h2 id="ca1a" class="kn ko iq bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">用装饰图案来解释</strong></h2><p id="619b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated">观察者是一种设计模式，在这种模式中，一个对象维护一个依赖于它的对象列表(观察者)，自动通知它们状态的任何变化。</p><p id="5097" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">当一个主体需要通知观察者一些有趣的事情发生时，它向观察者广播通知。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi oh"><img src="../Images/5bef1f84aa44389186ef066d7e7add65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlc_1exjWCJbSGJ6BQZt_w.png"/></div></div></figure><p id="2c54" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">例如，图像制作<strong class="ll ir">字数统计</strong>应用程序，无论用户何时输入，你都要计算字数。</p><pre class="kf kg kh ki gt mi mj mk ml aw mm bi"><span id="633b" class="kn ko iq mj b gy mn mo l mp mq">EventObserver<br/>│ <br/>├── subscribe: adds new observable events<br/>│ <br/>├── unsubscribe: removes observable events<br/>|<br/>└── broadcast: executes all events with bound data</span></pre><p id="28ad" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><strong class="ll ir">好用</strong></p><ul class=""><li id="9f1b" class="nn no iq ll b lm md lp me kw np la nq le nr mb ns nt nu nv bi translated">观察者设计模式可以在元素之间进行一对多的数据绑定。其高度解耦的特性使得观察者设计模式适用于复杂的应用程序</li><li id="23e1" class="nn no iq ll b lm nw lp nx kw ny la nz le oa mb ns nt nu nv bi translated">高度解耦和关注点的分离可以使我们代码的整体设计更加简洁</li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="cc69" class="mz ko iq bd kp na nb nc ks nd ne nf kv jw ng jx kz jz nh ka ld kc ni kd lh nj bi translated">结论</h1><p id="600f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr kw ls lt lu la lv lw lx le ly lz ma mb ij bi translated"><strong class="ll ir">创意设计模式</strong></p><ul class=""><li id="a111" class="nn no iq ll b lm md lp me kw np la nq le nr mb ns nt nu nv bi translated">关注创建对象的概念</li><li id="c63c" class="nn no iq ll b lm nw lp nx kw ny la nz le oa mb ns nt nu nv bi translated">公共属性的模式</li></ul><p id="f518" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><strong class="ll ir">结构设计模式</strong></p><ul class=""><li id="962b" class="nn no iq ll b lm md lp me kw np la nq le nr mb ns nt nu nv bi translated">关注对象的构建模块</li><li id="45e3" class="nn no iq ll b lm nw lp nx kw ny la nz le oa mb ns nt nu nv bi translated">考虑制作<em class="mr">指环王</em>游戏，其中有许多具有不同特征的角色(我们的模式不仅仅是手工编写成千上万个角色</li></ul><pre class="kf kg kh ki gt mi mj mk ml aw mm bi"><span id="365a" class="kn ko iq mj b gy mn mo l mp mq">A <em class="mr">Lord of the Rings </em>game could require constructors for <strong class="mj ir">Hobbit, Elf, Orc, Wizard, Mountain Giant, Stone Giant, </strong>and so on, but there could easily be hundreds of these</span></pre><p id="3a39" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated"><strong class="ll ir">行为设计模式</strong></p><ul class=""><li id="3207" class="nn no iq ll b lm md lp me kw np la nq le nr mb ns nt nu nv bi translated">关注物体一起玩耍和工作的方式</li></ul><p id="fd58" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">高度解耦；</p><ul class=""><li id="a434" class="nn no iq ll b lm md lp me kw np la nq le nr mb ns nt nu nv bi translated">易于在应用程序范围内实施</li><li id="78fa" class="nn no iq ll b lm nw lp nx kw ny la nz le oa mb ns nt nu nv bi translated">这种关注点的分离可以使我们代码的整体设计更加简洁</li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="5ff4" class="pw-post-body-paragraph lj lk iq ll b lm md jr lo lp me ju lr kw mf lt lu la mg lw lx le mh lz ma mb ij bi translated">如果您有任何问题或意见，请告诉我。我很快会带着JavaScript设计模式的更多细节解释回来。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="od oe di of bf og"><div class="gh gi oi"><img src="../Images/607194ad8ebf5afaaf33cc5d3c519019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DXj_aolLYCXBcx1k"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk">Photo by <a class="ae mc" href="https://unsplash.com/@cmhedger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Courtney Hedger</a> on <a class="ae mc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>