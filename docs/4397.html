<html>
<head>
<title>How To Setup Spring Boot With React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设置Spring Boot与反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-setup-spring-mvc-with-react-ce2cc422a7e0?source=collection_archive---------4-----------------------#2020-12-08">https://javascript.plainenglish.io/how-to-setup-spring-mvc-with-react-ce2cc422a7e0?source=collection_archive---------4-----------------------#2020-12-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/03699d0fdd5181c779a2d36d6c5174c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5O1FACcBhAfHurv32nmXCw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><em class="jz">This tutorial will have set you up with a full stack project in 6 steps</em></figcaption></figure><p id="98eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想创建一个完整的堆栈项目，它有一个包含一些数据的简单后端和一个显示数据的前端。就这样。</p><p id="fa44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目标并不是真正深入CRUD操作的细节，创建API或开发完整堆栈应用程序时附带的其他基本概念。它只是简单地表达了实现两个组件之间通信所必需的最低限度。</p><p id="442b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将讲述的是如何:</p><ol class=""><li id="267e" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc io">使用</strong><a class="ae lh" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">spring initializr</strong></a>为后端创建一个spring项目</li></ol><ul class=""><li id="7f9b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx li le lf lg bi translated">创建春季项目</li><li id="f0b5" class="ky kz in kc b kd lj kh lk kl ll kp lm kt ln kx li le lf lg bi translated">创建表示模型的JPA实体</li><li id="2100" class="ky kz in kc b kd lj kh lk kl ll kp lm kt ln kx li le lf lg bi translated">建立仓库并将数据存储到H2数据库</li><li id="347a" class="ky kz in kc b kd lj kh lk kl ll kp lm kt ln kx li le lf lg bi translated">创建一个控制器作为视图和模型之间的中介</li></ul><p id="0035" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2 <strong class="kc io">。使用</strong> <a class="ae lh" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">创建-反应-应用</strong> </a>为前端创建一个反应项目</p><ul class=""><li id="80bd" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx li le lf lg bi translated">创建反应项目</li><li id="fd2d" class="ky kz in kc b kd lj kh lk kl ll kp lm kt ln kx li le lf lg bi translated">从后端获取数据</li><li id="a104" class="ky kz in kc b kd lj kh lk kl ll kp lm kt ln kx li le lf lg bi translated">显示来自返回请求的信息</li></ul><h1 id="d3d7" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">第一步。使用Spring Initializr创建项目</h1><p id="392b" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated"><a class="ae lh" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>是生成Spring Boot项目的工具。我们只需沿着一个构建(Maven或Gradle)选择我们想要的依赖项，它就会组装一个项目。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/6bae0a2fb742404073f3bbc42420083e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlUomPAbl1d7bDf-J9wuYA.png"/></div></div></figure><p id="2cee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">添加以下依赖项:</p><ul class=""><li id="d088" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx li le lf lg bi translated">弹簧网</li><li id="6fee" class="ky kz in kc b kd lj kh lk kl ll kp lm kt ln kx li le lf lg bi translated">春季数据JPA</li><li id="8174" class="ky kz in kc b kd lj kh lk kl ll kp lm kt ln kx li le lf lg bi translated">H2数据库</li></ul><p id="1bd9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">点击<strong class="kc io">生成</strong>后，压缩文件将被下载到计算机上。该项目可以解压缩到所需的位置。在集成开发环境中打开项目。</p><h1 id="b13a" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">第二步。创建实体</h1><p id="6278" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">现在项目已经建立，我们要做的第一件事就是创建我们的JPA实体。</p><p id="5d5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，这个项目的目标是让我们的后端与前端通信。我们将创建JPA实体的实例，并显示在我们的前端。</p><p id="518d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">什么是JPA？什么是实体？</strong></p><p id="4ee5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JPA代表Java Persistence API，是用于在数据库中存储数据的类和方法的集合。</p><p id="2dd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实体表示要存储在数据库中的表。</p><p id="38f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们将创建一个类，它将包含一些数据属性。我们想创建这个类的实例，并向我们的前端显示它的数据。为此，我们将创建对象，将其存储在数据库中，当我们加载前端时，存储的数据将被提取并显示出来。</p><p id="8243" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题在于，我们不能只将普通的旧java对象存储到数据库中而不面临一些问题。对于以表格形式表示关系对象和以互连图形形式表示java对象的数据库，在存储和从数据库中检索对象时可能会发生不匹配。</p><p id="400a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JPA有助于以正确地将这些java对象持久存储到数据库中所必需的方式来表示它们。因此，通过在一个类上添加<code class="fe mw mx my mz b">@Entity</code>,我们告诉JPA这代表数据库中的一个表，并且创建的每个实例代表表中的一行。</p><pre class="ms mt mu mv gt na mz nb nc aw nd bi"><span id="590d" class="ne lp in mz b gy nf ng l nh ni">@Entity<br/>@Table(name = "ARTIST")<br/>public class Artist {<br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="nj">AUTO</em>)<br/>    private Long id;<br/><br/>    private String firstName;<br/>    private String lastName;<br/><br/>    @JsonBackReference<br/>    @OneToMany(mappedBy = "artist", cascade = CascadeType.<em class="nj">ALL</em>)<br/>    private Set&lt;Song&gt; songs = new HashSet&lt;&gt;();</span><span id="80d6" class="ne lp in mz b gy nk ng l nh ni">    //constructors, getters, and setters<br/>    //override toString<br/>    //override equals and hashCode -for id field only                 <strong class="mz io"><br/></strong><br/>}</span></pre><h1 id="734e" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">第三步。设置存储库</strong></h1><p id="1ff0" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">存储库负责JPA实体上的持久化和查询操作。</p><pre class="ms mt mu mv gt na mz nb nc aw nd bi"><span id="2474" class="ne lp in mz b gy nf ng l nh ni">@Repository<br/>public interface ArtistRepository extends JpaRepository&lt;Artist, Long&gt; {<br/>}</span></pre><h1 id="0c2a" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">第四步。加载数据</h1><p id="ee3b" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">现在我们需要做的是创建一些对象，并将它们存储到我们的H2数据库中。</p><p id="b1de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">H2数据库是一个轻量级的关系型Java数据库，可以配置为作为内存数据库运行。我们将使用它来存储我们的对象。</p><pre class="ms mt mu mv gt na mz nb nc aw nd bi"><span id="3bc0" class="ne lp in mz b gy nf ng l nh ni">@Component<br/>public class DataBaseLoader implements CommandLineRunner {<br/><br/>    private final ArtistRepository artistRepository;<br/>    private final SongRepository songRepository;<br/><br/>    public DataBaseLoader(ArtistRepository artistRepository, SongRepository songRepository) {<br/>        this.artistRepository = artistRepository;<br/>        this.songRepository = songRepository;<br/>    }<br/><br/>    @Override<br/>    public void run(String... args) throws Exception {<br/><br/>        Artist jt = new Artist("Justin", "Timberlake");<br/>        Song cryMeARiver = new Song("Cry Me a River");<br/><br/>        artistRepository.save(jt);<br/>        cryMeARiver.setArtist(jt);<br/>        songRepository.save(cryMeARiver);<br/><br/>    }<br/>}</span></pre><blockquote class="nl"><p id="59fe" class="nm nn in bd no np nq nr ns nt nu kx dk translated">如果你想知道，答案是肯定的，我是贾斯汀·汀布莱克的超级粉丝，所以这个例子看起来很合适</p></blockquote><h1 id="efd4" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz nv mb mc md nw mf mg mh nx mj mk ml bi translated">第五步。设置控制器</h1><p id="933e" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">我们将数据保存到内存数据库中。现在我们创建rest控制器，它负责将请求数据返回给已定义的请求处理程序方法。</p><pre class="ms mt mu mv gt na mz nb nc aw nd bi"><span id="b56d" class="ne lp in mz b gy nf ng l nh ni">@RestController<br/>@RequestMapping("/api")<br/>public class SongController {<br/><br/>    @Autowired<br/>    private SongService songService;<br/><br/>    public SongController(SongService songService) {<br/>        this.songService = songService;<br/>    }<br/><br/>    @GetMapping("/songs")<br/>    public List&lt;Song&gt; getAllSongs(){<br/>      List&lt;Song&gt; result = songService.getAllSongs();<br/>        return result;<br/>    }<br/>}</span></pre><p id="47c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们运行spring应用程序时，一个tomcat服务器在<code class="fe mw mx my mz b">localhost:8080</code>上启动。在我们的控制器中，我们创建了一个从数据库中获取所有歌曲并返回的方法。使用<code class="fe mw mx my mz b">@GetMapping("/songs")</code>,我们说当端点收到请求时调用函数。还有一个<code class="fe mw mx my mz b">@RequestMapping("/api")</code>为我们的请求指定了默认值。要检索所有的歌曲，完整的网址是<code class="fe mw mx my mz b">localhost:8080/api/songs</code></p><h1 id="270c" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">第六步。设置前端反应应用程序</h1><p id="d043" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">create-react-app是一个生成基本react项目的工具，因此可以避免初始设置和配置。</p><p id="506a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用命令行导航到一个位置以保存前端项目。</p><p id="51f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nj">如果您不熟悉命令行，请检查cmd </em>  <em class="nj">中导航的</em> <a class="ae lh" href="https://riptutorial.com/cmd/example/8646/navigating-in-cmd" rel="noopener ugc nofollow" target="_blank"> <em class="nj">上的此链接。</em></a></p><p id="2976" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行以下命令创建一个react应用程序。</p><pre class="ms mt mu mv gt na mz nb nc aw nd bi"><span id="5d77" class="ne lp in mz b gy nf ng l nh ni">npx create-react-app app-name-here<br/>cd app-name-here<br/>npm start</span></pre><p id="a46e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦应用程序设置完毕，我们将呈现保存在数据库中的样本数据。为此，我们将使用相同的路径从控制器中获取数据<code class="fe mw mx my mz b">const response = await fetch('/api/songs')</code></p><p id="876d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了呈现数据，我们将保存请求的响应体，并将其呈现为一个组件</p><pre class="ms mt mu mv gt na mz nb nc aw nd bi"><span id="894e" class="ne lp in mz b gy nf ng l nh ni">&lt;Card bg='light'style={{width:'18rem'}}&gt;</span><span id="6b82" class="ne lp in mz b gy nk ng l nh ni">&lt;Card.Header&gt;{song.title}&lt;/Card.Header&gt;</span><span id="1315" class="ne lp in mz b gy nk ng l nh ni">&lt;Card.Body&gt;</span><span id="7347" class="ne lp in mz b gy nk ng l nh ni">&lt;Card.Title&gt;{song.artists}&lt;/Card.Title&gt;</span><span id="e289" class="ne lp in mz b gy nk ng l nh ni">&lt;/Card.Body&gt;</span><span id="97bb" class="ne lp in mz b gy nk ng l nh ni">&lt;/Card&gt;</span></pre><p id="a9b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，前端实例在<code class="fe mw mx my mz b">localhost:3000</code>提供服务。我们的spring应用程序在<code class="fe mw mx my mz b">localhost:8080</code>上提供，所以现在我们要做的就是告诉我们的前端，我们的请求应该发送到<code class="fe mw mx my mz b">localhost:8080</code>。我们通过将<code class="fe mw mx my mz b">"proxy":”http://localhost:8080</code>添加到<code class="fe mw mx my mz b">package.json</code>中来实现这一点，就是这样！</p><p id="ce73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经完成了目标，现在我们的后端已经连接并与前端通信。</p><p id="67c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完全回购:<a class="ae lh" href="https://github.com/martinacarter1/springmvc-react/tree/master" rel="noopener ugc nofollow" target="_blank"> springmvc-react </a></p></div></div>    
</body>
</html>