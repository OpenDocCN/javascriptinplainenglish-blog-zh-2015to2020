<html>
<head>
<title>Best Features of ES2017 —Async Functions Pitfalls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2017的最佳特性—异步功能缺陷</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-features-of-es2017-async-functions-pitfalls-3588900c796b?source=collection_archive---------15-----------------------#2020-09-21">https://javascript.plainenglish.io/best-features-of-es2017-async-functions-pitfalls-3588900c796b?source=collection_archive---------15-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b51dec5d6b2dc4176f38e261f136f9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lxsra87Vc47-kVDM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@andsmall?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Small</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2017的最佳特性。</p><h1 id="d4c0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步函数的属性</h1><p id="4f9c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步函数不包装我们返回的承诺。</p><p id="bc96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ff9a" class="mn lc iq mj b gy mo mp l mq mr">async function asyncFunc() {<br/>  return Promise.resolve('foo');<br/>}</span></pre><p id="3668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6cc1" class="mn lc iq mj b gy mo mp l mq mr">asyncFunc()<br/>  .then(x =&gt; console.log(x))</span></pre><p id="e47a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">x</code>就是<code class="fe ms mt mu mj b">'foo'</code>。</p><p id="ddc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们返回被拒绝的承诺，那么抛出的错误值将在<code class="fe ms mt mu mj b">catch</code>回调中。</p><p id="98d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1268" class="mn lc iq mj b gy mo mp l mq mr">async function asyncFunc() {<br/>  return Promise.reject(new Error('error'));<br/>}</span></pre><p id="aa46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6377" class="mn lc iq mj b gy mo mp l mq mr">asyncFunc()<br/>  .catch(err =&gt; console.error(err));</span></pre><p id="e2d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe ms mt mu mj b">error</code>是<code class="fe ms mt mu mj b">Error</code>实例。</p><h1 id="4d03" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步功能提示</h1><p id="4148" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在<code class="fe ms mt mu mj b">=</code>右边的代码是一个承诺，我们永远不应该忘记<code class="fe ms mt mu mj b">await</code>。</p><p id="862f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8966" class="mn lc iq mj b gy mo mp l mq mr">async function asyncFunc() {<br/>  const value = promiseFunc();<br/>  //...<br/>}</span></pre><p id="c41a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是行不通的，因为没有<code class="fe ms mt mu mj b">await</code>来等待承诺的结果。</p><p id="0ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">await</code>即使函数不返回任何东西也有意义。</p><p id="4ffb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用承诺信号来暂停功能，直到事情完成。</p><p id="8e57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fd01" class="mn lc iq mj b gy mo mp l mq mr">async function asyncFunc() {<br/>  await sleep(2000);<br/>  //...<br/>}</span></pre><p id="3c30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用我们自己的<code class="fe ms mt mu mj b">sleep</code>功能使功能暂停2秒钟。</p><p id="a7a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以实现<code class="fe ms mt mu mj b">sleep</code>,只要它返回一个承诺。</p><h1 id="cad1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们不需要总是等待</h1><p id="ec2e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们只想调用一个承诺，而不想等待它的结果，那么我们不需要向它添加<code class="fe ms mt mu mj b">await</code>。</p><p id="b071" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8039" class="mn lc iq mj b gy mo mp l mq mr">async function asyncFunc() {<br/>  const writer = openFile('foo.txt');<br/>  writer.writeLine('foo'); <br/>  writer.writeLine('bar'); <br/>  await writer.close(); <br/>}</span></pre><p id="e164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有将<code class="fe ms mt mu mj b">await</code>添加到<code class="fe ms mt mu mj b">writer.writeLine</code>方法调用中，因为我们不想等待结果。</p><p id="baa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以让我们的函数运行得更快，因为我们不必等待。</p><h1 id="911e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe ms mt mu mj b">await</code>是顺序的，<code class="fe ms mt mu mj b">Promise.all()</code>是平行的</h1><p id="ef78" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须记住<code class="fe ms mt mu mj b">await</code>是顺序运行的。</p><p id="5ee1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe ms mt mu mj b">Promise.all</code>运行我们并行传递的承诺数组。</p><p id="7ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0e13" class="mn lc iq mj b gy mo mp l mq mr">async function foo() {<br/>  const result1 = await promise1();<br/>  const result2 = await promise2();<br/>}</span></pre><p id="b2d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe ms mt mu mj b">await</code>等待每个异步功能完成，直到运行下一行。</p><p id="b937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="31fe" class="mn lc iq mj b gy mo mp l mq mr">async function foo() {<br/>  const [result1, result2] = await Promise.all([<br/>    promise1(),<br/>    promise2(),<br/>  ]);<br/>}</span></pre><p id="d61a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe ms mt mu mj b">promise1</code>和<code class="fe ms mt mu mj b">promise2</code>并行运行。</p><h1 id="4516" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步函数和回调</h1><p id="01c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">await</code>只影响周围的异步功能。</p><p id="b6af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以异步函数不能在回调中<code class="fe ms mt mu mj b">await</code>。</p><p id="5205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，回调可以是异步函数。</p><p id="d24c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得回调很难使用。</p><p id="ff7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不能在非异步的<code class="fe ms mt mu mj b">map</code>回调中使用<code class="fe ms mt mu mj b">await</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3694" class="mn lc iq mj b gy mo mp l mq mr">async function download(urls) {<br/>  return urls.map(url =&gt; {    <br/>    const content = await makeRequest(url);<br/>    return content;<br/>  });<br/>}</span></pre><p id="7afc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在函数前面没有一个<code class="fe ms mt mu mj b">async</code>关键字。</p><p id="4a64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们也不能写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7bc0" class="mn lc iq mj b gy mo mp l mq mr">async function download(urls) {<br/>  return urls.map(async url =&gt; {    <br/>    const content = await makeRequest(url);<br/>    return content;<br/>  });<br/>}</span></pre><p id="bc74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们不能从回调中得到每个异步函数的结果。</p><p id="4e81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等待只在回调中完成。</p><p id="801e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该做的是将我们的URL映射到承诺，然后在承诺数组上调用<code class="fe ms mt mu mj b">Promise.all</code>。</p><p id="c3de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3e3e" class="mn lc iq mj b gy mo mp l mq mr">async function download(urls) {<br/>  const promiseArray = urls.map(async (url) =&gt; {<br/>    const content = await makeRequest(url);<br/>    return content;<br/>  });<br/>  return await Promise.all(promiseArray);<br/>}</span></pre><p id="cd7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">map</code>将URL数组映射到承诺数组，然后我们返回我们的<code class="fe ms mt mu mj b">Promise.all</code>调用以返回一个承诺，该承诺解析为数组中所有承诺的结果。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/3e15c2d8bc282ca94b9a6a22f60c8657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zajx5JpWezjOoNlB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sergeebee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Serg B</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c9db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7556" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步函数使用起来很方便，但是如果我们不小心的话，它可能会被误用。</p><p id="3644" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们应该确保正确使用它们以避免意想不到的结果。</p><h2 id="c6eb" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="da82" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>