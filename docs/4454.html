<html>
<head>
<title>createAsyncThunk in Redux-Toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux-Toolkit中的createAsyncThunk</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/createasyncthunk-in-redux-toolkit-4d8d2f0412d3?source=collection_archive---------0-----------------------#2020-12-13">https://javascript.plainenglish.io/createasyncthunk-in-redux-toolkit-4d8d2f0412d3?source=collection_archive---------0-----------------------#2020-12-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/3700e0bf2a13116d1b01c8030bddce0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvNYg3CEqcgKJ_dA-folfA.png"/></div></div></figure><div class=""/><p id="3c3d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">分派异步操作从来没有看起来这么好</em></p><p id="c070" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，这是我的<em class="kt"> Redux-Toolkit </em>系列的第三部分，你可以在下面找到第一和第二部分:</p><ul class=""><li id="ebab" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">第一部分:介绍<a class="ae ld" href="https://medium.com/datadriveninvestor/redux-toolkit-eb07f753649" rel="noopener"> Redux-Toolkit </a></li><li id="ab37" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks kz la lb lc bi translated">第2部分:在Redux-Toolkit中创建<a class="ae ld" href="https://medium.com/datadriveninvestor/createslice-in-redux-toolkit-c5e5441b75d9" rel="noopener">切片</a></li></ul><p id="b80e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当谈到管理React应用程序中的状态时，Redux已经成为某种程度上的行业标准。现在，随着Redux Toolkit的推出，生活变得前所未有的简单。它功能强大，易于设置，并且您可以创建存储片段，以获得更好的代码可维护性和模块化。</p><p id="318f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Redux的核心是同步的，所以我们需要添加像<a class="ae ld" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux-Thunk </a>或Saga这样的中间件来帮助我们处理异步位。有了Redux-Toolki，我们就可以将Thunk集成为一个依赖项。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h2 id="ce49" class="lq lr iy bd ls lt lu dn lv lw lx dp ly kg lz ma mb kk mc md me ko mf mg mh mi bi translated"><strong class="ak"><em class="mj">createAsyncThunk</em></strong></h2><p id="ada2" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">根据官方文档:<strong class="jx iz"><em class="kt">createasynchunk</em></strong>是一个<strong class="jx iz"> <em class="kt"> </em> </strong>函数，接受一个Redux动作类型字符串和一个应该返回一个承诺的回调函数。它根据您传入的操作类型前缀生成承诺生命周期操作类型，并返回一个thunk操作创建器，该创建器将运行承诺回调并根据返回的承诺调度生命周期操作。</p><p id="a6e0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来分解一下:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="dfb6" class="lq lr iy mu b gy my mz l na nb">export const fetchToDoList = createAsyncThunk(<br/> "todo/fetchList", async (_, { rejectWithValue },{condition:true}) =&gt; {<br/>   try {<br/>    const list = await getList();<br/>    return list;<br/>   } catch (err) {<br/>    return rejectWithValue([], err);<br/>   }<br/> });</span></pre><p id="3134" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">createasynchunk</strong>接受三个参数:</p><ol class=""><li id="8132" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks nc la lb lc bi translated">类型:<em class="kt">“todo/fetchList”。</em>遵循的一般命名约定是{reducerName}/{actionType}</li><li id="b7e8" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt"> payloadCreator </em>:是回调函数(<em class="kt"> async (_，{ rejectWithValue })= &gt; {} </em>)，第一个param是传递给回调的实参。第二个参数是thunkApi(定义如下)。</li><li id="21a5" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt"> options </em>:是一个有两个道具的对象，<em class="kt"> condition </em>是一个回调，它返回一个可以用来跳过执行的bool，<em class="kt">dispatchConditionRejection</em>使用<em class="kt"> condition </em>来调度动作。如果条件为假<em class="kt">dispatchConditionRejection</em>将不会分派任何动作。</li></ol><p id="70fa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> ThunkApi </strong>很重要，因为大多数时候你将依赖于其中定义的属性。它们是:</p><ol class=""><li id="836f" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks nc la lb lc bi translated"><em class="kt">调度</em>:调度不同的动作。</li><li id="a47d" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt"> getState </em>:从回调中访问redux存储</li><li id="ca78" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt"> requestId </em>:这是redux-toolkit为每个请求生成的唯一Id</li><li id="dce0" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt">信号</em>:该信号可用于<a class="ae ld" href="https://medium.com/datadriveninvestor/aborting-cancelling-requests-with-fetch-or-axios-db2e93825a36" rel="noopener">取消请求</a>。</li><li id="fccc" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt"> rejectWithValue </em>:是一个效用函数，在出错的情况下，可以返回给动作创建者一个定义好的有效载荷。</li><li id="67fe" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt"> extra </em>:设置时给予thunk中间件的“额外参数”，如果可用的话</li></ol><blockquote class="nd ne nf"><p id="beb6" class="jv jw kt jx b jy jz ka kb kc kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="iy">承诺生命周期动作:</em> </strong></p></blockquote><p id="276d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我更喜欢使用<em class="kt">createasincthunk</em><strong class="jx iz">，</strong>的一个主要原因是它提供的生命周期动作。动作的三个生命周期如下:</p><ol class=""><li id="ec0a" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks nc la lb lc bi translated"><em class="kt">待定</em>:在<em class="kt"> payloadCreator </em>中调用回调之前</li><li id="c87f" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated">履行了:关于成功执行死刑</li><li id="e6c9" class="ku kv iy jx b jy le kc lf kg lg kk lh ko li ks nc la lb lc bi translated"><em class="kt">拒绝</em>:错误时</li></ol><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6199" class="lq lr iy mu b gy my mz l na nb">[fetchToDoList.fulfilled]: (state, { meta, payload })=&gt; {  <br/>  state.todoList = payload;<br/> },<br/>[fetchToDoList.pending]: (state, { meta })=&gt;{<br/>  state.loading = "pending";<br/>},<br/>[fetchToDoList.rejected]: (state,{meta,payload,error })=&gt;{<br/>  state.error = error;<br/>}</span></pre><p id="686a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个生命周期都被传递了reducer状态(不是store obj)和thunk action creator，其中包含<em class="kt">有效负载(</em>返回值<em class="kt"> ) </em>已完成/已拒绝<em class="kt">，包含requestId和传递给<em class="kt"> payloadCreator的参数的meta </em>，如果被拒绝<em class="kt">则为error </em>。</em></p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="7aeb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个简单的todoList切片来更好地理解:</p><figure class="mp mq mr ms gt ip"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk">todoSlice</figcaption></figure></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="7dfe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，我们可以更方便地分派我们的异步操作，而不用将我们的逻辑分布到多个文件中。</p><p id="74c8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这里找到todo应用<a class="ae ld" href="https://github.com/devAbhimanyu/Redux-toolkit/tree/createAsyncThunk" rel="noopener ugc nofollow" target="_blank">的git repo。</a></p><p id="4f89" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">更多内容请看</em><a class="ae ld" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="kt">plain English . io</em></a><em class="kt">。报名参加我们的</em> <a class="ae ld" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <em class="kt">免费每周简讯</em> </a> <em class="kt">。在我们的</em> <a class="ae ld" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <em class="kt">社区</em> </a> <em class="kt">获得独家写作机会和建议。</em></p></div></div>    
</body>
</html>