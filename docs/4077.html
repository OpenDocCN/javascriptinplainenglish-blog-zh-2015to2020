<html>
<head>
<title>Best of Modern JavaScript — Proxy Handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——代理处理器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-proxy-handlers-efdf34cdf4cb?source=collection_archive---------8-----------------------#2020-11-14">https://javascript.plainenglish.io/best-of-modern-javascript-proxy-handlers-efdf34cdf4cb?source=collection_archive---------8-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/400dde23c2707801e3271f32f50dd007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-I78IqqQTOEUCmDF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mthwbchn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matthew Buchanan</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何控制JavaScript对象操作。</p><h1 id="8fc0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数代理处理程序</h1><p id="376e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以将处理程序方法添加到传递给<code class="fe me mf mg mh b">Proxy</code>构造函数或<code class="fe me mf mg mh b">Proxy.revocable</code>方法的<code class="fe me mf mg mh b">handler</code>中。</p><p id="12fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">apply(target, thisArgument, argumentsList)</code>让我们改变<code class="fe me mf mg mh b">apply</code>或<code class="fe me mf mg mh b">call</code>方法的行为。</p><p id="2e2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还可以改变直接调用函数的行为。</p><p id="922e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">target</code>是我们想要控制的目标对象。</p><p id="1206" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">thisArgument</code>让我们在函数中传递<code class="fe me mf mg mh b">this</code>的值。</p><p id="b667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们传入一个参数列表。</p><h1 id="4b79" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理程序方法的不变量</h1><p id="749b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">处理程序方法具有各种强制的不变量。</p><p id="39c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括以下内容。</p><p id="2d42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">apply(target, thisArgument, argumentsList)</code>没有强制的不变量。</p><p id="f467" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">construct(target, argumentsList, newTarget)</code>必须返回一个对象，而不是<code class="fe me mf mg mh b">null</code>或一个原始值。</p><p id="82e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要让我们给不可扩展的对象添加属性。</p><p id="047f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">configurable</code>为<code class="fe me mf mg mh b">false</code>，则<code class="fe me mf mg mh b">target</code>必须有一个不可配置的自身属性。</p><p id="7f0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">writable</code>和<code class="fe me mf mg mh b">configurable</code>都是<code class="fe me mf mg mh b">false</code>，那么我们就不能给属性写一个新的属性。</p><p id="4e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">deleteProperty(target, propKey)</code>不能删除<code class="fe me mf mg mh b">target</code>不可配置的自身属性。</p><p id="e498" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">get(target, propKey, receiver)</code>如果它有自己的、不可写的、不可配置的名为<code class="fe me mf mg mh b">propKey</code>的数据属性，则必须返回属性值。</p><p id="2cd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则必须返回<code class="fe me mf mg mh b">undefined</code>。</p><p id="4d64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">getOwnPropertyDescriptor(target, propKey)</code>必须返回一个对象或<code class="fe me mf mg mh b">undefined</code>。</p><p id="2ffe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标的不可配置now属性不能报告为不存在。</p><p id="0ca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果目标不可扩展，则它必须报告为现有。</p><p id="76a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不能将不可配置的属性报告为可配置的，也不能为不可配置和不可写的属性报告不同的值。</p><p id="3b1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">getPrototypeOf(target)</code>必须返回一个对象或<code class="fe me mf mg mh b">null</code>。</p><p id="199c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果目标是不可扩展的，那么处理程序必须返回目标对象的原型。</p><p id="80a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">has(target, propKey)</code>不能隐藏<code class="fe me mf mg mh b">target</code>不可配置的自有属性。</p><p id="db08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果目标是不可扩展的，那么<code class="fe me mf mg mh b">target</code>的所有属性都不会被隐藏。</p><p id="836e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">isExtensible(target)</code>必须返回一个布尔值。</p><p id="5ba3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">强制布尔值必须与<code class="fe me mf mg mh b">target.isExtensible</code>相同。</p><p id="2760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ownKeys(target)</code>必须返回一个被视为类似数组并被转换为数组的对象。</p><p id="d65a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果的每个元素必须是字符串或符号。</p><p id="1d9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果必须有<code class="fe me mf mg mh b">target</code>的所有不可配置非继承属性的关键字。</p><p id="2d3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">target</code>不是可扩展的，那么结果只能是它自己属性的键。</p><p id="fedc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">preventExtensions(target)</code>返回一个布尔值。</p><p id="b1f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用后<code class="fe me mf mg mh b">target.isExtensible()</code>必须返回<code class="fe me mf mg mh b">false</code>。</p><p id="b6c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">set(target, propKey, value, receiver)</code>应设置<code class="fe me mf mg mh b">target</code>的可写、可配置属性的属性。</p><p id="8e50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">target</code>已经有了自己的名为<code class="fe me mf mg mh b">propKey</code>的不可配置属性，那么应该抛出<code class="fe me mf mg mh b">TypeError</code>，因为该属性无法设置。</p><p id="5519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">setPrototypeOf(target, proto)</code>的返回结果被强制转换为布尔值。</p><p id="872e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果目标是不可扩展的，那么它的原型就不能被改变。</p><p id="8aa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，<code class="fe me mf mg mh b">target</code>的原型必须和现在的一样，否则就会抛出一个<code class="fe me mf mg mh b">TypeError</code>。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/686fae2d00ee919e39414ffc6582ea3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uM7vSpwFArobkTRQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@withluke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luke Stackpoole</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="312c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0424" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代理处理器方法必须遵循一些条件，即使它允许我们定制那些操作。</p><p id="7284" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，对象操作仍然是可预测的。</p><p id="477d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>