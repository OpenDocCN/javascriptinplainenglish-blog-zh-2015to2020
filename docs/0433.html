<html>
<head>
<title>I created the exact same app in React and Redux. Here are the differences.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在React和Redux中创建了完全相同的应用程序。以下是不同之处。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-created-the-exact-same-app-with-react-and-redux-here-are-the-differences-6d8d5fb98222?source=collection_archive---------0-----------------------#2019-10-14">https://javascript.plainenglish.io/i-created-the-exact-same-app-with-react-and-redux-here-are-the-differences-6d8d5fb98222?source=collection_archive---------0-----------------------#2019-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="83fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Redux的初学者指南，以及React内置的有Redux和没有Redux的确切应用程序的并行代码比较。</h2></div><h1 id="4a77" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">因为学习Redux可能很难——刚开始。</h1><p id="2e36" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一旦你学会了如何使用React，并且自信地开发了一些应用程序，这种感觉会很棒。你能够管理状态，一切似乎都很好。然而，很有可能到了你必须学习Redux的时候。</p><p id="963f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这可能是因为您正在开发的应用程序变得越来越大，您发现自己到处都在传递状态，需要一种更好的方法来管理您的数据。或者，这可能只是因为你已经注意到，大量的招聘广告需要了解Redux以及反应。无论哪种方式，知道如何使用Redux都是一个很好的知识，因此，你应该学会它。</p><p id="1060" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然而，有一件事很难理解，那就是为了理解它是如何工作的，你必须要考虑大量的额外代码。我个人也觉得那里的文档，包括官方的Redux文档，展示了如此多的使用Redux的不同方法，以至于Redux不再让人感觉触手可及。</p><p id="ee43" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在某种程度上，这是一件好事，因为它鼓励你以你认为合适的方式使用Redux，而不是说<em class="ly">“这正是你应该使用它的方式，如果你不这样做，那么你就是一个糟糕的开发人员”。</em>然而，只有当你知道你在用Redux做什么的时候，这种美好才会到来，在那之前，它只会让你很难学会。</p><p id="ccb9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">那么我们要怎么学习Redux呢？</p><h2 id="18ff" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">通过用React构建一个app，然后用Redux构建一模一样的app！</h2><p id="8c46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">哦，顺便说一下，当我说“<em class="ly">用Redux </em>构建一个应用”时，我们仍然在使用React——我们只是用Redux管理数据流。但从这里开始，除了沿途的一些切线，当我提到用Redux构建的app时，我真正的意思是用React和Redux构建。</p><h1 id="24e8" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">无论如何，这个介绍已经比我预期的要长了。因此，让我们先来快速了解一下这两款应用的外观:</h1><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/d604c0928972c2e277268a2b95655425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*keix6CuSiFKK9ID0KIB_CQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">React vs Redux. Not a battle as such, but rather a variation of approach to your app.</figcaption></figure><p id="3d78" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因为这两个React应用都是用<strong class="kz ir"> create-react-app、</strong>创建的，它们的文件结构基本相同，除了redux应用内的<strong class="kz ir"> redux </strong>文件夹。现在让我们来看看文件结构:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nb"><img src="../Images/1d84f715d394050890cc7d9d850e8ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkZz-VB06LQV2kfywMGAsw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">React on the left. Redux on the right.</figcaption></figure><p id="a51d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，假设这两个应用程序实现了完全相同的事情，你可能会想为什么Redux需要这么多额外的文件，以及它们的用途是什么。</p><p id="8c1e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您将注意到的第一件事是，为了让Redux为您的应用程序设置，需要大量的初始样板代码。这在很大程度上是它所应用的心智模型——Redux也植根于函数式编程，但是让我们把这个兔子洞留到另一个场合。无论如何，当构建更大的应用程序时，这些额外的代码真的很有价值，这些应用程序有大量的数据从各种组件、API等流入流出。一开始，这个简单的应用程序看起来有点大材小用，但是请坚持使用我们，因为我们并不是鼓励你在简单的应用程序中使用Redux，而是我们在一个简单的应用程序中使用它，以便让Redux更容易掌握和理解。</p><h1 id="c732" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">在我们深入研究代码之前，让我们先向前推进，多解释一下Redux。</h1><p id="d8ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Redux通过三个关键原则处理数据流:</p><h2 id="1b0b" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated"><strong class="ak"> 1。商店</strong></h2><p id="1225" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也称为单一来源的真理，存储基本上只是一个对象，你用一些状态初始化，然后每当我们想更新它，我们用它的新版本覆盖存储。无论如何，您可能已经在React应用程序中使用了这些相同的原则，因为通常认为最好的做法是重新创建状态，而不是改变它。为了进一步澄清这里的区别，如果我们有一个数组，我们想把一个新的条目压入其中，我们不会通过把一个新的条目压入数组来更新我们的存储，而是用它的一个更新版本来覆盖存储。</p><h2 id="9e2e" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">2.还原剂</h2><p id="bf6d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以我们的商店通过一个叫做reducer的东西来更新。这些基本上是我们发送新版本状态的机制。这可能还没有多大意义，所以让我们详细说明一下。假设我们有一个store对象，它有一个如下所示的数组:<code class="fe nc nd ne nf b">list: [{‘id: 1, text: ‘clean the house’}]</code>。如果我们有一个向数组中添加新项目的函数，我们的reducer将向我们的商店解释商店的新版本将是什么样子。所以在我们的<code class="fe nc nd ne nf b">list</code>数组的情况下，我们可能会获取我们的列表的内容，通过<code class="fe nc nd ne nf b">...</code>语法将它和我们想要添加的新项目一起传播到一个新的<code class="fe nc nd ne nf b">list</code>数组中。因此，我们用于添加新项目的缩减器可能看起来像这样:<code class="fe nc nd ne nf b">list: [...list, newItem]</code>。这也是我们在这里讨论如何为商店创建新的状态副本，而不是将新的项目推入商店的现有部分时的意思。</p><h2 id="a506" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">3.行动</h2><p id="26c1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，为了让我们的reducers知道哪些新数据要放入我们的状态，他们可以访问一个有效载荷。这个有效载荷通过一个动作发送给我们的reducer。就像我们创建的任何功能一样，一个动作通常可以通过props在我们应用程序的组件中访问。因为这些动作在我们的组件中，所以我们可以向它们传递参数——这些参数成为有效负载。</p><h2 id="b42f" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated"><strong class="ak">考虑到这一点，</strong></h2><p id="170d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以这样看待Redux:我们的应用程序可以访问<strong class="kz ir">动作。</strong>这些动作从我们的应用程序中携带数据(或通常所说的有效载荷)。<strong class="kz ir">动作</strong>具有与<strong class="kz ir">减速器</strong>共用的类型。每当<strong class="kz ir">动作</strong> <em class="ly">类型</em>被触发时，它就获取有效载荷并告诉我们的<strong class="kz ir">存储</strong>它现在应该是什么样子——我们通常指的是我们的数据对象现在应该是什么样子，因为它已经被更新了。</p><h2 id="928b" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">这个Redux心智模型还有其他部分，比如动作创建者和动作类型，等等——但是这些额外的元素并不是我们的To Do应用程序所必需的。</h2><p id="21ca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里的Redux设置对您来说可能是一个很好的起点，当您开始更熟悉Redux时，您可能会决定偏离这个设置。考虑到这一点，虽然我最初说过Redux文档可能有点令人不知所措，但是在创建自己的设置时，回顾所有不同的方法应该被视为灵感的来源。</p><h2 id="abd9" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated"><strong class="ak">向React应用添加Redux。</strong></h2><p id="e7c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，我们可以像创建React应用程序一样创建React应用程序。之后，使用yarn或npm安装以下两个包:<code class="fe nc nd ne nf b">redux</code>和<code class="fe nc nd ne nf b">react-redux</code>然后就万事大吉了！还有一个叫做<code class="fe nc nd ne nf b">redux-devtools-extension</code>的开发依赖项，在确保你的Redux应用按照你想要的方式运行时，它会非常有用。然而，它是可选的，所以如果你不想安装，不要觉得你必须安装它。</p><h1 id="16f9" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><strong class="ak">我们之前提到过所有的样板文件。让我们解释一下它的作用。</strong></h1><p id="d4da" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将从查看应用程序的根文件开始，这个文件是<strong class="kz ir"> main.js </strong></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ng"><img src="../Images/040a16760e529bc47dd03561a742e3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICwkrzFNIp2QNKPyYDjDEA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">main.js</figcaption></figure><p id="bee5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里我们有五个导入。前两个是针对React的，所以我们不会费心讨论它们，第五个导入只是我们的<code class="fe nc nd ne nf b">App</code>组件。第三和第四个进口是我们将重点关注的。第三个入口，<code class="fe nc nd ne nf b">Provider</code>基本上是我们Redux商店的入口(我们之前谈到过的东西)。实际上，这种工作方式还有更多的内容，因为我们需要选择哪些组件可以访问我们的商店，但是我们稍后将讨论这种工作方式。</p><p id="b65e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">正如您将看到的，我们用一个<code class="fe nc nd ne nf b">&lt;Provider&gt;</code>组件包装了我们的<code class="fe nc nd ne nf b">&lt;App/&gt;</code>组件。从上面的截图中你还会注意到一件事，那就是我们的<code class="fe nc nd ne nf b">Provider</code>得到了一个商店道具，我们在变量<code class="fe nc nd ne nf b">store</code>中传递了这个道具。你会看到我们的第四个导入，<code class="fe nc nd ne nf b">configureStore</code>实际上是一个我们已经导入的函数，然后将它的输出返回给我们的<code class="fe nc nd ne nf b">store</code>变量，如下:<code class="fe nc nd ne nf b">const store = configureStore();</code>。</p><p id="4b81" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在这个<code class="fe nc nd ne nf b">configureStore</code>基本上，你可能已经猜到了，是我们的商店配置。这包括我们想要传入的初始状态。这是一个实际上由我们自己创建的文件，稍后我们将对此进行更详细的讨论。简而言之，我们的<strong class="kz ir"> main.js </strong>文件导入我们的存储，并用它包装我们的根<code class="fe nc nd ne nf b">App</code>组件，从而提供对它的访问。</p><p id="c60a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">不幸的是，需要更多的样板文件，所以让我们向前一步，看看我们的根<code class="fe nc nd ne nf b">App</code>组件中的附加代码:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nh"><img src="../Images/bf4cfde65549298a6d2d12a7864b3d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3INPBf8WehOqh0O6jUL6eQ.png"/></div></div></figure><p id="82f9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">所以我们有另一个包含五个导入的文件。第一个是React，第四个是React组件，第五个是css文件，所以我们不要再讨论这些了。还记得我说过，我们如何为组件提供对商店的访问，还有更多内容吗？这就是我们的第二个导入，<code class="fe nc nd ne nf b">connect</code>开始发挥作用的地方。</p><p id="cd48" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果你看上面截图的底部，你会看到我们没有导出我们的<code class="fe nc nd ne nf b">App</code>组件，而是导出了<code class="fe nc nd ne nf b">connect</code>，这基本上是一个curried函数。curried函数基本上是一个返回另一个函数的函数。<code class="fe nc nd ne nf b">connect</code>在这里所做的基本上是获取<code class="fe nc nd ne nf b">mapStateToProps</code>和<code class="fe nc nd ne nf b">mapDispatchToProps</code>的内容——我们稍后将讨论这两个内容——然后获取我们的<code class="fe nc nd ne nf b">App</code>组件并将<code class="fe nc nd ne nf b">mapStateToProps</code>和<code class="fe nc nd ne nf b">mapDispatchToProps</code>的内容添加到其中，最后返回添加了新功能的<code class="fe nc nd ne nf b">App</code>组件。原来如此，但是那些<code class="fe nc nd ne nf b">mapStateToProps</code>和<code class="fe nc nd ne nf b">mapDispatchToProps</code>的内容是什么呢？</p><p id="0c86" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">嗯，<code class="fe nc nd ne nf b">mapStateToProps</code>从我们的存储中获取状态，并将其作为道具传递给我们连接的<code class="fe nc nd ne nf b">App</code>组件。在这种情况下，我们给它一个<code class="fe nc nd ne nf b">list</code>的键，因为它遵循了我们在商店内部给它的命名约定(稍后会有更多介绍)。不过我们不需要遵循这个约定，我们可以随意命名它——无论如何，<code class="fe nc nd ne nf b">list</code>是我们在应用程序中想要访问州的特定部分时所引用的名称。现在你会看到<code class="fe nc nd ne nf b">mapStateToProps</code>是一个以<code class="fe nc nd ne nf b">state</code>为参数的函数。在这种情况下，<code class="fe nc nd ne nf b">state</code>基本上就是我们的<code class="fe nc nd ne nf b">store</code>对象(稍后会详细介绍)。但是作为参考，如果我们把一个<code class="fe nc nd ne nf b">console.log('store', store)</code>放在<code class="fe nc nd ne nf b">mapStateToProps</code>里面，就像这样:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a77074d52702fba2839bfb94839df3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*8o49j_wfBTDR_NsVZWZsYg.png"/></div></figure><p id="98fc" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这是输出结果:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/07944ec426dcd468cd100d4e0624db88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*VAnNW9WGRJNuyO-OvuDr4g.png"/></div></figure><p id="db52" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">记住这一点，我们基本上只是访问我们的<code class="fe nc nd ne nf b">store</code>的某些部分，并且我们通过props将这些部分附加到我们的<code class="fe nc nd ne nf b">App</code>——在这种情况下，我们可以从控制台中看到我们的状态是一个名为<code class="fe nc nd ne nf b">appReducer</code>的对象，其中包含一个<code class="fe nc nd ne nf b">list</code>数组。因此，我们通过我们的<code class="fe nc nd ne nf b">mapStateToProps</code>函数将它附加到我们的<code class="fe nc nd ne nf b">App</code>组件，该函数返回一个键为<code class="fe nc nd ne nf b">list</code>值为<code class="fe nc nd ne nf b">state.appReducer.list</code>的对象。起初这一切看起来有点陌生和冗长，但希望这有助于分解这里正在发生的事情。</p><p id="35a5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">那么<code class="fe nc nd ne nf b">mapDispatchToProps</code>呢？这将我们带到我们的<strong class="kz ir"> App.js </strong>文件中的第三个导入，即<code class="fe nc nd ne nf b">appActions</code>。这是我们创建的另一个文件，我们稍后将深入研究它。现在，我们只需要知道<code class="fe nc nd ne nf b">mapDispatchToProps</code>是一个普通的对象，它接受我们将要创建的<strong class="kz ir">动作</strong>，并将它们作为道具传递给我们连接的<strong class="kz ir">应用</strong>组件。在Redux术语中，<strong class="kz ir">分派</strong>指的是<em class="ly">分派一个动作</em>，这基本上是我们在执行一个函数的一种花哨说法。所以<code class="fe nc nd ne nf b">mapDispatchToProps</code>有点像说mapFunctionsToProps，或者mapActionsToProps。然而，React文档称之为mapDispatchToProps，所以我们在这里将坚持这个命名约定。</p><p id="3368" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里我想注意的一点是，在一个典型的大型React应用程序中，我们的<code class="fe nc nd ne nf b">mapStateToProps</code>函数可能在返回的对象中有许多不同的键/值对。这也可能来自Redux应用程序中的<strong class="kz ir">商店</strong>的各种不同的<strong class="kz ir">减速器</strong>，因为如果需要，您可以拥有商店的访问点。同样的情况也适用于<code class="fe nc nd ne nf b">mapDispatchToProps</code>，从某种意义上来说，虽然我们的simple To Do应用程序只有一个文件来管理我们的操作——<code class="fe nc nd ne nf b">appActions</code>——一个更大的应用程序可能有几个文件来管理特定于应用程序某些部分的操作。你的<code class="fe nc nd ne nf b">mapDispatchToProps</code>文件可以从不同的地方获取动作，然后将它们作为道具传递给你的<code class="fe nc nd ne nf b">App</code>组件。同样，如何选择编写应用程序完全取决于您自己。</p><p id="3756" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们已经看了从Redux溢出到我们的根文件中的主要样板文件，现在让我们看看在我们的<strong class="kz ir"> Redux </strong>文件夹中发生了什么，在最后看一下我们如何在我们的React子组件中把所有这些放在一起(这里我指的是不是根<strong class="kz ir"> App.js </strong>组件的任何东西)。</p><h2 id="e7ae" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">Redux文件夹</h2><p id="f757" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里有很多东西需要打开。在我们开始之前，让我们再看一下我们的应用程序的文件结构:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9a72a373b6ea6c8b6483ab293a157c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*JsqDyA2Wy_08GnHS6SMDmw.png"/></div></figure><p id="5e7a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们将按照上面截图中文件出现的顺序来解决这个问题:</p><h2 id="99d8" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">行动</h2><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nl"><img src="../Images/bf5e6a47143606e8f733a23a8c5181a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEm7wWtXfj9znjnvTUUgvw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">actions/appActions.js</figcaption></figure><p id="e0f8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们记得前面的话，我们的<strong class="kz ir"> appActions </strong>文件就是我们导入到<strong class="kz ir"> App.js </strong>文件中的文件。这包含了从我们的应用程序中携带数据(也称为有效载荷)的函数。对于我们的待办事项应用程序，我们需要三项功能:</p><ol class=""><li id="c3ca" class="nm nn iq kz b la lt ld lu lg no lk np lo nq ls nr ns nt nu bi translated">保存输入数据的能力</li><li id="dbc0" class="nm nn iq kz b la nv ld nw lg nx lk ny lo nz ls nr ns nt nu bi translated">添加项目的能力</li><li id="6545" class="nm nn iq kz b la nv ld nw lg nx lk ny lo nz ls nr ns nt nu bi translated">删除项目的能力</li></ol><p id="74dd" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，第一个功能——<em class="ly">保存输入数据的能力</em>——实际上将在我们的<strong class="kz ir"> ToDo </strong>组件内部进行本地处理。我们本可以选择以“Redux方式”来处理这种情况，但我想证明，如果在您看来这样做没有意义，那么并非所有事情都必须通过Redux来处理。在这种情况下，我想简单地在组件级别处理输入数据，同时用Redux在中央级别维护实际的待办事项列表。因此，让我们来看看另外两个必需的功能:添加和删除条目。</p><p id="8749" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这些函数只需要一个有效载荷。对于添加新的待办事项，我们需要传递的有效负载很可能是新的待办事项。因此，我们的函数最终看起来像这样:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5d06e74fbc21875ec7260e37ec2455c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*RMiolWpmLYKa6WBpjsc8uQ.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">appActions.js</figcaption></figure><p id="01d9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们在这里看到，这个函数接受一个我选择调用的参数<code class="fe nc nd ne nf b">todo</code>，并返回一个有<code class="fe nc nd ne nf b">type</code>和<code class="fe nc nd ne nf b">payload</code>的对象。我们将<code class="fe nc nd ne nf b">todo</code>参数的值分配给<code class="fe nc nd ne nf b">payload</code>键。现在，正如您可能从上面的截图中注意到的，这里的<code class="fe nc nd ne nf b">types</code>实际上是从我们的<strong class="kz ir"> actionTypes </strong>文件夹中导入的变量，但是更多的是关于动作类型的。</p><p id="7b09" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们也有<code class="fe nc nd ne nf b">redux_delete</code>功能，将<code class="fe nc nd ne nf b">id</code>作为其有效载荷，以便我们附带的减速器知道要移除哪个待办事项。最后，我们有一个<code class="fe nc nd ne nf b">appActions</code>对象，它将我们的<code class="fe nc nd ne nf b">redux_add</code>和<code class="fe nc nd ne nf b">redux_delete</code>功能作为关键字和值。这也可以写成:</p><pre class="mm mn mo mp gt ob nf oc od aw oe bi"><span id="e353" class="lz kg iq nf b gy of og l oh oi">const appActions = {<br/>    redux_add: redux_add,<br/>    redux_delete: redux_delete<br/>};</span></pre><p id="d761" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果那样对你更有意义。我还想知道这里使用的所有命名，比如<code class="fe nc nd ne nf b">appActions</code>和我们函数的前缀<code class="fe nc nd ne nf b">redux_</code>不是要求，它只是我自己的命名约定。</p><h2 id="c1c0" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">操作类型</h2><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2cd119af60ff9bbf00c465bcc82037e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*FIvVsvoU9WnqaPRDBLXgJA.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">actionTypes/index.js</figcaption></figure><p id="ffea" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在你可能还记得我之前提到过，有一种方式，我们的减少者和行动者知道如何相互作用——这是通过使用<strong class="kz ir">类型</strong>。我们的<strong class="kz ir">减速器</strong>也将访问这些相同的<strong class="kz ir">动作类型</strong>。正如您所看到的，这些只是变量，其名称与分配给它的字符串相匹配。</p><p id="3884" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这一部分并不完全必要，如果您愿意，您可以避免完全创建这个文件和模式。然而，我们这样做是作为Redux的最佳实践，因为它为我们所有的<strong class="kz ir">动作类型</strong>提供了一个中心位置，这减少了我们需要更新的地方。考虑到我们的<strong class="kz ir">减速器</strong>也将使用这些，我们可以确信名称总是正确的，因为我们总是将它们从一个地方拉进来。说起<strong class="kz ir">减速机</strong> …</p><h2 id="e7c1" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">还原剂</h2><p id="2d6f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里有两个部分:我们的appReducer和我们的rootReducer。在较大的应用程序中，您可能会有许多不同的减压器。这些都将被拉入您的rootReducer中。在我们的例子中，考虑到我们应用程序的小尺寸，我们本可以用一个减速器来处理这个问题。然而，我选择在这里保留两个，因为您可能会以这种方式操作。哦，这里的名字是我的惯例——你可以随便叫你的减速器。</p><p id="d52c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们看看我们的<strong class="kz ir">评估器</strong>。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ok"><img src="../Images/391ec3d6602e47aaa3afd1218d6010cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxEAqE4DkEQ2l-Ed2w8Drg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">reducers/appReducer.js</figcaption></figure><p id="c200" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们看到的第一件事是，我们正在导入与我们的<strong class="kz ir">动作</strong>相同的<strong class="kz ir">动作类型</strong>。下一位是我们的<code class="fe nc nd ne nf b">initialState</code>变量，它是我们的状态。这是我们将用来初始化我们的商店，以便我们有一些初始状态开始。如果你不需要任何初始状态，你可以在你自己的项目中选择一个空对象——同样，这取决于对你的项目起作用的任何东西。</p><p id="6eed" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">下一位是我们的<code class="fe nc nd ne nf b">appReducer</code>函数，它有两个参数:第一个是一个<code class="fe nc nd ne nf b">state</code>参数，它是我们想要开始的状态。在我们的例子中，我们使用默认参数将第一个参数默认为我们的<code class="fe nc nd ne nf b">initialState</code>对象。这阻止了我们进一步传递任何东西。第二个参数是我们的<code class="fe nc nd ne nf b">action</code>。现在，每当我们的<code class="fe nc nd ne nf b">appActions.js</code>文件中的一个函数被触发时，这个<code class="fe nc nd ne nf b">appReducer</code>函数就会被触发——我们稍后会看到这些函数是如何被触发的，但现在只需知道这些函数最终会在我们的<strong class="kz ir"> ToDo.js </strong>文件中结束。总之，每次这些函数中的一个被触发时，我们的<code class="fe nc nd ne nf b">appReducer</code>会运行一系列的<code class="fe nc nd ne nf b">switch</code>语句来找到与传入的<code class="fe nc nd ne nf b">action.type</code>相匹配的语句。为了了解被触发的数据是什么样的，让我们用<code class="fe nc nd ne nf b">console.log </code>表示<code class="fe nc nd ne nf b">action</code>，如下所示:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ol"><img src="../Images/708cd88abbedf8d07d8c2b56ddcff9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uL9V7Gv5d9ZJ8M-Htx5kEA.png"/></div></div></figure><p id="f4be" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，在我们的应用程序中，假设我们创建了一个新的待办事项，在输入框中输入“拿出垃圾”并按下+按钮。执行此操作时，我们会在控制台中看到以下内容:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi om"><img src="../Images/714916199638486d307e72d4bea33e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdkIFXWl_Rk7j-1Pn9V_SA.png"/></div></div></figure><p id="e349" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在除了有效载荷，我们可以看到我们的<code class="fe nc nd ne nf b">action</code>有一个<code class="fe nc nd ne nf b">"ADD_ITEM"</code>的<code class="fe nc nd ne nf b">type</code>。这与我们的<code class="fe nc nd ne nf b">switch</code>语句中的<code class="fe nc nd ne nf b">ADD_ITEM</code>变量相匹配:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi on"><img src="../Images/c157dfb8a1aaa7d312a337740e83ea67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*DVZxb58zR2AUA3cKISvwFQ.png"/></div></figure><p id="5944" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">当有匹配时，它执行这个，这基本上告诉我们的存储它的新状态应该是怎样的。在这种情况下，我们告诉我们的存储，状态现在应该等于一个<code class="fe nc nd ne nf b">list</code>数组，它包含<code class="fe nc nd ne nf b">list</code>数组以前的内容，以及我们传入的新的<code class="fe nc nd ne nf b">payload</code>，如果我们再看一下控制台中记录的内容:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi om"><img src="../Images/714916199638486d307e72d4bea33e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdkIFXWl_Rk7j-1Pn9V_SA.png"/></div></div></figure><p id="5218" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在记住，<code class="fe nc nd ne nf b">action</code>承载有效载荷——这部分由我们在<strong class="kz ir"> appActions.js </strong>中看到的<strong class="kz ir">动作</strong>处理。我们的<strong class="kz ir">减速器</strong>拾取<strong class="kz ir">动作</strong>并根据哪个<code class="fe nc nd ne nf b">action.type</code>匹配进行处理。</p><p id="5362" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在让我们来看看我们的<strong class="kz ir"> rootReducer </strong>:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4b054f14141371eaf0ce56b73385e4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*9vjdndETtZAlVxv5LDaCzA.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">reducers/index.js</figcaption></figure><p id="4d58" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们的第一个进口货是<code class="fe nc nd ne nf b">combineReducers</code>。这是一个Redux helper函数，它基本上收集了所有不同的reducers，并将它们转换成一个对象，然后可以将该对象传递给我们的<code class="fe nc nd ne nf b">store</code>中的<code class="fe nc nd ne nf b">createStore</code>函数，稍后我们将对此进行介绍。第二个导入是我们之前创建和讨论的<code class="fe nc nd ne nf b">appReducer</code>文件。</p><p id="f568" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如前所述，我们并不真的需要这一步，因为我们的应用程序相当简单，但我决定出于学习目的保留这一步。</p><h2 id="1b20" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">商店</h2><p id="b8da" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们来看看我们的<strong class="kz ir"> configureStore.js </strong>文件:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi op"><img src="../Images/08d393a5b35b0f36dc6da50989c4fa02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*WU0qbOh-zuEkLMN6VCqu0Q.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">store/configureStore.js</figcaption></figure><p id="7f27" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里的第一个导入是<code class="fe nc nd ne nf b">createStore</code>，它保存了应用程序的完整状态。只能有一家<strong class="kz ir">店</strong>。你可以有许多有自己<code class="fe nc nd ne nf b">initialState</code>的减速器。理解这里的区别很重要，基本上你可以有许多提供某种形式状态的<strong class="kz ir">还原器</strong>，但是你只能有一个<strong class="kz ir">存储器</strong>从你的<strong class="kz ir">还原器</strong>中获取所有数据。</p><p id="1597" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这里的第二个导入是我们的<code class="fe nc nd ne nf b">rootReducer</code>，我们之前已经介绍过了。您将看到创建了一个名为<code class="fe nc nd ne nf b">configureStore</code>的简单函数，它将我们的<code class="fe nc nd ne nf b">createStore</code>导入作为一个函数返回，该函数将我们的<code class="fe nc nd ne nf b">rootReducer</code>作为其唯一的参数。</p><p id="e7d5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">同样，这是我们可以跳过的，只需在我们的根<code class="fe nc nd ne nf b">index.js</code>文件中创建存储。相反，我将它保存在这里，因为您可能会发现自己为您的<strong class="kz ir">商店</strong>做了很多配置。这可以从设置中间件到启用额外的Redux开发工具。这种情况很常见，但如果现在就讨论这些就太过分了，我已经从<code class="fe nc nd ne nf b">configureStore</code>中删除了这个应用不需要的任何东西。</p><p id="44ac" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好了，现在我们已经在我们的<strong class="kz ir"> Redux </strong>文件夹中设置好了一切，并且我们已经将Redux连接到我们的<strong class="kz ir"> index.js </strong>文件和我们的根<strong class="kz ir"> App.js </strong>组件。现在怎么办？</p><h1 id="a632" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">在我们的应用中触发Redux功能</h1><p id="428e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们现在在最后冲刺阶段。我们已经设置好了一切，我们连接的组件可以通过<code class="fe nc nd ne nf b">mapStateToProps</code>访问我们的商店，通过<code class="fe nc nd ne nf b">mapDispatchToProps</code>访问我们的动作，就像<code class="fe nc nd ne nf b">props</code>一样。我们像平常在React中一样访问这些道具，但仅供参考:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oq"><img src="../Images/e55eb706177dd9ebcfe8621baee9568f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vg6wad_A4ZrccNtju-0W7g.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">ToDo.js</figcaption></figure><p id="afb8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这三个道具和我们传入的是一样的:<code class="fe nc nd ne nf b">list</code>包含我们的<code class="fe nc nd ne nf b">state</code>，而<code class="fe nc nd ne nf b">redux_add</code>和<code class="fe nc nd ne nf b">redux_delete</code>是我们的添加和删除函数。</p><p id="85c9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然后我们只在需要的地方使用它们。在我们的例子中，我维护了我在我们的<em class="ly"> vanilla </em> React应用程序中使用的相同函数，除了不是使用来自<code class="fe nc nd ne nf b">useState</code>钩子的某种<code class="fe nc nd ne nf b">setList()</code>函数在本地更新状态，而是使用所需的有效负载调用我们的<code class="fe nc nd ne nf b">redux_add</code>或<code class="fe nc nd ne nf b">redux_delete</code>函数。让我们来看看:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi or"><img src="../Images/8dc4e0db79668a59dc00c80231943cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*7cNlST2c2HkPlJxZMh3l2g.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Adding items</figcaption></figure><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi os"><img src="../Images/1b508d27e6c61eb174c93bd3da9ff242.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*gASgWhpr7Kgf1Np6k_418g.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Deleting items</figcaption></figure><p id="ab02" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们用我们的<code class="fe nc nd ne nf b">deleteItem</code>函数来回顾导致应用程序状态更新的每一步。</p><p id="e3f0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><code class="fe nc nd ne nf b">redux_delete</code>从我们想要删除的待办事项中获取ID。</p><p id="b415" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果我们看一下我们的<strong class="kz ir"> appActions.js </strong>文件，我们会看到我们传入的ID变成了我们的<code class="fe nc nd ne nf b">payload</code>的值:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/a6b3ced66337fd61eb725f012f104bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*10BNKVbaiHboGufgFw5tUw.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">appActions.js</figcaption></figure><p id="d3a7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然后我们在我们的<strong class="kz ir"> appReducer.js </strong>文件中看到，无论何时在我们的<code class="fe nc nd ne nf b">switch</code>语句中命中<code class="fe nc nd ne nf b">DELETE_ITEM</code>类型，它都会返回我们状态的一个新副本，其中过滤掉了来自有效负载的ID:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ou"><img src="../Images/088a6c1508afe62e559ba457e77baa1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6xAkY-p-6EZbVV4vxGHvkw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">appReducer.js</figcaption></figure><p id="c7c5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">随着新状态的更新，应用程序中的UI也会更新。</p><h1 id="1b58" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">这就是Redux！</h1><p id="42d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们已经了解了如何将Redux添加到React项目中，如何配置存储，如何创建携带数据的动作，以及如何创建更新存储的reducers。我们还研究了如何将我们的应用程序连接到Redux，以便能够访问我们的所有组件。我希望你已经发现这很有用，并且已经更好地理解了一个应用程序如何使用Redux。</p><h2 id="d157" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">但是等等，刚刚用的app that呢？我以为这是个比较品？</h2><p id="346b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的目标是创建一个功能与React完全相同的应用程序。然而，在写这篇文章时，很明显需要花很多时间来解释Redux是如何工作的，所以它最终变成了Redux的初学者指南，演示如何将Redux添加到现有的React应用程序中。现有的有问题的React应用程序已经在这里审查过了:<a class="ae ov" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56" rel="noopener"> <strong class="kz ir">我创建了与React和Vue中创建的完全相同的应用程序。这里是差异</strong>。</a>所以请随时查看，这样您就可以自己查看不同之处。</p><h2 id="7009" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">你是否考虑过使用Redux挂钩来帮助简化一些代码？</h2><p id="335a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我确实做了！事实上，我写了一篇关于这个主题的文章——我强烈建议你继续阅读，找出如何减少React-Redux的一些样板文件:<a class="ae ov" href="https://medium.com/javascript-in-plain-english/how-i-reduced-the-amount-of-code-in-my-redux-app-by-using-redux-hooks-b19c926419ea" rel="noopener">https://medium . com/JavaScript-in-plain-English/how-I-Redux-app-by-using-Redux-hooks-b19c 926419 ea</a></p><h1 id="51cb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Github链接到两个应用程序:</h1><p id="ace1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">react ToDo:<a class="ae ov" href="https://github.com/sunil-sandhu/react-todo-2019" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/react-todo-2019</a></p><p id="5142" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">redux ToDo:<a class="ae ov" href="https://github.com/sunil-sandhu/redux-todo-2019" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/redux-todo-2019</a></p><p id="a2f4" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果您对本文中使用的样式感兴趣，并想制作您自己的等效作品，请随时这样做！👍</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="ow ox l"/></div></figure></div></div>    
</body>
</html>