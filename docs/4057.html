<html>
<head>
<title>How React Works Under the Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React是如何工作的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-react-works-under-the-hood-277356c95e3d?source=collection_archive---------1-----------------------#2020-11-13">https://javascript.plainenglish.io/how-react-works-under-the-hood-277356c95e3d?source=collection_archive---------1-----------------------#2020-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/5a9b1e657c9863721582843be5705f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWENYA3e4lvnU8VG5i2rhA.jpeg"/></div></div></figure><div class=""/><p id="e333" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React是一个非常流行的JavaScript库。今天，许多创业公司选择React作为他们为项目构建快速前端应用程序的工具。它的周下载量超过550万次，但没有多少开发人员知道React实际上是如何工作的。</p><p id="6fd0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">浏览不同的文档可能会令人沮丧，因此在本文中，我将尝试解决这个问题，并尽我所能解释React的内部工作方式。有很多内容要讲，所以我们开始吧。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/d069289573095a3784f6fd25fd376cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*-CugooARsfVr8yZDmfEyyA.png"/></div></figure><p id="3d9f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与Angular或Vue不同，React实际上只是普通的JavaScript，所以如果你知道JS的语法，知道一点状态管理，知道一点组件，你就可以开始使用React了。</p><h1 id="085a" class="ky kz iy bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">反应虚拟DOM</h1><p id="af7f" class="pw-post-body-paragraph jv jw iy jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">在它的核心，React只是为你维护一棵树，它会在节点上进行有效的差分计算。你的HTML代码很像一棵树，或者至少你的浏览器是这样对待它的。它构建了通常所说的文档对象模型或DOM。</p><p id="2ecb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">HTML DOM很大程度上是一个修改其中节点的接口(API)。它包含不同的方法，如<em class="mb"> getElementById </em>或新的<em class="mb"> querySelector </em>来定位每个节点，我们使用JS来处理DOM。这意味着每当我们想要改变内容时，我们都要修改DOM，但这相当昂贵。为什么相当贵，这是个问题。</p><p id="b27c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您至少对React有所了解，那么您可能听说过虚拟DOM，对吗？</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/22713fd46a6bc8f60c5f182f144d9451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*O_kuBbQwiF-U7a0_Kg6qQQ.png"/></div></figure><p id="b188" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能听说过<em class="mb">虚拟DOM </em>和<em class="mb">真实DOM </em>的区别在于前者要快得多。嗯，这是真的……算是吧。DOM对象实际上与真正的DOM对象具有相同的属性，但是速度上的差异是因为它不影响屏幕上的任何东西。V.DOM只是DOM的一个<em class="mb">表示</em>，但是它是轻量级的，并且与特定于浏览器的实现细节无关。更容易将V.DOM视为真实事物的蓝图。</p><p id="eb91" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在V.DOM中改变一些东西与在真实DOM中改变一些东西没有太大的区别。真正的区别是在那之后。当我们在浏览器中更改真正的DOM时，会触发布局和重画，这需要额外的资源，非常昂贵。这意味着我们必须避免接触DOM，尽可能地并且应该只改变那里的一些东西，当绝对确定这是最小的行动过程时。</p><p id="576f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，JS现在做的是检查所有的元素，如果检测到变化，它就改变整个元素容器。</p><p id="201a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React和类似的框架是如何解决这个问题并加速这个过程的，它找到了更新DOM所需的最小变化。我们的V.DOM会添加牛奶，将其与更新之前拍摄的DOM快照进行比较，找出变化最小的地方，并只更新<strong class="jx iz"> <em class="mb">这些变化。</em> </strong></p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi md"><img src="../Images/386a269d9a80c5cee5a98531223e4233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*eQWHqquDnrPL3VV0BzUIvQ.png"/></div></figure><p id="a62f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可能会问。"如果V.DOM和DOM是一样的，为什么会更快？"。正如我所说，V.DOM不接触屏幕，这意味着它不处理任何绘画和计算。它只是在蓝图上画出差异，告诉DOM，DOM只更新特定的元素，这大大减少了压力。</p><h1 id="546e" class="ky kz iy bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak"> JSX </strong></h1><p id="5fa2" class="pw-post-body-paragraph jv jw iy jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">你可能听说过JSX，但它到底是什么？它是做什么的？从根本上说，JSX只是为<code class="fe me mf mg mh b">React.createElement(component, props, ...children)</code>函数提供了语法上的好处。JSX电码</p><pre class="ku kv kw kx gt mi mh mj mk aw ml bi"><span id="ea9b" class="mm kz iy mh b gy mn mo l mp mq">&lt;MyButton color="blue" shadowSize={2}&gt;<br/>  Click Me<br/>&lt;/MyButton&gt;</span></pre><p id="fe55" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译成:</p><pre class="ku kv kw kx gt mi mh mj mk aw ml bi"><span id="863b" class="mm kz iy mh b gy mn mo l mp mq">React.createElement(<br/>  MyButton,<br/>  {color: 'blue', shadowSize: 2},<br/>  'Click Me'<br/>)</span></pre><p id="6429" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JSX标记的第一部分决定了React元素的类型。大写的类型表示JSX标签引用了React组件。这些标签被编译成对命名变量的直接引用，所以如果使用JSX <code class="fe me mf mg mh b">&lt;Foo /&gt;</code>表达式，<code class="fe me mf mg mh b">Foo</code>必须在范围内。<br/>所以，基本上使用JSX和React是<strong class="jx iz">而不是</strong>强制的，但它肯定是更可取的。它看起来非常类似于实际的HTML代码。</p><p id="338a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">会有什么反应？CreateElement到底是做什么的？它只是创建一个普通的JS对象。我们可以看到它，如果我们只是控制台记录它。为此，您只需创建HTML和JS文件。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mr"><img src="../Images/b136900969a9a2a289cbefef800edff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bn4nP67tw5uChg-U2NGbbA.png"/></div></div></figure><p id="95c2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们导入React脚本，并在我们的js文件中编写:</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/159c2bc0ca7e0012c7df3468a111a16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*v43-tW0UFygN9koDkxxOkg.png"/></div></figure><p id="2250" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们将它记录到浏览器中时，我们可以看到</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2eb5618dcc29efa3bdfb7c6d8d37f9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*SFimbD1ZuM5H7rhBi7lzyw.png"/></div></figure><p id="2768" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们在这个div中添加一个p</p><pre class="ku kv kw kx gt mi mh mj mk aw ml bi"><span id="fabd" class="mm kz iy mh b gy mn mo l mp mq">const parentElement = React.createElement(</span><span id="fa33" class="mm kz iy mh b gy mu mo l mp mq">‘div’,</span><span id="7d0f" class="mm kz iy mh b gy mu mo l mp mq">{id: ‘div’},</span><span id="3e95" class="mm kz iy mh b gy mu mo l mp mq">React.createElement(‘p’, {}, ‘A p inside a div’)</span><span id="1327" class="mm kz iy mh b gy mu mo l mp mq">)</span></pre><p id="d5c9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们会得到嵌套的对象。当你开始写嵌套的东西时，想象你有一个div，在这个div里面，你有另一个div，然后里面有一个按钮。它会很快失去控制。因此，JSX帮助你将HTML的简洁带到JavaScript的强大。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mv"><img src="../Images/4cad81f38f42520bd4e365dbc0c2676d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVVyZ0aHlQV08AfZ08hj8w.jpeg"/></div></div></figure><h1 id="baf4" class="ky kz iy bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">呈现React应用程序</h1><p id="73fd" class="pw-post-body-paragraph jv jw iy jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">那么这一切是如何组合在一起的呢？React实际上是如何将我们的组件呈现给浏览器的？遇见ReactDOM。ReactDOM根据节点的“type”属性递归地创建节点，并最终将它们附加到DOM中。它接收两个参数，第一个是追加什么，第二个是追加什么。</p><p id="517d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您曾经使用过create-react-app，您会在public文件夹中看到一个index.html文件，在src子根文件夹中看到一个index.js文件。这些可能是您的应用程序中最重要的文件。你看，React只需要在HTML文件中创建一个<strong class="jx iz">实际的</strong> div，这样它就可以将目标指向那个div，并在某种程度上将其总节点树挂在上面。这就是为什么，当您查看React应用程序时，您很可能会看到一个父div，树的其余部分在某种程度上附加到它上面。</p><p id="8b2e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些是关于React及其工作原理的一些最重要的概念。我意识到还有很多其他的事情，但是我不想把帖子写得太长太无聊。我可能会就这些话题分别发表文章。我希望这对你更好地理解这个美丽的图书馆的内部运作有所帮助。</p><p id="b4c0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请随时给我建议、问题或批评。<br/>保持阳性，检测阴性。和平！</p></div></div>    
</body>
</html>