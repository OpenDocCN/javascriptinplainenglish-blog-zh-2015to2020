<html>
<head>
<title>Plain JavaScript Versions of Lodash Methods to Reverse and Slice Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lodash方法的普通JavaScript版本，用于反转和切片数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/plain-javascript-versions-of-lodash-methods-to-reverse-and-sort-arrays-58d0f3535b0a?source=collection_archive---------14-----------------------#2020-05-04">https://javascript.plainenglish.io/plain-javascript-versions-of-lodash-methods-to-reverse-and-sort-arrays-58d0f3535b0a?source=collection_archive---------14-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8ea583851adc4f69a1abcd13402b1c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uVT1rD5DLOdLdEXw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="699d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="5f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用普通的JavaScript代码替换<code class="fe lb lc ld le b">reverse</code>、<code class="fe lb lc ld le b">slice</code>、<code class="fe lb lc ld le b">tail</code>、<code class="fe lb lc ld le b">takrRight</code>、<code class="fe lb lc ld le b">takeRightWhile</code>和<code class="fe lb lc ld le b">take</code>方法。</p><h1 id="2066" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反面的</h1><p id="34ca" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lb lc ld le b">reverse</code>方法反转数组，使第一个元素变成最后一个，第二个变成倒数第二个，依此类推。</p><p id="9a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个方法是基于<code class="fe lb lc ld le b">Arrar.prototype.reverse</code>的，所以我们不需要使用Lodash的<code class="fe lb lc ld le b">reverse</code>来反转数组。</p><p id="baef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现Lodash的<code class="fe lb lc ld le b">reverse</code>方法:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d3a9" class="mq lg iq le b gy mr ms l mt mu">const reverse = arr =&gt; arr.reverse()</span></pre><p id="6b1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3a5a" class="mq lg iq le b gy mr ms l mt mu">const result = reverse([1, 2, 3]);</span></pre><p id="045d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[3, 2, 1]</code>。</p><h1 id="2f5e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">slice</code></h1><p id="ef2b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash的<code class="fe lb lc ld le b">slice</code>方法返回从开始索引到结束索引的数组切片。我们可以指定<code class="fe lb lc ld le b">start</code>和<code class="fe lb lc ld le b">end</code>索引。</p><p id="e696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它基于<code class="fe lb lc ld le b">Array.prototype.slice</code>所以我们不需要使用它。如果我们真的想要Lodash的<code class="fe lb lc ld le b">slice</code>方法，我们可以如下实现它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="593b" class="mq lg iq le b gy mr ms l mt mu">const slice = (arr, start, end) =&gt; arr.slice(start, end)</span></pre><p id="f142" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是用<code class="fe lb lc ld le b">start</code>和<code class="fe lb lc ld le b">end</code>索引调用了<code class="fe lb lc ld le b">arr</code>的<code class="fe lb lc ld le b">slice</code>方法。</p><p id="4dbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="5b24" class="mq lg iq le b gy mr ms l mt mu">const result = slice([1, 2, 3], 1, 2);</span></pre><p id="bdd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">result</code>就是<code class="fe lb lc ld le b">[2]</code>。</p><h1 id="60fe" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">tail</code></h1><p id="15f4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">方法返回一个除了第一个元素之外的所有元素的数组。</p><p id="c257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1088" class="mq lg iq le b gy mr ms l mt mu">const tail = (arr) =&gt; arr.slice(1)</span></pre><p id="1634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们只是用1调用了<code class="fe lb lc ld le b">slice</code>来排除第一个元素</p><p id="b372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="44cd" class="mq lg iq le b gy mr ms l mt mu">const result = tail([30, 40, 50]);</span></pre><p id="8ebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lb lc ld le b">result</code>就是<code class="fe lb lc ld le b">[40, 50]</code>。</p><h1 id="f927" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">take</code></h1><p id="6e97" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">take</code>返回一个数组的切片，其中<code class="fe lb lc ld le b">n</code>的元素是从开始取的</p><p id="71a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以用<code class="fe lb lc ld le b">slice</code>实现如下:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e3f7" class="mq lg iq le b gy mr ms l mt mu">const take = (arr, n) =&gt; arr.slice(n)</span></pre><p id="5ac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe lb lc ld le b">n</code>作为<code class="fe lb lc ld le b">slice</code>的第一个参数传递会返回一个移除了第一个<code class="fe lb lc ld le b">n</code>条目的数组。</p><p id="a8cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="03d2" class="mq lg iq le b gy mr ms l mt mu">const result = take([30, 40, 50], 2);</span></pre><p id="8a69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[50]</code>。</p><h1 id="2679" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">takeRight</code></h1><p id="9948" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">takeRight</code>方法返回一个数组的切片，其中的<code class="fe lb lc ld le b">n</code>元素从末尾移除。</p><p id="929b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以如下使用<code class="fe lb lc ld le b">slice</code>:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="98ef" class="mq lg iq le b gy mr ms l mt mu">const takeRight = (arr, n) =&gt; arr.slice(0, -n)</span></pre><p id="a2e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将0和<code class="fe lb lc ld le b">-n</code>传递给<code class="fe lb lc ld le b">slice</code>，这样我们就可以返回一个数组，其中包含从第一个到第n个最后一个条目。</p><p id="e0a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7bf4" class="mq lg iq le b gy mr ms l mt mu">const result = takeRight([30, 40, 50], 2);</span></pre><p id="7271" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[30]</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/197865447ffce0d0d7707f8d5b5866d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7MjoLzVrp0m51s2U"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pixtolero2?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Eledut</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="69a4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">takeRightWhile</code></h1><p id="63e9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">takeRightWhile</code>返回一个新数组，从右边的原始数组中取出条目，直到我们用来通过返回数组来结束方法的给定谓词返回<code class="fe lb lc ld le b">true</code>。</p><p id="a2e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4aa6" class="mq lg iq le b gy mr ms l mt mu">const takeRightWhile = (arr, predicate) =&gt; {<br/>  let takenArr = [];<br/>  for (let i = arr.length - 1; i &gt;= 0; i--) {<br/>    if (!predicate(arr[i])) {<br/>      takenArr.push(arr[i]);<br/>    } else {<br/>      return takenArr.reverse();<br/>    }<br/>  }<br/>  return takenArr.reverse();<br/>}</span></pre><p id="87e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用一个<code class="fe lb lc ld le b">for</code>循环反向循环通过<code class="fe lb lc ld le b">arr</code>。然后我们在每次迭代中运行<code class="fe lb lc ld le b">predicate</code>函数，将每个元素作为参数，看看它是否返回<code class="fe lb lc ld le b">true</code>。</p><p id="486d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有，那么我们将条目推入<code class="fe lb lc ld le b">takenArr</code>。否则，我们反转返回<code class="fe lb lc ld le b">takenArr</code>,这样我们就有了原始顺序的元素。</p><p id="5c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4572" class="mq lg iq le b gy mr ms l mt mu">const result = takeRightWhile([30, 40, 50], a =&gt; a &lt; 40);</span></pre><p id="0c5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[40, 50]</code>，因为我们指定如果用<code class="fe lb lc ld le b">predicate</code>调用的第一个条目返回<code class="fe lb lc ld le b">true</code>，我们就停止。</p><h1 id="4136" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="eec5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">用简单的循环可以很容易地实现<code class="fe lb lc ld le b">takeRightWhile</code>方法。我们只需要反向循环遍历条目，而不是向前循环，先从末尾开始获取条目，然后再向开头前进。</p><p id="9c91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">takeRight</code>、<code class="fe lb lc ld le b">tail</code>和<code class="fe lb lc ld le b">take</code>方法可以用<code class="fe lb lc ld le b">slice</code>实现。</p><p id="7164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">reverse</code>和<code class="fe lb lc ld le b">slice</code>方法已经内置在普通的JavaScript中，无论如何它都有Lodash用法，所以我们可以只使用普通的JavaScript版本。</p><h2 id="88f0" class="mq lg iq bd lh mw mx dn ll my mz dp lp ko na nb lt ks nc nd lx kw ne nf mb ng bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="0280" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="721d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>