# 单元测试角度-组件测试

> 原文：<https://javascript.plainenglish.io/unit-testing-angular-component-testing-f0c478de3dd8?source=collection_archive---------6----------------------->

![](img/0fe45665a0b3fda6b43c9711f3d19b2c.png)

我们每天都看到向我们的应用程序添加自动化测试的更大推动力。无论这些是单元测试、集成测试还是 e2e 测试。

这将是基于为 Angular 和它的一些核心概念编写单元测试的一系列文章:组件、服务、管道和防护。

这些文章并不打算包罗万象，而是对单元测试的一个软介绍。对于更详细的组件测试文档，Angular 有一个很棒的文档页面:[https://angular.io/guide/testing](https://angular.io/guide/testing)

值得注意的是，我的一些固执己见的测试方法将会在本文中出现。测试已经是一个非常热门的话题了。我的建议是浏览所有的测试策略，然后决定你认为什么是最好的方法。

在本文中，我们将探索测试组件，从简单到更复杂的组件，我们将涵盖以下内容:

*   什么是单元测试？💡
*   为什么要编写单元测试？🤔
*   好了，现在我们如何编写单元测试呢？😄

我们将使用标准的 Jasmine 和 Karma 测试设置，这是 Angular 在使用 Angular CLI 生成的应用程序上提供的现成设置。

# 💡什么是单元测试？

单元测试是一种软件测试，它验证代码的一个独立部分(单元)的正确性。

假设你有一个简单的加法函数:

这个完整的函数可以被认为是一个单元，因此您的测试将验证这个单元是正确的。对该单元的快速测试可以是:

我们在这里介绍几个概念。
`it(...args)`是建立我们的单元测试的函数。这是测试跑步者中非常常见的测试术语。

我们还介绍了 AAA 测试模式。这是一种将你的测试分成 3 个部分的模式。

第一部分是**安排**:在这里你执行你的测试所需的任何设置。

第二部分是 **Act** :在这里，您将让您的代码执行您想要测试的动作。

第三个也是最后一个选项是**断言**:这里您将验证单元是否按预期执行。

在上面的测试中，我们设置了函数正确执行时的预期值，并且设置了将用于测试函数的数据。

然后，我们对之前安排的测试数据调用`sum()`函数，并将结果存储在`total`变量中。

最后，我们检查`total`是否与我们期望的值相同。

如果是的话，测试就会通过，这要感谢我们使用了`expect()`方法。

*注:* `*.toBe()*` *是 matcher 函数。匹配器函数检查传递到* `*expect()*` *函数的值是否与期望的结果匹配。Jasmine 附带了很多匹配器函数，可以在这里查看:*[*Jasmine Matchers*](https://jasmine.github.io/api/3.5/matchers.html)

# 🤔但是为什么呢？

轻松点。对变化的信心。

作为一名开发人员，您一直在对代码库进行修改。但是，如果没有测试，你怎么知道你没有在你的应用程序的不同区域做出破坏功能的改变呢？

您可以尝试手动测试应用程序中每个可能的区域和场景。但是这会消耗你的开发时间，最终影响你的生产力。

如果您可以简单地运行一个命令来检查您应用程序的所有区域，以确保一切仍按预期运行，那么效率会高得多。对吗？

这正是自动化单元测试的目标，尽管在编写测试时，您会花费更多的时间来开发特性或修复 bug，但如果您将来不得不更改功能或重构代码，您会将这些时间争取回来。

另一个好处是，任何跟在你后面的开发人员都可以使用你写的测试套件作为你写的代码的文档。如果他们不明白如何在代码中使用一个类或一个方法，测试会告诉他们如何使用！

*需要注意的是，这些好处来自于* ***写得好的*** *测试。稍后我们将探讨好的和坏的测试之间的区别。*

# 😄让我们写一个角度分量测试

我们将把它分成一系列步骤，涵盖以下测试场景:

*   只有输入和输出的简单组件
*   具有 DI 提供者的复杂组件

让我们从一个只有输入和输出的简单组件开始。纯粹的表象成分。

# 🖼️表象成分测试

我们将从一个非常简单的组件`user-speak.component.ts`开始，它有一个输入和一个输出。它将显示用户的名字，并有两个按钮允许用户回话:

如果您使用 Angular CLI *(强烈推荐！)*为了生成你的组件，你将得到一个现成的测试文件。如果没有，创建一个`user-speak.component.spec.ts`。

*注意:* `*.spec.ts*` *很重要。这就是测试运行人员知道如何找到您的测试的方法！*

然后在内部，确保它最初看起来像这样:

让我们解释一下这里发生了什么。

`describe('UserSpeakComponent', () => ...)`调用为我们的 User Speak 组件建立了一个测试套件。它将包含我们希望为我们的组件执行的所有测试。

`beforeEach()`调用指定了在每次测试运行之前应该执行的代码。使用 Angular，我们必须告诉编译器如何正确地解释和编译我们的组件。这就是`TestBed.configureTestingModule`的用武之地。对于这个特定的组件测试，我们不会涉及太多的细节，但是，在本文的后面，我们将描述当我们的组件中有 DI 提供者时，如何改变它。

*关于这方面的更多信息，请查看* [*角度测试文档*](https://angular.io/guide/testing)

每个`it()`调用都会为测试运行人员创建一个新的测试来执行。

在上面的例子中，我们目前只有一个测试。这个测试检查我们的组件是否创建成功。这几乎就像一个健全性检查，以确保我们已经为我们的组件正确地设置了`TestBed`。

现在，我们知道我们的组件类有一个`constructor`和两个方法`sayHello`和`sayGoodbye`。由于构造函数是空的，我们不需要测试它。但是，另外两个方法确实包含逻辑。

我们可以认为这些方法中的每一个都是需要测试的单元。因此，我们将为它们编写两个单元测试。

应该记住，当我们编写单元测试时，我们希望它们是独立的。本质上，这意味着它应该是完全独立的。如果我们仔细观察我们的方法，可以看到它们在组件的`speak` EventEmitter 上调用`emit`方法。

我们的单元测试对`emit`功能是否正常工作不感兴趣，相反，我们只想确保我们的方法恰当地调用了`emit`方法:

这里我们遇到了`spyOn`函数，它允许我们模拟出`emit`调用的实际实现，并创建一个 [Jasmine Spy](https://jasmine.github.io/api/3.5/global.html#spyOn) ，然后我们可以用它来检查是否进行了`emit`调用，以及向它传递了什么参数，从而允许我们单独检查我们的单元是否正确执行。

如果我们从命令行运行`ng test`，我们将看到测试正确通过。太棒了。

# 🔧重构

停下来。拥有两个本质上做同样事情的方法会复制大量代码。让我们重构我们的代码，让它变得更加枯燥:

太棒了，这样好多了。让我们再次运行测试:`ng test`。

啊哦！😱

测试失败了！

我们的单元测试能够正确地捕捉到我们改变了功能，并且潜在地破坏了一些先前工作的功能。💪

让我们更新我们的测试，以确保它们继续为我们的新逻辑工作:

我们已经删除了之前的两个测试，并用一个新的测试更新了它。这个测试确保传递给`saySomething`方法的任何字符串都将被传递给`emit`调用，允许我们测试 Say Hello 按钮和 Say Goodbye。

厉害！🚀

*注意:围绕在单元测试中测试 JSDOM 有一个争论。我个人反对这种方法，因为我觉得它更像是一个集成测试，而不是单元测试，应该与你的单元测试套件分开。*

让我们继续:

# 🤯复杂组件测试

现在我们已经看到了如何测试一个纯粹的表示性组件，让我们来看看测试一个注入了阿迪提供者的组件。

对此有几种方法，所以我将展示我倾向于采用的方法。

让我们创建一个注入了`UserService`的`UserComponent`:

相当简单，除了我们已经将`UserService`注入到我们的组件中。

同样，让我们建立我们的初始测试文件`user.component.spec.ts`:

如果我们现在运行`ng test`，它会失败，因为我们缺少`UserService`的提供者，因此`TestBed`不能正确地注入它来成功地创建组件。

因此，我们必须编辑设置的`TestBed`,以允许我们正确创建组件。请记住，我们正在编写单元测试，因此只想孤立地运行这些测试，并不关心`UserService`方法是否正常工作。

`TestBed`也不理解我们的 HTML 中的`app-user-speak`组件。这是因为我们没有将它添加到我们的声明模块中。然而，现在是争论的时候了。我对此的看法是，我们的测试不需要知道这个组件的组成，而是我们只测试我们的组件中的类型脚本，而不是 HTML，因此我们将使用一种称为浅层呈现的技术，这将告诉 Angular 编译器忽略 HTML 中的问题。

为此，我们必须编辑我们的`TestBed.configureTestingModule`,如下所示:

这将解决我们的`app-user-speak`未声明的问题。但是我们仍然需要为`UserService`错误修复我们丢失的提供者。我们将在单元测试中使用一种称为模仿的技术，来创建一个模仿对象，它将被注入到组件中，而不是真正的用户服务中。

有许多方法可以创建模拟/间谍对象。Jasmine 有一些内置选项，你可以在这里阅读。

我们将采用稍微不同的方法:

我们现在感兴趣的部分是我们的`providers`数组。这里我们告诉编译器提供这里定义为 UserService 的值。我们设置了一个新的对象，并定义了我们想要模仿的方法，在本例中是`getUser`，我们将告诉它返回一个特定的对象，而不是让真正的用户服务执行逻辑从数据库或类似的地方获取用户。

我对此的想法是，您与之交互的每个公共 API 都应该已经过测试，因此您的单元测试不需要确保 API 正确工作，但是，您希望确保您的代码能够正确处理 API 返回的内容。

现在让我们编写测试来检查我们是否在我们的`ngOnInit`方法中获取了用户。

这里我们简单地创建一个 spy 来确保在`ngOnInit`方法中进行`getUser`调用。完美。

我们还利用`.and.returnValue()`语法来告诉 Jasmine，当调用 API 时，它应该向`ngOnInit()`方法返回什么。这可以让我们通过强制返回错误或不完整的对象来检查边缘情况和错误情况。

让我们修改我们的`ngOnInit()`方法如下，以允许它处理错误:

现在让我们编写一个新的测试，告诉 Jasmine 抛出一个错误，允许我们检查我们的代码是否正确地处理了错误:

完美！🔥🔥我们现在也能够确保我们的代码能够正确处理错误！

这是对 Jasmine 和 Karma 的 Angular 单元测试组件的一个简短而不全面的介绍。我将发表更多关于单元测试角度的文章，涵盖测试服务、数据服务、管道和防护。

如有任何问题，欢迎在下方提问或在 Twitter 上联系我: [@FerryColum](https://twitter.com/FerryColum) 。

*原载于 2020 年 2 月 15 日*[*https://dev . to*](https://dev.to/coly010/unit-testing-angular-component-testing-2g47)*。*