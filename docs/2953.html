<html>
<head>
<title>How to build a Content Diff View in vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用普通JavaScript构建内容差异视图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/content-diff-view-in-vanilla-javascript-105a00abd7ce?source=collection_archive---------2-----------------------#2020-08-10">https://javascript.plainenglish.io/content-diff-view-in-vanilla-javascript-105a00abd7ce?source=collection_archive---------2-----------------------#2020-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5b8232118100d1827bf4103e834f03f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Co40TEFIAUWJF8Ksu86XAA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A diff’d version of HTML</figcaption></figure><p id="9cb4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">大家好，今天我们来谈谈“不同的观点”,看看我们如何在我们的项目中实现它。可以从tnwinc的repo <a class="ae kx" href="https://github.com/tnwinc/htmldiff.js/blob/master/src/htmldiff.coffee" rel="noopener ugc nofollow" target="_blank">这里</a>获取JS文件。虽然它是一个CoffeeScript代码，但是你可以使用任何在线转换器从它那里获得JS代码——我使用的是<a class="ae kx" href="http://js2.coffee" rel="noopener ugc nofollow" target="_blank"> JS2。咖啡</a>。或者你可以从这个<a class="ae kx" href="https://gist.github.com/KPChakravarthy/8a2fcddfa11f29ddb9cc557a87449aaa" rel="noopener ugc nofollow" target="_blank"> GitHub Gist </a>中抓取一份我的文件</p><p id="48dc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，这里有一些关于我们今天要实现的目标的信息。</p><h1 id="db5e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">场景</strong></h1><p id="fa0c" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">比方说，我们使用一种算法在后端生成一个文档，并将其提供给前端，在前端，我们使用所见即所得编辑器允许用户根据他们的要求修改内容。现在，几年后他们想知道他们改变了什么(几乎不可能，是的，但是你明白了)。这是他们期望看到两个文档之间差异的地方。</p><h1 id="50bd" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">抓到你了</strong></h1><ol class=""><li id="d3e4" class="mb mc in kb b kc lw kg lx kk md ko me ks mf kw mg mh mi mj bi translated">这是纯粹的普通JavaScript，没有任何依赖关系——这意味着你可以把文件放到任何你想要的项目上，加载它，然后砰！你可以走了。</li><li id="a7e7" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">它的美妙之处在于，它可以在前端和后端代码中实现——这完全取决于您和您的需求。例如，在我的例子中，有很多参数，计算会改变，文档会在后端更新，这是一个后端密集型任务，所以我们在后端实现它。如果您的需求主要是静态的，只有一堆来自BE的HTML，那么您可以选择在FE本身上实现它。</li><li id="67ce" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">实现的某些部分依赖于CSS3(没什么大不了的，但更像是玩弄可见性来创造一种空行的感觉。</li><li id="eeb4" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">CSS可以通过两种方式实现(据我所知)——<br/><strong class="kb io">a .</strong>当你使用TinyMCE这样的编辑器时，它会在iFrame中呈现所有内容，这意味着你可以选择将定制的CSS直接插入到只与该编辑器相关的编辑器中。这是一个很好的小功能，你可以从后端发送文档和它的CSS。<br/> <strong class="kb io"> b. </strong>使用像draft.js这样的编辑器，你需要提供一个包装类，并确保你的自定义CSS(现在应用于你的项目中)将只在想要的编辑器上生效。</li></ol><h1 id="e715" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">要求</strong></h1><ol class=""><li id="a90c" class="mb mc in kb b kc lw kg lx kk md ko me ks mf kw mg mh mi mj bi translated">任何后端——NodeJS、JAVA、RoR——都由你决定。</li><li id="758e" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">任何前端——Angular、React、Vue甚至纯JS——都由您决定。</li><li id="d8a7" class="mb mc in kb b kc mk kg ml kk mm ko mn ks mo kw mg mh mi mj bi translated">htmldiff.js文件的副本。您可以将它保存在您的项目目录中，或者进行更改并将其托管在您的CDN上。</li></ol><h1 id="a7fb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="e2be" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我们将采取一个HTML字符串，打破，撕裂和撕裂；但主要是把它拆分成字符，并与对应的字符进行比较，以显示不同之处。</p><p id="3e51" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成所有这些后，让我们深入研究代码。在进入JS之前，让我们快速创建布局并相应地调整样式。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3394" class="my kz in mu b gy mz na l nb nc"><strong class="mu io"><em class="nd">THE HTML</em></strong></span><span id="0fc3" class="my kz in mu b gy ne na l nb nc">&lt;div class="card"&gt;<br/>  &lt;div class="row"&gt;<br/>    &lt;div class="col"&gt;<br/>      &lt;h4&gt;Document with changes&lt;/h4&gt;<br/>      &lt;div class="card current-document" id="output"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="col"&gt;<br/>      &lt;h4&gt;Original Document&lt;/h4&gt;<br/>      &lt;div class="card system-generated" id="outputNew"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="0ac0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是你的布局，我会让你的风格适合你的项目。</p><p id="5cec" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">创建者在命名函数和变量方面做得很好，所以它们基本上是自解释的，尽管我会带你看一下主要的部分</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="bf3c" class="my kz in mu b gy mz na l nb nc">is_end_of_tag = function (char) {<br/>  return char === "&gt;";<br/>};<br/>is_start_of_tag = function (char) {<br/>  return char === "&lt;";<br/>};<br/>is_whitespace = function (char) {<br/>  return /^\s+$/.test(char);<br/>};<br/>is_tag = function (token) {<br/>  return /^\s*&lt;[^&gt;]+&gt;\s*$/.test(token);<br/>};<br/>isnt_tag = function (token) {<br/>  return !is_tag(token);<br/>};</span></pre><p id="251c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些函数用于确定字符“类型”——这对于知道何时何地在<ins> / <del>标签中开始换行非常有用。</del></ins></p><p id="fc5e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> html_to_tokens </strong>函数是字符串切割和字符匹配的地方。</p><p id="d157" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">“改变”发生在匹配字符串被映射和添加/删除的部分——<strong class="kb io">op _ map</strong>对象。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4cc1" class="my kz in mu b gy mz na l nb nc">op_map = {<br/>  equal: function (op, before_tokens, after_tokens) {<br/>    return before_tokens<br/>      .slice(op.start_in_before, +op.end_in_before + 1 || 9e9)<br/>      .join("");<br/>  },<br/>  insert: function (op, before_tokens, after_tokens) {<br/>    var val;<br/>    val = after_tokens.slice(op.start_in_after, +op.end_in_after + 1 || 9e9);<br/>    return wrap("ins", val);<br/>  },<br/>  delete: function (op, before_tokens, after_tokens) {<br/>    var val;<br/>    val = before_tokens.slice(op.start_in_before, +op.end_in_before + 1 || 9e9);<br/>    return wrap("del", val);<br/>  }<br/>};<br/>op_map.replace = function (op, before_tokens, after_tokens) {<br/>  return (<br/>    <strong class="mu io">op_map.delete(op, before_tokens, after_tokens) +<br/>    op_map.insert(op, before_tokens, after_tokens)</strong><br/>  );<br/>};</span></pre><p id="8bc2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您注意到这里，根据op_tokens中的变化，我们将把它放在一个<strong class="kb io"> &lt; ins &gt; </strong>标签或<strong class="kb io"> &lt; del &gt; </strong>标签周围，这表示它被插入或删除了。这里，<strong class="kb io"> return </strong>语句返回“删除”字符串+“插入”字符串的串联。然而，这里有一个问题。可以先显示delete再插入，但是要写一堆javascript把原始文档中删除的部分去掉。或<br/> 2。显示插入，然后删除，这样您就可以使用CSS <strong class="kb io"> visibility: hidden来隐藏删除；</strong></p><p id="e8e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我选择了第二行，并像这样交换了插入和删除行</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="1d2a" class="my kz in mu b gy mz na l nb nc">op_map = {<br/>  equal: function (op, before_tokens, after_tokens) {<br/>    return before_tokens<br/>      .slice(op.start_in_before, +op.end_in_before + 1 || 9e9)<br/>      .join("");<br/>  },<br/>  insert: function (op, before_tokens, after_tokens) {<br/>    var val;<br/>    val = after_tokens.slice(op.start_in_after, +op.end_in_after + 1 || 9e9);<br/>    return wrap("ins", val);<br/>  },<br/>  delete: function (op, before_tokens, after_tokens) {<br/>    var val;<br/>    val = before_tokens.slice(op.start_in_before, +op.end_in_before + 1 || 9e9);<br/>    return wrap("del", val);<br/>  }<br/>};<br/>op_map.replace = function (op, before_tokens, after_tokens) {<br/>  return (<br/>    <strong class="mu io">op_map.insert(op, before_tokens, after_tokens) +<br/>    op_map.delete(op, before_tokens, after_tokens)</strong><br/>  );<br/>};</span></pre><p id="ff02" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这给了我们一个喘息的机会来根据我们的需要编写CSS为了简单起见。这是CSS的要点—</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="c3a5" class="my kz in mu b gy mz na l nb nc">.current-document ins {<br/>  background: lightgreen;<br/>  text-decoration: none;<br/>}</span><span id="9d3c" class="my kz in mu b gy ne na l nb nc">.current-document del {<br/>  background: pink;<br/>}</span><span id="3e09" class="my kz in mu b gy ne na l nb nc">.system-generated del {<br/>  visibility: hidden;<br/>}</span><span id="8d1e" class="my kz in mu b gy ne na l nb nc">.system-generated ins {<br/>  text-decoration: none;<br/>}</span><span id="7738" class="my kz in mu b gy ne na l nb nc">.system-generated ins ~ del {<br/>  display: none;<br/>}</span></pre><p id="a7d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我相信CSS相当简单。“当前文档”(有更改的文档)上的<strong class="kb io"> ins </strong>和<strong class="kb io"> del </strong>都被设计为显示“更改”，并且都隐藏在“系统生成的”(原始文档)上，因此看起来像“原始”文档。</p><p id="3c2b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为我们在上面交换了行，我们现在可以使用兄弟选择器(~)从原始文档的DOM中删除<strong class="kb io"> del </strong>。</p><p id="e54f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在剩下的就是触发JS并输出结果。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="07f1" class="my kz in mu b gy mz na l nb nc">// Diff HTML strings<br/>let output = htmldiff(originalHTML, newHTML);<br/>let input = htmldiff(newHTML, originalHTML);</span><span id="3ce2" class="my kz in mu b gy ne na l nb nc">// Show HTML diff output as HTML!<br/>document.getElementById("output").innerHTML = output;<br/>document.getElementById("outputNew").innerHTML = input;</span></pre><p id="4637" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这就是这个故事的结尾。这是它的一支笔——</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="cc39" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我希望你喜欢这篇文章，它在某种程度上帮助了你。</h1><p id="95d3" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我总是乐于接受改进和改变，所以请随时在下面留言。接下来我将发表一篇关于使用AWS多部分上传API和预先设计的URL上传大文件到S3的文章，敬请关注。到那时，“<em class="nd">愿法典与你同在。”</em>👾</p></div></div>    
</body>
</html>