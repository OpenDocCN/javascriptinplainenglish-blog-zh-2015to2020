<html>
<head>
<title>Useful Custom Hooks for Tired React Devs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对疲劳反应开发者有用的定制钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useful-custom-hooks-for-tired-react-devs-f2f602dc754f?source=collection_archive---------1-----------------------#2020-10-25">https://javascript.plainenglish.io/useful-custom-hooks-for-tired-react-devs-f2f602dc754f?source=collection_archive---------1-----------------------#2020-10-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c2c8d3623c306a15557a58e6ad8407a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oZtyqEyaGsGbhgrT"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@polarmermaid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anne Nygård</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="120c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编写反应应用程序可能会得到同样的结果。我们经常发现自己一遍又一遍地重复定义相同组件行为的相同模式，人们会开始怀疑我们如何才能使这些模式越来越枯燥。</p><p id="b169" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反应钩棒极了。通过滥用JavaScript闭包的力量，并加上一些警告，可以在函数中保存状态。这有多酷？</p><p id="bcbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">(在我被C开发者喊下来之前，他们会告诉我函数中的</em> <code class="fe kz la lb lc b"><em class="ky">static</em></code> <em class="ky">变量实际上是有状态的，我知道。)</em></p><p id="7732" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">钩子不仅允许有状态行为，而且它们还是<em class="ky">被动的</em>。您可以使用钩子对组件的支柱、存储状态、对可变值的存储引用等的变化做出反应。这只是使用默认情况下附带的钩子。挂钩也是<em class="ky">可组合的</em>。这意味着我可以编写自己的钩子，使用其他钩子。通过将这些结合起来，可以有效地将状态、行为或反应性注入任何功能组件。</p><p id="3365" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我将介绍几个例子，包括reactor和React Native devs，它们证明了这种可组合性，并创建了一些整洁、超级方便、易于测试的功能，可以在任何项目中使用。</p><h1 id="f44f" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">通用挂钩</h1><p id="8a1b" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">这些钩子可用于reactor和React Native项目，因为它们都是JS专用的，并且使用了两者中可用的特性。</p><h2 id="2cc9" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">使用安装</h2><p id="fd91" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">通常情况下，我们可能会遇到这样的情况:副作用的后果是卸载一个期望进行状态更新的组件。例如，让我们想象以下取自我的一个旧代码库的例子:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="44c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，这个组件有几个我们不会涉及的问题，但是我们应该<em class="ky">真的</em>处理<code class="fe kz la lb lc b">props.onClick</code>拒绝的情况。</p><p id="5603" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论如何，就我们的目的而言，这没问题。但是如果<code class="fe kz la lb lc b">props.onClick</code>让应用程序导航到一个新的页面会发生什么呢？该按钮将卸载，因此，调用<code class="fe kz la lb lc b">setLoading(false)</code>。一般来说，<strong class="kc io">不应该更新未安装组件的状态</strong>，因为这会导致内存泄漏<strong class="kc io">。</strong></p><p id="3357" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们到达<code class="fe kz la lb lc b">setLoading(false)</code>时，我们需要知道组件是否仍然被安装，因为如果在此期间组件已经被卸载，我们需要跳过它。</p><p id="9519" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们写一个钩子给我们参考:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="02ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以在前面的例子中使用它:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0c6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个钩子帮助我避免了一些微妙的错误。快速前进-</p><h2 id="114f" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">useWebSocket</h2><p id="454b" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">如果您正在构建一个包含任何类型的实时通信(聊天、游戏等)的应用程序，那么您很可能最终会使用网络套接字。它们为您提供与另一台主机的全双工(双向)通信，这与采用请求-响应模型的HTTP相反。</p><p id="08ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在React组件中处理WebSocket的状态可能有点痛苦，并且您必须始终记住在卸载时关闭WebSocket，等等。简而言之，如果你在应用程序的很多地方使用WebSockets，这会导致很多重复。</p><p id="5ca7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看钩子:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2a42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个钩子返回一个ref，它将活动的WebSocket存储在它的<code class="fe kz la lb lc b">current</code>属性中，并在使用它的组件卸载时自动关闭它，例如</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="85ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个钩子有很多灵活的基于WebSocket的应用用例，特别是here chat，我们可以在聊天关闭时安全地关闭WebSocket，只有在聊天打开时才打开它。</p><p id="038f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">酷吧？假设我们得到了一个实际的<code class="fe kz la lb lc b">ws</code>实例的<code class="fe kz la lb lc b">ref</code>，那么使用通常的WebSocket API，很容易添加我们可能想要的任何额外行为。</p><h2 id="5101" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">使用负载</h2><p id="dcf1" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">这个钩子可以节省一点时间。想象一下这个场景——你有一个带有<code class="fe kz la lb lc b">n</code>按钮的组件，所有这些按钮都在按压/点击/点击等操作时启动一些异步操作。跟踪它们的加载状态有点麻烦——你不希望必须维护一个对象或加载布尔值的数组，因为这很容易导致错误——尤其是如果按钮的数量在组件的生命周期中会发生变化！看起来是这样的:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="55fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你有了一个关于动作加载状态的视图，被封装到一个钩子中——不再有<code class="fe kz la lb lc b">useState</code>弄乱你的组件，你可以这样做:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5ab8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为包装器确保返回您的<code class="fe kz la lb lc b">async</code>函数返回的承诺，所以您可以使用承诺(<code class="fe kz la lb lc b">await</code>、承诺链接等做所有您想做的事情。).</p><h1 id="c8bb" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">反应自然</h1><p id="9ffa" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">这里有一个钩子，我们可以在React本地应用程序中使用它，让我们的生活变得更加轻松。</p><h2 id="025e" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">使用状态条</h2><blockquote class="my mz na"><p id="a577" class="ka kb ky kc b kd ke kf kg kh ki kj kk nb km kn ko nc kq kr ks nd ku kv kw kx ig bi translated">编辑:<a class="ae jz" href="https://reactnavigation.org/docs/status-bar/#tabs-and-drawer" rel="noopener ugc nofollow" target="_blank">来自<code class="fe kz la lb lc b">react-navigation</code>文档的这个教程</a>提供了这个钩子的一个更加声明性的版本，以达到同样的效果。</p></blockquote><p id="4174" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在使用React导航编写React原生应用时，我们经常会遇到一个特殊的问题。简而言之，设备的状态栏通过渲染一个<code class="fe kz la lb lc b">StatusBar</code>组件来控制。但是，如果我们有一个多屏幕的应用程序，一次呈现多个屏幕，而不是延迟加载，这种方法可能会失败。这是因为渲染这个<code class="fe kz la lb lc b">StatusBar</code>更新了引擎下的配置，但是只反映了上次渲染时的状态。这意味着，如果你的应用程序有屏幕A和B，即使你有一个可见的，如果B在A之后呈现，状态栏将有来自屏幕B的配置，这对于屏幕A是错误的。</p><p id="194e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">幸运的是，React Native的<code class="fe kz la lb lc b">StatusBar</code>模块也导出了设置这个配置的强制方法。那么，如果我们可以编写一个钩子，在屏幕聚焦时进行这些命令性的调用，这样我们就总是有正确的配置，会怎么样呢？这是我为一个项目写的一个钩子，它就是这样做的:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Only drawback here is it’s not super future-proof for API changes.</figcaption></figure><p id="140e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们只需调用<code class="fe kz la lb lc b">useStatusBar</code>就可以在每个屏幕上设置配置，当屏幕成为焦点时，它总是正确的。这种基于钩子的替代方法有助于使你的标记在每个屏幕上都清晰地呈现出<code class="fe kz la lb lc b">StatusBar</code>。</p><h2 id="240a" class="mg le in bd lf mh mi dn lj mj mk dp ln kl ml mm lr kp mn mo lv kt mp mq lz mr bi translated">更进一步—使用外观AwareStatusBar</h2><p id="b64a" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">如果我们有一个应用程序，使用手机的配色方案+偏好，可以在幕后改变，支持黑暗和光明模式，会怎么样？我们可以更进一步:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A little more complicated, but super powerful!</figcaption></figure><p id="f5ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果用户在你的应用程序设置中改变了他们的颜色偏好，或者，例如，太阳下山，你手机的配色方案发生了变化，这个<code class="fe kz la lb lc b">StatusBar</code>将会意识到这一点，并与应用程序的其余部分相匹配。这里显然我们没有考虑<code class="fe kz la lb lc b">StatusBar</code> API中的其他方法，这将是一个受欢迎的改进。</p><h1 id="26df" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">包扎</h1><p id="5a04" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">如前所述，React应用程序可能会变得千篇一律。我们经常发现自己为许多组件维护相同的行为，而钩子是重用行为并使维护和迭代速度快如闪电的好方法。</p><p id="e348" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！</p><p id="9e9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi">💙</p></div></div>    
</body>
</html>