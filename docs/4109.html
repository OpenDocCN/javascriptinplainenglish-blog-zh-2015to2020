<html>
<head>
<title>Smart Styling Of Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件的智能样式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/smart-styling-of-web-components-c9c21df285be?source=collection_archive---------1-----------------------#2020-11-17">https://javascript.plainenglish.io/smart-styling-of-web-components-c9c21df285be?source=collection_archive---------1-----------------------#2020-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e2c6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何聪明地利用基于状态的样式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/33c8cd9dda95d55227bcf716932966eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gu8u2jLcu1iyRCNV"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="df58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Web组件的杀手锏之一是通过影子DOM真正封装样式。</p><p id="3d4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着Web组件的内部CSS可以与周围的文档完全隔离，而不需要特定的命名约定。</p><p id="1aed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件内部定义的所有样式都只适用于组件，不会从组件中泄漏出来，除了<a class="ae kv" href="https://www.w3.org/TR/CSS21/propidx.html" rel="noopener ugc nofollow" target="_blank">继承的CSS属性</a>之外，组件外部定义的样式不适用于组件。</p><p id="a9e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，这意味着只有那些适用于文本的属性才会被继承，比如<code class="fe ls lt lu lv b">font</code>、<code class="fe ls lt lu lv b">color</code>、<code class="fe ls lt lu lv b">line-height</code>、<code class="fe ls lt lu lv b">text-align</code>(以及<code class="fe ls lt lu lv b">visibility</code>)。所有其他样式都不会穿透影子DOM边界，而是在Web组件内部定义的。</p><p id="a59f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做的一个很大的好处是，CSS可以大大简化，因为每个样式表只适用于单个组件，这样就不需要大量的类名或BEM之类的命名约定。</p><p id="5d3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就好像你只需要对迷你文档进行样式化，不需要担心影响其他文档。</p><p id="5470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据你的Web组件的大小，你通常只需要少量的HTML元素，这样你的CSS就会保持清晰和简洁。</p><h1 id="7a91" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">基于状态的样式</h1><p id="8017" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在React和StencilJS组件中使用JSX时，我注意到当组件的内部状态改变时，情况通常会变得更复杂，这需要反映在它的UI中。</p><p id="01ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当你有一个按钮的<code class="fe ls lt lu lv b">disabled</code>属性被设置为<code class="fe ls lt lu lv b">true</code>时，你会想要向用户显示它被禁用了，可能是通过将<code class="fe ls lt lu lv b">opacity</code>设置为一个较低的值并将<code class="fe ls lt lu lv b">cursor</code>设置为<code class="fe ls lt lu lv b">not-allowed</code>。</p><p id="d7d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常这是通过应用条件类来实现的:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="26a6" class="mx lx iq lv b gy my mz l na nb">render() {<br/>  return (<br/>    &lt;div id="container" className={this.disabled ? 'disabled' : ''}&gt;<br/>      &lt;button&gt;Save&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="0dee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个简单的例子，但是您可以想象当更多的状态需要在UI中反映时，事情会变得非常棘手:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="a0e7" class="mx lx iq lv b gy my mz l na nb">render() {<br/>  return (<br/>    &lt;div id="container"<br/>      className={<br/>       `${this.disabled &amp;&amp; 'disabled'}<br/>        ${this.processing &amp;&amp; 'processing'<br/>        ${this.error &amp;&amp; 'error'}<br/>        ...<br/>      `}&gt;<br/>      &lt;button&gt;Save&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="6756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，有可用的<a class="ae kv" href="https://github.com/lukeed/clsx" rel="noopener ugc nofollow" target="_blank">库</a>来使应用条件类变得更容易，但是通常这仍然会很快变得混乱。</p><h1 id="4d67" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">将属性反映到属性</h1><p id="bcbb" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Web组件通过<em class="nc">将属性反映到属性</em>，为基于状态的样式提供了一个优秀的解决方案。</p><p id="1136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着Web组件的每个或仅某些属性具有相应的属性，每当属性值改变时，该属性就会更新。</p><p id="fd7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这已经是本地HTML元素的常见做法，例如<code class="fe ls lt lu lv b">&lt;button&gt;</code>和<code class="fe ls lt lu lv b">&lt;input&gt;</code>。</p><p id="dbe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您在页面上选择一个<code class="fe ls lt lu lv b">&lt;button&gt;</code>并将它的<code class="fe ls lt lu lv b">disabled</code>属性设置为<code class="fe ls lt lu lv b">true</code>时，您会注意到它也获得了一个<code class="fe ls lt lu lv b">disabled</code>属性:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="119e" class="mx lx iq lv b gy my mz l na nb">// before<br/>&lt;button&gt;Edit&lt;/button&gt;</span><span id="8365" class="mx lx iq lv b gy nd mz l na nb">const button = document.querySelector('button');<br/>button.disabled = true;</span><span id="7152" class="mx lx iq lv b gy nd mz l na nb">// after<br/>&lt;button <strong class="lv ir">disabled</strong>&gt;Edit&lt;/button&gt;</span></pre><p id="c612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以利用这种机制，结合<code class="fe ls lt lu lv b">:host()</code>选择器和CSS属性选择器，根据Web组件的状态轻松地设计它们的样式:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="4b3d" class="mx lx iq lv b gy my mz l na nb">:host([disabled]) button {<br/>  opacity: 0.5;<br/>  cursor: not-allowed;<br/>}</span></pre><p id="5989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">:host()</code>选择器可以接受一个任意的选择器，在这种情况下，我们使用属性选择器来定义按钮拥有<code class="fe ls lt lu lv b">disabled</code>属性时的样式。</p><p id="1aa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们将属性反映到属性，所以我们通常会使用属性选择器，但是当然我们也可以使用其他选择器，例如<code class="fe ls lt lu lv b">:host(.disabled)</code>。</p><p id="d4fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有必要定义仅在多个属性可用时才需要应用的样式，那么可以简单地一次指定这些属性:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="aa5f" class="mx lx iq lv b gy my mz l na nb">:host([disabled][active]) {<br/>  ...<br/>}</span></pre><p id="1a02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当<code class="fe ls lt lu lv b">disabled</code>和<code class="fe ls lt lu lv b">active</code>属性都存在时，才会应用上述规则。</p><p id="a8fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以定义属性有特定值时的样式。例如，我们可能想在按钮被点击时在按钮内部显示一个微调器，并且一个动作正在进行中，比如提交一个表单。</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="f461" class="mx lx iq lv b gy my mz l na nb">#spinner {<br/>  display: none;<br/>}</span><span id="d950" class="mx lx iq lv b gy nd mz l na nb">:host([state="processing"]) #spinner {<br/>  display: block;<br/>}</span><span id="7580" class="mx lx iq lv b gy nd mz l na nb">// inside the component:<br/>&lt;div id="container"&gt;<br/>  &lt;button&gt; <br/>    Saving...<br/>    &lt;svg id="spinner"&gt;&lt;/svg&gt;<br/>  &lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="6859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，默认情况下微调按钮<code class="fe ls lt lu lv b">svg</code>是隐藏的，当按钮的<code class="fe ls lt lu lv b">state</code>属性得到值<code class="fe ls lt lu lv b">processing</code>时，微调按钮将会显示。</p><p id="8ead" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以通过简单地更改Web组件的某些属性，轻松地显示和隐藏元素，或者对UI进行其他更改。</p><p id="d61f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种简单明了的方法，有很多好处。</p><ul class=""><li id="1a2d" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><strong class="ky ir">没有更多的类与属性保持同步</strong> <br/>对于类，我们需要为每个属性创建一个类，并确保它们保持同步。通过将属性反射到属性，属性被直接绑定到布局。</li><li id="d5a2" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">更简洁的HTML </strong> <br/>基于状态的样式完全由CSS完成，因此无需更多代码来切换条件类，从而使HTML更简洁。</li><li id="465e" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">更高效的CSS </strong> <br/>因为所有样式都是使用<code class="fe ls lt lu lv b">:host()</code>选择器完成的，所以所有CSS规则都是从主机元素开始自顶向下编写的。这鼓励CSS规则有效地利用CSS级联。<br/>当使用类时，这通常会导致非常具体的CSS规则和覆盖。<br/>我最近使用<code class="fe ls lt lu lv b">:host()</code>选择器重构了一个包含400多行CSS的大型StencilJS组件，使其包含的CSS少于300行。CSS现在不仅更短，而且更容易阅读和理解。</li><li id="ffb5" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated"><strong class="ky ir">从外部设计样式的能力</strong> <br/>由于组件的状态现在通过相应的属性从外部“可见”,这也可以用于从外部设计组件。<br/>例如，当一个<code class="fe ls lt lu lv b">&lt;awesome-button&gt;</code>组件通过它的<code class="fe ls lt lu lv b">disabled</code>属性被禁用并且也获得了这个属性时，样式也可以在它被禁用时从外部应用:</li></ul><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="0425" class="mx lx iq lv b gy my mz l na nb">awesome-button[disabled] {<br/>  pointer-events: none;</span><span id="a57f" class="mx lx iq lv b gy nd mz l na nb">  ...<br/>}</span><span id="872f" class="mx lx iq lv b gy nd mz l na nb">&lt;awesome-button disabled&gt;&lt;/awesome-button&gt;</span></pre><h1 id="9200" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">如何将属性反映到属性</h1><p id="a912" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">通过为属性定义一个setter，可以很容易地将属性反映到属性。每当属性值改变时，我们也在setter中改变属性:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="bb40" class="mx lx iq lv b gy my mz l na nb">set disabled(isDisabled) {<br/>  if(isDisabled) {<br/>    this.setAttribute('disabled', '');<br/>  }<br/>  else {<br/>    this.removeAttribute('disabled');<br/>  }<br/>}</span></pre><p id="fc43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，<code class="fe ls lt lu lv b">disabled</code>是一个空属性，所以我们只是根据值来设置或删除属性。</p><p id="cf8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们有一个可以接受特定值的<code class="fe ls lt lu lv b">state</code>属性，该属性也会接受这个值:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="220e" class="mx lx iq lv b gy my mz l na nb">set state(value) {<br/>  this.setAttribute('state', value);<br/>}</span></pre><p id="ab2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们还希望能够通过属性来更改属性，那么我们可能会尝试将它添加到Web组件的<code class="fe ls lt lu lv b">observedProperties</code>并实现<code class="fe ls lt lu lv b">attributeChangedCallback()</code>，但这是一个错误，因为这将导致无限循环:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="dc5d" class="mx lx iq lv b gy my mz l na nb">class AwesomeButton extends HTMLElement {</span><span id="4979" class="mx lx iq lv b gy nd mz l na nb">  static get observedProperties() {<br/>    return ['disabled'];<br/>  }</span><span id="a009" class="mx lx iq lv b gy nd mz l na nb">  constructor() {<br/>    super();</span><span id="9f04" class="mx lx iq lv b gy nd mz l na nb">    ...<br/>  } </span><span id="e9a1" class="mx lx iq lv b gy nd mz l na nb">  set disabled(isDisabled) {<br/>    if(isDisabled) {<br/>      this.setAttribute('disabled', '');<br/>    }<br/>    else {<br/>      this.removeAttribute('disabled');<br/>    }<br/>  }</span><span id="f93b" class="mx lx iq lv b gy nd mz l na nb">  <strong class="lv ir">// do NOT try to set the property inside the callback <br/>  // this will invoke the setter which in turn will invoke <br/>  // attributeChangedCallback which will invoke the setter again <br/>  // causing an infinite loop</strong><br/>  attributeChangedCallback(attr, oldVal, newVal) {<br/>    if(attr === 'disabled') {<br/>      this.disabled = this.hasAttribute('disabled');<br/>    }<br/>  }<br/>}</span></pre><p id="a72b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们提供了一个getter，它将从属性中读取值，因此它们总是同步的:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="159e" class="mx lx iq lv b gy my mz l na nb">get disabled() {<br/>  return this.hasAttribute('disabled');<br/>}</span></pre><h1 id="6553" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">基于状态的样式做得很好</h1><p id="e6fb" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当您开始编写通过属性到属性的反射来利用基于状态的样式的Web组件时，您会发现组件的HTML和CSS都将变得更加干净、简洁和易于理解。</p><p id="5e11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将在一个更高的层次上定义CSS规则，从主机开始向下，这将导致更干净的CSS，具有更少的规则和覆盖。</p><p id="682e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将从定义适用于某些属性的一般规则开始:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="8f41" class="mx lx iq lv b gy my mz l na nb">// default styles<br/>:host() {<br/>  ...<br/>}</span><span id="134a" class="mx lx iq lv b gy nd mz l na nb">// disabled = true<br/>:host([disabled]) {<br/>  ...<br/>}</span><span id="9bda" class="mx lx iq lv b gy nd mz l na nb">:host([disabled]) button {<br/>  ...<br/>}</span><span id="2477" class="mx lx iq lv b gy nd mz l na nb">// state = 'processing'<br/>:host([state="processing"]) {<br/>  ...<br/>}</span><span id="eccc" class="mx lx iq lv b gy nd mz l na nb">:host([state="processing"]) .spinner {<br/>  ...<br/>}</span></pre><p id="3a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要时，您可以应用特定的附加样式或覆盖:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="9be0" class="mx lx iq lv b gy my mz l na nb">// style applied when both state = "processing" and active = true<br/>:host([state="processing][active]) {<br/>  ...<br/>}</span></pre><p id="985e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将某些属性反映到属性中并不总是有意义的，所以当情况不是这样时，最好找到另一种解决方案。此外，请记住，只有接受原始值(如字符串、数字和布尔值)的属性才应该被反射。</p><p id="57fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，反射一个以对象数组作为值的属性是没有意义的，因为这个值需要被序列化，并且没有CSS规则可以定位它。</p><p id="7681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，最好反射到另一个具有原始值的属性。</p><p id="1fb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您有一个<code class="fe ls lt lu lv b">&lt;data-table&gt;</code>组件，它的<code class="fe ls lt lu lv b">data</code>属性接受一个对象数组，并且您需要在设置它时进行样式化，那么您可以反射到一个空属性<code class="fe ls lt lu lv b">populated</code>,以指示该组件已经被赋予了数据:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="60c4" class="mx lx iq lv b gy my mz l na nb">// value is an array of objects<br/>set data(value) {<br/>  if(value.length &gt; 0) {<br/>    this.setAttribute('populated', '');<br/>  }<br/>  else {<br/>    this.removeAttribute('populated');<br/>  }<br/>}</span></pre><p id="81f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看我的<a class="ae kv" href="https://github.com/DannyMoerkerke/material-webcomponents/blob/master/src/material-button.js" rel="noopener ugc nofollow" target="_blank">材质按钮</a> Web组件，它大量使用属性到属性的反射来设计灵感。</p><p id="5248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nc">你可以</em> <a class="ae kv" href="https://twitter.com/dannymoerkerke" rel="noopener ugc nofollow" target="_blank"> <em class="nc">在Twitter上关注我</em> </a> <em class="nc">我经常在那里写关于PWAs、web组件和现代Web功能的文章。</em></p></div></div>    
</body>
</html>