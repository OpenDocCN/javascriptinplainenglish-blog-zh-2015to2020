<html>
<head>
<title>Scratching the Surface of Higher Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript中高阶函数的皮毛</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/scratching-the-surface-of-higher-order-functions-in-javascript-4d4859bdb46b?source=collection_archive---------9-----------------------#2020-12-06">https://javascript.plainenglish.io/scratching-the-surface-of-higher-order-functions-in-javascript-4d4859bdb46b?source=collection_archive---------9-----------------------#2020-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1ac9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解高阶函数以及引擎盖下的内容的初级指南。map()，。过滤器()和。减少()。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/76696d892253570c43387cb61be1a0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5TksmXiaDswRDrLGNoF3w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Visual representation of .map(), .filter(), and .reduce()</figcaption></figure></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="8bb5" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">不管是哪种语言，每个人都有追求编程事业的理由。有些人学习它是因为他们喜欢它，它模仿了他们的思维方式。有些是为了钱。我想，其他人可能会在它周围成长，在这一点上这只是第二天性。我个人对它感兴趣已经有一段时间了。我离开了一份利润丰厚的职业，开始编程和构建我真正感兴趣的东西。对我来说，喜欢你做的事情是重要的，不可替代的。</p><p id="37e9" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">不管你来自哪里，也不管你编码的原因是什么，我们都必须经历学习基础知识的过程。对于那些在它周围长大的人来说，它可能会变得更容易。然而，从一开始就学习这些东西的人可能会对其中一些概念感到非常困难。</p><p id="75a0" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">今天，我将分解3个最广泛使用的高阶函数，并展示这些函数背后发生了什么。理解当你使用这些功能时会发生什么是非常重要的，而且你很有可能在面试中看到这些功能。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><h1 id="8ee3" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">高阶函数</h1><p id="c786" class="pw-post-body-paragraph kz la in lb b lc mn jo le lf mo jr lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">首先…什么是高阶函数？</p><p id="2edc" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">接受和/或返回另一个函数的函数称为<strong class="lb io">高阶函数</strong>。这意味着我们可以和这些人一起做一些非常有趣的事情。</p><h2 id="2d49" class="ms lw in bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">使用其他函数作为参数</h2><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="c6cd" class="ms lw in nf b gy nj nk l nl nm">isEven = (number) =&gt; number % 2 ===0;<br/>result = [1, 2, 3, 4, 5].filter(isEven)<br/>console.log(result)</span><span id="843d" class="ms lw in nf b gy nn nk l nl nm">// [2, 4]</span></pre><p id="ff3d" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">您可以看到，我们创建了一个箭头函数来确定一个数字是否为偶数。然后我们将那个<code class="fe no np nq nf b">isEven</code>函数作为参数传递给了<code class="fe no np nq nf b">.filter</code>。</p><h2 id="d3e7" class="ms lw in bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">返回函数</h2><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="04a4" class="ms lw in nf b gy nj nk l nl nm">add = (x) =&gt; (y) =&gt; x + y;</span></pre><p id="f1a5" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated"><code class="fe no np nq nf b">add</code>是一个需要两个参数的函数。首先，它请求<code class="fe no np nq nf b">x</code>，但是它返回一个请求<code class="fe no np nq nf b">y</code>的函数。</p><p id="8434" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这是因为JavaScript允许函数作为返回值，就像字符串、数字和布尔值一样。</p><p id="0b91" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">如果你想立即传递这些参数，你可以写一个叫做双重调用的东西——连续调用两个东西。看起来会像这样:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="d697" class="ms lw in nf b gy nj nk l nl nm">result = add(10)(20)</span><span id="1212" class="ms lw in nf b gy nn nk l nl nm">console.log(result) //30</span></pre><p id="5440" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">您也可以在不同的时间调用它们:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="8cf6" class="ms lw in nf b gy nj nk l nl nm">add10 = add(10)<br/>result = add10(20)</span><span id="5088" class="ms lw in nf b gy nn nk l nl nm">console.log(result) //30</span></pre><h2 id="6032" class="ms lw in bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">更高的可重用性</h2><p id="ff03" class="pw-post-body-paragraph kz la in lb b lc mn jo le lf mo jr lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">也许高阶函数最好的一点就是它们的可重用性。可重用性意味着更少的代码。更少的代码意味着更高效、更易读。微波炉上没有1分钟按钮有意义吗？那个按钮是预先设定好的，用来执行特定的功能，帮助你反复执行某个动作。</p><p id="825a" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">子丽和子思正在吹嘘他们最新的程序的规模。子礼道:“二十万行，不算评论！”子思回答说:“嘘，我的已经差不多一百万行了。”元马大师说:“我最好的程序有五百行。”听了这话，子礼和子思恍然大悟。”—元马大师，编程之书</p><p id="dc10" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">以同样的方式思考高阶函数。这些功能使得反复执行某些动作变得更加容易。再次强调效率和可读性。</p><p id="a6a6" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">有两种方法来构建一个软件设计:一种是让它简单到没有明显的缺陷，另一种是让它复杂到没有明显的缺陷— C.A.R. Hoare，1980年ACM图灵奖讲座</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="5681" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我想先讲3个主要的高阶函数。地图()。我将从头开始研究函数的样子，然后研究高阶函数的样子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/e1dc3c6e0071e784f09ab1de1a53ab8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VYFQhO8MTZpOORurLz3mwA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Funny picture that breaks down each method of .map(), .filter(), and .reduce()</figcaption></figure><h1 id="aa40" class="lv lw in bd lx ly nt ma mb mc nu me mf jt nv ju mh jw nw jx mj jz nx ka ml mm bi translated">。地图()</h1><p id="4ebf" class="pw-post-body-paragraph kz la in lb b lc mn jo le lf mo jr lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">从头开始:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="8b5f" class="ms lw in nf b gy nj nk l nl nm">const nums = [9, 4, 23, 52, 65];</span><span id="0d89" class="ms lw in nf b gy nn nk l nl nm">const plusTwo = () =&gt; {<br/>const newArray = [];</span><span id="5453" class="ms lw in nf b gy nn nk l nl nm">for (let i = 0; i &lt; nums.length; i++) {<br/>   newArray.push(nums[i] + 2)<br/>}<br/>return newArray;<br/>}</span><span id="4bd6" class="ms lw in nf b gy nn nk l nl nm">// [11, 6, 25, 54, 67]</span></pre><p id="b80a" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">使用高阶函数:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="4050" class="ms lw in nf b gy nj nk l nl nm">const nums = [9, 4, 23, 52, 65];</span><span id="79e3" class="ms lw in nf b gy nn nk l nl nm">const plusTwo = nums.map(number =&gt; number + 2)</span><span id="9e69" class="ms lw in nf b gy nn nk l nl nm">console.log(plusTwo) <br/>// [11, 6, 25, 54, 67]</span></pre><p id="d583" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">你可以看到第一个选项——从头开始——有更多的内容。使用这个选项，我们遍历整个<code class="fe no np nq nf b">nums</code>数组，对每次迭代做一些事情，将其推送到<code class="fe no np nq nf b">newArray</code>，然后返回那个<code class="fe no np nq nf b">newArray</code>。</p><p id="b417" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我们的第二个选择——使用<code class="fe no np nq nf b">.map()</code>——需要少得多。我们绘制地图，命名每一个迭代<code class="fe no np nq nf b">number</code>，并对这个数字做一些事情。默认情况下，map方法自动返回一个新数组，所以我们最终得到的是<code class="fe no np nq nf b">const plusTwo = [11, 6, 25, 54, 67]</code>。<code class="fe no np nq nf b">.map()</code>基本上是在<code class="fe no np nq nf b">nums</code>的基础上创建了一个新的数组，但是在每个数字上加了2，而且用了更少的代码，更容易阅读。</p><h1 id="1c0f" class="lv lw in bd lx ly nt ma mb mc nu me mf jt nv ju mh jw nw jx mj jz nx ka ml mm bi translated">。减少()</h1><p id="555a" class="pw-post-body-paragraph kz la in lb b lc mn jo le lf mo jr lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">从头开始:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="5c27" class="ms lw in nf b gy nj nk l nl nm">const nums = [15, 25, 7, 3, -2, 90];<br/>let sum = 0;</span><span id="aaa5" class="ms lw in nf b gy nn nk l nl nm">const sumArray = (nums) =&gt; {<br/>  for ( let i = 0; i &lt; nums.length; i++) {<br/>    sum += arr[i]<br/>  }<br/>console.log(sum);<br/>}</span></pre><p id="a27c" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">使用高阶函数:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="ac22" class="ms lw in nf b gy nj nk l nl nm">const nums = [15, 25, 7, 3, -2, 90];</span><span id="8dc3" class="ms lw in nf b gy nn nk l nl nm">const sum = nums.reduce((total, currentVal) =&gt; total + currentVal, 0)</span></pre><p id="f865" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">所以这个有点令人困惑。想象一个缩减器，一个可以把很多事情缩减成一件事情的东西。在这种情况下，我们将一个数组中的许多数字一个接一个地加在一起，以便<em class="nr">将它们减少到一个数字。</em></p><p id="a2a9" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">不过，这里的语法可能有点复杂。我用<code class="fe no np nq nf b">total</code>和<code class="fe no np nq nf b">currentVal</code>来让自己的头脑保持清醒。基本上，正在发生的事情是<code class="fe no np nq nf b">total</code>从0开始(我们告诉它在最后从哪里开始——这是reduce函数的第二个参数)。对于每次迭代，执行<code class="fe no np nq nf b">total + currentVal</code>。本质上是把这些数字一个一个加起来。<code class="fe no np nq nf b">sum</code>，最后，将有一个什么价值的减速器想出了。在这种情况下,<code class="fe no np nq nf b">sum = 138</code>一切都结束后。</p><p id="d9e5" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">重要的是要记住<code class="fe no np nq nf b">.reduce()</code>是一个<strong class="lb io">非常</strong>灵活的函数。它是所有高阶函数的万能工具。它可以用在许多不同的方面，我在这里展示的只是一个更容易理解的方面。小步骤…</p><h1 id="533d" class="lv lw in bd lx ly nt ma mb mc nu me mf jt nv ju mh jw nw jx mj jz nx ka ml mm bi translated">。过滤器()</h1><p id="8ec3" class="pw-post-body-paragraph kz la in lb b lc mn jo le lf mo jr lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">从头开始:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="c4b1" class="ms lw in nf b gy nj nk l nl nm">const nums = [9, 4, 23, 52, 65];</span><span id="c60e" class="ms lw in nf b gy nn nk l nl nm">const filterArray = () =&gt; {<br/>const newArray = [];</span><span id="4886" class="ms lw in nf b gy nn nk l nl nm">for (let i = 0; i &lt; nums.length; i++) {<br/>  if (nums[i] % 2 ===0) {<br/>    newArray.push(nums[i])<br/>    }<br/>  }<br/>return newArray;<br/>}</span></pre><p id="f5ca" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">使用高阶函数:</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="05a9" class="ms lw in nf b gy nj nk l nl nm">const filtered = nums.filter(number =&gt; number % 2 === 0)</span></pre><p id="9c72" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">好多了，对吧？在这两种情况下，返回的数组都是<code class="fe no np nq nf b">[4, 52]</code>，但是两者使用的代码看起来有很大的不同。首先，我们必须遍历<code class="fe no np nq nf b">nums</code>数组，对每个数字使用一个条件语句，如果它通过了，就把它推到<code class="fe no np nq nf b">newArray</code>，然后返回<code class="fe no np nq nf b">newArray</code>。这里发生了很多事情…</p><p id="a5b9" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">第二个选择是<strong class="lb io">更加</strong>直截了当。它做同样的事情，但是代码更少。<code class="fe no np nq nf b">number</code>代表<code class="fe no np nq nf b">nums</code>数组中的每一个数字，因为函数会遍历该数组。每次我们处理一个新号码时，它都会检查是否在使用<code class="fe no np nq nf b">number % 2 === 0</code>。非常重要的是要记住。filter()函数总是返回一个数组。因此，每个“通过测试”的数字都被推送到返回的新数组中。</p><h2 id="407b" class="ms lw in bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">结论</h2><p id="b5f7" class="pw-post-body-paragraph kz la in lb b lc mn jo le lf mo jr lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">因此，一开始学习这些东西可能会相当令人生畏。特别是，它是以训练营或其他快节奏的形式出现的。然而，理解幕后发生的事情是非常重要的，同样重要的还有我们为什么以这种方式做事。如果你发现自己真的在挣扎，记得休息一下。</p><p id="4e94" class="pw-post-body-paragraph kz la in lb b lc ld jo le lf lg jr lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">特别感谢FreeCodeCamp.org在这篇文章中提供的一些信息。我强烈推荐任何新的或有经验的程序员利用他们提供的资源。你可以在这里找到他们文章<a class="ae ny" href="https://www.freecodecamp.org/news/a-quick-intro-to-higher-order-functions-in-javascript-1a014f89c6b/" rel="noopener ugc nofollow" target="_blank">的完整内容</a>。</p></div></div>    
</body>
</html>