<html>
<head>
<title>Web Workers For Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的Web Workers</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-workers-for-beginners-57d7a389cded?source=collection_archive---------1-----------------------#2020-08-01">https://javascript.plainenglish.io/web-workers-for-beginners-57d7a389cded?source=collection_archive---------1-----------------------#2020-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e2ec16d0e2ee34edeb98014efea0fefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YmHdcc-lAKsTWPYc9fjRVw.png"/></div></div></figure><h2 id="02e3" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">JavaScript是一种单线程语言，这意味着它按顺序执行代码，并且必须在执行完一段代码后才能进入下一段代码。</h2><p id="6068" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">对于HTTP请求，JavaScript为我们提供了非阻塞的XMLHttpRequest。但是如果我们在程序中有一个CPU密集型代码，它将阻塞主线程直到它完成，使得UI在那段时间内没有响应。一种解决方法是使用setTimeout或setInterval。我们可以将CPU密集型代码分解成更小的部分，并附加超时。虽然它可能适用于较小的程序，但随着代码复杂性的增加，决定在哪里添加超时函数变得越来越困难。我们需要的是一个独立的线程来完成这些计算，从而使主线程可以自由地处理UI事件、操纵DOM或执行其他任务。</p><h2 id="9cfc" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">网络工人前来救援</strong></h2><p id="ec3a" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">HTML5向我们介绍了Web Worker。Web Workers是运行在不同线程上的JavaScript程序，与主线程并行。它允许您将长时间运行和计算密集型任务放在后台，而不会阻塞用户界面，使您的应用程序响应更快。Worker利用类似线程的消息在主脚本和后台脚本之间传递来实现并行性。</p><h2 id="7389" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">网络工作者的类型</h2><p id="bb03" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">通过为并行JavaScript程序创建单独的线程，工作线程允许我们实现多线程。有两种类型的网络工作者。</p><p id="b24b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁ <strong class="kw ir">专用工作器</strong>:专用Web工作器由主进程实例化，只能与之通信。</p><p id="cc3e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁ <strong class="kw ir">共享工作器</strong>:共享工作器可以被运行在同一个起点上的所有进程访问(不同的窗口、浏览器标签、iframes或其他共享工作器)。</p><blockquote class="lu lv lw"><p id="cc3a" class="ku kv lx kw b kx lp kz la lb lq ld le ly lr lg lh lz ls lj lk ma lt lm ln lo ij bi translated">本文将只涉及专门的工作者，我将通篇把他们称为'<strong class="kw ir"> web </strong> <strong class="kw ir"> workers </strong>或'<strong class="kw ir"> workers </strong>'。</p></blockquote><h2 id="6acb" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">入门指南</h2><p id="cb5e" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">Web Workers在浏览器中的一个孤立线程中运行。因此，它们执行的代码包含在单独的<strong class="kw ir"> JavaScript </strong>文件中，并通过异步HTTP请求合并到您的页面中。为了创建一个工作线程，我们在主页上添加了以下几行。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="79bd" class="jy jz iq mg b gy mk ml l mm mn">var worker = new Worker(‘calculate.js’);</span></pre><p id="8502" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果“<strong class="kw ir"> calculate.js </strong>”文件存在并且可以访问，浏览器将生成一个新线程来异步下载该文件。下载完成后，它将被执行，并且worker将开始。如果所提供的文件路径返回404，那么worker将会无声地失败。</p><p id="6a7f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">要启动worker，我们必须调用一个<strong class="kw ir"> postMessage </strong>()方法。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b1a9" class="jy jz iq mg b gy mk ml l mm mn">worker.postMessage(message, [transfer]);</span></pre><p id="9577" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这里的<strong class="kw ir">消息</strong>是传递给工作页面的对象。一个<strong class="kw ir">转移</strong>是一个可转移对象的可选数组(我们将在后面的章节中讨论可转移对象)。</p><p id="c2e5" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">web worker和主页面之间的通信通过两种方法进行，即<strong class="kw ir"> postMessage </strong>()方法和“<strong class="kw ir">message”</strong>事件处理程序。</p><p id="44e3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">postMessage 可以接受一个字符串或JSON对象作为它的单个参数。新的浏览器支持JSON对象作为方法的第一个参数，而旧的浏览器只支持字符串。当从<strong class="kw ir"> postMessage() </strong>发送一条消息时，另一个页面将接收该事件作为“<strong class="kw ir">消息</strong>”事件。对于错误处理，传递一个'<strong class="kw ir">错误</strong>'事件。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="acc0" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在上面的例子中，<strong class="kw ir">main.html</strong>用<strong class="kw ir"> postMessage </strong>调用了两个web workers(质数和阶乘)。我对质数和斐波那契方法使用了不同的web workers，这两种方法都象征着大量的计算。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c364" class="jy jz iq mg b gy mk ml l mm mn">primeWorker.postMessage({cmd:'first50'});<br/> <br/>fibonacciWorker.postMessage({cmd:'first100'});</span></pre><p id="0ee4" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">工作文件本身正在监听'<strong class="kw ir"> message' </strong>事件，一旦收到事件，它们就进行计算，并借助<strong class="kw ir"> self.postMessage </strong>方法将结果发送回来。我还添加了第三个按钮来改变背景颜色，它象征着用户界面的变化。当您从脚本中调用prime或factorial时，会产生一个独立的并行web worker线程，它将处理这些方法，并且您可以通过单击change background按钮在UI中并行地进行更改。</p><p id="14ad" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在main.html的文件中，我还添加了一个<strong class="kw ir">错误</strong>事件监听器。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6383" class="jy jz iq mg b gy mk ml l mm mn">fibonacciWorker.addEventListener('error', errorEvent, false);</span></pre><p id="12b3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果在工作线程执行时发生错误，将触发ErrorEvent。这个接口包含三个有用的属性，用于找出错误所在:<strong class="kw ir"> filename </strong> —导致错误的工作脚本的名称，<strong class="kw ir"> lineno </strong> —错误发生的行号，以及<strong class="kw ir"> message </strong> —对错误的有意义的描述。</p><p id="6d42" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">你一定注意到了我在<strong class="kw ir"> prime.js中使用了" self "，在<strong class="kw ir"> fibonacci.js </strong>中使用了"</strong> this" <strong class="kw ir"> </strong>，这是因为在worker的上下文中，" self "和" this "都引用了worker的全局范围。</p><p id="8b1e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在这里，如果我们没有使用web workers，那么在fibonacci和prime函数进行计算的时候，浏览器将会冻结，因此在那个时候您将无法与UI进行交互。</p><h2 id="6c94" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">导入脚本和库</h2><p id="4b78" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">工作线程可以使用<strong class="kw ir"> importScripts </strong>()方法导入外部脚本。它接受零个或多个URIs作为导入资源的参数。浏览器加载每个列出的脚本并执行它。来自每个脚本的任何全局对象然后可以被工作者使用。如果无法加载脚本，则抛出<code class="fe mq mr ms mg b">NETWORK_ERROR</code>，后续代码不会执行。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="03b6" class="jy jz iq mg b gy mk ml l mm mn">importScripts(‘foo.js’); /* imports just “foo.js” */</span><span id="5e24" class="jy jz iq mg b gy mt ml l mm mn">importScripts(‘foo.js’, ‘bar.js’);</span><span id="6328" class="jy jz iq mg b gy mt ml l mm mn">importScripts('//example.com/hello.js'); </span></pre><h2 id="f204" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">分包商</h2><p id="0164" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">工作线程可能会产生更多的子工作线程。这对于在运行时进一步分解大型任务非常有用。然而，子工作者有他们自己的一些条件:</p><p id="a1d5" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁子工作器必须与父页面托管在相同的源中。</p><p id="bf8a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">子工作器中的uris是相对于其父工作器的位置来解析的。这使得员工更容易跟踪他们的依赖关系在哪里。</p><p id="c3b2" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">但是当产生子工作器时，我们必须小心不要占用太多的用户系统资源。</p><h2 id="0a4b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">嵌入式工人</h2><p id="1679" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">如果您想要即时创建工作脚本，或者不想为工作脚本创建单独的文件。借助Blob和使用数据块，您可以将它们全部嵌入到一个页面中。</p><p id="9daa" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">使用Blob()，您可以通过创建一个字符串形式的工作器代码的URL句柄，将工作器“内联”到与主逻辑相同的HTML文件中。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="68eb" class="jy jz iq mg b gy mk ml l mm mn">let blob = new Blob([<br/>    "onmessage = function(e) { postMessage('msg from worker'); }"]);<br/><br/><em class="lx">// Obtain a blob URL reference to our worker 'file'.</em><br/>let blobURL = window.URL.createObjectURL(blob);</span></pre><p id="023b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">神奇的事情发生在<strong class="kw ir">窗口。URL.createObjectURL() </strong>。该方法创建一个简单的URL字符串，可用于引用存储在DOM文件或Blob对象中的数据。Blob URLs是唯一的，并且在应用程序的整个生命周期中都有效(例如，直到文档被卸载)。</p><p id="a0b0" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">现在是聪明的部分。JavaScript(数据块)不会解析没有src属性或具有不标识可执行MIME类型的type属性的脚本元素。因此，我们可以在这个脚本标记中编写我们的工作代码，然后使用Blob为其创建一个URL。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="fd9e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在上面的例子中，在脚本id“worker-1”中，我添加了web worker的代码，然后在JavaScript解析脚本中为其创建了一个Blob URL。</p><h2 id="c680" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">与员工之间传输数据</h2><p id="18a0" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">当我们使用<strong class="kw ir"> postMessage </strong>时，我们在web workers和主页面之间传输数据。这些数据是复制的，而不是在两个页面之间共享的，也就是说，对象在被传递给工作者时被序列化，然后在另一端被反序列化。大多数浏览器将此功能实现为<em class="lx"> </em> <a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="lx">结构化克隆</em> </a> <em class="lx">。</em>这对于小数据传输似乎没问题，但对于大数据量，这是一个明显的开销。</p><p id="8cdf" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">为了减轻这种性能损失，我们可以使用一个<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" rel="noopener ugc nofollow" target="_blank">可转移的</a>对象。使用可转移对象，数据可以从一个上下文转移到另一个上下文。它极大地提高了向工作人员发送数据的性能。如果你来自C/C++世界，可以把它看作是按引用传递。然而，与按引用传递不同，调用上下文中的“版本”一旦转移到新上下文中就不再可用。例如，当将一个ArrayBuffer从主应用程序转移到Worker时，原来的ArrayBuffer被清除，不再可用。它的内容被转移到Worker上下文。</p><p id="6145" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">要使用可转移对象，使用以下命令</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c96d" class="jy jz iq mg b gy mk ml l mm mn">worker.postMessage(arrayBuffer, [arrayBuffer]);</span></pre><p id="de82" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">第一个参数是数据，第二个参数是应该传输的项目列表。</p><h2 id="e6d9" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">可供网络工作者使用的功能</h2><p id="9fcf" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">由于多线程的特性，网络工作者只能访问JavaScript特性的一个子集。以下是功能列表:</p><p id="52a5" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">航海家⦁物体</p><p id="0e5c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁位置对象(只读)</p><p id="5234" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁ XMLHttpRequest</p><p id="9e1d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁ setTimeout()/clearTimeout()和setInterval()/clearInterval()</p><p id="17a1" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁应用程序缓存</p><p id="fc26" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁使用importScripts()导入外部脚本</p><p id="82ab" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁创造其他网络工作者</p><p id="f3ff" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁ Web Worker限制</p><p id="5ecb" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">网络工作者无法使用一些非常重要的JavaScript特性:</p><p id="d791" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">dom(它不是线程安全的)</p><p id="05f7" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">窗口对象⦁</p><p id="3f1e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">文档对象⦁</p><p id="1f8f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">父对象⦁</p><h2 id="493c" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">用例</h2><p id="79cd" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">网络工作者有很大的权力，但是就像俗话说的那样“权力越大，责任越大”。同样，我们在使用它们的时候也应该谨慎。在后台任务必须与主UI任务并行执行或者所执行的任务必须对用户隐藏的情况下，这应该是优选的。它的一些其他用例可能是:</p><p id="4102" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁预取和/或缓存数据以备后用。</p><p id="618e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁代码语法高亮显示或其他实时文本格式化。</p><p id="489b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁拼写检查器</p><p id="9edc" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁进步网络应用</p><p id="cf94" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁分析视频或音频数据。</p><p id="4372" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">web服务的⦁后台I/O或轮询。</p><p id="c985" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁处理大型数组或庞大的JSON响应。</p><p id="273a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><canvas>中的⦁图像滤波。</canvas></p><p id="cf2a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">⦁更新本地web数据库的许多行。</p><blockquote class="lu lv lw"><p id="f456" class="ku kv lx kw b kx lp kz la lb lq ld le ly lr lg lh lz ls lj lk ma lt lm ln lo ij bi translated">请注意:由于安全问题，您不能在浏览器上本地运行您的web workers。我用了Chrome的网络服务器，效果很好。</p></blockquote><p id="d5ac" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">感谢您抽出时间阅读这篇文章。在下一篇文章中，我将讨论服务工作者，一种不同但非常有用的web工作者。</p></div></div>    
</body>
</html>