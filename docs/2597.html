<html>
<head>
<title>JavaScript Best Practices — Objects and Invalid Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—对象和无效语法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-objects-and-invalid-syntax-287630a4d26c?source=collection_archive---------9-----------------------#2020-07-07">https://javascript.plainenglish.io/javascript-best-practices-objects-and-invalid-syntax-287630a4d26c?source=collection_archive---------9-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ccb083bd2f838c61167f1c4d6b672d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mhUY7Uoa9mxYPqPZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@calanthe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zosia Korcz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8250" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究在编写JavaScript代码时应该遵循的一些最佳实践。</p><h1 id="ba9d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">定义Setter时，对象必须包含Getter</h1><p id="b554" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">定义setter时，对象应该有一个getter。</p><p id="2a89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有getter的setter不是很有用，所以我们应该添加一个。</p><p id="3043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="438b" class="mn lc iq mj b gy mo mp l mq mr">const person = {<br/>  set name (value) {<br/>    this._name = value<br/>  },<br/>  get name () {        <br/>    return this._name<br/>  }<br/>}</span></pre><p id="bb33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="da69" class="mn lc iq mj b gy mo mp l mq mr">const person = {<br/>  set name (value) {<br/>    this._name = value<br/>  }<br/>}</span></pre><h1 id="4780" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">派生类的构造函数必须调用super</h1><p id="79c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在派生类中调用<code class="fe ms mt mu mj b">super</code>。</p><p id="4b3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f5c0" class="mn lc iq mj b gy mo mp l mq mr">class Cat extends Animal {<br/>  constructor () {<br/>    super()          <br/>    this.legs = 4;<br/>  }<br/>}</span></pre><p id="1089" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在我们的类中设置属性之前不调用<code class="fe ms mt mu mj b">super</code>的话，我们会得到一个错误，正如我们在例子中所做的那样。</p><h1 id="e103" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用数组文字代替数组构造函数</h1><p id="dae5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">Array</code>构造函数只会给我们的数组声明增加额外的复杂性。</p><p id="1f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它做了两件不同的事情。</p><p id="7489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它传递了一个参数，那么它会返回一个空数组，其中包含数组中的空槽数。</p><p id="7aa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，它会返回一个带有我们传入的参数的数组。</p><p id="c906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该只使用数组文字。</p><p id="24d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7570" class="mn lc iq mj b gy mo mp l mq mr">const nums = [1, 2, 3];</span></pre><p id="cef8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="76a4" class="mn lc iq mj b gy mo mp l mq mr">const nums = new Array(1, 2, 3);</span></pre><h1 id="5e78" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用参数。被调用方和参数。调用方</h1><p id="0c65" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在<code class="fe ms mt mu mj b">arguments</code>对象中使用任何属性，包括<code class="fe ms mt mu mj b">callee</code>和<code class="fe ms mt mu mj b">caller</code>属性。</p><p id="c497" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们使代码优化变得不可能。此外，它们被弃用，并且在严格模式下被禁止。</p><p id="9f56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们永远不应该使用它们。</p><h1 id="9bd1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要修改类声明的变量</h1><p id="0864" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个类，那么我们就不应该把它分配给别的东西。</p><p id="0c1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将避免很多混乱。</p><p id="b4dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7280" class="mn lc iq mj b gy mo mp l mq mr">class Dog {}<br/>Dog = 'woof';</span></pre><p id="92d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这太令人困惑了。</p><h1 id="fdb8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免修改使用常量声明的变量</h1><p id="c14d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用新值重新分配<code class="fe ms mt mu mj b">const</code>变量会给我们一个错误。</p><p id="d5f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该这样做。</p><p id="ad52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2b81" class="mn lc iq mj b gy mo mp l mq mr">const score = 100;<br/>score = 125;</span></pre><p id="9c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以删除第二行，或者创建一个新的变量，并为其赋值。</p><h1 id="605b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">条件语句中没有常量表达式</h1><p id="bde8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">常量表达式在条件语句中不是很有用。</p><p id="74a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它们总是对同一事物求值，所以有条件语句是没有用的。</p><p id="7d30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7beb" class="mn lc iq mj b gy mo mp l mq mr">if (false) {<br/>  // ...<br/>}</span></pre><p id="27f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">块内的代码从未运行过，因为我们有<code class="fe ms mt mu mj b">false</code>作为条件。</p><p id="feef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们可以将它们循环使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8fee" class="mn lc iq mj b gy mo mp l mq mr">while (true) {<br/>  // ...<br/>}</span></pre><p id="ae4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们可能想要无限循环。</p><h1 id="0e26" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正则表达式中没有控制字符</h1><p id="d915" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">regexes中不应该有控制字符。</p><p id="d614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是不可见的，并且很少在JavaScript字符串中使用。</p><p id="c895" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，将它们包括在内可能是一个错误。</p><p id="573b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d1a7" class="mn lc iq mj b gy mo mp l mq mr">const re = /\x1f/;</span></pre><h1 id="6aae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无调试器语句</h1><p id="3e2b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">debugger</code>语句用于在我们的代码中添加断点，以便我们可以检查变量。</p><p id="bbdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们应该记得在使用完它们后删除它们，这样我们的应用在生产时就不会暂停。</p><h1 id="d913" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">变量上没有删除运算符</h1><p id="0b8e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">delete</code>操作符用于删除属性。</p><p id="f615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它们不应该用在变量上。</p><p id="129f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0e4f" class="mn lc iq mj b gy mo mp l mq mr">let foo;<br/>delete foo;</span></pre><h1 id="5c33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数签名中没有重复的参数</h1><p id="8094" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在函数签名中有重复的参数。</p><p id="4abb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是无效的语法，会给我们带来意想不到的结果。</p><p id="b620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="50ab" class="mn lc iq mj b gy mo mp l mq mr">function sum (a, a, b) {  <br/>  // ...<br/>}</span></pre><p id="2060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aa7b" class="mn lc iq mj b gy mo mp l mq mr">function sum (a, b, c) {  <br/>  // ...<br/>}</span></pre><h1 id="1f47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类成员中没有重复的名称</h1><p id="7652" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有两个同名的班级成员。</p><p id="8022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那会产生意想不到的结果。</p><p id="6d23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4bf2" class="mn lc iq mj b gy mo mp l mq mr">class Cat {<br/>  meow() {}<br/>  meow() {}<br/>}</span></pre><p id="f3e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该给它们取不同的名字。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/c7b88a8cfd42e6ef9fe8413c3aaa4e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*phrDVsl2jMA0wOyH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@relentlessjpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">William Moreland</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="159c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="fe45" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在JavaScript代码中以无效的方式使用操作符。</p><p id="13b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该在不该出现的地方出现重复的表达式。</p><p id="b020" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何多余的字符和<code class="fe ms mt mu mj b">debugger </code>语句都应该从我们的代码中删除。</p><h2 id="ddd4" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">简单英语的JavaScript</h2><p id="a01a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>