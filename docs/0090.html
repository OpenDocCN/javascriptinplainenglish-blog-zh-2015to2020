<html>
<head>
<title>A Quick and Easy Guide to React Component Lifecycle Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速简单的组件生命周期反应方法指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-component-lifecycle-570e8dc75137?source=collection_archive---------0-----------------------#2019-03-02">https://javascript.plainenglish.io/react-component-lifecycle-570e8dc75137?source=collection_archive---------0-----------------------#2019-03-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6387" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本周，我如约带着另一篇文章回来了。这篇文章只是关于React组件生命周期方法。所以让我们开始吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fbc61c096288925de80d3c4ba9792d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRAD50wbZEsTe6U4XNrMFA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Lifecycle methods of React Components src: <a class="ae ky" href="http://wikitechy.com" rel="noopener ugc nofollow" target="_blank">wikitechy</a></figcaption></figure><p id="7d8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">生命周期方法</strong>:</p><ol class=""><li id="a83b" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated"><strong class="jm io"> componentWillMount </strong>在渲染之前在服务器端和客户端执行。</li><li id="c385" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated"><strong class="jm io">componentidmount</strong>仅在客户端第一次渲染后执行。这是AJAX请求和DOM或状态更新应该发生的地方。</li><li id="5aeb" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">在调用另一个渲染之前，一旦更新了属性，就会调用componentWillReceiveProps 。</li><li id="5eb9" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated"><strong class="jm io">shouldcomponentdupdate</strong>应该返回一个真或假的值。这将决定是否更新组件。默认情况下，该值设置为true。如果您确定组件在状态或属性更新后不需要呈现，您可以返回一个false值。</li><li id="b9d3" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated"><strong class="jm io"> componentWillUpdate </strong>在渲染之前被调用。</li><li id="3a12" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated"><strong class="jm io">componentiddupdate</strong>在渲染后立即被调用。</li><li id="b05b" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">从dom中卸载组件后，调用<strong class="jm io"> componentWillUnmount </strong>。我们正在卸载main.js中的组件。</li></ol><p id="0bfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例如:</strong></p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="62ff" class="ls lt in lo b gy lu lv l lw lx">//App.jsx<br/>import React from 'react';</span><span id="cf88" class="ls lt in lo b gy ly lv l lw lx">class App extends React.Component {<br/>   constructor(props) {<br/>      super(props);<br/>      <br/>      this.state = {<br/>         data: 0<br/>      }<br/>      this.setNewNumber = this.setNewNumber.bind(this)<br/>   };<br/>   setNewNumber() {<br/>      this.setState({data: this.state.data + 1})<br/>   }<br/>   render() {<br/>      return (<br/>         &lt;div&gt;<br/>            &lt;button onClick = {this.setNewNumber}&gt;INCREMENT&lt;/button&gt;<br/>            &lt;Content myNumber = {this.state.data}&gt;&lt;/Content&gt;<br/>         &lt;/div&gt;<br/>      );<br/>   }<br/>}<br/>class Content extends React.Component {<br/>   componentWillMount() {<br/>      console.log('Component WILL MOUNT!')<br/>   }<br/>   componentDidMount() {<br/>      console.log('Component DID MOUNT!')<br/>   }<br/>   componentWillReceiveProps(newProps) {    <br/>      console.log('Component WILL RECIEVE PROPS!')<br/>   }<br/>   shouldComponentUpdate(newProps, newState) {<br/>      return true;<br/>   }<br/>   componentWillUpdate(nextProps, nextState) {<br/>      console.log('Component WILL UPDATE!');<br/>   }<br/>   componentDidUpdate(prevProps, prevState) {<br/>      console.log('Component DID UPDATE!')<br/>   }<br/>   componentWillUnmount() {<br/>      console.log('Component WILL UNMOUNT!')<br/>   }<br/>   render() {<br/>      return (<br/>         &lt;div&gt;<br/>            &lt;h3&gt;{this.props.myNumber}&lt;/h3&gt;<br/>         &lt;/div&gt;<br/>      );<br/>   }<br/>}<br/>export default App;</span></pre><blockquote class="lz ma mb"><p id="ebe0" class="jk jl mc jm b jn jo jp jq jr js jt ju md jw jx jy me ka kb kc mf ke kf kg kh ig bi translated">现在让我们为应用程序创建一个主组件，它将包含我们刚刚创建的组件。</p></blockquote><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="6e55" class="ls lt in lo b gy lu lv l lw lx">//main.js<br/>import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from './App.jsx';<br/><br/>ReactDOM.render(&lt;App/&gt;, document.getElementById('app'));<br/><br/>setTimeout(() =&gt; {<br/>   ReactDOM.unmountComponentAtNode(document.getElementById('app'));}, 10000)</span></pre><h2 id="8ccd" class="ls lt in bd mg mh mi dn mj mk ml dp mm jv mn mo mp jz mq mr ms kd mt mu mv mw bi translated">进一步阅读</h2><div class="mx my gp gr mz na"><a href="https://bit.cloud/blog/-extracting-and-reusing-pre-existing-components-using-bit-add-l28qlxpz" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">使用位添加提取和重用预先存在的组件</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">最后，您完成了为应用程序中的输入创建一个奇妙的输入字段的任务。你对……很满意</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">比特云</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ks na"/></div></div></a></div><p id="73c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">更多内容请看</em><a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mc">plain English . io</em></strong></a><em class="mc">。报名参加我们的</em> <a class="ae ky" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mc">免费周报</em> </strong> </a> <em class="mc">。关注我们关于</em><a class="ae ky" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mc">Twitter</em></strong></a><a class="ae ky" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mc">LinkedIn</em></strong></a><strong class="jm io"><em class="mc"/></strong><a class="ae ky" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mc">YouTube</em></strong></a><strong class="jm io"><em class="mc">，以及</em></strong><em class="mc"/><a class="ae ky" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="mc">不和</em> </strong> </a>  <em class="mc">对成长黑客感兴趣？检查</em> <a class="ae ky" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="mc">电路</em> </strong> </a> <strong class="jm io"> <em class="mc">。</em> </strong></p></div></div>    
</body>
</html>