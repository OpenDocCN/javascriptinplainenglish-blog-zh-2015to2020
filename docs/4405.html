<html>
<head>
<title>JavaScript Async Await: Promisify the future to callback never again!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Async Await:承诺未来不再回调！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-async-await-promisify-the-future-to-callback-never-again-6762707e18e5?source=collection_archive---------12-----------------------#2020-12-08">https://javascript.plainenglish.io/javascript-async-await-promisify-the-future-to-callback-never-again-6762707e18e5?source=collection_archive---------12-----------------------#2020-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e09" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对承诺的回调直到异步等待</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a9408de3a2f02e048140de1299404037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iBkTUy7PjnWRebbj"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://unsplash.com/@kylebroad" rel="noopener ugc nofollow" target="_blank">Kyle Broad</a>, by <a class="ae kv" href="https://unsplash.com/photos/P9rQn2qcEV0" rel="noopener ugc nofollow" target="_blank">unsplash</a></figcaption></figure><h1 id="154a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="257d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有C#背景？那么您应该熟悉async-await。JavaScript在2017年将这些关键词引入语言。它们有助于解决异步代码的问题。</p><p id="dfbc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">到目前为止，异步代码以使用回调而闻名，它们大多是嵌套的，导致代码难以理解。这里有一张<a class="ae kv" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>或者也称为<a class="ae kv" href="https://levelup.gitconnected.com/escape-the-pyramid-of-doom-c58edd326225" rel="noopener ugc nofollow" target="_blank">末日金字塔</a>【2】【1】的图片。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/f7fc4c6afee95b09a9f4ca74b32ae10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*vqaLQGjDK1jKMvzV"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">author: <a class="ae kv" href="https://www.summarysofar.com/2019/11/24/mdn-make-me-understand" rel="noopener ugc nofollow" target="_blank">summary so far</a> (All rights reserved)</figcaption></figure><p id="a33a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">解决这个问题有很多选择，但没有一个是大的，成为一个可行的方法。他们都提出了自己的问题。无论是承诺还是生成器函数，甚至是Async之类的模块。JS [3]。</p><h1 id="885c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">昨天的代码</h1><p id="1fd1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">尽管async和await是一个重大的变化，但是我们不应该抛弃旧的概念。Async await在内部基于生成器函数和承诺。承诺依赖于什么？对！复试。新的抽象层次带来了封装旧概念的更好方法，但也带来了同样的问题。<a class="ae kv" href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/" rel="noopener ugc nofollow" target="_blank">软件公司的乔尔</a>在这种情况下做得很好。</p><p id="bdab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">具体来说:<em class="mq"> Async-Await </em>只能用于已经依赖于承诺的函数。如果你有没有的方法，你必须转换它们以便使用<em class="mq"> async-await </em>。这样做的一个好方法是使用一种叫做包装的技术。将现有的基于回调的函数包装到另一个使用承诺的函数中。这里有一个使用<em class="mq"> readFile </em>的例子来说明我的意思。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="eb80" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">包装函数清晰可见，调用promise构造函数。主体公开了基于回调机制的源函数。</p><p id="5e2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在想象你一整天都在为不同的项目做这件事。这是一个可怕的任务，只会给你带来痛苦和折磨。好在还有希望。如果您在节点中工作。基于JS的环境，你可以加快这一点。有一个准则，回调是函数的最后一个参数。返回错误通常是这个函数的第一个参数。当您的代码符合这些准则时，您可以只使用Node的效用函数。JS <a class="ae kv" href="https://nodejs.org/dist/latest-v8.x/docs/api/util.html" rel="noopener ugc nofollow" target="_blank"> <em class="mq">许诺</em></a>【5】。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f52f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以从这里的差价操作中获得巨大的利润。</p><p id="890c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个片段相当令人困惑。不要着急，仔细查看这个抽象的图表，看看各行的执行顺序和旁边的解释:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/8318a03fbca1863a2109185c35113925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xB0irhtwpXju3WNsKH66hA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">“Promisify the future”-explained, Author: Arnold Abraham</figcaption></figure><h1 id="1ade" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">现在</h1><p id="2fe9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">带有8.0版本节点。JS引入了一个内置的<a class="ae kv" href="https://nodejs.org/dist/latest-v8.x/docs/api/util.htm" rel="noopener ugc nofollow" target="_blank">实用程序</a> [5]让你更容易地使用promisify，并使它能够使用<em class="mq">异步等待</em>关键字。你可以得到丰富的源代码，易于理解，非常紧凑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7b4d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看看这段代码，读起来像同步代码吗？是的，肯定会，但它不会同步执行。在<em class="mq">等待</em>之后的函数被分解成一个协同例程。从技术上讲，这是一个生成器函数，在等待期间，异步代码可以继续运行。</p><p id="09f9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了使用<em class="mq"> await </em>，函数本身必须用关键字<em class="mq"> async </em>标记。调用函数<em class="mq"> processFile </em>也可以等待，只要调用方法也是异步标记的。只要调用方的调用方是异步方法，也可以等待调用方。</p><p id="de6c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">记得我提到末日金字塔的那部分。也可以在这里建立。新技术，老问题。此外，即使嵌套的if语句也可以被构造成厄运金字塔。</p><h1 id="8e49" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">第一批订单等待？</h1><p id="e9bd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">末日金字塔问题带来了一些问题。这个链条的第一条是什么？难道不应该是程序的主函数或者JavaScript的入口函数也应该是异步的吗？技术上是的，但它是同步的。还做什么？</p><p id="6f0f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">急救可以是自调用异步函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3f6b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">只是提一下，在这个<a class="ae kv" href="https://stackoverflow.com/questions/46515764/how-can-i-use-async-await-at-the-top-level" rel="noopener ugc nofollow" target="_blank"><em class="mq">stack overflow-answer</em></a>中列出了在你的入口点内部调用一个async的不同方法。[6]</p><p id="fbc0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Async也可用于lambdas，当然，正如您在示例中看到的try-catch(<em class="mq">03 _ async await . js</em>)。这是纯承诺或回调做不到的。try-catch会在语法上中断同步程序的执行。<br/>由于与同步程序相似，同步程序的控制结构很容易包含。特别是对于循环，<em class="mq"> async-await </em>被证明是非常有用的。它让您的代码的读者理解循环，而没有异步思维，尽管它是。</p><p id="44a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你曾经尝试过用纯回调或者基于承诺的代码来做一个循环吗？那么你知道我在说什么。</p><h1 id="adb5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="ef29" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当你想侮辱的时候，深入挖掘，你会有所发现。这里你可能会说<em class="mq"> async-await </em>并没有解决开发的根本问题。JavaScript并没有获得更多的技能，它以前和最后，也没有新的技术问题用这两个关键字解决。你是对的，但是对于可读性和理解以及编写代码所消耗的时间来说，<em class="mq"> async-await </em>弥补了巨大的差异。</p><p id="c993" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在编码时解决更简单的生活，更快的可理解性，可维护性，更少的易错性，我会说，<em class="mq"> async-await </em>已经使它的定位更加清晰，并给JavaScript带来了很多。</p><p id="45a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为你自己节省大量的时间，专注于重要的主题。  </p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="ca8d" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">继续读</h1><div class="ng nh gp gr ni nj"><a href="https://pjdarnold.medium.com/javascript-break-promises-keep-callbacks-4dbf9cff3d9a" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">JavaScript打破承诺&amp;保持回调</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">JavaScript中的回调:异步与同步</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">pjdarnold.medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://medium.com/javascript-in-plain-english/javascript-es6-modules-import-export-129a90e83ad6" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">JavaScript ES6模块导入导出</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">ES6模块导入导出业务用JavaScript和JS遗留代码</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx kp nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://medium.com/next-level-source-code/enums-typescript-4-0-and-javascript-guide-all-you-need-to-know-5e090355bff6" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">Enums TypeScript 4.0和JavaScript指南—您需要知道的一切</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">你将读到的关于enums的最后一个指南！</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx kp nj"/></div></div></a></div><h1 id="382c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">链接和参考</h1><p id="6a37" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">[1] <strong class="lq ir">末日金字塔</strong><br/><a class="ae kv" href="https://levelup.gitconnected.com/escape-the-pyramid-of-doom-c58edd326225" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/escape-the-Pyramid-of-Doom-c 58 edd 326225</a></p><p id="9f2f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[2] <strong class="lq ir">回调地狱<br/></strong><a class="ae kv" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">http://callbackhell.com/</a></p><p id="fe6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[3]<strong class="lq ir">async . js<br/></strong><a class="ae kv" href="https://caolan.github.io/async/v3/" rel="noopener ugc nofollow" target="_blank">https://caolan.github.io/async/v3/</a></p><p id="8820" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[4] <strong class="lq ir">乔尔关于软件<br/></strong><a class="ae kv" href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/" rel="noopener ugc nofollow" target="_blank">https://www . joelonsoftware . com/2002/11/11/the-law-of-leaky-abstracts/</a></p><p id="97c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">节点[5]。Js官方API-Doc util。许诺<br/></strong><a class="ae kv" href="https://nodejs.org/dist/latest-v8.x/docs/api/util.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/dist/latest-v8.x/docs/api/util.html</a></p><p id="f0bb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[6] <strong class="lq ir">来自main <br/> </strong> <a class="ae kv" href="https://stackoverflow.com/questions/46515764/how-can-i-use-async-await-at-the-top-level" rel="noopener ugc nofollow" target="_blank">的异步入口https://stack overflow . com/questions/46515764/how-can-I-use-Async-await-at-the-top-level</a></p></div></div>    
</body>
</html>