<html>
<head>
<title>How to Implement a Hash Map in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript实现散列映射</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-a-hash-map-be6a2696f250?source=collection_archive---------1-----------------------#2020-08-25">https://javascript.plainenglish.io/how-to-implement-a-hash-map-be6a2696f250?source=collection_archive---------1-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="365d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数组在查找特定索引处的元素方面非常出色，因为内存中的所有元素都是连续的，允许进行<code class="fe kl km kn ko b">O(1)</code>或常量时间查找。但是我们经常不或者不能通过索引来执行查找。哈希表和哈希表是解决这个问题的一种方法，使我们能够通过<code class="fe kl km kn ko b">keys</code>进行查找。</p><p id="423e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能从头开始实现<code class="fe kl km kn ko b">Map</code>类吗？只有两种方法是必需的- <code class="fe kl km kn ko b">get</code>和<code class="fe kl km kn ko b">set</code>。许多编程语言都有内置的散列或字典原语(如<code class="fe kl km kn ko b">Javascript</code> <code class="fe kl km kn ko b">Object</code> s和<code class="fe kl km kn ko b">{}</code>符号)，但是我们不想在这个练习中使用它们。</p><p id="7312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kp">这一课最初发表在https://algodaily.com</em><a class="ae kq" href="https://algodaily.com/challenges/implement-a-hash-map" rel="noopener ugc nofollow" target="_blank"><em class="kp"/></a><em class="kp">上，我在那里开设了一门技术面试课程，并为雄心勃勃的开发人员撰写思考文章。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0a2c59c8c85d02731810a705c94c7593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_a320ydz9-LPa0MT.png"/></div></div></figure><p id="6484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>常规的<code class="fe kl km kn ko b">Javascript</code>对象和<code class="fe kl km kn ko b">Map</code>类都是简单的键值散列表/关联数组，有一些关键的区别:</p><p id="c66e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kp">一个</em> <code class="fe kl km kn ko b"><em class="kp">Map</em></code> <em class="kp">对象可以按照插入顺序遍历它的元素，而JavaScript的</em> <code class="fe kl km kn ko b"><em class="kp">Object</em></code> <em class="kp">不保证顺序。另外，</em> <code class="fe kl km kn ko b"><em class="kp">Object</em></code> <em class="kp"> s由于原型原因有默认键，</em> <code class="fe kl km kn ko b"><em class="kp">Map</em></code> <em class="kp"> s没有自带默认键。</em> <a class="ae kq" href="https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373" rel="noopener"> <em class="kp">下面就好好细分一下</em> </a> <em class="kp">这两个。出于本练习的目的，让我们假设两者具有相同的功能。</em></p><p id="5e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于您将定义的两种方法:</p><ol class=""><li id="523d" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated"><code class="fe kl km kn ko b">get(key: string)</code>应该给定一个键，并返回该键的值。</li><li id="2e80" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><code class="fe kl km kn ko b">set(key: string, val: string)</code>应该以一个键和一个值作为参数，并存储这一对。</li></ol><p id="05c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们还提供了下面的散列函数<code class="fe kl km kn ko b">hashStr</code>。它试图避免碰撞，但并不完美。它接受一个字符串值并返回一个整数。</p><pre class="ks kt ku kv gt lr ko ls lt aw lu bi"><span id="e5ff" class="lv lw iq ko b gy lx ly l lz ma">function hashStr(str) {<br/>    let finalHash = 0;<br/>    for (let i = 0; i &lt; str.length; i++) {<br/>        const charCode = str.charCodeAt(i);<br/>        finalHash += charCode;<br/>    }<br/>    return finalHash;<br/>}<br/><br/>console.log(hashStr('testKey'))</span></pre><p id="ef34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们称我们的新类为<code class="fe kl km kn ko b">Hashmap</code>类，并像这样使用它:</p><pre class="ks kt ku kv gt lr ko ls lt aw lu bi"><span id="6047" class="lv lw iq ko b gy lx ly l lz ma">const m = new Hashmap();<br/>m.set('name', 'Jake');<br/>console.log(m.get('name'));</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先回顾一下普通哈希表是如何工作的，这个理论是我们的<code class="fe kl km kn ko b">Hashmap</code> <code class="fe kl km kn ko b">data structure</code>所基于的。正如我们已经注意到的，在许多编程语言中，有一个基于遗产<code class="fe kl km kn ko b">Hashtable</code>的<code class="fe kl km kn ko b">Hashmap</code>类。让我们一步一步地完成我们建议的代码实现。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/38ea4a5726a24ddda7a3c208ed8f8332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1igk0eyCI-CDsvrp.png"/></div></div></figure><p id="68c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们知道哈希表的工作原理是将数据存储在桶中。要访问这些桶，我们需要一种方法将<code class="fe kl km kn ko b">key</code>转换成桶号。(桶可以使用数组和<code class="fe kl km kn ko b"><a class="ae kq" href="https://dev.to/lessons/binary-search-technique" rel="noopener ugc nofollow" target="_blank">binary search</a></code>树来建模，但是为了保持简单和速度最大化，我们将坚持使用数组。)</p><p id="1fe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用键使我们不必知道数据在数组中的位置。因此，我们的<code class="fe kl km kn ko b">data structure</code>需要一个散列函数，在本例中提供为<code class="fe kl km kn ko b">hashStr</code>，将<code class="fe kl km kn ko b">index</code>计算到存储所需值的<code class="fe kl km kn ko b">buckets</code>中。我们本质上是通过我们的<code class="fe kl km kn ko b">hashStr</code>散列函数将<code class="fe kl km kn ko b">key</code>映射到一个数组索引。</p><pre class="ks kt ku kv gt lr ko ls lt aw lu bi"><span id="052f" class="lv lw iq ko b gy lx ly l lz ma">hashStr('r')<br/>// 114<br/><br/>// array = [  _  ,  X  ,  _  ,  _ ]<br/>// index     113   114   115   116</span></pre><p id="b39c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，<code class="fe kl km kn ko b">hashStr</code>所做的就是获取<code class="fe kl km kn ko b">set()</code>中提供的<code class="fe kl km kn ko b">key</code>，并为我们计算一个位置。因此，我们需要另一个<code class="fe kl km kn ko b">data structure</code>来存放值的实际存储和存储桶。当然，你已经知道它是一个数组了！</p><h1 id="b46b" class="mk lw iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">填写</h1><p id="2f26" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">哈希表的槽或桶通常存储在_ _ _ _ _ _ _ _ _及其索引中。</p><p id="18d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解:</strong>阵</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="a748" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写该类的良好开端是仅使用存储阵列对其进行初始化:</p><p id="28a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<code class="fe kl km kn ko b">hashStr</code>返回的索引来决定输入的值应该放在<code class="fe kl km kn ko b">this._storage</code>中的什么位置。</p><p id="36ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kp">关于冲突的一句话</em> : <code class="fe kl km kn ko b">collisions</code>当一个哈希函数为多个键返回相同的索引时，不在这个问题的范围之内。但是，有一些方法可以使用额外的数据结构来处理这些问题。</p><h1 id="eac8" class="mk lw iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">多项选择</h1><p id="5b7f" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">以下哪一项是哈希表实现中冲突的解决方案？</p><ul class=""><li id="9968" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk nm lj lk ll bi translated">没有好的冲突解决方案，哈希函数必须是唯一的</li><li id="c149" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk nm lj lk ll bi translated">使用单独的链接，通常使用链表，其中数组的索引由一系列值组成</li><li id="f911" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk nm lj lk ll bi translated">使用trie存储每个索引的值</li><li id="e6de" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk nm lj lk ll bi translated">将该存储桶中的所有值连接成一个字符串</li></ul><p id="7643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解决方案:</strong>使用单独的链接，通常使用一个链表，其中数组的索引由一串值组成</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="07e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们有了自己的构建模块，所以让我们继续实现<code class="fe kl km kn ko b">set</code>方法。该方法将:</p><ol class=""><li id="ab81" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">乘<code class="fe kl km kn ko b">key</code>通过了</li><li id="6317" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">通过哈希函数运行它，然后</li><li id="cb0c" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">将我们的<code class="fe kl km kn ko b">storage</code>中的值设置为特定的指数</li></ol><p id="8a58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意我们存储它的方式:在<code class="fe kl km kn ko b">this._storage</code> ( <code class="fe kl km kn ko b">this._storage[idx]</code>)中的每个索引本身就是一个数组，从而初步解决了冲突问题。</p><pre class="ks kt ku kv gt lr ko ls lt aw lu bi"><span id="b24e" class="lv lw iq ko b gy lx ly l lz ma">set(key, val) {<br/>  let idx = this.hashStr(key);<br/><br/>  if (!this._storage[idx]) {<br/>    this._storage[idx] = [];<br/>  }<br/><br/>  this._storage[idx].push([key, val]);<br/>}</span></pre><p id="6076" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">set</code>方法现在看起来很简单，对吗？</p><p id="489f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这与我们的<code class="fe kl km kn ko b">get</code>方法是同一个概念。我们在那里所做的也是通过<code class="fe kl km kn ko b">hashStr</code>方法运行传递的<code class="fe kl km kn ko b">key</code>，但是我们将转到结果索引并检索值，而不是设置。</p><pre class="ks kt ku kv gt lr ko ls lt aw lu bi"><span id="96c0" class="lv lw iq ko b gy lx ly l lz ma">  for (let keyVal of this._storage[idx]) {<br/>    if (keyVal[0] === key) {<br/>      return keyVal[1];<br/>    }<br/>  }</span></pre><p id="ad18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该注意的一个警告是，传递一个不存在的键(或者没有被<code class="fe kl km kn ko b">set</code>)是可能的，所以如果是这种情况，我们应该通过返回<code class="fe kl km kn ko b">undefined</code>来处理它。</p><pre class="ks kt ku kv gt lr ko ls lt aw lu bi"><span id="ca5a" class="lv lw iq ko b gy lx ly l lz ma">get(key) {<br/>  let idx = this.hashStr(key);<br/><br/>  if (!this._storage[idx]) {<br/>    return undefined;<br/>  }<br/><br/>  for (let keyVal of this._storage[idx]) {<br/>    if (keyVal[0] === key) {<br/>      return keyVal[1];<br/>    }<br/>  }<br/>}</span></pre><p id="553d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那应该差不多了！让我们试一试。</p><pre class="ks kt ku kv gt lr ko ls lt aw lu bi"><span id="fe95" class="lv lw iq ko b gy lx ly l lz ma">class Hashmap {<br/>  constructor() {<br/>    this._storage = [];<br/>  }<br/><br/>  hashStr(str) {<br/>    let finalHash = 0;<br/>    for (let i = 0; i &lt; str.length; i++) {<br/>      const charCode = str.charCodeAt(i);<br/>      finalHash += charCode;<br/>    }<br/>    return finalHash;<br/>  }<br/><br/>  set(key, val) {<br/>    let idx = this.hashStr(key);<br/><br/>    if (!this._storage[idx]) {<br/>      this._storage[idx] = [];<br/>    }<br/><br/>    this._storage[idx].push([key, val]);<br/>  }<br/><br/>  get(key) {<br/>    let idx = this.hashStr(key);<br/><br/>    if (!this._storage[idx]) {<br/>      return undefined;<br/>    }<br/><br/>    for (let keyVal of this._storage[idx]) {<br/>      if (keyVal[0] === key) {<br/>        return keyVal[1];<br/>      }<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="a510" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kp">本课最初发表于</em><a class="ae kq" href="https://algodaily.com/challenges/implement-a-hash-map" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://algodaily.com</em></a><em class="kp">，我在那里开设了一门技术面试课程，并为雄心勃勃的开发人员撰写思考片段。</em></p></div></div>    
</body>
</html>