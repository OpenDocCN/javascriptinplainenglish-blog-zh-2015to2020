<html>
<head>
<title>Node.js Tips — Send Emails, Hashing, Promises, and Express Project Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示-发送电子邮件、哈希、承诺和快速项目结构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-send-emails-hashing-promises-and-express-project-structure-83697d78b1aa?source=collection_archive---------8-----------------------#2020-07-16">https://javascript.plainenglish.io/node-js-tips-send-emails-hashing-promises-and-express-project-structure-83697d78b1aa?source=collection_archive---------8-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/571d325c034e1010780d32a48f0d569b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I5g1kkszsiDIIDj5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@theeastlondonphotographer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ehimetalor Akhere Unuabona</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="84b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究编写节点应用程序时常见问题的一些解决方案。</p><h1 id="dcc8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步/等待隐式返回承诺</h1><p id="06e7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步函数隐式返回承诺。</p><p id="05d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f00" class="mn lc iq mj b gy mo mp l mq mr">const <!-- -->increment = <!-- -->async (num) =&gt; {<br/>  return num + 1;<br/>}</span></pre><p id="6227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，这返回了一个承诺<code class="fe ms mt mu mj b">num</code>增加1。</p><p id="5627" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以通过书写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8362" class="mn lc iq mj b gy mo mp l mq mr">increment(2)<br/>  .then(num =&gt; console.log(num))</span></pre><p id="5cf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们传入2来递增，那么回调中的<code class="fe ms mt mu mj b">num</code>应该是3。</p><h1 id="bc5a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取Node.js中字符串的SHA1哈希</h1><p id="6736" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe ms mt mu mj b">crypto</code>模块得到字符串的SHA1散列。</p><p id="cf64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5610" class="mn lc iq mj b gy mo mp l mq mr">const crypto = require('crypto');<br/>const sha = crypto.createHash('sha1');<br/>sha.update('foo');<br/>sha.digest('hex');</span></pre><p id="facc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用想要散列的文本来调用<code class="fe ms mt mu mj b">update</code>。</p><p id="1b06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并调用<code class="fe ms mt mu mj b">digest</code>返回散列的十六进制字符串。</p><p id="a463" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，由于SHA1不是很安全，我们应该改为创建SHA256哈希:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="64de" class="mn lc iq mj b gy mo mp l mq mr">const crypto = require('crypto');<br/>crypto.createHash('sha256').update('foo').digest('hex');</span></pre><p id="1019" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">'sha256'</code>调用<code class="fe ms mt mu mj b">createHash</code>来创建SHA256哈希。</p><p id="9875" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余的都一样。</p><h1 id="c739" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让Axios自动在其请求中发送Cookies</h1><p id="66fb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过<code class="fe ms mt mu mj b">withCredentials</code>选项让Axios在其请求中发送cookies。</p><p id="06a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3762" class="mn lc iq mj b gy mo mp l mq mr">axios.get('/api/url', { withCredentials: true });</span></pre><p id="3370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需将其设置为<code class="fe ms mt mu mj b">true</code>即可发送饼干。</p><h1 id="bc88" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带有Gmail的节点邮件程序</h1><p id="8191" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用带有Gmail SMTP服务器的Nodemailer发送电子邮件。</p><p id="7f2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1ec6" class="mn lc iq mj b gy mo mp l mq mr">const nodemailer = require('nodemailer');<br/>const smtpTransport = require('nodemailer-smtp-transport');</span><span id="2587" class="mn lc iq mj b gy mv mp l mq mr">const transporter = nodemailer.createTransport(smtpTransport({<br/>  service: 'gmail',<br/>  host: 'smtp.gmail.com',<br/>  auth: {<br/>    user: 'email@gmail.com',<br/>    pass: 'password'<br/>  }<br/>}));</span><span id="e224" class="mn lc iq mj b gy mv mp l mq mr">const mailOptions = {<br/>  from: 'email@gmail.com',<br/>  to: 'friend@example.com',<br/>  subject: 'Hello Email',<br/>  text: 'hello friend'<br/>};</span><span id="44b2" class="mn lc iq mj b gy mv mp l mq mr">transporter.sendMail(mailOptions, (error, info) =&gt; {<br/>  if (error) {<br/>    console.log(error);<br/>  } <br/>  else {<br/>    console.log(info.response);<br/>  }<br/>});</span></pre><p id="7b6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为<code class="fe ms mt mu mj b">createTransport</code>方法来创建一个<code class="fe ms mt mu mj b">transporter</code>对象让我们发送电子邮件。</p><p id="e873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们输入SMTP服务器地址，将<code class="fe ms mt mu mj b">server</code>设置为<code class="fe ms mt mu mj b">'gmail'</code>，并输入我们Gmail帐户的用户名和地址。</p><p id="51b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过设置发件人和收件人电子邮件、主题和内容<code class="fe ms mt mu mj b">text</code>来设置邮件选项。</p><p id="0ae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们用<code class="fe ms mt mu mj b">mailOptions</code>在<code class="fe ms mt mu mj b">transporter</code>上调用<code class="fe ms mt mu mj b">sendMail</code>发送电子邮件。</p><p id="8b4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调在完成后被调用。</p><p id="ab43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">error</code>有错误，<code class="fe ms mt mu mj b">info</code>有发送邮件的结果。</p><h1 id="d618" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用值交换密钥JSON</h1><p id="ad7c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用一个对象的值来交换密钥。</p><p id="46a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以使用<code class="fe ms mt mu mj b">Object.keys</code>和for-of循环。</p><p id="7fc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="48cb" class="mn lc iq mj b gy mo mp l mq mr">const result = {};<br/>for (const key of <!-- -->Object.keys(obj)<!-- -->){<br/>   result[<!-- -->obj<!-- -->[key]] = key;<br/>}</span></pre><p id="7249" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">Object.keys</code>得到键，然后把<code class="fe ms mt mu mj b">obj</code>的值作为<code class="fe ms mt mu mj b">result</code>的键，把<code class="fe ms mt mu mj b">key</code>作为它们的值。</p><h1 id="55c0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建一个快速应用程序</h1><p id="ff5e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要构建一个Express应用程序，我们可以将生产代码放在根级别的<code class="fe ms mt mu mj b">app</code>文件夹中。</p><p id="4689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在它里面，我们有控制器的<code class="fe ms mt mu mj b">controllers</code>文件夹。</p><p id="979f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">models</code>文件夹里可以有模特。</p><p id="75d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">views</code> foder有观点。</p><p id="e588" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">test</code>文件夹就在根目录下，有测试。</p><p id="a2b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在里面，我们有<code class="fe ms mt mu mj b">models</code>和<code class="fe ms mt mu mj b">views</code>文件夹，用于每种代码的测试。</p><h1 id="9dac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带有require的Node.js ES6类</h1><p id="95d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过导出来导出我们想要的类到<code class="fe ms mt mu mj b">require</code>:</p><p id="5ef7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">animal.js</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="82ae" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  //...<br/>}<br/>module.exports = Animal;</span></pre><p id="0aec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><p id="adf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">app.js</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="650d" class="mn lc iq mj b gy mo mp l mq mr">const Animal = require('./Animal');<br/>const animal = new Anima();</span></pre><p id="86f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要<code class="fe ms mt mu mj b">animal</code>模块并使用该类。</p><h1 id="6f45" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在承诺链中之前或之后放置catch</h1><p id="3457" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个承诺链，那么我们可以将<code class="fe ms mt mu mj b">catch</code>方法放在任何我们想要捕捉被拒绝的承诺的地方。</p><p id="2049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们把它们放得更早，那么如果在它之后出现的承诺被拒绝，那么这个错误就不会被<code class="fe ms mt mu mj b">catch</code>发现。</p><p id="9801" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们把<code class="fe ms mt mu mj b">catch</code>放在前面，那么后面的承诺可以继续，直到后面来的承诺之一被拒绝。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2e1f1ab2232570d6522e213a5d19c23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7rCPcuFD3BSAsdeD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@marianamontesdeoca?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mariana Montes de Oca</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ab33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="847b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将<code class="fe ms mt mu mj b">catch</code>方法放在任何我们想要的地方，但是它们可能会根据位置捕获不同的错误。</p><p id="6f1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Axios可以使用<code class="fe ms mt mu mj b">withCredentials</code>选项发送cookies。</p><p id="7478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过获取键和值并交换它们来交换对象的键和值。</p><p id="9c16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Nodemailer可以用来发送电子邮件。</p><h2 id="dcc5" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="814e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>