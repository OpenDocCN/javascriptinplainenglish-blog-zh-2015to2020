# JavaScript 中的 Var，Let，Const 有什么区别？

> 原文：<https://javascript.plainenglish.io/whats-different-between-var-let-and-const-in-javascript-e0514d185ff6?source=collection_archive---------9----------------------->

![](img/866d3ad804e07979fea8a6f8249af100.png)

在不久前，JavaScript 中只有一种定义变量的方法，那就是使用`var`。然而，随着 ES6 的引入，增加了两种额外的方式，`let`和`const`。等等…为什么我们需要三种不同的方法来做同样的事情？有没有一个应该用在另一个之上的例子？这些就是我在这篇文章中要回答的一些问题。但是首先，我们需要讨论一个叫做**范围**的概念。

# 函数作用域与块作用域

JavaScript 有两个不同的范围。第一个是*功能范围*，有时也称为全局范围，第二个是*块范围*。让我们看几个例子来更好地理解函数作用域和块作用域之间的区别。

## **功能范围**

在上面的例子中，`foo`的值在函数的第 4 行被返回，但是当我们试图在第 7 行的函数之外访问`foo`时抛出一个错误。这是因为使用`var`定义的变量是 ***函数作用域的*** 。它们只能在定义它们的函数中被访问。那么块范围呢？

## **块范围**

让我们使用`let`和`const`再添加几个变量，以及一个`if`语句到我们之前的函数中，看看这些变量的范围有什么不同。

正如您在第 7–9 行中看到的，在`if`语句中的所有`console.log()`语句都返回预期的变量值。然而，在检查第 12–14 行时，我们开始看到一些不同之处。在第 12 行，控制台中显示了`foo`的值，但是第 13 和 14 行返回了`bar`和`baz`的 ReferenceError。这是因为`let`和`const`是 ***块范围的*** ！

> JavaScript 将代码块定义为一组花括号`{}`之间的代码。

因为`let`和`const`是*块作用域的*，它们只能用定义它们的`if`语句的花括号来访问。由于`var`是*函数作用域的*，并且第 12 行仍然在第 1 行定义的`someFunction`的花括号内，并在第 15 行结束，我们可以访问第 12 行`if`块之外的`foo`的值。最后，由于第 17 行在`someFunction`之外，我们不能再访问第 17 行的`foo`。

这个例子概述了 ES6 引入的`let`和`const`与旧的`var`变量声明在范围上的不同。范围是这些声明之间最明显的区别，但是，它们中的每一个都有一些额外的细微差别。

# 定义变量

首先让我们看一下遗留的声明性的，`var`。

## 在 for 循环中使用 var

假设我们有以下 for 循环:

那么您认为这段代码会输出到控制台上吗？

说真的…在你继续滚动之前，先猜一下吧！

上述代码的输出是:

```
0
1
2
3
4
5 // wait...why is this here?!?
```

我们期望我们的代码输出数字 0–4，但是我们也从控制台日志的第 5 行得到数字 5。原因是我们使用`var`定义了变量`i`。因为`var`是*函数作用域的*，它仍然可以在我们的 for 循环之外访问。一旦`i`增加到 5，for 循环本身就退出。然而，`i`保留了值 5，这就是第 5 行返回的内容。

## 重新定义 var

最初使用`var`定义的变量可以在以后使用`var`重新定义。

# 让

`let`声明与`var`非常相似，在很多方面感觉像是`var`的 ES6 升级版，修补了一些奇怪的地方。让我们看看`let`在上面列出的两个例子中是如何工作的。

## 在 for 循环中使用`let`

让我们探索一下上面使用的 for 循环，但是使用`let`而不是`var`。

那么这次的产量是多少呢？

```
0
1
2
3
4
//ReferenceError: i is not defined
```

正如你所看到的，值 1–4 被输出到控制台，但是由于`let`是*块范围的*，所以`i`在 for 循环之外是不可访问的。因此，我们在第 5 行得到一个 ReferenceError，而不是将值 5 输出到控制台。在绝大多数情况下，我们真的不应该在声明了`i`的 for 循环之外访问它。使用`let`确保我们不能这样做。

## 重新定义`let`

类似于`var`，我们能够重新定义已经使用`let`声明的变量。尽管我们被允许使用的语法更加严格。

正如你所看到的，我们仍然能够重新定义`foo`，但是我们不得不在不使用`let`的情况下这样做。这使我们不必试图创建一个变量，而是意外地重新定义一个现有的变量。

# 常数

关键字`const`是单词*常量*的缩写。和`let`一样，`const`是*块范围的*。不像`let`和`var`可以不初始化就声明，`const`声明的时候必须初始化。这两者的主要区别在于，当使用`const`声明一个变量时，它不能被重新赋值。这是有意义的，因为目的是变量保持不变。这意味着在 for 循环中使用它是没有意义的，因为它不能递增。

正如我之前提到的，使用`const`定义的变量不能被重新分配，但是可以变异。考虑下面的例子。

如您所见，第 8 行将抛出一个错误，因为它试图重新分配常量变量`cars`。然而，通过将值“porsche”推到数组的末尾来改变`cars`的值是完全可以的。上述函数的输出是:

```
[ 'acura', 'audi', 'bmw', 'porsche' ]
```

此外，因为`const`是块范围的，函数在第 19 行返回一个 ReferenceError，因为`console.log(cars)`位于定义变量`cars`的`if`语句之外。

# 提升

本文的主题不是提升，所以关于什么是提升，我就不赘述了。可以说，在编译阶段，JavaScript 将变量和函数声明存储到内存中。打个比方，想象一下 JavaScript 在执行代码之前，将所有变量和函数声明移到它们作用域的顶部。这不是正在发生的事情，但这是一个好的思考提升的方式。回到本文的主题，`var`、`let`、`const`的吊装方式是有区别的。这里有一个简单的例子:

与`let`或`const`相比，`var`的吊装方式有一个非常重要的区别。不同之处在于初始化。当 var 被提升时，不管分配给它的值是多少，它都用值`undefined`初始化。相比之下，当`let`或`const`被提升时，它们根本没有被初始化。

# 概述

*   `var`是函数作用域，而`let`和`const`是块作用域。
*   `var`和`let`可以重新分配，而`const`不能。
*   当`var`被提升时，它被初始化为`undefined`的值。当`let`和`const`被吊起时，它们根本没有被初始化。
*   `var`和`let`无需初始化即可声明。但是，`const`必须在声明的时候初始化。

那么什么时候应该用哪个呢？通常最好避免使用 var，因为它通常表示在 ES6 发布之前编写的未受影响的遗留代码。`var`的功能范围也可能比`let`和`const`的块范围更难跟踪。`let`和`const`更严格的语法要求也鼓励更好的编码。

在大多数情况下，当创建一个变量时，你的默认值应该是`const`。如果您怀疑将来需要重新分配它(for 循环、switch 语句、算法交换等)。)使用`let`。

有问题吗？其他想法？欢迎在评论中提出来！我希望这能对你有所帮助。