<html>
<head>
<title>Creating the correct JS function for the job</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为工作创建正确的JS函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-the-correct-function-for-the-job-9e15069dcca3?source=collection_archive---------4-----------------------#2019-12-11">https://javascript.plainenglish.io/creating-the-correct-function-for-the-job-9e15069dcca3?source=collection_archive---------4-----------------------#2019-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/808faddb63993060a39ce3f41b27615e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sFyqJk_cRBv6npqt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Fewings</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="221a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">后退一步</h1><p id="cfdd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">编写函数是封装可重用逻辑的一种简单但非常强大的方法，它对于掌握编写真正漂亮的代码非常重要。</p><p id="6b51" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">用Javascript编写函数有很多种方式——我们应该将它们混合在一个代码库中还是坚持一种特定的风格？只有一种方法可以找到答案，那就是尝试所有的方法。</p><h1 id="4c1e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">函数声明</h1><p id="d6ed" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最直白的一种，但它有一个肮脏的小秘密。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5f90" class="mn ke iq mj b gy mo mp l mq mr">console.log(powerOfTwo(2)); // outputs 4</span><span id="3edc" class="mn ke iq mj b gy ms mp l mq mr">function powerOfTwo(num){<br/>    return num * num;<br/>}</span></pre><p id="a1c9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">它们和用<code class="fe mt mu mv mj b">var</code>声明的变量一样被提升，正因为如此，它们应该被避免。在声明之前使用它没有任何意义，只会降低可读性。棺材上还有最后一颗钉子:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e613" class="mn ke iq mj b gy mo mp l mq mr">console.log(powerOfTwo(2)); // outputs 8</span><span id="e73c" class="mn ke iq mj b gy ms mp l mq mr">function powerOfTwo(num){<br/>    return num* num;<br/>}</span><span id="e5ae" class="mn ke iq mj b gy ms mp l mq mr">function powerOfTwo(num){<br/>    return num * num * num;<br/>}</span></pre><p id="fa08" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们可以重新声明函数，这可以带来一些有趣的调试会话。</p><h1 id="940a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">函数表达式</h1><p id="7656" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">声明的表亲，没有提升和重新声明的行为。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a7c3" class="mn ke iq mj b gy mo mp l mq mr">console.log(powerOfTwo(2)); // ReferenceError</span><span id="af0c" class="mn ke iq mj b gy ms mp l mq mr">const powerOfTwo = function(num) {<br/>    return num * num;<br/>}</span></pre><p id="5def" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">虽然没有人阻止你改变变量指向的函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a2c9" class="mn ke iq mj b gy mo mp l mq mr">let myFunc = function(num) {<br/>    return num * num;<br/>}</span><span id="daef" class="mn ke iq mj b gy ms mp l mq mr">myFunc = function(num){<br/>    return -num<br/>}</span><span id="c2e2" class="mn ke iq mj b gy ms mp l mq mr">console.log(powerOfTwo(2)); // outputs -2</span></pre><p id="fc85" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">还有另一种风格的函数表达式——命名函数表达式，看起来非常相似，只是在关键字<code class="fe mt mu mv mj b">function</code>后增加了一个名称:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="edd4" class="mn ke iq mj b gy mo mp l mq mr">const powerOfTwo = function power(num){<br/>    // trademarked logic<br/>}</span><span id="a76f" class="mn ke iq mj b gy ms mp l mq mr">const powerOfThree = function(num){<br/>    // trademarked logic<br/>}</span><span id="52b9" class="mn ke iq mj b gy ms mp l mq mr">console.log(powerOfTwo.name);   // power<br/>console.log(powerOfThree.name); // powerOfThree</span></pre><p id="6983" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果函数需要引用自身，这些方法会很有用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dcb1" class="mn ke iq mj b gy mo mp l mq mr">setTimeout(function named(flag){<br/>    if(flag){<br/>        console.log("this is the end");<br/>    } else {<br/>        console.log("march on");<br/>        named(true);<br/>    }<br/>}, 0);</span></pre><p id="4c72" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">虽然我更喜欢创建一个单独的函数表达式，并将其传递给<code class="fe mt mu mv mj b">setTimeout</code>，因为我相信这样会使代码更清晰，并很好地分离声明和使用的关系。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3168" class="mn ke iq mj b gy mo mp l mq mr">const toTimeout = function (flag){<br/>    if(flag){<br/>        console.log("this is the end");<br/>    } else {<br/>        console.log("march on");<br/>        toTimeout(true);<br/>    }<br/>}</span><span id="7281" class="mn ke iq mj b gy ms mp l mq mr">setTimeout(toTimeout, 0);</span></pre><h1 id="6fb3" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">箭头函数表达式</h1><p id="21da" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">它们的外观和行为就像函数表达式，没有<code class="fe mt mu mv mj b">function</code>关键字，并且在参数括号后添加了一个“粗箭头”:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6d9d" class="mn ke iq mj b gy mo mp l mq mr">const powerOfTwo = (num) =&gt; {<br/>    return num * num<br/>}</span></pre><p id="9618" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们可以把它变成一行程序，单一乘法变成返回语句:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d63a" class="mn ke iq mj b gy mo mp l mq mr">const powerOfTwo = (num) =&gt; num * num;</span></pre><p id="d8be" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">当我们有一个参数时，我们甚至可以去掉括号，尽管多个参数确实需要它们。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="402c" class="mn ke iq mj b gy mo mp l mq mr">const powerOfTwo = nom =&gt; nom * nom;<br/>const sum = (x, y) =&gt; x + y;</span></pre><p id="0134" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果我们没有参数呢？这也是有办法的。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="67e3" class="mn ke iq mj b gy mo mp l mq mr">// preffered way<br/>const random = _ =&gt; 5;</span><span id="ad64" class="mn ke iq mj b gy ms mp l mq mr">// works, but is more noisy<br/>const rand = i_dont_mattress =&gt; Math.random();</span></pre><p id="1b55" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果你正在参与<a class="ae kc" href="https://en.wikipedia.org/wiki/Code_golf" rel="noopener ugc nofollow" target="_blank"> code-golf </a>，所有这些关于如何编写一个单箭头函数的选项都很棒，但是我相信如果每个函数看起来都稍有不同，会损害可读性。如果所有函数看起来都一样，那么快速解析代码会容易得多，一致性仍然是王道。当我编写箭头函数时，我总是使用“全脂”语法，因为它简洁且易于理解:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e5a8" class="mn ke iq mj b gy mo mp l mq mr">const myFunc = (myParam) =&gt; {<br/>    // truly magnificent code<br/>    return myParam;<br/>}</span></pre><p id="f013" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">虽然拥有简洁一致的语法很重要，但这还不够。</p><h1 id="6757" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">本质</h1><p id="ea84" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当在我们的函数中使用<code class="fe mt mu mv mj b">this</code>时，关键的区别就出现了。函数根据函数执行的位置从父对象获取它们的<code class="fe mt mu mv mj b">this</code>对象，而箭头函数获取词法父作用域。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3696" class="mn ke iq mj b gy mo mp l mq mr">function declaration() {<br/>    console.log(this);  // window object<br/>}</span><span id="f41e" class="mn ke iq mj b gy ms mp l mq mr">const named = function declaration() {<br/>    console.log(this);  // window object<br/>}</span><span id="e3e5" class="mn ke iq mj b gy ms mp l mq mr">const expression = function() {<br/>    console.log(this);  // window object<br/>}</span><span id="d4f7" class="mn ke iq mj b gy ms mp l mq mr">const arrow = () =&gt; {<br/>    console.log(this);          // window object<br/>}</span></pre><p id="5c8a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mw">注意:如果用NodeJS执行，对于箭头</em> <code class="fe mt mu mv mj b"><em class="mw">this</em></code> <em class="mw">将</em> <code class="fe mt mu mv mj b"><em class="mw">{}</em></code> <em class="mw">作为Node中的全局作用域是模块本身，而不是浏览器中的全局对象。</em></p><p id="94ca" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果函数嵌套在对象中会怎样？</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9b85" class="mn ke iq mj b gy mo mp l mq mr">const obj = {<br/>    a: arrow,<br/>    f: expression<br/>}</span><span id="6d1c" class="mn ke iq mj b gy ms mp l mq mr">obj.a(); // {} or window<br/>obj.f(); // { a: [Function: arrow], f: [Function: expression] }</span></pre><p id="1de0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">箭头表达式仍将有其父作用域，而函数表达式将有父对象，因为它是从父对象执行的。如果我们在一个类中使用这些函数呢？</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="24b6" class="mn ke iq mj b gy mo mp l mq mr">class A {<br/>    value = 5;<br/> <br/>    constructor() {<br/>        this.a = arrow;<br/>        this.f = expression;<br/>    }<br/>}</span><span id="f4e5" class="mn ke iq mj b gy ms mp l mq mr">const a = new A();<br/>a.a(); // {}<br/>a.f(); // A { value: 5, a: [Function: arrow], f: [Function: expression] }</span></pre><p id="4b93" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">箭头<code class="fe mt mu mv mj b">this</code>不会改变，而函数表达式<code class="fe mt mu mv mj b">this</code>会改变。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ecf7" class="mn ke iq mj b gy mo mp l mq mr">class B {<br/>    value = 5;<br/> <br/>    constructor() {<br/>        this.a = () =&gt; {<br/>            console.log(this);<br/>        };<br/>        this.f = function() {<br/>            console.log(this);<br/>        };<br/>    }<br/>}</span><span id="ef1b" class="mn ke iq mj b gy ms mp l mq mr">const b = new B();<br/>b.a(); B // { value: 5, a: [Function (anonymous)], f: [Function (anonymous)] }</span><span id="c0f2" class="mn ke iq mj b gy ms mp l mq mr">b.f(); B // { value: 5, a: [Function (anonymous)], f: [Function (anonymous)] }</span></pre><p id="c430" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mw">重要提示:你不能绑定箭头函数，因为它们没有自己的</em> <code class="fe mt mu mv mj b">this</code> <em class="mw">。</em></p><p id="5709" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">所以我们可以对方法使用函数或者箭头表达式？嗯，不:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a686" class="mn ke iq mj b gy mo mp l mq mr">class C {<br/>    declaration() {<br/>       console.log("declaration");<br/>    }<br/>    <br/>    expression = function() {<br/>       console.log("expression");<br/>    }</span><span id="8ddd" class="mn ke iq mj b gy ms mp l mq mr">arrow = () =&gt; {<br/>       console.log("arrow");<br/>    }<br/>}</span><span id="7a3b" class="mn ke iq mj b gy ms mp l mq mr">class CC extends C {<br/>    declaration() {<br/>      super.declaration();  // can call<br/>    }<br/> <br/>    expression = function() {<br/>        super.expression(); // can't call<br/>    }<br/> <br/>    arrow = () =&gt; {<br/>        super.arrow();      // can't call<br/>    }<br/>}</span><span id="d8a1" class="mn ke iq mj b gy ms mp l mq mr">const cc = new CC();<br/>cc.declaration();<br/>cc.expression();<br/>cc.arrow();</span></pre><p id="32e0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于类方法，最好的方法是使用函数声明，因为这样你就可以从父类中调用该方法，而其他所有方法都不会将函数添加到原型中。如果我们在构造函数上定义方法呢？</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4129" class="mn ke iq mj b gy mo mp l mq mr">class C { <br/>    constructor(){<br/>        this.expression = function() {<br/>            console.log("expression");<br/>        }<br/> <br/>        this.arrow = () =&gt; {<br/>            console.log("arrow");<br/>        }<br/>    } <br/>}</span></pre><p id="1d7c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">不能在那里使用声明，表达式也不能使用super来调用它们。</p><h1 id="068f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="f4f6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">根据不同的情况，每一种功能都有它自己的位置:</p><ul class=""><li id="41a6" class="mx my iq ld b le lz li ma lm mz lq na lu nb ly nc nd ne nf bi translated">函数声明——非常适合类方法，不如函数好</li><li id="5561" class="mx my iq ld b le ng li nh lm ni lq nj lu nk ly nc nd ne nf bi translated">函数表达式——作为文字对象的方法很好，但对于类方法就不那么好了</li><li id="58c9" class="mx my iq ld b le ng li nh lm ni lq nj lu nk ly nc nd ne nf bi translated">箭头函数——很好，当你需要在传递函数的时候有父作用域，但是不适合任何类型的方法</li></ul><p id="6a69" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">虽然您可以使用arrow函数作为对象方法，但是如果您不需要使用<code class="fe mt mu mv mj b">this</code>，或者冒着被错误地重新声明的风险对纯函数使用函数声明，要点是了解您的工具并为工作选择正确的工具，而不是将所有工具拼凑在一起，然后调试奇怪的错误。</p></div></div>    
</body>
</html>