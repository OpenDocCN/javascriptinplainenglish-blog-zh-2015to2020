<html>
<head>
<title>10 Javascript Interview Questions and Answers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个Javascript面试问答</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-javascript-interview-theoretical-questions-and-answers-9cb946ced642?source=collection_archive---------1-----------------------#2019-09-02">https://javascript.plainenglish.io/10-javascript-interview-theoretical-questions-and-answers-9cb946ced642?source=collection_archive---------1-----------------------#2019-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/bc552bbc4376785a628809b651a1cee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4FVQdrMGnt3YKwf5vgq_w.png"/></div></div></figure><div class=""/><p id="ce08" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据<strong class="jx iz"> Stack Overflow的年度</strong><a class="ae kt" href="https://insights.stackoverflow.com/survey/2019" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">2019</strong></a>开发者调查，几乎有<strong class="jx iz"> 90，000人参与</strong>，<strong class="jx iz"> Javascript </strong>是最受欢迎的网络编程语言。所以这意味着每个人都在寻找JavaScript开发者，对吗？找到一份工作会有多难？嗯，如果你在技术面试中表现不好，你的机会几乎为零！</p><p id="84b1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我将尝试展示我发现自己遇到的一些问题。这里有一些问题，我希望你会觉得有用，我不会深入解释这些话题。我希望您熟悉Javascript，以便从本文中获得最大收益…</p><h2 id="acd6" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题1——var，let，const关键字有什么区别？</h2><p id="a875" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">ES2015 (ES6)带来了许多闪亮的新功能，由于现在是2019年，我们几乎所有人都以这样或那样的方式熟悉这些关键词。但是他们到底是什么，为什么<code class="fe ls lt lu lv b">var</code>还不够简单，我们已经被介绍给<code class="fe ls lt lu lv b">let</code>和<code class="fe ls lt lu lv b">const</code></p><ol class=""><li id="6119" class="lw lx iy jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">当我们在代码中声明变量时，范围可能是一个很大的问题，尤其是当我们使用第三方库或者与其他开发人员合作时。<code class="fe ls lt lu lv b">var</code>声明是全局作用域或函数作用域，而<code class="fe ls lt lu lv b">let</code>和<code class="fe ls lt lu lv b">const</code>是块作用域。</li><li id="81f5" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">变量可以通过值来更新，并且可以在它们的作用域内重新声明；<code class="fe ls lt lu lv b">let</code>变量也可以通过值更新，但不能重新声明；<code class="fe ls lt lu lv b">const</code>变量既不能更新也不能重新声明。</li><li id="e89a" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">所有这三个关键字都被提升到它们作用域的顶部，但是当<code class="fe ls lt lu lv b">var</code>变量用<code class="fe ls lt lu lv b">undefined</code>初始化时，<code class="fe ls lt lu lv b">let</code>和<code class="fe ls lt lu lv b">const</code>变量没有被初始化。</li><li id="615b" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">虽然<code class="fe ls lt lu lv b">var</code>和<code class="fe ls lt lu lv b">let</code>可以不初始化就声明，但是<code class="fe ls lt lu lv b">const</code>在声明时必须初始化。</li></ol><h2 id="4b5e" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">问题JavaScript中的“严格”模式是什么，如何启用它？</strong></h2><p id="c03c" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">这里最重要的答案是,<code class="fe ls lt lu lv b">use strict</code>是一种在运行时自愿对JavaScript代码执行更严格的解析和错误处理的方法。本来会被忽略或者会无声地失败的代码错误现在会生成错误或引发异常。一般来说，这是一个很好的做法。</p><p id="7f00" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">严格模式的一些主要优点如下:</p><ul class=""><li id="2262" class="lw lx iy jx b jy jz kc kd kg ly kk lz ko ma ks mk mc md me bi translated"><strong class="jx iz">让调试更容易。</strong>潜在的代码错误原本会被忽略或失败，现在会生成错误或抛出异常，这将导致您更快地得到警告。</li><li id="d72c" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mk mc md me bi translated"><strong class="jx iz">防止意外全局变量。</strong>如果没有<strong class="jx iz"> <em class="ml">严格模式，</em> </strong>给未声明的变量赋值会自动创建一个同名的全局变量。在<strong class="jx iz"> <em class="ml">严格模式</em> </strong>下，尝试执行会抛出错误。</li><li id="4de5" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mk mc md me bi translated"><strong class="jx iz">消除了</strong> <code class="fe ls lt lu lv b"><strong class="jx iz">this</strong></code> <strong class="jx iz">的威压。</strong>如果没有<strong class="jx iz"> <em class="ml">严格模式，</em> </strong>对空或未定义的<code class="fe ls lt lu lv b">this</code>值的引用会自动强制到全局，这可能会产生令人讨厌的错误。在<strong class="jx iz"> <em class="ml">严格模式</em> </strong>中，引用一个为空或未定义的<code class="fe ls lt lu lv b">this</code>值会抛出错误。</li><li id="3d12" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mk mc md me bi translated"><strong class="jx iz">不允许重复的参数值。</strong>在<strong class="jx iz"> <em class="ml">严格模式</em> </strong>中，当检测到函数的重复命名参数时抛出错误(<code class="fe ls lt lu lv b">function foo(<strong class="jx iz">val1</strong>, val2, <strong class="jx iz">val1</strong>){}</code>)，这几乎可以捕捉到代码中的某个bug。</li><li id="5254" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mk mc md me bi translated"><strong class="jx iz">对</strong> <code class="fe ls lt lu lv b"><strong class="jx iz">delete</strong></code> <strong class="jx iz">的无效用法抛出错误。</strong><code class="fe ls lt lu lv b">delete</code>操作符不能用于对象的不可配置属性。如果没有<strong class="jx iz"> <em class="ml">严格模式，</em> </strong>代码将在试图删除不可配置的属性时无声地失败，但是在<strong class="jx iz"> <em class="ml">严格模式</em> </strong>中，代码将抛出错误。</li></ul><h2 id="46ce" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题3——= =和===运算符有什么区别？</h2><p id="5b74" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">因为JavaScript支持严格相等和类型转换相等，所以知道哪个操作符用于哪个操作很重要。简单来说<code class="fe ls lt lu lv b">===</code>考虑变量的类型，而<code class="fe ls lt lu lv b">==</code>根据变量的值进行类型修正。</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="ba62" class="ku kv iy lv b gy mu mv l mw mx"><strong class="lv iz">0</strong>==<strong class="lv iz">false</strong>   // true, because false is equivalent of 0<br/><strong class="lv iz">0</strong>===<strong class="lv iz">false</strong>  // false, because both operands are of different type<br/><strong class="lv iz">2</strong>=="2"     // true, auto type coercion, string converted into number<br/><strong class="lv iz">2</strong>==="2"    // false, since both operands are not of same type</span></pre><p id="7a04" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ml">*这里需要注意的是，右边的</em> <code class="fe ls lt lu lv b"><em class="ml">==</em></code> <em class="ml">运算符会被强制转换成左边的类型。</em></p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="93a0" class="ku kv iy lv b gy mu mv l mw mx">NaN === NaN // false<br/>NaN == NaN  // false</span></pre><p id="9955" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ml">*你要记住</em> <code class="fe ls lt lu lv b">NaN</code> <em class="ml">(不是数字)不等于任何东西，包括它本身，</em> <code class="fe ls lt lu lv b">NaN</code></p><p id="bf6c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总是使用严格的等式运算符。使用<code class="fe ls lt lu lv b">===</code>并避免使用<code class="fe ls lt lu lv b">==</code>操作符，即使你需要类型强制，而是自己转换类型以使其更具可读性。</p><h2 id="0943" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题4——<code class="fe ls lt lu lv b">null</code>和<code class="fe ls lt lu lv b">undefined</code>有什么区别？</h2><h2 id="3b88" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">未定义</strong></h2><p id="c4b7" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated"><code class="fe ls lt lu lv b">undefined</code>表示，变量的值没有定义。JavaScript有一个全局变量<code class="fe ls lt lu lv b">undefined</code>，它的值是“undefined”<code class="fe ls lt lu lv b">typeof undefined</code>也是“undefined”。请记住，undefined不是一个常量或关键字。<strong class="jx iz"> undefined是一个只有一个值的类型:undefined </strong>。</p><h2 id="2a61" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">空</h2><p id="3e05" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated"><code class="fe ls lt lu lv b">null</code>表示空值或不存在的值，程序员用来表示“无值”。null是一个原始值，您可以将null赋给任何变量。null不是一个对象，它是一个原始值。例如，您不能向其添加属性。有时人们会错误地认为它是一个对象，因为<strong class="jx iz"> typeof null返回的是“object”。</strong> <code class="fe ls lt lu lv b">null == undefined</code></p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="005f" class="ku kv iy lv b gy mu mv l mw mx">typeof undefined   // undefined<br/>typeof null        // object<br/><br/>null === undefined // false<br/>null == undefined  // true; </span><span id="b95e" class="ku kv iy lv b gy my mv l mw mx">/*<br/>The reason <strong class="lv iz"><em class="ml">null</em></strong><em class="ml"> is equal to </em><strong class="lv iz"><em class="ml">undefined</em></strong> is because of JavaScript's type system and equality checking. In JavaScript, both <strong class="lv iz">null</strong> and <strong class="lv iz">undefined</strong> have a <strong class="lv iz">falsy</strong> value so when you do an equality check with <strong class="lv iz">==</strong> they are considered the same. If you use a strict equality check with === they are considered different.<br/>*/</span></pre><h2 id="fb5a" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题5 -这到底是什么？</h2><p id="0a9d" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated"><code class="fe ls lt lu lv b">this</code>第一眼看上去，关键字可能是一个非常令人困惑的概念。在大多数语言中，<code class="fe ls lt lu lv b">this</code>是对由类实例化的当前对象的引用。在JavaScript中，<code class="fe ls lt lu lv b">this</code>通常指的是“拥有”该方法的对象，但更多的是取决于函数是如何被调用的。</p><p id="0435" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在执行每个函数时，JavaScript引擎为函数设置一个属性<code class="fe ls lt lu lv b">this</code>，该属性引用当前的执行上下文。<code class="fe ls lt lu lv b">this</code>总是引用一个对象，取决于函数如何被调用。<code class="fe ls lt lu lv b">this</code>的值变化有7种不同的情况。</p><ol class=""><li id="4456" class="lw lx iy jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">在全局上下文或函数内部，这指的是窗口对象。</li><li id="720e" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">在IIFE内部(直接调用函数)如果你使用“use strict ”,这个值是未定义的。要通过“使用严格”的生命之窗，你必须通过这个。</li><li id="e087" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">在对象的上下文中执行函数时，对象成为此的值。</li><li id="6beb" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">在setTimeout函数中，这个的值是window对象。</li><li id="16a0" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">如果您使用构造函数(通过使用new关键字)来创建一个对象，该值将引用新创建的对象。</li><li id="0bf3" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">通过将对象作为bind、call或apply的第一个参数进行传递，可以将此的值设置为任意对象。</li><li id="9e79" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">对于dom事件处理程序，这个值将是触发事件的元素。</li></ol><h2 id="a4ac" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题JavaScript中的闭包是什么？</h2><p id="8beb" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">最简单的答案是。闭包是一个<strong class="jx iz">内部</strong>函数，它可以访问<strong class="jx iz">外部</strong>函数的变量。</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="09b0" class="ku kv iy lv b gy mu mv l mw mx">var outerNum = 100</span><span id="e35b" class="ku kv iy lv b gy my mv l mw mx">function outerFn() {<br/>  var innerNum = 50</span><span id="70d1" class="ku kv iy lv b gy my mv l mw mx">    function innerFn() {<br/>      return outerNum + innerNum<br/>    }<br/>   return innerFn()<br/>}</span><span id="ee7e" class="ku kv iy lv b gy my mv l mw mx">outerFn() //prints 150</span></pre><p id="501a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">如上例所述，一个</strong> <code class="fe ls lt lu lv b"><strong class="jx iz">closure</strong></code> <strong class="jx iz">基本上是另一个函数内部的一个函数。</strong></p><p id="47fc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">独特之处在于内部函数<code class="fe ls lt lu lv b"><strong class="jx iz">innerFn</strong></code>可以访问外部函数<code class="fe ls lt lu lv b"><strong class="jx iz">outerFn</strong></code>范围内的变量，在我们的例子中是变量<code class="fe ls lt lu lv b"><strong class="jx iz">outerNum</strong></code></p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="9518" class="ku kv iy lv b gy mu mv l mw mx">function fullName(firstName) {<br/>  const greeting = 'Hello'<br/>  <br/>  function mergeNames(lastName) {<br/>    return `${greeting} ${firstName} ${lastName}!`<br/>  }<br/>  return mergeNames<br/>}<br/>const getFullName = fullName('Agent')<br/>getFullName(); //prints "Hello Agent undefined!"<br/>getFullName('Smith'); //prints "Hello Agent Smith!"</span></pre><p id="e0ee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ls lt lu lv b">const getFullName = fullName('Agent')</code>表示外部函数<code class="fe ls lt lu lv b">fullName</code>将被调用并返回。</p><blockquote class="mz na nb"><p id="50db" class="jv jw ml jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx iz"><em class="iy">*即使函数已经返回，内部函数仍然可以访问外部函数变量。</em> </strong></p></blockquote><p id="3374" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，内部函数是<code class="fe ls lt lu lv b">mergeNames</code>。它仍然可以访问外部函数变量<code class="fe ls lt lu lv b">firstName === 'Agent’</code>，尽管外部函数<code class="fe ls lt lu lv b">fullName</code>已经被调用并返回。</p><p id="44f0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当我在控制台<code class="fe ls lt lu lv b">const getFullName = fullName('Agent')</code>中编写时，<code class="fe ls lt lu lv b">getFullName</code>变量现在包含了内部函数<code class="fe ls lt lu lv b">mergeNames</code>，以及对外部函数<code class="fe ls lt lu lv b">firstName</code>变量的引用。</p><p id="447c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当我调用<code class="fe ls lt lu lv b">getFullName()</code>时，我会看到下面的文本:“你好，代理未定义！”</p><p id="ad02" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是当我打电话给<code class="fe ls lt lu lv b">getFullName("Smith")</code>时，我看到了下面的短信:“你好，特工史密斯！”</p><h2 id="7326" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">闭包可以访问三个范围内的变量:</strong></h2><ul class=""><li id="beab" class="lw lx iy jx b jy ln kc lo kg nf kk ng ko nh ks mk mc md me bi translated">变量在<em class="ml">中声明自己的作用域</em></li><li id="4c1e" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mk mc md me bi translated">在<em class="ml">父函数作用域</em>中声明的变量</li><li id="70eb" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mk mc md me bi translated">在<em class="ml">全局命名空间</em>中声明的变量</li></ul><h2 id="c86b" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题JavaScript中的提升是什么？</h2><p id="cf93" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">最简单的回答是，<strong class="jx iz">提升</strong>是一种JavaScript机制，在代码执行之前，变量和函数声明被移动到它们作用域的顶部。</p><p id="abc7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这确实是看起来正在发生的事情，但重要的是从根本上理解真正正在发生的事情。如您所见，您的代码没有移动(令人惊讶！)它不会被神奇地移动到文件的顶部。真正发生的是<strong class="jx iz">你的函数和变量声明在编译阶段被添加到“内存”中。</strong></p><blockquote class="mz na nb"><p id="24da" class="jv jw ml jx b jy jz ka kb kc kd ke kf nc kh ki kj nd kl km kn ne kp kq kr ks ig bi translated"><strong class="jx iz">重要的是要知道:<em class="iy"> JavaScript只提升声明，初始化不会被提升。</em> </strong></p></blockquote><p id="4758" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们举一个简单的例子，</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="a3ba" class="ku kv iy lv b gy mu mv l mw mx">console.log(message); //output : undefined<br/>var message = ’The variable Has been hoisted’;</span></pre><p id="4dbd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于解释器来说，上面的代码如下所示，</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="f5c3" class="ku kv iy lv b gy mu mv l mw mx">var message;<br/>console.log(message);<br/>message = ’The variable Has been hoisted’;</span></pre><p id="ae8b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">最佳实践:</em> </strong>由于提升的原因，总是在各自作用域的顶部声明变量被认为是最佳实践。在声明时尝试初始化变量总是好的。这将提供更清晰的代码，并有助于避免<code class="fe ls lt lu lv b">undefined</code>变量。</p><h2 id="7d1c" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题JavaScript中的异步编程是什么？</h2><p id="2ef9" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">JavaScript以非阻塞的方式运行代码，默认情况下它是同步的和单线程的。这意味着代码不能创建新线程并并行运行。需要一些时间来完成的代码(从本地文件系统读取数据或访问Web API等。)正在后台执行，并且并行地继续代码执行。这种编程行为被称为异步编程。</p><p id="50aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为JavaScript是以非阻塞的方式执行的，所以如果需要在执行更多代码之前得到结果，就必须采取进一步的措施来处理代码。</p><p id="8e2b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript通过<strong class="jx iz">回调</strong>(es 2015之前的次数)、p <strong class="jx iz">承诺</strong> (ES2015)和<strong class="jx iz">异步/等待</strong> (ES2017)提供了处理异步编程的各种可能性。</p><h2 id="ea04" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题9 -什么是JavaScript事件委托、传播、冒泡和捕获？</h2><p id="ea3c" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">事件委托</em> </strong>是一种监听事件的技术，其中你<em class="ml">委托</em>一个父元素作为其内部发生的所有事件的监听器。</p><p id="bd90" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果您想检测特定表单(例如，带有class="job-application "的表单)中任何字段值的任何时间变化，您可以这样做:</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="88ef" class="ku kv iy lv b gy mu mv l mw mx">var form = document.querySelector('.job-application');</span><span id="3da0" class="ku kv iy lv b gy my mv l mw mx">// event listener for changes inside the form<br/>form.addEventListener('input', function (event) {</span><span id="952a" class="ku kv iy lv b gy my mv l mw mx">	// Log the field that was changed<br/>	console.log(event.target);</span><span id="72f2" class="ku kv iy lv b gy my mv l mw mx">}, false); // false here indicates event bubbling, true event    capturing (I will explain about that soon)</span></pre></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="5673" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">事件传播</em> </strong>实际上是对事件冒泡和事件捕获的统称。我们可以认为这是一个双向链，从窗口到事件目标，然后再返回。</p><p id="d619" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">事件冒泡</em> </strong>和<strong class="jx iz"> <em class="ml">事件捕获</em> </strong>是HTML DOM API中 <strong class="jx iz"> <em class="ml">事件传播</em> </strong> <em class="ml">两种方式。在JavaScript中，事件传播(流)过程由三个概念完成:</em></p><ol class=""><li id="f5aa" class="lw lx iy jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">从窗口到事件目标父级:这是<em class="ml">捕获阶段</em></li><li id="99ee" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">事件目标本身:这是<em class="ml">目标阶段</em></li><li id="dc64" class="lw lx iy jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">从事件目标父项返回到窗口:气泡阶段<em class="ml"/></li></ol><p id="8b69" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ml">事件</em> <strong class="jx iz"> <em class="ml">冒泡</em> </strong> <em class="ml">和</em> <strong class="jx iz"> <em class="ml">捕捉</em> </strong> <em class="ml">是</em>当一个事件发生在另一个元素内的一个元素中，并且两个元素都注册了该事件的句柄时……*<strong class="jx iz"><em class="ml">通过冒泡</em> </strong>时，该事件是<em class="ml">首先被最里面的元素捕捉和处理，然后传播到最外面的元素。<br/> </em> <strong class="jx iz"> <em class="ml"> *通过捕捉</em> </strong>、<em class="ml">事件首先被最外层元素捕捉并传播到内层元素。</em></p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="2dc4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">冒泡</em> </strong>是事件本身所做的。事件冒泡是指事件从最深的元素或目标元素开始到它的父元素，然后是所有从下到上的祖先元素。目前，所有的现代浏览器都将事件冒泡作为事件流的默认方式。</p><p id="23e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">事件开始是触发它的元素。然后，它<em class="ml">冒泡</em>到它的每个父元素，直到它到达<code class="fe ls lt lu lv b">html</code>元素。</p><p id="b998" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以表单域为例，事件会冒泡到父表单，然后是表单所在的任何容器或div，然后是<code class="fe ls lt lu lv b">body</code>，然后是<code class="fe ls lt lu lv b">html</code>元素，然后是<code class="fe ls lt lu lv b">document</code>，然后是<code class="fe ls lt lu lv b">window</code>。</p><p id="53e7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些父元素上的任何侦听器都会在它冒泡时被触发。</p><p id="d56b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">捕捉</strong>在事件的流向和相关回调方面基本上是相反的！</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4da2cf091ef547a322c44333def66347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-4f5kX2aF1_EqB3zZ1KNBg.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk">This diagram should help grasping the concept better</figcaption></figure><p id="3f48" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">T63】TL； </strong> <em class="ml"> </em> <strong class="jx iz">事件<em class="ml">委托</em> </strong> <em class="ml">是手法，</em> <strong class="jx iz"> <em class="ml">繁殖</em> </strong> <em class="ml">是冒泡和捕捉的总称。</em> <strong class="jx iz"> <em class="ml">冒泡</em> </strong> <em class="ml">是事件本身所做的事情，而</em> <strong class="jx iz"> <em class="ml">捕捉</em> </strong> <em class="ml">是对不冒泡的事件使用事件委托的一种方式。</em></p><ul class=""><li id="951a" class="lw lx iy jx b jy jz kc kd kg ly kk lz ko ma ks mk mc md me bi translated"><strong class="jx iz">提示</strong>:默认情况下，javascript将事件传播设置为冒泡。如果我们想使用capture，我们必须将addEventListener函数中的第三个参数设置为true。</li></ul><h2 id="afbc" class="ku kv iy bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">问题10-JavaScript中的一级、一阶、高阶、一元Currying和纯函数是什么？</h2><p id="5e62" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">一级函数</em> </strong>是指当一个函数和其他变量一样对待时。例如，函数可以作为参数传递给其他函数，可以由另一个函数返回，也可以作为值赋给变量。例如，在下面的示例中，分配给侦听器的处理函数</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="984c" class="ku kv iy lv b gy mu mv l mw mx">const handler = () =&gt; console.log ('This is a click handler function');<br/>document.addEventListener ('click', handler);</span></pre><p id="cffd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">一阶函数</em> </strong>是不接受其他函数作为自变量，也不返回一个函数作为其返回值的函数。</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="f78f" class="ku kv iy lv b gy mu mv l mw mx">const firstOrder = () =&gt; console.log ('I am a first order function!');</span></pre><p id="2241" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">高阶函数</em> </strong>是接受其他函数作为自变量或者返回一个函数作为返回值的函数。</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="fb4b" class="ku kv iy lv b gy mu mv l mw mx">const firstOrderFunc = () =&gt; console.log ('Hello I am a First order function');<br/>const higherOrder = ReturnFirstOrderFunc =&gt; ReturnFirstOrderFunc();<br/>higherOrder(firstOrderFunc); // logs "Hello I am a First order function"</span></pre><p id="b60e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">一元函数</em> </strong>(即一元)是只接受一个参数的函数。让我们举一个一元函数的例子。它代表函数接受的单个参数。</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="336a" class="ku kv iy lv b gy mu mv l mw mx">const unaryFunction = a =&gt; console.log (a + 10); //Add 10 to the given argument and display the value</span></pre><p id="58ba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"><em class="ml"/></strong>curry是将一个有多个参数的函数转化为一系列只有一个参数的函数的过程。柯林是以数学家哈斯克尔·库里的名字命名的。通过应用currying，一元函数将其转换为一元函数。让我们举一个一元函数的例子，看看它是如何变成currying函数的</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="7c92" class="ku kv iy lv b gy mu mv l mw mx">const multiArgFunction = (a, b, c) =&gt; a + b + c;<br/>const curryUnaryFunction = a =&gt; b =&gt; c =&gt; a + b + c;<br/>curryUnaryFunction (1); // returns a function: b =&gt; c =&gt;  1 + b + c<br/>curryUnaryFunction (1) (2); // returns a function: c =&gt; 3 + c<br/>curryUnaryFunction (1) (2) (3); // returns the number 6</span></pre><p id="acd7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Curried函数对于提高代码的可重用性和功能组合非常有用。</p><p id="e7d2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="ml">纯函数</em> </strong>是返回值仅由其自变量决定而没有任何副作用的函数。也就是说，如果你用相同的参数调用一个函数n次，并且在应用程序中有n个位置，那么它将总是返回相同的值。让我们举个例子来看看纯函数和不纯函数的区别，</p><pre class="mm mn mo mp gt mq lv mr ms aw mt bi"><span id="b187" class="ku kv iy lv b gy mu mv l mw mx">//Impure<br/>let numberArray = [];<br/>const impureAddNumber = number =&gt; numberArray.push (number);<br/>//Pure<br/>const pureAddNumber = number =&gt; argNumberArray =&gt;<br/>  argNumberArray.concat ([number]);</span><span id="1a29" class="ku kv iy lv b gy my mv l mw mx">//Display the results<br/>console.log (impureAddNumber (6)); // returns 6<br/>console.log (numberArray); // returns [6]<br/>console.log (pureAddNumber (7) (numberArray)); // returns [6, 7]<br/>console.log (numberArray); // returns [6]</span></pre><h1 id="749b" class="nu kv iy bd kw nv nw nx kz ny nz oa lc ob oc od lf oe of og li oh oi oj ll ok bi translated">结论</h1><p id="def5" class="pw-post-body-paragraph jv jw iy jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">虽然一次编码面试可能包含不同的挑战；理论问题、作业、数据结构和算法等。掌握你面试的主要编程语言的基础是非常重要的。我试图涵盖其中的一些概念…</p><p id="0dac" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读，祝您面试顺利！</p></div></div>    
</body>
</html>