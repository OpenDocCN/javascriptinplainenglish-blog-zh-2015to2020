<html>
<head>
<title>JavaScript Best Practices — Async, Generators, Spaces, and Sorting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—异步、生成器、空格和排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-async-generators-spaces-and-sorting-9473fd792425?source=collection_archive---------11-----------------------#2020-07-23">https://javascript.plainenglish.io/javascript-best-practices-async-generators-spaces-and-sorting-9473fd792425?source=collection_archive---------11-----------------------#2020-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/71267e22063e61c220bf97d61a97fe36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PaEINQXXXyK-DzaF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@vincentvanzalinge?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vincent van Zalinge</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d5d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="4bcd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有导致await或yield竞争条件的赋值</h1><p id="8994" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">await</code>总是异步的，而<code class="fe me mf mg mh b">yield</code>也可以是异步的，所以如果我们并行赋值，就会导致竞争条件。</p><p id="a445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0b6" class="mq lc iq mh b gy mr ms l mt mu">let length = 0;</span><span id="f696" class="mq lc iq mh b gy mv ms l mt mu">async function addLength(pageNum) {<br/>  length += await getPageLength(pageNum);<br/>}</span><span id="eaf5" class="mq lc iq mh b gy mv ms l mt mu">Promise.all([addLength(1), addLength(2)]).then(() =&gt; {<br/>  console.log(totalLength);<br/>});</span></pre><p id="42b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们不知道每个电话的<code class="fe me mf mg mh b">addLength</code>什么时候结束。</p><p id="a8f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该按如下顺序运行这些:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5319" class="mq lc iq mh b gy mr ms l mt mu">async function addLengths() {<br/>  const length1 = await addLength(1);<br/>  const length2 = await addLength(2);<br/>  return length1 + length2;<br/>}</span></pre><h1 id="da0f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有没有<code class="fe me mf mg mh b">await</code>表达式的异步函数</h1><p id="ccf4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有没有<code class="fe me mf mg mh b">await</code>表达式的<code class="fe me mf mg mh b">async</code>函数。</p><p id="4b7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有<code class="fe me mf mg mh b">await</code>，这意味着我们没有使用promises it，所以我们不需要<code class="fe me mf mg mh b">async</code>关键字。</p><p id="bf13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b094" class="mq lc iq mh b gy mr ms l mt mu">async function foo() {<br/>  doWork();<br/>}</span></pre><p id="7e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="39a9" class="mq lc iq mh b gy mr ms l mt mu">async function foo() {<br/>  await doWork();<br/>}</span></pre><h1 id="9f3e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSDoc注释</h1><p id="c7a5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用JSDoc注释来解释参数和描述函数的作用。</p><p id="74ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="776e" class="mq lc iq mh b gy mr ms l mt mu">/**<br/> * Multiplies two numbers together.<br/> * @param {int} num1 The first number.<br/> * @param {int} num2 The second number.<br/> * @returns {int} The product of the two numbers.<br/> */<br/>function multiply(num1, num2) {<br/>  return num1 * num2;<br/>}</span></pre><p id="901e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">param</code>解释参数，<code class="fe me mf mg mh b">returns</code>解释返回的结果。</p><p id="94d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顶部有功能描述。</p><h1 id="36b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在正则表达式上使用<code class="fe me mf mg mh b">u</code>标志</h1><p id="6e55" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在正则表达式中使用<code class="fe me mf mg mh b">u</code>标志，以便正确处理UTF-16字符对。</p><p id="0855" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b540" class="mq lc iq mh b gy mr ms l mt mu">/^[👍]$/.test("👍")</span></pre><p id="f0f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac30" class="mq lc iq mh b gy mr ms l mt mu">/^[👍]$/u.test("👍")</span></pre><p id="48be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个返回<code class="fe me mf mg mh b">false</code>，是错的。</p><p id="7bf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是第二个返回<code class="fe me mf mg mh b">true</code>，是对的。这是因为我们添加了<code class="fe me mf mg mh b">u</code>标志。</p><h1 id="6d20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有没有Y的发生器函数<code class="fe me mf mg mh b">ield</code></h1><p id="7ade" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">没有<code class="fe me mf mg mh b">yield</code>的生成器函数不需要是生成器。</p><p id="85b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6ad7" class="mq lc iq mh b gy mr ms l mt mu">function* foo() {<br/>  return 10;<br/>}</span></pre><p id="73f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8ee5" class="mq lc iq mh b gy mr ms l mt mu">function* foo() {<br/>  yield 20;<br/>  return 10;<br/>}</span></pre><h1 id="18ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Rest算子和Spread算子之间的间距及其表达式</h1><p id="54f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在rest和spread操作以及它们的表达式之间不需要空格。</p><p id="ed74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="32cb" class="mq lc iq mh b gy mr ms l mt mu">let arr2 = [1, 2, 3];<br/>arr1.push(... arr2);</span></pre><p id="7103" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e647" class="mq lc iq mh b gy mr ms l mt mu">fn(... args)</span></pre><p id="173f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="67c9" class="mq lc iq mh b gy mr ms l mt mu">let arr2 = [1, 2, 3];<br/>arr1.push(...arr2);</span></pre><p id="7873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="29aa" class="mq lc iq mh b gy mr ms l mt mu">fn(...args)</span></pre><h1 id="d454" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">自动分号插入(ASI) </strong></h1><p id="2b32" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该自己加上分号，这样我们就知道每一行从哪里开始或结束。</p><p id="ce07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f0bb" class="mq lc iq mh b gy mr ms l mt mu">let n = 0<br/>const increment = () =&gt; {<br/>  return ++n<br/>}</span></pre><p id="0efc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="218d" class="mq lc iq mh b gy mr ms l mt mu">let n = 0;<br/>const increment = () =&gt; {<br/>  return ++n;<br/>}</span></pre><h1 id="c4a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分号前后的间距</h1><p id="28ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果分号后面有东西，我们应该在分号后面加一个空格</p><p id="44aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2539" class="mq lc iq mh b gy mr ms l mt mu">var c = "foo";var e = "bar";</span></pre><p id="22e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f865" class="mq lc iq mh b gy mr ms l mt mu">var c = "d"; var e = "f";</span></pre><h1 id="4a1c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分号的位置</h1><p id="5499" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该把分号放在有意义的地方。</p><p id="6672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6bbb" class="mq lc iq mh b gy mr ms l mt mu">foo()<br/>;[1, 2, 3].forEach(bar)</span></pre><p id="566b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d714" class="mq lc iq mh b gy mr ms l mt mu">foo();<br/>[1, 2, 3].forEach(bar);</span></pre><p id="f476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更常规，更清晰。</p><h1 id="5627" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">导入排序</h1><p id="394f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对进口商品进行分类，以便更容易跟踪。</p><p id="1552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d8cd" class="mq lc iq mh b gy mr ms l mt mu">import b from 'foo.js';<br/>import a from 'bar.js';</span></pre><p id="703c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3c90" class="mq lc iq mh b gy mr ms l mt mu">import a from 'bar.js';<br/>import b from 'foo.js';</span></pre><h1 id="61cd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">排序对象关键字</h1><p id="41be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以按字母顺序对对象键进行排序，以便更容易找到它们。</p><p id="462d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b8f8" class="mq lc iq mh b gy mr ms l mt mu">let obj = {<br/>  a: 1,<br/>  c: 3,<br/>  b: 2<br/>};</span></pre><p id="ff75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="064d" class="mq lc iq mh b gy mr ms l mt mu">let obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3,<br/>};</span></pre><h1 id="bb97" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">排序变量</h1><p id="5241" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对变量进行排序，使它们更容易找到，</p><p id="c0cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="56da" class="mq lc iq mh b gy mr ms l mt mu">var b, a;</span></pre><p id="0a56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4d86" class="mq lc iq mh b gy mr ms l mt mu">var a, b;</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/7f634865ad4cd36ee18c9a6cc3b84f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d3hWNVr5XSxE8CaC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@dariuscotoi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Darius Cotoi</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="bbd0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d104" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对对象属性、变量、导入等进行排序。让他们更容易被找到。</p><p id="6965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们把分号放在传统的地方，使他们更容易阅读。</p><p id="4ccc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">u</code>标志应该在正则表达式中，以使JavaScript正确搜索字符对。</p><p id="ca40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有<code class="fe me mf mg mh b">await</code>，那么我们就不需要<code class="fe me mf mg mh b">async</code>函数。</p><p id="8e2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有<code class="fe me mf mg mh b">yield</code>，那么我们就不需要一个生成器函数。</p><h1 id="b9b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="c4e5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>