<html>
<head>
<title>What’s new with TypeScript 4.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.0的新增功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-new-with-typescript-4-0-beta-a2e674846ef3?source=collection_archive---------1-----------------------#2020-07-07">https://javascript.plainenglish.io/whats-new-with-typescript-4-0-beta-a2e674846ef3?source=collection_archive---------1-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="27c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TypeScript 4.0有哪些新的亮点—语言特性</h2></div><p id="238f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们刚刚完成向TS 3.9的迁移，4.0版本已经在这里了！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/b110b79b2c5820c3801ed3d0f2cd6af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ts3lYA8TB3a6qWmDknphoQ.png"/></div></figure><p id="a143" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将回顾作为<a class="ae lj" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.0 </a>的一部分刚刚发布的所有内容。</p><p id="62a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将只讨论语言特性。我可能会写一些额外的帖子来介绍编辑器的生产力、性能和错误修复。</p><h1 id="7243" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">从构造函数推断类属性</h1><p id="7f7a" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">目前，当<code class="fe mh mi mj mk b">tsc</code>配置为<code class="fe mh mi mj mk b">noImplicitAny</code>模式时，以下TS代码不会编译:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="2192" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在<a class="ae lj" href="https://github.com/microsoft/TypeScript/pull/37920" rel="noopener ugc nofollow" target="_blank">这个PR </a>已经被合并，因此，从TS 4.0开始，<em class="mn">上面的代码将</em>编译，TypeScript将推断出<code class="fe mh mi mj mk b">x</code>的类型为<code class="fe mh mi mj mk b">string | boolean</code>。</p><p id="8a58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是TypeScript的类型推断将帮助我们的又一个例子！</p><h1 id="3d8f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">短路赋值运算符</h1><p id="101d" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">Daniel Rentz介绍的这个<a class="ae lj" href="https://github.com/microsoft/TypeScript/issues/37255" rel="noopener ugc nofollow" target="_blank">提案</a>对应的是一个<a class="ae lj" href="https://github.com/tc39/proposal-logical-assignment" rel="noopener ugc nofollow" target="_blank"> TC39提案，名为“提案-逻辑-分配”</a>，目前处于第3阶段(即<a class="ae lj" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">基本就绪</a>)！).</p><p id="924c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它旨在结合逻辑运算符和赋值表达式。结合从TS 3.7开始我们就有的<a class="ae lj" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing" rel="noopener ugc nofollow" target="_blank"> nullish合并</a>，我们将能够编写更精简的代码。</p><p id="e78d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是提案中给出的一个例子:</p><pre class="lc ld le lf gt mo mk mp mq aw mr bi"><span id="ed4c" class="ms ll iq mk b gy mt mu l mv mw">obj1.obj2.obj3.x ??= 42;</span></pre><p id="6496" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有这些新的短路操作符的相同代码:</p><pre class="lc ld le lf gt mo mk mp mq aw mr bi"><span id="2128" class="ms ll iq mk b gy mt mu l mv mw">obj1.obj2.obj3.x = obj1.obj2.obj3.x ?? 42;</span></pre><p id="e448" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，有了这种支持，我们将拥有一种更具表达力的语言，我们将能够结合检查和赋值，这将是非常棒的。</p><p id="8993" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如Daniel Rosenwasser所提到的，我们会为每个逻辑运算符设置一个这样的运算符，因此:</p><pre class="lc ld le lf gt mo mk mp mq aw mr bi"><span id="92c7" class="ms ll iq mk b gy mt mu l mv mw"><em class="mn">LeftHandSideExpression</em> <!-- -->&amp;&amp;=<!-- --> <em class="mn">AssignmentExpression</em></span><span id="b8d4" class="ms ll iq mk b gy mx mu l mv mw"><em class="mn">LeftHandSideExpression</em> <!-- -->||=<!-- --> <em class="mn">AssignmentExpression</em></span><span id="fefd" class="ms ll iq mk b gy mx mu l mv mw"><em class="mn">LeftHandSideExpression</em> <!-- -->??=<!-- --> <em class="mn">AssignmentExpression</em></span></pre><p id="6d70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对应于我们目前可以做的事情:</p><pre class="lc ld le lf gt mo mk mp mq aw mr bi"><span id="6c9a" class="ms ll iq mk b gy mt mu l mv mw"><em class="mn">LeftHandSideExpression</em> <!-- -->&amp;&amp;<!-- --> (<em class="mn">LeftHandSideExpression</em> <!-- -->=<!-- --> <em class="mn">AssignmentExpression</em>)</span><span id="bef4" class="ms ll iq mk b gy mx mu l mv mw"><em class="mn">LeftHandSideExpression</em> <!-- -->||<!-- --> (<em class="mn">LeftHandSideExpression</em> <!-- -->=<!-- --> <em class="mn">AssignmentExpression</em>)</span><span id="747e" class="ms ll iq mk b gy mx mu l mv mw"><em class="mn">LeftHandSideExpression</em> <!-- -->??<!-- --> (<em class="mn">LeftHandSideExpression</em> <!-- -->=<!-- --> <em class="mn">AssignmentExpression</em>)</span></pre><h1 id="2286" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">允许未知的catch子句绑定</h1><p id="57fa" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">目前，如果您尝试向catch子句添加类型注释，编译器会报错:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="39e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码无法编译，并引发以下错误:<code class="fe mh mi mj mk b">TS1196: Catch clause variable cannot have a type annotation</code></p><p id="823d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，我们根本不能向catch子句添加类型注释，从类型安全的角度来看，这是相当可悲的。问题是错误总是被认为是<code class="fe mh mi mj mk b">any</code>，这让我们可以对catch块中的对象做任何事情。</p><p id="d0b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种行为仅仅是因为，最初，<code class="fe mh mi mj mk b">unknown</code>关键字并不存在。但是现在，在这里使用它会更有意义。</p><p id="11cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如在<a class="ae lj" href="https://github.com/microsoft/TypeScript/issues/36775" rel="noopener ugc nofollow" target="_blank">这个提议</a>的注释中所指出的，我们可以得到一个新的严格标志，让我们在默认情况下强制这样做(也就是说，让所有的catch子句错误成为未知类型)。这将迫使我们在块中使用它之前正确地检查类型。</p><p id="dca5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我真正感兴趣的一项改进！</p><h1 id="9714" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">可变元组类型</h1><p id="19fe" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">一个可怕的新功能的野蛮的名字。如果你还不了解元组，<a class="ae lj" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">先去了解那些</a>。</p><p id="db06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不是元组的最大粉丝(我通常更喜欢对象/自定义类型)，但有时它们确实很有用，例如在编写测试时(或者像React :p这样奇怪的库的类型定义)。</p><p id="3bae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript 4.0改进了类型推断，现在允许正确地对处理元组的函数进行类型化。</p><p id="5cc2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，它现在在定义元组类型时支持泛型，允许它们对元组元素使用在函数上定义的泛型类型。正如发行说明所述，这意味着我们可以表示元组和数组上的高阶操作，即使我们不知道我们正在操作的实际类型。</p><p id="7f8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发行说明包括几个示例:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ff33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在上面看到的，<code class="fe mh mi mj mk b">tail</code>函数返回一个数组，或者类型为<code class="fe mh mi mj mk b">T</code>的元素。这段代码写起来/理解起来都很简单，这太棒了。多亏了这个新功能，您可以看到<code class="fe mh mi mj mk b">r1</code>和<code class="fe mh mi mj mk b">r2</code>被正确地输入了。</p><p id="5a06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个改进是扩展元素现在可以出现在元组中的任何位置；不仅仅是在结尾:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0e82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用TS 3.9.x及更早版本，无法编译。有了TS 4.0，我们将能够做到这一点，编译器将高兴地展平跨页，无论它们位于何处。</p><p id="3f30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如发行说明中所解释的，通过结合这两个特性，我们现在可以更好地键入类似于<code class="fe mh mi mj mk b">concat</code>函数的东西:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9cfa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">厉害！</p><p id="1810" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些新的类型推断改进将对我们的代码质量产生巨大影响，我迫不及待地想在生产中使用它们。</p><p id="f141" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多详情请查看<a class="ae lj" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-beta/" rel="noopener ugc nofollow" target="_blank">完整发行说明</a>。例如，它们还涵盖了这将如何改进像函数组合和部分参数应用这样的用例。</p><h1 id="98b8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">标记元组元素</h1><p id="c1c7" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">另一个由Brian Kim介绍的<a class="ae lj" href="https://github.com/Microsoft/TypeScript/issues/28259" rel="noopener ugc nofollow" target="_blank">提议</a>，旨在给我们定义元组元素标签的能力。</p><p id="f001" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，元组是这样声明的:</p><pre class="lc ld le lf gt mo mk mp mq aw mr bi"><span id="8129" class="ms ll iq mk b gy mt mu l mv mw">// length, count<br/>type Segment = [number, number];</span></pre><p id="26ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们不能给元组元素分配标签，最简单的(但非常丑陋的)解决方案是依靠注释来提醒我们每个元素对应的内容。</p><p id="8f34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个解决方案(更干净)是使用具有更有用名称的自定义类型。尽管如此，仍有改进的空间。</p><p id="d13c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些语言，例如<a class="ae lj" href="https://docs.microsoft.com/en-us/dotnet/csharp/tuples#named-and-unnamed-tuples" rel="noopener ugc nofollow" target="_blank"> C# </a>和Python支持这一点。</p><p id="484b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这被添加到语言中，那么我们将能够更简单地创建更有表现力的元组:</p><pre class="lc ld le lf gt mo mk mp mq aw mr bi"><span id="9146" class="ms ll iq mk b gy mt mu l mv mw">type Segment = [length: number, count: number];</span></pre><p id="f6ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，通过查看元组，我们直接知道每个数字对应的是什么。</p><p id="ad8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于清楚地理解元组是由什么组成非常有用。此外，如提案中所提到的，它还将增加操纵/返回元组的API的表达能力。</p><p id="3376" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如Daniel Rosenwasser所说，元组元素名称不会在类型系统中强制执行任何操作；它们的存在纯粹是为了传达意图。</p><h1 id="182a" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">调整类型脚本对反应的支持</h1><p id="c79c" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">就像打字稿一样，反应速度快得惊人。</p><p id="c481" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从我出版了关于打字脚本、反应、角度和Vue的书以来，事情一直在发展。我关于反应的章节仍然相关，但是反应. createElement API正在<a class="ae lj" href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md" rel="noopener ugc nofollow" target="_blank">改变</a>。</p><p id="c8a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于TypeScript支持JSX，它确实需要遵循这些发展。本期在<a class="ae lj" href="https://github.com/microsoft/TypeScript/issues/34547" rel="noopener ugc nofollow" target="_blank">中对此进行了跟踪，已经打开了</a><a class="ae lj" href="https://github.com/microsoft/TypeScript/pull/39199" rel="noopener ugc nofollow" target="_blank">PR</a>。该修改应包含在TS 4.0.1中。</p><p id="f6c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，对定制JSX工厂的支持将登陆TS 4.0，允许我们通过<code class="fe mh mi mj mk b">jsxFragmentFactory</code>选项定制片段工厂。查看发行说明和PR 之后的<a class="ae lj" href="https://github.com/microsoft/TypeScript/pull/38720" rel="noopener ugc nofollow" target="_blank">以了解详细信息。</a></p><h1 id="a545" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">重大变化</h1><p id="30b4" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">TS 4.0计划有一些突破性的变化:</p><ul class=""><li id="70ae" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated">lib.d.ts已经更改(DOM类型已经调整)，这意味着当升级到这个新版本时，我们可能会面临一些新的编译错误。首先，已经过时很久的属性<code class="fe mh mi mj mk b">document.origin</code>已经被删除了</li><li id="c34a" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">用属性覆盖访问器(反之亦然)现在在所有情况下都被认为是错误的。以前仅在使用<code class="fe mh mi mj mk b">useDefineForClassfields</code>时出现错误。因此，如果您的派生类覆盖了基类的getter/setter，那么TS 4.0就会出现编译错误。查看<a class="ae lj" href="https://github.com/microsoft/TypeScript/pull/37894" rel="noopener ugc nofollow" target="_blank">公关</a>了解详情</li><li id="988a" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">对于TS 4.0，当处于<code class="fe mh mi mj mk b">strictNullChecks</code>模式时(即始终，对吗？？！)，则<code class="fe mh mi mj mk b">delete</code>运算符的操作数必须是<code class="fe mh mi mj mk b">any</code>、<code class="fe mh mi mj mk b">unknown</code>、<code class="fe mh mi mj mk b">never</code>或者是可选的(即包含<code class="fe mh mi mj mk b">undefined</code>)；否则，代码不会编译。查看<a class="ae lj" href="https://github.com/microsoft/TypeScript/pull/37921" rel="noopener ugc nofollow" target="_blank">公关</a>了解详情</li></ul><h1 id="0217" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">贬值</h1><p id="6aec" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">由于TS 4.0引入了新的节点工厂API，用于生成TS AST节点的旧工厂函数<a class="ae lj" href="https://github.com/microsoft/TypeScript/pull/35282" rel="noopener ugc nofollow" target="_blank">已被弃用</a>。</p><p id="4aef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于绝大多数项目来说，这不应该是一个问题。</p><h1 id="cc1a" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">结论</h1><p id="4503" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在本文中，我分享了TypeScript 4.0的新功能和亮点。</p><p id="7536" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种令人惊叹的语言继续以闪电般的速度发展。</p><p id="7524" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迫不及待想把这个用在生产上！</p><h1 id="b800" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">喜欢这篇文章吗？点击下面“喜欢”按钮查看更多内容，并确保其他人也能看到！</h1><p id="b130" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">PS:如果你想了解大量关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的其他很酷的东西，那么不要犹豫，去<a class="ae lj" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae lj" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p><h2 id="7e3f" class="ms ll iq bd lm nm nn dn lq no np dp lu ko nq nr lw ks ns nt ly kw nu nv ma nw bi translated">简单英语的JavaScript</h2><p id="82a6" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae lj" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">订阅我们的YouTube频道</strong> </a> <strong class="kh ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>