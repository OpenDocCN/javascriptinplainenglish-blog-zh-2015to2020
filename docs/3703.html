<html>
<head>
<title>7 JavaScript Design Patterns Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的7个JavaScript设计模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-javascript-design-patterns-every-developer-should-know-df9c40e7debf?source=collection_archive---------4-----------------------#2020-10-19">https://javascript.plainenglish.io/7-javascript-design-patterns-every-developer-should-know-df9c40e7debf?source=collection_archive---------4-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2743" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果您可以像构建一个漂亮的模板一样构建您的源代码，并将其应用于所有同类项目，那会怎么样？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a9549e96e1234230dfa1a3500d1540f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S9_klVsS3AlqMvak"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@echaparro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Edgar Chaparro</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3378" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个项目一个模板？听起来很神奇，不是吗？</p><p id="5b6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也是我努力追求的编码水平。</p><p id="7810" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现它的方法之一是使用设计模式，这有助于编写结构良好、美观且有组织的代码。</p><p id="bfab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个故事中，我们将发现JavaScript中使用的一些常见设计模式。让我们开始吧。</p><h1 id="8dec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.构造器模式</h1><p id="ffd9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您熟悉构造函数，它是用特定的属性和方法初始化对象的函数。</p><p id="149d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构造器模式类似于这个定义。我们使用这种模式来创建同一个对象的多个实例。</p><p id="523e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中创建新对象有很多方法。看看下面的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5cac" class="mu lt iq mq b gy mv mw l mx my">// Using <strong class="mq ir">{}</strong> to create empty objects:<br/>let person = {};</span><span id="9048" class="mu lt iq mq b gy mz mw l mx my">// Using <strong class="mq ir">Object()</strong> to create empty objects:<br/>let person = new Object();</span><span id="cd94" class="mu lt iq mq b gy mz mw l mx my">// Using <strong class="mq ir">function constructor</strong>:<br/>function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>  this.showName = () =&gt; console.log(this.name);<br/>}</span><span id="0148" class="mu lt iq mq b gy mz mw l mx my">let person = new Person(‘Amy’, 28);<br/>person.showName();</span></pre><h1 id="7121" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.原型模式</h1><p id="354e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">原型模式是一种基于对象的创造性设计模式。它通过从原型克隆对象来创建对象的新实例。原型模式的主要焦点是创建一个对象，作为每个对象构造器的蓝图。</p><p id="970a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您发现直接构造一个新对象是复杂且低效的，那么原型模式就非常适合这种情况。</p><p id="f684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以用一种经典方式实现原型模式，如下所示:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="951c" class="mu lt iq mq b gy mv mw l mx my">function Book(title, price) {<br/>  this.title = title;<br/>  this.price = price;<br/>  this.printTitle = () =&gt; console.log(this.title);<br/>}</span><span id="d3dc" class="mu lt iq mq b gy mz mw l mx my">function BookPrototype(prototype) {<br/>  this.prototype = prototype;</span><span id="9570" class="mu lt iq mq b gy mz mw l mx my">  this.clone = () =&gt; {<br/>    let book = new Book();<br/>    book.title = prototype.title;<br/>    book.price = prototype.price;<br/>    <br/>    return book;<br/>  };<br/>}</span><span id="d1d6" class="mu lt iq mq b gy mz mw l mx my">let sampleBook = new Book(‘JavaScript’, 15);<br/>let prototype = new BookPrototype(sampleBook);<br/>let book = prototype.clone();<br/>book.printTitle();</span></pre><p id="c29f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于JavaScript有自己内置的原型工具，您可以更有效地使用it模式，如下所示:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="62f2" class="mu lt iq mq b gy mv mw l mx my">let book = {<br/>  title: ‘JavaScript’,<br/>  price: 15<br/>}</span><span id="fb44" class="mu lt iq mq b gy mz mw l mx my">let anotherBook = Object.assign({}, book);</span></pre><p id="3c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有第一本书作为原型。然后，我们使用这个原型创建一个新的book实例，这样新的book就有了用原型值初始化的所有属性值。</p><h1 id="ae91" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.命令模式</h1><p id="ef79" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这种模式的主要目的是将动作或操作封装成对象。</p><p id="ae2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您需要为一家电子商务商店构建一个支付系统。根据所选择的付款方式，您将需要处理特定的流程。</p><p id="c4b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3a33" class="mu lt iq mq b gy mv mw l mx my">if (selectedPayment == ‘creditcard’) {<br/>  // handle payment by creditcard<br/>}</span></pre><p id="1039" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些付款方式只有一个步骤，但其他方式可能不止一个步骤。通过使用上面的示例代码，您提供了一个实现，而不是一个接口，这会导致紧耦合。</p><p id="665e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">命令模式是提供松散耦合的一个很好的解决方案。系统不应该知道太多关于每个特定支付方法处理的信息。为了实现这一点，该模式将把请求操作的代码与执行实际实现的代码分开。</p><p id="ff71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c496" class="mu lt iq mq b gy mv mw l mx my">function Command(operation) {<br/>  this.operation = operation;<br/>}</span><span id="a832" class="mu lt iq mq b gy mz mw l mx my">Command.prototype.execute = function () {<br/>  this.operation.execute();<br/>}</span><span id="83b5" class="mu lt iq mq b gy mz mw l mx my">function ProcessCreditCardPayment() {<br/>  return {<br/>    execute: function() {<br/>      console.log(‘Credit Card’)<br/>    }<br/>  };<br/>}</span><span id="db6c" class="mu lt iq mq b gy mz mw l mx my">function ProcessPayPalPayment() {<br/>  return {<br/>    execute: function() {<br/>      console.log(‘PayPal’)<br/>    }<br/>  };<br/>}</span><span id="b463" class="mu lt iq mq b gy mz mw l mx my">function ProcessStripePayment() {<br/>  return {<br/>    execute: function() {<br/>      console.log(‘Stripe’)<br/>    }<br/>  };</span><span id="a14f" class="mu lt iq mq b gy mz mw l mx my">}</span><span id="fe3d" class="mu lt iq mq b gy mz mw l mx my">function CreditCardCommand() {<br/>  return new Command(new ProcessCreditCardPayment());<br/>}</span><span id="6da5" class="mu lt iq mq b gy mz mw l mx my">function PayPalCommand() {<br/>  return new Command(new ProcessPayPalPayment());<br/>}</span><span id="e4fd" class="mu lt iq mq b gy mz mw l mx my">function StripeCommand() {<br/>  return new Command(new ProcessStripePayment());<br/>}</span><span id="4c77" class="mu lt iq mq b gy mz mw l mx my">function PaymentSystem() {<br/>  let paymentCommand;<br/>    <br/>  return {<br/>    setPaymentCommand: function(command) {<br/>      paymentCommand = command;<br/>    },<br/>    executeCommand: function() {<br/>      paymentCommand.execute();<br/>    }<br/>  };<br/>}</span><span id="83cf" class="mu lt iq mq b gy mz mw l mx my">function run() {<br/>  let paymentSystem = new PaymentSystem();<br/>  paymentSystem.setPaymentCommand(new CreditCardCommand());<br/>  paymentSystem.executeCommand();<br/>  paymentSystem.setPaymentCommand(new PayPalCommand());<br/>  paymentSystem.executeCommand();<br/>  paymentSystem.setPaymentCommand(new StripeCommand());<br/>  paymentSystem.executeCommand();<br/>}</span><span id="9ae9" class="mu lt iq mq b gy mz mw l mx my">run();</span></pre><h1 id="95fd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.观察者模式</h1><p id="83c3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你订阅过时事通讯吗？</p><p id="fc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是这样的话，无论主人什么时候发邮件，你都会收到通知。</p><p id="275b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">观察者模式以同样的机制工作。它为您提供了一个订阅模型，您可以订阅一个事件，当该事件发生时，您会收到通知。</p><p id="4797" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a23e" class="mu lt iq mq b gy mv mw l mx my">function Newsletter() {<br/>  this.observers = [];<br/>}</span><span id="a4f7" class="mu lt iq mq b gy mz mw l mx my">Newsletter.prototype = {<br/>  subscribe: function (observer) {<br/>    this.observers.push(observer);<br/>  },<br/>  unsubscribe: function(observer) {<br/>    this.observers = this.observers.filter(ob =&gt; ob !== observer);<br/>  },</span><span id="f5b5" class="mu lt iq mq b gy mz mw l mx my">  notify: function() {<br/>    this.observers.forEach(observer =&gt; console.log(‘Hello ‘ + observer.toString()));<br/>  }<br/>}</span><span id="c3b2" class="mu lt iq mq b gy mz mw l mx my">let subscriber1 = ‘Subscriber 1’;<br/>let subscriber2 = ‘Subscriber 2’;<br/>let newsletter = new Newsletter();</span><span id="b585" class="mu lt iq mq b gy mz mw l mx my">newsletter.subscribe(subscriber1);</span><span id="b4ce" class="mu lt iq mq b gy mz mw l mx my">newsletter.subscribe(subscriber2);<br/>newsletter.notify(); // Hello Subscriber 1 Hello Subscriber 2</span><span id="3688" class="mu lt iq mq b gy mz mw l mx my">newsletter.unsubscribe(subscriber2);<br/>newsletter.notify(); // Hello Subscriber 1</span></pre><h1 id="758d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.单一模式</h1><p id="3182" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是最广为人知的模式。我们使用这种模式来限制一个类只有一个实例，并且它可以被全局访问。当你需要一些东西来处理整个应用程序中任何地方的特定任务时，这是非常有用的。</p><p id="dbed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="98ea" class="mu lt iq mq b gy mv mw l mx my">const utils = (function () {<br/>  let instance;<br/>  <br/>  function initialize() {<br/>    return {<br/>      sum: function (a, b) {<br/>        return a + b;<br/>      }<br/>    };<br/>  }</span><span id="bd85" class="mu lt iq mq b gy mz mw l mx my">  return {<br/>    getInstance: function () {<br/>      if (!instance) {<br/>        instance = initialize();<br/>      }</span><span id="4d92" class="mu lt iq mq b gy mz mw l mx my">      return instance;<br/>    }<br/>  };<br/>})();</span><span id="b421" class="mu lt iq mq b gy mz mw l mx my">let sum = utils.getInstance().sum(3, 5); // 8</span></pre><p id="f4db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这很方便，但您应该明智地使用这种模式，因为它有一个缺点，使您的代码难以测试。</p><h1 id="f457" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.模块模式</h1><p id="93a5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">该模式是用于实现软件模块概念的设计模式。模块模式是一种强大的模式，通常在JavaScript中使用。</p><p id="7bfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您查看JavaScript库时，您会看到这种模式通常被用作单例对象。它使您能够封装您的代码来编写最健壮的应用程序。</p><p id="3588" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将模块中的函数、变量和属性作为公共或私有成员。</p><p id="a616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a561" class="mu lt iq mq b gy mv mw l mx my">const bookModule = (function() {<br/>  // private<br/>  let title = ‘JavaScript’;<br/>  let price = 15;</span><span id="544e" class="mu lt iq mq b gy mz mw l mx my">  // public<br/>  return {<br/>    printTitle: function () {<br/>      console.log(title);<br/>    }<br/>  }<br/>})();</span><span id="81ea" class="mu lt iq mq b gy mz mw l mx my">bookModule.printTitle(); // JavaScript</span></pre><h1 id="7fc6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.工厂模式</h1><p id="7fb5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可能在不知不觉中使用了它的模式。工厂模式就像一个工厂。在JavaScript中，它将对象的创建与代码的其余部分分开。您包装创建代码，然后公开API来生成不同的对象。</p><p id="f6f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2d72" class="mu lt iq mq b gy mv mw l mx my">const Vehicle = function() {};</span><span id="b6ce" class="mu lt iq mq b gy mz mw l mx my">const Car = function() {<br/>  this.say = function() {<br/>    console.log(‘I am a car’);<br/>  }<br/>};</span><span id="d6da" class="mu lt iq mq b gy mz mw l mx my">const Truck = function() {<br/>  this.say = function() {<br/>    console.log(‘I am a truck’);<br/>  }<br/>};</span><span id="ad6f" class="mu lt iq mq b gy mz mw l mx my">const Bike = function() {<br/>  this.say = function() {<br/>    console.log(‘I am a bike’);<br/>  }<br/>};</span><span id="a212" class="mu lt iq mq b gy mz mw l mx my">const VehicleFactory = function() {<br/>  this.createVehicle = (vehicleType) =&gt; {<br/>    let vehicle;</span><span id="596e" class="mu lt iq mq b gy mz mw l mx my">    switch (vehicleType) {<br/>      case ‘car’:<br/>        vehicle = new Car();<br/>        break;<br/>      case ‘truck’:<br/>        vehicle = new Truck();<br/>        break;<br/>      case ‘bike’:<br/>        vehicle = new Bike();<br/>        break;<br/>      default:<br/>        vehicle = new Vehicle();<br/>    }<br/> <br/>    return vehicle;<br/>  }<br/>};</span><span id="34d5" class="mu lt iq mq b gy mz mw l mx my">const vehicleFactory = new VehicleFactory();</span><span id="41b9" class="mu lt iq mq b gy mz mw l mx my">let car = vehicleFactory.createVehicle(‘car’);<br/>let truck = vehicleFactory.createVehicle(‘truck’);<br/>let bike = vehicleFactory.createVehicle(‘bike’);</span><span id="22e9" class="mu lt iq mq b gy mz mw l mx my">car.say(); // I am a car<br/>truck.say(); // I am a truck<br/>bike.say(); // I am a bike</span></pre><h1 id="3371" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="0f71" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据我的经验，很难将设计模式应用到你的项目中。你必须多次尝试和失败，这样你才能掌握它。然而，努力是有回报的。一旦你完全理解了设计模式，并且知道什么时候应该实现什么模式，你就可以把你的代码提升到最健壮的水平。</p><p id="a5f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上只是一些设计模式的简单例子。如果你觉得这个话题有趣，你应该更深入地研究它。相信我，你永远不会后悔。</p><p id="add9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="e574" class="mu lt iq bd lu nh ni dn ly nj nk dp mc lf nl nm me lj nn no mg ln np nq mi nr bi translated">进一步阅读</h2><div class="ns nt gp gr nu nv"><a href="https://medium.com/javascript-in-plain-english/15-simple-coding-techniques-to-get-your-tasks-done-with-shorter-code-in-javascript-59d46801db0" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">15种简单的编码技术，用更短的JavaScript代码完成任务</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">不要浪费时间写长代码，而你可以把它写得更短，更清晰，更易读。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div></div></div>    
</body>
</html>