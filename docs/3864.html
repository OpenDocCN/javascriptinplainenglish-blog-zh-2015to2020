<html>
<head>
<title>A TypeScript Project Structure Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿项目结构指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-project-directory-structure-module-resolution-and-related-configuration-options-1d8b87ffec88?source=collection_archive---------0-----------------------#2020-10-30">https://javascript.plainenglish.io/typescript-project-directory-structure-module-resolution-and-related-configuration-options-1d8b87ffec88?source=collection_archive---------0-----------------------#2020-10-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="116d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">目录结构、模块解析和相关配置选项</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cf4f38107d885b2053d54873646c2e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIz4af_hq49uh-JdhKQ1Mg.jpeg"/></div></div></figure><p id="9aac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript项目的目录结构和模块解析并不复杂，直到您开始将事物组织成单独的单元，将它们放入不同的目录，并尝试这里讨论的一些配置选项。</p><p id="a372" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本文提供了对影响TypeScript项目目录结构和模块解析的机制和配置选项的总体理解，以及一些注意事项，希望能避免读者陷入某些陷阱。但是，它不是教程，没有给出详细的例子。要了解更多详细信息，您可以找到配置选项首次出现时TypeScript手册相关部分的链接，以及本文末尾演示这里讨论的特性和配置选项的测试项目。</p><p id="6479" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本文假设读者了解TypeScript和Node.js包以及模块解析的基础知识。除非另有说明，所有讨论的配置选项都是TypeScript选项，它们作为命令行选项传递给编译器，或者在“tsconfig.json”中设置。</p><p id="d1db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本文只讨论常见的用例。这里讨论的TypeScript项目输出。js文件放入一个目录(“outDir”)，而不是一个输出文件(“outFile”)，编译器使用“节点”模块解析策略。以便讨论不会因为不常见的用例以及仅为向后兼容而保留的选项而分散读者的注意力。</p><p id="5990" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本讨论中的“实现文件”是指TypeScript源文件(。ts，。tsx ),它将被编译器编译成。js文件。“项目根目录”是指“tsconfig.json”所在的目录。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="b9d4" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">通用tsconfig.json选项</strong></h1><p id="fd3c" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#extends" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mp">延伸</em></strong></a><strong class="kq io"/></p><p id="8122" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选项“extends”指定了另一个要继承的配置文件，这可能是您的配置的一个很好的起点。有些社区维护的基本配置针对特定的运行时环境进行了调整，您可以在项目中安装和继承这些配置。见项目<a class="ae mo" href="https://github.com/tsconfig/bases/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">@ ts config/bases</strong></a>。</p><p id="892c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong><a class="ae mo" href="https://www.typescriptlang.org/tsconfig#rootDir" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mp">rootDir</em></strong></a><strong class="kq io"/></p><p id="91f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“rootDir”指定预期包含所有实现文件的根。“rootDir”应该包含所有实现文件，即将要编译的源文件。</p><p id="9a4c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">默认情况下，“rootDir”被推断为“所有非声明输入文件中最长的公共路径”。这意味着如果你所有的输入源文件都在下面。/src，"，"/src”被推断为“rootDir”。如果你的源文件都在两者之下。”/src "和"。/test "，那么"。/”将是“rootDir”。</p><p id="8f63" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不要混淆“rootDir”和“rootDir”。他们是不同的。</p><h1 id="3a27" class="lr ls in bd lt lu mq lw lx ly mr ma mb jt ms ju md jw mt jx mf jz mu ka mh mi bi translated"><strong class="ak">输出选项</strong></h1><p id="c5f3" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">这些选项设置发出的JavaScript是什么样子的(以便它们与不同的运行时环境兼容)，生产什么其他产品，以及它们输出到哪里。</p><p id="d065" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#outDir" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">胜过</strong></a><strong class="kq io"/></p><p id="c2b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果指定，输出<code class="fe mv mw mx my b">.js</code>(以及<code class="fe mv mw mx my b">.d.ts</code>、<code class="fe mv mw mx my b">.js.map</code>等。)文件将被发送到此目录中。在大多数类型脚本项目中，应该设置“升级”。否则，除了源之外，还会发出输出，污染源文件夹。</p><p id="bb17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“rootDir”下的目录结构将保留在“outDir”中。这意味着从“rootDir/path a/path b/module EC . ts”编译的JavaScript将被发送到“outDir/path a/path b/module EC . js”。</p><p id="e397" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总之，规则是:“rootDir”包含所有要编译的实现文件(源文件)，而“outDir”是发出输出的地方。“rootDir”下的相同目录结构保留在“outDir”中。本文中讨论的一些选项允许源文件采用非常灵活的目录结构。然而，在任何情况下，这条规则都不会改变。</p><p id="cb97" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#target" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">目标</strong></a><strong class="kq io"/></p><p id="02c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">旨在根据发出的JS代码将在其中执行的运行时环境进行设置。此选项确定源代码中的哪些功能(如arrow function ()=&gt;{})在发出的JS中被降级，即在较新版本的Javascript语言中实现的哪些功能不应在输出Javascript文件中发出，而应使用较旧版本的语法和功能来实现，以便与较旧的运行时兼容。</p><p id="ef14" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选项“目标”更改选项“lib”、“module”的默认值，并通过选项“module”，选项“moduleResolution”。</p><p id="ea7a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#module" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">模块</strong></a><strong class="kq io"/></p><p id="3520" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此选项确定发出的JavaScript中的模块导入和导出代码(在运行时使用)，而不是编译时TypeScript的模块解析。默认值取决于选项“目标”。</p><p id="a83b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于该选项影响发出的Javascript，因此该值应该取决于发出的Javascript代码将被使用的运行时环境的模块系统。如今，最著名的模块系统是“CommonJS”和“ES模块”。</p><p id="f73e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您将发出的代码与Node一起使用，那么模块系统取决于您将发出的Javascript代码放入的包的类型。包的类型由package.json中的“类型”字段决定，如果最近的父package.json缺少“类型”字段或包含“类型”:“commonjs”，则使用CommonJS模块系统。如果包含“类型”:“模块”，则使用“ES模块”系统。关于如何设置该选项的更多信息，请点击阅读<a class="ae mo" rel="noopener ugc nofollow" target="_blank" href="/how-to-correctly-use-typescript-module-import-syntax-and-settings-in-various-circumstances-e98bfa87f70f">。</a></p><p id="6f6a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong><a class="ae mo" href="https://www.typescriptlang.org/tsconfig#declaration" rel="noopener ugc nofollow" target="_blank">T5】申报</a><strong class="kq io"/></p><p id="f755" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果此选项设置为“true”，编译器将生成类型声明“. d.ts”文件。如果其他代码要使用该项目，则应打开该选项。</p><p id="a2e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#declarationMap" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">声明映射</strong></a><strong class="kq io"/></p><p id="f5de" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果打开了“声明”，选项“declarationMap”会使编译器发出类型声明(. d.ts)的源映射，将定义映射回原始。ts”源文件。效果是当用户点击一个定义时，编辑器(比如VS代码)可以转到原来的。使用“转到定义”等功能时，ts文件。</p><h1 id="3280" class="lr ls in bd lt lu mq lw lx ly mr ma mb jt ms ju md jw mt jx mf jz mu ka mh mi bi translated"><strong class="ak">“package . JSON”选项</strong></h1><p id="f838" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">这些选项通过导出类型、函数、值、对象以及导入包时执行的入口点来定义包的公开接口。</p><p id="be05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#including-declarations-in-your-npm-package" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">【类型】</strong> </a></p><p id="26ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">指示包的类型—是CommonJS包还是es模块？缺少“类型”字段或“类型”字段的值为“commonjs”表示是CommonJS包。值“模块”表示es模块。</p><p id="913a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您使用Node.js运行代码，则该字段确定Node.js为您的代码提供什么模块。对于CommonJS，“require()”是提供的并且可用，ES模块“import”“export”语句则不是。对于ES模块，情况正好相反。</p><p id="9647" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#including-declarations-in-your-npm-package" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">【类型】【打字员】</strong> </a></p><p id="24f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">指示包的类型声明文件(. d.ts)。“打字员”与“类型”同义，两者都可以使用。如果“index.d.ts”位于包的根，则可以省略“types ”,尽管仍然建议这样做。</p><p id="ef7b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果包装将由外部代码使用，应注明“类型”。</p><p id="0d19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#main" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">主</strong></a><strong class="kq io"/></p><p id="3574" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是包的主要JavaScript入口点。</p><p id="6947" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通常，“types”指向声明文件，“main”指向。从“outDir”中的TypeScript入口点发出的js。</p><p id="8964" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://nodejs.org/api/packages.html#packages_exports" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">出口</strong></a><strong class="kq io"/></p><p id="e007" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为“主”选项的替代，该选项支持<a class="ae mo" href="https://nodejs.org/api/packages.html#packages_subpath_exports" rel="noopener ugc nofollow" target="_blank">子路径导出</a>和<a class="ae mo" href="https://nodejs.org/api/packages.html#packages_conditional_exports" rel="noopener ugc nofollow" target="_blank">条件导出</a>。到目前为止，在Node.js v15.0.1下，这两个特性仍然是实验性的，因此不再进一步讨论。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="a970" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">初始实施文件</strong></h1><p id="974e" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">实现文件是源文件()。ts。tsx)将由tsc编译，并且输出(。js)的实现文件被发射到“outDir”中。默认情况下，编译项目根目录下的所有源文件。</p><p id="af4b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">文件包含选项(“包含”、“排除”、“文件”)可以明确指定最初<strong class="kq io"><em class="mp"/></strong>包含在实现文件中的文件。然后，在编译期间，编译器可以通过模块解析(在“import”语句中)递归地包括由初始实现文件引用的进一步的实现文件。这将在讨论TypeScript模块解析之后进行讨论。</p><p id="2e49" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#include" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">包括</strong></a><strong class="kq io"/></p><p id="0343" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">指定相对于项目根目录的文件名或文件名模式列表。</p><p id="2f06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#exclude" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">排除</strong></a><strong class="kq io"/></p><p id="e01c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">指定在解析“include”时要跳过的文件名或文件名模式的列表。注意:“排除”仅在解析“包含”时起作用。即使某个文件是由“exclude”指定的，如果编译器解析了对它的模块引用，它仍然可以包含在实现文件中。</p><p id="c039" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#files" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">文件</strong></a><strong class="kq io"/></p><p id="7bec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">指定要作为实现文件包含的文件列表。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="aadd" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">模块参考基础知识</strong></h1><p id="e71b" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">模块引用是将“导入”语句中的路径解析为表示模块的文件。代表性文件可以是源文件(。ts，。tsx)或类型声明(. d.ts)。</p><p id="0212" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">通用选项</strong></p><p id="35a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#moduleResolution" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">模块解析</strong> </a> <strong class="kq io">(模块解析策略)</strong></p><p id="7049" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选项“moduleResolution”设置TypeScript编译器在编译时如何解析模块。不要与选项“模块”混淆，该选项设置输出的模块系统。js文件并影响发出的代码的运行时行为。</p><p id="3e20" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选项“moduleResolution”的值可以是“经典”或“节点”。“classic”只是为了向后兼容而保留的，不在本文中讨论。值“节点”是现代代码中使用的节点。这里所有的讨论都是基于“节点”的。</p><p id="ef5f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于选项“moduleResolution”的默认值会受到选项“target”或“module”的值的影响，因此最好将选项“moduleResolution”显式设置为“node”。</p><p id="36a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项“trace resolution”</strong></p><p id="4a6b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此选项使编译器能够输出模块解析的每一步以供诊断。</p><h1 id="a26a" class="lr ls in bd lt lu mq lw lx ly mr ma mb jt ms ju md jw mt jx mf jz mu ka mh mi bi translated"><strong class="ak">相对和非相对模块分辨率</strong></h1><p id="cf41" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">根据TypeScript源文件中“import”语句中的路径，模块引用是相对模块引用(以/、)开始。/或者../)和非相对(绝对)模块引用。</p><h1 id="c251" class="lr ls in bd lt lu mq lw lx ly mr ma mb jt ms ju md jw mt jx mf jz mu ka mh mi bi translated"><strong class="ak">相对模块分辨率和相关选项</strong></h1><p id="42b1" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">相对模块解析解析相对于导入文件的模块。它用于解析包中的内部模块。</p><p id="7336" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以下是影响TypeScript相对模块分辨率的选项:</p><p id="4c24" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong><a class="ae mo" href="https://www.typescriptlang.org/tsconfig#rootDirs" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">rootDirs</strong></a><strong class="kq io"/></p><p id="4401" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">配置了相对于项目根目录(tsconfig.json所在位置)的目录列表，当编译器解析相对模块引用时，编译器会将这些目录视为合并到一个根目录中。</p><p id="0e19" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">重要提示:</strong>阅读下面关于路径和目录结构不一致的“警告”。</p><h1 id="bd08" class="lr ls in bd lt lu mq lw lx ly mr ma mb jt ms ju md jw mt jx mf jz mu ka mh mi bi translated"><strong class="ak">非相关模块分辨率及相关选项</strong></h1><p id="b880" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">非相关模块被解析(1)相对于选项<strong class="kq io"> baseUrl </strong>并通过<strong class="kq io">路径映射</strong>，如果配置的话，(2)通过模仿Node.js模块解析机制，或(3)到<a class="ae mo" href="https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules" rel="noopener ugc nofollow" target="_blank">环境模块</a>声明。它通常用于导入外部依赖项。但是“baseUrl”也允许它用于导入内部模块。</p><p id="766b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤1:尝试解析相对于“</strong><a class="ae mo" href="https://www.typescriptlang.org/tsconfig#baseUrl" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">baseUrl</strong></a><strong class="kq io">”和“</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#paths" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">路径</strong></a><strong class="kq io">”</strong></p><p id="1dd8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此步骤仅在设置了选项“baseUrl”时有效。“baseUrl”(相对于项目根目录)指向一个基目录，编译器基于该目录尝试解析非相对模块引用。</p><p id="e217" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用“baseUrl ”,同一个包中的两个内部模块可以使用非相对模块引用来相互引用，而不是必须使用相对引用，相对引用有时非常麻烦，如“../../../../pathA/pathB/pathC "。</p><p id="1934" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选项“paths”在非相对模块解析中启用“baseUrl”上的路径映射。它将路径模式映射到相应的目录位置数组(一个模式映射到一个位置数组)。目录位置是相对于“baseUrl”指定的。</p><p id="8ff1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为一个模式在数组中提供多个目录位置允许“后退”映射，这意味着尝试依次在多个位置解析一个模块。</p><p id="0af8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">重要提示:</strong>阅读下面关于路径和目录结构不一致的“警告”。</p><p id="785b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">第二步:模仿Node.js模块解析机制</strong></p><p id="4f9c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设“/root/pathA/pathB/pathC/modulea . ts”包含语句“import {whatever} from 'moduleB '”，TypeScript编译器在模拟Node.js模块解析时，(1)在“/root/pathA/pathB/pathC”、“/root/pathA/pathB”、“/root”、“/root”和“/”下依次查找文件夹“node_modules”，一次向上前进一个目录，并且(2)如果找到文件夹“node_modules”，则依次查找文件如果步骤(2)在“node_modules”文件夹中失败，编译器返回到步骤(1)继续处理目录，直到“/”。</p><p id="d121" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">步骤3:解析为环境模块声明</strong></p><p id="df25" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">环境模块是类型声明(. d.ts)中模块的类型声明。详见打字手册中的<a class="ae mo" href="https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules" rel="noopener ugc nofollow" target="_blank">环境模块</a>。</p><h1 id="2fac" class="lr ls in bd lt lu mq lw lx ly mr ma mb jt ms ju md jw mt jx mf jz mu ka mh mi bi translated"><strong class="ak">使用“baseUrl”、“paths”和“rootDirs”的注意事项</strong></h1><p id="2e7c" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">当“baseUrl”、“paths”和“rootDirs”都没有使用时，源文件的目录结构以及发出的JavaScript的目录结构(回想一下,“rootDir”中的目录结构保留在“outdir”中)与Node.js模块解析机制一致。在相对模块引用的情况下，可以按照导入语句中的路径在目录结构中解析模块。在非相对模块引用的情况下，该模块应该是外部模块，由诸如npm之类的包管理器安装在目录“node_modules”下。最后，编译后的输出可以直接由Node.js执行，或者由下游的构建工具使用。</p><p id="f4da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选项“baseUrl”、“paths”和“rootDirs”可以配置TypeScript编译器在模块解析期间将“import”语句中的模块路径映射到文件系统中的非常规目录。“baseUrl”和“paths”允许基于不在“node_modules”下的路径解析非相关模块，而“outDirs”允许解析虚拟合并成一个的多个根中的相关模块。现在，“rootDir”下的目录结构仍然保留在“outDir”中，不管映射如何，这意味着输出目录结构与发出的。因此，不能通过Node.js或类似工具直接解析js文件。</p><p id="6bd2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这不是打字稿的问题。假设在与运行时可执行文件的最终布局不匹配的源目录布局中，开发人员有责任通过包括构建步骤(例如将依赖项从不同位置复制到最终位置)来解决这个问题。需要注意的是，编译器不会执行这些步骤。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="58cb" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">通过模块解析包含引用的实现文件</strong></h1><p id="811e" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">回想一下，模块解析将模块引用解析为表示该模块的文件。该文件可以是源文件(例如ts，。tsx)或类型声明(. d.ts)。模块引用可以是相对模块引用，也可以是非相对模块引用。相对模块引用是相对于导入模块的源文件来解析的。通过以下方式解析非相对模块引用:(1)相对于baseUrl和路径映射，(2)模仿Node.js策略在“node_modules”文件夹中搜索，以及(3)解析到环境模块。</p><p id="96a1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是一些规则，关于什么时候一个代表被引用模块的文件被包含在实现文件中，意味着一个输出。js将被编译并发送到outDir:</p><p id="e4ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(1)在相对和非相对模块解析中，如果模块解析为类型声明文件(. d.ts)或环境模块，则不包括在内。编译器很乐意使用该文件中包含的类型信息，而不需要进一步查看。这包括模块解析为包含“类型”属性的package.json的情况。</p><p id="05a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(2)在非相对模块解析中，如果编译器模仿Node.js模块解析，解析为“node_modules”文件夹中的文件，则该文件不包括在实现文件中。该模块被假定在一个外部包中，单独构建，并在运行时通过一个包管理器(如npm)集成。</p><p id="f426" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">(3)否则该文件(源文件)包含在实现文件中，编译器将编译该文件并发出一个. js。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="5c45" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated"><strong class="ak">增量编译和项目引用</strong></h1><p id="25c4" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">增量编译通过跳过那些已经编译过并且没有改变的源文件来节省时间。项目引用允许一起构建两个或更多相关的项目，而被引用的项目是增量编译的。有了这两个特性，一个完整的项目可以分解成更小的项目，以便更好地组织和更快地构建。</p><p id="59f6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设项目a和项目b都在开发中。ProjectA在ProjectB中导入并使用代码。当ProjectA被编译时，开发人员也希望编译ProjectB，但只是在需要的时候。</p><p id="bbec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了实现这一点，两个项目都需要在它们的项目根中包含tsconfig.json。然后，在他们的配置中，ProjectA需要使用选项“引用”来引用ProjectB，ProjectB必须启用选项“复合”。</p><p id="809d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#references" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">参考</strong></a><strong class="kq io"/></p><p id="7a8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在ProjectA中，选项“reference”是用对象数组配置的。对象的“path”属性引用被引用项目(ProjectB)的项目根(包含tsconfig.json)。对象还有一个“prepend”属性，但它只适用于“outFile ”,不在讨论之列。</p><p id="54be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，此选项仅在使用“- -build”调用tsc时有效。</p><p id="c880" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">选项“</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#composite" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">复合</strong></a><strong class="kq io">”:</strong></p><p id="df30" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">默认情况下，该选项的值为“true”。对于被另一个项目(ProjectB)引用的项目，必须将其设置为“true”。它强制实施以下约束，使构建工具能够快速确定项目是否需要重新构建，而无需查看源代码:</p><ul class=""><li id="a4f2" class="mz na in kq b kr ks ku kv kx nb lb nc lf nd lj ne nf ng nh bi translated">“rootDir”默认为项目根目录(包含tsconfig.json)</li><li id="4cfd" class="mz na in kq b kr ni ku nj kx nk lb nl lf nm lj ne nf ng nh bi translated">所有要编译的实现文件必须由“include”和“files”显式匹配，而不是由模块引用包含。这样，构建工具不需要检查源文件来确定需要构建哪些文件。</li><li id="8b7f" class="mz na in kq b kr ni ku nj kx nk lb nl lf nm lj ne nf ng nh bi translated">“declaration”默认为true，以生成类型声明(. d.ts)。您可能还希望启用“declarationMap ”,以便当用户在代码编辑器(如具有“转到定义”功能的VS Code)中单击定义时，编辑器会转到源文件(。ts)而不是类型声明(. d.ts)。</li></ul><p id="5dbb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">增量编译选项</strong> <a class="ae mo" href="https://www.typescriptlang.org/tsconfig#incremental" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">增量</strong> </a> <strong class="kq io">和构建模式(-b，- - build) </strong></p><p id="ac78" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">增量编译依赖于构建信息文件来确定哪些源代码需要重新构建。文件的位置可以由“tsBuildInfoFile”选项控制。如果文件丢失，tsc将进行全面编译。</p><p id="5599" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Tsc命令行选项“-b”、“- -build”使tsc构建被引用的项目。由于被引用的项目必须打开选项“复合”，而“复合”又强制“增量”，所以被引用的项目总是增量编译的。“复合”还打开“声明”，因此发出被引用项目的类型声明(. d.ts)。那么对被引用项目的模块引用将被解析为类型声明，而不是实现。</p><p id="2e70" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有一些标志可以与"-b "或"- - build "一起使用。它们是"- - dry "用于模拟运行，"- - clean "用于清理构建输出，"- - force "用于构建，好像所有项目都过期了一样，而"- - watch "用于在监视模式下构建。</p><p id="1afe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，增量编译根据编译信息文件确定编译哪个源代码，而不检查输出。如果上次生成的生成信息文件在那里，并且没有源文件被更改，即使发出了。js文件被删除，增量编译不会重新创建它们。目前，在Github上有一个关于这个的<a class="ae mo" href="https://github.com/microsoft/TypeScript/issues/30602" rel="noopener ugc nofollow" target="_blank">公开问题</a>。此外，如果构建信息文件被删除，当调用' tsc -b - -clean '时，将发出。js文件不会被删除。为了避免这种情况，请始终将构建信息文件(tsconfig.tsbuildinfo)与发出的. js一起移除。</p><p id="88c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">将引用的项目作为模块导入</strong></p><p id="4ea3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选项“reference”仅生成被引用的项目，不会更改TypeScript的模块引用的任何行为。要将引用的项目作为模块导入，请参考上面讨论的模块引用。</p><p id="cae5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">使用项目参考的注意事项</strong></p><p id="936a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">被引用项目的类型声明文件(. d.ts)由编译器生成。这意味着，在构建之前，引用被引用项目的导入语句将在代码编辑器(如VS代码)中显示错误，因为缺少声明。有时候，VS代码中的错误直到重新启动才会消失。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h1 id="22e3" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">结论</h1><p id="d854" class="pw-post-body-paragraph ko kp in kq b kr mj jo kt ku mk jr kw kx ml kz la lb mm ld le lf mn lh li lj ig bi translated">理解了这些机制和配置选项，您应该能够以更灵活的方式组织您的TypeScript项目。如果您想尝试本文中讨论的特性和配置选项，您可以查看这个<a class="ae mo" href="https://github.com/bingtimren/ts-proj-structure-demo" rel="noopener ugc nofollow" target="_blank">演示项目</a>并研究它的构建过程。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="e60d" class="nn ls in bd lt no np dn lx nq nr dp mb kx ns nt md lb nu nv mf lf nw nx mh ny bi translated">进一步阅读</h2><div class="nz oa gp gr ob oc"><a href="https://bit.cloud/blog/sharing-types-between-your-frontend-and-backend-applications-l5qih48g" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">在前端和后端应用程序之间共享类型</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">您的后端API已经更新，可以返回新类型的数据。必须通知前端团队进行更新…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">比特云</p></div></div><div class="ol l"><div class="om l on oo op ol oq km oc"/></div></div></a></div></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><p id="2076" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mp">更多内容请看</em><a class="ae mo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mp">plain English . io</em></strong></a><em class="mp">。报名参加我们的</em> <a class="ae mo" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mp">免费周报</em> </strong> </a> <em class="mp">。关注我们关于</em><a class="ae mo" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mp">Twitter</em></strong></a><a class="ae mo" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mp">LinkedIn</em></strong></a><em class="mp"/><a class="ae mo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mp">YouTube</em></strong></a><em class="mp"/><a class="ae mo" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="mp">不和</em> </strong> </a> <em class="mp">。对增长黑客感兴趣？检查</em> <a class="ae mo" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="mp">电路</em> </strong> </a> <em class="mp">。</em></p></div></div>    
</body>
</html>