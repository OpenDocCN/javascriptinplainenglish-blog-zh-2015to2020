<html>
<head>
<title>Interfaces and Classes in TypeScript/Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript/Angular中的接口和类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/interfaces-and-classes-in-typescript-part-6-3-7fee77b7518b?source=collection_archive---------0-----------------------#2019-11-15">https://javascript.plainenglish.io/interfaces-and-classes-in-typescript-part-6-3-7fee77b7518b?source=collection_archive---------0-----------------------#2019-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9c22" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是Angular(第6.3部分)/什么是TypeScript？</h2></div><p id="a5d1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">工作原理… |如何开始…</p><blockquote class="ky kz la"><p id="0d59" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">如果<em class="in">你还没有涉及到本系列的</em><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/arrow-functions-in-typescript-part-6-2-of-series-what-angular-is-%EF%B8%8F-what-typescript-is-d4584d87d01b" rel="noopener"><em class="in">Part—6.2</em></a><em class="in">我推荐你查看一下这个链接→</em><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/arrow-functions-in-typescript-part-6-2-of-series-what-angular-is-%EF%B8%8F-what-typescript-is-d4584d87d01b" rel="noopener">Arrow Functions in TypeScript | Part—6.2 |什么是Angular？🤷🏻‍♂️什么是打字稿？</a></p></blockquote><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/fb845bf6b16105a967c7fcd6558cf9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Psa8FAE2oevzxMA2RiYzUA.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">In this part covered Interfaces and Classes in TypeScript</figcaption></figure><h1 id="b971" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">打字稿基础👇</h1><ol class=""><li id="5165" class="mo mp in ke b kf mq ki mr kl ms kp mt kt mu kx mv mw mx my bi translated"><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/type-annotations-fundamentals-of-typescript-part-6-1-823ab6f62ead" rel="noopener">类型标注</a></li><li id="aa4a" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx mv mw mx my bi translated"><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/arrow-functions-in-typescript-part-6-2-of-series-what-angular-is-%EF%B8%8F-what-typescript-is-d4584d87d01b" rel="noopener">箭头功能</a></li><li id="162e" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx mv mw mx my bi translated"><strong class="ke io">接口</strong></li><li id="5d7b" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx mv mw mx my bi translated"><strong class="ke io">跟班</strong></li><li id="125d" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx mv mw mx my bi translated">构造器</li><li id="82dc" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx mv mw mx my bi translated">访问修饰符</li><li id="b9cc" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx mv mw mx my bi translated">性能</li><li id="4e5f" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx mv mw mx my bi translated">模块</li></ol><h1 id="13e6" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">6.3接口</h1><p id="2f8f" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">在TypeScript中使用自定义类型的更好方法是使用接口。一个<strong class="ke io">接口</strong>是一个为类定义语法的结构。除了函数，<strong class="ke io">接口</strong>也可以<strong class="ke io">用于</strong>一个类来定义定制类型。接口是一个抽象类型，它不像类那样包含任何代码。</p><p id="9116" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"><em class="lb">TypeScript中接口和类有什么区别？</em> </strong></p><p id="12a6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个<strong class="ke io">类</strong>是一个蓝图，从中我们可以创建共享相同配置的对象——属性和方法。一个<strong class="ke io">接口</strong>是一组描述一个对象的相关属性和方法，但是既不为它们提供实现也不为它们提供初始化。</p><p id="9fb8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">👉让我们定义一个接口</p><ul class=""><li id="7952" class="mo mp in ke b kf kg ki kj kl nh kp ni kt nj kx nk mw mx my bi translated">接口名称:<code class="fe nl nm nn no b">Point</code></li><li id="b339" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">然后在界面块中添加属性为<code class="fe nl nm nn no b">x</code>和<code class="fe nl nm nn no b">y</code></li><li id="cdc4" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">接口的名称应该总是使用以大写字母开头的Pascal命名约定。看下面<code class="fe nl nm nn no b"><strong class="ke io">P</strong></code>的名字界面<code class="fe nl nm nn no b"><strong class="ke io">Point</strong></code>是以大写字母开头的。</li></ul><pre class="lh li lj lk gt np no nq nr aw ns bi"><span id="4216" class="nt lx in no b gy nu nv l nw nx">interface <strong class="no io">Point</strong> {<br/>    x: number,<br/>    y: number<br/>}</span></pre><p id="4387" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请看下面的<strong class="ke io">内联注释示例— </strong>检查此链接👉<a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/arrow-functions-in-typescript-part-6-2-of-series-what-angular-is-%EF%B8%8F-what-typescript-is-d4584d87d01b" rel="noopener">点击此处</a>阅读更多关于行内注释的信息。</p><pre class="lh li lj lk gt np no nq nr aw ns bi"><span id="6131" class="nt lx in no b gy nu nv l nw nx">let drawNewLine = function (<strong class="no io">point1: {x: number, y: number}, point2: {x: number, y: number}</strong>) {<br/>    console.log("Code to draw a line comes here...");<br/>}</span></pre><p id="3366" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过声明接口来简化上面的代码。</p><ul class=""><li id="2511" class="mo mp in ke b kf kg ki kj kl nh kp ni kt nj kx nk mw mx my bi translated">它干净多了，而且</li><li id="2d61" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">可以在多个地方重复使用</li></ul><pre class="lh li lj lk gt np no nq nr aw ns bi"><span id="6f34" class="nt lx in no b gy nu nv l nw nx">let drawNewLine = function (<strong class="no io">point1: Point, point2: Point</strong>) {<br/>    console.log("Code to draw a line comes here...");<br/>}</span></pre><p id="23e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看上面👆<code class="fe nl nm nn no b">point1</code>和<code class="fe nl nm nn no b">point2</code>对象指向界面<code class="fe nl nm nn no b">Point</code>。</p><h1 id="c19f" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">内聚力</h1><p id="5652" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated"><strong class="ke io">衔接的概念:</strong>意为<strong class="ke io"> </strong>有关联的事物应该永远是一个单位的一部分。他们应该走在一起，这就是所谓的凝聚力。</p><p id="9a5e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个界面的例子定义了一个点对象的形状(看👇第一行)和下面我们有独立的功能(看👇第6行)，这就是我们违反衔接原则的地方。</p><p id="9ef3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，<code class="fe nl nm nn no b">drawNewLine</code>的概念与<code class="fe nl nm nn no b">Point</code>接口高度相关。现在，当我们创建另一个函数<code class="fe nl nm nn no b">lengthOfLine</code>(看👇10号线)。我们再次违反了内聚原则:我们有两个函数(<code class="fe nl nm nn no b">drawNewLine</code>和<code class="fe nl nm nn no b">lengthOfLine</code>)，它们与<code class="fe nl nm nn no b">Point</code>对象是分开的。他们都应该是一个单位的一部分。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/3452a38b3316d778ba5e614ce596d034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNagSQutYw5b-80HlMec_w.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><strong class="bd nz">x</strong>, <strong class="bd nz">y</strong> and <code class="fe nl nm nn no b"><strong class="bd nz">drawNewLine</strong>, <strong class="bd nz">lengthOfLine</strong> all should be a part of single unit</code></figcaption></figure><p id="4149" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在面向对象编程中，我们称这种单元类为高度相关的类、组、属性、函数。</p><p id="3a0b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相关的事物应该总是一个单元的一部分，但是在这种情况下，我们不能在接口内移动这些函数，因为接口纯粹是用于声明的，它们不能包含实现。</p><p id="94e1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">⭐️现在，看看我们能做什么…</p><ul class=""><li id="fb75" class="mo mp in ke b kf kg ki kj kl nh kp ni kt nj kx nk mw mx my bi translated">我们可以在接口中添加一个<strong class="ke io">函数声明，它不接受任何参数，返回void意味着这个函数不返回任何东西。看👇下面。</strong></li><li id="db19" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">因为参数<code class="fe nl nm nn no b">x</code>和<code class="fe nl nm nn no b">y</code>已经是接口<code class="fe nl nm nn no b"><strong class="ke io">Point</strong></code>的一部分，所以我们不需要在<code class="fe nl nm nn no b">drawNewLine</code>函数中传递参数。这些函数可以直接访问同一个单元中的属性<code class="fe nl nm nn no b">x</code>和<code class="fe nl nm nn no b">y</code>。</li><li id="f8e8" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">在接口中，我们不能有实现，我们只能有函数的签名。</li></ul><pre class="lh li lj lk gt np no nq nr aw ns bi"><span id="c9f9" class="nt lx in no b gy nu nv l nw nx">interface <strong class="no io">Point</strong> {<br/>    x: number,<br/>    y: number,<br/>    drawNewLine: () =&gt; void;<br/>}</span></pre><p id="4e25" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编译器从接口中了解到它声明了两个属性(<code class="fe nl nm nn no b">x</code>、<code class="fe nl nm nn no b">y</code>)和一个方法(<code class="fe nl nm nn no b">drawNewLine</code>)——它的实现在其他地方。</p><p id="68cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所知，我们只能在接口中声明，不能在接口中实现，而实现需要类。</p><h1 id="249d" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">⭐️更在接口道</h1><ul class=""><li id="f951" class="mo mp in ke b kf mq ki mr kl ms kp mt kt mu kx nk mw mx my bi translated"><strong class="ke io">可选属性:</strong>并非接口的所有属性都是必需的。有些在特定条件下存在，有些可能根本不存在。我们可以通过在属性名后面加上<code class="fe nl nm nn no b"> ? (question mark)</code>来指定这一点。看👇下面第4行&amp; 5 —这些可选参数可以在调用函数时随意传递。看👇下方24号线&amp; 28处。</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/8f2e4a34690907ed747230eb014d195d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CdIn1_HXz_DDdrPY8Byjg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">We can specify <strong class="bd nz">Optional Properties</strong> by putting<code class="fe nl nm nn no b"> ? (question mark)</code> after the name of the property</figcaption></figure><ul class=""><li id="6995" class="mo mp in ke b kf kg ki kj kl nh kp ni kt nj kx nk mw mx my bi translated"><strong class="ke io">只读</strong>我们可以通过在遗产名称前加上<code class="fe nl nm nn no b">readonly</code>来说明这一点。看👇在4号线下方&amp; 5处。</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/82f6e54ef3c851db611cf897857a1ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-5JqB_th51Ae_eTaRR4rw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">We can specify <strong class="bd nz">Readonly</strong> <strong class="bd nz">Properties</strong> by putting <code class="fe nl nm nn no b">readonly</code> before the name of the property</figcaption></figure><ul class=""><li id="2b7a" class="mo mp in ke b kf kg ki kj kl nh kp ni kt nj kx nk mw mx my bi translated"><strong class="ke io"> Readonly vs Const: </strong>记住是使用<code class="fe nl nm nn no b">readonly</code>还是<code class="fe nl nm nn no b">const</code>的最简单方法是询问你是在变量还是属性上使用它。变量使用<code class="fe nl nm nn no b">const</code>，而属性使用<code class="fe nl nm nn no b">readonly</code>。现在，<code class="fe nl nm nn no b"><strong class="ke io">variable</strong></code>可以是一个局部<code class="fe nl nm nn no b">variable</code>，定义在一个过程中，并且只在该过程中可用。而<code class="fe nl nm nn no b"><strong class="ke io">property</strong></code>是类、结构和接口的成员。</li></ul></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><h1 id="23d7" class="lw lx in bd ly lz oh mb mc md oi mf mg jt oj ju mi jw ok jx mk jz ol ka mm mn bi translated">6.3课程</h1><p id="206d" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">一个<strong class="ke io">接口</strong>有完全抽象的方法，即没有任何人的方法。一个<strong class="ke io">接口</strong>在语法上类似于<strong class="ke io">类</strong>，但是在<strong class="ke io">类</strong>和<strong class="ke io">接口</strong>之间有一个主要的<strong class="ke io">区别</strong>，即<strong class="ke io">类</strong>可以被实例化，但是<strong class="ke io">接口</strong>永远不能被实例化。<strong class="ke io">类</strong>的成员可以是私有的、公共的或受保护的。并且一个<strong class="ke io">接口</strong>的成员总是公共的。一个<strong class="ke io">接口</strong>说需要做什么。一个<strong class="ke io">类</strong>说明了它是如何完成的。</p><p id="4fc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">类</strong>是高度相关的变量(属性)和函数(方法)的组。</p><h1 id="1aa1" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">⭐️运用衔接原则</h1><p id="8d18" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">用类代替接口应用内聚原则。这里<code class="fe nl nm nn no b">x</code>和<code class="fe nl nm nn no b">y</code>是存储数据的字段，<code class="fe nl nm nn no b">drawNewLine</code>和<code class="fe nl nm nn no b">lengthOfLine</code>是函数。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/2b6f1fdd409e5e6e1cb510c9d58d0327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3IednYdDYYl8y350ddbUg.png"/></div></div></figure><p id="0199" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们有一切都在一个类。我们有两个字段和两个方法。当一个函数是类的一部分时，我们称它为方法。</p><h1 id="427e" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">⭐️是时候了⏳创建类和调用方法的对象</h1><ul class=""><li id="d007" class="mo mp in ke b kf mq ki mr kl ms kp mt kt mu kx nk mw mx my bi translated">创建一个<code class="fe nl nm nn no b">class</code> — <em class="lb">外观的对象👇17号线下方</em></li><li id="9d8c" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">调用一个没有设置属性<code class="fe nl nm nn no b">x</code>和<code class="fe nl nm nn no b">y</code> — <em class="lb"> Look值的方法👇下面的第18行—这将返回输出👉x:未定义，y:未定义</em></li><li id="8e2d" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">设置属性<code class="fe nl nm nn no b">x</code>和<code class="fe nl nm nn no b">y</code> — <em class="lb"> Look的值后调用方法👇下面第22行—这将返回输出👉x: 1，y: 2 </em></li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/5df548c3ec07ea137ac66cd1b370acc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Edz4vXRdmw8kPBR70vytw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Creating Class | Create an object of Class | &amp; call methods</figcaption></figure><p id="21bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看上面👆这就是我们在程序中定义和使用类的方式。</p><pre class="lh li lj lk gt np no nq nr aw ns bi"><span id="e2ca" class="nt lx in no b gy nu nv l nw nx">let pointObj = new Point();</span></pre><p id="eea7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里<code class="fe nl nm nn no b">Point</code>是类，<code class="fe nl nm nn no b">pointObj</code>是对象，或者我们可以说它是类<code class="fe nl nm nn no b">Point</code>的实例。</p><p id="f034" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">⭐️ <strong class="ke io">类和对象的最佳例子:</strong>想想人类——这里<code class="fe nl nm nn no b">Human</code>是一个类，当我们创建这个类的实例<code class="fe nl nm nn no b">Human</code>时，我们得到<code class="fe nl nm nn no b">John</code>、<code class="fe nl nm nn no b">Paul</code>、<code class="fe nl nm nn no b">Bob</code>、<code class="fe nl nm nn no b">Mary</code>——这些都是对象。</p><ul class=""><li id="2282" class="mo mp in ke b kf kg ki kj kl nh kp ni kt nj kx nk mw mx my bi translated">人类👤— <code class="fe nl nm nn no b">Human</code>是一个类。</li><li id="836e" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated"><code class="fe nl nm nn no b">John</code>👨‍🌾，<code class="fe nl nm nn no b">Paul</code>👨‍🎓，<code class="fe nl nm nn no b">Bob</code>👨‍💻，<code class="fe nl nm nn no b">Mary</code>👩‍💼—是类别<code class="fe nl nm nn no b">Human</code>的对象。</li></ul></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><blockquote class="ky kz la"><p id="ebd8" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">下一个重要概念…</p></blockquote><h1 id="6829" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">⭐️实现接口/类实现接口:</h1><p id="8daa" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated"><strong class="ke io">接口</strong>中的所有方法都是用空体声明的，都是公共的，默认所有字段都是公共的、静态的、最终的。实现<strong class="ke io">接口</strong>的<strong class="ke io">类</strong>必须实现<strong class="ke io">接口</strong>中声明的所有方法和字段。</p><ul class=""><li id="6a0e" class="mo mp in ke b kf kg ki kj kl nh kp ni kt nj kx nk mw mx my bi translated">我们不能在接口的方法中编写任何代码，也不能初始化变量👇下面第3行和第4行 —空体，即只允许<em class="lb">申报。</em></li><li id="bb0c" class="mo mp in ke b kf mz ki na kl nb kp nc kt nd kx nk mw mx my bi translated">我们可以在类的方法中编写代码，也可以初始化变量👇下面第9和11行 —方法实施。</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/f08ba4d5768e9f016afb9a6b0b70101d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1h4CImCpkz-yGebGTWGMA.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><code class="fe nl nm nn no b">Please carefully read all the comments in the image</code></figcaption></figure><blockquote class="ky kz la"><p id="0b2d" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">下一个重要概念…</p></blockquote><h1 id="bc4a" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">⭐️扩展一个接口/接口扩展另一个接口:</h1><p id="dfc1" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">一个<strong class="ke io">接口</strong>可以<strong class="ke io">扩展</strong>另一个<strong class="ke io">接口</strong>，就像一个类可以<strong class="ke io">扩展</strong>另一个类一样。这允许我们将一个接口的成员复制到另一个接口中，这为我们如何将接口分成可重用的组件提供了更多的灵活性。<strong class="ke io">扩展</strong>关键字用于<strong class="ke io">扩展</strong>一个<strong class="ke io">接口。</strong></p><p id="b681" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">看👇下面第10行</em> —类型<strong class="ke io">S<em class="lb">square</em></strong><em class="lb">的变量(Square)可以访问其他接口(Shape和PenStroke)的成员，因为Square具有扩展的形状和PenStroke。</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/2ddb35bfec07b3258905bf1018225c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NA1P_mxp2Ubvb09fm_TT8w.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><code class="fe nl nm nn no b">Please carefully read all the comments in the image</code></figcaption></figure><blockquote class="om"><p id="184e" class="on oo in bd op oq or os ot ou ov kx dk translated">以前要记住的事情👋👋</p></blockquote><blockquote class="ky kz la"><p id="48d9" class="kc kd lb ke b kf ox jo kh ki oy jr kk lc oz kn ko ld pa kr ks le pb kv kw kx ig bi translated"><strong class="ke io"> <em class="in">类扩展了另一个</em> </strong>(涵盖于此👇文章)<strong class="ke io"><em class="in"><br/></em></strong><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/constructors-and-access-modifiers-in-typescript-22a2d6188780#09ed" rel="noopener"><em class="in">https://medium . com/@ ankitmaheshwarin/constructors-and-access-modifiers-in-typescript-222d 6188780 # 09ed</em></a></p><p id="dd25" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="ke io"> <em class="in">类实现了一个接口</em> </strong>(在本👇<strong class="ke io"><br/></strong><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/interfaces-and-classes-in-typescript-part-6-3-7fee77b7518b#ebd8" rel="noopener"><em class="in">https://medium . com/@ ankitmaheshwarin/interfaces-and-classes-in-typescript-part-6-3-7 fee 77 b 7518 b # EBD 8</em></a></p><p id="ce73" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="ke io"> <em class="in">接口扩展了另一个接口</em> </strong>(在本👇<strong class="ke io"><br/></strong><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/interfaces-and-classes-in-typescript-part-6-3-7fee77b7518b#0b2d" rel="noopener"><em class="in">https://medium . com/@ ankitmaheshwarin/interfaces-and-classes-in-typescript-part-6-3-7 fee 77b 7518 b # 0b2d</em></a></p></blockquote></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><p id="c03e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是关于<strong class="ke io">接口</strong>和<strong class="ke io">类</strong>——下一部分见👋👋来涵盖另一个概念<strong class="ke io">构造函数。</strong></p></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><blockquote class="ky kz la"><p id="436c" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">如果<em class="in">你还没有涉及到本系列的</em><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/arrow-functions-in-typescript-part-6-2-of-series-what-angular-is-%EF%B8%8F-what-typescript-is-d4584d87d01b" rel="noopener"><em class="in">Part—6.2</em></a><em class="in">我推荐你查看一下这个链接→</em><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn/arrow-functions-in-typescript-part-6-2-of-series-what-angular-is-%EF%B8%8F-what-typescript-is-d4584d87d01b" rel="noopener">Arrow Functions in TypeScript | Part—6.2 |什么是Angular？🤷🏻‍♂️什么是打字稿？</a></p><p id="d0a1" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">敬请期待第6.4集<br/><a class="ae lf" href="https://medium.com/@AnkitMaheshwariIn" rel="noopener">https://medium.com/@AnkitMaheshwariIn</a></p></blockquote></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><p id="98cb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi pc translated">如果你不介意给它一些掌声👏 👏既然有帮助，我会非常感谢:)帮助别人找到这篇文章，所以它可以帮助他们！</p><p id="edbf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">永远鼓掌…</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/2f4712882de180d90c9dcdb0cb91ae69.png" data-original-src="https://miro.medium.com/v2/resize:fit:156/1*ZyakciENSuUWo7tqu84tXQ.gif"/></div></figure><h1 id="a79e" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">了解更多信息</h1><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="pm pn l"/></div></figure></div></div>    
</body>
</html>