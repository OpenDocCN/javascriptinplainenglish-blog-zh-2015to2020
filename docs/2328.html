<html>
<head>
<title>Beware of unsafe implicit globals in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">注意JavaScript中不安全的隐式全局变量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/beware-of-unsafe-implicit-globals-in-javascript-f370ccca8fdb?source=collection_archive---------3-----------------------#2020-06-13">https://javascript.plainenglish.io/beware-of-unsafe-implicit-globals-in-javascript-f370ccca8fdb?source=collection_archive---------3-----------------------#2020-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0833" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">未声明变量的潜在危险以及如何消除它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/968122bee553d698527df5bc769edcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rh2LLVITYmex6HyzqYVwWg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">original image by <a class="ae kv" href="https://www.flickr.com/photos/fattytuna/" rel="noopener ugc nofollow" target="_blank">Becky Lai</a> <a class="ae kv" href="https://www.flickr.com/photos/fattytuna/2157627278" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/fattytuna/2157627278</a></figcaption></figure><p id="1483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你给一个没有明确声明的变量赋值(用<strong class="ky ir"> <em class="ls"> var </em> </strong>、<strong class="ky ir"> <em class="ls">让</em> </strong>、<strong class="ky ir"> <em class="ls"> const </em> </strong>或者作为当前函数的一个参数)，JavaScript会隐式地把它创建为一个全局变量。在web应用程序中，“全局”意味着它是<strong class="ky ir"> <em class="ls">窗口</em> </strong>对象的属性。</p><p id="0108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这是这样一个“被遗忘的”声明的典型案例:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="d5a9" class="ly lz iq lu b gy ma mb l mc md">for (<strong class="lu ir">i</strong>=0; i&lt;list.length; i++) {<br/>    // do something<br/>}</span></pre><p id="7bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当循环开始时，一个<strong class="ky ir"> <em class="ls">窗口. i </em> </strong>被自动定义，因为开发者忘记了包含一个<strong class="ky ir"> <em class="ls">让</em> </strong>(或<strong class="ky ir"> <em class="ls"> var </em> </strong>关键字，如下所示:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="d28b" class="ly lz iq lu b gy ma mb l mc md">for (<strong class="lu ir">let</strong> i=0; i&lt;list.length; i++) {<br/>...</span></pre><p id="3de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个不需要的全局变量会一直存在，直到网页被卸载。这是一种在复杂的web应用程序中很容易发生的错误，更常见的情况是，它们是在没有严格标准的情况下，在任何结构良好的框架之外开发的。</p><h1 id="8c4a" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">附带损害赔偿</h1><p id="29a0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为什么这会很危险？</p><p id="bb52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，任何未声明的变量都可能无意中覆盖<strong class="ky ir"> <em class="ls">窗口</em> </strong>对象的同名属性。例如，以下代码覆盖了标准的<strong class="ky ir"> <em class="ls"> alert </em> </strong>函数，因为它为一个同名的未声明变量赋值:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="c43f" class="ly lz iq lu b gy ma mb l mc md">if (!somecheck()) {<br/>    alert = 'Check failed';<br/>} else {<br/>    alert = '';<br/>}<br/>if (alert) console.log(alert);</span></pre><p id="93f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到<strong class="ky ir"> <em class="ls">窗口</em> </strong>对象有200多个属性，这并不像看起来那么不可能。在被粗心的程序员意外覆盖的属性或函数中，我们可以找到看似无害的东西，比如<em class="ls">关闭、获取、名称、位置、顶部、停止、图像、事件、</em>等。</p><p id="f880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，程序员假设变量是<em class="ls">局部的</em>可能会产生奇怪的行为。例如，以下代码块在外部和内部函数中都包含相同的错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7f97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<strong class="ky ir"> <em class="ls"> i </em> </strong>(未声明的)变量在外部和内部循环中都被用作迭代器，对内部函数的调用会无意中损害外部循环，不会产生预期的结果。事实上，这个变量并不像程序员想象的那样是<em class="ls"/>局部变量，但它确实是两个函数中的<em class="ls">同一个变量(window.i)。现实生活中的例子比这复杂得多，也更微妙。</em></p><h1 id="6c94" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">如何将它们冲洗掉</h1><p id="5617" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在将web应用程序部署到生产环境之前，最好识别并修复此类未声明的变量。三个简单的步骤就足够了:</p><ol class=""><li id="61ba" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">在执行任何脚本之前保存<strong class="ky ir"> <em class="ls">窗口</em> </strong>对象的属性列表</li><li id="e21c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">在加载所有脚本后，将初始属性与现有属性进行匹配，以识别在初始页面加载期间创建的变量</li><li id="bea3" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">在对应用程序的所有功能进行有意义的导航之后，执行相同的比较，以找出在标准使用期间产生的其他变量。</li></ol><p id="5cf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了不需要的属性列表，最后一步是在代码中搜索变量隐式声明并修复它们。</p><p id="6ac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写了一些非常简单的代码，可以帮助完成这些任务。</p><h2 id="a89a" class="ly lz iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">初始化</h2><p id="15a0" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在一个典型的设置中，我将这段代码作为初始的<em class="ls"> &lt;脚本&gt; </em>包含在应用程序主页中(index.html，index.html或类似的):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="64d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它在<strong class="ky ir"> <em class="ls"> glob.initial </em> </strong>中保存一个包含所有属性名的数组，并定义了<strong class="ky ir"> <em class="ls"> showDiff </em> </strong>函数，用于显示给定时刻的新变量列表。请注意，只有在进行这种检查和清洁时，才应包含此代码，并在之后删除。</p><h2 id="31f1" class="ly lz iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">装载后检查</h2><p id="cc62" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">其次，我通常会放一个小脚本，在网页加载完成后立即执行第一次检查(如果使用jQuery，我会把它放在$。就绪功能):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2af1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">典型的输出(到浏览器控制台)如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/62b21a4a9f6da10cd658bb4da92198f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBYuystVqx5YJgROw9TyUw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Output showing a list of new properties (Chrome console)</figcaption></figure><p id="a770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，从一个真实的应用程序来看，一些函数被无意中定义在“根”级别(<em class="ls"> getRandomColor </em>和<em class="ls"> hexToRgb </em>)以及<em class="ls"> countries </em>数组。我可以很容易地修好它们。</p><h2 id="c182" class="ly lz iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated">在飞行检查中</h2><p id="d83b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在大量使用应用程序后，我们可以进行最详尽的分析，揭示用户工作过程中产生的变量。</p><p id="d186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单的方法是使用浏览器调试工具对我们的<em class="ls"> showDiff </em>函数执行适当的调用。换句话说，用户停止其操作，打开调试器窗口，并在<em class="ls">手表</em>面板中输入以下表达式:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="5f69" class="ly lz iq lu b gy ma mb l mc md">glob.showDiff(glob.afterLoad, Object.keys(window));</span></pre><p id="5390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着显示<strong class="ky ir"> <em class="ls">窗口</em> </strong>对象在加载时保存的属性和现在的属性之间的差异。同样在控制台上，结果将是操作时创建的变量列表。</p><h1 id="1b94" class="me lz iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="629c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我认为在赋值时自动创建全局变量是JavaScript环境中的一个缺陷。以我的经验来看，我曾经历过一段艰难的时间，从奇怪的症状开始调试代码，结果发现原因是一个未声明的变量。我几乎看不出拥有这样一个隐含的全局<em class="ls">作用域有什么好处。</em></p><p id="87d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望我小小的贡献能对很多人有所帮助。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h2 id="f435" class="ly lz iq bd mf nq nr dn mj ns nt dp mn lf nu nv mp lj nw nx mr ln ny nz mt oa bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="c889" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我们的YouTube频道</strong> </a> <strong class="ky ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>