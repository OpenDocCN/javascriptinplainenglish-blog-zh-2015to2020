<html>
<head>
<title>A dependency injection setup for React applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用程序的依赖注入设置</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-dependency-injection-setup-for-react-applications-af9c67fa5e9c?source=collection_archive---------7-----------------------#2020-11-23">https://javascript.plainenglish.io/a-dependency-injection-setup-for-react-applications-af9c67fa5e9c?source=collection_archive---------7-----------------------#2020-11-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="cea3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何配置React应用程序使用InversifyJS在组件中注入服务</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/afa1b036033a78a4388aede312f12a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j_aUTT3eItAjIfaS"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@erikeae?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Erik Eastman</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="913b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想如果你在这里，你知道什么是依赖注入。在某些情况下，我对前端开发感到困惑。如果技术上不需要，为什么要使用依赖注入？我可以在组件中导入“服务”，瞧，它可以调用API或在存储上写入。客户端是“平凡的”，它只显示数据、灯光和颜色:)</p><p id="7904" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于小型应用程序来说，这可能是一个很有价值的方法，但是当你的应用程序需要增长很多年的时候，当你试图测试你的代码的时候，问题就来了。在某一点上，您将开始这样做，因为大型代码库需要测试来减轻问题和手工QA部门的压力(如果有的话)，以实现连续交付或在发布前的UAT中。引入依赖注入允许你分离代码，提高可测试性，当然，增加组件的组织，使你能够更好地扩展或改变它们。</p><p id="fb79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React不像Angular那样提供现成的依赖注入。于是，我自问如何让React能够实现依赖注入。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="b31e" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">应用程序设置</h1><p id="9c7f" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">让我们从使用<a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建一个新的React应用程序开始:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="8c68" class="my lx in mu b gy mz na l nb nc">npx create-react-app <strong class="mu io">my-app</strong> --template <strong class="mu io">typescript</strong></span><span id="89ef" class="my lx in mu b gy nd na l nb nc">or</span><span id="2b41" class="my lx in mu b gy nd na l nb nc">yarn create react-app <strong class="mu io">my-app</strong> --template <strong class="mu io">typescript</strong></span><span id="4799" class="my lx in mu b gy nd na l nb nc">cd <strong class="mu io">my-app</strong></span></pre><p id="422b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们需要安装<a class="ae ks" href="http://inversify.io/" rel="noopener ugc nofollow" target="_blank"> InversifyJS </a>:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="57db" class="my lx in mu b gy mz na l nb nc">npm install <strong class="mu io">inversify reflect-metadata</strong></span><span id="4f85" class="my lx in mu b gy nd na l nb nc">or</span><span id="b7e2" class="my lx in mu b gy nd na l nb nc">yarn add <strong class="mu io">inversify reflect-metadata</strong></span></pre><p id="23e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，只需编辑<em class="ne"> tsconfig.json </em>使其适应inversify。只需在<em class="ne">编译器选项</em>中添加这两行:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="b54c" class="my lx in mu b gy mz na l nb nc">"<strong class="mu io">experimentalDecorators</strong>": true,<br/>"<strong class="mu io">emitDecoratorMetadata</strong>": true</span></pre><p id="5a8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">InversifyJS使用decorators工作，我们只需要告诉TypeScript识别并与代码一起发出这些信息。</p><p id="1ac0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要检查我们的设置是否有效，只需使用以下命令启动应用程序:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="d00b" class="my lx in mu b gy mz na l nb nc">npm start</span><span id="4711" class="my lx in mu b gy nd na l nb nc">or</span><span id="a37a" class="my lx in mu b gy nd na l nb nc">yarn start</span></pre><h1 id="cb66" class="lw lx in bd ly lz nf mb mc md ng mf mg jt nh ju mi jw ni jx mk jz nj ka mm mn bi translated">依赖注入设置</h1><p id="bef1" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">如果应用程序像预期的那样工作，并且应该如此，我们就可以开始将注意力转移到依赖注入上。</p><p id="6c4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要知道如何使用Inversify，请查看它的文档。对于我们的目的，我们只需要一个简单的配置。</p><p id="be88" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Inversify使用容器来注册服务。之后，可以使用同一个容器对象创建或获取服务。与其他DI工具没有什么不同。所以，让我们添加一个简单的服务。转到<em class="ne"> src </em>文件夹，创建一个新的TS文件<em class="ne"> date-string.service.ts </em>:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="9540" class="my lx in mu b gy mz na l nb nc"><strong class="mu io">export class </strong>DateStringService {<br/>  <strong class="mu io">constructor</strong>(<br/>    <strong class="mu io">private </strong>prefix: <strong class="mu io">string<br/>  </strong>) {}<br/><br/>  getDateString() {<br/>    <strong class="mu io">return </strong>`${<strong class="mu io">this</strong>.prefix}: ${(<strong class="mu io">new </strong>Date()).toISOString()}`;<br/>  }<br/>}</span></pre><p id="491c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> DateStringService </strong>只是在构造函数中接受一个前缀，并返回当前日期，其前缀是在创建过程中指定的字符串。</p><p id="e610" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们设置容器。在<em class="ne"> src/index.ts </em>中，您应该有类似于以下代码的内容:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="25fe" class="my lx in mu b gy mz na l nb nc"><strong class="mu io">import </strong>React <strong class="mu io">from </strong>'react';<br/><strong class="mu io">import </strong>ReactDOM <strong class="mu io">from </strong>'react-dom';<br/><strong class="mu io">import </strong>'./index.css';<br/><strong class="mu io">import </strong><em class="ne">App </em><strong class="mu io">from </strong>'./App';<br/><strong class="mu io">import </strong><em class="ne">reportWebVitals </em><strong class="mu io">from </strong>'./reportWebVitals';<br/><br/>ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;App /&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);<br/><br/>// If you want to start measuring performance in your app, pass a function<br/>// to log results (for example: reportWebVitals(console.log))<br/>// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals<br/><em class="ne">reportWebVitals</em>();</span></pre><p id="5df8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只需添加一个容器配置:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="9819" class="my lx in mu b gy mz na l nb nc">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import './index.css';<br/>import <em class="ne">App </em>from './App';<br/>import { DateStringService } from './date-string.service';<br/>import <em class="ne">reportWebVitals </em>from './reportWebVitals';<br/><strong class="mu io">import { Container } from 'inversify';</strong><br/><br/><strong class="mu io">const container = new Container();<br/>container.bind(DateStringService)<br/>   .toConstantValue(new DateStringService('today is'));</strong><br/><br/>ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;App /&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);<br/><br/>// If you want to start measuring performance in your app, pass a function<br/>// to log results (for example: reportWebVitals(console.log))<br/>// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals<br/><em class="ne">reportWebVitals</em>();</span></pre><p id="ba5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">完成了。现在，您的容器能够创建一个新的<em class="ne"> DateStringService </em>并在需要时提供它。</p><h1 id="0171" class="lw lx in bd ly lz nf mb mc md ng mf mg jt nh ju mi jw ni jx mk jz nj ka mm mn bi translated">解决服务问题</h1><p id="fbab" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">我们需要做的最后一步是建立在组件内部解析服务的能力。为此，我们创建了一个特定的绑定。让我们创建一个名为<em class="ne"> react-binding.tsx </em>的新文件，其中包含以下代码:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="1c60" class="my lx in mu b gy mz na l nb nc"><strong class="mu io">import </strong>{ Container, interfaces } <strong class="mu io">from </strong>'inversify';<br/><strong class="mu io">import </strong>React, { <em class="ne">useContext </em>} <strong class="mu io">from </strong>'react';<br/><br/>// Defines the context to support the container.<br/><strong class="mu io">interface </strong>ContainerContext {<br/>  container: Container | <strong class="mu io">null</strong>;<br/>}<br/><br/><em class="ne">/**<br/> * Defines the context to use Inversify<br/> * container to resolve dependencies.<br/> */<br/></em><strong class="mu io">const </strong>InversifyContext = React.<em class="ne">createContext</em>&lt;ContainerContext&gt;(<br/>  { container: <strong class="mu io">null </strong>},<br/>);<br/><br/>// Defines props for the provider.<br/><strong class="mu io">interface </strong>ContainerProviderProps {<br/>  container: Container;<br/>}<br/><br/><em class="ne">/**<br/> * Defines the React component to provide<br/> * the container to the child components.<br/> */<br/></em><strong class="mu io">export const </strong><em class="ne">ContainerProvider</em>: React.FC&lt;ContainerProviderProps&gt; = (<br/>  { container, children },<br/>) =&gt; (<br/>  &lt;InversifyContext.Provider value={{ container }}&gt;<br/>    {children}<br/>  &lt;/InversifyContext.Provider&gt;<br/>);<br/><br/><em class="ne">/**<br/> * Defines the hook used to resolve a dependency in a component.<br/> */<br/></em><strong class="mu io">export function </strong><em class="ne">useInjection</em>&lt;T&gt;(identifier: interfaces.ServiceIdentifier&lt;T&gt;): T {<br/>  <strong class="mu io">const </strong>{ container } = <em class="ne">useContext</em>(InversifyContext);<br/>  <strong class="mu io">if </strong>(!container) {<br/>    <strong class="mu io">throw new </strong>Error('The container should not be null');<br/>  }<br/>  <strong class="mu io">try </strong>{<br/>    <strong class="mu io">return </strong>container.get&lt;T&gt;(identifier);<br/>  } <strong class="mu io">catch </strong>(e) {<br/>    <strong class="mu io">return </strong>container.resolve&lt;T&gt;(identifier <strong class="mu io">as </strong>interfaces.Newable&lt;T&gt;);<br/>  }<br/>}</span></pre><p id="b744" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一小段代码是注射过程的核心。</p><ul class=""><li id="94c4" class="nk nl in kv b kw kx kz la lc nm lg nn lk no lo np nq nr ns bi translated"><strong class="kv io"> InversifyContext </strong>是将通过组件层次结构传递的上下文，以便容器本身在任何地方都可用。</li><li id="2e53" class="nk nl in kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated"><strong class="kv io"> ContainerProvider </strong>是一个UI容器，它将被用作应用程序组件的包装器，以便为任何子组件提供上下文。</li><li id="8c6a" class="nk nl in kv b kw nt kz nu lc nv lg nw lk nx lo np nq nr ns bi translated"><strong class="kv io"> useInjection </strong>是一个an hoc，它将被用来获取上下文(因此反转容器)以获取或解析指定为参数的服务(关于<em class="ne">获取</em>和<em class="ne">解析</em>之间的区别，请参见<a class="ae ks" href="https://github.com/inversify/InversifyJS/blob/master/wiki/container_api.md#containerresolveconstructor-newable" rel="noopener ugc nofollow" target="_blank"> InversifyJS </a>)。</li></ul><p id="14c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们必须再次编辑<em class="ne"> index.tsx </em>来用全新的ContainerProvider包装应用程序组件:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="e327" class="my lx in mu b gy mz na l nb nc">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import './index.css';<br/>import <em class="ne">App </em>from './App';<br/>import { DateStringService } from './date-string.service';<br/>import { <em class="ne">ContainerProvider </em>} from './react-binding';<br/>import <em class="ne">reportWebVitals </em>from './reportWebVitals';<br/>import { Container } from 'inversify';<br/><br/>const container = new Container();<br/>container.bind(DateStringService).toConstantValue(new DateStringService('today is'));<br/><br/>ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/><strong class="mu io">    &lt;ContainerProvider container={container}&gt;<br/>      &lt;App /&gt;<br/>    &lt;/ContainerProvider&gt;</strong><br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);<br/><br/>// If you want to start measuring performance in your app, pass a function<br/>// to log results (for example: reportWebVitals(console.log))<br/>// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals<br/><em class="ne">reportWebVitals</em>();</span></pre><p id="398d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，现在在应用程序组件中:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="61ea" class="my lx in mu b gy mz na l nb nc">import React from 'react';<br/><strong class="mu io">import { DateStringService } from './date-string.service';</strong><br/>import logo from './logo.svg';<br/>import './App.css';<br/><strong class="mu io">import { <em class="ne">useInjection </em>} from './react-binding';</strong><br/><br/>function <em class="ne">App</em>() {<br/><strong class="mu io">  // Gets the service.<br/>  const dateStringService = <em class="ne">useInjection</em>(DateStringService);</strong><br/><br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;header className="App-header"&gt;<br/>        &lt;img src={logo} className="App-logo" alt="logo" /&gt;<br/>        &lt;p&gt;<br/>          Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to reload.<br/>        &lt;/p&gt;<br/><strong class="mu io">        &lt;p&gt;<br/>          {dateStringService.getDateString()}<br/>        &lt;/p&gt;</strong><br/>        &lt;a<br/>          className="App-link"<br/>          href="https://reactjs.org"<br/>          target="_blank"<br/>          rel="noopener noreferrer"<br/>        &gt;<br/>          Learn React<br/>        &lt;/a&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default <em class="ne">App</em>;</span></pre><p id="dce7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以通过启动应用程序来检查是否一切都如我们所期望的那样工作，您应该会看到一个新的行，显示从服务获得的字符串。</p><h1 id="5ba4" class="lw lx in bd ly lz nf mb mc md ng mf mg jt nh ju mi jw ni jx mk jz nj ka mm mn bi translated">结论</h1><p id="e7fd" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">我们设置了一个简单的依赖注入，即使我们没有关注InversifyJS特性。无论如何，这个简单的方法允许您在您的反应应用程序中有一个可靠的DI层。通过研究文档，您可以得到一个非常稳定和可扩展的设计来处理InversifyJS容器配置。在我的项目中，我通常为一个模块创建模块和注册服务，以增加代码解耦。也许，在我未来的一个故事中，我将深入探讨这种设置的模块化结构。</p><p id="5639" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">请记住，这种方法不属于Inversify，您可以将其与其他库一起使用，例如typedi。</strong></p></div></div>    
</body>
</html>