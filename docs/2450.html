<html>
<head>
<title>A misconception about Angular life-cycle methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对角度生命周期方法的误解</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-misconception-about-angular-life-cycle-methods-346f1be73d7?source=collection_archive---------1-----------------------#2020-06-25">https://javascript.plainenglish.io/a-misconception-about-angular-life-cycle-methods-346f1be73d7?source=collection_archive---------1-----------------------#2020-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/44225991f6ec6d4b10d0e3e24ce462cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5mT2czKkVVLHsdA1A91lQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@robert2301?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Robert Ruggiero</a> on <a class="ae jd" href="/s/photos/confusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="b2f9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释当一个组件类扩展另一个组件类时，如何调用生命周期方法。</p><p id="ac2a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继承是重用代码的最佳方式之一。通过继承，我们可以将常见的方法、属性转移到一个新的类中，只要扩展它，这个类就可以在任意数量的实例中重用。</p><h1 id="8620" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">角度分量的继承:</h1><p id="49e2" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">组件类只是带有装饰器的类。装饰者提供元数据，Angular使用这些元数据来构建组件实例，并在运行时通过依赖注入将请求的服务注入到构造函数中。那么，我们可以从一个组件类扩展另一个组件类吗？是的，但是有一些问题我们现在要讨论一下。</p><h1 id="0be1" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">角度编译和变化检测过程的一些背景:</h1><p id="8f00" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们后退一步，理解Angular组件是如何编译的，以及如何在运行时调用组件的生命周期方法。</p><p id="ca6e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑这个简单的应用程序。它有一个根组件<code class="fe me mf mg mh b">AppComponent</code>，并在<code class="fe me mf mg mh b">AppModule</code>中配置用于引导进程。<br/>在app组件模板中，我们增加了子组件元素选择器<code class="fe me mf mg mh b">&lt;app-child&gt;&lt;/app-child&gt;</code>。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Example</figcaption></figure><p id="6034" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谈到子组件实现，它有一个模板和一个样式表。这个子组件扩展了另一个组件<code class="fe me mf mg mh b">ParentComponent</code>，和其他组件一样，它有自己的模板和<code class="fe me mf mg mh b">@Component </code>装饰器。如果我们现在运行我们的应用程序，引导过程在<code class="fe me mf mg mh b">main.ts</code>文件中启动，它从创建平台、提供者开始，然后从根组件<code class="fe me mf mg mh b">AppComponent</code>开始实例化组件。由于我们在<code class="fe me mf mg mh b">AppComponent</code>中有了子组件选择器，angular将为<code class="fe me mf mg mh b">ChildComponent</code>创建一个实例，并将其保存在<code class="fe me mf mg mh b">LView</code>中——这是angular组件的内部表示，用于更新DOM、运行变更检测和执行生命周期方法等。</p><p id="56c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们知道Angular没有为<code class="fe me mf mg mh b">ParentComponent</code>创建任何实例，因为这个组件不属于任何组件。所以，现在的问题是Angular在<code class="fe me mf mg mh b">ParentComponent</code>中调用生命周期方法了吗？</p><p id="59bb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答案是<strong class="kf jh">否</strong>。为什么？因为生命周期方法的执行是由Angular处理的，它使用<code class="fe me mf mg mh b">LView</code>来完成。由于父组件不是视图的一部分，该组件中的生命周期方法不会被执行，但是<code class="fe me mf mg mh b">ChildComponent</code>方法会像我们期望的那样作为角度变化检测周期的一部分被执行。</p><p id="6188" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当一个组件扩展另一个组件类时，就像扩展一个没有任何元数据的类一样，这些类上方法的执行与原型继承的工作方式相同。</p><p id="88b5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">继承中的方法执行:</strong></p><ol class=""><li id="a04b" class="mo mp jg kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated"><code class="fe me mf mg mh b">ChildComponent</code>和<code class="fe me mf mg mh b">ParentComponent</code>都有方法<code class="fe me mf mg mh b">ngOnInit</code> <br/>的实现→在这种情况下，<code class="fe me mf mg mh b">Childcomponent </code>上的<code class="fe me mf mg mh b">ngOnInit</code>方法被执行。</li><li id="435b" class="mo mp jg kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">只有<code class="fe me mf mg mh b">ParentComponent</code>实现了<code class="fe me mf mg mh b">ngOnInit<br/></code> →在这种情况下，来自<code class="fe me mf mg mh b">ParentComponent</code>的<code class="fe me mf mg mh b">ngOnInit</code>方法被执行</li><li id="5506" class="mo mp jg kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">只有<code class="fe me mf mg mh b">ChildComponent</code>有<code class="fe me mf mg mh b">ngOnInit<br/></code>的实现→在这种情况下，来自<code class="fe me mf mg mh b">ChildComponent</code>的<code class="fe me mf mg mh b">ngOnInit</code>方法被执行</li></ol><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/7dfcba9f6c0c9fe615225c3ce8e06e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXzXf0NiwMq7xkPgcxHbmg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Logging `this` of child component</figcaption></figure><h1 id="ec3c" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何确保两个组件的生命周期方法都被调用？</h1><p id="f541" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在扩展和扩展组件实现相同方法的情况下，我们可以使用<code class="fe me mf mg mh b">super</code>从扩展组件的方法中调用父组件的方法。这里有一个简单的例子。</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/c1fa1fc21d98f0ebeea37e7c304d441d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uzx_vrB4MW4Qtrq3VyJ5uQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Calling parent’s life-cycle method from child component</figcaption></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="5c8b" class="lb lc jg bd ld le nl lg lh li nm lk ll lm nn lo lp lq no ls lt lu np lw lx ly bi translated">结论:</h1><p id="e588" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Angular不会调用扩展类组件上的生命周期方法。简单地说，从另一个组件类扩展一个组件类与扩展一个普通的JavaScript类完全一样。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="3a58" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这对你有用。感谢阅读！关注我的新文章。</p><h2 id="6f33" class="nq lc jg bd ld nr ns dn lh nt nu dp ll ko nv nw lp ks nx ny lt kw nz oa lx ob bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="013d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae jd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">plain English . io</strong></a>和<a class="ae jd" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">找到它们订阅我们的YouTube频道</strong> </a> <strong class="kf jh">！</strong></p></div></div>    
</body>
</html>