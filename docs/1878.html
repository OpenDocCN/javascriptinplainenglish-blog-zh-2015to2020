<html>
<head>
<title>Rethinking SOLID principles in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新思考JavaScript中的坚实原则</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rethinking-solid-principles-in-javascript-7effdd4dc37d?source=collection_archive---------4-----------------------#2020-05-01">https://javascript.plainenglish.io/rethinking-solid-principles-in-javascript-7effdd4dc37d?source=collection_archive---------4-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7988" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何理解和应用坚实的原则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0e9689114b76186c89b2ff08ffba8ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XEcvVgrzAaia7wif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@nesabymakers?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NESA by Makers</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">固体原理的发明始于80年代末。Robert C. Martin在USENET(一种早期的脸书)上讨论软件设计原则时开始发展这些原则。经过加减运算，罗伯特·c·马丁在21世纪初制定了这些原则。直到2004年才整理出原理，称之为固本原理。这是一个缩写，代表五个具体的设计原则。</p><ul class=""><li id="17a0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">S代表单一责任原则</li><li id="8e5e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> O </strong>代表开启关闭原理</li><li id="2a4e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> L </strong>代表利斯科夫替代原理</li><li id="6b23" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> I </strong>代表界面分离原理</li><li id="69c6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> D </strong>表示依赖倒置原则</li></ul><p id="7d18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">坚实的原则在构建单个模块或更大的架构时都很有用。因此，我们将通过JavaScript中的例子来探究每个原则。</p><h1 id="e87b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">单一责任原则</h1><p id="190f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个原理在汤姆·狄马克和梅里尔·佩奇-琼斯的著作中有所描述。他们称之为凝聚力。他们把内聚定义为一个模块中元素的功能相关性。</p><h2 id="1c70" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">SRP出了什么问题？</h2><p id="8bc9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">事实上，这个原则可能是最不容易理解的，因为有一个特别不恰当的名称。许多开发人员明白每个模块应该只做一件事。毫无疑问，有这样一个原则。但它不是一个坚实的原则，它实际上不是SRP。</p><h2 id="ff49" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">那么，什么是SRP呢？</h2><p id="a78e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">描述如下:“<em class="np">每个软件模块有且只有一个理由改变</em>”。因为，软件系统的改变是为了满足用户需求，满足利益相关者，所以我们可以这样重新表述这个原则:“<em class="np">每个模块应该对一个，并且仅仅是一个，用户或利益相关者</em>”<em class="np">。</em>但是很可能会有不止一个用户或利益相关者希望系统以同样的方式改变，我们称他们为行动者或小组，所以最终的版本是:“<em class="np">每个模块应该对一个，且只能对一个行动者</em>负责”。</p><h2 id="c575" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">我们通过一些例子来了解什么是SRS</h2><p id="e1ad" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">假设我们有一个<code class="fe nq nr ns nt b">Employee</code>对象，它有三个功能:<code class="fe nq nr ns nt b">calculatePay()</code>、<code class="fe nq nr ns nt b">reportHours()</code>和<code class="fe nq nr ns nt b">save()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d0a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，它违反了SRP，因为这三项职能由三个不同的参与者负责。</p><ul class=""><li id="5b89" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">calculatePay()</code>职能由会计部门负责。</li><li id="607f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">reportHours()</code>功能由人力资源部使用。</li><li id="1588" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">save()</code>功能由数据库管理员指定。</li></ul><p id="e9ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，避免这个问题的方法是分离支持不同参与者的代码。</p><ul class=""><li id="042e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">EmployData</code>对象保存一个共享的简单数据结构，它由所有三个角色使用。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="8df0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">PayCalculator</code>对象有<code class="fe nq nr ns nt b">calculatePay()</code>方法。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="2ed7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">HourReporter</code>对象有<code class="fe nq nr ns nt b">reportHours()</code>方法。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="98bd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nq nr ns nt b">EmployeeServer</code>对象有<code class="fe nq nr ns nt b">save()</code>方法。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d295" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们如何使用SRS来重构糟糕的代码。每个功能负责一个特定的参与者。SRP是最简单的原则之一，也是最难实现的原则之一。</p><h1 id="2822" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">开闭原则</h1><p id="7c85" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Bertrand Meyer在20世纪80年代将这一原则公之于众，出现在他的著作《面向对象的软件构造》中。软件系统被设计成允许那些系统的行为通过添加新代码而不是改变现有代码来改变。</p><h2 id="f1b9" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">什么是开闭原则(OCP)？</h2><p id="86eb" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">OCP声明如下:“<em class="np">软件实体(类、模块、函数等)应该对扩展开放，但对修改关闭”</em>Meyer，Bertrand <em class="np">。</em>这个原则建议我们重构系统，这样进一步的改变就不会引起更多的修改。大多数开发人员认为OCP是指导他们设计类和模块的原则。</p><p id="0684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OCP有两个主要属性，它们是。</p><ul class=""><li id="f9f1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">开放扩展—我们能够扩展模块的功能。</li><li id="1f77" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对修改关闭—扩展模块的行为不会导致模块的源代码或二进制代码发生变化。</li></ul><p id="82ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个属性似乎相互矛盾，因为扩展模块行为的正常方式是对该模块的源代码进行更改。</p><h2 id="0484" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">那么，如何实现OCP呢？</h2><p id="82ec" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">假设每个雇员都有一个角色和被授予的特权。但是，如果我们在系统中引入一个新的角色，而不修改现有的东西。所以我们可以像下面的例子一样，让它通过OCP。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9a24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在上面的例子中，我们不必修改现有的代码，而是可以扩展它来添加一个新的角色。OCP是系统架构背后的驱动力之一。目标是使系统易于扩展，而不会受到变化的严重影响。</p><h1 id="c38b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">利斯科夫替代原理</h1><p id="b184" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Barbara Liskov对子类型的著名定义，来自1988年在一次题为《数据抽象和层次结构》的会议主题演讲中。简而言之，这一原则认为，要用可互换的部件构建软件系统，这些部件必须遵守一个允许这些部件相互替换的契约。</p><h2 id="fcab" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">你可以这样理解它</h2><p id="6acd" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个原理的一个经典例子是一个有四条边的矩形。矩形的高度可以是任何值，宽度可以是任何值。正方形是宽度和高度相等的长方形。所以可以说可以把rectangle类的属性扩展到square类。为了做到这一点，您需要将子类(正方形)与父类(矩形)交换，以符合具有四条等边的正方形的定义，但派生类不会影响父类的行为，因此如果您这样做，将违反Liskov替换原则。</p><h2 id="a24e" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">看到哪里出问题了吗？</h2><p id="d3da" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">假设我们有一个应用程序，它使用一个矩形对象，定义如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5b82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于正方形是边长相等的矩形的知识，我们决定创建一个正方形对象来代替矩形。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，当应用程序试图用正方形代替矩形时，就发现了一个问题。原来其中一个方法是这样计算矩形的面积的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="46c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用<code class="fe nq nr ns nt b">square</code>调用该方法时，乘积是16，而不是预期值12。我们的<code class="fe nq nr ns nt b">square</code>对象违反了关于<code class="fe nq nr ns nt b">area</code>函数的利斯科夫替换原则。在这种情况下，长度和宽度属性的存在暗示了我们的正方形可能不会100%与矩形兼容，但我们不会总是有这样明显的暗示。</p><h1 id="689e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">界面分离原理</h1><p id="938a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个原则建议软件设计者避免依赖他们不用的东西。</p><h2 id="2d50" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">举一个简单的例子来理解ISP</h2><p id="6153" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">假设你进入一家餐馆，你是一个纯素食者。那家餐馆的服务员给了你菜单卡，上面有素食、非素食、饮料和糖果。在这种情况下，作为顾客，你应该有一张菜单卡，上面只包括素食，而不是你不吃的任何东西。对于不同类型的顾客，菜单应该是不同的。每个人的公共或通用菜单卡可以分成多个卡片，而不是一个。使用这个原则有助于减少副作用和所需更改的频率。</p><h2 id="37f4" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">如何用JavaScript实现ISP？</h2><p id="768c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">因为我们在JavaScript中默认没有接口。但是我们都可能会遇到这样的情况，我们想在一个类的构造函数上做很多事情。那么，现在如何实现ISP呢？</p><p id="35b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先说一些我们要在构造函数里做的设置。我们所做的设置应该与构造函数中其他不需要的设置分开。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，<code class="fe nq nr ns nt b">validateUser()</code>函数将在<code class="fe nq nr ns nt b">initiateUser()</code>构造函数调用中被调用，尽管它并不总是需要的。我们可以用下面的代码将它引入ISP。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0fdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如上面的代码，我们将不需要的逻辑从<code class="fe nq nr ns nt b">contractor</code>函数中分离出来。</p><h1 id="b69d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">依存倒置原则</h1><p id="68e3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在我们讨论这个主题之前，请记住依赖倒置和依赖注入都是不同的概念。大多数人对此感到困惑，认为两者是一样的。现在关键点在这里，记住这个原则。</p><h2 id="1454" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">不要与依赖注入原则混淆</h2><p id="49a3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">依赖倒置原则(DIP)告诉我们，最灵活的系统是那些源代码依赖仅指抽象而非具体的系统。相反，细节应该取决于政策。</p><h2 id="a610" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">看一个真实的例子</h2><p id="1e02" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">您可以考虑电视遥控器电池的真实例子。您的遥控器需要电池，但这与电池品牌无关。你可以使用任何你想要的XYZ品牌，它会工作。所以我们可以说电视遥控器和品牌名称是松耦合的。依赖反转使你的代码更加可重用。</p><h2 id="88dd" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">如何用JavaScript实现DIP？</h2><p id="0045" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在静态类型语言(如Java)中，这意味着use、import和include语句应该只引用包含接口、抽象类或其他某种抽象声明的源模块。不应该依赖任何具体的东西。对于JavaScript，我们如何实现DIP？</p><p id="a888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个简单的例子来理解我们如何轻松地做到这一点。</p><p id="3dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想联系服务器获取一些数据。如果不使用DIP，可能会如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2ce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用DIP，我可能会编写如下代码</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="a25e" class="nd mh iq nt b gy oa ob l oc od">fillFromServer("/address/to/data", thingyView)</span></pre><p id="755b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们想要使用jQuery的Ajax的特殊情况，抽象函数<code class="fe nq nr ns nt b">fillFromServer</code>可以实现如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象<code class="fe nq nr ns nt b">view</code>可以基于id为<code class="fe nq nr ns nt b">thingy1</code>和<code class="fe nq nr ns nt b">thingy2</code>的元素为视图的特殊情况实现，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，对吧？我希望这能让你对如何在JavaScript中应用坚实的原则有一个基本的了解。</p><h2 id="6732" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="d90a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:<a class="ae kv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ky ir">AI in Plain English</strong></a>，<a class="ae kv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ky ir">UX in Plain English</strong></a>，<a class="ae kv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ky ir">Python in Plain English</strong></a><strong class="ky ir"/>—谢谢，继续学习！</p><p id="b6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">submissions @ plain English . io</strong></a><strong class="ky ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p><h1 id="4a06" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><p id="baf7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">[1]结构化分析和系统规范。汤姆·狄马克，你的儿子。出版社计算系列，1979年。</p><p id="a36e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]结构化系统设计实用指南，第2版。由…编辑梅里尔·佩奇·琼斯。Your-don出版社计算系列，1988年。</p><p id="c783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]面向对象的软件构造。伯特兰·梅尔。普伦蒂斯霍尔，1988年。</p></div></div>    
</body>
</html>