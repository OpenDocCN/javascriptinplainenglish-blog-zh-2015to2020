<html>
<head>
<title>How to Write TypeScript Ambients Types Definition for a JavaScript library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为JavaScript库编写类型脚本环境类型定义</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-write-typescript-types-for-a-javascript-library-e598b9eb8be7?source=collection_archive---------2-----------------------#2020-12-28">https://javascript.plainenglish.io/how-to-write-typescript-types-for-a-javascript-library-e598b9eb8be7?source=collection_archive---------2-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="cbf9" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">提示和技巧</h2><div class=""/><div class=""><h2 id="2ceb" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">任何JavaScript库都可以轻松定义类型。创建、扩展和贡献任何缺少类型的存储库。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c36b23e496d7f37a3b2a9bf0ff2f6e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zTVArwW37I0_lORsucT8A.png"/></div></div></figure><p id="1f9b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在打字稿的早期，这是一个复杂的时期。最初设计用于名称空间和某种“定制模块”，现在最好的方法是使用ES6模块。</p><p id="cffb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如何管理模块和代码隔离将影响我们如何为我们的库编写环境类型定义。</p><p id="dd4f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们来深究一下吧！</p><h1 id="f1f6" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">快速记住编译器的基本知识</h1><p id="eda2" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">在深入到TypeScript类型化的问题之前，我想澄清一些事情，因为对于每个开发人员来说，这似乎并不奇怪。</p><p id="742d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">也许就像我一样，当老师试图教你C语言或某种编译语言时，你正在教室里做别的事情。</p><p id="39b3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们需要理解编译，因为在声明我们的类型定义时，我们需要很好地理解我们正在处理的范围。</p><p id="84fc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我的意思是，当TypeScript“编译”你的代码时，他到底在做什么？或者我应该说:任何编译器真正在做什么？</p><p id="4401" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">大多数时候，默认情况下，如果没有作用域机制，您编写的所有代码都是全局作用域的，即使是在多个文件中定义的:共享变量和函数。</p><p id="a040" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就是为什么在JavaScript早期，我们在浏览器页面全局上下文中使用模块模式。因为人们倾向于使用来自不同地方的多个脚本，这导致了代码冲突。</p><p id="93ed" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这通常以这样一种方式实现，即使用某种“立即调用的函数表达式”来用限定了作用域的API填充一个全局对象。这模仿了作用域的行为。</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="73dc" class="my lx iq mu b gy mz na l nb nc">window.app_modules = window.app_modules || {};</span><span id="e82c" class="my lx iq mu b gy nd na l nb nc">app_modules.MyModule = (function() {<br/>  var privateVariable = 1;<br/><br/>  var publicFunction = function() {<br/>    return privateVariable;<br/>  }</span><span id="73ec" class="my lx iq mu b gy nd na l nb nc">  return {<br/>    publicFunction: publicFunction<br/>   };<br/>})();</span><span id="2ef3" class="my lx iq mu b gy nd na l nb nc">console.log(app_modules.MyModule.publicFunction());</span></pre><p id="80aa" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">嗯，类似这样模仿私有财产的东西。允许使用JavaScript作用域来防止变量在模块间全局使用。</p><h2 id="6077" class="my lx iq bd ly ne nf dn mc ng nh dp mg lj ni nj mi ln nk nl mk lr nm nn mm iw bi translated">编译器的一项工作是将多个文件放入一个文件中，并确保声明之间的正确性。</h2><p id="a591" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">因此，编译器获取一个文件工作空间，将所有文件合并成一个文件，一旦完成，它可能还会将代码转换为一些高度优化的字节码(这与TypeScript的情况不同)。</p><p id="a8ee" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">这是什么意思？</strong></p><p id="69a2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这意味着，如果JavaScript文件的作用域不正确，它会在文件之间共享相同的变量。这不是一件好事，因为它可能会引发某种意想不到的影响。但是对于ES6模块，这是TypeScript的一个兼容特性，有一个特殊性。</p><blockquote class="no np nq"><p id="61e8" class="la lb nr lc b ld le ka lf lg lh kd li ns lk ll lm nt lo lp lq nu ls lt lu lv ij bi translated">只要您导入或导出文件中的内容，您的代码就仅限于该文件。变量声明，函数，任何东西。否则，只需尝试创建两个没有导出的文件，一个创建变量<code class="fe nv nw nx mu b">toto</code>，另一个显示该变量，所有没有导出的内容都在同一个名称空间中，用TypeScript编译它，您会得到两个文件中冲突的<code class="fe nv nw nx mu b">toto</code>的值</p></blockquote><p id="5497" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了解决这些问题，我们可以使用名称空间，它为事物的范围创建了某种边界(它在许多编程语言中工作得很好)，使用我们上面看到的模块模式，或者只是借助EcmaScript模块导出/导入某些东西。</p><p id="44cd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">嗯！让我们深入到我们真正的需求:创建一个类型定义</p><h1 id="0f52" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">获取类型脚本库的良好声明</h1><p id="32bf" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">好了，现在我们有了基本的东西，我们可以使用我们的scope来玩我们的打字游戏了。我们刚刚下载了我们最新的库，但是有一个问题…库的创建者在没有打字稿的情况下完成了所有这些！(是啊2020年还存在)。</p><p id="c715" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">比如一个名为<code class="fe nv nw nx mu b">somelibrary</code>的库，你最终得到的是经典</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="20c3" class="my lx iq mu b gy mz na l nb nc">Could not find a declaration file for module 'somelibrary'. '/Users/screamz/workspace/myapp/node_modules/somelibrary/index.js' implicitly has an 'any' type.<br/>  Try `npm install @types/somelibrary` if it exists or add a new declaration (.d.ts) file containing `declare module 'somelibrary';`ts(7016)</span></pre><p id="9917" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在孤注一掷的尝试中，你可以尝试运行<code class="fe nv nw nx mu b">npm install -D @types/somelibrary</code>，当然，你会在墙上留下这个好消息</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/58d208fb05b5126dc7563a9cd215ffe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CCQG_qXK92uJ00Bj3S5NUw.gif"/></div></div></figure><p id="ef0a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> 404未找到</strong></p><p id="ea7d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">不错！</p><p id="3c66" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">嗯，你现在可能会觉得有点绝望，但不要担心，你的好兄弟在这里！我们很快会解决这个问题。</p><h1 id="84cc" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">为JavaScript库创建自己的TypeScript类型声明</h1><p id="df96" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">严肃的事情开始了，我将向您展示处理这个问题的两种方法。</p><p id="a759" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">第一个也是最笨的一个，用我们在法国Faire l'Autruche中的一个表达来说是完美的，字面意思是把头埋在沙子里。(享受)</p><p id="c9d9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了实现这一点，你只需创建一个名为<code class="fe nv nw nx mu b">X.d.ts</code>的新文件，其中<code class="fe nv nw nx mu b">X</code>是你想要的任何定义文件，这应该在你的类型脚本编译器的范围内(如果你没有在<code class="fe nv nw nx mu b">tsconfig.json)</code>中指定<code class="fe nv nw nx mu b">include</code>属性，这意味着在项目文件夹中)</p><h2 id="fe87" class="my lx iq bd ly ne nf dn mc ng nh dp mg lj ni nj mi ln nk nl mk lr nm nn mm iw bi translated">示例1</h2><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="5323" class="my lx iq mu b gy mz na l nb nc">// ambients.d.ts at project root<br/>declare module "somelibrary"; // Don't use brackets after</span></pre><p id="5eb3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注意引号，这很重要，因为没有引号还有另一种语法，它的意思不一样。对于括号来说，这不是一回事，我们会进一步了解</p><p id="42ae" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好吧！你只是回避了这个问题，没有作任何声明。</p><p id="2ef7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">它的意思是，它告诉编译器，当你将所有这些文件合并成一个文件时，只需将我要写的内容放在<code class="fe nv nw nx mu b">somelibrary</code>上下文中，然后……什么都不做，将任何导出的内容标记为<code class="fe nv nw nx mu b">any</code>类型</p><p id="aff1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然而，当你赶时间的时候，这听起来不错，但实际上并不是最佳的，让我们看看我们能做得更好。</p><h2 id="045a" class="my lx iq bd ly ne nf dn mc ng nh dp mg lj ni nj mi ln nk nl mk lr nm nn mm iw bi translated">示例2</h2><p id="9ed0" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">想象一下，我们的<code class="fe nv nw nx mu b">somelibrary</code>正在导出一个函数，我们用这个函数来玩<code class="fe nv nw nx mu b">import { createFactory } from "somelibrary</code>，它有一个命名的导出，也有一个默认的导出，就像那个<code class="fe nv nw nx mu b">import SomeLibrary from "somelibrary";</code></p><p id="e761" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们有两种情况:</p><ul class=""><li id="6316" class="nz oa iq lc b ld le lg lh lj ob ln oc lr od lv oe of og oh bi translated"><strong class="lc ja">你写代码是为了你自己，只在你自己的库中</strong></li></ul><p id="150b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后将它添加到编译范围内的环境定义文件中</p><pre class="kp kq kr ks gt mt mu mv mw aw mx bi"><span id="0e97" class="my lx iq mu b gy mz na l nb nc">// ambients.d.ts<br/>declare module "somelibrary" {<br/>  export function createFactory(someparam: string): SomeInterface;<br/>  export default createFactory;<br/>  <br/>  interface SomeInterface {<br/>    you: string;<br/>    got_this: number;<br/>    bro: boolean;<br/>  }<br/>}</span></pre><p id="9a81" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">到目前为止，一切顺利。这是因为您告诉Typescript编译器只覆盖名为<code class="fe nv nw nx mu b">somelibrary</code>的库的类型。</p><ul class=""><li id="14b0" class="nz oa iq lc b ld le lg lh lj ob ln oc lr od lv oe of og oh bi translated"><strong class="lc ja">您编写代码是为了在应用程序存储库中发出一个拉请求</strong></li></ul><p id="412f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">几乎是同样的事情，在项目根目录下创建一个types.d.ts文件并声明API，你可以省略<code class="fe nv nw nx mu b">declare module "somelibrary"</code>指令，因为TypeScript会自动确定它的范围。</p><p id="8f8e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后在库的<code class="fe nv nw nx mu b">package.json</code>中应用一个<code class="fe nv nw nx mu b">types</code>键，指向我们刚刚编写的声明文件。</p><p id="d80c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好了，你现在可以提出拉请求了！</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="b3f6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae op" href="https://codingspark.io/?referral=medium" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja"> 🇫🇷为法国人🥖我提议将⚡️编码Spark和abonner合并为一个简讯，以收取相关技术的费用</strong>！</a></p></div></div>    
</body>
</html>