<html>
<head>
<title>Deno: A better beginner’s guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Deno:更好的初学者指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deno-first-approach-5a78c591513e?source=collection_archive---------5-----------------------#2020-09-04">https://javascript.plainenglish.io/deno-first-approach-5a78c591513e?source=collection_archive---------5-----------------------#2020-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Deno的目标是修复什么，它是用什么构建的，后端JavaScript的未来会是什么样子，以及您现在可以在Deno中使用的代码示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4bd9c7884c1c290783828c918751acd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y7o1flJ1oYDV0A0j_3XADQ.gif"/></div></div></figure><p id="3b0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Deno是一个跨平台的运行时，即一个运行时环境，基于<code class="fe ln lo lp lq b"><a class="ae lr" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank">Google's V8</a></code> <a class="ae lr" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank">引擎</a>，用<code class="fe ln lo lp lq b"><a class="ae lr" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank">Rust</a></code> <a class="ae lr" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank">语言</a>开发，用<a class="ae lr" href="https://github.com/tokio-rs/tokio" rel="noopener ugc nofollow" target="_blank">为事件循环系统构建一个库</a>。</p><p id="452f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"># deno # node # typescript # rust</strong></p><h2 id="0634" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">放弃</h2><p id="15d3" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">在开始之前，非常重要的是要记住，在撰写本文时，Deno仍在开发中。因此，由于API中潜在的意外变化，任何产生的代码都必须被认为是不稳定的。因此，我们将使用版本<code class="fe ln lo lp lq b">0.21.0</code>作为下一步的基础。</p><p id="fecc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，还应该注意，Deno并不打算取代Node或与其合并。</p><div class="mq mr gp gr ms mt"><a href="https://medium.com/flutter-community/deno-1-0-released-easy-rest-api-example-e40fef062afa" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">Deno 1.0发布！(简单)REST API示例</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">Deno已经正式发布，1.0.0版本现已上市！如果你不知道什么是Deno，看看这个视频…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh kp mt"/></div></div></a></div><h1 id="a2b2" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">简介和架构</h1><p id="164f" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">Deno是一个跨平台的运行时，即基于<code class="fe ln lo lp lq b"><a class="ae lr" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank">Google's V8</a></code> <a class="ae lr" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank">引擎</a>，用<code class="fe ln lo lp lq b"><a class="ae lr" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank">Rust</a></code> <a class="ae lr" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank">语言</a>开发，用<code class="fe ln lo lp lq b"><a class="ae lr" href="https://github.com/tokio-rs/tokio" rel="noopener ugc nofollow" target="_blank">Tokio</a></code> <a class="ae lr" href="https://github.com/tokio-rs/tokio" rel="noopener ugc nofollow" target="_blank">库</a>为事件循环系统构建的运行时环境。</p><h1 id="23b9" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">节点的问题</h1><p id="8884" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">Deno是由它的创造者，<strong class="kt ir">瑞安·达尔(</strong><a class="ae lr" href="https://dev.to/ry" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">@ ry</strong></a><strong class="kt ir">)</strong>在2018年6月的欧洲JSConf上提出的，距离首次提交仅1个月。</p><p id="c395" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这次演讲中，Dahl揭露了Node架构中的十个缺陷(对此他自责不已)。总而言之:</p><ul class=""><li id="7caf" class="nt nu iq kt b ku kv kx ky la nv le nw li nx lm ny nz oa ob bi translated">Node.js随着回调而发展，牺牲了V8第一版中的Promise API</li><li id="8c90" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">应用程序上下文的安全性</li><li id="043e" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">GYP(<em class="oh">Generate Your Projects</em>)，编译系统强迫用户在<code class="fe ln lo lp lq b">C++</code>中编写他们的绑定(节点和V8之间的链接)，而V8本身不再使用它。</li><li id="c635" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">依赖性管理器NPM本质上链接到节点<code class="fe ln lo lp lq b">require</code>系统。到目前为止，NPM模块都存储在一个单一的中央服务器上，由一家私人公司管理。最后，<code class="fe ln lo lp lq b">package.json</code>文件变得过于关注项目，而不是技术代码本身(许可证、描述、存储库等)。</li><li id="b8d7" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">随着时间的推移，<code class="fe ln lo lp lq b">node_modules</code>文件夹变得过于沉重和复杂，使得模块解析算法变得复杂。最重要的是，上面提到的<code class="fe ln lo lp lq b">node_modules</code>和<code class="fe ln lo lp lq b">require</code>的使用是对浏览器所建立的标准的背离。</li><li id="14f1" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">require</code>语法省略了文件中的<code class="fe ln lo lp lq b">.js</code>扩展名，这和最后一点一样，不同于浏览器标准。此外，在找到请求的模块之前，模块解析算法被迫浏览几个文件夹和文件。</li><li id="b5e6" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">在require能够支持<code class="fe ln lo lp lq b">package.json</code>文件之后，名为<code class="fe ln lo lp lq b">index.js</code>的入口点就变得无用了</li><li id="2979" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">浏览器中没有<code class="fe ln lo lp lq b">window</code>对象，防止了任何同构</li></ul><p id="6ee1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，总的缺点是，随着时间的推移，节点已经将I/O事件饱和系统的优先级降低到有利于模块系统。</p><h1 id="e75b" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">Deno的解决方案:</h1><p id="bf17" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">然后达尔开始在Deno工作，目的是解决节点的大部分问题。为了实现这一点，该技术基于一组规则和范例，允许未来的开发遵循以下指导原则:</p><h2 id="3662" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">本机类型脚本支持</h2><ul class=""><li id="bacf" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">创造者的最高目标之一，他对语言有着特殊的兴趣。这些年来，我们已经看到Node在维护对新的<code class="fe ln lo lp lq b">V8</code>和<code class="fe ln lo lp lq b">ECMAScript</code>特性的支持时，不需要破坏现有的API。</li><li id="d5d1" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">Deno已经结束了，它使您能够立即使用TypeScript，而无需对应用程序进行初始配置。使用仅限于默认编译器的本机配置。然而，可以使用标志<code class="fe ln lo lp lq b">--config=&lt;file&gt;</code>给编译器一个tsconfig.json文件。</li></ul><h2 id="8346" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">通过支持<code class="fe ln lo lp lq b">ECMAScript</code>模块语法和取消<code class="fe ln lo lp lq b">require()</code>功能，与网络同构</h2><ul class=""><li id="51a3" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">如上所述，节点遭受无效的依赖性解析；Deno通过在遵守标准的同时更加明确、简单和直接来解决这个问题。</li><li id="fdd8" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">(import * as log from "https://deno.land/std/log/mod.ts";)</code></li></ul><h2 id="0886" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">远程代码被检索并缓存在本地</h2><ul class=""><li id="eaa3" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">像<code class="fe ln lo lp lq b">node_modules</code>一样，正常工作项目所必需的依赖项被下载并在本地检索。但是，它们不会存储在项目级别，而是存储在Deno的全局缓存文件夹中。(<code class="fe ln lo lp lq b">~/.deno/src</code>默认)</li><li id="0ca2" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">无论有多少本地项目需要，都不需要重新下载相同版本的依赖项。注意这个功能类似于<code class="fe ln lo lp lq b">yarn plug'n'play</code>。</li></ul><h2 id="7d72" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">最终用户必须明确给出特定的权限</h2><ul class=""><li id="8947" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">如今，安全性是每个应用程序的基础。为此，Deno以沙盒模式包含可执行文件，在这种模式下，执行上下文之外的每个操作都必须得到授权。例如，网络访问必须由用户在CLI中明确表示“是”或使用<code class="fe ln lo lp lq b">--allow-net</code>标志来授予。</li><li id="9789" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated">Deno再次希望向网络范例靠拢。(例如，通过网站访问网络摄像头)</li></ul><h2 id="cf7a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">一个可交付，一个可执行</h2><ul class=""><li id="e23e" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">为了确保高效配送，Deno提供了自己的捆扎机(<code class="fe ln lo lp lq b">deno bundle</code>)来生产单一耗材(。js)在交付时和之后，一个单独的可执行二进制文件(<code class="fe ln lo lp lq b">deno compile</code>)。</li></ul><h2 id="2589" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">最后但同样重要的是…</h2><ul class=""><li id="4f8f" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">Deno还致力于在出现未处理的错误时总是终止程序；生成与当前浏览器兼容的JavaScript代码；以支持应用程序最高层的承诺(<code class="fe ln lo lp lq b">top-level await</code>，受V8支持，在TypeScript端等待)；能够以高效的速度(如果不比Node更快的话)通过HTTP提供服务。</li></ul><h1 id="7912" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">Deno(根本)不针对的是:</h1><h2 id="c446" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">使用类似于<code class="fe ln lo lp lq b">package.json</code>的清单</h2><ul class=""><li id="fdc3" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">检索依赖项本身的代码不需要依赖项管理清单。</li></ul><h2 id="aa52" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">像<code class="fe ln lo lp lq b">npm</code>这样的包管理器的使用</h2><ul class=""><li id="4352" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">出于同样的原因，<code class="fe ln lo lp lq b">npm</code>(或等同物)对于Deno应用程序的开发不是也不应该是必不可少的。</li></ul><h2 id="a4b6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">符号/节点同构</h2><ul class=""><li id="898e" class="nt nu iq kt b ku ml kx mm la oi le oj li ok lm ny nz oa ob bi translated">即使这两种技术使用相同的语言，设计也不相同，因此不允许同构代码。</li></ul><h1 id="3bf2" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">建筑模型</h1><h2 id="0633" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">锈</h2><p id="3400" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">Rust是用来封装V8引擎的语言。正是他通过可以在JavaScript中使用的API来公开隔离的功能。这个链接，或者说<strong class="kt ir">绑定</strong>，被称为<code class="fe ln lo lp lq b">libdeno</code>，是按原样交付的，独立于Deno基础设施的其余部分，这要感谢一个被称为<code class="fe ln lo lp lq b">deno-core</code>的Rust模块(一个<strong class="kt ir">机箱</strong>；<a class="ae lr" href="https://crates.io/crates/deno" rel="noopener ugc nofollow" target="_blank">https://crates.io/crates/deno</a>由命令行deno-cli消耗。<br/>如果你愿意，这个板条箱可以用在你自己的Rust app里。</p><p id="e803" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">deno-cli</code>是crate核心、TypeScript编译器(最终代码的热编译和缓存)和Tokyo(事件循环库)之间的链接。</p><p id="e233" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总而言之，下面是执行过程的示意图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/6476182eb6900bbb3e80c3d677cfc3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N5OWN_rG77YIgZfO.png"/></div></div></figure><h2 id="798a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">时男</h2><p id="4055" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">这个用Rust编写的库赋予了该语言异步编程和面向事件编程的能力。</p><p id="97ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本来，Rust不支持事件循环管理，直到2014年，它一直使用<code class="fe ln lo lp lq b">libuv</code>库来异步和跨平台地执行其I/O操作，从而弥补了这一缺陷。</p><p id="e696" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的是，Node今天在其V8进程中仍然使用libuv。</p><p id="373b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，Tokio成为Rust中所有异步事件驱动编程的参考库。</p><p id="12d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从Deno的角度来看，Tokio因此负责并行化由<code class="fe ln lo lp lq b">deno-core</code>隔离中暴露的V8绑定执行的所有异步I/O(提醒一下，<code class="fe ln lo lp lq b">deno-core</code>是独立的Rust crate)</p><h2 id="c071" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">V8</h2><p id="b5d8" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">最后，正如前面几次提到的，整个架构是基于JavaScript解释引擎的。它会定期更新，以满足最新版本的TypeScript等的需求。撰写本文时，Deno使用的版本是2019年10月14日起的版本<code class="fe ln lo lp lq b">7.9.304</code>。</p><h1 id="437c" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">生态系统和首次开发</h1><h2 id="eb4a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">装置</h2><p id="37a1" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">对于现在的几个版本，Deno可以通过Scoop for Windows和通过Homebrew for OSX获得。</p><p id="8418" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装也可以通过Shell下的<code class="fe ln lo lp lq b">cURL</code>手动完成，特别是对于目前只有这个解决方案的Linux，或者通过PowerShell下的<code class="fe ln lo lp lq b">iwr</code>for Windows。</p><p id="6914" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照与代码相同的理念，Deno是作为一个单独的可执行文件交付的。</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="bf2f" class="ls lt iq lq b gy oq or l os ot"># Shell<br/>curl -fsSL https://deno.land/x/install/install.sh | sh</span><span id="845c" class="ls lt iq lq b gy ou or l os ot"># PowerShell<br/>iwr https://deno.land/x/install/install.ps1 -useb | iex</span><span id="8c2f" class="ls lt iq lq b gy ou or l os ot"># Scoop<br/>scoop install deno</span><span id="9af2" class="ls lt iq lq b gy ou or l os ot"># Homebrew<br/>brew install deno</span></pre><p id="ec59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装完成后，启动命令<code class="fe ln lo lp lq b">deno https://deno.land/welcome.ts</code>测试其功能是否正常。</p><h2 id="af4c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">deno-cli</h2><p id="07e3" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">命令行界面提供了一组集成的特性，允许您沉浸在Deno专有的开发环境中。最重要的是，当你需要向社区提供你的图书馆时，它也允许你保持符合标准。</p><p id="16f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是当前可用的命令列表:</p><ul class=""><li id="2494" class="nt nu iq kt b ku kv kx ky la nv le nw li nx lm ny nz oa ob bi translated">允许从程序的入口点检查程序的依赖性</li><li id="c520" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno fmt</code>允许用集成的<code class="fe ln lo lp lq b">Prettier</code>格式化代码</li><li id="c4aa" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno bundle</code>如前所述，允许将我们的应用程序转换成一个具有依赖关系的可交付文件，一个<code class="fe ln lo lp lq b">.js</code>文件(可供浏览器使用)</li><li id="2fcd" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno install</code>允许从URL或本地代码在主文件夹(<code class="fe ln lo lp lq b">~/.deno/bin</code>默认)中安装Deno应用程序</li><li id="27b5" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno types</code>允许生成Deno的types脚本类型进行开发</li><li id="684d" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno test</code>允许执行集成测试工具。(Deno集成了自己的测试库)</li><li id="227b" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno completions</code>允许在终端中添加自动完成功能(通常在Deno安装过程中已经添加)</li><li id="f004" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno eval</code>允许解释包含可由Deno执行的代码的文件或字符串</li><li id="cbd7" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno xeval</code>(根据与<code class="fe ln lo lp lq b">xargs</code>相同的想法命名)允许<code class="fe ln lo lp lq b">deno eval</code>运行代码，但是通过获取来自<code class="fe ln lo lp lq b">stdin</code>的每一行</li></ul><h2 id="3055" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">" HelloWorld.ts "</h2><p id="d4a5" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">现在我们来谈谈我们的第一个节目。目前，即使Deno生态系统本身提供了一系列可以在命令行上使用的开发工具，VSCode扩展目录(或其他编辑器)在功能上仍然非常贫乏。</p><p id="b6f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要期望在你的第一行代码中有完整的开发者体验。</p><h1 id="6388" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">示例1: Grep</h1><p id="e594" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">第一个例子简单再现了grep的行为，突出了Deno标准库的导入、它们的用法以及文件和参数的操作。</p><p id="310e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了对它们进行分组，可以在一个通常称为<code class="fe ln lo lp lq b">deps.ts</code>的文件中声明依赖关系:</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="8443" class="ls lt iq lq b gy oq or l os ot">import * as path from "https://deno.land/std/fs/path/mod.ts";<br/>export { path };<br/>export { green, red, bold } from "https://deno.land/std/colors/mod.ts";</span></pre><p id="2842" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后经典导入到它的<code class="fe ln lo lp lq b">mod.ts</code>(相当于节点中的<code class="fe ln lo lp lq b">index.js</code>):</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="034d" class="ls lt iq lq b gy oq or l os ot">import { path, green, red, bold } from "./deps.ts";</span></pre><p id="cd12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从Deno的“<em class="oh"> http </em>”导入是在编译时对web资源的检索。Deno目前只支持<code class="fe ln lo lp lq b">http://</code>、<code class="fe ln lo lp lq b">https://</code>和<code class="fe ln lo lp lq b">file://</code>协议。</p><p id="bf1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们验证直接从<code class="fe ln lo lp lq b">Deno</code>全局对象传递和检索的参数:</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="dada" class="ls lt iq lq b gy oq or l os ot">if (Deno.args.length != 3) {<br/>  if (Deno.args.length &gt; 3) {<br/>    throw new Error("grep: to much args.");<br/>  } else {<br/>    throw new Error("grep: missing args.");<br/>  }<br/>}</span><span id="3d5d" class="ls lt iq lq b gy ou or l os ot">const [, text, filePath] = Deno.args;</span></pre><p id="9c73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们解析并迭代该文件，以显示包含您正在寻找的模式的行:</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="831f" class="ls lt iq lq b gy oq or l os ot">try {<br/>  const content = await Deno.readFile(path.resolve(Deno.cwd(), filePath));</span><span id="feb6" class="ls lt iq lq b gy ou or l os ot">  let lineNumber = 1;<br/>  for (const line of new TextDecoder().decode(content).split("\n")) {<br/>    if (line.includes(text)) {<br/>      console.log(<br/>        `${green(`(${lineNumber})`)} ${line.replace(text, red(bold(text)))}`<br/>      );<br/>    }<br/>    lineNumber++;<br/>  }<br/>} catch (error) {<br/>  console.error(`grep: error during process.\n${error}`);<br/>}</span></pre><p id="10eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，要启动应用程序，请执行命令<code class="fe ln lo lp lq b">deno grep/mod.ts foo grep/test.txt</code></p><p id="1130" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">foo</code>是模式，<code class="fe ln lo lp lq b">test.txt</code>是包含字符串的文件。</p><h1 id="55f0" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">示例2:过度猜测数字</h1><p id="ea27" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">第二个例子是一个小游戏，目标是从“多”或“少”的线索中找出一个0到10之间的数字。它强调了第三方框架的使用、React的导入和JSX兼容性。</p><p id="0797" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第三方的导入几乎等同于标准的导入:</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="e22e" class="ls lt iq lq b gy oq or l os ot">import Home from "./page.tsx";<br/>import {<br/>  Application,<br/>  Router,<br/>  RouterContext<br/>} from "https://deno.land/x/oak/mod.ts";<br/>import { App, GuessSafeEnum, generate, log } from "./misc.ts";</span></pre><p id="6ee8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个<code class="fe ln lo lp lq b">.tsx</code>文件被导入，必须使用React才能运行整个东西。<code class="fe ln lo lp lq b">page.tsx</code>文件完成如下:</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="7f6a" class="ls lt iq lq b gy oq or l os ot">import React from "https://dev.jspm.io/react";<br/>import ReactDOMServer from "https://dev.jspm.io/react-dom/server";</span></pre><p id="6751" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢<code class="fe ln lo lp lq b">.tsx</code>扩展和React，我们可以使用JSX导出一个在服务器端呈现的组件，例如:</p><pre class="kg kh ki kj gt om lq on oo aw op bi"><span id="a142" class="ls lt iq lq b gy oq or l os ot">export default (props: HomeProps = {}) =&gt; `&lt;!DOCTYPE html&gt;<br/>  ${ReactDOMServer.renderToString((<br/>  &lt;&gt;<br/>    &lt;Home {...props} /&gt;<br/>    &lt;hr /&gt;<br/>    &lt;Debug {...props} /&gt;<br/>  &lt;/&gt;<br/>))}`;</span></pre><p id="6f4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以用命令<code class="fe ln lo lp lq b">deno guessanumber/mod.ts</code>运行这个例子</p><p id="2e4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，你可以在Github上找到完整的例子，甚至直接从它们的<em class="oh">" raw . githubusercontent "</em>URL运行它们。</p><p id="0229" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(<a class="ae lr" href="https://github.com/bios21/deno-intro-programmez" rel="noopener ugc nofollow" target="_blank">https://github.com/bios21/deno-intro-programmez</a>)</p><h1 id="93e4" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">生产和未来</h1><p id="db14" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">现在，Deno还没有准备好生产。主要用途是创建命令行工具、后台任务管理器或web服务器(如Node)，Deno的性能没有达到Dahl希望的水平。</p><p id="6382" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，可以开始尝试开发内部工具，比如批处理脚本。</p><p id="cb16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae lr" href="https://deno.land/benchmarks.html" rel="noopener ugc nofollow" target="_blank">https://deno.land/benchmarks.html</a>上有一个实时基准</p><p id="9655" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一次又一次地提交，基准更新，并在几个级别上将Deno的性能与Node的性能进行比较，例如每秒请求数(这是阻碍生产使用的第一个瓶颈)、最大延迟、输入输出交互、内存消耗等。</p><p id="c3be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Deno在一些方面已经比Node更好，并随着时间的推移不断改进，希望在所有测试中获得第一名。</p><h2 id="9113" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">1.0版</h2><p id="d60c" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">除了性能之外，Deno还为1.0版本的发布提供了一系列基本功能和工具，可以说是准备好投入生产使用了。</p><h2 id="0c8e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">调试</h2><p id="0617" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">当前无法调试或检查应用程序；在开发过程中可能会受到限制的东西。这个主要特性对于1.0版是必需的。</p><p id="a412" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">利用<code class="fe ln lo lp lq b">V8</code>，调试将依赖于<code class="fe ln lo lp lq b">V8InspectorClient</code>和<em class="oh"> Chrome Devtools </em>，允许使用与任何其他JavaScript开发相同的工具。</p><h2 id="7da8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">API稳定性</h2><p id="17c6" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">无论是在TypeScript层还是在<code class="fe ln lo lp lq b">deno-core</code>中，API中仍然存在一些bug。这些bug虽然小，但还是阻碍了整体的良好稳定性。</p><p id="0d40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">稳定不仅仅意味着平稳的执行，还意味着具有一致和统一的入口点。因此，必须从名称甚至签名的角度对一些函数进行审查。</p><h2 id="cf4c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">清晰明确的文件</h2><p id="4f22" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">任何在后台开始的项目都有一个共同的问题Deno文档仍然很少，缺乏用例或对特定主题的解释。</p><p id="f114" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">官网目前正在重新设计，很快就会完成。</p><h2 id="7ca2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">将来的</h2><p id="e3b3" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">与第一个稳定版本分离，将对CLI进行添加，将提供对添加本机功能的支持(通过Rust中称为<em class="oh"> "ops" </em> crates的模块)，以及与Web世界和<strong class="kt ir"> ECMA标准</strong>更紧密的兼容性(例如，通过支持<em class="oh"> WebAssembly模块</em>)。</p><p id="a97f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于CLI，以下是计划功能的非详尽列表:</p><ul class=""><li id="039d" class="nt nu iq kt b ku kv kx ky la nv le nw li nx lm ny nz oa ob bi translated">允许将其整个应用程序编译成一个完全独立的二进制文件。</li><li id="a4c2" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno doc</code>允许生成一个JSON结构的完整代码文档。这个JSON将成为Deno的标准，然后可以被包含该标准的可视化文档工具使用。</li><li id="c63f" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno ast</code>允许从给定的入口点生成代码的<em class="oh">抽象语法树(AST) </em>的JSON结构。AST可以被像<code class="fe ln lo lp lq b">ESLint</code>这样的工具用来有计划地分析代码结构，并识别潜在的代码缺陷或内存泄漏。</li><li id="c9ae" class="nt nu iq kt b ku oc kx od la oe le of li og lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">deno lint</code>与<code class="fe ln lo lp lq b">deno fmt</code>相结合，可以使所有开发人员产生的代码保持一致，并通过确保代码符合Deno标准来提高质量。请注意，目前不能访问或修改linter配置。</li></ul><p id="9c57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1.0版本已经很接近了，快速的开发速度使得团队可以估计在今年年底或明年一月初发布。</p><p id="1c61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重要的是要记住，Deno仍然是一个开源的社区项目，社区有责任通过试验该技术，将其推向极限，并向开发人员提供尽可能多的数据来提供帮助。</p><div class="mq mr gp gr ms mt"><a href="https://medium.com/@tejmaddimsetty/deno-node-js-killer-introduction-demo-d8869f6e6a34" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">Deno: Node.js黑仔？介绍和演示</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">辞旧迎新！Deno会取代Node吗？？让我想想。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="ov l ne nf ng nc nh kp mt"/></div></div></a></div><h2 id="c831" class="ls lt iq bd lu lv lw dn lx ly lz dp ma la mb mc md le me mf mg li mh mi mj mk bi translated">社区和贡献</h2><p id="a2f9" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">由于其相对年轻的年龄，德诺社区仍然很小。然而，它每天都在增长，许多来自Rust或Node的开发人员对这项技术越来越感兴趣。</p><p id="ee0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Deno需要你，请随意提交你的内容；提供的许多库都是Node、Rust甚至Go中现有库的移植。</p><p id="311a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总之，Deno仍处于早期阶段，但Ryan Dahl并不是第一次尝试。</p><p id="cd2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于1.0版本的新功能，TypeScript的可用性，越来越有趣的性能，最后但同样重要的是，由于自信和不断增长的社区，Deno无疑将成为2020/2021年利用的潜在趋势技术之一。</p><p id="aa95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">敬请期待！</p><p id="95e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您阅读这篇文章。随时欢迎反馈。</p></div><div class="ab cl ow ox hu oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ij ik il im in"><p id="a0f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在<a class="ae lr" href="https://github.com/tejamaddimsetty" rel="noopener ugc nofollow" target="_blank">Github</a>&amp;<a class="ae lr" href="http://www.linkedin.com/in/tejmaddimsetty" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>上联系我</p></div></div>    
</body>
</html>