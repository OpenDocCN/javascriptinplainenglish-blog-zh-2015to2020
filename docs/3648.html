<html>
<head>
<title>Angular Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有角度的小抄</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-cheat-sheet-cddd2f295b2c?source=collection_archive---------0-----------------------#2020-10-15">https://javascript.plainenglish.io/angular-cheat-sheet-cddd2f295b2c?source=collection_archive---------0-----------------------#2020-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/efa87d88cf2c154820aadd41c465d7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*OfFT0feKghOFfv_bT8_FMQ.jpeg"/></div></div></figure><p id="c707" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular 是一个基于打字稿的开源web应用框架，用于构建基于web和移动的应用。在本文中，我们将通过解释它的一些核心API来介绍一些angular特性。你可以按照这个角度备忘单来构建你的项目。我们试图在这里涵盖角度CLI、角度生命周期挂钩、角度路由等等。</p><h1 id="a7ae" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">角度CLI</h1><p id="cb73" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Angular让我们能够使用他们的CLI做很多事情。您可以只使用CLI配置整个应用程序。以下是一些命令:</p><ul class=""><li id="ddc7" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">这个命令将使用npm把Angular CLI安装到我们的本地机器上。</li><li id="e4ae" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng new &lt;application name&gt;</code>:这将使用<code class="fe mg mh mi mj b">ng new</code>命令设置一个新的角度应用。</li><li id="2b62" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng new &lt;application name&gt; --prefix best</code>:这将创建一个新项目，并将项目前缀设置为new。</li><li id="a317" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng new --help</code>:返回所有可用的角度命令列表。</li><li id="5f60" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng lint my-app</code>:这个命令检查我们的整个应用程序是否有林挺警告。</li><li id="2b9e" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated">如果有任何形式的林挺错误，这个命令将修复它。</li><li id="285b" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated">这格式化了我们的整个代码库。</li><li id="ce63" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng lint my-app --help</code>:该命令返回所有可用的林挺命令列表。</li><li id="134a" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng add &lt;package name&gt;</code>:这个命令将使用你的包管理器来下载新的依赖项，并用配置变更来更新项目。</li><li id="8003" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng generate component &lt;name&gt;</code>:这将在我们的应用程序上创建一个新的组件。我们也可以使用<code class="fe mg mh mi mj b">ng g c &lt;name&gt;</code>简写来做到这一点。</li><li id="6b9b" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng g d &lt;directive name&gt;</code>:该命令角度指令。</li><li id="09ff" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng g s &lt;service name&gt;</code>:创建新的基于Javascript类的服务。</li><li id="d02e" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng g p &lt;pipe name&gt;</code>:生成新管道</li><li id="0a72" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng g cl &lt;destination&gt;</code>:这将在指定目录下创建一个新类。</li><li id="a5d2" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng build</code>:构建用于生产的应用程序，并将其存储在<code class="fe mg mh mi mj b">dist</code>目录中。</li><li id="f86f" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng serve -o</code>:通过使用任何端口4200或任何可用端口在浏览器中打开应用程序来服务应用程序。</li><li id="6446" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ng serve -ssl</code>:使用ssl服务应用程序</li></ul><h1 id="2aee" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">有角度的生命周期挂钩</h1><p id="9d04" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Angular中的一个组件有一个生命周期，它经历了从出生到死亡的许多不同阶段。我们可以挂钩到这些不同的阶段，以获得对我们的应用程序的一些非常细粒度的控制。这里你可以看到一些有角度的生命周期钩子。</p><ul class=""><li id="97a7" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngOnChanges</code>:每当其中一个输入属性改变时调用。</li><li id="2744" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngOnInit</code>:在<code class="fe mg mh mi mj b">ngOnChanges</code>完成后立即调用，调用一次。</li><li id="7881" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngOnDestroy</code>:angular销毁指令或组件前调用</li><li id="616b" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngDoCheck</code>:每当运行变更检测时，就会调用这个函数。</li><li id="0d27" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngAfterContentInit</code>:在 Angular执行任何内容投影到组件视图后调用<em class="mp">。</em></li><li id="ef35" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngAfterContentChecked</code>:每次Angular的变化检测机制检查给定组件的内容时，都会调用这个函数。</li><li id="226e" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngAfterViewInit</code>当组件的视图被完全初始化时，这个函数被调用。</li><li id="c9fe" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">ngAfterViewChecked</code>:角度变化检测机制每次检查给定组件的视图时调用。</li></ul><h1 id="a14c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何使用角钩</h1><p id="8fed" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">永远记住钩子在一个组件或目录中工作，所以在我们的组件中使用它们，我们可以这样做:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="21a9" class="my kv in mj b gy mz na l nb nc">`class ComponentName {<br/>    @Input('data') data: Data;<br/>    constructor() {<br/>        console.log(`new - data is ${this.data}`);<br/>    }<br/>    ngOnChanges() {<br/>        console.log(`ngOnChanges - data is ${this.data}`);<br/>    }<br/>    ngOnInit() {<br/>        console.log(`ngOnInit  - data is ${this.data}`);<br/>    }<br/>    ngDoCheck() {<br/>        console.log("ngDoCheck")<br/>    }<br/>    ngAfterContentInit() {<br/>        console.log("ngAfterContentInit");<br/>    }<br/>    ngAfterContentChecked() {<br/>        console.log("ngAfterContentChecked");<br/>    }<br/>    ngAfterViewInit() {<br/>        console.log("ngAfterViewInit");<br/>    }<br/>    ngAfterViewChecked() {<br/>        console.log("ngAfterViewChecked");<br/>    }<br/>    ngOnDestroy() {<br/>        console.log("ngOnDestroy");<br/>    }<br/>}</span></pre><h1 id="432c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">组件DOM</h1><p id="99ce" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Angular自带DOM特性，可以从数据绑定和动态样式定义方面做很多事情。让我们来看看一些特性:<br/>在我们深入研究这些特性之前，一个简单的component.ts文件是这样的:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="aa0e" class="my kv in mj b gy mz na l nb nc">import { Component } from '@angular/core';<br/>@Component({<br/>    // component attributes<br/>    selector: 'app-root',<br/>    templateUrl: './app.component.html',<br/>    styleUrls: ['./app.component.less']<br/>})<br/>export class AppComponent {<br/>    name: 'Sunil';<br/>}</span></pre><h1 id="5758" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">让我们来看看一些模板语法:</h1><ul class=""><li id="f765" class="lx ly in jx b jy ls kc lt kg nd kk ne ko nf ks mc md me mf bi translated"><code class="fe mg mh mi mj b">Interpolation</code>:使用<code class="fe mg mh mi mj b">{{data to be displayed}}</code>将显示ts文件的动态内容。</li><li id="40a4" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">&lt;button (click)="callMethod()" ... /&gt;</code>:向按钮添加点击事件，调用ts文件中定义的方法</li><li id="1716" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">&lt;button *ngIf="loading" ... /&gt;</code>:向to元素添加条件。条件句必须听真值或假值。</li><li id="cde1" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">*ngFor="let item of items"</code>:遍历已定义的项目列表。把这想象成一个for循环。</li><li id="95d6" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">&lt;div [ngClass]="{green: isTrue(), bold: itTrue()}"/&gt;</code>:基于条件增加动态类。</li><li id="c875" class="lx ly in jx b jy mk kc ml kg mm kk mn ko mo ks mc md me mf bi translated"><code class="fe mg mh mi mj b">&lt;div [ngStyle]="{'color': isTrue() ? '#bbb' : '#ccc'}"/&gt;</code>:根据条件向模板添加动态样式</li></ul><h1 id="60bd" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">组件通信</h1><p id="3dd5" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">从一个组件向另一个组件传递数据在Angular。您可以在子组件和父组件之间、父组件和父组件之间传递数据:</p><ul class=""><li id="4d2b" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><code class="fe mg mh mi mj b">input()</code>:此方法有助于将值传递给子组件。</li></ul><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="7ce0" class="my kv in mj b gy mz na l nb nc">export class SampleComponent {<br/>@Input() value: 'Some Data should go in here';<br/>}</span></pre><p id="64ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">子组件在父组件中注册，如下所示:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="b5fd" class="my kv in mj b gy mz na l nb nc">&lt;child-component [value]="data"&gt;&lt;/child-component&gt;</span></pre><ul class=""><li id="7c97" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><code class="fe mg mh mi mj b">output()</code>:该方法向父组件发出事件。一组数据可以传递到发出的事件中，这使它成为从子节点向父节点传递数据的媒介:</li></ul><p id="1d94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要从子组件发出事件:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="b4dc" class="my kv in mj b gy mz na l nb nc">@Output() myEvent: EventEmitter &lt; MyModel &gt; = new EventEmitter();<br/>calledEvt(item: MyModel) {<br/>    this.myEvent.emit(item);<br/>}</span></pre><p id="6f68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后父组件监听该事件:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="3b5f" class="my kv in mj b gy mz na l nb nc">&lt;parent-component <br/>(myEvent)="callMethod()"&gt;&lt;/parent-component&gt;</span></pre><h1 id="3bb2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">角度路由</h1><p id="6cb4" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">路由是Angular的另一个很酷的功能，通过Angular路由系统，我们可以浏览页面，甚至添加路由保护。</p><ul class=""><li id="1514" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">组件路由:通过定义路径和要呈现的组件，我们可以在应用程序中定义路由:</li></ul><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="a52c" class="my kv in mj b gy mz na l nb nc">const routes: Routes = [ <br/>  { path: 'home', component:HomeComponent }, <br/>  { path: 'blog/:id', component: BlogPostCompoent }, <br/>  { path: '**', component: PageNotFoundComponent } <br/>];</span></pre><p id="e96b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使路由工作，将这个文件添加到您的<code class="fe mg mh mi mj b">app.module.ts</code>文件中:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="4697" class="my kv in mj b gy mz na l nb nc">RouterModule.forRoot(routes)</span></pre><p id="9f2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在某些情况下，您希望跟踪路径中发生的情况，您可以添加此功能以在角度项目中启用跟踪:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="20aa" class="my kv in mj b gy mz na l nb nc">RouterModule.forRoot(routes,{enableTracing:true})</span></pre><p id="ea81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在Angular中浏览页面，我们可以使用<code class="fe mg mh mi mj b">routerLink</code>属性，该属性接受我们要路由到的组件的名称:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="571e" class="my kv in mj b gy mz na l nb nc">&lt;a routerLink="/home" routerLinkActive="active"&gt; Crisis Center&lt;/a&gt;</span></pre><p id="4726" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mg mh mi mj b">routerLinkActive="active"</code>将在激活时向链接添加一个激活类。</p><h1 id="fe41" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">书写路线保护</h1><p id="ce72" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们可以为路由认证定义保护。我们可以使用<code class="fe mg mh mi mj b">CanActivate</code>类来做到这一点:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="f9dd" class="my kv in mj b gy mz na l nb nc">class AlwaysAuthGuard implements CanActivate {        <br/>        canActivate() {<br/>                return true;<br/>        }<br/>}</span></pre><p id="c7c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了在我们的路线中使用这种机械防护，我们可以在这里定义它:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="b47f" class="my kv in mj b gy mz na l nb nc">const routes: Routes = [<br/>  { path: 'home', component:HomeComponent },<br/>  { path: 'blog/:id', component: BlogPostCompoent,canActivate: [AlwaysAuthGuard],  },<br/>    { path: '**', component: PageNotFoundComponent }<br/>];</span></pre><h1 id="0445" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">角度服务</h1><p id="5b97" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当您可以处理http请求和在应用程序上播种数据时，Angular services就派上了用场。他们专注于呈现数据，并将数据访问委托给服务。</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="263a" class="my kv in mj b gy mz na l nb nc">@Injectable()<br/>export class MyService {<br/>    public users: Users[];<br/>    constructor() { }<br/>    getAllUsers() {<br/>        // some implementation<br/>    }<br/>}</span></pre><p id="fc40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在组件中使用此服务，请使用import语句导入它，然后在构造函数中注册它</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="82b7" class="my kv in mj b gy mz na l nb nc">import MyService from '&lt;path&gt;'<br/>constructor(private UserService: MyService)</span></pre><p id="c64e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了使事情变得简单，我们可以使用这个命令在Angular中生成一个服务</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="aa59" class="my kv in mj b gy mz na l nb nc">ng g s &lt;service name&gt;</span></pre><h1 id="29f4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Http服务</h1><p id="3bba" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Angular自带http服务，用于发出http请求。要使用它，您必须首先将它导入到您的根模块中:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="9cac" class="my kv in mj b gy mz na l nb nc">import { HttpClientModule} from "@angular/common/http";</span></pre><p id="29e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导入之后，我们现在可以在我们的服务中使用它来发出http请求:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="4a15" class="my kv in mj b gy mz na l nb nc">import { Injectable } from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/>@Injectable({<br/>    providedIn: 'root'<br/>})<br/>export class UserService {<br/>    constructor(private http: HttpClient) { }<br/>    getAllUsers() {<br/>        return this.http.get(`${baseURL}admin/list-users`);<br/>    }<br/>}</span></pre><h1 id="fc9f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Http拦截器</h1><p id="91e3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">一个<strong class="jx io">拦截器</strong>是一段代码，它被你的应用程序收到的每一个<strong class="jx io"> HTTP </strong>请求激活。把拦截器想象成nodejs中的中间件，http请求通过这段代码传递。</p><p id="c669" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要定义一个拦截器，在src目录中创建一个<code class="fe mg mh mi mj b">http-interceptor.ts</code>文件，并添加如下内容:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="f38b" class="my kv in mj b gy mz na l nb nc">import { Injectable } from '@angular/core';<br/>import {<br/>    HttpEvent,<br/>    HttpInterceptor,<br/>    HttpHandler,<br/>    HttpRequest,<br/>    HttpErrorResponse,<br/>    HttpResponse<br/>} from '@angular/common/http';<br/>import { Observable } from 'rxjs';<br/>import { tap } from 'rxjs/operators';<br/>@Injectable({<br/>    providedIn: 'root'<br/>})<br/>export class HttpConfigInterceptor implements HttpInterceptor {<br/>    constructor() { }<br/>    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {<br/>        // Get the auth token from  localstorage.<br/>        const authToken = localStorage.getItem('token');<br/>        // Clone the request and replace the original headers with<br/>        // cloned headers, updated with the authorization.<br/>        const authReq = req.clone({<br/>            headers: req.headers.set('Authorization', authToken)<br/>        });<br/>        // send cloned request with header to the next handler.<br/>        return next.handle(authReq);<br/>    }<br/>}</span></pre><p id="a4d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个简单的拦截器，它检查用户的设备localstorage中是否有令牌。如果用户这样做，它将在所有http头中传递令牌。</p><h1 id="0474" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">管道</h1><p id="75eb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Angular中的管道让我们能够将数据转换成任何特定的格式。例如，您可以编写一个简单的管道，将整数格式化为货币格式，或者将日期格式化为任何格式。<br/> Angular附带了一些内置管道，比如日期和货币管道。</p><p id="81b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以这样定义我们自己的定制管道:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="8c74" class="my kv in mj b gy mz na l nb nc">import { Pipe, PipeTransform } from '@angular/core';</span><span id="c3f1" class="my kv in mj b gy ng na l nb nc">@Pipe({ name: 'exponentialStrength' })<br/>export class ExponentialStrengthPipe implements PipeTransform {<br/>    transform(value: number, exponent?: number): number {<br/>        return Math.pow(value, isNaN(exponent) ? 1 : exponent);<br/>    }<br/>}</span></pre><p id="2339" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在组件中使用管道，我们可以这样做:</p><pre class="mq mr ms mt gt mu mj mv mw aw mx bi"><span id="e38f" class="my kv in mj b gy mz na l nb nc">{{power | exponentialStrength: factor}}</span></pre><h1 id="afed" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">WrapPixel的自由角度模板</h1><p id="84e7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">好吧，我希望你喜欢我们的Angularjs备忘单，并了解了Angular Lifecycle钩子、路由等等。这将有助于开发您的项目。同样，角度模板也可以帮助你的项目。因为它们有令人惊叹的设计界面和现成的组件，可以节省您的时间和金钱。你也可以通过WraPixel找到最好的免费角度模板。你可以零投资下载并在你的个人和商业项目中使用它。</p></div></div>    
</body>
</html>