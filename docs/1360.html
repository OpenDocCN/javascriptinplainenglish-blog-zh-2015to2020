<html>
<head>
<title>How to create a ‘What’s New’ Popover in React and Material UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React和Material UI中创建“最新动态”弹出窗口</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-a-whats-new-popover-in-react-and-material-ui-f936e6c8f32e?source=collection_archive---------4-----------------------#2020-03-06">https://javascript.plainenglish.io/how-to-use-a-whats-new-popover-in-react-and-material-ui-f936e6c8f32e?source=collection_archive---------4-----------------------#2020-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a0141a6dd667098545c3ec2b5877c1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STdYzHjmNK4wQAN2sEQYtQ.png"/></div></div></figure><p id="a805" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript拥有最好的开源包和软件生态系统之一。开发人员的时间现在可以缩短，可以比以往更快地将新功能发布给用户。好的UI / UX的一个原则是，当开发者引入一个新的特性时，应用程序会用背景和弹出窗口提醒用户，引导用户探索并弄清楚如何使用这个新特性。</p><p id="857a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将构建一个可重用的组件，我们可以用它来突出我们的应用程序中的任何新功能。</p><p id="d001" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在此查看完整的代码库:</p><div class="kt ku gp gr kv kw"><a href="https://gitlab.com/sundry/react/whats-new-popover" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">杂货/反应/什么-新-流行</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">GitLab.com</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">gitlab.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jt kw"/></div></div></a></div></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="5f7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从使用启用了typescript的create react应用程序开始，我们将使用由react的优秀开发人员提供给我们的默认应用程序。我们不会花太多时间来组织应用程序，但我们会创建两个新的文件夹和文件。一个用于组件和挂钩。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="c4f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从简单的部分开始。</p><p id="53b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户点击弹出窗口时，我们希望将该动作保存在本地存储中。当他们回到应用程序时，它会从本地存储中读取，而不会显示弹出窗口。这很重要，这样我们就不会在用户每次加载页面时打扰他们。</p><p id="0932" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将创建一个<strong class="jx io"> hooks </strong>文件夹，这样我们就可以存储这个<strong class="jx io"> useLocalStorage </strong>钩子。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4341" class="mb mc in lx b gy md me l mf mg">import { useState } from 'react';</span><span id="db26" class="mb mc in lx b gy mh me l mf mg">function useLocalStorage(key: string, initialValue: any) {<br/>  const [storedValue, setStoredValue] = useState(() =&gt; {<br/>    try {<br/>      const item = window.localStorage.getItem(key);<br/>      return item ? JSON.parse(item) : initialValue;<br/>    } catch (e) {<br/>      console.log(e);<br/>      return initialValue;<br/>    }<br/>  });</span><span id="033d" class="mb mc in lx b gy mh me l mf mg">  const setValue = (value: any) =&gt; {<br/>    try {<br/>      const valueToStore = value instanceof Function ? value(storedValue) : value;<br/>      setStoredValue(valueToStore);<br/>      window.localStorage.setItem(key, JSON.stringify(valueToStore));<br/>    } catch (e) {<br/>      console.log(e);<br/>    }<br/>  };<br/>  return [storedValue, setValue];<br/>}</span><span id="9b18" class="mb mc in lx b gy mh me l mf mg">export default useLocalStorage;</span></pre><p id="e6ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">已经有一些包实现了这个钩子，但是我不喜欢在我的应用程序中引入我并不真正需要的依赖。如果你有不同的感受，请留下评论。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="418a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是有趣的部分。</p><p id="6f74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创建一个<strong class="jx io">组件</strong>文件夹，其中的子目录将存储我们的popover组件。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="54ff" class="mb mc in lx b gy md me l mf mg">import React, { useState } from 'react';<br/>import { makeStyles } from '@material-ui/core/styles';<br/>import Backdrop from '@material-ui/core/Backdrop';<br/>import Popover from '@material-ui/core/Popover';<br/>import Typography from '@material-ui/core/Typography';<br/>import Button from '@material-ui/core/Button';<br/>import Grid from '@material-ui/core/Grid';<br/>import Divider from '@material-ui/core/Divider';<br/>import useLocalStorage from 'hooks/useLocalStorage';</span><span id="0396" class="mb mc in lx b gy mh me l mf mg">const useStyles = makeStyles(theme =&gt; ({<br/>  backdrop: {<br/>    zIndex: theme.zIndex.drawer + 1,<br/>    color: '#fff',<br/>  },<br/>  typography: {<br/>    padding: theme.spacing(2),<br/>    color: theme.palette.primary.contrastText,<br/>  },<br/>  grid: {<br/>    padding: theme.spacing(),<br/>    background: theme.palette.primary.main,<br/>  },<br/>}));</span><span id="7213" class="mb mc in lx b gy mh me l mf mg">interface Props {<br/>  id: string;<br/>  anchorEl: Element;<br/>  text: string;<br/>  onClose: Function;<br/>}</span><span id="90a5" class="mb mc in lx b gy mh me l mf mg">const WhatsNew: React.FC&lt;Props&gt; = ({ anchorEl, text, onClose, id }) =&gt; {<br/>  const classes = useStyles();<br/>  const [open, setOpen] = useState(true);<br/>  const [gotIt, setGotIt] = useLocalStorage(`whats-new-${id}`, false);<br/>  <br/>  const handleClose = () =&gt; {<br/>    setOpen(false);<br/>    onClose();<br/>  };</span><span id="3704" class="mb mc in lx b gy mh me l mf mg">  if (gotIt) {<br/>    return &lt;&gt;&lt;/&gt;;<br/>  }<br/>  <br/>  return (<br/>    &lt;Backdrop className={classes.backdrop} open={open} onClick={handleClose}&gt;<br/>      &lt;Popover<br/>        id={'new-menu'}<br/>        open={open}<br/>        anchorEl={anchorEl}<br/>        onClose={handleClose}<br/>        anchorOrigin={{<br/>          vertical: 'bottom',<br/>          horizontal: 'center',<br/>        }}<br/>        transformOrigin={{<br/>          vertical: 'top',<br/>          horizontal: 'center',<br/>        }}<br/>      &gt;<br/>        &lt;Grid<br/>          container<br/>          justify="flex-end"<br/>          direction="column"<br/>          className={classes.grid}<br/>        &gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography className={classes.typography}&gt;What's New&lt;/Typography&gt;<br/>            &lt;Divider /&gt;<br/>          &lt;/Grid&gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography className={classes.typography}&gt;{text}&lt;/Typography&gt;<br/>          &lt;/Grid&gt;<br/>          &lt;Grid item container justify="flex-end"&gt;<br/>            &lt;Button variant="contained" onClick={() =&gt; setGotIt(true)}&gt;<br/>              GOT IT<br/>            &lt;/Button&gt;<br/>          &lt;/Grid&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Popover&gt;<br/>    &lt;/Backdrop&gt;<br/>  );<br/>};</span><span id="7f51" class="mb mc in lx b gy mh me l mf mg">export default WhatsNew;</span></pre><p id="5946" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们看看我们想要传入哪些typescript道具来使其可重用。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2bd5" class="mb mc in lx b gy md me l mf mg">interface Props {<br/>  id: string;<br/>  anchorEl: Element;<br/>  text: string;<br/>  onClose: Function;<br/>}</span></pre><ol class=""><li id="3e0a" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated"><em class="mr"> id </em> —这是必需的，这样我们可以保存一个id，当他们单击<em class="mr">get IT</em>按钮时，该id将在本地存储中使用。</li><li id="2b49" class="mi mj in jx b jy ms kc mt kg mu kk mv ko mw ks mn mo mp mq bi translated"><em class="mr"> anchorEl </em> —这需要告诉素材UI弹出窗口在文档中的什么元素旁边出现，给用户一个在哪里寻找新特性的想法。</li><li id="8d75" class="mi mj in jx b jy ms kc mt kg mu kk mv ko mw ks mn mo mp mq bi translated"><em class="mr">文本</em> —这是对新增功能以及如何使用新功能的简要描述。</li><li id="0749" class="mi mj in jx b jy ms kc mt kg mu kk mv ko mw ks mn mo mp mq bi translated"><em class="mr"> onClose </em> —这是一个回调函数，当用户点击<em class="mr">get IT</em>时，我们需要将anchorEl的值设置为null并隐藏弹出窗口。</li></ol><p id="1c16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们看看组件中的状态。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="30ce" class="mb mc in lx b gy md me l mf mg">const [open, setOpen] = useState(true);<br/> <br/>const [gotIt, setGotIt] = useLocalStorage(`whats-new-${id}`, false);</span></pre><p id="012a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们保存了一个关于弹出窗口是否打开和显示的状态，以及一个关于用户是否点击了<em class="mr">或者是否得到了</em>的本地存储布尔值。</p><p id="b358" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以写代码，如果他们已经点击了<em class="mr">明白了</em>，就不显示弹出窗口。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="249a" class="mb mc in lx b gy md me l mf mg">if (gotIt) {<br/>  return &lt;&gt;&lt;/&gt;;<br/>}</span></pre><p id="6e1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Material UI提供了两个组件，我们将使用它们来实现我们的目标。</p><p id="63ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mr">背景</em> —该组件将显示一个变暗的背景。这很有用，因为它会将注意力从应用上转移开，突出新功能。</p><p id="d6e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个组件将在我们的锚元素旁边呈现一个框，突出显示新的特性。</p><p id="fd84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在popover组件中，我们可以显示新功能的描述和一个供用户点击的按钮，告诉应用程序他们现在知道新功能。</p><p id="758a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任务完成！</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="0b93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是最后一部分。</p><p id="9602" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如何使用React和Material UI中的新弹出窗口？</p><p id="253c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在通过运行create react app命令创建的默认App组件中，我们将添加一个新按钮，然后使用popover来突出显示这个新特性。</p><p id="8b37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要一个ref和一个anchor元素。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6c21" class="mb mc in lx b gy md me l mf mg">const newRef = useRef&lt;HTMLDivElement | null&gt;(null);<br/>const [anchorEl, setAnchorEl] = useState();</span><span id="5c5c" class="mb mc in lx b gy mh me l mf mg">useEffect(() =&gt; {<br/>  setAnchorEl(newRef.current);<br/>}, []);</span></pre><p id="7bbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当App第一次渲染时，我们会调用useEffect并抓取newRef，设置anchor元素。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="0f97" class="mb mc in lx b gy md me l mf mg">&lt;div ref={newRef}&gt;<br/>  &lt;Button variant="contained" color="primary"&gt;<br/>    New Button<br/>  &lt;/Button&gt;<br/>&lt;/div&gt;</span></pre><p id="0fde" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以将ref分配给按钮周围的div。这将告诉我们的弹出窗口显示在这个按钮旁边。我们想让每个人都知道我们的新按钮。告诉你的朋友！</p><p id="c66f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们可以带来我们的爆米花。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5f5f" class="mb mc in lx b gy md me l mf mg">&lt;WhatsNewPopover<br/>  id="new-button"<br/>  text="This button is new, please click it"<br/>  anchorEl={anchorEl}<br/>  onClose={() =&gt; {<br/>    setAnchorEl(null);<br/>  }}<br/>/&gt;</span></pre><p id="2f28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们给它一个对新特性有意义的id。提供新功能的描述。传入我们的锚元素，并给它一个回调，当点击时，它会将我们的锚元素设置为空值，隐藏弹出窗口。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/7fbf04f73a976d5e678be5db9cba9451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oT6i1DvT0b0tORfV40gNcw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk">What’s New Popover</figcaption></figure><p id="f70b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了一个可重用的组件，我们可以在现实世界中使用它。当然，我们可能需要设计得更好一点，但是材质UI的默认风格已经很棒了。</p><p id="e670" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们开始破解并创造新的功能！</p></div></div>    
</body>
</html>