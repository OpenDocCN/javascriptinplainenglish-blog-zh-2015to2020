<html>
<head>
<title>Communicating Between Stores in MobX-state-tree with React and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和TypeScript在MobX-state-tree中的存储之间进行通信</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/communicating-between-stores-in-mobx-state-tree-with-react-and-typescript-24d103001b32?source=collection_archive---------3-----------------------#2019-12-11">https://javascript.plainenglish.io/communicating-between-stores-in-mobx-state-tree-with-react-and-typescript-24d103001b32?source=collection_archive---------3-----------------------#2019-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="16a8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="408f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当使用MobX-state-tree管理状态时，您可能会遇到尝试跨存储进行通信的问题。从一个存储中需要一个计算属性，并需要在另一个存储中使用它，这种情况并不罕见。这就是今天的文章将涵盖的内容。</p><p id="222a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">概括我们的问题，我们有如下的陈述:</p><blockquote class="ll lm ln"><p id="ea63" class="ki kj lo kk b kl lg kn ko kp lh kr ks lp li kv kw lq lj kz la lr lk ld le lf ig bi translated">给定存储A，属性X表示为A.X，我们希望能够对存储b使用A.X。</p></blockquote></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="4ff0" class="jk jl in bd jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh bi translated">演示设置</h1><p id="6a30" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在我创建的一个演示项目中，用户可以看到两张卡片。在初始状态下，一张卡需要用户的PIN。另一张卡包含一条信息，这条信息对没有通过PIN认证的用户是隐藏的。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/bbac2128df146d9ecfbcb9ee215c16a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcgyMOAfrenoREgTpQTEdQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Simple Demo UI</figcaption></figure><p id="fd11" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这些卡中的每一个都有自己的组件，称为<code class="fe mu mv mw mx b">Pin</code>和<code class="fe mu mv mw mx b">Message</code>。这些组件的状态在它们自己的状态树模型中处理。当用户提交PIN后，他们会看到以下秘密消息:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi my"><img src="../Images/2fcd3ad65c5e2099e8a83eba31fec281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6ESo6n5eZR-vJ90sEkZsQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">UI when validated</figcaption></figure></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="74fc" class="jk jl in bd jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh bi translated">模型和商店</h1><h2 id="d695" class="mz jl in bd jm na nb dn jq nc nd dp ju kt ne nf jy kx ng nh kc lb ni nj kg nk bi translated"><code class="fe mu mv mw mx b">PinModel</code>和pinStore</h2><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nl"><img src="../Images/f2b434d0e7ae5d557d4b57b077a9910d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cA3Qr9UBfe1GpzdCF1u5w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Source code for PinModel</figcaption></figure><p id="1636" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">PinModel是我们在Pin组件中使用的状态的蓝图。在这个虚构的例子中，我们的模型<code class="fe mu mv mw mx b">isAuthenticated</code>中只有一个属性，它是一个布尔变量，指示当前用户是否已经过身份验证。我们还向一些认证服务添加了异步请求的模拟，但实际上这只是一个始终兑现的承诺。让我们记住，这是一个人为的例子，显示商店之间的沟通！</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nm"><img src="../Images/ffcda2274a928597827cd7db9fc450cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqYpt1DTEnaGdKp6L-K-Vg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Source code for pinStore</figcaption></figure><p id="6181" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mu mv mw mx b">pinStore</code>简单地创建模型的一个实例，我们将其导出以供消费。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="9729" class="mz jl in bd jm na nb dn jq nc nd dp ju kt ne nf jy kx ng nh kc lb ni nj kg nk bi translated">消息模型和消息存储</h2><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nn"><img src="../Images/9048f5d02ae479662d9c52df08ae1f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ld4Q8be4X9lEf2B7Z3Jwfw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Source code for MessageModel</figcaption></figure><p id="aa3c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">MessageModel应该是定义消息组件所需状态的位置；然而，为了让这个组件知道用户是否已经被认证，它需要从pinStore中借用<code class="fe mu mv mw mx b">isAuthenticated</code>字段。我们如何做到这一点？从图中可以看出，我们使用了MobX-state-tree中的一个名为<code class="fe mu mv mw mx b">getParent</code>的函数。该功能允许我们在状态树中向上，并访问该级别的商店。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi no"><img src="../Images/a7973fa622497ec835ba393241e150b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*attqsqE6W9rY85IzJgnFkg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Source code for messageStore</figcaption></figure><p id="370f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这种情况下的messageStore编写如下，因为不需要为MessageModel初始化任何东西。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="4b50" class="mz jl in bd jm na nb dn jq nc nd dp ju kt ne nf jy kx ng nh kc lb ni nj kg nk bi translated">全球模型和全球商店</h2><p id="0c12" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">允许商店之间进行这种通信的关键是构造父商店。在我们的例子中，我们称之为全球商店。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi np"><img src="../Images/64b75d207e7cb907e5fe2c4fbd49e69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPTizpS0IK2uJLbiTPeWHw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Source code for GlobalModel</figcaption></figure><p id="dee0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们在右边看到的GlobalModel被定义为包含子商店。在这种情况下，我们有两个子存储:pinStore和messageStore。在子商店之间共享属性方面，我们需要在GlobalModel中定义<em class="lo">视图</em>来公开子商店中的状态变量。我们可以看到，我们从pinStore中公开了<code class="fe mu mv mw mx b">isAuthenticated</code>变量，这样这些子存储中的任何一个都可以通过<code class="fe mu mv mw mx b">getParent</code>函数访问该属性。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nq"><img src="../Images/7c9593c85ebc6387cf35673dcc5344e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGhyUx6JghUqJ13NK9CfRA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Source code for globalStore</figcaption></figure><p id="9a0b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">globalStore是通过传入存储的实例来定义的。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="59f4" class="jk jl in bd jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh bi translated">事物反作用的一面</h1><p id="4529" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">既然我们已经为我们的模型建立了所有的逻辑，我们需要将它们与我们的组件集成。</p><h2 id="3660" class="mz jl in bd jm na nb dn jq nc nd dp ju kt ne nf jy kx ng nh kc lb ni nj kg nk bi translated">App.tsx</h2><p id="2b5b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我不完全确定这是否是将商店注入提供商的最佳方式。我肯定会接受建议！</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nr"><img src="../Images/c0d246a96d1df52509345e234b496e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tnI-rf1VBVfBkq-Zzn9zA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">App.tsx</figcaption></figure><p id="b25b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要将MobX-state-tree与React一起使用，我们必须将存储注入到提供者组件中。我们通过导入globalStore，然后将这些值传播到一个对象中，作为props到Provider组件中。</p><h2 id="9c3f" class="mz jl in bd jm na nb dn jq nc nd dp ju kt ne nf jy kx ng nh kc lb ni nj kg nk bi translated">向组件中注入存储。</h2><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ns"><img src="../Images/3422f9377861538d852ca8b2796a558e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1FK1o0R-_iL3qkwh4oUKw.png"/></div></div></figure><p id="2421" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为了将存储注入到组件中，我们在这里遵循相同的模式。我们注入商店的名称，并将组件包装为观察者。通过这样做，我们可以访问商店作为组件的道具。鉴于我对TypeScript还不熟悉，我注意到的一件事是，我们需要将store设置为可选的，否则我们会被期望将store作为一个道具显式地钻取。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="3492" class="jk jl in bd jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh bi translated">结论</h1><p id="d3de" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对于源代码，我包含了一个到<a class="ae nt" href="https://github.com/ja153903/mobx-state-tree-parent-child-demo" rel="noopener ugc nofollow" target="_blank">库</a>的链接。我希望听到一些最佳实践方面的反馈。MobX-state-tree是一个很好的状态管理工具。我强烈建议试一试！</p></div></div>    
</body>
</html>