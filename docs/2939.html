<html>
<head>
<title>How does the Event Loop work in Node.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件循环在Node.js中是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-does-event-loop-work-in-node-js-d96729ae4a95?source=collection_archive---------8-----------------------#2020-08-08">https://javascript.plainenglish.io/how-does-event-loop-work-in-node-js-d96729ae4a95?source=collection_archive---------8-----------------------#2020-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6e8c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">事件循环是什么，它是如何工作的，以及它为什么重要</h2></div><h2 id="ad46" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是输入/输出操作？</h2><p id="633e" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated"><strong class="la io"> I/O </strong>代表输入/输出。I/O用于标记CPU计算机中的进程与该CPU外部的任何东西(内存、磁盘、网络，甚至另一个进程)之间的通信，该进程通过信号与这些外部的东西进行通信。它们被流程接收时是输入，被流程发送时是输出。<br/>节点内。Js的操作术语I/O指的是最耗时的网络和磁盘操作。Node的<em class="lr">事件循环</em>是围绕这样一个事实设计的，即计算机编程中最大的浪费来自于等待这样的I/O操作。</p><h2 id="66be" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">处理缓慢的输入/输出操作</h2><ul class=""><li id="55af" class="ls lt in la b lb lc le lf kl lu kp lv kt lw lq lx ly lz ma bi translated"><strong class="la io"> <em class="lr">同步</em> </strong>:通过逐个执行操作来处理慢速I/O的最简单方法。这是我们处理I/O的有价值的方式，因为当我们执行一个I/O操作时，我们不能处理任何其他操作。</li><li id="97d4" class="ls lt in la b lb mb le mc kl md kp me kt mf lq lx ly lz ma bi translated"><strong class="la io"> <em class="lr"> Fork() </em> </strong> <em class="lr">:从操作系统中分叉另一个进程来处理每个请求。但问题是，这样我们就不能同时处理大量的请求。</em></li><li id="598a" class="ls lt in la b lb mb le mc kl md kp me kt mf lq lx ly lz ma bi translated"><strong class="la io"> <em class="lr">线程</em> </strong>:我们可以为每个请求启动一个新的线程，但是线程编程不是在公园里散步！Apache是多线程的，它为每个请求创建一个线程。</li><li id="6fbe" class="ls lt in la b lb mb le mc kl md kp me kt mf lq lx ly lz ma bi translated"><strong class="la io"> <em class="lr">事件循环</em> </strong>:通过使用事件循环，我们可以处理大量的请求，而不会阻塞主执行运行时。</li></ul><h2 id="8eed" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">事件循环</h2><p id="8f67" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">第一个定义:处理外部事件并将它们转换成回调调用的实体。</p><p id="8af3" class="pw-post-body-paragraph ky kz in la b lb mg jo ld le mh jr lg kl mi li lj kp mj ll lm kt mk lo lp lq ig bi translated">第二个定义:从事件队列中挑选事件并将它们的回调推送到调用堆栈的循环。</p><p id="2ce6" class="pw-post-body-paragraph ky kz in la b lb mg jo ld le mh jr lg kl mi li lj kp mj ll lm kt mk lo lp lq ig bi translated">为了理解事件循环，我们需要了解几个概念:</p><p id="6ac3" class="pw-post-body-paragraph ky kz in la b lb mg jo ld le mh jr lg kl mi li lj kp mj ll lm kt mk lo lp lq ig bi translated"><strong class="la io">调用堆栈<br/> </strong>一种先进先出的简单数据结构。每次我们调用一个函数，它都会被推至堆栈，每次我们从一个函数返回时，它都会从堆栈中弹出。</p><p id="bed7" class="pw-post-body-paragraph ky kz in la b lb mg jo ld le mh jr lg kl mi li lj kp mj ll lm kt mk lo lp lq ig bi translated"><strong class="la io">节点事件队列<br/> </strong>有时又称为消息队列或回调队列。事件循环将回调从事件队列推送到调用堆栈。</p><h2 id="e83a" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">事件循环中最重要的工作</h2><p id="ef1c" class="pw-post-body-paragraph ky kz in la b lb lc jo ld le lf jr lg kl lh li lj kp lk ll lm kt ln lo lp lq ig bi translated">当堆栈为空但事件队列不为空时，它将使一个事件从事件队列中出列，并将其回调推送到堆栈。这就是为什么我们称之为事件循环！事件循环一直做这个简单的事情，直到事件队列变空。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/84056d0f174b0c184e9c1faae302089b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sh4VVWOGnLzG4jFcqlJ8hA.jpeg"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Nodejs schema</figcaption></figure><p id="1f62" class="pw-post-body-paragraph ky kz in la b lb mg jo ld le mh jr lg kl mi li lj kp mj ll lm kt mk lo lp lq ig bi translated">正如我们在这张图片中看到的，当调用堆栈为空时，nodejs事件循环的工作是推送事件的回调函数。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nb"><img src="../Images/b42aaa56994249cb6b5a2c91eac433a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gz-ptCl4de5XTOkpHjaQ0Q.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Simple diagram of the event loop</figcaption></figure><p id="8059" class="pw-post-body-paragraph ky kz in la b lb mg jo ld le mh jr lg kl mi li lj kp mj ll lm kt mk lo lp lq ig bi translated">在这张图片中，左边的框是V8引擎，它有调用堆栈和堆。它使用堆来存储对象。当我们调用一个异步函数时，它会将数据推送到回调队列(如果是时候的话！)并且如果调用栈为空，事件循环将调用推回到V8的调用栈。</p><p id="2058" class="pw-post-body-paragraph ky kz in la b lb mg jo ld le mh jr lg kl mi li lj kp mj ll lm kt mk lo lp lq ig bi translated">我们对节点的了解。Js和它的事件循环的区别在于它是一个无限循环，它的任务是当调用栈为空时将回调从事件队列推送到调用栈。</p></div></div>    
</body>
</html>