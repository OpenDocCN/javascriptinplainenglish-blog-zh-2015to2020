<html>
<head>
<title>Tips for improving JavaScript performance that your users will love</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高JavaScript性能的技巧，用户会喜欢的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-and-practical-tips-for-javascript-performance-892e0d3f951d?source=collection_archive---------0-----------------------#2020-03-22">https://javascript.plainenglish.io/simple-and-practical-tips-for-javascript-performance-892e0d3f951d?source=collection_archive---------0-----------------------#2020-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="617e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你的用户会喜欢的12个技巧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da83a9f31aaa60247ede0228a97779d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UrW7qifJ0QCHt_03oTylw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Speed car panel</figcaption></figure><h2 id="0ef9" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">索引:</h2><ul class=""><li id="83b4" class="lr ls iq lt b lu lv lw lx le ly li lz lm ma mb mc md me mf bi translated">使用局部变量</li><li id="a851" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">使用浏览器缓存</li><li id="35d7" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">缓存DOM</li><li id="dadc" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">避免递归调用</li><li id="247c" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">使用XMLHttpRequest、Fetch或类似的</li><li id="6469" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">实施事件委托</li><li id="7c8a" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">将代码最小化并组合成模块</li><li id="d4eb" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">使用顶级等待功能</li><li id="ab34" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">小心添加不必要的依赖项</li><li id="a997" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">让网络工作者从事高强度工作</li><li id="9139" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">使用Javascript文件捆绑工具</li><li id="8336" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">检测问题的工具</li><li id="675c" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">结论</li></ul><h2 id="973c" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用局部变量</h2><p id="8b67" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">当我们声明一个全局变量时，它会在整个生命周期中保留在内存中。但是，如果我们在局部上下文中用例如let或const关键字声明变量，则应用块范围，并且在块执行后从内存中删除变量。如果我们在全局变量中保存长文本字符串或JSON数据，浏览器会很快耗尽内存，这可能会恶化或阻塞页面。</p><p id="97da" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">尝试总是在您的作用域内使用一个变量是一个简单而良好的实践，可以显著提高整体性能。</p><p id="ee48" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">在下一个例子中，我们可以看到var关键字声明的变量是如何作用于直接函数体(函数作用域)的。相反，let变量的作用域是由{}表示的直接封闭块(块作用域)。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d9e2" class="kv kw iq ne b gy ni nj l nk nl">function foo() {<br/>  var v1 = "Variable 1";<br/>  let v2 = "Variable 2";<br/>  console.log(v1, v2);<br/>  <br/>  {<br/>    let v3 = "Variable 3";<br/>    console.log(v3);<br/>  }</span><span id="58ea" class="kv kw iq ne b gy nm nj l nk nl">console.log(v3); <br/>  //Uncaught ReferenceError: v3 is not defined<br/>}<br/>foo();</span></pre><p id="3aaf" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">在顶层，由var关键字声明的变量确实在全局对象上创建了一个属性，但是对于由let关键字声明的变量，不会出现这种情况:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3ca6" class="kv kw iq ne b gy ni nj l nk nl">//globally scoped<br/>var var1= "I'm in the global object";</span><span id="0ac6" class="kv kw iq ne b gy nm nj l nk nl">//globally scoped<br/>let var2= "I'm not in the global object";</span><span id="5a06" class="kv kw iq ne b gy nm nj l nk nl">console.log(window.var1); <br/>//I'm in the global object</span><span id="71de" class="kv kw iq ne b gy nm nj l nk nl">console.log(window.var2); <br/>//Undefined</span></pre><h2 id="d52f" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用浏览器缓存</h2><p id="1110" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">我们可以使用HTTP协议缓存快速实现这一点，将所有javascript放入以*结尾的文件中。在静态URI位置或使用服务人员发现的js。这告诉浏览器在接下来的执行中利用本地缓存的脚本或数据副本。</p><h2 id="1fc0" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">缓存DOM</h2><p id="aeb5" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">访问DOM非常慢。如果你打算多次使用一个元素的内容，那么把它保存在一个局部变量中并使用它是一个好主意。当您删除DOM的值时，该变量应该不会导致任何内存泄漏。</p><h2 id="6ff7" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">避免递归调用</h2><p id="35aa" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">调用堆栈是一种有限的资源，如果我们递归地调用函数而不小心，很容易发生堆栈溢出。最小化这种情况的一种方法是使用ES6尾部调用优化。使用尾部调用优化，如果函数中的最后一个表达式是对另一个函数的调用，则引擎会优化调用堆栈以防止其增长。</p><p id="ce0a" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">尾部调用优化的问题是它没有标准化，所以最重要的是，如果你需要一个递归函数，在创建它的时候要小心。在大多数情况下，可以不使用递归，而是将递归调用转换为循环。</p><h2 id="87cf" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用XMLHttpRequest、fetch或类似的</h2><p id="baaf" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">Ajax请求有助于减少来自服务器的内容量，并避免在页面加载之间重新创建脚本环境对性能的影响。</p><h2 id="b179" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实施事件委托</h2><p id="ed8d" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">使用<a class="ae nn" href="https://javascript.info/event-delegation" rel="noopener ugc nofollow" target="_blank">事件委托</a>，您可以使用单个事件处理程序来管理整个页面的一类事件。没有它，web应用程序会因为太多的事件处理程序和内存不足而陷入停顿。事件委托的优势包括:需要管理的功能更少，Dom和代码之间的联系更少，因此需要使用的内存更少。</p><h2 id="0616" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">将代码最小化并组合成模块</h2><p id="3a73" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">我们可以将应用的组件捆绑到*。js文件，并通过一个javascript minimizer工具(如uglify-js)传递它们，该工具从源代码中删除所有不必要的字符，而不改变它们的功能。缩小极大地提高了网站的速度和可访问性。它对通过有限的数据计划或低带宽访问您网站的用户也很有用。</p><p id="28e6" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">例如，如果你通过像<a class="ae nn" href="https://javascript-minifier.com/" rel="noopener ugc nofollow" target="_blank"> javascript-minifie </a> r这样的在线最小化器传递下面的代码，你可以得到下面的代码:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="98bf" class="kv kw iq ne b gy ni nj l nk nl">var myValues= [];<br/>for (var i = 0; i &lt; 5; i++) {<br/>  myValues[i] = i + 10;<br/>  console.log("You have" +  i  +"items");<br/>}</span><span id="fe89" class="kv kw iq ne b gy nm nj l nk nl">//Minified code<br/>for(var myValues=[],i=0;i&lt;5;i++)myValues[i]=i+10,console.log("You have"+i+"items");</span></pre><p id="9494" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">例如，JQuery 3.4.1库的<a class="ae nn" href="https://code.jquery.com/jquery-3.4.1.js" rel="noopener ugc nofollow" target="_blank">原始版本</a>和<a class="ae nn" href="https://code.jquery.com/jquery-3.4.1.min.js" rel="noopener ugc nofollow" target="_blank">缩小版本</a>之间有187kb的差异:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bc719d974926f9ca5b09a3b7a34e4281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*Ip-jxEPLrLaiZec0-CXYsw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Jquery file original and minified version size.</figcaption></figure><p id="1589" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">如果你使用的是静态文件捆绑工具，比如WebPack，在他的流程中包含一个最小化器是一个很好的做法。</p><h2 id="7a63" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用顶级等待功能</h2><p id="5404" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">使用顶级Await，ECMAScript模块可以等待资源或选择何时加载它们，这使它成为一个有助于提高整体应用程序性能的优秀特性。在我的文章“新的顶级Await特性如何在JavaScript中工作”中阅读更多关于这个新特性的内容</p><h2 id="7610" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">小心添加不必要的依赖项</h2><p id="d9ef" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">有了像npm或yarn这样的包管理器，我们可以轻松地下载和使用一千个公共包。但是我们经常包含我们不需要的库或者包含我们不需要的东西的库。要解决这个问题，请分析您的包以检测未使用的代码。然后移除未使用和不需要的库。</p><h2 id="0092" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">让网络工作者从事高强度工作</h2><p id="44f6" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">Web Workers允许您生成新的线程并将任务委派给这些线程，以提高性能。这样，通常会阻塞其他作业的开销任务被传递给一个工作线程，主线程可以运行而不会被开销任务阻塞。</p><h2 id="29ae" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用Javascript文件捆绑工具</h2><p id="e976" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">Javascript捆绑是一个过程，它将不同的文件分组，以减少加载页面所需的HTTP请求数量，并缩短请求加载时间。捆绑是当今“基于模块”的开发中常用的方法。你有像<a class="ae nn" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>这样的工具来帮助你自动捆绑你的脚本。</p><h2 id="b750" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">检测问题的工具</h2><p id="596a" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">有许多工具可以帮助您识别网页中的问题。在Chrome中，你可以使用主菜单中的选项:更多工具-开发者工具选项来查看每个选项卡的内存、网络和性能。此外，在Chrome中，你可以使用“审计”选项卡来帮助你识别和修复影响网站性能、可访问性和用户体验的常见问题。像<a class="ae nn" href="https://developers.google.com/speed/pagespeed/insights/" rel="noopener ugc nofollow" target="_blank"> PageSpeed Insights </a>这样的在线工具也可以帮助你分析你的网站。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ef6ddbc76a12074c18859cbb2c1e5577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*w4HNn_TtZ313Gv40NB-9Tg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Chrome DevTools image</figcaption></figure><p id="ee18" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">如果您正在使用像Node这样的包管理器，您可以使用npm audit命令来检测您正在使用的包的问题，或者使用<a class="ae nn" href="https://nodesource.com/products/pricing" rel="noopener ugc nofollow" target="_blank"> NodeSource平台</a>来研究应用程序的性能。</p><h2 id="4e87" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h2><p id="0c4d" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">优化代码是至关重要的，但不要忘记，保持可读性通常更重要。因此，当您应用优化时，不要忘记代码不仅要由机器读取，而且要小心重新发明轮子，因为在许多情况下，大多数问题都有有效的解决方案。</p><p id="1ed3" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">如果你喜欢这篇文章，可以考虑通过我的<a class="ae nn" href="https://kesk.medium.com/membership" rel="noopener">个人资料</a>订阅Medium。谢谢大家！</p></div></div>    
</body>
</html>