<html>
<head>
<title>Replacing Lifecycle methods with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React挂钩替换生命周期方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lifecycle-methods-substitute-with-react-hooks-b173073052a?source=collection_archive---------0-----------------------#2020-04-26">https://javascript.plainenglish.io/lifecycle-methods-substitute-with-react-hooks-b173073052a?source=collection_archive---------0-----------------------#2020-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="839a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">当你有钩子的时候为什么要使用类组件🤩🧨</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e4609344205db958515fa0b553687a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNpdZTxdRqaxt19MVvjNiA.png"/></div></div></figure><p id="7e46" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在离Hooks发布已经一年多了。越来越多的开发人员在传统的基于类的组件上转向钩子实现。即使基于钩子的实现在开始时很难理解，但最终改用钩子是值得的。🎉</p><p id="c460" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们开始研究替换方法之前。让我们看看React 16中使用的经典生命周期事件</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lk"><img src="../Images/1bacb927bbc0166e7249f088ba5b3e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_UWbSFyhbBMVeCkj.jpeg"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">React 16 Lifecycle Methods</figcaption></figure><p id="2251" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">生命周期图像积分—<a class="ae lp" href="https://twitter.com/dceddia" rel="noopener ugc nofollow" target="_blank">https://twitter.com/dceddia</a></p><p id="543d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们来看看它们中的每一个，以及如何替换它们。</p><h1 id="752b" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">componentDidMount()</h1><p id="c7db" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">该方法通常在组件第一次完成呈现时调用。在组件安装完成后，它在整个生命周期中只被调用一次。</p><p id="f81a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mn">带挂钩:</em> </strong></p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="3a75" class="mt lr in mp b gy mu mv l mw mx">function MyExample() {<br/>  const [count, setCount] = useState(0);<br/><br/>  useEffect(() =&gt; {<br/>    document.title = `You clicked ${count} times`;<br/>  }, []); // Pass an empty array to run only callback on mount only.<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="667a" class="lq lr in bd ls lt nf lv lw lx ng lz ma jt nh ju mc jw ni jx me jz nj ka mg mh bi translated"><code class="fe nk nl nm mp b">componentDidUpdate( )</code></h1><p id="8e61" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">这个方法在应用程序生命周期中被多次调用。它在更新发生后立即被调用。初始呈现时不调用此方法。</p><p id="8252" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有两种处理方式，</p><ol class=""><li id="1933" class="nn no in kq b kr ks ku kv kx np lb nq lf nr lj ns nt nu nv bi translated"><strong class="kq io">在每次渲染时调用钩子</strong> <br/>正如你可以看到的，如果下面的例子钩子中的第二个参数为空，意味着它将每次渲染。</li></ol><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="ebd9" class="mt lr in mp b gy mu mv l mw mx">function MyExample() {<br/>  const [count, setCount] = useState(0);<br/><br/>  useEffect(() =&gt; {<br/>    document.title = `You clicked ${count} times`;<br/>  }); // No second argument, so run after every render.<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b591" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2。当特定属性(依赖关系)改变时调用钩子<br/> </strong>在这个实现中，我们需要将第二个参数传递给useEffect，每当依赖关系改变时，它将被自动触发。</p><p id="68c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mn">带挂钩:</em> </strong></p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="175c" class="mt lr in mp b gy mu mv l mw mx">function MyExample() {<br/>  const [count, setCount] = useState(0);<br/><br/>  useEffect(() =&gt; {<br/>    document.title = `You clicked ${count} times`;<br/>  }, [count]);<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="c3f8" class="lq lr in bd ls lt nf lv lw lx ng lz ma jt nh ju mc jw ni jx me jz nj ka mg mh bi translated">ComponentWillUnmount()</h1><p id="3e6d" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">顾名思义，这个方法将在组件被卸载时被调用，并且在组件的生命周期中只被调用一次。</p><p id="c7bc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mn">带钩子:</em> </strong> <em class="mn"> <br/> </em>在<code class="fe nk nl nm mp b">useEffect</code>的回调参数中返回一个回调，在卸载前会被调用。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="65ce" class="mt lr in mp b gy mu mv l mw mx">function MyExample() {<br/>  const [count, setCount] = useState(0);<br/><br/>  useEffect(() =&gt; {<br/>    // It will be called before unmounting.<br/>    return () =&gt; {<br/>      console.log('componentWillUnmount!');<br/>    };<br/>  }, []);<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="0f52" class="lq lr in bd ls lt nf lv lw lx ng lz ma jt nh ju mc jw ni jx me jz nj ka mg mh bi translated"><code class="fe nk nl nm mp b">shouldComponentUpdate( )</code></h1><p id="9bd7" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">默认情况下，这个生命周期方法在组件每次渲染时被调用，当你必须渲染组件或避免渲染时，你可以返回true/false。</p><p id="545f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是由于钩子只能在功能组件中使用，并且功能组件内部处理shouldComponentUpdate()方法来使用。您已经可以使用<code class="fe nk nl nm mp b">React.PureComponent</code>或<code class="fe nk nl nm mp b">React.memo</code>在组件级别实现这一点。用于防止子组件的重新呈现。</p><p id="7926" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mn">带挂钩:</em> </strong> <em class="mn"> <br/> </em>默认情况下，只会浅浅地比较道具对象中的复杂对象。如果您想要控制比较，您也可以提供一个定制的比较函数作为第二个参数。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="58a3" class="mt lr in mp b gy mu mv l mw mx">import React from 'react'</span><span id="c739" class="mt lr in mp b gy nw mv l mw mx">function areEqual(prevProps, nextProps) {<br/>  /*<br/>  return true if passing nextProps to render would return<br/>  the same result as passing prevProps to render,<br/>  otherwise return false<br/>  */<br/>}</span><span id="d961" class="mt lr in mp b gy nw mv l mw mx">const Weather = ({weather}) =&gt; {<br/>    return (&lt;div&gt;<br/>             &lt;p&gt;{weather.city}&lt;/p&gt;<br/>             &lt;p&gt;{weather.temperature}&lt;/p&gt;<br/>             {console.log('Render')}<br/>            &lt;/div&gt;<br/>    )<br/>}<br/><br/>export default React.memo(Weather, <!-- -->areEqual<!-- -->)</span></pre></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="cddd" class="lq lr in bd ls lt nf lv lw lx ng lz ma jt nh ju mc jw ni jx me jz nj ka mg mh bi translated"><code class="fe nk nl nm mp b">getDerivedStateFromProps( )</code></h1><p id="0fbf" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated"><code class="fe nk nl nm mp b">getDerivedStateFromProps</code>在调用render方法之前被调用，无论是初始挂载还是后续更新。它应该返回一个对象来更新状态，或者返回null来不更新任何东西。</p><p id="b6c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mn">带挂钩:</em> </strong></p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="e60f" class="mt lr in mp b gy mu mv l mw mx">function ScrollView({row}) {<br/>  const [isScrollingDown, setIsScrollingDown] = useState(false);<br/>  const [prevRow, setPrevRow] = useState(null);<br/><br/>  if (row !== prevRow) {<br/>    // Row changed since last render. Update isScrollingDown.<br/>    setIsScrollingDown(prevRow !== null &amp;&amp; row &gt; prevRow);<br/>    setPrevRow(row);<br/>  }<br/><br/>  return `Scrolling down: ${isScrollingDown}`;<br/>}</span></pre><p id="a3e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">示例参考—<a class="ae lp" href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops" rel="noopener ugc nofollow" target="_blank">https://react js . org/docs/hooks-FAQ . html # how-do-I-implement-getderivedstatefromprops</a></p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><h1 id="7c25" class="lq lr in bd ls lt nf lv lw lx ng lz ma jt nh ju mc jw ni jx me jz nj ka mg mh bi translated"><strong class="ak">无生命周期方法替换</strong></h1><p id="7197" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">根据react文档，下面是一些没有任何生命周期方法替代钩子的方法:</p><ol class=""><li id="a69b" class="nn no in kq b kr ks ku kv kx np lb nq lf nr lj ns nt nu nv bi translated"><strong class="kq io">componentiddcatch()</strong></li><li id="e916" class="nn no in kq b kr nx ku ny kx nz lb oa lf ob lj ns nt nu nv bi translated"><strong class="kq io">getsnapshotbefore update()</strong></li><li id="f331" class="nn no in kq b kr nx ku ny kx nz lb oa lf ob lj ns nt nu nv bi translated"><strong class="kq io">getDerivedStateFromError()</strong></li></ol></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="27d7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是所有方法的快速预览</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oc"><img src="../Images/befbf6cc97c1367857896e306d4c57e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsk4y_rRxmX_Qtol3H3caw.png"/></div></div></figure><p id="c435" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读这篇文章。我希望你们都准备好开始将传统的基于类的组件替换成基于钩子的实现。</p><p id="0f5f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">快乐学习！💻 😄</p><h2 id="5d54" class="mt lr in bd ls od oe dn lw of og dp ma kx oh oi mc lb oj ok me lf ol om mg on bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="a6bc" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae lp" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kq io">AI in Plain English</strong></a><a class="ae lp" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kq io">UX in Plain English</strong></a><a class="ae lp" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kq io">Python in Plain English</strong></a><strong class="kq io"/>—谢谢，继续学习！</p><p id="53d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae lp" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">submissions @ plain English . io</strong></a><strong class="kq io"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>