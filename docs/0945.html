<html>
<head>
<title>My First Full Stack Web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的第一个全栈Web应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/my-first-full-stack-web-application-8ac82db61b10?source=collection_archive---------3-----------------------#2020-01-05">https://javascript.plainenglish.io/my-first-full-stack-web-application-8ac82db61b10?source=collection_archive---------3-----------------------#2020-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/81db96e63787e1f7cdcc01518a4c0992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rt-Iz4E6n9Pbrqx4QTaYmw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Share My Bike homepage image</figcaption></figure><p id="150f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在600多节课、实验室和4个文件夹项目之后，现在是时候谈谈我最后的文件夹项目了。当报名参加<a class="ae kx" href="https://flatironschool.com/" rel="noopener ugc nofollow" target="_blank">熨斗学校</a>的在线自定进度软件工程课程时，我知道要完成五个文件夹项目才能毕业。对我来说，最终项目似乎是一件遥远的事情，需要很多我还不具备的技能。但它就在那里，准备提交审查。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="6233" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于这个最终的组合项目，目标是构建一个风格化的<strong class="kb io">单页面应用程序</strong>，它由一个<a class="ae kx" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React.js </a>和<a class="ae kx" href="http://Redux.js" rel="noopener ugc nofollow" target="_blank"> Redux.js </a>前端组成，调用Ruby on Rails API。</p><h2 id="1dcd" class="lf lg in bd lh li lj dn lk ll lm dp ln kk lo lp lq ko lr ls lt ks lu lv lw lx bi translated">单页应用程序</h2><p id="96d5" class="pw-post-body-paragraph jz ka in kb b kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw ig bi translated">那么首先，什么是<strong class="kb io">单页应用</strong>？它是一个网站或网络应用程序，通过动态地重写当前页面来响应用户的动作或行为，而不是从服务器重新加载新页面。对此有两种方法:</p><ul class=""><li id="b199" class="md me in kb b kc kd kg kh kk mf ko mg ks mh kw mi mj mk ml bi translated">要么只在一个页面加载中检索所有必要的内容，但根据应用程序的复杂性，这可能会花费太长时间并损害用户体验。</li><li id="b955" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated">或者例如在用户<strong class="kb io">事件</strong>之后，每个适当的内容被<strong class="kb io">请求</strong>到服务器。常见的用户事件包括点击按钮、向下滚动页面、悬停在某个元素上、按下键盘上的某个键…</li></ul><p id="18a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第二种方法对于复杂的应用程序来说是最常见的。事实上，让我们记住，单页应用程序的原因是一个更流畅的用户体验，不会被全页重载打断。</p><p id="d941" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">就代码而言，这意味着整个应用程序只有一个HTML文件——通常命名为<em class="mr">index.html</em>。</p><h2 id="d44d" class="lf lg in bd lh li lj dn lk ll lm dp ln kk lo lp lq ko lr ls lt ks lu lv lw lx bi translated">构建应用程序结构</h2><p id="817c" class="pw-post-body-paragraph jz ka in kb b kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw ig bi translated">应用程序分为两部分:前端和后端。<strong class="kb io">前端</strong>是用户与之交互的部分:界面。<strong class="kb io">后端</strong>管理服务器和用户界面之间的连接。要构建应用程序，有两个选项:</p><ul class=""><li id="4436" class="md me in kb b kc kd kg kh kk mf ko mg ks mh kw mi mj mk ml bi translated">第一个选择是为后端和前端构建一个代码库——比如在Github上。</li><li id="7d21" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated">第二个选择是构建两个代码库:一个用于后端，一个用于前端。这有几个好处。其中两个是，一方面，它允许后端——在我们的例子中是一个API被<strong class="kb io">重用</strong>多次，我们想要多少前端就重用多少次，另一方面，它允许<strong class="kb io">较小的目录</strong>在我们的文本编辑器中管理。</li></ul><p id="0886" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">选择没有对错之分。我上面给出的支持两个独立存储库的两个原因是我选择在两个独立的存储库中构建我的应用程序的主要原因。</p><p id="8baf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我构建的第一个存储库是后端存储库。在我的<strong class="kb io">终端</strong>中，我使用下面的命令创建了一个作为API的<strong class="kb io"> Rails </strong>应用程序，没有任何视图。这就像创建一个带有额外的<strong class="kb io">标志</strong>的常规Rails应用程序一样。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d82d" class="lf lg in mx b gy nb nc l nd ne">rails new my_app_backend --api</span></pre><p id="3be4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于前端，我使用了<strong class="kb io"> create-react-app </strong>生成器来开始。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7a93" class="lf lg in mx b gy nb nc l nd ne">npx create-react-app my_app_frontend</span></pre><p id="89e0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这两个命令为我提供了开始工作所需的所有文件。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="e508" class="lf lg in bd lh li lj dn lk ll lm dp ln kk lo lp lq ko lr ls lt ks lu lv lw lx bi translated">关于组件的类型</h2><p id="df8d" class="pw-post-body-paragraph jz ka in kb b kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw ig bi translated">这个特定项目的技术要求是至少有2个<strong class="kb io">容器</strong>组件和5个<strong class="kb io">无状态</strong>组件。React中的组件是接口的构建块。它可以从父组件(称为<strong class="kb io">道具</strong>)接收<strong class="kb io">输入</strong>，并且可以根据需要多次<strong class="kb io">重复使用</strong>。</p><p id="e486" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了更详细地了解这些容器组件和无状态组件，让我们先用几句话解释一下什么是<strong class="kb io"> <em class="mr">状态</em> </strong>。状态是我们导入的数据，并且会受到<strong class="kb io">更改</strong>。在<em class="mr">状态</em>改变的众多原因中，有两个可能:它所来自的数据库已经被更新，所以<em class="mr">状态</em>将相应地改变或者用户修改了它。</p><p id="6d37" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">容器组件也称为<strong class="kb io">有状态</strong>组件，无状态组件也称为<strong class="kb io">表示性</strong>组件。容器和表示组件之间的区别不是严格的，而是任意的，每个开发者都可以自由地组织他们的组件。但是一般来说，容器组件<strong class="kb io">会有<em class="mr">状态</em> </strong>，并且能够跟踪它的<strong class="kb io">变化</strong>，而表示组件<strong class="kb io">不会有<em class="mr">状态</em> </strong>，它或者<strong class="kb io">显示通过<em class="mr">道具</em>传入的</strong>内容，或者总是显示相同的内容。</p><p id="6cf8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于我们在本文中讨论的应用程序，我决定进行基本的拆分。我为API中的每个<strong class="kb io">模型</strong>构建了一个<strong class="kb io">容器</strong>组件。随着我的前进，我删除了一些不必要的，我增加了其他的。主要是我的<strong class="kb io">有状态</strong>组件是<strong class="kb io">形式</strong>。最好的例子是注册表单和登录表单。在React的一个表单中，对于每个用户<strong class="kb io">输入</strong>，都有一个<strong class="kb io">改变</strong>处于<em class="mr">状态</em>，无论是本地<em class="mr">状态</em>还是<strong class="kb io"> Redux </strong>存储<em class="mr">状态</em>(我们稍后会稍微讨论Redux)。无状态组件的一个例子是<em class="mr"> BicyclesList.js </em>下的<strong class="kb io">自行车列表</strong>。该组件作为<strong class="kb io"> <em class="mr">道具</em> </strong>接收来自<em class="mr">城市容器</em>组件的城市列表，并且与<em class="mr">状态</em>没有任何联系。</p><h2 id="f410" class="lf lg in bd lh li lj dn lk ll lm dp ln kk lo lp lq ko lr ls lt ks lu lv lw lx bi translated">React中的路由</h2><p id="a60a" class="pw-post-body-paragraph jz ka in kb b kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw ig bi translated">由于我们构建了一个没有完全重新加载页面的单页面应用程序，我们可能想知道<strong class="kb io">路由</strong>是如何完成的。在web应用程序路由器中，您决定当用户访问某个<strong class="kb io">页面</strong>时<strong class="kb io">应该发生什么</strong>。因为我们在单个页面应用程序中只有<strong class="kb io">一个视图</strong>，所以我们不能像以前在Rails应用程序中那样，当用户点击链接时<strong class="kb io">将用户重定向到<strong class="kb io">新视图</strong>。</strong></p><p id="aea9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一如既往，我们的问题总有解决的办法。下面是<strong class="kb io"> <em class="mr">反应路由器</em>库</strong>。除其他外，它使我们能够确保:</p><ul class=""><li id="2f24" class="md me in kb b kc kd kg kh kk mf ko mg ks mh kw mi mj mk ml bi translated">我们有一个显示用户正在做什么的URL，而不仅仅是基本的根URL</li><li id="73df" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated">用户可以使用浏览器的前进和后退按钮<strong class="kb io">和</strong></li><li id="86f6" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated">用户可以<strong class="kb io">在地址栏中输入</strong>一个URL，然后<strong class="kb io">导航</strong>查看页面</li></ul><p id="6bf5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了解释我在路线中使用的模式，我将使用CitiesContainer作为示例:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="25bf" class="lf lg in mx b gy nb nc l nd ne"><em class="mr">App.js</em></span><span id="dffa" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">import</strong> React <strong class="mx io">from</strong> 'react';<br/><strong class="mx io">import</strong> { Route } <strong class="mx io">from</strong> 'react-router-dom';<br/><strong class="mx io">import</strong> CitiesContainer <strong class="mx io">from</strong> './containers/CitiesContainer';</span><span id="83b8" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">class</strong> CitiesContainer <strong class="mx io">extends</strong> React.Component {<br/>  render() {<br/>    <strong class="mx io">return</strong> (<br/>      &lt;Route path='/cities' component={CitiesContainer} /&gt;<br/>    )<br/>  }<br/>}</span><span id="ff49" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">export default</strong> App;</span></pre><p id="027e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过使用<em class="mr">路径</em>而不是<em class="mr">精确路径</em>，所有包含“/城市”的路径都将被考虑在内。CitiesContainer组件内部:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5522" class="lf lg in mx b gy nb nc l nd ne"><em class="mr">containers/CitiesContainer.js </em></span><span id="4afc" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">import</strong> React <strong class="mx io">from</strong> 'react';<br/><strong class="mx io">import</strong> { connect } <strong class="mx io">from</strong> 'react-redux';<br/><strong class="mx io">import</strong> { Route } <strong class="mx io">from</strong> 'react-router-dom';<br/><strong class="mx io">import</strong> { fetchCities } <strong class="mx io">from</strong> '../actions/fetchCities';<br/><strong class="mx io">import</strong> CitiesList <strong class="mx io">from</strong> '../components/CitiesList';<br/><strong class="mx io">import</strong> CityPage <strong class="mx io">from</strong> '../components/CityPage';<br/><strong class="mx io">import</strong> BicyclesList <strong class="mx io">from</strong> '../components/BicyclesList';</span><span id="f928" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">class</strong> CitiesContainer <strong class="mx io">extends</strong> React.Component {<br/>  componentDidMount() {<br/>    <strong class="mx io">this</strong>.props.fetchCities()<br/>  } <br/>  <br/>  render() {<br/>    <strong class="mx io">return</strong> (<br/>      &lt;div&gt;<br/>        &lt;Route exact path='/cities' render={() =&gt; &lt;CitiesList <br/>         cities={this.props.cities} /&gt;} /&gt;<br/>        &lt;Route exact path='/cities/:id' render={(routerProps) =&gt; <br/>         &lt;CityPage {...routerProps} cities={this.props.cities} <br/>         /&gt;}/&gt;<br/>        &lt;Route path='/cities/:id/bicycles' render={(routerProps) =&gt; <br/>         &lt;BicyclesList {...routerProps} cities={this.props.cities} <br/>         /&gt;}/&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="260b" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">const</strong> mapStateToProps = state =&gt; {<br/>  <strong class="mx io">return</strong> {<br/>    cities: state.cities<br/>  }<br/>}</span><span id="ecba" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">export</strong> <strong class="mx io">default</strong> <strong class="mx io">connect</strong>(mapStateToProps, { fetchCities })(CitiesContainer)</span></pre><p id="732e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="mr"> routerProps </em>是由<em class="mr"> react-router-dom </em>包提供给美国开发者的。他们允许我们在<em class="mr">道具</em>中获取URL的内容作为<strong class="kb io">参数</strong>。在我们的例子中，它允许我们在props中获得适当城市的<strong class="kb io"> id </strong>，通过它我们可以<strong class="kb io">过滤</strong>所有城市——由<em class="mr"> props </em>给出——并隔离出我们需要的城市。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="5c82" class="lf lg in bd lh li lj dn lk ll lm dp ln kk lo lp lq ko lr ls lt ks lu lv lw lx bi translated">使用Redux</h2><p id="dcbe" class="pw-post-body-paragraph jz ka in kb b kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw ig bi translated">所以，我们终于到了Redux。你会问Redux是什么。我记得问过我自己——和谷歌——同样的问题。我在Youtube上输入“Redux是什么？”时发现了这个视频我觉得很清楚。我希望这对你也有用。<a class="ae kx" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux文档</a>告诉我们Redux是JavaScript应用程序的<strong class="kb io">可预测状态容器</strong>。文档坚持Redux的4个方面:</p><ul class=""><li id="19f5" class="md me in kb b kc kd kg kh kk mf ko mg ks mh kw mi mj mk ml bi translated"><strong class="kb io">可预测的</strong>:它有助于编写在不同环境下运行的<strong class="kb io">一致的</strong>应用程序，并且易于测试。</li><li id="f882" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated"><strong class="kb io">集中化</strong>:将应用程序的状态和逻辑集中化允许强大的功能，如<strong class="kb io"> <em class="mr">状态</em>持久性</strong>。</li><li id="6f0c" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated"><strong class="kb io">可调试的</strong>:Redux dev tools使得跟踪应用状态<strong class="kb io">何时、何地、为何以及如何改变</strong>变得容易。</li><li id="d386" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated"><strong class="kb io">灵活</strong> : Redux适用于任何UI层。</li></ul><p id="eca8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我们的应用程序中，Redux在很多方面都非常方便，但是在这个应用程序中真正重要的一点是拥有关于<strong class="kb io">当前用户</strong>的信息——如果有一个登录的用户——可以在任何地方访问。事实上，我们将这些信息存储在<strong class="kb io"> Redux store </strong>中，这样我们就可以在应用程序的任何地方访问这些信息，而不仅仅是在组件中作为<em class="mr">道具</em>传递。事实上，任何子组件都可以<strong class="kb io"> <em class="mr">将</em> </strong>连接到商店，并且:</p><ul class=""><li id="028a" class="md me in kb b kc kd kg kh kk mf ko mg ks mh kw mi mj mk ml bi translated">有<strong class="kb io">状态的内容为<em class="mr">道具</em> </strong>，但没有<strong class="kb io">引用</strong>存放在我们的组件中，使用<em class="mr"> mapStateToProps() </em>。</li><li id="2ce0" class="md me in kb b kc mm kg mn kk mo ko mp ks mq kw mi mj mk ml bi translated">或者使用<em class="mr"> mapDispatchToProps() </em>能够<strong class="kb io"> <em class="mr">分派</em> </strong>动作，而不需要<strong class="kb io">引用</strong>我们组件中的存储。</li></ul><p id="d1d5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这允许在管理的<em class="mr">状态</em>和显示的<em class="mr">状态</em>的<strong class="kb io">之间分离关注点。但这并不是我们用Redux所能做的全部。在构建<strong class="kb io">异步</strong>动作创建器时，我们使用了<strong class="kb io"> <em class="mr"> thunk </em>中间件</strong>。</strong></p><p id="70ea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一、什么是中间件？维基百科上说它<em class="mr">是一种计算机软件，它向</em> <strong class="kb io"> <em class="mr">操作系统</em> </strong> <em class="mr">之外的软件应用程序提供</em> <strong class="kb io"> <em class="mr">服务</em> </strong> <em class="mr">。可谓'</em>软件胶水' '。所以thunk让我们可以做一些我们不能做的事情。一个<em class="mr"> thunk </em>函数将<em class="mr"> dispatch </em>作为一个参数，这样它就可以在函数内部<strong class="kb io">使用，在我们的例子中是在动作创建者内部。由于<em class="mr">分派</em>可以在函数内部使用，这使得当</strong>我们的<em class="mr">获取</em>请求是<strong class="kb io">完成</strong>时，我们能够<em class="mr">只分派</em>。这就是在下面的示例中所做的，我们只在获取所有城市的获取请求完成时进行调度:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="18dc" class="lf lg in mx b gy nb nc l nd ne"><em class="mr">actions/fetchCities.j</em><strong class="mx io"><em class="mr">s</em></strong></span><span id="9380" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">export</strong> <strong class="mx io">const</strong> fetchCities = () =&gt; {<br/>  <strong class="mx io">return</strong> (dispatch) =&gt; {<br/>    fetch('<a class="ae kx" href="http://localhost:3000/api/v1/cities'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/v1/cities'</a>)<br/>    .then(response =&gt; response.json())<br/>    .then(cities =&gt; {<br/>      dispatch({<br/>        <strong class="mx io">type</strong>: 'FETCH_CITIES',<br/>        <strong class="mx io">payload</strong>: cities<br/>      })<br/>    })<br/>  }<br/>}</span></pre><h2 id="65b5" class="lf lg in bd lh li lj dn lk ll lm dp ln kk lo lp lq ko lr ls lt ks lu lv lw lx bi translated">使用“提取”的数据持久性</h2><p id="58df" class="pw-post-body-paragraph jz ka in kb b kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw ig bi translated">使用<em class="mr">获取</em>，我们能够<strong class="kb io">从服务器获取</strong>数据，以及<strong class="kb io">将</strong>数据发送到同一服务器。从服务器获取数据的例子可以在我谈到路由时提到的CitiesContainer例子中找到。我们在下面的动作控制器中使用fetch来<strong class="kb io">获取</strong>所有城市:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b968" class="lf lg in mx b gy nb nc l nd ne"><em class="mr">actions/fetchCities.j</em><strong class="mx io"><em class="mr">s</em></strong></span><span id="a1b5" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">export</strong> <strong class="mx io">const</strong> fetchCities = () =&gt; {<br/>  <strong class="mx io">return</strong> (dispatch) =&gt; {<br/>    fetch('<a class="ae kx" href="http://localhost:3000/api/v1/cities'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/v1/cities'</a>)<br/>    .then(response =&gt; response.json())<br/>    .then(cities =&gt; {<br/>      dispatch({<br/>        <strong class="mx io">type</strong>: 'FETCH_CITIES',<br/>        <strong class="mx io">payload</strong>: cities<br/>      })<br/>    })<br/>  }<br/>}</span></pre><p id="25e0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在认证部分，登录动作创建者是一个向服务器发送<strong class="kb io"> POST </strong>请求的好例子。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5765" class="lf lg in mx b gy nb nc l nd ne"><em class="mr">actions/auth.js</em></span><span id="4087" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">export</strong> <strong class="mx io">const</strong> login = credentials =&gt; {<br/>  <strong class="mx io">return</strong> (dispatch) =&gt; {<br/>    fetch('<a class="ae kx" href="http://localhost:3000/api/v1/login'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/v1/login'</a>, {<br/>      <strong class="mx io">credentials</strong>: 'include',<br/>      <strong class="mx io">method</strong>: 'POST',<br/>      <strong class="mx io">headers</strong>: {<br/>        'Content-Type': 'application/json'<br/>      },<br/>      <strong class="mx io">body</strong>: JSON.stringify(credentials)<br/>    })<br/>      .then(response =&gt; response.json())<br/>      .then(user =&gt; {<br/>        if (user.error) {<br/>          alert(user.error)<br/>        } else {<br/>          dispatch(setCurrentUser(user))<br/>          dispatch(resetLoginForm())<br/>        }<br/>      })<br/>      .catch(console.log)<br/>  }<br/>}</span><span id="f6aa" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">export</strong> <strong class="mx io">const</strong> setCurrentUser = user =&gt; {<br/>  <strong class="mx io">return</strong> {<br/>    <strong class="mx io">type</strong>: 'SET_CURRENT_USER',<br/>    <strong class="mx io">payload</strong>: user<br/>  }<br/>}</span><span id="975e" class="lf lg in mx b gy nf nc l nd ne"><strong class="mx io">export</strong> <strong class="mx io">const</strong> resetLoginForm = () =&gt; {<br/>  <strong class="mx io">return</strong> {<br/>    <strong class="mx io">type</strong>: 'RESET_LOGIN_FORM'<br/>  }<br/>}</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="e42b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">至于<strong class="kb io">造型</strong>，我最初打算用<strong class="kb io">引导</strong>来反应，因为这是我主要听说过的一个。由于对样式非常陌生，并且在<strong class="kb io">导航</strong>栏元素方面没有找到我要找的东西，我搜索了一下我可以在React中使用的其他样式<strong class="kb io">框架</strong>。阅读<a class="ae kx" href="https://medium.com/@zeolearn/6-best-reactjs-based-ui-frameworks-9c780b96236c" rel="noopener">这篇文章</a>，我检查了<strong class="kb io">语义UI </strong> React的菜单组件，找到了我最初寻找的设置。由于从未使用过其他风格框架，我无法比较语义UI与其他相比使用起来有多简单，但是我必须说让<strong class="kb io">习惯</strong>并使用起来是相当容易的。</p><p id="2f7c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">就像应用程序的其余部分一样，样式并不完全是我此刻想要的样子，但我计划让这个应用程序在各个方面都是一个正在进行的工作。既然已经有了<strong class="kb io">的结构</strong>和基本特性，增加<strong class="kb io">的新特性</strong>会比从头开始容易。我期待增强应用程序的<strong class="kb io">功能</strong>。</p></div></div>    
</body>
</html>