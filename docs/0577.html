<html>
<head>
<title>How to Transfer Files and Data Between Angular Clients and Node.js Backends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular客户端和Node.js后端之间传输文件和数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-transfer-files-and-data-between-angular-clients-and-node-js-backends-fb002ef3a1d?source=collection_archive---------3-----------------------#2019-11-11">https://javascript.plainenglish.io/how-to-transfer-files-and-data-between-angular-clients-and-node-js-backends-fb002ef3a1d?source=collection_archive---------3-----------------------#2019-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/be43e67418a3e1a71e5726279d9d695f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SO-O97CMe3jfQ_Ju.jpg"/></div></div></figure><p id="843c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让Angular应用程序的服务器端和浏览器端代码共享代码库有助于项目的可维护性。您可以使用服务器端渲染(SSR)概念，通过Angular Universal和Node.js实现这一点。您甚至可以使用SSR在应用服务器(Node.js)和其上运行的Angular应用程序之间安全地传递数据，包括文件。</p><p id="8d1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将向您展示如何创建一个应用程序，使用一个代码库从Node.js服务器上传、存储、管理和下载文件。完成此项目后，您将能够:</p><ul class=""><li id="1dc3" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">创建角度应用程序</li><li id="8d77" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">使用Angular Universal和Node.js设置服务器端渲染</li><li id="da8f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">实现文件传输操作</li><li id="6303" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">创建动态的内存文件列表</li><li id="9e8e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在服务器应用程序和Angular for SSR使用的JavaScript之间传递有关存储内容的数据</li></ul><p id="ccb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成这篇文章中的任务，你需要:</p><ul class=""><li id="643a" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lk" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也会安装NPM。)</li><li id="ab61" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank">角CLI </a></li></ul><p id="7622" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些工具在说明中提及，但不是必需的:</p><ul class=""><li id="df77" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lk" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">吉特</a></li></ul><p id="666d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从这篇文章中最有效地学习，你应该具备以下条件:</p><ul class=""><li id="d764" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lk" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a>和<a class="ae lk" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">角度</a>框架的工作知识</li><li id="e090" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">熟悉角度可观测量和依赖注入</li><li id="11ae" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">对<a class="ae lk" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的一些暴露</li></ul><p id="c851" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在之前的文章中<a class="ae lk" href="https://medium.com/javascript-in-plain-english/build-faster-javascript-web-apps-with-angular-universal-a-transferstate-service-and-an-api-b7e4afd0fe9c" rel="noopener">了解更多关于服务器端渲染</a> (SSR)的信息。</p><p id="d83a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub上有这篇文章的配套资源库<a class="ae lk" href="https://github.com/maciejtreder/angular-and-nodejs-data" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="27d2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建项目、组件和服务文件</h1><p id="8100" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在这一步中，您将实现应用程序的第一个“草稿”。您将创建一个用于向服务器上传文件的表单，并创建一个上传文件的内存列表。和往常一样，您需要从初始化项目开始。</p><p id="e5a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">转到您想要创建项目的目录，输入以下命令行指令来初始化项目并添加<a class="ae lk" href="https://angular.io/guide/forms-overview" rel="noopener ugc nofollow" target="_blank">角度形式</a>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5d36" class="mx lm iq mt b gy my mz l na nb">ng new angular-and-nodejs-data --style css --routing false<br/>cd angular-and-nodejs-data/<br/>npm install @angular/forms</span></pre><p id="216a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行以下命令行指令来创建<code class="fe nc nd ne mt b">FileService</code>类:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="fc2f" class="mx lm iq mt b gy my mz l na nb">ng g s file --skipTests</span></pre><p id="7e38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行以下命令来创建<code class="fe nc nd ne mt b">FileUploaderComponent</code>和<code class="fe nc nd ne mt b">FileListComponent</code>类:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="884e" class="mx lm iq mt b gy my mz l na nb">ng g c fileUploader --skipTests<br/>ng g c fileList --skipTests</span></pre><p id="cb2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请务必仔细注意组件名称的大小写。</p><h1 id="3995" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建文件服务</h1><p id="ec77" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><code class="fe nc nd ne mt b">FileService</code>的初始实现将是临时的，它将允许用户添加和删除列表中的文件，但它实际上不会将文件移动到任何地方。它连接文件列表和文件上传组件，并维护文件列表，但是，正如您从下面的代码中看到的，它没有上传或下载功能。</p><p id="fbed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下类型脚本代码替换<em class="nf">src/app/file . service . ts</em>文件的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="6e50" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建文件上传组件</h1><p id="075e" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">文件上传组件的用户界面将基于一个表单，因此有必要将<code class="fe nc nd ne mt b">ReactiveFormsModule</code>导入到主角度<code class="fe nc nd ne mt b">AppModule</code>中。</p><p id="dff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下导入语句添加到<em class="nf"> src/app/app.module.ts </em>文件中:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7fc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">修改<em class="nf"> src/app/app.module.ts </em>文件的<code class="fe nc nd ne mt b">imports:</code>部分以包含<code class="fe nc nd ne mt b">ReactiveFormsModule</code>:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5a8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nc nd ne mt b">FileUploaderComponent</code>的实现从一个模板开始，用户可以用它来选择要上传的文件。</p><p id="2750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下html标记替换<em class="nf">src/app/file-uploader/file-uploader . component . HTML</em>文件的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b3f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe nc nd ne mt b">FileUploaderComponent</code>类中实现上传文件的逻辑。</p><p id="924c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下类型脚本代码替换<em class="nf">src/app/file-uploader/file-uploader . component . ts</em>文件的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，<code class="fe nc nd ne mt b">onFileChange()</code>方法被绑定到HTML表单的<code class="fe nc nd ne mt b">input type="file"</code>元素的<code class="fe nc nd ne mt b">(change)</code>动作。还要注意的是，<code class="fe nc nd ne mt b">formGroup</code>对象的<code class="fe nc nd ne mt b">patchValue</code>方法用于向Angular提供<code class="fe nc nd ne mt b">reader</code>的内容，这样它就可以继续进行表单的验证。</p><p id="b10c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当提交表单时，<code class="fe nc nd ne mt b">onSubmit()</code>事件触发并将命名文件上传到<code class="fe nc nd ne mt b">fileService</code>，文件列表在此更新。</p><h1 id="38c7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建文件列表组件</h1><p id="bce9" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><code class="fe nc nd ne mt b">FileListComponent</code>类实现了从<code class="fe nc nd ne mt b">FileService</code>中检索文件列表的方法。它还提供可以对列出的文件执行的下载和删除操作。</p><p id="f7c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下类型脚本代码替换<em class="nf">src/app/file-list/file-list . component . ts</em>文件的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9c93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可观察到的<code class="fe nc nd ne mt b">fileList$</code>中的数据将显示在一个列表中，该列表还包括用于下载和删除每个文件的可点击命令。</p><p id="9540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下html标记替换<em class="nf">src/app/file-list/file-list . component . HTML</em>文件的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8a5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nc nd ne mt b">*ngFor</code>循环遍历来自<code class="fe nc nd ne mt b">fileList$</code> observable的文件列表，发出一个字符串数组。将为每个条目创建一个包含绑定到<code class="fe nc nd ne mt b">download()</code>和<code class="fe nc nd ne mt b">remove()</code>操作的<code class="fe nc nd ne mt b">&lt;span&gt;</code>元素的<code class="fe nc nd ne mt b">&lt;li&gt;</code>元素。</p><p id="57ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CSS可以用来表示包含在范围中的命令是可点击的。</p><p id="1fd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下CSS代码插入到<em class="nf">src/app/file-list/file-list . component . CSS</em>文件中:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="22df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nc nd ne mt b">FileListComponent</code>类和<code class="fe nc nd ne mt b">FileUploaderComponent</code>类必须包含在应用程序的主要组件<code class="fe nc nd ne mt b">AppComponent</code>中，以便在浏览器中呈现。</p><p id="5951" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下html标记替换<em class="nf">src/app/app . component . HTML</em>的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="44e8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试基本应用程序</h1><p id="f653" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在<em class="nf">Angular-and-nodejs-data</em>中执行以下Angular CLI命令，构建并运行应用程序:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2695" class="mx lm iq mt b gy my mz l na nb">ng serve</span></pre><p id="3f98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开浏览器选项卡，导航到<a class="ae lk" href="http://localhost:4200." rel="noopener ugc nofollow" target="_blank"> http://localhost:4200。您应该会看到一个空的文件列表和一个可供用户输入的表单，如下所示:</a></p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/38b652497e91ab9ce594aeb4bf446971.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/0*7dSwP4pwJNkPet_R.jpg"/></div></figure><p id="f3f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选择合适的文件，点击<strong class="ka ir">上传</strong>按钮。选定文件的名称应出现在文件列表中，如下例所示:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/19a800b9eedb8ee7ac6db13e699af152.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*6arHo3NFKuzkeBGE.jpg"/></div></figure><p id="8070" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试点击<strong class="ka ir">下载</strong>。你会看到什么都没发生。</p><p id="5a5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">试着点击<strong class="ka ir">移除</strong>。该文件名应该从列表中删除。</p><p id="5349" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，应用程序使用户能够选择文件并“上传”它们，但是它们只“上传”到客户机上内存中的文件列表。文件也可以从内存列表中删除。</p><p id="beeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是很有用，但足以向您展示用户界面和文件列表是如何工作的。</p><p id="aa7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想使用GitHub存储库中的代码赶上这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ff88" class="mx lm iq mt b gy my mz l na nb">git clone <a class="ae lk" href="https://github.com/maciejtreder/angular-and-nodejs-data.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-and-nodejs-data.git</a><br/>cd angular-and-nodejs-data<br/>git checkout step1<br/>npm install</span></pre><h1 id="7e6c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">在服务器上保存文件</h1><p id="18db" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">下一步是将文件传输到服务器并存储在磁盘上。您将通过向<code class="fe nc nd ne mt b">FileService</code>类添加更多功能来实现这一点。</p><p id="f636" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，您需要将Node.js服务器添加到项目中，并创建一个专用于存储用户上传的文件夹。</p><p id="5a82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="nf">角度和节点数据</em>文件夹<em class="nf">，</em>中，在命令行执行以下指令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d418" class="mx lm iq mt b gy my mz l na nb">ng add @ng-toolkit/universal<br/>mkdir user_upload</span></pre><p id="f88a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装<code class="fe nc nd ne mt b"><a class="ae lk" href="https://github.com/maciejtreder/ng-toolkit/blob/master/schematics/universal/README.md" rel="noopener ugc nofollow" target="_blank">@ng-toolkit/universal</a></code>项目增加了<a class="ae lk" href="https://angular.io/guide/universal" rel="noopener ugc nofollow" target="_blank">角度通用</a>支持，只需一个命令。它还包括Node.js后端和服务器端呈现(SSR)。你可以在这篇文章的<a class="ae lk" href="https://www.twilio.com/blog/create-search-engine-friendly-internationalized-web-apps-angular-universal-ngx-translate" rel="noopener ugc nofollow" target="_blank">中阅读更多关于Angular中的SSR及其对搜索引擎优化(SEO)的影响。</a></p><h1 id="4257" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">在服务器代码中实现RESTful API端点</h1><p id="3e6c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">API端点将在服务器上提供文件处理，因此需要对<em class="nf"> server.ts </em>文件做一些修改。它们包括添加<code class="fe nc nd ne mt b">fs</code>模块支持(用于操作文件系统)和指定存储数据的目录。</p><p id="9451" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<em class="nf"> server.ts </em>文件，找到下面的常量声明:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4974" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面一行之后立即添加以下常量声明:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cd6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现/ <em class="nf">上传</em>端点，该端点将由前端应用程序使用。</p><p id="c1fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="nf"> server.ts </em>文件中，找到以下代码行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="526a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将下面的类型脚本代码添加到<em class="nf"> server.ts </em>文件中，紧跟在上面的行之后:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d980" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们将在请求正文中上传Base64编码的数据，所以我们需要调整最大正文大小。</p><p id="7b81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在靠近<em class="nf"> server.ts </em>文件顶部的地方，找到以下代码行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ec01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用下面的TypeScript代码替换上面的行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现/ <em class="nf">删除</em>端点。</p><p id="acc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下类型脚本代码添加到<em class="nf"> server.ts </em>文件的底部:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="106c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现GET <em class="nf"> /files </em>端点。</p><p id="8ece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将下面一行类型脚本代码添加到<em class="nf"> server.ts </em>文件的底部:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6b82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe nc nd ne mt b">express.static</code>方法通知Node.js，发送到<em class="nf"> /files/** </em>端点的每个GET请求都应该被视为“静态”托管，从<code class="fe nc nd ne mt b">userFiles</code>目录、<em class="nf"> user_upload </em>提供服务。</p><p id="e1cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务器中的这些RESTful API端点现在可以在前端Angular应用程序中使用。</p><p id="b505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下类型脚本代码替换<em class="nf">src/app/file . service . ts</em>文件的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e01a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码完全实现了上传、下载和删除文件的操作。它还添加了<code class="fe nc nd ne mt b">isLoading()</code>方法，该方法返回一个可观察到的布尔值，表明上传数据的操作是否正在进行。可以在AppComponent类中使用observable来通知用户活动的状态。</p><p id="55a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下类型脚本代码替换<em class="nf"> src/app/app.component.ts </em>的内容:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4dee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当来自<code class="fe nc nd ne mt b">Observable</code>的值指示上传正在进行时，应用程序将显示以下loader GIF(包含在GitHub存储库中):</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7535b8f777cf053f5396c451d44a9109.png" data-original-src="https://miro.medium.com/v2/resize:fit:160/0*Otap2SW7MOzeQMMh"/></div></figure><p id="ede4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下HTML标记添加到<em class="nf">src/app/app . component . HTML</em>文件的底部:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="633b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试上传和下载文件</h1><p id="2aa4" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">重新构建应用程序，并检查上传和下载功能是否正常工作。</p><p id="5d3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="nf"> angular-and-nodejs-data </em>目录中执行以下npm命令行指令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1521" class="mx lm iq mt b gy my mz l na nb">npm run build:prod<br/>npm run server</span></pre><p id="6a46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开浏览器选项卡并导航至<a class="ae lk" href="http://localhost:8080." rel="noopener ugc nofollow" target="_blank"> http://localhost:8080。</a>选择一个文件并上传。</p><p id="05f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件名应显示在<strong class="ka ir">您的文件</strong>下的文件列表中，并且还应出现在<em class="nf">用户_上传</em>目录中。</p><p id="7670" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也应该能够通过点击<strong class="ka ir">下载</strong>来下载文件。请注意，根据文件类型和您的浏览器设置，您的浏览器可能会在新的选项卡或窗口中打开文件，而不是下载它。下图演示了完整的序列:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/003e88e8790877f0d8bef3e1f70ae743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*uTSAbR67SnGht-Fb"/></div></figure><p id="1c08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击<strong class="ka ir">移除</strong>并确认文件名已从<strong class="ka ir">您的文件</strong>下的列表中移除，并且文件本身已从<em class="nf">用户_上传</em>目录中移除。</p><p id="9fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想使用GitHub存储库中的代码赶上这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1e0e" class="mx lm iq mt b gy my mz l na nb">git clone <a class="ae lk" href="https://github.com/maciejtreder/angular-and-nodejs-data.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-and-nodejs-data.git</a><br/>cd angular-and-nodejs-data<br/>git checkout step2<br/>npm install</span></pre><h1 id="8e16" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">检索并显示文件列表</h1><p id="6184" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">你差不多完成了。该应用程序支持上传一个新文件到存储器，检索它，并删除它。当用户导航回应用程序时会出现问题。</p><p id="3f64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以模拟这种行为。如果您的浏览器中仍然打开着<a class="ae lk" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>，请点击刷新按钮。文件列表不见了！但是它们仍然在服务器上的<em class="nf"> user_upload </em>目录中。</p><p id="4c57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该项目的下一步是为<em class="nf"> user_upload </em>目录实现一个响应文件列表。浏览器窗口中显示的列表将动态更新以反映目录的内容，并且当应用程序启动时，它将反映目录中的文件列表。</p><p id="12c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过向我们的服务器添加另一个REST端点来返回文件列表，可以做到这一点。当后端服务器代码与执行服务器端渲染的代码运行在不同的机器上时，这将是一个很好的解决方案。</p><p id="22c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是只要后端代码和服务前端的代码运行在同一个服务器上，那么执行Angular Universal(服务器端渲染)代码和执行REST调用到同一个机器上就没有意义。相反，您可以使用<code class="fe nc nd ne mt b">fs</code>模块列出给定路径中的所有文件。</p><p id="2e52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前一篇文章<a class="ae lk" href="https://www.twilio.com/blog/faster-javascript-web-apps-angular-universal-transferstate-api-watchdog" rel="noopener ugc nofollow" target="_blank">用Angular Universal、TransferState服务和API看门狗</a>构建更快的JavaScript Web应用，演示了如何实现<code class="fe nc nd ne mt b">isPlatformServer()</code>和<code class="fe nc nd ne mt b">isPlatformBrowser()</code>方法来确定哪个平台正在执行代码。这个项目也使用这些函数。</p><p id="7862" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前一篇文章还展示了如何通过将<code class="fe nc nd ne mt b">TransferState</code>对象注入到<code class="fe nc nd ne mt b">AuthService</code>类中，在服务器和客户端之间共享数据。这些方法有助于客户端代码访问<code class="fe nc nd ne mt b">fs</code>模块功能，即使模块本身不能在浏览器中加载。这个项目也利用了这种技术。</p><p id="8f61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下图显示了事件的顺序:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a2ea2cf0e3bd1ce9649d6ffa32e943f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*lmAfgOU4m43TiXGd.jpg"/></div></figure><ol class=""><li id="f34d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated">用户对服务器执行GET /请求。</li><li id="88c6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">Node.js接收请求。</li><li id="e101" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">Node.js启动Angular并在服务器上呈现视图。</li><li id="a49c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">数据存储在<a class="ae lk" href="https://angular.io/api/platform-browser/TransferState" rel="noopener ugc nofollow" target="_blank">传输状态</a>注册表中。</li><li id="60dc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">服务器端呈现的视图，包括浏览器端的JavaScript和TransferState注册表，被传递给浏览器，Angular应用程序在浏览器中重新呈现。</li></ol><p id="ffac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里还有一点需要考虑。您知道，出于安全原因，浏览器不允许JavaScript代码操纵文件系统。Angular CLI使用的<a class="ae lk" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a> JavaScript模块捆绑系统不允许您将<code class="fe nc nd ne mt b">fs</code>模块用于为浏览器构建的代码。</p><p id="e847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这个项目在两个平台上都有一个单一的代码库，webpack把它解释为是为浏览器而构建的——部分来说确实如此。但是它需要<code class="fe nc nd ne mt b">fs</code>来读取目录内容和操作文件，所以它需要一个解决方案来绕过在浏览器中运行<code class="fe nc nd ne mt b">fs</code>的禁令。</p><p id="3231" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，您可能会认为需要为服务器端代码创建一个单独的代码库，让您维护两个项目。但是有一种技术可以让你保持单一的代码库，并且仍然可以从服务器上执行的角度操作文件。</p><p id="a755" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular有能力在“Angular沙箱”之外注入值和引用。您可以将Node.js函数的引用传递给angular-side代码，并从那里执行它。</p><p id="57cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请看下图:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c30f28a8dd679905ad212d188d3503e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*FMGL1p3uzYWJMTOy.jpg"/></div></figure><ol class=""><li id="5b09" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated">浏览器向服务器发送GET /请求。</li><li id="8233" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">服务器触发Angular来呈现视图，并调用<code class="fe nc nd ne mt b">FileService</code>的<code class="fe nc nd ne mt b">constructor()</code>。</li><li id="f737" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">构造函数使用<code class="fe nc nd ne mt b">isPlatformServer()</code>方法来确定它是否正在服务器上的Node.js中执行。如果是，构造函数调用注入到<code class="fe nc nd ne mt b">FileService</code>中的<code class="fe nc nd ne mt b">listFiles()</code>方法作为回调。<code class="fe nc nd ne mt b">listFiles()</code>方法提供了<em class="nf"> user_upload </em>目录内容的当前列表，然后存储在<code class="fe nc nd ne mt b">fileList</code>局部变量中。</li><li id="4f2a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">文件列表存储在<code class="fe nc nd ne mt b">TransferState</code>对象中。</li><li id="a3da" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">渲染的视图被发送回浏览器，并且浏览器在客户端上显示视图和引导角度。</li><li id="02a7" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">客户机再次调用<code class="fe nc nd ne mt b">constructor()</code>，并使用<code class="fe nc nd ne mt b">isPlatformServer()</code>来确定代码正在客户机上执行。</li><li id="fc64" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated"><code class="fe nc nd ne mt b">constructor()</code>从<code class="fe nc nd ne mt b">TransferState</code>对象中获取文件列表。</li></ol><h1 id="be86" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">实现服务器端文件操作</h1><p id="a43a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">有了API端点，您就可以从客户端完成文件操作的实现。</p><p id="d5c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<em class="nf"> server.ts </em>文件，找到以下代码行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cd5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面一行的下方插入以下类型脚本代码:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f69e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="nf"> server.ts </em>文件中找到以下代码:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="90a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">修改上面显示的代码，以包括下面显示的附加行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="006a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候在Angular应用程序中使用这个服务器函数了。</p><p id="a3cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<em class="nf">src/app/file . service . ts</em>文件，用以下类型脚本代码替换现有的<code class="fe nc nd ne mt b">import</code>指令:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b904" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使页面上显示的文件列表能够包含目录中的所有文件，需要将<code class="fe nc nd ne mt b">fileList$</code>的可观察类型更改为<code class="fe nc nd ne mt b">ReplaySubject</code>，这是一个可观察类型，它向其订阅者提供了之前发送给它的值的列表。这使得观察者能够在订阅可观察对象之前获得添加到可观察对象的文件列表。根据<a class="ae lk" href="http://reactivex.io/documentation/subject.html" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a>::<code class="fe nc nd ne mt b">ReplaySubject</code>向任何观察者发出由源可观测物发出的所有项目，不管观察者何时订阅。”</p><p id="c86b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="nf">src/app/file . service . ts</em>文件中找到以下代码行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="81f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用下面的TypeScript代码替换上面的行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1b12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">修改<code class="fe nc nd ne mt b">FileService</code>构造函数，为该类提供<code class="fe nc nd ne mt b">PLATFORM_ID</code>(客户端或服务器)和<code class="fe nc nd ne mt b">TransferState</code>对象。如果代码在服务器上运行，构造器逻辑读取<em class="nf"> user_upload </em>目录的内容(通过使用对<code class="fe nc nd ne mt b">listFiles</code>方法的注入引用)并将文件列表添加到<code class="fe nc nd ne mt b">TransferState</code>对象。如果代码在客户端运行，那么<code class="fe nc nd ne mt b">transferState</code>中的文件列表被复制到类的私有成员变量<code class="fe nc nd ne mt b">fileList</code>中。</p><p id="b4fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="nf">src/app/file . service . ts</em>文件中找到下面的代码行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="53ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用下面的TypeScript代码替换上面的行:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="3e0b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试整个应用程序</h1><p id="f4ab" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">通过在<em class="nf">angular-and-nodejs-data</em>目录的命令行中执行以下指令来重建应用程序:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e478" class="mx lm iq mt b gy my mz l na nb">npm run build:prod<br/>npm run server</span></pre><p id="a287" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开浏览器窗口并导航至<a class="ae lk" href="http://localhost:8080." rel="noopener ugc nofollow" target="_blank"> http://localhost:8080。</a>在<em class="nf"> user_upload </em>目录下的任何文件都应该列在<strong class="ka ir"> Your files </strong>下，如下图所示，你应该可以从服务器上传、下载和删除文件。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e9e2c1d41af01f56c7eb445ed0ff4ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*Sa2Rwj5geWUa-WaF"/></div></figure><p id="6faf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想使用GitHub存储库中的代码赶上这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f8ba" class="mx lm iq mt b gy my mz l na nb">git clone <a class="ae lk" href="https://github.com/maciejtreder/angular-and-nodejs-data.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-and-nodejs-data.git</a><br/>cd angular-and-nodejs-data<br/>git checkout step3<br/>npm install</span></pre><h1 id="3ec7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">安全呢？</h1><p id="a952" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在客户端上运行的Angular可以访问外部的数据吗，比如服务器文件系统？是的，它是。服务器和浏览器有相同的代码库吗？是的，你知道。</p><p id="ef1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会问:“那么<a class="ae lk" href="https://www.owasp.org/index.php/Path_Traversal" rel="noopener ugc nofollow" target="_blank">路径遍历</a>呢？网上所有人都能看到我存储在<em class="nf"> user_upload </em>目录下的数据吗？”这个问题在这里再合适不过了！</p><p id="8d9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在应用程序中所做的是将<em class="nf">引用</em>传递给方法，而不是方法本身。这就是为什么从Node.js向Angular客户端应用程序提供数据是一种共享敏感数据的好方法。</p><p id="81af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查构建输出，并查看一下<em class="nf"> dist/main.hashcode.js </em>文件中的<code class="fe nc nd ne mt b">FileService</code>构造函数:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8574" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，JavaScript期望Node.js将一个<em class="nf">引用</em>作为变量<code class="fe nc nd ne mt b">t</code>传递给函数。输出包中的JavaScript无法检索到关于服务器上目录结构的任何信息。</p><h1 id="60ca" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将数据从Node.js传递到Angular的摘要</h1><p id="c474" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在本项目中，您学习了如何在单个项目代码库中在客户端浏览器和Node.js服务器之间传输文件。客户端的用户界面可以选择要上传的文件，将它们上传到存储它们的服务器，列出存储在服务器上的文件，删除存储在服务器上的文件，以及从服务器下载文件。您看到了如何使用Angular Universal和Node.js在一个Angular代码库中完成所有这些工作。您还看到了这是一种在客户端和服务器之间传输数据(包括存储在服务器上的文件)的安全方法。</p><h1 id="54e4" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">额外资源</h1><p id="d4da" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><a class="ae lk" href="https://angular.io/guide/universal" rel="noopener ugc nofollow" target="_blank"> Angular Universal </a>文档，包括教程和CLI参考</p><p id="e9c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lk" href="https://angular.io/guide/dependency-injection-in-action#dependency-injection-in-action" rel="noopener ugc nofollow" target="_blank">依赖注射在动作</a>在角度</p><p id="d298" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lk" href="https://angular.io/api/platform-browser/TransferState" rel="noopener ugc nofollow" target="_blank"> TransferState </a>类文档，是@angular/platform-browser的一部分</p><p id="7c83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lk" href="http://reactivex.io/documentation/subject.html" rel="noopener ugc nofollow" target="_blank"> ReplaySubject </a>用其他主题对象变量解释的对象</p><p id="5a2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lk" href="https://rxjs-dev.firebaseapp.com/api/index/class/ReplaySubject" rel="noopener ugc nofollow" target="_blank"> RxJS ReplaySubject </a>文档，一个“进行中的工作”</p><p id="ffb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nf">我是Maciej Treder，通过</em>联系我<a class="ae lk" href="mailto:contact@maciejtreder.com" rel="noopener ugc nofollow" target="_blank"><em class="nf">contact@maciejtreder.com</em></a>T6、T8<em class="nf">https://www.maciejtreder.com</em><em class="nf">或@ maciejtreder on</em><a class="ae lk" href="http://github.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="nf">GitHub</em></a><em class="nf">、</em><a class="ae lk" href="https://twitter.com/maciejtreder" rel="noopener ugc nofollow" target="_blank">T21【Twitter】</a><em class="nf">和</em><a class="ae lk" href="https://www.linkedin.com/in/maciej-treder/" rel="noopener ugc nofollow" target="_blank">T27LinkedIn</a><em class="nf">。</em></p><p id="0510" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nf">此帖子最初发布在</em> <a class="ae lk" href="https://www.twilio.com/blog/transfer-files-data-javascript-applications-angular-node-js" rel="noopener ugc nofollow" target="_blank"> <em class="nf"> Twilio博客</em> </a> <em class="nf">上。</em></p></div></div>    
</body>
</html>