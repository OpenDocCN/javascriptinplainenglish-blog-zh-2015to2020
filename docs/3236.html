<html>
<head>
<title>Testing in React, Part 4: Enzyme</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的测试，第4部分:酶</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-in-react-part-4-enzyme-9b030ad616ae?source=collection_archive---------0-----------------------#2020-09-12">https://javascript.plainenglish.io/testing-in-react-part-4-enzyme-9b030ad616ae?source=collection_archive---------0-----------------------#2020-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5c8bc4b45df6fed446d9ccc745de7c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CqGkT7ic6ZjDytA5ZVXDw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@frostroomhead?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Rodion Kutsaev</a> on <a class="ae jd" href="https://unsplash.com/s/photos/biology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="9b64" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本文是React中测试系列的一部分:</p><p id="0e47" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-1-types-tools-244107abf0c6" rel="noopener">React中的测试，第1部分:类型&amp;工具</a></p><p id="90ab" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-2-react-testing-library-f32432b93c6c" rel="noopener">React中的测试，第2部分:React测试库</a></p><p id="9970" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-3-jest-jest-dom-7a8a03ae60b" rel="noopener">React中的测试，第3部分:Jest &amp; Jest-Dom </a></p><p id="9369" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">React中的测试，第4部分:酶</strong></p><p id="5c1e" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/@bryn.bennett/testing-in-react-part-5-end-to-end-testing-with-cypress-bd2bf8d3385f" rel="noopener">React中的测试，第5部分:使用Cypress的端到端测试</a></p><p id="5e5a" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-6-real-world-testing-with-react-testing-library-jest-enzyme-and-cypress-9c73436d95d8" rel="noopener">React中的测试，第6部分:React测试库、Jest、Enzyme和Cypress的真实测试</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="020f" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">我知道我说过我们不打算讨论酶——但是惊喜吧！我们是。虽然我理解测试代码产生的用户体验背后的意图，而不是实际的代码实现，但这两者是不可分割地交织在一起的。正因为如此，我发现Enzyme不是React测试库的替代品，而是与之配合使用的额外工具，因此值得花一些时间。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="aba3" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">酶与反应测试库</h1><p id="2b30" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">首先，这两个库有什么不同？我们已经讨论了RTL(如果你错过了，你可以在这里找到它<a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-2-react-testing-library-f32432b93c6c" rel="noopener"/>，但是作为一个快速回顾，RTL专注于测试代码产生的<em class="kp">体验</em>。它像用户一样测试代码的呈现。</p><p id="b8d8" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">例如，要提交一个表单，用户可以寻找一个带有文本“submit”的按钮，点击它，然后可能会看到某种呈现给DOM的“success”消息。使用React Testing Library测试它，您会找到基于“Submit”文本的按钮，单击它，然后查询“success”消息的文本。然而，使用Enzyme，您将测试“点击”和“成功”消息之间的功能性。</p><p id="716b" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">由于这种基础上的分歧，有一个特别重要的对比:酶可以直接测试状态及其操作，而反应测试库不能。这是我选择将Enzyme与其他测试工具结合使用的最大原因。有时候你需要直接测试状态，直接测试更新状态。在这样做的过程中，我发现了一些错误和不一致，虽然它们不影响用户体验，但不是好代码，可能会导致负面的UX影响。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="49c9" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">渲染组件</h1><p id="24b4" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">酶测试从实际呈现React组件开始，为此，您有三种选择:浅层呈现、完全DOM呈现和静态呈现。我们将讨论前两个问题。</p><h2 id="4ad9" class="ms lq jg bd lr mt mu dn lv mv mw dp lz lm mx my md ln mz na mh lo nb nc ml nd bi translated">浅层渲染</h2><blockquote class="ne"><p id="5974" class="nf ng jg bd nh ni nj nk nl nm nn ll dk translated">浅层呈现有助于将组件作为一个单元进行测试，并确保您的测试不会间接断言子组件的行为。</p></blockquote><p id="7c2a" class="pw-post-body-paragraph kn ko jg kq b kr no kt ku kv np kx ky lm nq lb lc ln nr lf lg lo ns lj lk ll ij bi translated">以上来自<a class="ae jd" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酵素文献</a>。浅层渲染比完全DOM渲染重量轻。它应该用于测试范围仅限于被测试组件的测试，并且不需要测试生命周期方法。一般来说，您可以从浅层呈现开始，当它不能满足您的需求时，就转到完整的DOM呈现。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="4c96" class="ms lq jg ny b gy oc od l oe of">import { shallow } from 'enzyme';<br/>import MyComponent from './MyComponent';</span><span id="5330" class="ms lq jg ny b gy og od l oe of">it('renders the component title', () =&gt; {<br/>   const wrapper = shallow(&lt;MyComponent /&gt;);</span><span id="6bf3" class="ms lq jg ny b gy og od l oe of">   expect(wrapper.find('.header')).to.have.lengthOf(1);<br/>});</span></pre><h2 id="bf72" class="ms lq jg bd lr mt mu dn lv mv mw dp lz lm mx my md ln mz na mh lo nb nc ml nd bi translated">完全DOM渲染</h2><blockquote class="ne"><p id="86db" class="nf ng jg bd nh ni nj nk nl nm nn ll dk translated">完全DOM呈现非常适合于这样的用例:您的组件可能会与DOM APIs交互，或者需要测试包装在更高级组件中的组件。</p></blockquote><p id="8f73" class="pw-post-body-paragraph kn ko jg kq b kr no kt ku kv np kx ky lm nq lb lc ln nr lf lg lo ns lj lk ll ij bi translated">完整DOM呈现的权重更大，当组件需要访问其自身范围之外的资源时，应该使用完整DOM呈现来代替浅层呈现。它更类似于在完整的浏览器环境中进行测试，而不是对单一组件进行单元测试。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="e822" class="ms lq jg ny b gy oc od l oe of">import { mount } from 'enzyme';<br/>import MyComponent from './MyComponent';</span><span id="05a9" class="ms lq jg ny b gy og od l oe of">it('calls componentDidMount', () =&gt; {<br/>   const wrapper = mount(<br/>      &lt;MyComponent<br/>        handleOnChange={handleOnChange}<br/>        foo={bar}<br/>      /&gt;<br/>   );</span><span id="9c6a" class="ms lq jg ny b gy og od l oe of">   handleOnChange('baz');<br/>   wrapper.update();</span><span id="0155" class="ms lq jg ny b gy og od l oe of">   expect(wrapper.props().foo).to.Equal('baz');<br/>});</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="6e23" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">API参考</h1><p id="5606" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">在<a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/shallow.html" rel="noopener ugc nofollow" target="_blank"> Enzyme文档</a>中，你可以找到每种渲染类型的完整调用列表。这些可以用来遍历呈现的组件，断言呈现的组件的某些内容，或者操纵呈现的组件。</p><h2 id="458d" class="ms lq jg bd lr mt mu dn lv mv mw dp lz lm mx my md ln mz na mh lo nb nc ml nd bi translated">横越</h2><p id="dbcd" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">遍历允许您在组件中找到不同的元素，然后您可以对这些元素进行操作或断言。在这一点上，你应该对Jest和RTL很熟悉:</p><ul class=""><li id="f22b" class="oh oi jg kq b kr ks kv kw lm oj ln ok lo ol ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/contains.html" rel="noopener ugc nofollow" target="_blank">contains(nodeOrNodes)</a></code>:接受一个或多个DOM节点，并根据呈现的包装器中是否存在该节点返回一个布尔值。</li><li id="5b1c" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ReactWrapper/children.html" rel="noopener ugc nofollow" target="_blank">children(selector)</a></code>:可选地接受一个选择器，返回当前包装器的所有子级，或者返回当前包装器的具有给定选择器的所有子级。</li><li id="2f45" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/find.html" rel="noopener ugc nofollow" target="_blank">find(selector)</a></code>:接受一个选择器，并返回呈现的包装器中具有给定选择器的所有节点。</li><li id="9409" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/findWhere.html" rel="noopener ugc nofollow" target="_blank">findWhere(fn)</a></code>:接受谓词函数(返回布尔值的函数)，返回谓词函数为<code class="fe oq or os ny b">true</code>的所有节点。</li><li id="40f6" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/getElement.html" rel="noopener ugc nofollow" target="_blank">getElement()</a></code>:返回包装后的元素。</li><li id="16da" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/getElements.html" rel="noopener ugc nofollow" target="_blank">getElements()</a></code>:返回包装后的元素。</li><li id="2a6d" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/parent.html" rel="noopener ugc nofollow" target="_blank">parent()</a></code>:返回当前包装器的父节点。</li><li id="2a44" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/text.html" rel="noopener ugc nofollow" target="_blank">text()</a></code>:返回包装组件中呈现的文本字符串。应该谨慎使用，但是可以用于像<code class="fe oq or os ny b">contain()</code>这样的调用。</li></ul><h2 id="f0ec" class="ms lq jg bd lr mt mu dn lv mv mw dp lz lm mx my md ln mz na mh lo nb nc ml nd bi translated">操纵</h2><p id="b8eb" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">操纵调用是我发现除了其他工具之外使用Enzyme的最有利的理由。这些允许你<em class="kp">改变一些关于渲染组件<em class="kp">实现</em>的东西</em>，比如<code class="fe oq or os ny b">state</code>。</p><ul class=""><li id="230e" class="oh oi jg kq b kr ks kv kw lm oj ln ok lo ol ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/setContext.html" rel="noopener ugc nofollow" target="_blank">setContext(context)</a></code>:接受一个上下文对象，设置根组件的上下文，并重新呈现。</li><li id="cd37" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ReactWrapper/setProps.html" rel="noopener ugc nofollow" target="_blank">setProps(nextProps[, callback])</a></code>:接受带有新属性和可选回调函数的对象，设置根组件的属性并重新渲染。</li><li id="ffad" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ReactWrapper/setState.html" rel="noopener ugc nofollow" target="_blank">setState(nextState[, callback])</a></code> / <code class="fe oq or os ny b">state()</code>:接受具有新状态和可选回调函数的对象，设置根组件的状态并重新呈现。<code class="fe oq or os ny b">state()</code>可以用来访问状态对象。</li><li id="2e00" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ReactWrapper/simulate.html" rel="noopener ugc nofollow" target="_blank">simulate(event[, mock])</a></code>:类似于RTL的<code class="fe oq or os ny b">fireEvent()</code>，接受一个字符串形式的事件名(即‘click’)和一个可选的模拟对象，模拟包装器根节点上的事件。</li><li id="7433" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/update.html" rel="noopener ugc nofollow" target="_blank">update()</a></code>:更新酶组分树以匹配反应组分树。</li></ul><h2 id="c669" class="ms lq jg bd lr mt mu dn lv mv mw dp lz lm mx my md ln mz na mh lo nb nc ml nd bi translated">断言</h2><p id="133b" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">在这一点上，断言也应该看起来很熟悉，并且是关于元素的实际被测试的东西。找到一个元素后，你可以这样写，“它有文本‘欢迎使用我的应用！’".</p><ul class=""><li id="1683" class="oh oi jg kq b kr ks kv kw lm oj ln ok lo ol ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/contains.html" rel="noopener ugc nofollow" target="_blank">contains(nodeOrNodes)</a></code>:接受一个或多个节点，根据包装器是否包含给定的节点返回一个布尔值。</li><li id="6d46" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/equals.html" rel="noopener ugc nofollow" target="_blank">equals(node)</a></code>:接受一个节点，根据包装器是否等于传入的节点返回一个布尔值。</li><li id="8feb" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/hasClass.html" rel="noopener ugc nofollow" target="_blank">hasClass(className)</a></code>:接受字符串形式的类名，根据包装的节点是否具有给定的类名返回一个布尔值。</li><li id="c79b" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/isEmpty.html" rel="noopener ugc nofollow" target="_blank">isEmpty()</a></code>:如果包装器为空，返回一个布尔值。</li><li id="238b" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><code class="fe oq or os ny b"><a class="ae jd" href="https://enzymejs.github.io/enzyme/docs/api/ShallowWrapper/some.html" rel="noopener ugc nofollow" target="_blank">some(selector)</a></code>:接受一个选择器，根据包装器内的任何节点是否包含给定的选择器返回一个布尔值。</li></ul><h2 id="f006" class="ms lq jg bd lr mt mu dn lv mv mw dp lz lm mx my md ln mz na mh lo nb nc ml nd bi translated">还有一点</h2><p id="ec3f" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">上面有很多关于“被包装的节点”和“包装器”的讨论。明确地说，这可以是从调用返回的任何包装节点——而不仅仅是通常声明并分配给呈现组件的初始<code class="fe oq or os ny b">wrapper</code>变量。这意味着您可以遍历呈现的组件以找到您想要测试的节点，将找到的节点的包装器赋给一个新变量，然后在这个新包装器上使用上面的调用:</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="8816" class="ms lq jg ny b gy oc od l oe of">import { mount } from 'enzyme';<br/>import MyComponent from './MyComponent';</span><span id="926c" class="ms lq jg ny b gy og od l oe of">it('displays a header with text "Welcome!"', () =&gt; {<br/>   const wrapper = mount(&lt;MyComponent /&gt;);</span><span id="d5b9" class="ms lq jg ny b gy og od l oe of">   // Wraps the header node in a new wrapper on which to make calls<br/>   const header = wrapper.find('.header');</span><span id="f253" class="ms lq jg ny b gy og od l oe of">   expect(header).hasClass('header');<br/>   expect(header).to.equal('&lt;div className="header"&gt;Welcome!&lt;/div&gt;')<br/>});</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="a348" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated"><em class="kp">现在</em>我可以说，下一步我们将使用Cypress进行端到端测试，之后我们将返回并在真实的应用程序中进行真实的测试实现。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="de42" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">之前的</strong>:<a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-3-jest-jest-dom-7a8a03ae60b" rel="noopener">React，Part 3: Jest &amp; Jest-Dom </a>中的测试</p><p id="9f10" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">下一个</strong>:React中的<a class="ae jd" href="https://medium.com/@bryn.bennett/testing-in-react-part-5-end-to-end-testing-with-cypress-bd2bf8d3385f" rel="noopener">测试，第5部分:使用Cypress的端到端测试</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="9ac3" class="ms lq jg bd lr mt mu dn lv mv mw dp lz lm mx my md ln mz na mh lo nb nc ml nd bi translated">资源</h2><ul class=""><li id="7535" class="oh oi jg kq b kr mn kv mo lm oy ln oz lo pa ll om on oo op bi translated"><a class="ae jd" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank">官方酶文档</a></li><li id="22d0" class="oh oi jg kq b kr ot kv ou lm ov ln ow lo ox ll om on oo op bi translated"><a class="ae jd" href="https://create-react-app.dev/docs/running-tests/" rel="noopener ugc nofollow" target="_blank">使用Create React应用程序运行测试</a></li></ul></div></div>    
</body>
</html>