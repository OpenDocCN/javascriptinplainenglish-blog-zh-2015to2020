<html>
<head>
<title>More Lodash Features that are Available in Plain JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">普通JavaScript中提供的更多Lodash特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/more-lodash-features-that-are-available-in-plain-javascript-894c060fc26e?source=collection_archive---------1-----------------------#2020-02-17">https://javascript.plainenglish.io/more-lodash-features-that-are-available-in-plain-javascript-894c060fc26e?source=collection_archive---------1-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9eb2993bbbf1df0e2f300480558679da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CAZEFYobjFYuV27v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kris_ricepees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gary Bendig</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9ac0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">近年来，JavaScript中的新特性一直在快速发展。之前由其他库填补的不足，已经成为普通JavaScript的内置特性。</p><p id="0ea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看现在普通JavaScript中可用的Lodash方法，比如函数currying、部分应用的函数等等。</p><p id="4ca5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash的一些特性更好，但是对于其他特性，普通的JavaScript就足够了。</p><h1 id="cb2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">咖喱菜肴</h1><p id="83c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Lodash中的<code class="fe me mf mg mh b">curry</code>方法返回一个函数，该函数有一个或多个最初传入的参数。我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fba9" class="mq lc iq mh b gy mr ms l mt mu">const subtract = (a, b) =&gt; a - b;<br/>const currySubtract = _.curry(subtract);<br/>const subtract1 = currySubtract(1);<br/>const diff = subtract1(5);<br/>console.log(diff);</span></pre><p id="6dc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们定义了subtract函数，它返回第一个参数减去第二个参数。</p><p id="1a71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用传递了subtract方法的<code class="fe me mf mg mh b">curry</code>方法来创建一个新方法，该方法生成一个参数并返回带有由该参数设置的第一个参数的<code class="fe me mf mg mh b">subtract</code>函数。那就是<code class="fe me mf mg mh b">currySubtract</code>功能。</p><p id="bc27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">currySubtract</code>来设置<code class="fe me mf mg mh b">subtract</code>函数的参数，并返回带有第一个参数集的函数。最后，我们用第二个参数<code class="fe me mf mg mh b">subtract</code>调用<code class="fe me mf mg mh b">subtract1</code>函数得到最终结果。</p><p id="9787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码对普通JavaScript做同样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ba84" class="mq lc iq mh b gy mr ms l mt mu">const currySubtract = a =&gt; b =&gt; a - b;<br/>const subtract1 = currySubtract(1);<br/>const diff = subtract1(5);<br/>console.log(diff);</span></pre><p id="901c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它做完全相同的事情，但是不调用<code class="fe me mf mg mh b">curry</code>方法。</p><h1 id="6f69" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">部分的</h1><p id="5c58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Lodash也有一个部分应用函数的方法，它与curry不同，因为函数的一些参数被直接传递到函数中，并返回新的函数。</p><p id="0d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e08a" class="mq lc iq mh b gy mr ms l mt mu">const add = (a, b) =&gt; a + b;<br/>const add1 = _.partial(add, 1);<br/>const sum = add1(2);<br/>console.log(sum);</span></pre><p id="9238" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">partial</code>方法传入第一个参数，并返回传入第一个参数的函数。这给了我们<code class="fe me mf mg mh b">add1</code>函数。</p><p id="1d1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后when可以用第二个参数调用<code class="fe me mf mg mh b">add1</code>函数，在上面的代码中是2，我们为<code class="fe me mf mg mh b">sum</code>得到3。</p><p id="7a4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在普通的JavaScript中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1b12" class="mq lc iq mh b gy mr ms l mt mu">const add = (a, b) =&gt; a + b;<br/>const add1 = b =&gt; add(1, b);<br/>const sum = add1(2);<br/>console.log(sum);</span></pre><p id="c931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以像对待<code class="fe me mf mg mh b">curry</code>方法调用一样跳过Lodash <code class="fe me mf mg mh b">partial</code>方法调用。</p><h1 id="e735" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">情商</h1><p id="4433" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Lodash有<code class="fe me mf mg mh b">eq</code>方法来比较值。例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d730" class="mq lc iq mh b gy mr ms l mt mu">const equal = _.eq(1, 1);</span></pre><p id="e830" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的功能与<code class="fe me mf mg mh b">Object.is</code>相同，所以我们可以直接使用它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/3c3150f747d9395e3b614946bef0aa85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FqUuSvruOqiPWhkZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@the_real_napster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dominik Lange</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8872" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">增加</h1><p id="9641" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">它还有<code class="fe me mf mg mh b">add</code>方法，我们可以像在下面的代码中一样使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1478" class="mq lc iq mh b gy mr ms l mt mu">const sum = _.add(1, 1);</span></pre><p id="86d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到值是2。它和<code class="fe me mf mg mh b">+</code>操作符做同样的事情，所以我们可以用它来代替。</p><h1 id="1d76" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">嵌套运算符</h1><p id="c326" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">好的一面是，我们可以将这些方法直接传递给其他Lodash方法，如<code class="fe me mf mg mh b">map </code>和<code class="fe me mf mg mh b">reduce</code>，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a2bf" class="mq lc iq mh b gy mr ms l mt mu">const mult = _.map([1, 2, 3], n =&gt; _.multiply(n, 2));</span></pre><p id="dc6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从上面的代码中得到<code class="fe me mf mg mh b">[2, 4, 6]</code>，我们从:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1432" class="mq lc iq mh b gy mr ms l mt mu">const sum = _.reduce([1, 2, 3], _.add);</span></pre><h1 id="0621" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在</h1><p id="0f7a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">at</code>方法让我们通过索引来访问对象的属性值或数组的条目。</p><p id="c9f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，给定以下对象，我们可以编写以下内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="85b2" class="mq lc iq mh b gy mr ms l mt mu">const obj = { a: [{ b: { c: 2 } }, 1] };</span></pre><p id="edef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过写下以下内容来获得带有<code class="fe me mf mg mh b">at</code>的<code class="fe me mf mg mh b">c</code>属性的值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="67a9" class="mq lc iq mh b gy mr ms l mt mu">const c = _.at(obj, ["a[0].b.c"]);</span></pre><p id="b08b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么对于<code class="fe me mf mg mh b">c</code>我们得到2。</p><p id="6e80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过向上面的数组传递更多路径来访问一个对象的多个属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5a16" class="mq lc iq mh b gy mr ms l mt mu">const vals = _.at(obj, ["a[0].b.c", "a[0].b"]);</span></pre><p id="740d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们et:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a004" class="mq lc iq mh b gy mr ms l mt mu">2<br/>{c: 2}</span></pre><p id="7e2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，我们可以直接访问路径:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3a7d" class="mq lc iq mh b gy mr ms l mt mu">const vals = [obj.a[0].b.c, obj.a[0].b];</span></pre><p id="a318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，对于可能不存在的访问路径来说，这很好。例如，给定同一个对象，如果我们写下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0a47" class="mq lc iq mh b gy mr ms l mt mu">const vals = _.at(obj, ["a[0].b.c", "d.e"]);</span></pre><p id="b658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到第二个条目的<code class="fe me mf mg mh b">undefined</code>,而不是崩溃应用程序。</p><p id="957e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，Lodash在对象路径访问方面仍然有一些优势。然而，其他操作符，如add、multiply、curry和partial，我们可以自己用普通的JavaScript轻松定义，所以Lodash仍然有一些价值。</p></div></div>    
</body>
</html>