# 偷这段 JavaScript 代码！

> 原文：<https://javascript.plainenglish.io/steal-this-javascript-e65cf3320491?source=collection_archive---------16----------------------->

## 复制和粘贴 JavaScript 代码的利与弊

![](img/27d32fe862bebf43c8f3c41e0520df46.png)

Photo by [Maxwell Nelson](https://unsplash.com/@maxcodes?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

我们都做过。我们都会再做一次。这是一个历史悠久的传统，同时受到崇敬和唾骂，通常是由同一个人根据上下文来说。当然，我说的是复制和粘贴代码。

在程序员中存在着一种有趣的二分法，我们都倾向于痴迷于细节，而实际的倾向会让我们说“去它的，它能工作，发货吧！”。编码人员之间关于需要理解你的代码库的每一寸以及不要重新发明轮子的永恒争论经常以争吵和理解我们每个人都有自己的底线而告终。

关于这个话题的笑话比比皆是。《从堆栈溢出复制和粘贴》这本书的虚构书名将成为我个人的经典之作，但它也直接聚焦于问题的症结。对这种做法的嘲笑态度已经存在很长时间了。十年前，编码人员会把复制/粘贴开发人员称为“脚本小子”，这个词隐含着所有有意的优越感。

尽管一切都是有背景的。对于一个创建个人网站的 weekend warrior 开发人员来说，复制并粘贴一大块他们永远也不可能理解的代码，但为他们实现一个目标是完全可以理解和接受的。然而，如果同一个周末战士向他的朋友收取 50 美元，让他为他们的网站做这件事，这种看法就会发生巨大的变化。那么，对于专业开发人员来说，什么时候可以复制和粘贴代码呢？

## 复制的情况

让我们先定义我们的术语，因为这种水可以很快变得浑浊。肯定有一些开发人员会告诉你，你添加的任何不是你写的代码都是不可接受的。这些强硬派包括使用像 lodash 或 jQuery 这样的库。他们的立场通常围绕着这样一个论点，即那些库附带了一堆你不需要的函数，并且/或者你应该在你的代码库中编写任何函数来为你的代码库优化它。

我们现在谈的不是这个。为了便于讨论，专门发布供使用的库是公平的游戏。但是，如果您正在编写一个 web 应用程序，并且需要一个函数来对数组进行排序或搜索，该怎么办呢？你当然可以谷歌一下，找到数百种不同的实现，你可以很容易地把它们放入你的代码中来完成这项工作。为什么要从头开始重写这个函数？有些问题已经解决了，那么我们真的有必要要求大家重新发现解决方案吗？在大多数情况下，你所能期望的最好结果就是写出一个和现有解决方案一样好的版本，所以为什么要浪费你的时间呢？

我通常的经验法则是留意为什么我选择使用别人的代码块。举个例子，如果我发现了一个数组排序算法，在检查之后发现我不能重写得更好了？我用它。我尽量不让复制/粘贴代码成为捷径。对于不合格的代码来说，很容易发现它进入了您的代码库，并最终成为一个问题。

在我看来，代码复制的另一个优秀用例是在 API 方面。当我需要的只是一个特定的数据块时，我并不总是有时间从头到尾地学习一个 API。当我可以开发一个功能或者追踪一个 bug 的时候，这并不是对我时间的有效利用。

## 为什么不应该复制代码

有一个非常合理的理由来证明永远不要复制代码。虽然这听起来很明显，但是如果你不得不从其他地方复制代码，这很好地表明了你的技能中有一个漏洞。我们应该总是努力做好我们所做的事情，依靠别人的工作给了我们一个避免学习新东西的机会，以便更快地完成工作。

这不仅仅是一个语义点。从设计上来说，编程就是寻找最优雅、最有效的解决方案。有时候，一个问题真的已经尽可能好地解决了，但事实上这种情况很少发生。如果你花时间充分理解问题集，并下定决心寻找更好的解决方案，你发现的“相当好”的算法实现可能会得到改进。

说“够好了”并继续前进是很容易的。有时时间和经济限制要求这样做，但每次发生这种情况时，你都错过了变得更好的机会。编程教育不是一个线性的过程，所以学习一个新的东西经常会同时带来其他几个方面的进步，让你成为一个更全面的程序员。

最终，选择使用什么以及何时使用完全取决于每个开发人员。在完成工作和避免自满之间找到平衡很重要，但这并不总是容易做到的。我完全理解那些顶着时间和资源的巨大限制努力完成工作的开发人员。与此同时，我鼓励任何有能力的人尽可能多地尝试编写代码，并尽最大努力学习如何编写自己不会的代码。

最终，你会成为一个更好的开发者。