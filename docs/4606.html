<html>
<head>
<title>Use the Open/Close Principle to Write Clean, Modular React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用打开/关闭原则编写干净的模块化React代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-open-close-principles-in-react-to-write-clean-modular-code-61e2a03d31b9?source=collection_archive---------4-----------------------#2020-12-24">https://javascript.plainenglish.io/how-to-use-open-close-principles-in-react-to-write-clean-modular-code-61e2a03d31b9?source=collection_archive---------4-----------------------#2020-12-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/892aaa7e75a86cea0643762ecffa1ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HDSLgcS5HVDpkZXSN5SYg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pankajpatel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae kc" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="00fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将向您展示如何将<strong class="kf ir">开/关原则</strong> ( <em class="lb">软件架构中一个众所周知的概念</em>)应用到您的React组件中，并轻松编写干净、可重用和模块化的代码。</p><h2 id="e961" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">什么是开/关原理？</strong></h2><p id="d65d" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在面向对象编程中，开放/封闭原则陈述了“软件实体(类、模块、函数等)”。)应该对扩展开放，但对修改关闭”；也就是说，这样的实体可以允许其行为被扩展，而无需修改其源代码。</p><h2 id="6736" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">但是这在React应用中有什么用呢？</strong></h2><p id="86d0" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">为了理解这在React应用程序中是如何有用的，让我们从一个实际问题开始。假设我们正在构建一个仓库应用程序。在这个应用程序中，我们有一个名为<code class="fe ma mb mc md b">OrderReport</code>的组件，它负责处理用户订单。</p><p id="8db3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们的代码如何寻找这个样本组件</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="42df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，假设我们的业务规则发生了变化。管理层已经决定，现在我们的仓库公司将处理三种类型的订单。一些客户可以选择特殊递送选项或快速递送选项。</p><p id="4c8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是新客户数据的样子。</p><pre class="me mf mg mh gt mk md ml mm aw mn bi"><span id="6814" class="lc ld iq md b gy mo mp l mq mr">const customerB = {<br/>    name: "Company B",<br/>    address: "410 Ramsy St",<br/>    total: 1000,<br/>    isFastTracked: true<br/>};<br/>const customerC = {<br/>    name: "Company C",<br/>    address: "123 Abram Ave",<br/>    total: 1010,<br/>    specialDelivery: true<br/>};</span></pre><p id="01d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管理层给了我们一个要求，我们仍然需要支持所有的老客户对象。然而，如果一个客户对象有一个<code class="fe ma mb mc md b">isFastTracked</code>标志或者一个<code class="fe ma mb mc md b">specialDelivery</code>标志，那么我们将需要执行一些额外的逻辑，例如我们需要进行一个额外的api调用和呈现额外的信息。</p><p id="b82e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从开发人员的角度来看，这似乎是一个简单的实现。我们可以将这些额外的逻辑实现到现有的<code class="fe ma mb mc md b">OrderReport</code>组件中，如下所示。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4a4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，组件在这里开始变得嘈杂。我们将太多的职责分配给了这个单一的组件。此外，这个组件很难测试，不太容易重用。现在，如果大约一周之后，我们的业务需要添加五种新类型的交付选项，并且业务逻辑略有不同，该怎么办呢？现在我们有一个问题，更新这个组件将是一个繁琐和容易出错的任务。当我们设计单个软件组件/模块时，软件更容易维护，因为扩展是开放的，修改是封闭的。这就是开/闭原理。我们希望避免对我们的核心<code class="fe ma mb mc md b">OrderReport</code>进行重大修改，同时使其可扩展，以便其功能可以用于其他组件。</p><p id="fb25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在经典的面向对象编程中，这是通过继承来实现的。在像<strong class="kf ir"> <em class="lb"> Java、C# </em> </strong>和<strong class="kf ir"> <em class="lb"> Python </em> </strong>这样的语言中，我们可以扩展现有的类来为代码添加额外的功能。然而，在<strong class="kf ir"> JavaScript </strong>中，我们可以简单地通过一个函数组合来实现。让我们来看看如何应用它。在下面的例子中，我创建了一个新的高阶组件，它只负责处理快速跟踪订单</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="050a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，它接收一个基本组件作为参数，并向其添加额外的功能。在这个场景中，我们的基本组件是旧的<code class="fe ma mb mc md b">OrderReport</code>组件。我们可以回到最简单的<code class="fe ma mb mc md b">OrderReport</code>组件，如下所示。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4447" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe ma mb mc md b">App</code>组件中，每当我们发现一个快速跟踪订单时，我们可以用<code class="fe ma mb mc md b">withFastTrackedOrder</code>更高的订单组件来组合它。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c922" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以为特殊订单创建一个高阶组件。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9af5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更改我们的应用程序组件来反映这些变化，如下所示</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比我们想出的第一个解决方案要干净得多。现在我们所有组件都可以扩展了。我们可以很容易地创建更多的<strong class="kf ir"> HOC </strong> ( <em class="lb">高阶组件)</em>来扩展这些组件中每一个的功能，并且我们不必修改核心功能。这样，我们的应用程序对未来的变化更加敏捷。</p><p id="0a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，这些更小的组件负责一个特定的任务，这使得它们更容易维护，如果我们想在应用程序的不同部分重用，并且更容易编写单元测试。</p><p id="118e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天到此为止😀，希望你喜欢这篇文章。</p></div></div>    
</body>
</html>