<html>
<head>
<title>Best of Modern JavaScript — Typed Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript类型数组的精华</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-typed-arrays-dbe6038cb281?source=collection_archive---------11-----------------------#2020-10-29">https://javascript.plainenglish.io/best-of-modern-javascript-typed-arrays-dbe6038cb281?source=collection_archive---------11-----------------------#2020-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/de2100ec5541d9230d9516a25fd77274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bupt2ord6v8ahTV1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@benhershey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ben Hershey</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b3ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript类型化数组。</p><h1 id="e8cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箝位转换</h1><p id="5bb5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">钳位转换与模块转换的工作方式不同。</p><p id="523b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript为我们提供了具有类型化数组的构造函数，这种构造函数可以进行钳位转换，比如<code class="fe me mf mg mh b">Uint8ClampedArray</code>构造函数。</p><p id="5464" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它与模转换的工作方式不同，因为所有下溢值都被转换为最低值。</p><p id="0f7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且所有溢出值都被转换为最高值。</p><p id="a2bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容来创建一个:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9b29" class="mq lc iq mh b gy mr ms l mt mu">const uint8c = new Uint8ClampedArray(1);</span></pre><p id="670c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7d58" class="mq lc iq mh b gy mr ms l mt mu">uint8c[0] = 255;</span></pre><p id="f379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到255作为<code class="fe me mf mg mh b">uint8c[0]</code>的值。</p><p id="bd46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8f95" class="mq lc iq mh b gy mr ms l mt mu">uint8c[0] = 256;</span></pre><p id="9947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然得到255。</p><p id="020d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d8c4" class="mq lc iq mh b gy mr ms l mt mu">uint8c[0] = 0;</span></pre><p id="600c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到0。</p><p id="13b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dca8" class="mq lc iq mh b gy mr ms l mt mu">uint8c[0] = -1;</span></pre><p id="808a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然得到0。</p><h1 id="0758" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">字节序</h1><p id="ec62" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在类型化数组中存储多个字节，那么字节序就很重要。</p><p id="8f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Big-endian意味着最重要的字节先出现。</p><p id="3351" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有2个字节像<code class="fe me mf mg mh b">0xABCD</code>，那么<code class="fe me mf mg mh b">0xAB</code>先来，然后是<code class="fe me mf mg mh b">0xCD</code>。</p><p id="12a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Little-endian意味着最不重要的字节排在最前面。</p><p id="823c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着数字的存储顺序与它们在大端数组中的存储顺序相反。</p><p id="0f35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CPU架构之间的字节顺序不同，但在本地API之间是一致的。</p><p id="8e4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型化数组使我们能够与这些API进行通信。</p><p id="19d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么他们的字节序不能改变。</p><p id="f35e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">二进制文件和协议的字节顺序跨平台是固定的。</p><p id="3210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据视图允许我们指定字节序，这样我们就可以跨多个平台传输文件并使用不同的协议进行通信。</p><h1 id="35d8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">负指数</h1><p id="99b9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">负指数可与<code class="fe me mf mg mh b">slice</code>方法一起使用。</p><p id="b8eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Index -1表示类型化数组的最后一个元素。</p><p id="1f7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6345" class="mq lc iq mh b gy mr ms l mt mu">const arr = Uint8Array.of(0, 1, 2);<br/>const last = arr.slice(-1);</span></pre><p id="8638" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一些数字创建了一个<code class="fe me mf mg mh b">Uint8Array</code>。</p><p id="9902" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用-1调用了<code class="fe me mf mg mh b">slice</code>，用<code class="fe me mf mg mh b">arr</code>的最后一个条目返回一个类型化数组。</p><p id="96f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">偏移量必须是非负整数。</p><p id="58a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们向<code class="fe me mf mg mh b">DataView.prototype.getInt8</code>方法传递一个负数，我们将得到一个RangeError。</p><h1 id="2038" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组缓冲器</h1><p id="898a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">ArrayBuffers</code>存储数据和视图让我们读取和更改它们。</p><p id="b646" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建DataView，我们需要为构造函数提供一个ArrayBuffer。</p><p id="babc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型化数组构造函数可以有选择地为我们创建ArrayBuffers。</p><p id="e299" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ArrayBuffer</code>构造函数接受一个数组缓冲区长度的数字。</p><p id="91bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们传入的参数是一个ArrayBuffers的视图，那么<code class="fe me mf mg mh b">ArrayBuffer</code>构造函数有<code class="fe me mf mg mh b">isView</code>静态方法返回<code class="fe me mf mg mh b">true</code>。</p><p id="0ac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有类型数组和数据视图有使它们成为视图的<code class="fe me mf mg mh b">[[ViewedArrayBuffer]]</code>内部槽。</p><p id="c090" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ArrayBuffer.prototype.byteLength</code>是一个实例方法，以字节为单位返回ArrayBuffer的容量。</p><p id="804e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个getter方法。</p><p id="1ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ArrayBuffer.prototype.slice(start, end)</code>是一个实例方法，返回一个索引大于等于<code class="fe me mf mg mh b">start</code>小于<code class="fe me mf mg mh b">end</code>的新ArrayByffer。</p><p id="4078" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">start</code>和<code class="fe me mf mg mh b">end</code>可以是负数。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/93b4b5d4de930b6388e59731623b8ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LgS5M2ClTVx1mcAs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@josephbalzanodev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joseph Balzano</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3c2e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="307f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组可以用各种方式包装值。</p><p id="d16c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们必须有正确的字节顺序来正确地存储和交流数据。</p><p id="8554" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ArrayBuffers让我们存储二进制数据并切片。</p><p id="a9d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>