<html>
<head>
<title>Stacks vs Queues with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript的堆栈与队列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stacks-vs-queues-with-javascript-eeb33ae4c93c?source=collection_archive---------19-----------------------#2020-11-23">https://javascript.plainenglish.io/stacks-vs-queues-with-javascript-eeb33ae4c93c?source=collection_archive---------19-----------------------#2020-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="671b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript数据结构系列的第3部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3631dfde82347d0887706cfd8696cc58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MVhdRChLResVPdhR"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@eklektikum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Iva Rajović</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将使用JavaScript来看看堆栈和队列之间的区别。请记住，我将使用数组来解释不同之处。如果您对创建堆栈或队列的最有效方法感兴趣，我建议您创建一个链表。查看我下面的文章，了解更多关于构建单链表的知识。</p><div class="ls lt gp gr lu lv"><a href="https://chadmuro.medium.com/building-a-singly-linked-list-with-javascript-8427733361f8" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">用JavaScript构建一个单链表</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">他们说学东西的最好方法是教它。在这一系列文章中，我将教你关于…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">chadmuro.medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><h1 id="a914" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">堆栈与队列</h1><p id="754d" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">堆栈和队列是添加和删除数据的数据结构。它们之间的区别在于删除数据的顺序。</p><p id="6d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把书库想象成桌子上的一堆书。你可以在这堆书的上面加一本书。当你拿走一本书时，你从书堆的顶部拿走它(这是你在顶部添加的最后一本书)。这是LIFO结构(后进先出)。</p><p id="ae65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把队列想象成一个队列或者一条线。如果你在商店排队购买你的商品，可以在队伍的后面添加一个人。当收银员准备好了，排在队伍前面的人是第一个被帮助的人。这是FIFO结构(先进先出)。</p><h1 id="848c" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">栈和队列用在哪里？</h1><p id="8b53" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">堆栈最常见的用途是在调用堆栈中。您还会看到在使用撤销/重做或路由时。例如，如果您按下浏览器中的后退按钮，您将返回添加到堆栈中的最后一个站点。</p><p id="98db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你需要排队等候时，随时都可以使用队列。一个常见的例子是打印任务。打印机一次只能打印一页，添加到队列中的第一页是打印的第一页。</p><h1 id="e833" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">使用数组创建堆栈</h1><p id="9b9e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">使用数组创建堆栈很简单。我们需要使用push和pop方法在堆栈末尾添加和移除值。这遵循后进先出结构。在下面的例子中，我创建了一个名为stack的新数组，并加入了三个值(我访问过的网站)。为了从数组中移除，我将使用pop方法来移除我添加到堆栈中的最后一个网站。在这种情况下，我们将删除“youtube”。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="07a4" class="nm ml iq ni b gy nn no l np nq">let stack = [];</span><span id="06f5" class="nm ml iq ni b gy nr no l np nq">stack.push('google');<br/>stack.push('medium');<br/>stack.push('youtube');</span><span id="286f" class="nm ml iq ni b gy nr no l np nq">stack.pop();</span></pre><h1 id="934d" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">使用数组创建队列</h1><p id="8218" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">使用数组创建队列与创建堆栈非常相似。唯一的区别是，我们不是使用pop来删除队列末尾的值，而是使用shift来删除队列开头的值。这遵循FIFO结构。在下面的例子中，我们创建了一个具有三个值的队列，分别命名为first、second和third。通过使用shift方法，我们删除了“first”，它是添加到队列中的第一个值。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="b50c" class="nm ml iq ni b gy nn no l np nq">let queue = [];</span><span id="f302" class="nm ml iq ni b gy nr no l np nq">queue.push('first');<br/>queue.push('second');<br/>queue.push('third');</span><span id="7dca" class="nm ml iq ni b gy nr no l np nq">queue.shift();</span></pre><h1 id="50aa" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">堆栈和队列的大O符号</h1><p id="7622" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">堆栈和队列用于插入和删除数据。如果您需要搜索或访问数据，我们通常会使用其他数据结构。在我上面的解释中，我们使用数组来实现堆栈和队列。当处理大量数据时，数组在创建堆栈和队列时效率不高，因为数组还会为每个值创建索引并附加许多其他方法。当添加或删除时，您可能需要重新索引整个数组，这可能导致O(N)时间复杂度。创建堆栈和队列的更好方法是使用链表。</p><p id="1f25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在下面的代码中看到使用链表创建的堆栈和队列。这将确保添加和删除数据的时间复杂度为O(1)。</p><p id="bfc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于堆栈来说，单链表的实现是相同的，只是我们将使用unshift和shift方法，并将它们重命名为push和pop。我们将使用shift和unshift，而不是从单链表中进行push和pop的原因是，pop不是常数时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于队列，我们将使用push添加到列表的末尾，使用shift从列表的开头删除。因为它是一个队列，我们将方法的名称从push改为enqueue，从shift改为dequeue。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="db94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ob">感谢阅读！如果有兴趣了解更多，推荐查看柯尔特·斯蒂尔的Udemy课程，</em> <a class="ae kv" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank"> <em class="ob"> JavaScript算法与数据结构大师班</em> </a> <em class="ob">。如果你错过了本系列的第2部分，在那里我们学习了如何反转一个单链表，请看下面。</em></p><div class="ls lt gp gr lu lv"><a href="https://chadmuro.medium.com/reversing-a-singly-linked-list-with-javascript-a2d3dc58d344" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">用JavaScript反转单向链表</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在我的上一篇文章中，我们用JavaScript构建了一个具有push、pop、shift和unshift功能的单链表。检查…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">chadmuro.medium.com</p></div></div><div class="me l"><div class="oc l mg mh mi me mj kp lv"/></div></div></a></div></div></div>    
</body>
</html>