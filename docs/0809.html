<html>
<head>
<title>Using Angular CDK Portal to create a Modal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角CDK门户网站创建一个模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-angular-cdk-portal-to-create-a-modal-fde843428d83?source=collection_archive---------3-----------------------#2019-12-14">https://javascript.plainenglish.io/using-angular-cdk-portal-to-create-a-modal-fde843428d83?source=collection_archive---------3-----------------------#2019-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/07e9dbd4e75128a2512bef4794ebf59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55jvv9Guyx5ec37w2Bb28Q.png"/></div></div></figure><p id="ce2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">几个月前，我突然想到一件事。我可以有一个单一的、通用的、全局的模态，并且只向它的主体注入一个内容，而不是有几乎一百个模态组件吗？</p><p id="a904" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道这是可能的，我玩动态加载组件已经有一段时间了，并认为这应该可以做到。我只是不知道这种方法是否可扩展。</p><p id="4c52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就在那时，我发现了<a class="ae kt" href="https://material.angular.io/cdk/categories" rel="noopener ugc nofollow" target="_blank">有角度的CDK </a>，更准确地说，是入口的概念。根据安格尔CDK公司的<a class="ae kt" href="https://material.angular.io/cdk/portal/overview" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="ku"><p id="3207" class="kv kw in bd kx ky kz la lb lc ld ks dk translated">一个<code class="fe le lf lg lh b">Portal</code>是一个UI，它可以被动态地呈现到页面上的一个空位上。</p><p id="b667" class="kv kw in bd kx ky kz la lb lc ld ks dk translated">“UI块”可以是一个<code class="fe le lf lg lh b">Component</code>或一个<code class="fe le lf lg lh b">TemplateRef</code>,“开放插槽”是一个<code class="fe le lf lg lh b">PortalOutlet</code>。</p></blockquote></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="c5c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的想法是在<code class="fe le lf lg lh b">app.component</code>级别有一个单一的模态组件，使用一个定制的服务控制和注入模板给它。</p><h2 id="99d7" class="lp lq in bd lr ls lt dn lu lv lw dp lx kg ly lz ma kk mb mc md ko me mf mg mh bi translated">由<a class="ae kt" href="https://valor-software.com/ngx-bootstrap/#/modals#directive-child" rel="noopener ugc nofollow" target="_blank"> ngx-bootstrap </a>供电的模态组件</h2><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">generic-modal.component.html</figcaption></figure><p id="7c0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个基本的模态设置。这里重要的部分是:</p><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="6bd4" class="lp lq in lh b gy mw mx l my mz">&lt;ng-container *cdkPortalOutlet&gt;&lt;/ng-container&gt;</span></pre><p id="6c30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其中<code class="fe le lf lg lh b">cdkPortalOutlet</code>是一个创建一个槽的指令，我们将在这个槽中动态地附加模板。</p><p id="eeac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以将其位置设置为<code class="fe le lf lg lh b">CENTER</code>或<code class="fe le lf lg lh b">RIGHT</code>。最后一件事是，我已经禁用背景点击和ESC键关闭模式，我会得到它在一分钟内。</p><h2 id="7114" class="lp lq in bd lr ls lt dn lu lv lw dp lx kg ly lz ma kk mb mc md ko me mf mg mh bi translated">模态定制服务</h2><p id="161d" class="pw-post-body-paragraph jv jw in jx b jy na ka kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks ig bi translated">我们的定制服务将保存模态的状态，并将与RxJs <code class="fe le lf lg lh b">BehaviorSubject</code>一起工作。我们首先声明几件事:</p><ul class=""><li id="0bf7" class="nf ng in jx b jy jz kc kd kg nh kk ni ko nj ks nk nl nm nn bi translated">一个私人的<code class="fe le lf lg lh b">BehaviorSubject</code>来掌控国家</li><li id="801e" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">一个<code class="fe le lf lg lh b">get state</code>方法，这样模态组件可以监听变化</li><li id="2d8c" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">方法来打开和关闭，这意味着组件将使用模态。</li></ul><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="ddbc" class="lp lq in lh b gy mw mx l my mz">private state$ = new BehaviorSubject&lt;ModalState&gt;(undefined);</span><span id="08b6" class="lp lq in lh b gy nt mx l my mz">get state(): Observable&lt;ModalState&gt; {<br/>  return this.state$.asObservable();<br/>}</span><span id="1321" class="lp lq in lh b gy nt mx l my mz">open(position: ModalPosition) {<br/>  this.state$.next({open: true, position});<br/>}<br/><br/>close() {<br/>  this.state$.next({open: false, position: undefined});<br/>}</span></pre><p id="249c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe le lf lg lh b">ModalState</code>和<code class="fe le lf lg lh b">ModalPosition</code>声明如下:</p><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="5286" class="lp lq in lh b gy mw mx l my mz">export interface ModalState {<br/>  open: boolean;<br/>  position: ModalPosition;<br/>}<br/><br/>export enum ModalPosition {<br/>  <em class="nu">CENTER </em>= 'CENTER',<br/>  <em class="nu">RIGHT </em>= 'RIGHT',<br/>}</span></pre><p id="5d47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是入口部分。我们还将为模板门户提供一个<code class="fe le lf lg lh b">BehaviorSubject</code>,为通用模态组件提供一个getter，为每个“持有”模态的组件提供一个setter。</p><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="4166" class="lp lq in lh b gy mw mx l my mz">private portal$ = new BehaviorSubject&lt;TemplatePortal&gt;(undefined);</span><span id="4857" class="lp lq in lh b gy nt mx l my mz">get portal(): Observable&lt;TemplatePortal&gt; {<br/>  return this.portal$.asObservable();<br/>}</span><span id="10b3" class="lp lq in lh b gy nt mx l my mz">setModalPortal(portal: TemplatePortal) {<br/>  this.portal$.next(portal);<br/>}</span></pre><p id="b257" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe le lf lg lh b">TemplatePortal</code>是Angular CDK声明的一个类。此类的一个实例可以附加到门户网站。</p><p id="8a02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">出于两个原因，我决定将设置门户部分与开放部分分开:</p><ul class=""><li id="cb56" class="nf ng in jx b jy jz kc kd kg nh kk ni ko nj ks nk nl nm nn bi translated">这样父组件就可以控制触发模式打开的事件，但是如果需要的话，拥有模板的子组件负责它的所有逻辑部分，包括设置<code class="fe le lf lg lh b">TemplatePortal</code>。</li><li id="d46d" class="nf ng in jx b jy no kc np kg nq kk nr ko ns ks nk nl nm nn bi translated">所以我们可以在我们的<code class="fe le lf lg lh b">ngOnInit</code>上设置一个<code class="fe le lf lg lh b">TemplatePortal</code>，只在事件发生时打开它。模板已经准备好了，就等着展示了。</li></ul><p id="8876" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们的自定义模态服务如下所示:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk"><a class="ae kt" href="https://gist.github.com/JGhignatti/6aa0cbe68ce982d6a62a56d5a3a19493#file-generic-modal-service-ts" rel="noopener ugc nofollow" target="_blank">generic-modal.service.ts</a></figcaption></figure><h2 id="a542" class="lp lq in bd lr ls lt dn lu lv lw dp lx kg ly lz ma kk mb mc md ko me mf mg mh bi translated">监听我们的定制服务更改并连接门户</h2><p id="ee74" class="pw-post-body-paragraph jv jw in jx b jy na ka kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks ig bi translated">现在回到模态组件，这次是TypeScript文件。首先，我们可以参考ngx-bootstrap的<code class="fe le lf lg lh b">ModalDirective</code>和Angular的<code class="fe le lf lg lh b">CDKPortalOutlet</code>。</p><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="f4ea" class="lp lq in lh b gy mw mx l my mz">@ViewChild('modal', {static: false}) modal: ModalDirective;<br/>@ViewChild(CdkPortalOutlet, {static: false}) portalOutlet: PortalOutlet;</span></pre><p id="88d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在我们的组件的<code class="fe le lf lg lh b">ngOnInit</code>上，我们可以订阅我们的定制服务的<code class="fe le lf lg lh b">Observables</code>。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk"><a class="ae kt" href="https://gist.github.com/JGhignatti/9e79a0ef75d0978ab91acdfd389e94ed#file-generic-modal-component-ts" rel="noopener ugc nofollow" target="_blank">generic-modal.component.ts</a></figcaption></figure><p id="0746" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular CDK的门户工作起来就像打电话一样简单<code class="fe le lf lg lh b">attach</code>，只要记住<code class="fe le lf lg lh b">detach</code>如果你已经连接了一个。</p><h2 id="95a7" class="lp lq in bd lr ls lt dn lu lv lw dp lx kg ly lz ma kk mb mc md ko me mf mg mh bi translated">让我们使用它！</h2><p id="fef2" class="pw-post-body-paragraph jv jw in jx b jy na ka kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks ig bi translated">想象一个Home组件，带有一个打开居中模态的按钮。该组件声明了一个<code class="fe le lf lg lh b">ng-template</code>，用于设置门户。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk"><a class="ae kt" href="https://gist.github.com/JGhignatti/a3dbc24775f39ac5812da536d9c26cd6#file-home-component-ts" rel="noopener ugc nofollow" target="_blank">home.component.ts</a></figcaption></figure><p id="e0c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们再次看到它是多么容易使用角CDK的门户。要创建一个<code class="fe le lf lg lh b">TemplatePortal</code>，你只需要模板本身的<code class="fe le lf lg lh b">TemplateRef</code>和一个<code class="fe le lf lg lh b">ViewContainerRef</code>。</p><h2 id="fbec" class="lp lq in bd lr ls lt dn lu lv lw dp lx kg ly lz ma kk mb mc md ko me mf mg mh bi translated">奇特的结尾</h2><p id="dc8e" class="pw-post-body-paragraph jv jw in jx b jy na ka kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks ig bi translated">这是一个已经工作的通用全局模型，它公开了一个<code class="fe le lf lg lh b">PortalOutlet</code>并接受一个<code class="fe le lf lg lh b">TemplatePortal</code>，但是，等等，我们如何关闭它呢？</p><p id="56ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还记得我禁用背景点击和ESC键吗？这样你就需要有一个按钮或者其他什么东西来调用我们的模态服务的<code class="fe le lf lg lh b">close()</code>，对吗？</p><p id="bb68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，你可以保持背景和ESC启用，监听<code class="fe le lf lg lh b">ModalDirective</code>的<code class="fe le lf lg lh b">onHide</code>或<code class="fe le lf lg lh b">onHidden</code>事件来调用<code class="fe le lf lg lh b">close</code>，这样我们的状态就会保持最新，但这不是一个好方法。相反，我们可以听背景点击和按下ESC键来模仿这种行为，但方法要恰当。返回模式组件类型脚本文件</p><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="a309" class="lp lq in lh b gy mw mx l my mz">@HostListener('mousedown', ['$event'])<br/>onClick(event: any) {<br/>  if (event.target.classList.contains('modal')) {<br/>    this.genericModalService.close();<br/>  }<br/>}<br/><br/>@HostListener('keydown', ['$event'])<br/>onEsc(event: any) {<br/>  if (event.key === 'Escape') {<br/>    this.genericModalService.close();<br/>  }<br/>}</span></pre><h2 id="f751" class="lp lq in bd lr ls lt dn lu lv lw dp lx kg ly lz ma kk mb mc md ko me mf mg mh bi translated">瞧吧</h2><p id="7abd" class="pw-post-body-paragraph jv jw in jx b jy na ka kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks ig bi translated">我们的应用程序中有一个单一的模式，我们有一个定制的服务来控制它，我们可以在应用程序的任何地方向它呈现模板。如果你想的话，你可以今天就到此为止，但是我想提出另一个方案。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="62f1" class="nw lq in bd lr nx ny nz lu oa ob oc lx od oe of ma og oh oi md oj ok ol mg om bi translated">同一页面上的多个模态场景</h1><p id="ad1b" class="pw-post-body-paragraph jv jw in jx b jy na ka kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks ig bi translated">想象你现在有一个二级页面，有两个按钮，每个按钮打开一个不同的模态，意味着不同的模板。</p><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="d461" class="lp lq in lh b gy mw mx l my mz">@Component({<br/>  selector: 'app-secondary',<br/>  template: `<br/>    &lt;app-secondary-first-modal&gt;&lt;/app-secondary-first-modal&gt;<br/>    &lt;app-secondary-second-modal&gt;&lt;/app-secondary-second-modal&gt;<br/><br/>    &lt;div&gt;<br/>        &lt;p&gt;secondary works!&lt;/p&gt;<br/>        &lt;button class="btn btn-primary" (click)="onFirstClick()"&gt;Secondary First Modal&lt;/button&gt;<br/>        &lt;button class="btn btn-primary" (click)="onSecondClick()"&gt;Secondary Second Modal&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>  styleUrls: ['./secondary.component.scss']<br/>})<br/>export class SecondaryComponent { ... }</span></pre><p id="76ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe le lf lg lh b">SecondaryFirstModal</code>的<code class="fe le lf lg lh b">ngOnInit</code>会设置一个<code class="fe le lf lg lh b">TemplatePortal</code>，而<code class="fe le lf lg lh b">SecondarySecondModal</code>的<code class="fe le lf lg lh b">ngOnInit</code>会设置一个不同的。最后初始化的子节点会设置其内容，但第一个子节点不会。我们该如何应对？</p><p id="90ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以让父组件引用其子组件的<code class="fe le lf lg lh b">TemplateRef</code>，但是正如我所说的，我希望模态组件能够独立存在，而不是链接到它的父组件。所以我这里的方法是不同的:输入我们所有的模态！</p><h2 id="00d4" class="lp lq in bd lr ls lt dn lu lv lw dp lx kg ly lz ma kk mb mc md ko me mf mg mh bi translated">在同一页面上处理多个模态</h2><p id="d323" class="pw-post-body-paragraph jv jw in jx b jy na ka kb kc nb ke kf kg nc ki kj kk nd km kn ko ne kq kr ks ig bi translated">我们可以让自定义服务的<code class="fe le lf lg lh b">open</code>方法接受第二个参数<code class="fe le lf lg lh b">modalType</code>，并为其创建一个<code class="fe le lf lg lh b">BehaviorSubject</code>，就像这样。</p><pre class="mi mj mk ml gt ms lh mt mu aw mv bi"><span id="bb35" class="lp lq in lh b gy mw mx l my mz">private type$ = new BehaviorSubject&lt;ModalType&gt;(undefined);</span><span id="04c5" class="lp lq in lh b gy nt mx l my mz">get type(): Observable&lt;ModalType&gt; {<br/>  return this.type$.asObservable();<br/>}</span><span id="0798" class="lp lq in lh b gy nt mx l my mz">open(position: ModalPosition, type?: ModalType) {<br/>  this.type$.next(type);<br/>  this.state$.next({open: true, position});<br/>}</span></pre><p id="2311" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在回到我们的<code class="fe le lf lg lh b">secondary-first-modal.component.ts</code></p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk"><a class="ae kt" href="https://gist.github.com/JGhignatti/74115d894d509d0b21a6a306247b5468#file-secondary-first-modal-component-ts" rel="noopener ugc nofollow" target="_blank">secondary-first-modal.component.ts</a></figcaption></figure><p id="53ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该组件订阅了<code class="fe le lf lg lh b">genericModalService.type</code>变更，当其父组件调用<code class="fe le lf lg lh b">open</code>并传递该组件的特定<code class="fe le lf lg lh b">modalType</code>时，它将接收该信息并将其自己的模板设置到门户出口。</p><p id="7dd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法强调了我们将开放操作与设置门户操作分开的第一个原因。如果需要，子模态也可以对事件做出反应，并且是独立的。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="9108" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在<a class="ae kt" href="https://stackblitz.com/github/JGhignatti/angular-cdk-modal" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>上查看现场工作演示，或者从我的<a class="ae kt" href="https://github.com/JGhignatti/angular-cdk-modal" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获取。</p><div class="on oo gp gr op oq"><a href="https://stackblitz.com/github/JGhignatti/angular-cdk-modal" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd io gy z fp ov fr fs ow fu fw im bi translated">AngularCDKGenericModal</h2><div class="ox l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">stackblitz.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jt oq"/></div></div></a></div><p id="aa8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在我的推特上联系我。</p></div></div>    
</body>
</html>