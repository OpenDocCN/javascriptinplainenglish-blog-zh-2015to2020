<html>
<head>
<title>Achieving separation of concerns using Events in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js中的事件实现关注点分离</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/achieving-separation-of-concerns-using-events-in-nodejs-40e23b1d5c3b?source=collection_archive---------8-----------------------#2020-08-25">https://javascript.plainenglish.io/achieving-separation-of-concerns-using-events-in-nodejs-40e23b1d5c3b?source=collection_archive---------8-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/f7b5169121b3058c9d2c883b573c708d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*2Ljlw-HH014Uy9uYDsAu2Q.png"/></div></figure><div class=""/><p id="8f2a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">关注点分离(SoC) </strong>软件设计和架构中的一个重要概念，它是关于将系统分解成高度独立且在功能上略有重叠的部分。</p><p id="78cd" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于OOP语言来说，<strong class="jw iy">封装</strong>和<strong class="jw iy">继承</strong>是实现SoC的主要方式之一。<strong class="jw iy">事件驱动编程(EDP) </strong>也可以是SoC中的一个主要概念，理想情况下，抛出事件的模块不应该知道将处理它们的模块。在本文中，我将通过一个真实的例子带您在<strong class="jw iy"> NodeJS </strong>中实现EDP。</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><h1 id="85ab" class="kz la ix bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">带示例的基本概念</h1><p id="0c20" class="pw-post-body-paragraph ju jv ix jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">我将谈论一个人工智能系统，它处理输入，在几个状态之间移动，并相应地采取行动。我可以举一个通过Q学习算法进行强化学习的例子。</p><p id="2d51" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然Q-learning算法的核心思想是使用奖励来优化代理的知识库，但是动作执行将是可以从学习过程中分离出来的另一个主题。</p><p id="1bc8" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个例子是Pacman游戏，其中动作将被限制在下面的列表中(上移-下移-左移-右移), SoC将通过分离Q-Learning算法实现和将动作应用于屏幕以将Pacman移动到其中一个方向来实现。</p><figure class="md me mf mg gt is gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/ba7f6b045a1b9e9309772695595f5202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/0*68uqTEEyv5tWBHak.gif"/></div></figure><p id="92f5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我的例子中，我将使用一个非常有趣的库来实现事件驱动系统:</p><div class="ip iq gp gr ir mh"><a href="https://www.npmjs.com/package/events" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd iy gy z fp mm fr fs mn fu fw iw bi translated">事件</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">所有引擎的节点事件发射器。这为没有Node.js模块的环境实现了node . js模块，比如…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">www.npmjs.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv it mh"/></div></div></a></div><p id="dfe4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">库中EventEmitter组件支持通过“Emitter”函数调度事件的能力，以及使用“on”函数将处理程序附加到事件的能力，接下来我们将更多地讨论这些概念。</p><p id="2c85" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事件驱动的系统通常由以下部分组成:</p><ul class=""><li id="9e87" class="mw mx ix jw b jx jy kb kc kf my kj mz kn na kr nb nc nd ne bi translated"><strong class="jw iy"> Event: </strong>系统内部可能发生的事件类型，在我们的例子中是(Top，bottom，Left，Right)并且可以使用enum实现，我在events.js文件内部实现了该文件，该文件导出以下仅由键值对组成的对象，如果您不希望任何人错误地修改该对象，一个好的做法是对该对象使用<a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank"> Object.freeze() </a>:</li></ul><figure class="md me mf mg gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/66ff6e39c1dfdd672531c09d9b78e1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmtbJQoxDDvo8G66rkbmCg.png"/></div></div></figure><ul class=""><li id="d73e" class="mw mx ix jw b jx jy kb kc kf my kj mz kn na kr nb nc nd ne bi translated"><strong class="jw iy">事件处理程序:</strong>一个将被附加到事件的函数，因此每当调度程序调度该事件时，该函数将被触发以用特定的逻辑来处理该事件，我将通过一个由作为函数的处理程序组成的类来实现它，在初始化函数中，我将传递调度程序，并根据事件类型将事件处理程序与该调度程序链接起来，如下所示:</li></ul><figure class="md me mf mg gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nl"><img src="../Images/fb0e7a6c3085179fabbcc29b62227c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxL12ElXN8pLUbMmRbXR2g.png"/></div></div></figure><ul class=""><li id="9eee" class="mw mx ix jw b jx jy kb kc kf my kj mz kn na kr nb nc nd ne bi translated"><strong class="jw iy">事件分派器:</strong>根据特定上下文分派事件的核心，下面是一个简单的例子:</li></ul><figure class="md me mf mg gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nm"><img src="../Images/33fecffdd2bbde1cee8147db1117890c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBwGiEOjkjL0eoL9ghZMiA.png"/></div></div></figure><p id="66a5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简而言之，QCore是我的主要组件，负责Q-Learning算法，决定下一个状态，并分派应该采取的行动。然后任何其他处理程序可以监听这些事件来移动Pacman，做一些日志记录，给某人发送消息…等等。请注意，多个处理程序可以附加到同一个事件上，最好将每组处理程序封装在一个特定的类中，每个类都有一个单独的职责，比如日志记录、通信、渲染等等。</p><p id="3e0b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">注意:</strong>我使用了一个库来实现事件驱动系统，但是你也可以自己设计，接下来是一个非常基本的例子，说明如何用Javascript来实现:</p><figure class="md me mf mg gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nl"><img src="../Images/c02aa1d79f2994551d5a16e4d95a4722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QPgxcHWtCxOhlnKqModjQ.png"/></div></div></figure><p id="fad0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我相信一个例子总是比理论演讲更有助于更快地理解案例。我的例子是在人工智能中，但你可以在任何领域应用该模式，大多数时候，当你有一个管道来处理一些输入，你还想做一些与处理业务逻辑无关的其他事情时，那么最好的解决方案之一是为管道中的每一步分派事件，然后根据其他需要设计处理程序模块来处理事件。</p><p id="0258" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我希望这种模式的快速概述可以帮助开始新项目的人，因为我知道在预先设计的项目中实现这一点并不容易，将包括大量的重构和测试:)但是相信我，如果您的项目在功能上有很多重叠，您会非常高兴。</p></div></div>    
</body>
</html>