<html>
<head>
<title>Serverless: 3 things AWS Cognito needs to be production ready</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器:AWS Cognito需要做好生产准备的3件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/serverless-things-i-wish-i-had-known-before-i-started-part-1-aws-cognito-cf5d3a0c3d9d?source=collection_archive---------0-----------------------#2019-10-01">https://javascript.plainenglish.io/serverless-things-i-wish-i-had-known-before-i-started-part-1-aws-cognito-cf5d3a0c3d9d?source=collection_archive---------0-----------------------#2019-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/780fc60c4d8f90effeee498b4d92df8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*Imz8oo5JvU1Zf3qj6PyyVw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Image from <a class="ae jy" href="https://www.kaspersky.com.au/blog/security-week-digest-33/9591/" rel="noopener ugc nofollow" target="_blank">https://www.kaspersky.com.au/blog/security-week-digest-33/9591/</a></figcaption></figure><p id="0141" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">上周我分享了一篇文章，“无服务器:学习如何在你的团队中实现it，而不使他们成为AWS云架构师专家”，鼓励公司和团队实现无服务器架构。然而，作为一个相当近期推出的架构，该工具可能没有(如果有的话)一个简单的方法来实现一些必要的功能，这可能会给新用户带来困难。因此，我将讲述一系列我希望在开始使用AWS Cognito用户池之前就知道的事情。</p><h1 id="0a53" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">认证:Cognito提供什么，真正需要什么。</strong></h1><p id="8e14" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated"><em class="ma"> Cognito用户池是用于无服务器架构的AWS资源，其目的是提供基于云的服务，通过API(或其他服务，如</em> <a class="ae jy" href="https://aws-amplify.github.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> Amplify </em> </a> <em class="ma">)可以对用户进行身份验证。它提供了几个级别/类型的配置，其实现非常简单。</em></p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mb"><img src="../Images/d3f81e0f7957d92730caaac4897b1d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ab4Ggi6D_wZJZtRbmfkIfA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Cognito User Pool AWS Console</figcaption></figure><p id="1947" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">虽然有机会通过一个独特的独立工具来管理访问控制可能令人兴奋，并且所提供的配置级别可以覆盖几乎所有的用户需求，但仍然存在一些问题，如令牌无效、缺少备份和个性化身份验证，这将需要AWS做一些额外的工作。</p><p id="6c56" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir"> 1。令牌失效</strong></p><p id="28fa" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">考虑一个web应用程序用户案例，在用户登录并保持非活动状态一段时间(比如15分钟)后，他们将被注销。看起来很简单，对吧？不完全是。尽管amplify的Auth模块会自动运行令牌验证并在必要时刷新令牌，但为客户端配置的最短过期时间是1小时。因此，如果需要实现更短的有效期，则必须通过客户端手动完成。</p><p id="ea73" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">有人可能会想:“这不是什么大问题，因为这是一个易于实现的解决方案”。如果不是因为令牌不会在1小时之前失效，这一点没有争议。是的，用户注销，但生成的令牌仍然可以使用。换句话说:用户登录应用程序并收到一个令牌，然后，考虑到他们已经有一段时间不活动，应用程序检测到它并执行注销API方法。用户已注销，但是，使用此令牌向API(使用与授权者相同的Cognito)发出的任何请求将在1小时内被接受。不幸的是，这还没有得到解决，但至少，有一个公开的<a class="ae jy" href="https://github.com/aws-amplify/amplify-js/issues/3435" rel="noopener ugc nofollow" target="_blank">问题</a>。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5a4edd74ee2c49f1597f32e5d97f5af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*GxjQbKRz99tay_mFpvItng.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Cognito Token Invalidation Flow</figcaption></figure><p id="4763" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir"> 2。集成代理验证</strong></p><p id="6e89" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="ma">代理集成是一个选项，其中API路径可以以这样一种方式配置，到该路径的每个请求将被重定向到另一个配置的url API </em>。</p><p id="7513" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">考虑到并非所有的方法都需要重新实现，使用代理可能会非常方便，但是应用程序仍然需要在转发用户请求之前对用户进行身份验证。最方便的选择应该是Cognito，但在这种情况下，它带来的限制多于灵活性。</p><p id="31aa" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">将Cognito实现为代理身份验证并不是一个很大的挑战，因为有一种简单的方法来配置它，但是如果需要一些额外的业务逻辑来验证用户的请求呢？设想一个与第三方服务集成的应用程序，它返回给定乘客的航班详细信息。即使用户A在应用程序中通过了身份验证，他们也不能请求用户B的数据，除非他们拥有“管理员”角色。换句话说，仅仅因为一个用户注册了一个密码，并不意味着他们可以访问所有应用程序的服务。不幸的是，由于集成代理的配置方式，在转发请求之前没有执行lambda函数。在这种情况下，如何根据用户的详细信息或角色来验证用户从代理访问数据？</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ml"><img src="../Images/48c7c8b9ea6fb18062ccb8f91059033e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yY92gSZudhnnwk1skEAIQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">AWS Architecture of Lambda and HTTP Proxy</figcaption></figure><blockquote class="mm mn mo"><p id="9df3" class="jz ka ma kb b kc kd ke kf kg kh ki kj mp kl km kn mq kp kq kr mr kt ku kv kw ij bi translated">使用Cognito无法做到这一点，因为在授权后没有执行lambda函数的选项。</p></blockquote><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ms"><img src="../Images/c2bbc975ab92394f311779b5c0ea0701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vL0BkNWSsHEoCpi1YFSpFg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">API Gateway Authorizer Configuration</figcaption></figure><p id="7891" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">虽然很少有人会想到(这非常符合逻辑)仔细检查Cognito的配置，试图找到一种在请求令牌验证之后执行代码的方法，但Cognito处理与注册和登录相关的事件，而不是令牌验证。事实上，API Gatway是一个组件，它使用Cognito处理令牌验证，然后将请求重定向到Lambda或代理。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ms"><img src="../Images/c85282c598538ab5de66fee0232bfe14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKPg97e0lIERigG7o791Cw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Cognito User Pool — Triggers</figcaption></figure><p id="9229" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">可能的解决方案是什么？不使用Cognito内置授权器，而是构建一个定制的lambda授权器，然后将其用于代理端点。这种方法的好处是可以根据用户的详细信息、角色以及请求路径和方法灵活地定义规则。然而，也有一些权衡:</p><ol class=""><li id="48b3" class="mt mu iq kb b kc kd kg kh kk mv ko mw ks mx kw my mz na nb bi translated">Cognito auth令牌需要手动解密，在这种情况下，这意味着要编写一些额外的代码，并重写已经存在的代码。</li><li id="9380" class="mt mu iq kb b kc nc kg nd kk ne ko nf ks ng kw my mz na nb bi translated">无法缓存Cognito令牌。虽然授权者允许配置缓存周期(这样，为了节省时间，API网关将跳过令牌验证，直到缓存过期)，但因为每个端点可能有不同的业务规则，所以这种情况不太可能适用。</li></ol><p id="9e71" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">2020年3月25日更新:</strong>代码示例</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Example of a customised lambda authorizer</figcaption></figure><p id="babf" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">另一个要考虑的方法是重写第三方的每个方法，并通过lambda函数发出请求。这样，在发出请求之前，就可以验证用户的详细信息和角色。</p><p id="7c0d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">目标是了解应用程序将使用多少第三方API，以及将包含多少第三方API的方法。意识越强，就越容易决定什么对项目更好。</p><p id="af01" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir"> 3。用户数据备份怎么办？</strong></p><p id="89c0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">作为一个独立的访问控制工具，Cognito拥有自己的用户和组实体，不需要任何外部数据库存储。然而，它们没有提供备份或导出这些数据的方法- <a class="ae jy" href="https://forums.aws.amazon.com/thread.jspa?threadID=296932" rel="noopener ugc nofollow" target="_blank">问题参考</a>。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nj"><img src="../Images/27701cddca95fa5fb8ff2359f21ec868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLVh6Jv5ksW1Ph3qa58pKA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Cognito User Pool without option to Export Users</figcaption></figure><p id="557f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">完全可以理解的是，云服务的原则之一是“信任”，这意味着他们保证服务将始终可用和稳定。但是如果有人不小心删除了Cognito资源呢？如果需要将用户迁移到另一个服务，该怎么办？记住为什么要有数据库备份的原因，由于缺少这些选项而导致的潜在问题是数不胜数的。</p><p id="320a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">尽管忽略这一点的简单决定就足够了，但考虑到更愿意为某一情况做好准备而不是事后准备，找到导出数据的方法被认为更安全。找到的解决方案是创建一个调度lambda(与cron作业中的概念相同),它将调用Cognito API，提取用户的详细信息，将它们导出到文件中，然后上传到某个存储服务中。因为一个<a class="ae jy" href="https://www.npmjs.com/~mifi" rel="noopener ugc nofollow" target="_blank"> npm合作者</a>编写了这个伟大的<a class="ae jy" href="https://www.npmjs.com/package/cognito-backup" rel="noopener ugc nofollow" target="_blank">认知备份模块</a>，它将完成所有将数据提取到文件的工作，不需要编写太多代码。因此，最终的解决方案是一个包含两个步骤的脚本:备份和上传。</p><p id="0faf" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">结论</strong></p><p id="7a21" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">作为一个新的框架，有一些选项对业务来说可能很重要，但它们可能仍然是提供商所缺少的。因此，有必要进行一些分析性修订，以检查是否存在不同解决方案的可能性，或者是否根本不可能(并接受它)。这篇文章是为了分享一些“糟糕”的经历和一个潜在的解决方法。</p><p id="385f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">更重要的是，值得强调的是，不管强调了哪些要点，AWS和无服务器框架在根据用户需求更新其服务方面一直做得很好，因此，毫无疑问，最终很少有人会很快被修复。</p><p id="f75c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">资源</strong></p><p id="64b7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><a class="ae jy" href="https://aws-amplify.github.io/" rel="noopener ugc nofollow" target="_blank">https://aws-amplify.github.io/</a><br/><a class="ae jy" href="https://www.kaspersky.com.au/blog/security-week-digest-33/9591/" rel="noopener ugc nofollow" target="_blank">https://www . Kaspersky . com . au/blog/security-week-digest-33/9591</a><a class="ae jy" href="https://github.com/aws-amplify/amplify-js/issues/3435" rel="noopener ugc nofollow" target="_blank">https://github.com/aws-amplify/amplify-js/issues/3435</a><br/>T16】https://forums.aws.amazon.com/thread.jspa?threadID=296932<a class="ae jy" href="https://www.npmjs.com/package/cognito-backup" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/cognito-backup</a></p><h2 id="cb26" class="nk ky iq bd kz nl nm dn ld nn no dp lh kk np nq ll ko nr ns lp ks nt nu lt nv bi translated"><a class="ae jy" href="https://medium.com/@cbernardes/serverless-things-i-wish-i-had-known-part-2-dynamodb-x-mongodb-x-aurora-serverless-1053cfddff36?source=friends_link&amp;sk=a0891772e2c260bdcbd4cd365d91254d" rel="noopener"> <strong class="ak">第二部——DynamoDB x MongoDB x</strong>傲罗<strong class="ak"> a </strong> </a> <strong class="ak"> → </strong></h2></div></div>    
</body>
</html>