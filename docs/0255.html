<html>
<head>
<title>Round and Round the JavaScript Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一圈又一圈的JavaScript循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/round-and-round-the-javascript-loop-7111e5cfa6ac?source=collection_archive---------4-----------------------#2019-09-06">https://javascript.plainenglish.io/round-and-round-the-javascript-loop-7111e5cfa6ac?source=collection_archive---------4-----------------------#2019-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d917f79e693e0424f7e0de81cafe3263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*rS84-uP7EDVXaQIDoNYq-w.gif"/></div></figure><p id="071d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">JavaScript是单线程的，这意味着它一次只能做一件事。当你调用一个函数时，它被压入调用栈，当函数返回时，它被弹出栈。这个限制实际上是有帮助的，因为它允许您编写程序而不用担心并发问题。但是，由于它的单线程特性，您必须避免“阻塞”代码</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="b1ff" class="lb lc iq kx b gy ld le l lf lg">function blocking () {<br/>  while(true) {<br/>    console.log('This goes on forever'<br/>  }<br/>}</span><span id="6166" class="lb lc iq kx b gy lh le l lf lg">blocking()</span></pre><p id="507a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当这个函数被同步调用时，它会阻塞主线程，因为函数永远不会解析。如果您在浏览器中运行这段代码，窗口将变得没有响应。这是因为主线程正忙于while循环，而且由于JavaScript只有一个线程，所以它不能一次处理多件事情。</p><p id="b902" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们看一个更现实的例子，假设您正在对一个API进行fetch调用以检索一些数据。如果这个动作是同步发生的，那么在主JS线程等待从服务器返回数据的时候，我们的页面会有几秒钟没有响应，但是我们知道事实并非如此，那么javascript是如何处理异步任务的呢？</p><h2 id="2c6b" class="lb lc iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">Web APIS</h2><p id="2317" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">浏览器由JavaScript引擎和许多其他应用程序组成，这些应用程序允许发送HTTP请求和监听DOM事件等多种功能。该功能通过WebAPIs向JavaScript公开</p><p id="c52c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Web APIs异步运行，这意味着它们可以在后台执行任务，并且保持主JavaScript线程畅通。完成任务后，web API使用回调函数将数据返回到主JavaScript线程中。让我们看一个简单的例子</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="cc32" class="lb lc iq kx b gy ld le l lf lg">function logger() {<br/>  console.log('Starting...');<br/>  setTimeout(() =&gt; console.log(`setTimeout finished!`), 1000);<br/>  console.log('Finished!');<br/>}</span><span id="7b2c" class="lb lc iq kx b gy lh le l lf lg">logger()</span></pre><p id="a913" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在浏览器中运行这段代码如下所示:</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/326a71e19dff0a0a17873db9b78cd3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEkWJzixzSonUjt1R19jwQ.png"/></div></div></figure><p id="7013" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么像setTimeout这样的函数是如何进入Web API领域，然后再回到JavaScript领域的呢？</p><h2 id="f571" class="lb lc iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">事件循环</h2><p id="3ec3" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">事件循环负责处理JavaScript线程上接下来运行什么代码。事件循环按顺序将函数调用逐个添加到调用堆栈中。看一下上面的例子，logger()函数将被推送到堆栈上。该函数首先调用console.log，它将被推送到堆栈上，立即执行，然后弹出堆栈。接下来，setTimeout函数被推到堆栈上，但是这次不是记录字符串“setTimeout finished！”setTimeout函数通过web API异步发生，在返回主线程之前，它将等待1000毫秒。然后JavaScript将setTimeout弹出堆栈并调用最终的console . log。logger()函数随后返回并弹出堆栈。该函数返回后，调用堆栈完全为空，事件循环将获取我们传递给setTimeout的回调函数，并将其推送到堆栈上。</p><h2 id="9dbb" class="lb lc iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">消息(回调/任务)队列</h2><p id="e816" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">当调用setTimeout时，浏览器将通过web API启动一个计时器，主线程上的代码执行将继续。当计时器到期时，传递给setTimeout的回调函数将被添加到消息队列中。一旦调用堆栈为空，事件循环就会查看消息队列，并检查是否有任何函数正在排队等待执行。如果它发现任何排队的回调函数，它将把它们推到堆栈上并执行它们。事件循环优先考虑调用堆栈，只在堆栈完全为空时查看消息队列。</p><p id="11ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是浏览器整体外观的示意图:</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/628ec79e1bac3d316031e4298535aff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZnTJxGdNibqHvSpQveKzw.png"/></div></div></figure><h2 id="5664" class="lb lc iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">JavaScript运行时可视化工具</h2><p id="1b3c" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">为了进一步探索JavaScript在幕后做了什么，看看这个由菲利普·罗伯茨制作的叫做<a class="ae mk" href="http://latentflip.com/loupe/" rel="noopener ugc nofollow" target="_blank">放大镜</a>的工具。</p><p id="5b80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你对这个话题感兴趣，想了解更多，请查看JS CONF的这些讲座:</p><p id="467f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mk" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0" rel="noopener ugc nofollow" target="_blank">在回路中</a></p><p id="d159" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mk" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">到底什么是事件循环？</a></p></div></div>    
</body>
</html>