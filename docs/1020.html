<html>
<head>
<title>JavaScript: Reviewing Primitive and Non-Primitive Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:检查原始和非原始数据类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-reviewing-primitive-and-non-primitive-data-types-5bc4ca68c3de?source=collection_archive---------2-----------------------#2020-01-16">https://javascript.plainenglish.io/javascript-reviewing-primitive-and-non-primitive-data-types-5bc4ca68c3de?source=collection_archive---------2-----------------------#2020-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7234" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JS价值观与参考文献简评</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/72ea0491a6f3f8b8b62456044fd3820d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OIN6HJhz27kx5P9B"/></div></div></figure><p id="f3d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这篇博客中，我将回顾我对两种不同数据类型的理解:<strong class="kq io">原语</strong>和<strong class="kq io">非原语</strong>。</p><p id="0b7e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它们代表了数据在内存中存储的两种不同方式。</p><blockquote class="lk ll lm"><p id="a73e" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">如果你对这个话题足够熟悉，你可以跳到博客结尾的结论。</p></blockquote></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="fdcd" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">什么是数据类型？</h1><p id="7f01" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">如果您对代码有一点点了解，您应该知道有各种不同的数据“类型”。</p><p id="ae85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">某些函数可能只适用于特定的数据类型。</p><p id="1de5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="2c3b" class="na lz in mw b gy nb nc l nd ne">// The following is possible:</span><span id="32c9" class="na lz in mw b gy nf nc l nd ne">5 * 3 // 15<br/>"ha" + "ppy" // "happy"</span><span id="86b0" class="na lz in mw b gy nf nc l nd ne">// The following is not possible:</span><span id="3672" class="na lz in mw b gy nf nc l nd ne">"ben" * 2 // NaN You cannot multiply a string<br/>"hope" - "o" // NaN You cannot subtract a string from another string</span></pre><p id="9eae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同时，不同的数据类型以不同的方式存储在计算机的内存中。</p><h1 id="4348" class="ly lz in bd ma mb ng md me mf nh mh mi jt ni ju mk jw nj jx mm jz nk ka mo mp bi translated">原始与非原始</h1><p id="a95a" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">在我讨论数据类型的两个类别之前，我将列出哪些数据类型属于哪个类别。</p><h2 id="7c8b" class="na lz in bd ma nl nm dn me nn no dp mi kx np nq mk lb nr ns mm lf nt nu mo nv bi translated">原始的</h2><ol class=""><li id="cc5e" class="nw nx in kq b kr mq ku mr kx ny lb nz lf oa lj ob oc od oe bi translated">数字</li><li id="0bfd" class="nw nx in kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated">用线串</li><li id="e1bf" class="nw nx in kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated">布尔运算</li><li id="9c6a" class="nw nx in kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated">不明确的</li><li id="cd74" class="nw nx in kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated">空</li></ol><h2 id="1a31" class="na lz in bd ma nl nm dn me nn no dp mi kx np nq mk lb nr ns mm lf nt nu mo nv bi translated">非原语(统称为对象)</h2><ol class=""><li id="79b9" class="nw nx in kq b kr mq ku mr kx ny lb nz lf oa lj ob oc od oe bi translated">目标</li><li id="e382" class="nw nx in kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated">数组</li><li id="2933" class="nw nx in kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated">功能</li></ol><p id="5260" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这两个类别代表了这些数据类型存储到内存中的两种不同方式。图元由<strong class="kq io">值</strong>存储，而非图元(对象)由<strong class="kq io">引用</strong>存储。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="6e16" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看一个如何存储<strong class="kq io">原语</strong>的例子:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="5279" class="na lz in mw b gy nb nc l nd ne">let a = 5<br/>let b = a<br/>console.log(a) // 5<br/>console.log(b) // 5<br/>console.log(a === b) // true</span><span id="f310" class="na lz in mw b gy nf nc l nd ne">a = 10<br/>console.log(a) // 10<br/>console.log(b) // 5<br/>console.log(a === b) // false</span></pre><p id="e958" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里发生了什么？</p><blockquote class="lk ll lm"><p id="2e13" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">我们设置两个不同的变量:<strong class="kq io"> a </strong>和<strong class="kq io">b</strong>T14】。</p><p id="97a9" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><strong class="kq io">一个</strong> <em class="in"> </em>被设置为等于5。</p><p id="985c" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><strong class="kq io"> b </strong> <em class="in"> </em>被设置为等于<strong class="kq io"> <em class="in"> a </em> </strong>。</p><p id="560d" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">然后我们把<strong class="kq io"> a </strong> <em class="in"> </em>的值改成等于10。</p><p id="c955" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">然而不知何故，<strong class="kq io"> b </strong> <em class="in"> </em>的值还是5！</p></blockquote><p id="6ec6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是因为原语是按值存储的。</p><p id="7379" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着，每当我们决定使用原始数据类型声明一个新变量时，我们就在内存中为该值创建了一个新地址。</p><p id="2b83" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们回头看看我们的例子:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="4d26" class="na lz in mw b gy nb nc l nd ne">let a = 5<br/>let b = a</span></pre><p id="82dc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> a </strong>的数据类型是一个原始数据类型的数字。它的<em class="ln">值</em>为5。</p><p id="0c1b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> b </strong>的数据类型也是数字。它的值为<strong class="kq io"> a </strong>。</p><p id="2196" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，变量<strong class="kq io"> b </strong>存储的不是变量<strong class="kq io"> a </strong>本身，而是变量的值。</p><p id="fd2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> a </strong>的值为5，因此<strong class="kq io"> b </strong>将5存储到其地址中。</p><p id="3f51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">稍后，即使我们决定改变<strong class="kq io"> a </strong>的值，这也不会影响已经存储在<strong class="kq io"> b </strong>中的值。</p><p id="ffce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这也是为什么现在我们比较两者的时候，两者不再等同。</p><p id="c3c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们来看看<strong class="kq io">非原语(对象)</strong>:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="d938" class="na lz in mw b gy nb nc l nd ne">let a = [10]<br/>let b = a<br/>console.log(a === b) // true</span><span id="def3" class="na lz in mw b gy nf nc l nd ne">a.push(10)<br/>console.log(a) // [10, 10]<br/>console.log(a === b) // true</span></pre><blockquote class="lk ll lm"><p id="55bf" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">我们设置两个不同的变量:<strong class="kq io"> a </strong>和<strong class="kq io"> b </strong>。</p><p id="eee5" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><strong class="kq io">一个</strong>被设置为等于一个保存单个值的数组:10。</p><p id="de27" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated"><strong class="kq io"> b </strong>被设置为等于<strong class="kq io"> a </strong>。</p><p id="27b9" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">比较<strong class="kq io"> a </strong>和<strong class="kq io"> b </strong>返回<strong class="kq io">真值</strong>。</p><p id="191b" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">接下来我们修改了<strong class="kq io"> a </strong>中的数据。</p><p id="5633" class="ko kp ln kq b kr ks jo kt ku kv jr kw lo ky kz la lp lc ld le lq lg lh li lj ig bi translated">然而，再次比较这两个变量，我们仍然返回<strong class="kq io"> true </strong>。</p></blockquote><p id="d66c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其原因是由于非原语(对象)是通过引用存储的。</p><p id="fc00" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这么看吧:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="c071" class="na lz in mw b gy nb nc l nd ne">let a = [10]<br/>let b = a</span><span id="b6ac" class="na lz in mw b gy nf nc l nd ne">// the variable a is referencing the address of the array object [10]<br/>// the variable b is referencing the address of the variable a which is pointing to the address of [10]</span></pre><p id="4229" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">基本上，当处理非原始数据类型时，我们总是存储指向一个地址的指针。</p><p id="d9fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">既然是这样，如果我们修改指向相同地址的任何变量，我们将改变存储在地址本身内的值。</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="4ea1" class="na lz in mw b gy nb nc l nd ne">let a = []<br/>let b = a<br/>let c = b</span><span id="e52f" class="na lz in mw b gy nf nc l nd ne">a.push(1)<br/>console.log(a) // [1]<br/>console.log(b) // [1]<br/>console.log(c) // [1]</span><span id="8708" class="na lz in mw b gy nf nc l nd ne">b.push(2)<br/>console.log(a) // [1, 2]<br/>console.log(b) // [1, 2]<br/>console.log(c) // [1, 2]</span></pre><p id="808b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们从另一个角度来看这个问题:</p><pre class="kd ke kf kg gt mv mw mx my aw mz bi"><span id="5f8f" class="na lz in mw b gy nb nc l nd ne">console.log([10] === [10])</span></pre><p id="5ca7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你认为上面那行代码的结果是什么？</p><p id="5a2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">想想吧…</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cf0aa374812b530ab19af423ed8084e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3JYsY41LCV07qd_d"/></div></div></figure><p id="8581" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在那一行代码中，我们到底在比较什么？</p><p id="0c49" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">他们指向同一个地址吗？</p><p id="09cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">答案？</p><p id="7f5b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">假的！</strong></p><p id="9859" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为什么会这样呢？</p><p id="e505" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从表面上看，它们都包含相同的值，都是数组，都包含一个具有相同值(10)的元素。</p><p id="f055" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，您比较的不是值，而是地址。</p><p id="38f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">左边的<strong class="kq io">【10】</strong>与左边的<strong class="kq io">【10】</strong>在内存中的地址不同。</p><p id="52a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相等运算符(===)检查它们是否指向同一个地址，这就是结果为假的原因。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="de32" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">结论</h1><p id="fbeb" class="pw-post-body-paragraph ko kp in kq b kr mq jo kt ku mr jr kw kx ms kz la lb mt ld le lf mu lh li lj ig bi translated">原始数据类型由<strong class="kq io">值</strong>存储。非原始数据类型由<strong class="kq io">引用</strong>存储。当声明一个变量时，你通常会创建一个潜在的新地址。</p><p id="e653" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在存储原语的情况下，该变量指向该原语值的新地址。当存储一个原始值(即使它只是一个被设置为值的变量)时，您是在将一个值本身存储到一个新地址中。</p><p id="e791" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在非基本对象的情况下，变量保存对对象的引用。它不是为一个值创建一个新的地址，只是一个指向对象的指针。如果你修改一个指向地址的变量，你实际上是在修改存储在地址中的数据。</p></div></div>    
</body>
</html>