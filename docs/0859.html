<html>
<head>
<title>Fewest Flights — A Breadth First Search Sample Problem and Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最少航班—广度优先搜索样本问题及解决方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fewest-flights-a-breadth-first-search-sample-problem-and-solution-72c5224c71af?source=collection_archive---------5-----------------------#2019-12-23">https://javascript.plainenglish.io/fewest-flights-a-breadth-first-search-sample-problem-and-solution-72c5224c71af?source=collection_archive---------5-----------------------#2019-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/da120cca2992884ac0af895d71b1b9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hG1Fx57Ltdc013G5JDP_cw.jpeg"/></div></div></figure><p id="34ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个广度优先搜索的示例问题。为了快速阅读这是什么，以及对图形的基本理解，请阅读<a class="ae kw" href="https://medium.com/javascript-in-plain-english/data-structures-understanding-graphs-82509d35e6b5" rel="noopener">这个</a>。</p><p id="7117" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题陈述:</strong>有<strong class="ka ir"> n </strong>个城市通过<strong class="ka ir"> m </strong>个航班连接。每次战斗从城市<strong class="ka ir"> u </strong>出发，到达城市<strong class="ka ir"> v </strong>。</p><p id="d53b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在给定所有的城市和航班，以及起始城市<strong class="ka ir"> src </strong>和目的地<strong class="ka ir"> dst </strong>，任务是找出从<strong class="ka ir"> src </strong>到<strong class="ka ir"> dst </strong>所需的最少航班数。如果没有这条路线，输出<strong class="ka ir"> -1 </strong>，如果<strong class="ka ir"> src </strong>和<strong class="ka ir"> dst </strong>相同，输出<strong class="ka ir"> 0 </strong>。</p><p id="607d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于给定的输入:</p><blockquote class="kx ky kz"><p id="37d2" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">src--&gt; " ATL " dest--&gt; " NYC "航班--&gt;[["ATL "，" NYC"]，["NYC "，" LA"]，[" ATL "，" MIA"]]</p></blockquote><p id="5c8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5c56" class="ln lo iq lj b gy lp lq l lr ls">const fewestFlights = function(src, dest, flights) {<br/>    const graph = toAdjacencyList(flights);<br/>    const queue = [];<br/>    const visited = new Set();<br/>    visited.add(src);<br/>    queue.push(src);</span></pre><p id="f03d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用广度优先搜索找到从src(源)到dest(目的地)的最短航班数。我们希望使用numberOfFlights来存储到达每个位置需要多少次飞行。</p><p id="e178" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要写一个函数，它接受一个边列表，并返回一个邻接表。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d081" class="ln lo iq lj b gy lp lq l lr ls">const toAdjacencyList = function(edgeList) {<br/>    const adjacencyList = {};<br/>    for (let edge of edgeList) {<br/>      const src = edge[0];<br/>      const dest = edge[1];</span><span id="859e" class="ln lo iq lj b gy lt lq l lr ls">      if (adjacencyList[src] != undefined) {<br/>          adjacencyList[src].push(dest);<br/>      } else {<br/>          adjacencyList[src] = [dest];<br/>      }<br/>    }<br/>    return adjacencyList;<br/>}</span></pre><p id="fdec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤1:创建一个名为numberOfFlights的对象来跟踪到达一个城市的航班次数。关键是城市，价值是到达那个城市的航班数。</p><p id="1cb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lj b">const numberOfFlights = {};</code></p><p id="5e21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二步。将numberOfFlights[src]设置为0。由于我们从<strong class="ka ir"> src </strong>出发，所以只需0次飞行即可到达:</p><p id="caca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lj b">numberOfFlights[src] = 0;</code></p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6497" class="ln lo iq lj b gy lp lq l lr ls">while (queue.length &gt; 0) {<br/>      const currentCity = queue.shift();<br/>      const adjacentCities = graph[currentCity] || [];</span></pre><p id="07fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三步。如果您到达目的地，返回到达目的地所需的航班号:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b9e6" class="ln lo iq lj b gy lp lq l lr ls">if (currentCity === dest) {<br/>        return numberOfFlights[dest];<br/>    }</span></pre><p id="103e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第四步。到达下一个城市的航班数量等于<code class="fe lu lv lw lj b">numberOfFlights</code>到达当前城市+1</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7dd7" class="ln lo iq lj b gy lp lq l lr ls">for (nextCity of adjacentCities) {<br/>        if (!visited.has(nextCity)) {</span><span id="7b55" class="ln lo iq lj b gy lt lq l lr ls">            numberOfFlights[nextCity] = numberOfFlights[currentCity] + 1;</span><span id="a260" class="ln lo iq lj b gy lt lq l lr ls">            queue.push(nextCity);<br/>            visited.add(nextCity);<br/>        }<br/>}<br/>}</span></pre><p id="e0bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有从src到dest的路径，则返回-1</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9b94" class="ln lo iq lj b gy lp lq l lr ls">return -1;<br/>}</span></pre><p id="199d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae kw" href="https://codepen.io/rachelhawa/pen/xxxowEM" rel="noopener ugc nofollow" target="_blank">这里</a>查看上面正在使用的代码和测试用例。</p></div></div>    
</body>
</html>