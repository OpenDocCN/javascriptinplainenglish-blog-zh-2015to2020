<html>
<head>
<title>Understanding Regular Expressions Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解正则表达式第5部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-regular-expressions-8be3b2271af?source=collection_archive---------13-----------------------#2020-07-19">https://javascript.plainenglish.io/introduction-to-regular-expressions-8be3b2271af?source=collection_archive---------13-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cf1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特殊字符</p><p id="4891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的上一期中，我们从一些简单的模式匹配开始了正则表达式引擎。我们代码的第一次迭代可以匹配文字字符和通配符。为了更多地了解正则表达式的内部工作原理，让我们给引擎添加一些功能。更具体地说，让我们添加一些通用特殊字符:'？'，'+，' ' * '在我们开始了解引擎如何识别这些模式之前，我将简要介绍一下每个特殊字符的工作原理:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/ee36dd864c6e318c98ccadeee13b159e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*sKegIi6PjkQ1CX8KqQJ3pA.jpeg"/></div></figure><ol class=""><li id="26f8" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">'?'-问号表示匹配该字符一次或多次。只有当字符出现不止一次时，这种模式才会失败。</li><li id="af4d" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">+'-加号表示一个字符可以在一行中的给定位置出现一次或多次。如果字符没有出现在该位置，则失败。</li><li id="c749" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">*-这种模式有趣而独特，因为它在技术上永远不会失败。' *特殊字符状态匹配在我前面0次或更多次的字符。</li></ol><p id="a024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看一些例子，看看这些角色在实践中是如何工作的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lh"><img src="../Images/f323cc15bc6939f286cab286370a1fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBIqj_Ds7lNbp3y7LoI2TQ.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">? special character</figcaption></figure><p id="2fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面可以看出，这个“？”特殊字符本质上使它前面的字符是可选的。对于最后一行,“u”字符出现了两次，打破了模式并返回false。现在让我们看一些“+”的例子</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lq"><img src="../Images/ee15c7e98be47cce466ab6260112f434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2G7Yvu0FflZLmwN14lWYYw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">+ special character</figcaption></figure><p id="8fad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个角色很有趣，因为只有当这个角色根本没有出现时，它才会失败。只要角色确实出现了，出现的次数就无关紧要了。只有在文本“颜色”中，测试才返回false。测试只是简单地问“这个角色是否出现在这个位置？”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lr"><img src="../Images/887cabfefdc9370aa904c4e331bb4c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyrlN_e-Ai-ys5v4OTi01w.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">‘*’ special character</figcaption></figure><p id="9be0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我们的测试中，我们可以看到模式从不失败，这似乎与最后一行“coloxr”返回false相矛盾。然而，实际上，该模式会失败，因为引擎会将“x”与内联的下一个字符“r”进行比较</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi kl"><img src="../Images/e6d33c507165813830903b56ae492265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*MaJk4GOzBhY-BWtqHkO4rw.jpeg"/></div></div></figure><p id="8112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基础知识说完了，让我们深入研究正则表达式引擎的代码。</p><pre class="km kn ko kp gt ls lt lu lv aw lw bi"><span id="ded9" class="lx ly iq lt b gy lz ma l mb mc">export default function regtest(pattern, text) {<br/>  //pattern is the regular expression pattern to match against<br/>  //text is the text with which to find the regular expression pattern<br/>  //textCounter-the counter that points to the place in the text the engine is checking<br/>  //patternCounter-the counter that points to the place in the regular expression patternCounter<br/>  //being checked<br/>  //innerCounter-the counter of the inner loop for the current place in the text being<br/>  //checked against patternCounter<br/>  const specialcharacters = ['?','+','*','^','$']<br/>  let textCounter = 0<br/>  //outer loop that</span><span id="2524" class="lx ly iq lt b gy md ma l mb mc"><strong class="lt ir">while(textCounter &lt; text.length)</strong>{<br/>    let patternCounter = 0<br/>    if(text[textCounter] === pattern[0]<br/>      || pattern[0] === '.'<br/>      ){<br/>      let innerCounter = textCounter<br/>      <strong class="lt ir">while(patternCounter &lt; pattern.length &amp;&amp;<br/>        (pattern[patternCounter] === text[innerCounter]<br/>          || pattern[patternCounter] === '.'<br/>          || specialcharacters.includes(pattern[patternCounter + 1])<br/>        ))</strong>{<br/>        <strong class="lt ir">if(pattern[patternCounter + 1] === '?')</strong>{<br/>          if(pattern[patternCounter] !== text[innerCounter]){<br/>            innerCounter -= 1<br/>          }<br/>          patternCounter += 1<br/>        }<br/>       <strong class="lt ir"> else if(pattern[patternCounter + 1] === '*')</strong> {<br/>            if(pattern[patternCounter] !== text[innerCounter]){<br/>              innerCounter -= 1<br/>            }<br/>            else {<br/>              while(pattern[patternCounter] === text[innerCounter + 1]){<br/>                innerCounter += 1<br/>              }<br/>            }<br/>            patternCounter += 1<br/>        }<br/>        <strong class="lt ir">else if(pattern[patternCounter + 1] === '+')</strong> {<br/>          <br/>            if(text[innerCounter] !== pattern[patternCounter]){<br/>              break<br/>            }<br/>            else {<br/>              while(pattern[patternCounter] === text[innerCounter + 1]){<br/>                innerCounter += 1<br/>              }<br/>            }<br/>            patternCounter += 1<br/>        }<br/>        innerCounter += 1<br/>        patternCounter += 1<br/>      }<br/>      if(patternCounter &gt;= pattern.length){<br/>        return true<br/>      }<br/>    }<br/>    textCounter += 1<br/>  }<br/>  return false<br/>}<br/>//exports.regtest = regtest;<br/>//module.exports = regtest</span></pre><p id="e728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我将最重要的部分加粗，以突出逻辑流的最关键方面，就像之前外部while循环遍历每个字符以寻找匹配一样。如果在找到匹配之前到达了字符串的末尾，则返回false。一旦引擎找到第一个匹配，内部循环就扫描本地字符，寻找完整的模式匹配。在if-else分支中，三个特殊字符有自己的逻辑分支:' *，' '？'和“+.”对文字字符和通配符的测试在内部while循环的条件中。</p><p id="45b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回顾if-else分支的逻辑，特殊字符的简单公式是一个简单的两步过程:</p><ol class=""><li id="0042" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">如有必要，引擎会确定字符是否与模式匹配。</li><li id="0edc" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">如果模式不匹配，则中断并返回false。</li><li id="104e" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">如果模式匹配，确保innerCounter和patternCounter变量在下一次循环迭代中处于正确的位置。换句话说，下一步必须比较正确的字符。</li></ol><h2 id="47a9" class="lx ly iq bd me mf mg dn mh mi mj dp mk jy ml mm mn kc mo mp mq kg mr ms mt mu bi translated">结论</h2><p id="6daf" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">构建这些特殊角色的逻辑的主要要点是位置决定一切。至少到目前为止，让引擎工作的困难是确保在逻辑流中的正确点比较正确的字符和模式。到目前为止，我们还不需要任何帮助方法。代码可以很好地处理while循环和if-else语句。</p><p id="58bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们是怎么知道的？在我们的下一期文章中，当我们回顾jest单元测试引擎时，我将回答这个问题。</p><h1 id="b5f4" class="na ly iq bd me nb nc nd mh ne nf ng mk nh ni nj mn nk nl nm mq nn no np mt nq bi translated">更多资源</h1><p id="6920" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">RegExpr-学习、构建和测试正则表达式的在线工具</p><p id="1ffe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nr" href="https://regexone.com/" rel="noopener ugc nofollow" target="_blank">RegEx One</a>-通过简单的互动练习学习正则表达式</p><p id="116b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nr" href="https://www.regular-expressions.info/refcharacters.html" rel="noopener ugc nofollow" target="_blank">正则表达式信息</a>-特殊字符</p><p id="67ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">著名的JavaScript书《雄辩的JavaScript》中有一章非常精彩地讲述了正则表达式。</p><p id="84f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nr" href="https://github.com/GreatDeveloper66/RegExp-Engine" rel="noopener ugc nofollow" target="_blank">GitHub</a>——GitHub储存库，用于本文中回顾的代码。</p></div></div>    
</body>
</html>