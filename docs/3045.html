<html>
<head>
<title>Understanding WebSockets and Their Possibilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解网络套接字及其可能性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-websockets-and-its-possibilities-ef4f5b48973f?source=collection_archive---------4-----------------------#2020-08-23">https://javascript.plainenglish.io/understanding-websockets-and-its-possibilities-ef4f5b48973f?source=collection_archive---------4-----------------------#2020-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e5b8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">能够在用户的浏览器和服务器之间打开双向交互通信会话的技术</em></h2></div><h2 id="4a3b" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">简介</strong></h2><p id="f558" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">作为web应用程序的用户，我们已经习惯于能够通过聊天、文本消息或其他形式的数字通信方法与他人快速、无缝地交互。大多数消费者认为这是某种神秘的互联网魔法，作为程序员，我们知道有一个更深更丰富的解释来解释这种网络技术是什么，它是做什么的，以及它是如何在幕后运作的。</p><h2 id="078d" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">你好网络套接字</strong></h2><p id="025c" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">从历史上看，对于希望构建实时web应用程序的程序员来说，过去的情况是，您构建应用程序，将消息从发送方的客户端发送到服务器，然后将该响应从服务器发送到接收方的客户端。通过WebSocket API (WebSockets)，我们消除了这一需求，并为web开发人员引入了无限的可能性来利用客户机和服务器之间的双向(双向)通信。现在我们已经介绍了网络套接字，让我们了解网络套接字实际上是如何工作的。</p><p id="551c" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">从MDN:<em class="ma"/><strong class="le ir"><em class="ma">WebSocket API</em></strong><em class="ma">是一种先进的技术，它使得在用户的浏览器和服务器之间打开双向交互通信会话成为可能。有了这个API，您可以向服务器发送消息并接收事件驱动的响应，而无需点击服务器进行回复(</em><a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://developer . Mozilla . org/en-US/docs/Web/API/WebSockets _ API</em></a><em class="ma">)。</em></p><p id="28b0" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">本质上，网络套接字允许客户端和服务器保持彼此之间的持久连接，而不需要来自HTTP协议的常备请求和响应事件循环。网络套接字不是让客户端向服务器发出请求，让服务器响应来完成请求，而是最初使用HTTP，然后保持TCP连接的活动状态，这样就避免了通常困扰HTTP请求和响应周期的延迟，而是使用TCP连接来获得几乎没有延迟的实时响应。</p><p id="cd66" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">对于TCP连接，网络套接字在请求打开网络套接字连接的客户端和同意握手的服务器之间创建初始握手。一旦创建了这个握手，握手就持续存在(在视觉上继续保持在服务器和客户机之间—见下图)，并且这个持久的TCP连接(握手)充当通信桥，然后允许数据(以消息的形式)以实时的方式从客户机流向服务器并返回。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/20fc85af5287aa3ab9a03d0d2348de8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*LWBq3RTebdimwMv-"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Image from (<a class="ae mb" href="https://images.techhive.com/images/article/2016/06/websockets-100668229-primary.idge.jpg" rel="noopener ugc nofollow" target="_blank">https://images.techhive.com/images/article/2016/06/websockets-100668229-primary.idge.jpg</a>)</figcaption></figure><h2 id="fc62" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">让我们来看看技术问题</strong></h2><p id="91bf" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">如果没有WebSockets，用户将使用HTTP长轮询。通过HTTP长轮询，客户端不断轮询服务器并请求新信息。一旦有新数据可用，服务器将向客户端发送数据，因此客户端要接收该新数据，必须继续联系服务器以查看数据库的状态是否已经改变，即是否有新信息要显示。这将持续进行，并且不断检查服务器的新信息需要事件循环来加重服务器基础设施的负担，并且随着来自许多用户的多个客户端访问服务器，这将加重服务器的负担，并且需要将大量数据发送到发出请求的所有不同客户端。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/272125b04dc4ad3edbd44b09ddcda377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*acapGQ3LlN8Xsi5w"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Image from (<a class="ae mb" href="https://medium.com/front-end-weekly/what-are-websockets-7bf0e2e1af2" rel="noopener">https://medium.com/front-end-weekly/what-are-websockets-7bf0e2e1af2</a>).</figcaption></figure><p id="2b30" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">另一方面，对于WebSockets，我们之前描述的初始握手意味着从每个客户端到服务器建立持久的TCP连接，这将允许数据以实时的方式从客户端流向服务器，反之亦然。这个过程从客户机向服务器发出一个初始的GET HTTP请求开始。</p><p id="e158" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">一旦发出初始请求并且握手被接受，TCP连接就保持打开，并且与HTTP长轮询方法不同，不需要每次都从客户端向服务器发出新的请求，因此事件循环不需要处理来自每个客户端的每个持续进行的请求。</p><p id="537a" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">相反，服务器将只是发送任何新的信息给客户端，客户端将根据需要呈现这些新信息。它自动默认地将新信息从服务器传递到客户端，消除了HTTP长轮询将执行的高延迟、基础设施繁重的请求的需要。</p><h2 id="204a" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">何时使用WebSockets </strong></h2><p id="b32f" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">对于那些热衷于在自己的应用程序中添加WebSockets的程序员来说。让我们花点时间来评估什么类型的应用程序最适合WebSockets。如前所述，做得最好的web应用程序是实时或接近实时的应用程序，但是它到底有什么特征呢？</p><p id="733f" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">让我们看看Windows开发人员的博客，它解释了什么时候您可能需要通过传统HTTP使用WebSockets:</p><h2 id="b327" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak"> <em class="kf">反应时间快</em> </strong></h2><p id="7745" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated"><em class="ma">当客户需要对变化(尤其是无法预测的变化)做出快速反应时，WebSocket可能是最佳选择。考虑一个允许多个用户实时聊天的聊天应用程序。如果使用WebSockets，每个用户都可以实时发送和接收消息。与REST相比，WebSockets允许更高的效率，因为它们不需要发送和接收每个消息的HTTP请求/响应开销。</em></p><h2 id="3ffc" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak"> <em class="kf">持续更新</em> </strong></h2><p id="26d2" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">当客户想要持续更新资源状态时，WebSockets通常是一个很好的选择。当客户无法预测何时会发生变化，并且变化很可能在短期内发生时，WebSockets是一个特别好的选择。</p><h2 id="36dd" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">T3T5】</strong></h2><p id="8f15" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">WebSocket协议不是围绕请求-响应设计的。消息可以在任何时候从连接的任何一端发送，并且没有对一个消息的本地支持来指示它与另一个消息相关。这使得该协议非常适合“启动并忘记”的消息传递场景，而不太适合需要一方在另一方的响应可以启动之前做出响应的事务性需求。</p><h2 id="004e" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak"> <em class="kf">小有效载荷下的高频消息传递</em> </strong></h2><p id="0c7a" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated"><em class="ma">web socket协议提供了交换消息的持久连接。这意味着单个消息不会产生任何额外的税费来建立传输。诸如建立SSL、内容协商和交换大容量报头之类的费用只在连接建立时征收一次。</em></p><p id="9e6e" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated"><em class="ma">由于WebSockets是专门为长期连接场景设计的，因此它们避免了建立连接和发送HTTP请求/响应头的开销，从而显著提高了性能。</em></p><p id="4482" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated"><em class="ma">引自:(</em><a class="ae mb" href="https://blogs.windows.com/windowsdeveloper/2016/03/14/when-to-use-a-http-call-instead-of-a-websocket-or-http-2-0/#:~:text=WebSockets%20allow%20for%20a%20higher,each%20message%20sent%20and%20received.&amp;text=When%20a%20client%20wants%20ongoing,are%20generally%20a%20good%20fit." rel="noopener ugc nofollow" target="_blank"><em class="ma">https://blogs . windows . com/windows developer/2016/03/14/when-to-use-a-http-call-inst-of-a-web socket-or-http-2-0/</em></a><em class="ma">)</em></p><p id="633d" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">如果您的web应用程序的特征符合上面列出的要求，那么可以考虑将这些流行的WebSocket库集成到您的应用程序中。</p><h2 id="791c" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">你自己的图书馆</strong></h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/06463158f5abc48dedcda6a425cbfe34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*wqZ_x1rXYwpKQZ5E"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">(<a class="ae mb" href="https://www.traveller.com.au/content/dam/images/g/s/2/8/9/w/image.gallery.galleryLandscape.620x414.gs94jd.png/1477354626702.jpg" rel="noopener ugc nofollow" target="_blank">https://www.traveller.com.au/content/dam/images/g/s/2/8/9/w/image.gallery.galleryLandscape.620x414.gs94jd.png/1477354626702.jpg</a>)</figcaption></figure><p id="065f" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">当希望使用WebSocket API时，我们希望寻找与WebSockets和我们的服务器端语言一起工作的有用的库。对于我们的示例，我们使用流行的Javascript运行时Node.js，并将引用Node.js生态系统中的js库示例。</p><p id="b010" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">下面是三个流行的WebSocket JS库，它们提供了实现WebSockets的功能，您可以将这些功能用于您的实时应用程序:</p><h2 id="ee0d" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">1.socket.io</h2><p id="c6a6" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">一个广泛流行和使用的WebSocket包装器/API，拥有超过43K颗星。socket.io由Node.js服务器和 <a class="ae mb" href="https://github.com/socketio/socket.io-client" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> Javascript客户端库</em> </a> <em class="ma">组成，为处理代理和负载平衡器以及个人防火墙和杀毒软件提供可靠性，甚至支持二进制流。这里是</em> <a class="ae mb" href="https://github.com/socketio/socket.io" rel="noopener ugc nofollow" target="_blank"> <em class="ma">环节</em> </a> <em class="ma">。</em></p><h2 id="82b2" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">②<em class="kf">。ws</em>T17】</strong></h2><p id="e246" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated"><em class="ma"> With 9k stars WS是一个流行的WebSocket是Node.js的客户端/服务器库，帮助管理WebSocket协议下的事情。由于WebSocket协议在大多数主流浏览器中都是本地支持的，所以有些人选择直接使用WebSocket，而不在上面使用socket.io。这里是</em> <a class="ae mb" href="https://github.com/websockets/ws" rel="noopener ugc nofollow" target="_blank"> <em class="ma">链接</em> </a> <em class="ma">。</em></p><h2 id="67d9" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">3.sockjs</h2><p id="61fc" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">At 6k stars sockjs是一个浏览器JavaScript库，它提供了一个类似WebSocket的对象，带有一个跨浏览器Javascript API，可以在浏览器和web服务器之间创建低延迟、全双工、跨域的通信。它遵循HTML5 WebSocket API，只有当它失败时，它才回退到特定于浏览器的协议。这里是 <a class="ae mb" href="https://github.com/sockjs/sockjs-node" rel="noopener ugc nofollow" target="_blank"> <em class="ma">链接</em> </a> <em class="ma">。</em></p><p id="a6d3" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">引自:(<a class="ae mb" href="https://blog.bitsrc.io/8-node-js-web-socket-libraries-for-2018-818e7e5b67cf" rel="noopener ugc nofollow" target="_blank">https://blog . bitsrc . io/8-node-js-we b-socket-libraries-for-2018-818 e7e 5b 67 cf</a>)</p><p id="0e79" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">现在我们有三个JS库可以帮助您的应用程序实现WebSockets，让我们仔细看看可以与这些WebSocket库一起使用的托管服务，它们可以帮助实时增强您的应用程序，并使构建更加容易。原谅我的双关语。</p><h2 id="4d09" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">更快的解决方案</strong></h2><p id="59d6" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk kp ll lm ln kt lo lp lq kx lr ls lt lu ij bi translated">对于我们这些专注于使用WebSockets实现解决方案，而不热衷于编写基础架构代码或处理WebSocket部署的人来说，您可以考虑socket.io等JS库的替代方案，或许可以利用更快更有效的解决方案，如受欢迎的<a class="ae mb" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank"> Pusher API </a>等托管解决方案。</p><p id="f7f7" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">什么是Pusher API？正如他们的网站所说:</p><p id="ba9f" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">Pusher是一个平台，允许开发者尽可能快地轻松构建具有实时特性的应用程序。Pusher专门为开发人员构建实时和可扩展的基础设施，并打包了强大的功能，如客户端事件、可查询API、发布/订阅消息等(<a class="ae mb" href="https://pusher.com/tutorials/react-websockets" rel="noopener ugc nofollow" target="_blank"><em class="ma">【https://pusher.com/tutorials/react-websockets】</em></a><em class="ma">)。</em></p><p id="e70e" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">使用Pusher，程序员可以做更少的工作来将实时行为实现到他们的应用程序中，而使用Pusher Channels这样的服务，可以建立所有必要的基础设施来让您的实时应用程序快速而简单地与Web Sockets一起工作。此外，Pusher确保您的后台基础设施服务器代码能够高效地伸缩，从而减轻程序员在处理大量客户端请求时的负担，这些请求会随着您的实时应用程序越来越受欢迎而出现。</p><h2 id="01f6" class="kg kh iq bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">结论</strong></h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mu"><img src="../Images/49cb747566138c711003f788e26dcc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0aeytzI4y0L9zisW"/></div></div></figure><p id="5e4f" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">图片来自(<a class="ae mb" href="https://images.unsplash.com/photo-1565049981953-379c9c2a5d48?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;w=1000&amp;q=80" rel="noopener ugc nofollow" target="_blank">https://images . unsplash . com/photo-1565049981953-379 c 9 C2 a5d 48？IX lib = r b-1 . 2 . 1&amp;ixid = eyjhchbfawqiojeymdd 9&amp;w = 1000&amp;q = 80</a></p><p id="5366" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">让我们最后总结一下WebSockets给希望构建接近实时和实时应用程序的程序员带来的好处！</p><p id="c93d" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">WebSockets是客户机/服务器web技术中的一个游戏改变者。通过建立“握手”，在客户端和服务器之间建立持久的TCP连接，这允许在客户端和服务器之间进行双向消息传递，与传统的HTTP请求响应周期相比，这具有非常低的延迟和少得多的技术开销。</p><p id="5c8c" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">这种持续的TCP连接允许最终用户以代码高效和实时的方式构建和使用实时应用，同时允许程序员不必花费大量资源来编写基础设施代码来处理实时行为或部署。</p><p id="3de6" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">对于那些渴望了解更多关于WebSockets和更深入一点的人，请参考WebSocket API文档(<a class="ae mb" href="https://html.spec.whatwg.org/multipage/web-sockets.html" rel="noopener ugc nofollow" target="_blank">https://html.spec.whatwg.org/multipage/web-sockets.html</a>)并查看WebSockets上的Mozilla文档(<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a>)。</p><p id="29a9" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated">感谢您的阅读，并享受WebSockets带来的乐趣！</p><p id="ef2c" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated"><strong class="le ir">参考文献</strong><br/><a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Web sockets _ API</a></p><p id="d3e2" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated"><a class="ae mb" href="https://sookocheff.com/post/networking/how-do-websockets-work/" rel="noopener ugc nofollow" target="_blank">https://sookocheff . com/post/networking/how-do-web sockets-work/</a></p><p id="63d6" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated"><a class="ae mb" href="https://blogs.windows.com/windowsdeveloper/2016/03/14/when-to-use-a-http-call-instead-of-a-websocket-or-http-2-0/" rel="noopener ugc nofollow" target="_blank">https://blogs . windows . com/windows developer/2016/03/14/when-to-use-a-http-call-inst-a-web socket-or-http-2-0/</a></p><p id="bf0e" class="pw-post-body-paragraph lc ld iq le b lf lv jr lh li lw ju lk kp lx lm ln kt ly lp lq kx lz ls lt lu ij bi translated"><a class="ae mb" href="https://pusher.com/websockets" rel="noopener ugc nofollow" target="_blank">https://pusher.com/websockets</a></p></div></div>    
</body>
</html>