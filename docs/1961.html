<html>
<head>
<title>Learning JavaScript by Implementing Lodash Methods — Arrays and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现Lodash方法学习JavaScript数组和对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-arrays-and-objects-a23ca2a76c59?source=collection_archive---------4-----------------------#2020-05-07">https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-arrays-and-objects-a23ca2a76c59?source=collection_archive---------4-----------------------#2020-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa7793256ff9713aacf0605bbfa9eaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2G6AS3E7H4GuG7FL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jentheodore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jen Theodore</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="17db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="2550" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究Lodash方法，这些方法将数组压缩成对象属性和值，并遍历数组和对象。</p><h1 id="7946" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">zipObject</code></h1><p id="3f53" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">zipObject</code>方法将2个数组放入对象属性和值中。第一个数组包含属性名，第二个包含属性值。</p><p id="159c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现我们自己的<code class="fe lz ma mb mc b">zipObject</code>方法:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3fa6" class="mq lc iq mc b gy mr ms l mt mu">const zipObject = (props, vals) =&gt; {<br/>  let obj = {};<br/>  for (let i = 0; i &lt; props.length; i++) {<br/>    obj[props[i]] = vals[i];<br/>  }<br/>  return obj;<br/>}</span></pre><p id="6248" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们创建了一个空对象。然后我们遍历<code class="fe lz ma mb mc b">props</code>数组来获取属性名和索引。</p><p id="88be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过使用索引访问<code class="fe lz ma mb mc b">vals</code>数组中的条目，用我们自己的属性和相应的值填充<code class="fe lz ma mb mc b">obj</code>对象。</p><p id="1e79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fd62" class="mq lc iq mc b gy mr ms l mt mu">const result = zipObject(['a', 'b'], [1, 2]);</span></pre><p id="d465" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lz ma mb mc b">result</code>的值:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d591" class="mq lc iq mc b gy mr ms l mt mu">{<br/>  "a": 1,<br/>  "b": 2<br/>}</span></pre><h1 id="0a5d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">countBy</code></h1><p id="7861" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">countBy</code>方法从一个数组中创建一个对象，该数组将数组条目作为键，键通过<code class="fe lz ma mb mc b">iteratee</code>函数处理。每个键的值是通过<code class="fe lz ma mb mc b">iteratee</code>映射后键的数量。</p><p id="29cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">iteratee</code>接受一个参数并将该参数映射到其他东西。</p><p id="5d51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2033" class="mq lc iq mc b gy mr ms l mt mu">const countBy = (arr, iteratee) =&gt; {<br/>  let obj = {};<br/>  for (const a of arr) {<br/>    if (typeof obj[iteratee(a)] === 'undefined') {<br/>      obj[iteratee(a)] = 0;<br/>    } else {<br/>      obj[iteratee(a)]++;<br/>    }<br/>  }<br/>  return obj;<br/>}</span></pre><p id="8251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过用键调用<code class="fe lz ma mb mc b">iteratee</code>来映射键，键是数组条目。</p><p id="d30b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当属性尚未定义时，我们将相应的值设置为0。</p><p id="c9e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们将该值增加1。最后，我们返回<code class="fe lz ma mb mc b">obj</code>。</p><p id="27bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8465" class="mq lc iq mc b gy mr ms l mt mu">const result = countBy([6.1, 4.2, 6.3], Math.floor);</span></pre><p id="e4b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到的<code class="fe lz ma mb mc b">result</code>是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8839" class="mq lc iq mc b gy mr ms l mt mu">{<br/>  "4": 0,<br/>  "6": 1<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/07d8e2a1b38343ce8f5acb60a6ffdabe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JbQEnDez9GvGj8T-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@stavrialena?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stavrialena Gontzou</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a25c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">forEach</code></h1><p id="a3fb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">forEach</code>方法遍历集合中的一个元素，并对每个元素调用<code class="fe lz ma mb mc b">iteratee</code>。</p><p id="39ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">iteratee</code>函数可以通过显式返回<code class="fe lz ma mb mc b">false</code>来停止循环的执行。</p><p id="d56a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以将数组或对象作为第一个参数。</p><p id="c1d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ddc4" class="mq lc iq mc b gy mr ms l mt mu">const forEach = (collection, iteratee) =&gt; {<br/>  if (Array.isArray(collection)) {<br/>    for (const a of collection) {<br/>      const result = iteratee(a)<br/>      if (result === false) {<br/>        break;<br/>      }<br/>    }<br/>  } else {<br/>    for (const a of Object.keys(collection)) {<br/>      const result = iteratee(collection[a], a)<br/>      if (result === false) {<br/>        break;<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="01cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们首先检查<code class="fe lz ma mb mc b">collection</code>是否是一个数组。如果是，那么我们使用一个<code class="fe lz ma mb mc b">for...of</code>循环遍历每个条目，并在每个条目上调用<code class="fe lz ma mb mc b">iteratee</code>。</p><p id="1529" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它返回<code class="fe lz ma mb mc b">false</code>，那么我们停止循环。</p><p id="f8f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，如果<code class="fe lz ma mb mc b">collection</code>不是一个数组，那么我们通过用<code class="fe lz ma mb mc b">Object.keys</code>获取键来遍历对象的键，然后对每个键-值对运行<code class="fe lz ma mb mc b">iteratee</code>。</p><p id="81cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象情况下的参数<code class="fe lz ma mb mc b">iteratee</code>是值，然后是键，而数组情况下的<code class="fe lz ma mb mc b">iteratee</code>只是数组条目。</p><p id="d59e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lz ma mb mc b">iteratee</code>返回<code class="fe lz ma mb mc b">false</code>，那么我们停止循环。</p><p id="b220" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1a65" class="mq lc iq mc b gy mr ms l mt mu">forEach([1, 2], (value) =&gt; {<br/>  if (value === 2) {<br/>    return false;<br/>  }<br/>  console.log(value);<br/>});</span><span id="0607" class="mq lc iq mc b gy mw ms l mt mu">forEach({<br/>  'a': 1,<br/>  'b': 2<br/>}, (value, key) =&gt; {<br/>  console.log(key);<br/>});</span></pre><p id="7e18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到第一个<code class="fe lz ma mb mc b">forEach</code>日志1和第二个呼叫日志‘a’和‘b’。</p><h1 id="ed59" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0647" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">使用<code class="fe lz ma mb mc b">for</code>循环，将键和值填充到一个对象中并返回它，可以很容易地实现<code class="fe lz ma mb mc b">zipObject</code>方法。</p><p id="9326" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">countBy</code>方法类似，但是值是每个项目的计数，这是通过首先调用一个<code class="fe lz ma mb mc b">iteratee</code>函数来填充键并计数在调用<code class="fe lz ma mb mc b">iteratee</code>函数后出现的项目数来确定的。</p><p id="9cd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当<code class="fe lz ma mb mc b">iteratee</code>函数返回<code class="fe lz ma mb mc b">false</code>时，可以通过<code class="fe lz ma mb mc b">for...of</code>循环和中断循环来实现<code class="fe lz ma mb mc b">forEach</code>函数。</p><h2 id="84eb" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">来自简明英语团队的说明</h2><p id="7aa4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！</p><p id="6aef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会与您联系！</p></div></div>    
</body>
</html>