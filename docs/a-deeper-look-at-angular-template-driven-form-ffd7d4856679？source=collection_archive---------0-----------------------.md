# 深入了解角度模板驱动的表单

> 原文：<https://javascript.plainenglish.io/a-deeper-look-at-angular-template-driven-form-ffd7d4856679?source=collection_archive---------0----------------------->

![](img/130485653fd08bf05c27c56c314f8a08.png)

## 探索以最简单的方式创建复杂表单的方法

# 介绍

**表单**是互联网上广泛使用的工具，知道如何处理用户输入**是每个优秀的 web 开发人员都应该具备的技能**。

**处理表单从来都不容易**，尤其是如果你在**企业开发**中工作，那里有更复杂的场景，你有大量的用户输入。

每个表单密集型应用程序**都必须回答以下问题**:

*   **全局跟踪表单状态**
*   **处理输入控件的有效性**
*   **显示用户友好的错误信息，以便用户知道如何解决问题**

Angular 通过使用框架风格的方法解决了与表单复杂性相关的问题，给出了两种创建表单的方法:**模板驱动**或**反应式**。

在这篇文章中，我们将深入了解模板驱动方法，这是在 Angular 中创建表单最快最简单的方法。

# 角度模板驱动的表单

> 模板驱动表单是用一种方法创建的表单，其中输入控件的数据和行为是在模板级别声明和管理的

使用这个指令**构建的表单只能在端到端测试**中进行测试，因为这需要一个 **DOM** 的存在，但是这种机制仍然非常有用，并且易于理解。

# 快速浏览如何使用模板驱动的表单

## 启用模板驱动的表单

要开始在 Angular **中使用表单，我们需要在我们的应用程序模块**中显式导入它们:

# 我们的第一个模板驱动表单

让我们来看一个**基本表单模板，它模拟了一个真实的工作登录过程**，请求用户插入一些信息:

我们在这里做的是用**两个控件**，用户名和密码声明一个简单的表单，这两个控件都是**必填字段** ( *标有* `*required*` *属性*)。

一旦用户填写了所有请求的输入，提交按钮将被启用。

当用户单击 submit 按钮时，在模板表单顶部声明的关联方法`*(ngSubmit)="onSubmitForm()"*`将被触发，您可以在这里编写逻辑来发送用于身份验证的数据。

在 Angular 中制作一个工作模板驱动的表单**非常简单快速**，但是如果你想创建更复杂的解决方案，你需要理解**这种类型的表单声明是如何工作的**所以在接下来的章节中跟随我来解锁。

# NgModel 验证功能

决定组件变量和模板中发生的事情之间的链接的关键是`[(ngModel)]`，这种符号强调两个表单控件与一个视图模型变量双向绑定，简称为`user`。

更重要的是，当用户点击一个必填字段时，**该字段显示为红色，直到用户输入一些内容。**

Angular 实际上是在为我们跟踪三个表单字段状态，并将下面的 CSS 类应用到表单及其控件中:

*   **触动**或**未触动**
*   **有效**或**无效**
*   **洁净的**或**肮脏的**

> 这些 CSS 状态类对于设计表单错误状态非常有用。

Angular 实际上也在跟踪整个表单的有效性状态，用它来启用/禁用提交按钮。

# 这一切的逻辑一定在控制器里，对吧？

让我们看看与视图相关联的控制器**，看看所有这些表单逻辑是如何实现的:**

我们只有一个视图模型对象`user`的声明，和一个`ngSubmit`使用的事件处理程序。

跟踪表单错误和注册验证器的所有非常有用的功能都由我们**负责，没有任何特殊的配置**。

# 那 Angular 是怎么做到的呢？

其工作方式是，有一组隐式定义的表单指令应用于视图。

> Angular 将自动对表单应用一个表单级指令，创建一个`FormGroup`，并将其链接到表单。

> 如果出于某种原因你不想要这个，你可以通过添加`ngNoForm`作为表单属性来禁用这个功能。

此外，每个输入还将被应用一个向控件组注册自身的指令，如果像`required`或`maxlength`这样的元素被应用到输入，验证器将被注册。

`[(ngModel)]`的存在也将在表单和用户模型之间创建一个双向绑定**，所以你不需要手动将表单中的值分配给你的局部变量。**

这就是为什么这被称为模板驱动的表单，因为验证和绑定都是在模板的层次上以声明的方式**建立的。**

# 如果我们不需要双向绑定，只需要字段初始化呢？

有时候我们只想创建一个表单并初始化它，但不一定要做双向绑定。

我们可能希望让用户填写表单并按 submit，然后才获得最新的值。

我们可以通过使用简单的`[ngModel]`语法来做到这一点:

这将允许我们通过填写用户对象的字段来初始化表单:

# 如果我们不需要字段初始化，还能得到验证吗？

表单不需要初始值，只需要验证。

如果我们只想获得`ngModel`的验证功能，而不需要初始化值或双向绑定，我们可以使用下面的语法:

# 使用模板驱动表单的利弊

我们在这篇文章中做的例子非常简单，如果我们有更复杂的表单要做，我们还必须考虑如何阅读。

> 当我们在一个字段中添加越来越多的 validator 标签，或者开始添加复杂的跨字段验证时，表单的可读性就会降低。

这种处理表单的方式的优点是它的简单性，这对于构建大范围的表单来说可能绰绰有余。

不利的一面是，**表单验证逻辑无法进行单元测试**。

测试这种逻辑的唯一方法是使用浏览器运行**端到端测试，例如使用像`PhantomJs`这样的无头浏览器。**

一天，一位教授告诉我:

> “如果市场上同时存在两种类似的东西，那么这意味着它们提供不同的解决方案，解决不同的问题”

确切地说，Angular 有两种处理表单的方法:模板驱动的方法，也就是本文的方法，或者使用反应式表单。

如果模板驱动的方法非常简单和直观，那么**反应式表单可以让你控制表单声明的所有方面**。

*那么为什么不一直使用反应式呢？*

因为反应式表单是一种更复杂的处理表单的方式，当我们需要管理的输入控件很少时，我们不需要这种深度。

我们在本文中制作的登录表单是一个很好的例子**，这种情况下**模板驱动的方法是最好的**，我们只有两个输入和一个按钮来提交数据，所有的凭证都自动写入我们的组件变量中，我们只需要调用 API 来进行身份验证。**

> 另一方面，如果我们制作了一个注册表单，它通常有许多不同类型的字段，那么用反应方式声明表单会更好。

# 从函数式编程角度的一些想法

模板驱动的表单并没有错，但是从**编程技术的角度来看，**双向绑定是一种促进可变性的解决方案。

> 每个表单都有一个状态，可以通过许多不同的交互来更新，由应用程序开发人员来管理该状态并防止它被破坏。

这对于非常大的表单来说很难做到，并且会引入一类潜在的 bug。

# 摘要

模板驱动的表单是一个很好的方式来处理有角度的表单。

使用这种方法，模型是由模板中的指令创建的，而不是在组件上显式创建的。

`ngForm`指令自动附加到`<form>`并创建一个顶级`FormGroup`。

我们学习了如何使用`ngModel`指令，它如何为我们创建`FormControl`实例，以及我们如何使用它在组件上实现到域模型的双向数据绑定。

# 相关链接

如果你想了解更多关于角形的知识，Victor Savkin 在 Angular Air 的[播客将详细介绍这两种形式和
T5。](https://www.youtube.com/watch?v=NuZKwcPmis8)

这篇[博客文章](http://victorsavkin.com/post/108837493941/better-support-for-functional-programming-in)给出了 Angular 如何更好地支持函数式反应式编程技术的高级概述。

如果你想详细学习角形，这里有一个很好的 Youtube 视频，你可以跟着看。

***感谢阅读，快乐编码！***

## 简单英语的 JavaScript

喜欢这篇文章吗？如果有，通过 [**订阅获取更多类似内容解码，我们的 YouTube 频道**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw) **！**