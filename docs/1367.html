<html>
<head>
<title>Guide to the Express Router Object — Request and Parameter Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速路由器对象指南—请求和参数处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/guide-to-the-express-router-object-request-and-parameter-handling-3b80823ed49c?source=collection_archive---------5-----------------------#2020-03-07">https://javascript.plainenglish.io/guide-to-the-express-router-object-request-and-parameter-handling-3b80823ed49c?source=collection_archive---------5-----------------------#2020-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5d85faf5bc80fcb800352e591145646b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o4unpZfiRQHD8sCQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jonflobrant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jon Flobrant</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bdf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Express <code class="fe lb lc ld le b">router</code>对象是中间件和路线的集合。它是主应用程序中的一个迷你应用程序。</p><p id="c23b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只能执行中间件和路由功能，不能独立运行。</p><p id="fd09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它本身也像中间件一样，所以我们可以将它与<code class="fe lb lc ld le b">app.use</code>一起使用，或者作为另一个路由的<code class="fe lb lc ld le b">use</code>方法的参数。</p><p id="9145" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看<code class="fe lb lc ld le b">router</code>对象的方法，包括<code class="fe lb lc ld le b">all</code>、<code class="fe lb lc ld le b">param</code>和监听特定类型请求的方法。</p><h1 id="5aec" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">方法</h1><h2 id="cfb6" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">router.all(路径，[回调，...]回调)</h2><p id="a544" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><code class="fe lb lc ld le b">router.all</code>方法使用回调来处理各种请求。</p><p id="b664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以传入一个常量路径，或者一个带有路径模式的字符串或者一个正则表达式。</p><p id="7272" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以传递为所有连接到<code class="fe lb lc ld le b">router</code>的路由运行的中间件，如下所示:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="e1d0" class="md lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="2527" class="md lg iq le b gy ng nd l ne nf">const app = express();<br/>const fooRouter = express.Router();</span><span id="7624" class="md lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="1d35" class="md lg iq le b gy ng nd l ne nf">const mw1 = (req, res, next) =&gt; {<br/>  console.log('middleware 1 called');<br/>  next();<br/>}</span><span id="cff7" class="md lg iq le b gy ng nd l ne nf">const mw2 = (req, res, next) =&gt; {<br/>  console.log('middleware 2 called');<br/>  next();<br/>}</span><span id="7ee0" class="md lg iq le b gy ng nd l ne nf">fooRouter.all('*', mw1, mw2);</span><span id="194b" class="md lg iq le b gy ng nd l ne nf">fooRouter.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>})</span><span id="f7f1" class="md lg iq le b gy ng nd l ne nf">app.use('/foo', fooRouter);</span><span id="e0dd" class="md lg iq le b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="82cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="7b29" class="md lg iq le b gy nc nd l ne nf">middleware 1 called<br/>middleware 2 called</span></pre><p id="5882" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们向<code class="fe lb lc ld le b">/foo</code>发出一个请求，因为任何以<code class="fe lb lc ld le b">/foo</code>开头的内容都会通过<code class="fe lb lc ld le b">fooRouter</code>发送，并且我们有一个带有传入中间件的<code class="fe lb lc ld le b">fooRouter.all</code>方法调用。</p><p id="65df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等价地，我们可以写:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="13a7" class="md lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="6a59" class="md lg iq le b gy ng nd l ne nf">const app = express();<br/>const fooRouter = express.Router();</span><span id="4401" class="md lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="8d17" class="md lg iq le b gy ng nd l ne nf">const mw1 = (req, res, next) =&gt; {<br/>  console.log('middleware 1 called');<br/>  next();<br/>}</span><span id="ec42" class="md lg iq le b gy ng nd l ne nf">const mw2 = (req, res, next) =&gt; {<br/>  console.log('middleware 2 called');<br/>  next();<br/>}</span><span id="df90" class="md lg iq le b gy ng nd l ne nf">fooRouter.all('*', mw1);<br/>fooRouter.all('*', mw2);</span><span id="ce48" class="md lg iq le b gy ng nd l ne nf">fooRouter.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>})</span><span id="83b2" class="md lg iq le b gy ng nd l ne nf">app.use('/foo', fooRouter);</span><span id="cc48" class="md lg iq le b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="4ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要调用<code class="fe lb lc ld le b">fooRouter.all</code>的顺序与回调的传入顺序相同，它们就是相同的。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/74eb6085aa8f207f089281f4b420b573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R1ds_eHUAXebOEQk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sgabriel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sebastien Gabriel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="35e8" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">路由器。方法(路径，[回调，...]回调)</h2><p id="f710" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><code class="fe lb lc ld le b">router.METHOD</code>是用给定的方法处理请求。例如，<code class="fe lb lc ld le b">router.get</code>用于处理GET请求，<code class="fe lb lc ld le b">router.post</code>用于处理POST请求等。</p><p id="eeda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有调用<code class="fe lb lc ld le b">router.head</code>，除了GET方法之外<code class="fe lb lc ld le b">router.get</code>还会自动调用<code class="fe lb lc ld le b">HTTP HEAD</code>。</p><p id="3559" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以提供多次回访，并且一视同仁。这些回调可以调用<code class="fe lb lc ld le b">next('route')</code>调用来绕过剩余的路由回调。</p><p id="9d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="89cb" class="md lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="4e69" class="md lg iq le b gy ng nd l ne nf">const app = express();<br/>const fooRouter = express.Router();</span><span id="678f" class="md lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="9f5f" class="md lg iq le b gy ng nd l ne nf">fooRouter.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>})</span><span id="fc53" class="md lg iq le b gy ng nd l ne nf">app.use('/foo', fooRouter);</span><span id="79b7" class="md lg iq le b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="727f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们向<code class="fe lb lc ld le b">/foo</code>发出请求时，我们得到<code class="fe lb lc ld le b">foo</code>。</p><p id="8326" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以为路线<code class="fe lb lc ld le b">path</code>传入一个正则表达式。例如，我们可以写:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="716c" class="md lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="0427" class="md lg iq le b gy ng nd l ne nf">const app = express();<br/>const fooRouter = express.Router();</span><span id="9c2d" class="md lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="1d7f" class="md lg iq le b gy ng nd l ne nf">fooRouter.get('/ab+c/', (req, res) =&gt; {<br/>  res.send('foo');<br/>})</span><span id="ea14" class="md lg iq le b gy ng nd l ne nf">app.use('/foo', fooRouter);</span><span id="fde5" class="md lg iq le b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="06b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">监听对路径<code class="fe lb lc ld le b">/foo/abc</code>、<code class="fe lb lc ld le b">/foo/abbc</code>、<code class="fe lb lc ld le b">/foo/abbbc</code>等的请求。，因为我们在正则表达式中指定了在路径中查找任意数量的字符<code class="fe lb lc ld le b">b</code>。</p><h2 id="81a9" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">router.param(名称，回调)</h2><p id="0ae3" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><code class="fe lb lc ld le b">router.param</code>让我们在客户端发出请求并传入特定参数时触发<code class="fe lb lc ld le b">callback</code>函数调用。</p><p id="60b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">name</code>是我们寻找的参数占位符名称。</p><p id="cb0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">callback</code>功能的参数有:</p><ul class=""><li id="f27e" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><code class="fe lb lc ld le b">req</code>，请求对象。</li><li id="6a7e" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">res</code>，应答对象。</li><li id="295a" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">next</code>，表示下一个中间件功能。</li><li id="b0ae" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">name</code>参数的值。</li><li id="686c" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">参数的名称。</li></ul><p id="3a34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="b7bd" class="md lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="54ad" class="md lg iq le b gy ng nd l ne nf">const app = express();<br/>const fooRouter = express.Router();</span><span id="6f45" class="md lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="6d91" class="md lg iq le b gy ng nd l ne nf">fooRouter.param('name', (req, res, next, name) =&gt; {<br/>  req.name = name;<br/>  next();<br/>})</span><span id="827d" class="md lg iq le b gy ng nd l ne nf">fooRouter.get('/:name', (req, res) =&gt; {<br/>  res.send(req.name);<br/>})</span><span id="760b" class="md lg iq le b gy ng nd l ne nf">app.use('/foo', fooRouter);</span><span id="32ff" class="md lg iq le b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="f1f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们向<code class="fe lb lc ld le b">/foo/abc</code>发出请求，然后我们得到<code class="fe lb lc ld le b">abc</code>，因为<code class="fe lb lc ld le b">fooRouter.param</code>发现<code class="fe lb lc ld le b">name</code>参数是通过URL传入的。</p><p id="12b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">name</code>参数的值为<code class="fe lb lc ld le b">'abc'</code>，因为它抓取了<code class="fe lb lc ld le b">/foo/</code>之后的部分，然后我们将<code class="fe lb lc ld le b">name</code>赋给<code class="fe lb lc ld le b">req.name</code>并调用<code class="fe lb lc ld le b">next</code>。</p><p id="8631" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，调用我们传递给<code class="fe lb lc ld le b">foorRouter.get</code>的路由处理程序，然后我们将<code class="fe lb lc ld le b">req.name</code>传递给<code class="fe lb lc ld le b">res.send</code>并将其作为响应发送。</p><h1 id="6202" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="aa48" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">Express <code class="fe lb lc ld le b">router</code>让我们可以创建一个Express应用程序的子应用程序，这样我们就不必在主应用程序中添加所有的路线处理器和中间件。</p><p id="0929" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用这种方法，我们可以倾听各种各样的要求。我们还可以用相应的方法监听特定类型的请求，比如GET或POST请求。它们都接受一个字符串或正则表达式路径和一个路由处理程序回调。</p><p id="cd7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们有<code class="fe lb lc ld le b">param</code>方法来获取路线参数，并使用它做我们想做的事情。</p></div></div>    
</body>
</html>