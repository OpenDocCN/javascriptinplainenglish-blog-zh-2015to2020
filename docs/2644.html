<html>
<head>
<title>What’s New in TypeScript 3.9?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.9有什么新功能？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-new-in-typescript-3-9-7a9eb72e763?source=collection_archive---------9-----------------------#2020-07-11">https://javascript.plainenglish.io/whats-new-in-typescript-3-9-7a9eb72e763?source=collection_archive---------9-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bd339761b1c30cd0e653f45fc460b5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qomcT68Gt1W4UsE6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@heytowner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JOHN TOWNER</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="40b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript是一种扩展JavaScript的语言，使编写JavaScript应用程序变得更容易。</p><p id="49f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript 3.9带来了我们都能从中受益的新特性。</p><p id="30bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究TypeScript 3.9的新特性。</p><h1 id="d3a1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">推断承诺的实现结果</h1><p id="f9b9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接受一组承诺，并解析出所有承诺的实现值。</p><p id="2943" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们会在一个数组里。</p><p id="71dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript在推断结果类型时存在问题。</p><p id="7c81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5b1f" class="mq lc iq mh b gy mr ms l mt mu">interface Person {<br/>  speak(): void<br/>}</span><span id="02f8" class="mq lc iq mh b gy mv ms l mt mu">interface Dog {<br/>  bark(): void<br/>}</span><span id="8027" class="mq lc iq mh b gy mv ms l mt mu">async function speak(person: Promise&lt;Person&gt;, dog: Promise&lt;Dog | undefined&gt;) {<br/>  const [person, dog] = await Promise.all([person, dog]);<br/>  person.speak();<br/>}</span></pre><p id="6b45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们将得到“对象可能未定义”的错误，即使<code class="fe me mf mg mh b">Person</code>总是被定义为由类型参数指定的。</p><p id="550f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe me mf mg mh b">dog</code>的承诺，它推断出了错误的类型。</p><p id="879c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了TypeScript 3.9，这个问题就解决了。</p><h1 id="0bbb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">速度改进</h1><p id="8500" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript 3.9提高了编译速度。</p><p id="8b9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">import</code>陈述通常需要5到10秒钟。</p><p id="5abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在快多了。</p><p id="44ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Material-UI的编译时间减少了40%。</p><h1 id="5e38" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">//@ ts-expect-错误注释</h1><p id="c7d7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">新的<code class="fe me mf mg mh b">// @ts-expect-error</code>注释非常方便，因为我们可以用它来抑制测试中可能出现的打字错误。</p><p id="ac0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果您正在测试此功能:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="500a" class="mq lc iq mh b gy mr ms l mt mu">const doSomething = (foo: string, bar: string) =&gt; {<br/>  assert(typeof foo === "string");<br/>  assert(typeof bar === "string");<br/>  //...<br/>}</span></pre><p id="ba2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可能想传入一个不是字符串的东西来测试它。</p><p id="3613" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用这个注释标签，现在就有可能了。</p><p id="8b3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3526" class="mq lc iq mh b gy mr ms l mt mu">// @ts-expect-error<br/>doSomething(123, 'abc');</span></pre><p id="b79d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且TypeScript编译器不会忽略这个错误。</p><h1 id="fd60" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">条件表达式中未调用的函数检查</h1><p id="edad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript 3.7引入了未调用函数检查，以便在我们忘记调用函数时报告错误。</p><p id="9f46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0e6c" class="mq lc iq mh b gy mr ms l mt mu">function shouldRun(): boolean {<br/>    // ...<br/>}</span><span id="f450" class="mq lc iq mh b gy mv ms l mt mu">if (shouldRun) {<br/>  //...<br/>}</span></pre><p id="2ec1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们会得到一个错误，因为应该调用<code class="fe me mf mg mh b">shouldRun</code>来返回一个布尔值，而不是在没有调用它的情况下写入。</p><p id="38b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe me mf mg mh b">shouldRun</code>是真的，如果不调用它，检查就没有用。</p><p id="c0a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该检查只适用于<code class="fe me mf mg mh b">if</code>语句。</p><p id="6d2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在它还检查三元表达式。</p><p id="920c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="02c6" class="mq lc iq mh b gy mr ms l mt mu">shouldRun ? 'foo' : 'bar'</span></pre><p id="513d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也会得到一个错误。</p><h1 id="6fa3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JavaScript中的CommonJS自动导入</h1><p id="e543" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用TypeScript 3.9，TypeScript可以从<code class="fe me mf mg mh b">require</code>导入中检测类型，以便导入CommonJS模块。</p><p id="9d6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以像这样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9e26" class="mq lc iq mh b gy mr ms l mt mu">const { readFile } = require("fs");</span></pre><p id="b570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以由TypeScript编译器检查。</p><h1 id="1ab9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在代码操作中保留换行符</h1><p id="8e1e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript重构和快速修复现在可以在添加新行时保留它们。</p><p id="ea12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，e如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ea01" class="mq lc iq mh b gy mr ms l mt mu">for (let i = 0; i &lt;= 1000; i++) {<br/>  let cube = i ** 3;</span><span id="69eb" class="mq lc iq mh b gy mv ms l mt mu">  console.log(cube);<br/>}</span></pre><p id="5736" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么在自动修复和重构之后，循环体中的新行将被保留。</p><h1 id="57a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">缺失返回表达式的快速修复</h1><p id="e72b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们忘记了一个<code class="fe me mf mg mh b">return</code>，TypeScript现在会为我们修复它。</p><p id="959c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0c22" class="mq lc iq mh b gy mr ms l mt mu">const f = () =&gt; { 100 }</span></pre><p id="d300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后去掉大括号，或者添加一个return关键字。</p><h1 id="eb0e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解析可选链接和非空断言的差异</h1><p id="6fc6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在同一个表达式中有<code class="fe me mf mg mh b">?.</code>和<code class="fe me mf mg mh b">!.</code>操作符。</p><p id="ecac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a783" class="mq lc iq mh b gy mr ms l mt mu">a.foo?.bar!.baz</span></pre><p id="de40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它被解释为</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5a79" class="mq lc iq mh b gy mr ms l mt mu">(a.foo?.bar).baz</span></pre><p id="ecc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在TypeScript 3.9中，整个表达式的解释不带<code class="fe me mf mg mh b">!</code>。</p><p id="faa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以保持旧的行为方式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f6a" class="mq lc iq mh b gy mr ms l mt mu">(a.foo?.bar)!.baz</span></pre><h1 id="937d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对交叉点和可选属性进行更严格的检查</h1><p id="2048" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有如下的交叉类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="045d" class="mq lc iq mh b gy mr ms l mt mu">interface A {<br/>  a: string;<br/>}</span><span id="8094" class="mq lc iq mh b gy mv ms l mt mu">interface B {<br/>  b: string;<br/>}</span><span id="b7ec" class="mq lc iq mh b gy mv ms l mt mu">interface C {<br/>  a?: boolean;<br/>  b: string;<br/>}</span><span id="db5a" class="mq lc iq mh b gy mv ms l mt mu">declare let x: A &amp; B;<br/>declare let y: C;</span><span id="9720" class="mq lc iq mh b gy mv ms l mt mu">y = x;</span></pre><p id="9edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于TypeScript 3.9检查可选和必需属性的类型，因此我们不能再将<code class="fe me mf mg mh b">y</code>分配给<code class="fe me mf mg mh b">x</code>。</p><p id="c88a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它们不匹配，所以现在认为它们不兼容。</p><h1 id="27ee" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">吸气剂/沉降剂不再可计数</h1><p id="e29f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，我们不能枚举获取者和设置者。</p><p id="b813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于TypeScript 3.9，这与常规的ECMAScript规范是一致的。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/4f7c3c3fe2e6258112fed7e58998fd70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hxfNA1ekTVNlgkW5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8d8c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4a91" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript 3.9修正了许多错误，使编译更快。</p><p id="442c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些事情会给我们带来更少的挫折和更高的生产力，从而使我们受益。</p><p id="e8e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺和类型检查的改进对我们都有很大帮助。</p><h2 id="dc38" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简单英语JavaScript</strong></h2><p id="2c43" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>