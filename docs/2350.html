<html>
<head>
<title>Introducing NGRX component-store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGRX组件库简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introducing-ngrx-component-store-part-1-67019dba0cb0?source=collection_archive---------0-----------------------#2020-06-16">https://javascript.plainenglish.io/introducing-ngrx-component-store-part-1-67019dba0cb0?source=collection_archive---------0-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cf8b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:<a class="ae kf" href="https://ngrx.io/guide/component-store" rel="noopener ugc nofollow" target="_blank">组件库</a>是<a class="ae kf" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NGRX </a>家族即将推出的反应库。让我们来发现它，看看它到底是怎么回事！</h2></div><p id="6c8b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">更新2020–06–18</strong>:<a class="ae kf" href="https://medium.com/@dSebastien/ngrx-component-store-deep-dive-947c0a5be6dc" rel="noopener">第二部现已推出</a>！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/5a3d0df7832b0ec5fa12b27912e956b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnWpXIfYVjwZdaqxVeDPpA.jpeg"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Picture courtesy of <a class="ae kf" href="https://unsplash.com/@rossf" rel="noopener ugc nofollow" target="_blank">Ross Findon</a></figcaption></figure><p id="9094" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">NGRX即将推出的组件存储模块是由Google Firebase控制台团队的两名成员设计的。Kevin Elko(提出想法/原始设计的人)，以及NGRX的核心维护者之一的<a class="ae kf" href="https://twitter.com/AlexOkrushko" rel="noopener ugc nofollow" target="_blank"> Alex Okrushko </a>，他对其进行了提炼，并将其集成到NGRX中。</p><p id="363e" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在第一篇文章中，我将向您概述这个新的NGRX模块。我将告诉你为什么你可能想要使用它(即，它被设计来解决什么问题)，并展示它的高级API。</p><h1 id="0b19" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是组件商店？</h1><p id="daf6" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">组件库的<a class="ae kf" href="https://okrushko.dev/component-store-dd" rel="noopener ugc nofollow" target="_blank">设计文档描述了这个新NGRX模块旨在帮助解决的几个场景。我将在下一节中讨论这些内容。</a></p><p id="b595" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果您只是想了解它的要点，那么可以将组件存储视为一种创建可重用的反应状态存储的方法，这些存储独立于全局NGRX存储，并且绑定到应用程序的子集，甚至绑定到特定的组件。</p><p id="14bb" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">正如我稍后将解释的，组件存储旨在帮助我们避免混合关注点(例如，用不属于它的状态污染全局NGRX存储)，同时将业务逻辑和状态从您的组件中隔离出来，使它们保持简单，易于测试/重构/维护。</p><p id="8ce0" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在实践中，组件存储为我们提供了一种实现管理“本地”状态的基于推送的反应式服务的额外方式。对于公开BehaviorSubject实例的简单服务来说，它实际上是一个更强大的替代方案。多亏了组件库，我们应该能够更容易地重用复杂的组件。</p><p id="3a58" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">此外，我们还能够轻松地创建依赖于状态管理的组件的多个实例。得益于此，将复杂的表示组件集成到故事书故事中会变得更加容易。至少这是我感兴趣的事情；-)</p><p id="90da" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最后但同样重要的是，API当然是完全反应式的，因此是基于推送的。</p><p id="7a78" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们看一下组件存储设计的一些用例。</p><h1 id="3281" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用例1:模块状态</h1><p id="1942" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">组件存储旨在提供一种方法来隔离模块特定的局部状态(在角度意义上不是必需的)，而不是在没有意义的情况下用它来污染全局NGRX存储。</p><p id="e645" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">有时，我们确实会将并不真正属于它的状态添加到全局NGRX存储中。</p><p id="afd9" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">多亏了组件存储，我们将能够创建更多的自包含模块，保持关注点的良好分离，并消除全局存储中的混乱；保持其专用于<em class="mp">实际的</em>全局共享状态。</p><h1 id="c11e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用例2:大型/复杂组件</h1><p id="f9e1" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">组件存储旨在支持的第二个主要用例是大型/复杂组件。</p><p id="b201" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">通常，我们的Angular应用程序中的一些页面组件会编排许多愚蠢的组件。当您有5–10个这样的组件，每个组件都有4–5个输入+同样多的输出时，您就有很多本地状态需要维护/调整，这些组件和许多输出需要处理。</p><p id="1fd2" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当这种情况发生时，有不同的方法可以让你的代码保持干净。</p><p id="6012" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">首先，您可以尝试并确保组件的粒度足够。</p><p id="4f3d" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果复杂性确实存在，并且您无法避免，那么您所能做的最好的事情就是将业务逻辑和状态管理提取到组件之外，并放到服务/外观中(例如，使用<a class="ae kf" href="https://indepth.dev/presenters-with-angular/" rel="noopener ugc nofollow" target="_blank"> Presenter模式</a>)。通过这样做，您将使组件更简单/更容易维护，并且您将避免混淆顾虑/责任。</p><p id="7610" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">组件存储模块也旨在帮助我们改善这种情况。有了组件存储，我们可以创建基于推送的(被动的)服务，这些服务与组件的生命周期相关联。</p><p id="f7cc" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该组件的每个实例都有自己的基于组件存储的服务实例，允许我们重用有自己状态的复杂组件，而不依赖于全局NGRX存储。</p><p id="a560" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这不仅将帮助我们从这些组件中提取业务逻辑和状态，还将使共享/重用这些组件变得更加容易。</p><h1 id="6d02" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">何时使用组件存储</h1><p id="b419" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">基于我们上面经历的用例，您应该已经对此有了一个好的想法。</p><p id="d1b5" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">真正的问题是如何确定什么属于全局NGRX存储，什么属于基于组件存储的服务？</p><p id="3efa" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">像往常一样，您需要考虑该状态是否需要与应用程序的其他部分共享和/或持久化/重新水合。您认为对特定组件或模块来说是本地的所有东西都可以放在使用组件存储创建的“本地”存储中。</p><p id="c824" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">考虑这样一个事实:当用户导航到应用程序的其他部分时，由基于组件存储的服务管理的数据通常会被擦除。如果这对于您的用例来说是不允许的，那么您可能确实需要依赖全局存储或其他机制。</p><p id="81aa" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">通常，基于组件存储的服务实例与使用它们的元素的生命周期相关联。因此，如果您在组件中使用组件存储服务，那么当您的组件被销毁时，该服务也将被销毁。不一定是这样，但我认为这将是常态而不是例外。</p><h1 id="a94c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">目标和非目标</h1><p id="64ab" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">组件商店有一套清晰的目标和非目标:</p><p id="3300" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">目标:</p><ul class=""><li id="7ff9" class="mq mr iq ki b kj kk km kn kp ms kt mt kx mu lb mv mw mx my bi translated">可以在没有ngrx/store的情况下使用</li><li id="752d" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">帮助组件清除其本地状态</li><li id="32f5" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">反应式/推式解决方案</li><li id="de77" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">类型安全</li><li id="9a5f" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">没有假定任何属性存在的“神奇字符串”</li><li id="1d99" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">保持状态不变</li><li id="6a14" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">让它更有性能</li><li id="276d" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">保持测试简单</li></ul><p id="362a" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">没有目标:</p><ul class=""><li id="3c56" class="mq mr iq ki b kj kk km kn kp ms kt mt kx mu lb mv mw mx my bi translated">不要试图将数据保存在单个存储中，因为它意味着本地状态。</li><li id="126f" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">不是要取代全球商店(ngrx/商店)</li><li id="7047" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">不意味着绑定到应用程序级组件(实际上是全球商店)</li><li id="a3c1" class="mq mr iq ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated">不需要附加到Redux开发工具</li></ul><p id="9cd2" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这个名单我没什么好说的；所有的观点都是不言自明的。我不知道你怎么想，但是当我看到目标清单的时候，我已经爱上它了；-)</p><h1 id="79bb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="3c22" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">在关于组件存储的第一篇文章中，我很快解释了它的来源和它试图解决的问题。</p><p id="46a9" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在下一篇文章中，我们将一起深入研究一些代码，这样我们就可以开始了解它是如何工作的，使用起来有多简单。</p><p id="a3bc" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我最初想在本文中这样做，但是“发布”按钮很痒，而且已经晚了；-)</p><p id="388f" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">敬请期待下一部分！</p><h1 id="0f9c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">喜欢这篇文章吗？</h1><p id="3787" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">如果你想了解关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的大量其他很酷的东西，那么不要犹豫<a class="ae kf" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae kf" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>