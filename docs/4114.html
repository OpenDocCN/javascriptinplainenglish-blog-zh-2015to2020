<html>
<head>
<title>Building Component Library with Docz and Lerna</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docz和Lerna构建组件库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-component-library-with-docz-and-lerna-5cd7f470ec05?source=collection_archive---------6-----------------------#2020-11-17">https://javascript.plainenglish.io/building-component-library-with-docz-and-lerna-5cd7f470ec05?source=collection_archive---------6-----------------------#2020-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6d310f4745d7cfa940a97d08e92471a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJEg_Sijuk6tJyjYzaV2Mw.jpeg"/></div></div></figure><p id="0363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件库如今风靡一时，许多公司推出了自己的解决方案，或者坚持使用一堆开源替代方案。利用组件库进行UI开发，尤其是在大型团队中，有很多好处。它允许充分利用模块化和可重用的UI组件，这提高了开发速度，并统一了多个团队和应用程序的风格。将它与一个健壮的设计系统结合起来，从设计到开发团队的交接会变得更加顺畅和高效。</p><p id="d492" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React、Vue等框架/库非常适合这个目的，因为它们被设计成高度模块化。在这篇文章中，React和Styled组件被用作开发组件的主要工具。</p><p id="2b6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一些有用的工具，可以用来加速库的开发过程和部署。采用模块化方法，每个组件都是一个自己的npm包，整个库是一个monorepo，这是有意义的。在那里<a class="ae kw" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> Lerna </a>将被用于管理项目中的多个包，以及跟踪它们的版本和发布过程。</p><p id="b6f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试和记录组件，使用了<a class="ae kw" href="https://github.com/doczjs/docz" rel="noopener ugc nofollow" target="_blank"> Docz </a>(作为<a class="ae kw" href="https://github.com/storybookjs/storybook" rel="noopener ugc nofollow" target="_blank">故事书</a>的替代)。它允许用<a class="ae kw" href="https://mdxjs.com/" rel="noopener ugc nofollow" target="_blank"> MDX </a>记录组件，MDX是一种结合了JSX和Markdown的格式，基本上可以在Markdown文件中导入React组件。此外，Docz version 2运行在<a class="ae kw" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank"> GatsbyJS </a>上，这带来了更快的开发和构建速度，并允许访问Gatsby庞大的插件和工具网络。</p><h1 id="bba4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Lerna设置</h1><p id="a8ab" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将首先创建一个名为<strong class="ka ir"> uikit </strong>的新项目，并安装所需的依赖项。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c5da" class="mj ky iq mf b gy mk ml l mm mn">$ npm i -g lerna $ mkdir uikit &amp;&amp; cd $_ $ yarn add docz react react-dom styled-components</span></pre><p id="65c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装了核心依赖项之后，就该初始化Lerna项目了。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9249" class="mj ky iq mf b gy mk ml l mm mn">$ lerna init</span></pre><p id="f068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将创建以下项目结构:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="de42" class="mj ky iq mf b gy mk ml l mm mn">ui-kit/<br/>  packages/<br/>  package.json<br/>  lerna.json</span></pre><p id="90d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">UI组件将存储在<code class="fe mo mp mq mf b">packages</code>文件夹中。</p><p id="a3f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们检查生成的<code class="fe mo mp mq mf b">lerna.json</code>，它充当Lerna的配置文件。默认情况下，不会发生太多事情，经过一些定制后，配置将如下所示。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="65e3" class="mj ky iq mf b gy mk ml l mm mn">{<br/>  "npmClient": "yarn",<br/>  "version": "independent",<br/>  "packages": [<br/>    "packages/*"<br/>  ],<br/>  "useWorkspaces": true<br/>}</span></pre><p id="9ca9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里最重要的变化是选择<code class="fe mo mp mq mf b">yarn</code>作为npm客户端，指定<code class="fe mo mp mq mf b">independent</code>版本控制，这样包版本可以彼此独立地改变，并且启用<a class="ae kw" href="https://yarnpkg.com/lang/en/docs/workspaces/" rel="noopener ugc nofollow" target="_blank"> Yarn工作区</a>。<code class="fe mo mp mq mf b">packages</code>选项指向我们库包的位置，我们将保持默认设置。Lerna的<a class="ae kw" href="https://github.com/lerna/lerna#lernajson" rel="noopener ugc nofollow" target="_blank"> Github页面</a>提供了更广泛的配置选项列表。</p><p id="14a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们需要将与工作区相关的选项添加到根目录<code class="fe mo mp mq mf b">package.json.</code></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="72b0" class="mj ky iq mf b gy mk ml l mm mn">{<br/>  "name": "uikit",<br/>  "license": "MIT",<br/>  "workspaces": {<br/>    "packages": [<br/>      "packages/*"<br/>    ]<br/>  },<br/>  "private": true,<br/>  "dependencies": {<br/>    "docz": "^2.2.0",<br/>    "lerna": "^3.20.2",<br/>    "react": "^17.0.1",<br/>    "react-dom": "^17.0.1",<br/>    "styled-components": "^5.0.0"<br/>  },<br/>  "devDependencies": {<br/>    "prettier": "^2.1.2"<br/>  }<br/>}</span></pre><p id="8a0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们指定了到<code class="fe mo mp mq mf b">workspaces</code>的路径，与<code class="fe mo mp mq mf b">lerna.json</code>中的路径相同。此外，我们必须使包私有，否则工作区将无法工作。</p><h1 id="261c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建第一个组件</h1><p id="f344" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了开始开发工作，让我们添加第一个包— <code class="fe mo mp mq mf b">Typography</code>，带有必要的基本字体组件。因此，项目的结构将更新如下。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5890" class="mj ky iq mf b gy mk ml l mm mn">ui-kit/<br/>  packages/<br/>    typography/<br/>      src/<br/>        index.js<br/>      CHANGELOG.md<br/>      package.json<br/>  package.json<br/>  lerna.json</span></pre><p id="87a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在实际编写字体组件之前，让我们对字体的<code class="fe mo mp mq mf b">package.json</code>做一些修改。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="347d" class="mj ky iq mf b gy mk ml l mm mn">{<br/>  "name": "@uikit/typography",<br/>  "version": "1.0.0",<br/>  "description": "Base fonts",<br/>  "main": "dist/index.js",<br/>  "module": "src/index.js",<br/>  "files": [<br/>    "dist",<br/>    "CHANGELOG.md"<br/>  ],<br/>  "author": "",<br/>  "license": "MIT"<br/>}</span></pre><p id="bb80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里最有趣的是<code class="fe mo mp mq mf b">main</code>、<code class="fe mo mp mq mf b">module</code>和<code class="fe mo mp mq mf b">files</code>字段。我们将把<code class="fe mo mp mq mf b">main</code>指向<code class="fe mo mp mq mf b">dist</code>文件夹，传输的文件将存储在这里，稍后将在已安装的包中使用。<code class="fe mo mp mq mf b">module</code>将指向<code class="fe mo mp mq mf b">src</code>文件夹，因此在开发过程中可以直接从源文件夹导入包，并且更改将立即反映出来，而无需再次引导包或运行构建脚本。最后，<a class="ae kw" href="https://docs.npmjs.com/files/package.json#files" rel="noopener ugc nofollow" target="_blank"> files </a>属性包含文件列表，这些文件将包含在发布的包中。</p><p id="c330" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以在<code class="fe mo mp mq mf b">typography</code>的<code class="fe mo mp mq mf b">index.js</code>中设置一些基本的字体样式。这些将作为样式组件。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0471" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意来自<code class="fe mo mp mq mf b">styled-components</code>的<code class="fe mo mp mq mf b">css</code>助手用于定义样式的可重用部分，然后由其他组件扩展。组件还接受一个<code class="fe mo mp mq mf b">fontWeight</code>属性进行定制，默认为<code class="fe mo mp mq mf b">regular</code>。</p><h1 id="1c8b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">尝试Docz游乐场</h1><p id="e213" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这似乎是一个实践这些组件的好时机，这也是<code class="fe mo mp mq mf b">Docz</code>将被用来记录它们的用法的地方。为了做到这一点，我们需要在项目的某个地方添加一个包含组件文档的<code class="fe mo mp mq mf b">.mdx</code>文件，其中一个文件需要指向<code class="fe mo mp mq mf b">route: /</code>，并且将被用作首页。让我们在<code class="fe mo mp mq mf b">packages</code>的根中创建这个<code class="fe mo mp mq mf b">index.mdx</code>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="33a2" class="mj ky iq mf b gy mk ml l mm mn">// index.mdx</span><span id="e3e1" class="mj ky iq mf b gy mt ml l mm mn">---<br/>name: Welcome<br/>route: /<br/>---</span><span id="0bb9" class="mj ky iq mf b gy mt ml l mm mn"># Welcome to the awesome UI Kit</span><span id="c93b" class="mj ky iq mf b gy mt ml l mm mn">Select any of the components from the sidenav to get started.</span></pre><p id="4626" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe mo mp mq mf b">yarn docz dev</code>后，我们可以导航到<code class="fe mo mp mq mf b">localhost:3000</code>，看到库的首页。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/a3fc38668e42521d444a3e8f8da6013c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O0Gj-4jpI9VjLJIf.png"/></div></div></figure><p id="b5a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了将文档添加到排版中，我们将在包中创建一个<code class="fe mo mp mq mf b">docs</code>文件夹，并在那里添加<code class="fe mo mp mq mf b">typography.mdx</code>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="dd0e" class="mj ky iq mf b gy mk ml l mm mn">ui-kit/<br/>  packages/<br/>    typography/<br/>      docs/<br/>        typography.mdx<br/>      src/<br/>        index.js<br/>      CHANGELOG.md<br/>      package.json<br/>  package.json<br/>  lerna.json</span></pre><p id="5696" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了记录组件，我们将使用一个特殊的Docz组件，称为<code class="fe mo mp mq mf b">Playground</code>。将它包裹在组件周围将允许在组件显示的正下方编辑它们。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="61aa" class="mj ky iq mf b gy mk ml l mm mn">---<br/>name: Typography<br/>menu: Components<br/>---</span><span id="e6a3" class="mj ky iq mf b gy mt ml l mm mn">import { Playground } from 'docz';<br/>import { H1, H2, H3, H4, H5, H6, Text, SmallText } from '../src/index';</span><span id="087a" class="mj ky iq mf b gy mt ml l mm mn"># Base Typography<br/>&lt;Playground&gt;<br/>    &lt;H1&gt;Heading 1&lt;/H1&gt;<br/>    &lt;H2&gt;Heading 2&lt;/H2&gt;<br/>    &lt;H3&gt;Heading 3&lt;/H3&gt;<br/>    &lt;H4&gt;Heading 4&lt;/H4&gt;<br/>    &lt;H4 fontWeight='bold'&gt;Heading 4 bold&lt;/H4&gt;<br/>    &lt;H5&gt;Heading 5&lt;/H5&gt;<br/>    &lt;H6&gt;Heading 6&lt;/H6&gt;<br/>    &lt;Text&gt;Text&lt;/Text&gt;<br/>    &lt;SmallText&gt;SmallText&lt;/SmallText&gt;<br/>&lt;/Playground&gt;</span></pre><p id="ae5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">刷新页面后，或者必要时重启dev sever，我们将能够看到我们的排版组件。最棒的是，我们可以直接编辑页面上的代码，并立即看到更新的结果！</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/aef0e3e83a02280a6a9990155aa109b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l2lrridh9RJYbvtc.png"/></div></div></figure><h1 id="9383" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">添加自定义字体</h1><p id="b0f6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这对于内置字体来说很好，但是如果我们想要加载一个自定义字体，比如说从Google fonts加载呢？不幸的是，由于Docz的v2是对v1的主要重写，仍然没有清晰的、有文档记录的方法来做到这一点。然而，有一个<a class="ae kw" href="https://github.com/doczjs/docz/issues/944#issuecomment-514684671" rel="noopener ugc nofollow" target="_blank">解决方案</a>，它也很好地展示了Gatsby配置的可扩展性和一个概念，称为<a class="ae kw" href="https://www.docz.site/docs/component-shadowing" rel="noopener ugc nofollow" target="_blank">组件隐藏</a>。</p><p id="5b01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于特定于Gatsby的组件，我们需要在项目的根目录下创建一个<code class="fe mo mp mq mf b">src</code>文件夹，其中将存储特定于主题的组件。因为我们正在扩展<code class="fe mo mp mq mf b">gatsby-theme-docz</code>，所以需要在<code class="fe mo mp mq mf b">src</code>中创建一个同名的文件夹。最后，我们将在其中创建一个<code class="fe mo mp mq mf b">wrapper.js</code>文件，具有以下项目结构。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1ca5" class="mj ky iq mf b gy mk ml l mm mn">ui-kit/<br/>  packages/<br/>    typography/<br/>      docs/<br/>        typography.mdx<br/>      src/<br/>        index.js<br/>      CHANGELOG.md<br/>      package.json<br/>  src/<br/>    gatsby-theme-docz/<br/>      wrapper.js<br/>  package.json<br/>  lerna.json</span></pre><p id="6a00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在内部<code class="fe mo mp mq mf b">wrapper.js</code>我们将添加一个非常简单的组件，它唯一的任务就是传递它的子组件。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="006b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">制作一个只转发孩子的组件似乎毫无意义，然而这样做的原因是我们现在可以在这个组件中包含<code class="fe mo mp mq mf b">css</code>样式，这将在全球范围内应用。为此，让我们在<code class="fe mo mp mq mf b">wrapper.js</code>旁边创建<code class="fe mo mp mq mf b">styles.css</code>，并在那里导入一种选中的字体。在本教程中，我们将使用<strong class="ka ir">蒙特塞拉特</strong>。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3ddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们只需要将这个文件导入到<code class="fe mo mp mq mf b">wrapper.js</code>中，并为排版更新<code class="fe mo mp mq mf b">fontFamily</code>常量。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更改应该立即可见(如果不可见，请重启dev服务器)。这可能不是最干净的方法，但它完成了工作，而且由于不再可能通过<code class="fe mo mp mq mf b">doczrc.js</code>加载自定义字体，这可能是少数可行的解决方案之一。</p><h1 id="cca5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">自定义文档网站</h1><p id="4e64" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">说一下<code class="fe mo mp mq mf b">doczrc.js</code>，用来配置一个Docz项目。配置选项列表可在项目的<a class="ae kw" href="https://www.docz.site/docs/project-configuration" rel="noopener ugc nofollow" target="_blank">文档网站</a>上找到。由于我们现在使用Montserrat作为UI工具包的排版，如果我们的文档网站使用相同的字体，这将是有意义的。为此，我们将向<code class="fe mo mp mq mf b">doczrc.js</code>添加一个<code class="fe mo mp mq mf b">themeConfig</code>属性，其中将应用最常用的文本元素的样式。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="138b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们需要将项目配置与组件分开，所以我们必须单独声明字体系列，并将其用于特定的文本元素。此外，我们可以定制项目标题和描述。默认的<code class="fe mo mp mq mf b">themeConfig</code>可以在<a class="ae kw" href="https://github.com/doczjs/docz/blob/master/core/gatsby-theme-docz/src/theme/index.js" rel="noopener ugc nofollow" target="_blank"> Docz的Github页面</a>找到。在<a class="ae kw" href="https://www.docz.site/docs/gatsby-theme" rel="noopener ugc nofollow" target="_blank">文档</a>中描述了更多定制项目的选项，如添加自定义徽标。</p><h1 id="d7b2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">添加按钮</h1><p id="bfae" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最后，是时候添加一个React组件了，<code class="fe mo mp mq mf b">Buttons,</code>它也将利用排版来更好地说明组件如何一起使用。和以前一样，我们将制作一个新的包，所以项目的结构如下。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1387" class="mj ky iq mf b gy mk ml l mm mn">ui-kit/<br/>  packages/<br/>    typography/<br/>      docs/<br/>        typography.mdx<br/>      src/<br/>        index.js<br/>      CHANGELOG.md<br/>      package.json<br/>    buttons/<br/>      docs/<br/>        buttons.mdx<br/>      src/<br/>        index.js<br/>        Buttons.js<br/>      CHANGELOG.md<br/>      package.json<br/>  src/<br/>    gatsby-theme-docz/<br/>      style.css<br/>      wrapper.js<br/>  package.json<br/>  lerna.json</span></pre><p id="f394" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了一些小的例外，<code class="fe mo mp mq mf b">buttons</code>的<code class="fe mo mp mq mf b">package.json</code>看起来几乎和<code class="fe mo mp mq mf b">typography</code>的一模一样。最值得注意的是<code class="fe mo mp mq mf b">buttons</code>有<code class="fe mo mp mq mf b">typography</code>包作为依赖。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d416" class="mj ky iq mf b gy mk ml l mm mn">{<br/>  "name": "@uikit/buttons",<br/>  "version": "1.0.0",<br/>  "description": "Button components",<br/>  "main": "dist/index.js",<br/>  "module": "src/index.js",<br/>  "files": [<br/>    "dist",<br/>    "CHANGELOG.md"<br/>  ],<br/>  "dependencies": {<br/>    "@uikit/typography": "^1.0.0"<br/>  },<br/>  "author": "",<br/>  "license": "MIT"<br/>}</span></pre><p id="2330" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们运行<code class="fe mo mp mq mf b">lerna bootstrap</code>之后，它将安装所有需要的包并符号链接<code class="fe mo mp mq mf b">packages</code>文件夹中的依赖项。这样做的一个好处是，如果我们对<code class="fe mo mp mq mf b">typography</code>包进行任何更改，并在<code class="fe mo mp mq mf b">buttons</code>中使用该包，这些更改将立即反映在两个包中，而不需要重新构建或发布它们。这让开发体验真的很快很高效！</p><p id="f96f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装完所有依赖项后，我们可以开始为按钮编写代码了。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ef21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们定义了两个非常基本的按钮组件。样式组件有一些基本样式，可以进一步扩展。<code class="fe mo mp mq mf b">ButtonSmall</code>有一个预定义的文本组件，因此接受按钮文本作为单独的属性。此外，为了方便起见，我们从<code class="fe mo mp mq mf b">Buttons.js</code>中导出<code class="fe mo mp mq mf b">index.js</code>中的所有内容。这将确保每个包有一个单一的导出点，当每个包有多个文件时特别有用。现在让我们在操场上试试这些新部件。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4ee8" class="mj ky iq mf b gy mk ml l mm mn">// packages/buttons/docs/buttons.mdx<br/><br/>---<br/>name: Buttons<br/>menu: Components<br/>---<br/><br/>import { Playground } from 'docz';<br/>import { Button, ButtonSmall } from '../src/index';<br/><br/># Buttons<br/><br/>## Base button<br/>&lt;Playground&gt;<br/>  &lt;Button&gt;Test&lt;/Button&gt;<br/>&lt;/Playground&gt;<br/><br/><br/><br/>## Small button<br/>&lt;Playground&gt;<br/>  &lt;ButtonSmall text='Click me'/&gt;<br/>&lt;/Playground&gt;</span></pre><p id="c5a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导航回<code class="fe mo mp mq mf b">localhost:3000</code>我们可以确认按钮按预期工作。有了它，我们就有了一个文档化的、功能性的组件库，可以很容易地扩展。</p><h1 id="0cb5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">部署文档和发布包</h1><p id="664e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">到目前为止，我们主要关注组件库的开发方面，但是在组件库变得可用之前，还需要完成一些其他重要的步骤。</p><h1 id="3ec4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">发布包</h1><p id="8e1c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">要发布自上次发布以来发生变化的所有包(在用<a class="ae kw" href="https://babeljs.io/docs/en/" rel="noopener ugc nofollow" target="_blank"> Babel </a>传输它们之后)，我们可以使用<code class="fe mo mp mq mf b">lerna publish</code>命令。在发布之前，它会提示为每个包指定版本。可以用<code class="fe mo mp mq mf b">publish</code>命令直接指定版本，该命令会将相同的版本应用于所有已更改的包，并跳过提示，例如<code class="fe mo mp mq mf b">lerna publish minor</code>。为了发布工作，需要在<code class="fe mo mp mq mf b">lerna.json</code>中添加一个<code class="fe mo mp mq mf b">registry</code>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="27c4" class="mj ky iq mf b gy mk ml l mm mn">"command": {<br/>  "publish": {<br/>    "registry": "https://mypackageregistry/"<br/>  }<br/>}</span></pre><h1 id="e79f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">建立文档并为他们服务</h1><p id="6fd0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Docz附带了一些内置脚本，使得查看和部署文档变得更加容易。它可以通过运行<code class="fe mo mp mq mf b">yarn docs build &amp;&amp; yarn docz serve</code>在本地构建和服务。对于在线部署文档，Docz的网站上有一个<a class="ae kw" href="https://www.docz.site/docs/deploying-your-docs" rel="noopener ugc nofollow" target="_blank">用Netlify </a>做这件事的简单例子。在Netlify站点设置完成后，通过运行<code class="fe mo mp mq mf b">netlify deploy --dir .docz/dist.</code>可以很容易地进行部署</p><p id="cbd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想看看组件库的样板代码，可以在<a class="ae kw" href="https://github.com/Clarity-89/ui-kit" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="544f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ka ir">！</strong></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="bf61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nd">原载于</em><a class="ae kw" href="https://claritydev.net/blog/building-component-library-with-docz-and-lerna/" rel="noopener ugc nofollow" target="_blank"><em class="nd">https://claritydev.net</em></a><em class="nd">。</em></p></div></div>    
</body>
</html>