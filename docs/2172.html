<html>
<head>
<title>JavaScript Best Practices— Loops and Useless Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—循环和无用的表达式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-loops-and-useless-expressions-3494407d7803?source=collection_archive---------10-----------------------#2020-05-26">https://javascript.plainenglish.io/javascript-best-practices-loops-and-useless-expressions-3494407d7803?source=collection_archive---------10-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c362b8aae270527bbabb014be4842946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q3RJneDLuJyeilRW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@blizzard88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Grant Durr</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4aa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="6ace" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们不应该有的循环，无用的标签，<code class="fe lb lc ld le b">catch</code>子句，以及无用的<code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>调用。</p><h1 id="978e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有未修改的循环条件</h1><p id="819e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们有一个未修改条件的<code class="fe lb lc ld le b">while</code>或<code class="fe lb lc ld le b">do...while</code>循环，该循环将永远运行，因为循环条件没有用新值更新。</p><p id="6c35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这通常不是我们想要的，因为它会因为无限循环而导致程序崩溃。</p><p id="9a8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，无限循环有时适用于像生成器函数这样的函数，当从函数创建并调用生成器时，这些函数会返回最新的值。</p><p id="e76f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在常规的<code class="fe lb lc ld le b">while</code>循环中，我们可能不应该编写无限循环:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d7a0" class="mq lg iq le b gy mr ms l mt mu">while (condition) {<br/>    doSomething();<br/>}</span></pre><p id="7fa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，它适用于返回无限个条目的生成器函数:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="83a3" class="mq lg iq le b gy mr ms l mt mu">function* num() {<br/>  let i = 1;<br/>  while (true) {<br/>    yield i;<br/>    i++;<br/>  }<br/>}</span><span id="e7f7" class="mq lg iq le b gy mv ms l mt mu">const iterator = num();<br/>const val = iterator.next().value;<br/>const val2 = iterator.next().value;</span></pre><p id="ca2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个<code class="fe lb lc ld le b">num</code>生成器函数，在我们通过调用它创建了一个<code class="fe lb lc ld le b">iterator</code>之后，它返回一个新的整数，然后对它调用<code class="fe lb lc ld le b">next</code>一次一次地获取一个值。</p><p id="02a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于常规的<code class="fe lb lc ld le b">while</code>或<code class="fe lb lc ld le b">do...while</code>循环，我们应该总是有一个变化的条件。</p><p id="21c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="aae7" class="mq lg iq le b gy mr ms l mt mu">let x = 1;<br/>while (x &lt;= 5) {<br/>  console.log(x);<br/>  x++;<br/>}</span></pre><p id="c732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有一个条件，当我们将<code class="fe lb lc ld le b">x</code>加1直到<code class="fe lb lc ld le b">x</code>为5时，该条件结束循环。</p><h1 id="8075" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有未使用的表达式</h1><p id="34a5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们代码中的一些JavaScript表达式是无用的，因为它不做任何事情。例如，如果我们有以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2066" class="mq lg iq le b gy mr ms l mt mu">x + 1;</span></pre><p id="b3a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它什么也不做，因为我们没有把它赋给变量，也没有在函数中返回它。</p><p id="7099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了构建工具，像这样的表达式可能会被消除并破坏应用程序逻辑。</p><p id="43e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，像<code class="fe lb lc ld le b">x = 1, y = 2</code>这样的序列赋值表达式总是没有用，除非我们返回值，将它们赋给其他地方的另一个变量，或者稍后对它进行一些操作。</p><h1 id="7952" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有未使用的标签</h1><p id="3304" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">未使用的标签是无用的，因为它们在任何地方都不会被使用。因此，这是死代码，只是占用空间。</p><p id="4f3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ab51" class="mq lg iq le b gy mr ms l mt mu">loop:<br/>  for (let i = 1; i &lt;= 5; i++) {<br/>    console.log(i);<br/>  }</span></pre><p id="d534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要么我们应该使用它，要么我们应该删除它。我们可以如下使用它，例如:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fd20" class="mq lg iq le b gy mr ms l mt mu">loop:<br/>  for (let i = 1; i &lt;= 5; i++) {<br/>    console.log(i);<br/>    if (i === 2) {<br/>      break loop;<br/>    }<br/>  }</span></pre><p id="fa74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe lb lc ld le b">i</code>为2时，我们用<code class="fe lb lc ld le b">break loop</code>标记<code class="fe lb lc ld le b">loop</code>的循环。</p><h1 id="f896" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有不必要的<code class="fe lb lc ld le b">.call()</code>和<code class="fe lb lc ld le b">.apply()</code></h1><p id="791c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>方法只有在我们需要改变函数中<code class="fe lb lc ld le b">this</code>的值，并用各种参数调用它的时候才有用。</p><p id="999c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的以下用法不是很有用:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6665" class="mq lg iq le b gy mr ms l mt mu">function greet(greeting) {<br/>  console.log(`${greeting} ${this.name}`);<br/>}</span><span id="71fe" class="mq lg iq le b gy mv ms l mt mu">greet.call(undefined, 'hi');</span></pre><p id="bcad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入<code class="fe lb lc ld le b">undefined</code>使<code class="fe lb lc ld le b">this</code>设置为<code class="fe lb lc ld le b">undefined</code>。所以和直接调用<code class="fe lb lc ld le b">greet('hi')</code>是一样的。</p><p id="5a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不需要调用<code class="fe lb lc ld le b">call</code>方法。</p><p id="7b3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，下面的<code class="fe lb lc ld le b">apply</code>调用也是无用的:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b9ff" class="mq lg iq le b gy mr ms l mt mu">function greet(greeting) {<br/>  console.log(`${greeting} ${this.name}`);<br/>}</span><span id="9606" class="mq lg iq le b gy mv ms l mt mu">greet.apply(undefined, ['hi']);</span></pre><p id="5d3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也是直接调用<code class="fe lb lc ld le b">greet('hi')</code>。</p><p id="e185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该以有用的方式用<code class="fe lb lc ld le b">call</code>或<code class="fe lb lc ld le b">apply</code>调用<code class="fe lb lc ld le b">greet</code>。</p><p id="758d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该这样称呼它们:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="aa48" class="mq lg iq le b gy mr ms l mt mu">function greet(greeting) {<br/>  console.log(`${greeting} ${this.name}`);<br/>}</span><span id="1cec" class="mq lg iq le b gy mv ms l mt mu">greet.apply({<br/>  name: 'jane'<br/>}, ['hi']);</span><span id="4f10" class="mq lg iq le b gy mv ms l mt mu">greet.call({<br/>  name: 'jane'<br/>}, 'hi');</span></pre><p id="fa19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们将函数内部的<code class="fe lb lc ld le b">this</code>的值设置为一个具有<code class="fe lb lc ld le b">name</code>属性的对象，这样函数内部的<code class="fe lb lc ld le b">this.name</code>就可以用<code class="fe lb lc ld le b">this.name</code>填充。</p><p id="7fea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实际上需要使用<code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>来设置上面例子中<code class="fe lb lc ld le b">this</code>的值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/4049511a3b3c62a00950dd94d386efa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UGZNTBWafY3DD7Qd"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Icons8 Team</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="29ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="56fd" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">未修改的循环条件在大多数情况下是不好的，因为它可能会因为无限循环而导致崩溃。</p><p id="ebd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，无限循环在用返回的迭代器不断返回值的生成器函数中很有用。</p><p id="07cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">未使用的循环标签是无用的，因此应该删除死代码。</p><p id="6f51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>是没有用的，就像那些把<code class="fe lb lc ld le b">this</code>的值设置为<code class="fe lb lc ld le b">undefined</code>的，因为它们和直接调用函数没什么区别。</p><p id="b679" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们也不应该在代码中有未使用的表达式，因为这只是我们可以删除的更多无用的代码。</p><h1 id="d8b4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="fb1d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>找到所有这些信息——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>