<html>
<head>
<title>Compress Express.js Responses with the Compression Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用压缩中间件压缩Express.js响应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/compress-express-responses-with-the-compression-middleware-e9d784065065?source=collection_archive---------3-----------------------#2020-03-05">https://javascript.plainenglish.io/compress-express-responses-with-the-compression-middleware-e9d784065065?source=collection_archive---------3-----------------------#2020-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/956f04ab7bf2122da425bb91ad941bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_XNPVTKz6iO2GWAQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@shmabbss?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Abigail Lynn</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8bd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">压缩我们的回答是提高我们的Express应用程序性能的一个很好的方法。</p><p id="3150" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以使用<code class="fe lb lc ld le b">compression</code>中间件。</p><p id="ce95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究压缩数据的可用选项，以及如何用它发送压缩响应。</p><h1 id="10b4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加中间件</h1><p id="a04a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以通过运行以下命令来安装该软件包:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d038" class="mq lg iq le b gy mr ms l mt mu">npm install compression</span></pre><p id="ae15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将它包括在内:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3f32" class="mq lg iq le b gy mr ms l mt mu">const compression = require('compression');</span></pre><h1 id="0ffc" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">选择</h1><p id="7110" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">compression</code>中间件接受一个<code class="fe lb lc ld le b">options</code>参数，该参数是一个具有以下属性的对象:</p><h2 id="209c" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">组块大小</h2><p id="4924" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">压缩输出的块大小。默认为16384字节或<code class="fe lb lc ld le b">zlib.Z_DEFAULT_CHUNK</code>，其中<code class="fe lb lc ld le b">zlib</code>为<code class="fe lb lc ld le b">zlib</code>节点包。</p><h2 id="f7de" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">过滤器</h2><p id="e3c6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">决定应该压缩哪种响应的函数。该函数被称为<code class="fe lb lc ld le b">filter(req, res)</code>,如果响应类型应该被压缩，则应该返回<code class="fe lb lc ld le b">true</code>,如果不应该，则返回<code class="fe lb lc ld le b">false</code>。</p><p id="0b66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认功能使用<code class="fe lb lc ld le b">compressible</code>模块检查<code class="fe lb lc ld le b">res.getHeader('Content-Type')</code>是否可压缩。</p><h2 id="8713" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">水平</h2><p id="658a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">要应用的压缩级别压缩级别越高，完成的时间就越长。</p><p id="b4b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值的范围从0(无压缩)到9(最高压缩级别)。-1可用于表示默认压缩级别，相当于级别6。</p><h2 id="3ea1" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">内存级别</h2><p id="74c5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这设置了应该为压缩分配多少内存，并且是一个从1(最小级别)到9(最大级别)的整数。</p><p id="e259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认为<code class="fe lb lc ld le b">zlib.Z_DEFAULT_MEMLEVEL</code>或8。</p><h2 id="bc07" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">战略</h2><p id="f539" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这将设置压缩算法。该值仅在压缩比上有所不同，并不影响压缩输出的内容。</p><p id="bcf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是可用的:</p><ul class=""><li id="904b" class="ng nh iq kf b kg kh kk kl ko ni ks nj kw nk la nl nm nn no bi translated"><code class="fe lb lc ld le b">zlib.Z_DEFAULT_STRATEGY</code> —用于正常数据</li><li id="a290" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated"><code class="fe lb lc ld le b">zlib.Z_FILTERED</code> —用于过滤器产生的数据。过滤后的数据主要由随机分布的小值组成。这种算法可以更好地压缩这类数据。该算法强制进行更多的霍夫曼编码。</li><li id="2754" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated"><code class="fe lb lc ld le b">zlib.Z_FIXED</code> —用于防止使用动态霍夫曼代码</li><li id="6c94" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated"><code class="fe lb lc ld le b">zlib.Z_HUFFMAN_ONLY</code> —仅强制霍夫曼编码</li><li id="3cd4" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated"><code class="fe lb lc ld le b">zlib.Z_RULE</code> —将匹配距离限制为1，这提供了仅与Huffman一样好的压缩率，但为PNG数据提供了更好的压缩</li></ul><h2 id="255b" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">阈值</h2><p id="84d3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">响应会考虑压缩前响应正文大小的字节阈值。默认<code class="fe lb lc ld le b">1kb</code>。该值可以是字节数或由<code class="fe lb lc ld le b">bytes</code>模块应用的任何字符串。</p><h2 id="40d4" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">窗口位</h2><p id="ce1f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">默认值是<code class="fe lb lc ld le b">zlib.Z_DEFAULT_WINDOWBITS</code>或15。</p><h2 id="c0b0" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">。过滤器</h2><p id="fa3e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">默认的过滤函数，我们可以用它来构造一个自定义的过滤函数来扩展默认的操作。</p><h2 id="215c" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">保留冲洗</h2><p id="55a1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">添加了一个<code class="fe lb lc ld le b">res.flush</code>方法，强制将部分压缩的响应刷新到客户端。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/04a917d634444cc3d87d1a33bee0ff18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Lj9BWTSke12MDJS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rstone_design?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ryan Stone</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2b2e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">例子</h1><p id="1d9e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1542" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const compression = require('compression');</span><span id="1733" class="mq lg iq le b gy nv ms l mt mu">const app = express();<br/>const shouldCompress = (req, res) =&gt; {<br/>  if (req.headers['x-no-compression']) {<br/>    return false<br/>  }<br/>  return compression.filter(req, res);<br/>}</span><span id="c07a" class="mq lg iq le b gy nv ms l mt mu">app.use(bodyParser.json());<br/>app.use(compression({<br/>  filter: shouldCompress,<br/>  level: 7,<br/>}));</span><span id="5bf3" class="mq lg iq le b gy nv ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  const foo = 'foo';<br/>  res.send(foo.repeat(3000));<br/>});</span><span id="f26f" class="mq lg iq le b gy nv ms l mt mu">app.listen(3000);</span></pre><p id="a76a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们添加了<code class="fe lb lc ld le b">compression</code>中间件并指定了一些选项。</p><p id="5f63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们指定当<code class="fe lb lc ld le b">x-no-compression</code>头不存在时压缩我们的响应。</p><p id="582c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们改变了压缩级别。</p><p id="099e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了<code class="fe lb lc ld le b">x-no-compression</code>头，我们的响应是9KB。通过删除<code class="fe lb lc ld le b">x-no-compression</code>头启用压缩后，响应只有402字节。</p><p id="870b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，差异是巨大的。这是因为文本是重复的，所以它可以只保留其中的一部分，然后重复它，而不是存储整个字符串。</p><h1 id="805a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">服务器发送的事件</h1><p id="6fbb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用服务器发送的事件来压缩响应。为此，我们在输出窗口被缓冲后压缩内容。</p><p id="0e82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了这些，我们就可以把数据发送给客户端。</p><p id="a96e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">res.flush()</code>方法将任何存在的东西发送给客户端。</p><p id="ecdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="06b0" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const compression = require('compression');</span><span id="117f" class="mq lg iq le b gy nv ms l mt mu">const app = express();<br/>const shouldCompress = (req, res) =&gt; {<br/>  if (req.headers['x-no-compression']) {<br/>    return false<br/>  }<br/>  return compression.filter(req, res);<br/>}</span><span id="6f63" class="mq lg iq le b gy nv ms l mt mu">app.use(bodyParser.json());<br/>app.use(compression({<br/>  filter: shouldCompress,<br/>  level: 7,<br/>}));</span><span id="ad54" class="mq lg iq le b gy nv ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.setHeader('Content-Type', 'text/event-stream');<br/>  res.setHeader('Cache-Control', 'no-cache');<br/>  const timer = setInterval(() =&gt; {<br/>    res.write('foo');<br/>    res.flush()<br/>  }, 2000)</span><span id="c2ea" class="mq lg iq le b gy nv ms l mt mu">  res.on('close', () =&gt; {<br/>    clearInterval(timer)<br/>  })<br/>});</span><span id="3b2b" class="mq lg iq le b gy nv ms l mt mu">app.listen(3000);</span></pre><p id="34cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向客户端发送一个文本事件流，然后我们应该在屏幕上看到每2秒钟添加一次的<code class="fe lb lc ld le b">foo</code>。</p><h1 id="5f3d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="69b4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">compression</code>中间件对于压缩常规响应和服务器发送的事件输出非常有用。</p><p id="e909" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以设置压缩级别、块大小等选项。</p><p id="19b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果我们想要压缩服务器端事件，我们应该调用<code class="fe lb lc ld le b">res.flush</code>将已经缓冲的内容压缩后发送给客户端。</p></div></div>    
</body>
</html>