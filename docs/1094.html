<html>
<head>
<title>Demystifying JavaScript’s ‘This’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开JavaScript的“这个”的神秘面纱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-javascripts-this-e460d0d93ed9?source=collection_archive---------7-----------------------#2020-01-28">https://javascript.plainenglish.io/demystifying-javascripts-this-e460d0d93ed9?source=collection_archive---------7-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fbc5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这很容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/54ef3a6e6f281f6090b572eddc4a47db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9b7JlBTW1-tb3lRWzfPxw.png"/></div></div></figure><p id="e4c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于JavaScript (JS)初学者来说，最神秘、最令人困惑的概念之一是关键字“this”。让它如此令人困惑的是，它根据使用它的上下文表现不同。好消息是，一旦你理解了它的细微差别，你会发现‘这个’其实没那么复杂。让我们直接开始吧！</p><h2 id="722e" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><strong class="ak">这是什么？</strong></h2><p id="2bc1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">“This”是JavaScript语言中引用对象的关键字。该对象可以是以下两种情况之一:</p><ol class=""><li id="e9ff" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">“窗口”对象</li><li id="3544" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">对象的实例</li></ol><h1 id="f894" class="mz lo iq bd lp na nb nc ls nd ne nf lv jw ng jx ly jz nh ka mb kc ni kd me nj bi translated"><strong class="ak"> 1。窗口对象</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/362ea7e44084ca8110fb7483d8cadbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62nOReDjekOPifQQGW5fQA.png"/></div></div></figure><p id="ae4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">window对象代表文档对象模型(DOM)中的浏览器本身。它在DOM层次结构中占据最高位置，因为它是<em class="nl">文档</em>对象及其所有子对象的父对象。“This”在两种情况下可以引用窗口对象:</p><ul class=""><li id="7a6f" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm nm mr ms mt bi translated">当在全球范围内使用时</li><li id="0a08" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm nm mr ms mt bi translated">当在无基函数中使用时</li></ul><h2 id="e68c" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><strong class="ak">在全球范围内</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/fb304efc94e069b19c0261f038ffa6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4G3iGP4DOXKFpH_Y-jy8A.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">The keyword ‘this’ in a global context</figcaption></figure><p id="b43a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你打开repl.it for JavaScript并输入<code class="fe ns nt nu nv b"><em class="nl">console.log(this)</em></code> <em class="nl">，</em>，你会看到，如上所述，它显示了<em class="nl">本地浏览器窗口(在右边)</em>。或者，要在浏览器控制台中查看它，您可以在“index.js”文件中键入相同的命令，在“index.html”文件中引用，然后点击CMD + J(在Mac上)或CTRL + J(在PC上)。您将得到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1b36d437dec08b837e2e82076026390e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*U38mxTbaHA-yuY4_AmUNsg.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Logging out the value of ‘this’ in a browser console</figcaption></figure><p id="8915" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，“this”代表了<em class="nl">窗口</em>对象，它的直接子对象是文档对象。</p><h2 id="6098" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><strong class="ak">用于无基础功能时</strong></h2><p id="70f9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在JS中，无基函数是用关键字“function”定义的函数，与绑定到类/对象(即实例方法)的方法相反。当“this”用于常规无基函数时，它指的是<em class="nl">窗口</em>对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/f97afad7ddc1effceb7f7c70de5b2cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WfjaGWaI-Krxc_CBl71i_w.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">‘This’ refers to the ‘window’ object when called within a function not tied to any object</figcaption></figure><p id="4933" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们再次得到和以前一样的输出。</p><h1 id="6770" class="mz lo iq bd lp na nb nc ls nd ne nf lv jw ng jx ly jz nh ka mb kc ni kd me nj bi translated"><strong class="ak"> 2。一个对象的实例</strong></h1><p id="7c93" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><em class="nl"> ' </em>这个<em class="nl"> ' </em>也可以指一个对象的实例，就像在那个对象的<em class="nl">方法</em>中定义的情况一样。让我们在index.js文件中键入以下内容:</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="d6b2" class="ln lo iq nv b gy oc od l oe of">const pet = {</span><span id="221c" class="ln lo iq nv b gy og od l oe of">    name: 'Milou',</span><span id="b1ae" class="ln lo iq nv b gy og od l oe of">    bark(){</span><span id="3d09" class="ln lo iq nv b gy og od l oe of">           console.log(this);</span><span id="df46" class="ln lo iq nv b gy og od l oe of">    }//BARK()</span><span id="d8fd" class="ln lo iq nv b gy og od l oe of">}//PET</span><span id="914a" class="ln lo iq nv b gy og od l oe of">pet.bark();</span></pre><p id="01ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在浏览器控制台中看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bae33d10398c4a3762490d69f651888d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*d_9uNqh0Nijjzoslw8RxFQ.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">‘This’ as an object</figcaption></figure><p id="1911" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里,“this”的值是“pet”对象的名称属性及其“bark”方法。因此，“this”指的是一个特定的对象实例，而不是<em class="nl">窗口</em>对象。现在，让我们向pet对象添加另一个方法，看看“this”的计算结果是什么:</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="d054" class="ln lo iq nv b gy oc od l oe of">const pet = {</span><span id="6d33" class="ln lo iq nv b gy og od l oe of">       name: 'Milou',</span><span id="c3b7" class="ln lo iq nv b gy og od l oe of">       bark(){</span><span id="aaa6" class="ln lo iq nv b gy og od l oe of">              console.log(this)</span><span id="bebd" class="ln lo iq nv b gy og od l oe of">       }//BARK()</span><span id="92a2" class="ln lo iq nv b gy og od l oe of">}//PET</span><span id="ffba" class="ln lo iq nv b gy og od l oe of">//pet.bark();</span><span id="9fa6" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">pet.walk = function(){</strong></span><span id="0bb5" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">        console.log(this);<br/>}//WALK</strong></span><span id="a302" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">pet.walk();</strong></span></pre><p id="bca9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果是‘this’仍然像以前一样引用‘pet’对象，尽管我们在对象的定义之外使用‘function’关键字显式地定义了它。那是因为它仍然在一个类函数或方法的上下文中，并且“this”从它被执行的地方获得它的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/daf0aa902b3826aebbe7e0600008a049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*h39iZyoa7yHyqqJ5qBRf8g.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">‘This’ still refers to the object</figcaption></figure><p id="81a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们使用一个构造函数来输出' this '的值会发生什么？JS中的构造函数是使用对象名的大写字母定义的，并使用“new”操作符调用。我们可以按如下方式重构代码:</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="d369" class="ln lo iq nv b gy oc od l oe of">const pet = {</span><span id="908c" class="ln lo iq nv b gy og od l oe of">      name: 'Milou',</span><span id="e5d4" class="ln lo iq nv b gy og od l oe of">      bark(){</span><span id="913c" class="ln lo iq nv b gy og od l oe of">              console.log(this)</span><span id="4140" class="ln lo iq nv b gy og od l oe of">      }//BARK()</span><span id="d10d" class="ln lo iq nv b gy og od l oe of">}//PET</span><span id="45e3" class="ln lo iq nv b gy og od l oe of">//pet.bark();</span><span id="2cc7" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">function Pet(petName){//Pet constructor</strong></span><span id="134e" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">     this.name = petName;</strong></span><span id="5e15" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">     console.log(this);</strong></span><span id="c9ac" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">}//PET Constructor</strong></span><span id="7473" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">const dog = new Pet('Scooby');</strong></span></pre><p id="5636" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:<em class="nl">构造函数通常在类内部定义，然而JS也允许我们在类外部创建它。</em></p><p id="2f83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4fb89cc2b2520a4893ccc0718f846286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*rA5bcM_hM46jUgDgohYWRA.png"/></div></figure><p id="c66e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，尽管这被定义为“宠物”对象之外的一个函数，但它仍然引用宠物对象的一个实例。请注意，它现在引用的是一个新实例，其名称是“Scooby”而不是“Milou”。每当我们使用<em class="nl"> new </em>操作符调用一个函数时，即一个构造函数，“this”将总是指向正在被实例化的对象。构造函数也是一个对象的方法，因此“this”仍然指的是对象实例，而不是全局<em class="nl">窗口</em>对象。</p><p id="6ecf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试试别的东西。如果我们修改代码，将一个数组作为pet对象的属性，然后在对象中输出它的值，会怎么样呢？</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="a019" class="ln lo iq nv b gy oc od l oe of">const pet = {</span><span id="ca90" class="ln lo iq nv b gy og od l oe of">      name: 'Milou',</span><span id="9525" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">      colors: ['black', 'brown', 'white'],</strong></span><span id="4232" class="ln lo iq nv b gy og od l oe of">      <strong class="nv ir">petColors(){</strong></span><span id="b8dd" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">              this.colors.forEach(function(color){</strong></span><span id="285a" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">                  console.log(color);</strong></span><span id="1c12" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">               });//FOREACH</strong></span><span id="f0da" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">      }//PETCOLORS()</strong></span><span id="7b1a" class="ln lo iq nv b gy og od l oe of">}//PET</span><span id="348d" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">pet.petColors();</strong></span></pre><p id="cab9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们添加了一个颜色数组和一个<em class="nl"> petcolors </em>方法来显示它们。然后' This '被用来引用对象的颜色，调用<em class="nl"> forEach </em>方法来注销每种颜色。正如所料，This仍然指向pet对象，因为它是通过“petcolor”方法与<em class="nl">对象联系在一起的。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c8f384240afce6acf8d5c33149dbffd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*r0-4hFUWeh_oBRbp6JjBJw.png"/></div></figure><p id="2eae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想在每种颜色旁边显示宠物的名字呢？我们可以通过在“console”语句中添加<em class="nl"> name </em>属性来修改输出:</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="b684" class="ln lo iq nv b gy oc od l oe of">console.log(this.name, color);</span></pre><p id="52b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据浏览器的不同，您可能会在每种颜色旁边看到“未定义”，或者出现一个<em class="nl">无声错误</em>，其中“this.name”根本不显示任何值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9914708e5c0f8f3dec6571b8ac3dad9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*jCsgnz2r6RbfJSyYrX9oDw.png"/></div></figure><p id="8420" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">发生了什么事？为了搞清楚这一点，让我们看看“这”等于什么:</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="c180" class="ln lo iq nv b gy oc od l oe of">console.log(this);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/8a8735415e585dc26a4de281c6016bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*A3D79KVtfePJ1XyiQXT28Q.png"/></div></figure><p id="5782" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇哦。！！' This '引用了窗口对象！这怎么可能呢？它不是在“petColors”方法内部使用的吗？？这里发生的情况是，尽管“this”在对象方法内部，但它进一步嵌套在<em class="nl"> forEach的</em>回调函数中！回调函数之所以存在，是因为它是<em class="nl"> forEach </em>迭代器所需要的；该函数与pet对象没有任何联系(即，pet对象的方法)。换句话说，这个函数只是一个常规函数，就像我们之前介绍的“global_this”函数一样，因此引用了全局<em class="nl">窗口</em>对象。This总是根据它的执行位置来获取它的值。</p><p id="c679" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们如何补救这种情况？<em class="nl"> forEach </em>允许传递一个对象作为第二个参数，“thisArgs”。在这种情况下，我们将通过“this”传递实际的宠物对象作为参数。</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="f4c8" class="ln lo iq nv b gy oc od l oe of">const pet = {</span><span id="c6fa" class="ln lo iq nv b gy og od l oe of">      name: 'Milou',</span><span id="dbcd" class="ln lo iq nv b gy og od l oe of">      colors: ['black', 'brown', 'white'],</span><span id="5ab3" class="ln lo iq nv b gy og od l oe of">      petColors(){</span><span id="7785" class="ln lo iq nv b gy og od l oe of">             this.colors.forEach(function(color){</span><span id="0746" class="ln lo iq nv b gy og od l oe of">                  console.log(this.name, color);</span><span id="8dfd" class="ln lo iq nv b gy og od l oe of">             }, <strong class="nv ir">this</strong>);//FOREACH</span><span id="923f" class="ln lo iq nv b gy og od l oe of">      }//PETCOLORS()</span><span id="6a80" class="ln lo iq nv b gy og od l oe of">}//PET</span><span id="b77a" class="ln lo iq nv b gy og od l oe of">pet.petColors();</span><span id="0a86" class="ln lo iq nv b gy og od l oe of">}//PET</span><span id="0b4d" class="ln lo iq nv b gy og od l oe of">pet.petColors();</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/d4394bf3c503734032fe67dc798c17ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*ectM3zFR7jM1LY1OMCJ5xg.png"/></div></figure><p id="2c5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过将“this”作为<em class="nl"> forEach </em>迭代器的第二个参数传递(即在回调函数之外)，语句“this.name”现在将引用pet对象，而不是全局(窗口)对象。要进一步了解这一点，请将第二个参数替换为下面的object {name: 'Scooby'}，看看会发生什么。</p><p id="d667" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解决这个问题的另一种方法是将“forEach”中的函数转换为匿名回调函数:</p><pre class="kg kh ki kj gt ny nv nz oa aw ob bi"><span id="c344" class="ln lo iq nv b gy oc od l oe of">petColors(){</span><span id="1da5" class="ln lo iq nv b gy og od l oe of">this.colors.forEach(<strong class="nv ir">(color) =&gt; {</strong></span><span id="419c" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">console.log(this.name, color);</strong></span><span id="50aa" class="ln lo iq nv b gy og od l oe of"><strong class="nv ir">}</strong>);//FOREACH</span></pre><p id="08ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将把“This”绑定到对象实例。</p><p id="f0a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">概括地说，作为一条经验法则，“this”指的是以下两种情况之一:</p><ol class=""><li id="26b9" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">一个对象，如果在该对象的方法中调用它。它的值取决于它在代码中的执行位置。</li><li id="80cf" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">全局“窗口”对象，如果它在全局函数之外、常规函数或匿名回调函数中被调用，只要它没有被强制通过参数、箭头函数或<em class="nl"> bind() </em>方法引用对象实例。</li></ol><p id="1bc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于这篇文章是针对JavaScript初学者的，我们所涵盖的内容足以让你牢牢掌握关键字“this”。然而，围绕它有更多的细微差别。有关更多详细信息，请参见下面的MDN web文档。</p><div class="om on gp gr oo op"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">这</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">与其他语言相比，函数的this关键字在JavaScript中的行为略有不同。它也有一些…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">developer.mozilla.org</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd kp op"/></div></div></a></div><h2 id="6e5d" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">快乐编码:)</h2></div></div>    
</body>
</html>