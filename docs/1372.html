<html>
<head>
<title>The Best Way to Type Check in Vanilla JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在普通JS中键入Check的最佳方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-best-way-to-type-check-in-vanilla-js-55197b4f45ec?source=collection_archive---------1-----------------------#2020-03-08">https://javascript.plainenglish.io/the-best-way-to-type-check-in-vanilla-js-55197b4f45ec?source=collection_archive---------1-----------------------#2020-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b09" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在JavaScript中检查变量类型的最好方法不是<code class="fe kf kg kh ki b">typeof</code>。以下是为什么使用<code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>的原因，以及如何将其别名化为自定义的<code class="fe kf kg kh ki b">type_of</code>函数。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b665e1fc899b22f8b6fd38939248aad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0tjmXuo567rD1-0v"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@fransaraco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Francesca Saraco</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6838" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">用JavaScript中的<code class="fe kf kg kh ki b">typeof</code>进行类型检查</h1><p id="3020" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di"> E </span>大家都知道<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank">typeof</a></code> <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank">关键字</a>有些问题，最明显的是<code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">typeof</a></code> <a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">返回</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">"object"</a></code> <a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">为</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">null</a></code>:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mx"><img src="../Images/a1bd08a6e84afbbb79386a9a8fedfba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5cAYwYj1hi-607srrrXzKw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Source: <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank">MDN Docs</a></figcaption></figure><p id="9186" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">值得庆幸的是，有一个更好的解决方案可以使用<a class="ae kz" href="https://snipcart.com/blog/learn-vanilla-javascript-before-using-js-frameworks#definition" rel="noopener ugc nofollow" target="_blank"> vanilla JavaScript </a>，尽管它有点拗口:<code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>。</p><p id="ba44" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">注意，我所说的普通JS是指根本不使用任何外部库，只使用ES5 ( <a class="ae kz" href="http://speakingjs.com/es5/ch25.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript5 </a>)特性。</p><p id="238e" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">(网站<a class="ae kz" href="http://vanilla-js.com/" rel="noopener ugc nofollow" target="_blank">vanilla-js.com</a>会开玩笑地让你下载一个空的“香草JS库”文件——因为浏览器内置了香草JavaScript。)</p><p id="0b7b" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">先说<code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>然后试着用一下。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="7953" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">为什么<code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>有效</h1><p id="c197" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di">E</span>JavaScript中的非常对象都有一个默认的<code class="fe kf kg kh ki b">.toString()</code>方法，它依赖于<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#Object_instances_and_Object_prototype_object" rel="noopener ugc nofollow" target="_blank">Object</a></code> <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#Object_instances_and_Object_prototype_object" rel="noopener ugc nofollow" target="_blank">原型</a>(<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" rel="noopener ugc nofollow" target="_blank">Object.prototype.toString()</a></code>方法)。</p><blockquote class="np nq nr"><p id="9636" class="ls lt ns lu b lv my jr lx ly mz ju ma nt na md me nu nb mh mi nv nc ml mm mn ij bi translated"><strong class="lu ir">使用</strong> <code class="fe kf kg kh ki b"><strong class="lu ir">toString()</strong></code> <strong class="lu ir">来检测对象类</strong></p><p id="7d0f" class="ls lt ns lu b lv my jr lx ly mz ju ma nt na md me nu nb mh mi nv nc ml mm mn ij bi translated"><code class="fe kf kg kh ki b">toString()</code>可以和每一个对象一起使用并允许你得到它的类。</p><p id="61f7" class="ls lt ns lu b lv my jr lx ly mz ju ma nt na md me nu nb mh mi nv nc ml mm mn ij bi translated">要对每个对象使用<code class="fe kf kg kh ki b">Object.prototype.toString()</code>，您需要对其调用<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener ugc nofollow" target="_blank">Function.prototype.call()</a></code>或<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank">Function.prototype.apply()</a></code>，将您想要检查的对象作为第一个参数传递(称为<code class="fe kf kg kh ki b">thisArg</code>)。<em class="iq"> — </em> <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#Using_toString_to_detect_object_class" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> MDN文档</em> </a></p></blockquote><p id="a3b7" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">虽然默认的<code class="fe kf kg kh ki b">.toString()</code>方法可以被覆盖，但是对象原型的版本返回一个字符串，第二个字是type。</p><blockquote class="np nq nr"><p id="72b0" class="ls lt ns lu b lv my jr lx ly mz ju ma nt na md me nu nb mh mi nv nc ml mm mn ij bi translated">如果此方法未在自定义对象中重写，<code class="fe kf kg kh ki b">toString()</code>将返回“<code class="fe kf kg kh ki b">[object type]</code>”，其中<code class="fe kf kg kh ki b">type</code>是对象类型— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#Description" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="dce5" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">通过使用<code class="fe kf kg kh ki b">.call()</code>或<code class="fe kf kg kh ki b">.apply()</code>，我们可以使用所有对象从<code class="fe kf kg kh ki b">Object</code>原型继承的原始的<code class="fe kf kg kh ki b">.toString()</code>方法。</p><p id="24cd" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">这个原始的<code class="fe kf kg kh ki b">Object.prototype.toString()</code>方法总是返回包含特定对象类型的字符串<code class="fe kf kg kh ki b">`object ${type}`</code>，比如<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date" rel="noopener ugc nofollow" target="_blank">Date</a></code>。</p><p id="5f22" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">接下来我使用<code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>和<code class="fe kf kg kh ki b">typeof</code>进行比较。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="e01b" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated"><code class="fe kf kg kh ki b">Object.prototype.toString.call()</code> vs. <code class="fe kf kg kh ki b">typeof</code></h1><p id="70d1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi mo translated">对于JavaScript中的类型检查，U  sing <code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>比<code class="fe kf kg kh ki b">typeof</code>工作得多，因为它对于<code class="fe kf kg kh ki b">null</code>工作得很好。</p><p id="263a" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">不仅如此，它还返回任何给定对象的特定类型:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="745c" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">创建一个<code class="fe kf kg kh ki b">type_of</code>功能</h1><p id="2884" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di"> G </span>鉴于用JavaScript写一个函数是多么容易，为<code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>做一个<code class="fe kf kg kh ki b">type_of</code>函数也是超级容易的。</p><p id="9d7c" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">下面是这样做的一个示例，它只返回小写数据类型:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="e8e4" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">对象包装原语？没问题</h1><p id="45d0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi mo translated">将<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">new</a></code> <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">关键字</a>与JavaScript中的<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="noopener ugc nofollow" target="_blank">Number()</a></code> <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="noopener ugc nofollow" target="_blank">函数</a>之类的包装对象一起使用通常被认为是不好的做法。</p><p id="a5b6" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">这样做就创建了所谓的<a class="ae kz" href="https://www.tutorialspoint.com/how-to-get-the-primitive-value-of-string-in-javascript" rel="noopener ugc nofollow" target="_blank">一个对象包装的原语</a>:一个实际上是对象的原语值(所以<code class="fe kf kg kh ki b">typeof</code>返回<code class="fe kf kg kh ki b">"object"</code>)。</p><p id="4eb1" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">我们不希望这样的原因是这些对象包装器是在幕后调用的，允许我们访问原语的属性。</p><p id="ba28" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">一个例子是<code class="fe kf kg kh ki b">"string".length</code>，其中<a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-string-in-javascript-a16b196915ff" rel="noopener">字符串</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-string-in-javascript-a16b196915ff" rel="noopener">"string"</a></code>是一个原语，因此JavaScript解释器自动创建一个对象。</p><p id="83e5" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">但是，如果需要，我们可以使用<code class="fe kf kg kh ki b">Object.prototype.toString.call()</code>来检测代码中对象包装原语的真实类型(对象类):</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e3ec" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">将对象包装的原语转换回原语值的另一种方法是调用<code class="fe kf kg kh ki b">.valueOf()</code>方法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="6f0a" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">结论</h1><p id="2a11" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di">它</span>绝对是满嘴的。将此页面加入书签，以便您可以复制粘贴:<code class="fe kf kg kh ki b">Object.prototype.toString.call().slice(8,-1).toLowerCase()</code></p><p id="7da8" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">希望你现在明白为什么<code class="fe kf kg kh ki b">typeof</code>有点糟糕了——它为所有对象类型返回<code class="fe kf kg kh ki b">"object"</code>,包括数组，也为<code class="fe kf kg kh ki b">null</code>返回。</p><p id="a543" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">如果你不相信，或者你需要复习一下<code class="fe kf kg kh ki b">typeof</code>，你可以看看我写的关于<a class="ae kz" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">如何在JavaScript </a>中使用 <code class="fe kf kg kh ki b"><a class="ae kz" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">typeof</a></code> <a class="ae kz" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">而不是在更好的编程中使用</a><a class="ae kz" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener"/>:</p><div class="ny nz gp gr oa ob"><a href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">如何使用typeof检查JavaScript中的数据类型</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">检查九个字符串之一:undefined、object (null)、boolean、number、bigint、string、symbol、function或object…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kt ob"/></div></div></a></div><p id="1771" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">抱歉<code class="fe kf kg kh ki b">typeof</code>，你的<a class="ae kz" href="https://2ality.com/2013/10/typeof-null.html" rel="noopener ugc nofollow" target="_blank">与</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://2ality.com/2013/10/typeof-null.html" rel="noopener ugc nofollow" target="_blank">typeof null</a></code>的长期bug意味着在JavaScript中有更好的方式来输入check:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="38ed" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">我希望在你的代码中看到<code class="fe kf kg kh ki b">type_of</code>！<strong class="lu ir">快乐编码！</strong>💻👩‍💻💯🥳</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="6488" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">附言</h1><p id="acd1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated"><a class="oq or ep" href="https://medium.com/u/7ff73ef0ff02?source=post_page-----55197b4f45ec--------------------------------" rel="noopener" target="_blank"> Slo Mo </a>在回复这篇博文时指出有可能改变<code class="fe kf kg kh ki b">Object.prototype.toString()</code>的默认行为。</p><blockquote class="np nq nr"><p id="7a30" class="ls lt ns lu b lv my jr lx ly mz ju ma nt na md me nu nb mh mi nv nc ml mm mn ij bi translated">这样用<code class="fe kf kg kh ki b">toString()</code>不靠谱；对象可以通过定义一个<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag" rel="noopener ugc nofollow" target="_blank">Symbol.toStringTag</a></code>属性来改变<code class="fe kf kg kh ki b">Object.prototype.toString()</code>的行为，导致意想不到的结果。</p></blockquote><p id="b6cd" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">这听起来似乎应该有更好的选择，但遗憾的是没有。在我关于JavaScript数组类型检查的文章<a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-check-for-an-array-in-javascript-6ad20f7a0e21" rel="noopener">中，我深入研究了可选的类型检查，如<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank">instanceof</a></code>和<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" rel="noopener ugc nofollow" target="_blank">.constructor</a></code>:</a></p><div class="ny nz gp gr oa ob"><a href="https://medium.com/javascript-in-plain-english/how-to-check-for-an-array-in-javascript-6ad20f7a0e21" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">如何在JavaScript中检查数组</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">JavaScript数组是一种对象类型，所以typeof []返回“object”——对于查看您是否有数组没有太大帮助…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="os l om on oo ok op kt ob"/></div></div></a></div><p id="8f2c" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">基本上<code class="fe kf kg kh ki b">instanceof</code>在<code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" rel="noopener ugc nofollow" target="_blank">iframes</a></code>里是行不通的，<code class="fe kf kg kh ki b">.constructor</code>可以直接在任何对象上覆盖。</p><p id="1ec7" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">比较<code class="fe kf kg kh ki b">.constructor</code>和<code class="fe kf kg kh ki b">Object.prototype.toString()</code>，我感觉我通过定义一个<code class="fe kf kg kh ki b">Symbol.toStringTag</code>属性来破坏<code class="fe kf kg kh ki b">Object.prototype.toString()</code>的可能性比重写<code class="fe kf kg kh ki b">.constructor</code>要小。</p><p id="840b" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">如果您错误地将<a class="ae kz" href="https://medium.com/better-programming/making-sense-of-vs-in-javascript-f9dbbc6352e3" rel="noopener">的等号运算符</a> ( <code class="fe kf kg kh ki b">==</code>或<code class="fe kf kg kh ki b">===</code>)改为<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment" rel="noopener ugc nofollow" target="_blank">的赋值运算符</a> ( <code class="fe kf kg kh ki b">=</code>)，很容易意外覆盖<code class="fe kf kg kh ki b">.constructor</code>:</p><pre class="kk kl km kn gt ot ki ou ov aw ow bi"><span id="de3a" class="ox lb iq ki b gy oy oz l pa pb">if(object.constructor = "Date") {} // whoops!</span><span id="7e85" class="ox lb iq ki b gy pc oz l pa pb">if(object.constructor === "Date") {} // correct</span></pre><p id="3da2" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">基于我广泛的研究，我还没有找到比<code class="fe kf kg kh ki b">Object.prototype.toString()</code>更好的类型检查解决方案，尽管它有不可靠性。</p><p id="12be" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">综上所述，我认为我们都可以从更严格的类型检查系统中受益，比如<a class="ae kz" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>、<a class="ae kz" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank"> Flow </a>，或者仅仅是<a class="ae kz" href="https://code.visualstudio.com/docs/nodejs/working-with-javascript" rel="noopener ugc nofollow" target="_blank">VS代码内置的TypeScript特性</a>。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="a0a1" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">进一步阅读</h1><ul class=""><li id="4d72" class="pd pe iq lu b lv lw ly lz mb pf mf pg mj ph mn pi pj pk pl bi translated"><a class="oq or ep" href="https://medium.com/u/4bd9ef570b9b?source=post_page-----55197b4f45ec--------------------------------" rel="noopener" target="_blank"> Damian Cipolat </a>结合<code class="fe kf kg kh ki b">typeof</code>和<code class="fe kf kg kh ki b">assert</code>在上检查类型<a class="ae kz" href="https://dev.to/damxipo/pure-dynamic-type-check-in-javascript-2l29" rel="noopener ugc nofollow" target="_blank">:</a></li></ul><div class="ny nz gp gr oa ob"><a href="https://dev.to/damxipo/pure-dynamic-type-check-in-javascript-2l29" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">javascript中的纯动态类型检查</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">在本文中，我将展示仅使用Javascript进行动态类型检查的3种方法。什么是动态类型检查…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">开发到</p></div></div><div class="ok l"><div class="pm l om on oo ok op kt ob"/></div></div></a></div><ul class=""><li id="f987" class="pd pe iq lu b lv my ly mz mb pn mf po mj pp mn pi pj pk pl bi translated"><a class="ae kz" href="https://webbjocke.com/javascript-check-data-types/" rel="noopener ugc nofollow" target="_blank">Webbjocke博客</a>使用<code class="fe kf kg kh ki b">typeof</code>搭配<code class="fe kf kg kh ki b">instance_of</code>和<code class="fe kf kg kh ki b">.constructor</code>:</li></ul><div class="ny nz gp gr oa ob"><a href="https://webbjocke.com/javascript-check-data-types/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">如何更好地检查javascript中的数据类型— Webbjocke</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">检查javascript中的数据类型并不总是最容易的。语言本身提供了一个操作符…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">webbjocke.com</p></div></div><div class="ok l"><div class="pq l om on oo ok op kt ob"/></div></div></a></div><ul class=""><li id="284a" class="pd pe iq lu b lv my ly mz mb pn mf po mj pp mn pi pj pk pl bi translated">Ryland G 认为也许你应该在开发工具上使用TypeScript<a class="ae kz" href="https://dev.to/taillogs/practical-ways-to-write-better-javascript-26d4" rel="noopener ugc nofollow" target="_blank"/>:</li></ul><div class="ny nz gp gr oa ob"><a href="https://dev.to/taillogs/practical-ways-to-write-better-javascript-26d4" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">编写更好JavaScript的实用方法</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">提高你的JS的可靠方法。用javascript做标签，webdev，初学者，react。</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">开发到</p></div></div><div class="ok l"><div class="pr l om on oo ok op kt ob"/></div></div></a></div><ul class=""><li id="53eb" class="pd pe iq lu b lv my ly mz mb pn mf po mj pp mn pi pj pk pl bi translated"><a class="oq or ep" href="https://medium.com/u/d55832d5b3b1?source=post_page-----55197b4f45ec--------------------------------" rel="noopener" target="_blank"> Fernando Doglio </a>对比<a class="ae kz" href="https://blog.bitsrc.io/static-type-checking-vs-dynamic-type-checking-in-javascript-13643f4952a9" rel="noopener ugc nofollow" target="_blank">零碎的流程和打字稿</a>:</li></ul><div class="ny nz gp gr oa ob"><a href="https://blog.bitsrc.io/static-type-checking-vs-dynamic-type-checking-in-javascript-13643f4952a9" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">JavaScript中的静态类型检查与动态类型检查</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">您更喜欢在执行期间还是在捆绑期间(或之前的任何阶段)发现bug</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">blog.bitsrc.io</p></div></div><div class="ok l"><div class="ps l om on oo ok op kt ob"/></div></div></a></div><ul class=""><li id="fc7e" class="pd pe iq lu b lv my ly mz mb pn mf po mj pp mn pi pj pk pl bi translated"><a class="ae kz" href="http://seg.phault.net/about/" rel="noopener ugc nofollow" target="_blank"> Ryan Paul </a>在他的博客上解释说，你可以使用VSCode来突出显示类型脚本类型错误，而不需要实际上传你的JavaScript <a class="ae kz" href="http://seg.phault.net/blog/2017/10/typescript-without-transpiling/" rel="noopener ugc nofollow" target="_blank">:</a></li></ul><div class="ny nz gp gr oa ob"><a href="http://seg.phault.net/blog/2017/10/typescript-without-transpiling/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">无需传输文件即可获得TypeScript的优势</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">编辑描述</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">seg.phault.net</p></div></div><div class="ok l"><div class="pt l om on oo ok op kt ob"/></div></div></a></div><ul class=""><li id="204d" class="pd pe iq lu b lv my ly mz mb pn mf po mj pp mn pi pj pk pl bi translated"><a class="oq or ep" href="https://medium.com/u/b9e31d4262c1?source=post_page-----55197b4f45ec--------------------------------" rel="noopener" target="_blank"> Martin Hochel </a>在他的中型博客上写了关于vanilla JS <a class="ae kz" href="https://medium.com/@martin_hotell/build-100-type-safe-react-apps-in-vanilla-javascript-bd29a8364078" rel="noopener">中的类型安全:</a></li></ul><div class="ny nz gp gr oa ob"><a href="https://medium.com/@martin_hotell/build-100-type-safe-react-apps-in-vanilla-javascript-bd29a8364078" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">用普通JavaScript构建100%类型安全的React应用程序</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">或者我们如何充分利用TypeScript，而不必在我们的代码库中编写任何TS，通过利用…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.co</p></div></div><div class="ok l"><div class="pu l om on oo ok op kt ob"/></div></div></a></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pv"><img src="../Images/f244f0eadf181464f6d1992907427cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMPfA_ZtfUPfKiihcf6PNA.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@fransaraco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Francesca Saraco</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="fb25" class="pw-post-body-paragraph ls lt iq lu b lv my jr lx ly mz ju ma mb na md me mf nb mh mi mj nc ml mm mn ij bi translated">德里克·奥斯汀博士是《职业规划:如何在6个月内成为成功的6位数程序员 的作者，该书现已在亚马逊上架。</p></div></div>    
</body>
</html>