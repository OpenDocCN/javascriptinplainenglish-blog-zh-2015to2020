<html>
<head>
<title>Next.js SSR vs. SSG &amp; Incrementalism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">next . js SSR vs SSG &amp;渐进性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-ssr-vs-ssg-incrementalism-pt-2-2-3928757e9dc?source=collection_archive---------1-----------------------#2020-11-16">https://javascript.plainenglish.io/next-js-ssr-vs-ssg-incrementalism-pt-2-2-3928757e9dc?source=collection_archive---------1-----------------------#2020-11-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="06a0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第二部分</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cc382fc591ee6811dc9f782409863a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SbLwZL5iXZqfFZmo"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@sctgrhm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Graham</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="65a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我的上一篇文章中，我回顾了客户端渲染(CSR)和服务器端渲染(SSR)的一些基础知识。如果你不熟悉，请点击这里查看:</p><div class="lp lq gp gr lr ls"><a href="https://medium.com/javascript-in-plain-english/next-js-ssr-vs-ssg-incrementalism-pt-1-2-490bce12d97" rel="noopener follow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">next . js SSR vs SSG &amp;渐进性</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">第一部分</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">medium.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg km ls"/></div></div></a></div><p id="c54c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create React App </a>是CSR app的典范，<a class="ae ks" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>是SSR世界的引子。如前所述，Next.js通过大量选项将服务器上的所有渲染提升到了一个新的水平，因此这篇文章将通过用例解释它的一些功能。</p><p id="996f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">🗒快速提示:你可以谷歌一下“CRA SSR ”,有很多事情可以做。我只是在谈论基本的开箱即用功能。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="69d4" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">Next.js中的预渲染</h1><p id="d5ac" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">Next.js侧重于预渲染，这是一个比SSR更通用的术语。<a class="ae ks" href="https://nextjs.org/docs/basic-features/pages#pre-rendering" rel="noopener ugc nofollow" target="_blank">文档</a>描述预渲染包括两件事:</p><ol class=""><li id="b098" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">服务器端渲染(SSR)，就像上一篇文章谈到的那样</li><li id="eea6" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">静态发电(SSG =静态站点发电)</li></ol><p id="35d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">SSG类似于SSR，服务器负责预渲染HTML(没有CSR！)，但是<strong class="kv io">它发生在构建时，</strong>即一个现成的Next.js项目的<code class="fe oa ob oc od b">npm run build</code>。一般来说，你可以静态地构建对所有客户都一样的页面(营销页面、博客文章页面等)。更多关于用例的内容将会出现)。</p><p id="b4cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为什么构建时生成的东西很棒？</p><ol class=""><li id="f306" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">当你运行一个<code class="fe oa ob oc od b">build</code>命令时，这是在实际访问你的站点的人的工作流程之外，所以如果花一点时间也没问题</li><li id="e766" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">一旦你的SSG页面建好了，它们就可以放在CDN里了。这意味着HTML位于世界各地的边缘位置，浏览器为用户请求和呈现这些内容的速度非常快</li><li id="b345" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">您的web服务器将不必为从CDN提供的静态生成的页面做任何工作，因此您不需要担心它在这种情况下的性能</li></ol><p id="deed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些优势融合了CSR和SSR的优势，就像我在上一篇文章中描述的那样——即服务器负责创建实际的HTML，但我们仍然可以将其放在CDN中。Next.js文档的主题实际上变成了“如果你能用SSG做用例，就去做吧。</p><p id="afbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Next.js文档很棒，但是有几个概念让我对SSG有了更好的选择。下面的用例试图澄清一些事情。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="68c3" class="mp mq in bd mr ms mt mu mv mw mx my mz jt na ju nb jw nc jx nd jz ne ka nf ng bi translated">密码</h1><p id="1842" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">代码样本可以在这个回购这里找到<a class="ae ks" href="https://github.com/neightjones/next-ssr-ssg-blog" rel="noopener ugc nofollow" target="_blank">https://github.com/neightjones/next-ssr-ssg-blog</a></p><h1 id="7b28" class="mp mq in bd mr ms oe mu mv mw of my mz jt og ju nb jw oh jx nd jz oi ka nf ng bi translated">用例1:简单的营销页面</h1><p id="6de8" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">这个例子很清楚。假设我们有一个“关于我们”页面，由一个没有数据获取或任何东西的组件组成——只是一个静态页面。查看报告中的<a class="ae ks" href="https://github.com/neightjones/next-ssr-ssg-blog/blob/master/pages/AboutUs.js" rel="noopener ugc nofollow" target="_blank">关于我们的页面。</a></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="1e01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们当然希望它在构建时静态生成，因为这很简单。每个用户都会看到同样的东西，所以可以直接从CDN获得服务。幸运的是，SSG是Next.js的默认版本。当您运行<code class="fe oa ob oc od b">npm run build</code>时，它将变成一个基本的HTML页面，一切都准备好了。</p><h1 id="e5f2" class="mp mq in bd mr ms oe mu mv mw of my mz jt og ju nb jw oh jx nd jz oi ka nf ng bi translated">用例2:博客文章列表</h1><p id="8049" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">现在我们已经超越了案例1，更棘手的案例都将涉及某种动态内容。这可能意味着两件事:</p><ol class=""><li id="6e7d" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">页面上的某些内容会随着时间的推移而改变(例如，您向您的博客添加了新的博客帖子，所以现在列出这些内容的页面需要显示新的帖子)</li><li id="1801" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">由于新的内容，已经存在的页面集合会扩大(例如，现在你添加了一个新的博客帖子，你可能会有一个额外的页面，像<code class="fe oa ob oc od b">/posts/&lt;new_post_id&gt;</code></li></ol><p id="8883" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们首先关注这个组件，列出我们所有的博客文章。这是在Next.js中使用服务器端渲染的情况吗？毕竟，随着博客文章的增加，我刷新我的浏览器，我想看到所有最新的文章。有了SSR，我对列表页面的请求每次都会被构建在服务器上，然后服务器总是会从数据库(或者文件系统，但是我的博客文章是被存储的)中获取最新的内容。SSR会给你你想要的结果，但是Next.js可以做得更好。</p><p id="eea9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">进入<strong class="kv io"> <em class="mh">带数据静态生成。</em> </strong>下一步。js有一个内置的方法来完成SSG，即在<strong class="kv io">构建</strong>时依赖外部数据，所以您可以预构建所有需要的东西并将其放入CDN中。你需要做的就是在你的一个页面组件上实现一个名为<code class="fe oa ob oc od b">getStaticProps</code>的<code class="fe oa ob oc od b">async</code>函数。</p><p id="6459" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我不会重新发明轮子，但这里有一个简单的例子。<a class="ae ks" href="https://nextjs.org/docs/basic-features/pages#static-generation-with-data" rel="noopener ugc nofollow" target="_blank">查看此处单据</a>可了解更多详细信息。<a class="ae ks" href="https://github.com/neightjones/next-ssr-ssg-blog/blob/master/pages/BlogList.js" rel="noopener ugc nofollow" target="_blank">此处链接至回购组件。</a></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="dc95" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于<code class="fe oa ob oc od b">getStaticProps</code>已经实现，Next将知道在构建时运行<code class="fe oa ob oc od b">getBlogs</code>(并且在服务器上)，这将创建显示博客文章列表的最终HTML。这个页面可以位于CDN中，所以在浏览器中访问和渲染会非常快。</p><p id="c77b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可能也希望每个博客帖子有一个页面，就像<code class="fe oa ob oc od b">/posts/&lt;some_post_id&gt;</code>一样。Next.js还使得在构建时静态生成这些<strong class="kv io">路径&amp;页面</strong>变得容易。因此，如果你有3篇id为1、2和3的博客文章，你可以使用SSG预渲染3个适当的博客页面，路径都设置为go ( <code class="fe oa ob oc od b">/posts/1</code>、<code class="fe oa ob oc od b">/posts/2</code>和<code class="fe oa ob oc od b">/posts/3</code>)。要做到这一点，您需要结合使用<code class="fe oa ob oc od b">getStaticPaths</code>和<code class="fe oa ob oc od b">getStaticProps</code>。不需要重新创建文档，<a class="ae ks" href="https://nextjs.org/docs/basic-features/pages#scenario-2-your-page-paths-depend-on-external-data" rel="noopener ugc nofollow" target="_blank">所以在这里检查一下</a>。</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="029e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于数据的静态生成，我们现在可以在构建时构建所有的博客文章页面和路径，这很棒。如果你写了一篇新的博文会怎么样？所有内容都是在构建时生成的，所以如果你刷新浏览器，你就看不到新的帖子了。在这种情况下，最好的办法是重建网站，这样就可以获得最新的内容。这可能看起来有点烦人，但是内容不会太频繁地改变<em class="mh">和</em>，并且您可以自动化您的博客的构建/部署过程。</p><p id="f7ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">重建和部署的需求当然回避了这个问题——在什么情况下内容变化太快或者变得太大而不值得一直重建你的站点？另一个要考虑的因素是哪些用户可以访问各种内容？对于博客的例子，我假设它是完全公开的。但是，如果有一些私人的，每个用户的数据，我们不希望预先渲染用户数据的一切。下一个用例展示了Next.js中的几个SSG技巧，以处理更多的复杂性。</p><h1 id="f592" class="mp mq in bd mr ms oe mu mv mw of my mz jt og ju nb jw oh jx nd jz oi ka nf ng bi translated">用例3:成长中的电子商务网站</h1><p id="b6ae" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">这个例子基于Vercel(next . js的开发者)的这篇博客文章。我会总结一下，但我也建议浏览他们的完整帖子。</p><p id="203b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面，我们用数据的静态生成处理了你的博客站点的预渲染策略。现在，你有一个快速增长的电子商务网站。本周将增加数千种产品，现有的产品列表会经常变化(定价、库存等。).</p><p id="8a6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们首先关注列出产品的页面(例如<code class="fe oa ob oc od b">/products</code>)，以及单个产品页面(例如<code class="fe oa ob oc od b">/products/1</code>)。如果我们尝试应用静态数据生成技术会发生什么？</p><ol class=""><li id="9054" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">随着产品被添加到网站，我们将遇到一个问题。我们将不得不频繁地重建网站，这将花费很长时间，因为我们将静态地生成数千个产品页面。这是不可行的。</li><li id="ab84" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">同样，随着产品的变化，我们也会遇到问题。同样，我们将不得不重建网站以向客户反映产品的变化。也不可行。</li></ol><p id="a8ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们希望确保客户看到最新的数据，以便他们能够购买产品。<strong class="kv io">我们最终应该使用SSR来确保每个请求的数据都是最新的吗？？</strong></p><p id="bf0f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事实证明，很可能不是！Next.js有一个叫做<strong class="kv io">增量静态生成</strong>的概念，它帮助像我们的电子商务商店这样的动态网站留在静态生成的世界里(Next.js竭尽全力帮助我们使用SSG！).随着我越来越多地使用Next.js，我发现这是一些最酷的东西。</p><p id="4175" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="mh">案例1:在静态生成的构建生命周期中添加产品页面</em> </strong></p><p id="08a9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们已经静态生成了包含100种产品的电子商务站点。但现在1000款新品将于本周上市。我们可以在对<code class="fe oa ob oc od b">getStaticPaths</code>的调用中使用一个名为<code class="fe oa ob oc od b">fallback</code>的键(<a class="ae ks" href="https://nextjs.org/docs/basic-features/pages#scenario-2-your-page-paths-depend-on-external-data" rel="noopener ugc nofollow" target="_blank">我在上面也链接过这个</a>，但是这是在使用SSG并在构建时自动生成所有路径和产品页面的情况下)。</p><p id="1a2e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正常情况下，<code class="fe oa ob oc od b">fallback</code>会是<code class="fe oa ob oc od b">false</code>。这正如您所料——任何在构建时没有生成的路径都将返回404。这很好，因为如果有人去<code class="fe oa ob oc od b">/products/&lt;non-existent product_id&gt;</code>，404是正确的。但是，如果<code class="fe oa ob oc od b">fallback</code>设置为<code class="fe oa ob oc od b">true</code>，您可以解锁一些特殊行为。<a class="ae ks" href="https://nextjs.org/docs/basic-features/data-fetching#fallback-true" rel="noopener ugc nofollow" target="_blank">查看官方</a> <code class="fe oa ob oc od b"><a class="ae ks" href="https://nextjs.org/docs/basic-features/data-fetching#fallback-true" rel="noopener ugc nofollow" target="_blank">fallback: true</a></code> <a class="ae ks" href="https://nextjs.org/docs/basic-features/data-fetching#fallback-true" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="7d5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe oa ob oc od b">true</code>时，404 <strong class="kv io">不会因未知路径而返回</strong>。相反，您将从Next得到指示，您应该显示一个“回退”页面(本质上是一个加载页面)。同时，服务器将<strong class="kv io">缓慢地</strong>为用户生成合适的页面。工作流程如下:</p><ol class=""><li id="9275" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">我在网站上添加了一个新的id为<code class="fe oa ob oc od b">5000</code>的产品</li><li id="0821" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">一个用户试图进入页面<code class="fe oa ob oc od b">/products/5000</code>，但是它还不存在(当然不存在，因为我刚刚添加了产品)</li><li id="60e8" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">浏览器将为用户显示一个回退/加载页面(没有错误或类似的情况)</li><li id="51fb" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">服务器为产品5000生成HTML页面，然后将5000添加到它的已知路径集中(现在产品5000的页面可以缓存在CDN中)</li><li id="d538" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">用户现在将看到产品页面，而不是回退页面</li><li id="9be6" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">在此部署的生命周期内，对于此产品的所有未来请求，产品5000都已准备就绪，只需轻松完成一次工作！</li></ol><p id="3905" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="mh">案例2:在静态生成构建的生命周期中更新产品页面</em> </strong></p><p id="22f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种情况在Next.js中更加简单。这种情况被称为增量静态<strong class="kv io"> Re </strong> generation，因为这是关于在初始构建之后定期重新生成页面。</p><p id="7013" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您所需要做的就是在对<code class="fe oa ob oc od b">getStaticProps</code>的调用中添加一个名为<code class="fe oa ob oc od b">revalidate</code>的键。例如，<code class="fe oa ob oc od b">revalidate: 60</code> (60秒)会有以下工作流程:</p><ol class=""><li id="58cb" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">最初，构建了产品X的页面。如果它是延迟构建的，用户将在时间0看到这个新的产品页面</li><li id="f7f3" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">假设1秒钟后，产品的价格发生了变化</li><li id="4228" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">现在，大约30秒后，另一个用户转到产品x的页面。尽管如此，他们仍然会看到旧的<em class="mh">价格信息，因为每60秒才重新生成一次</em></li><li id="b4de" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">整整一分钟后，另一个用户请求该页面，Next知道重新生成产品X页面，这将引入新的定价(虽然对于这个用户，他们可能仍然会再次获得旧页面，但他们已经通知Next生成新页面)</li></ol></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><p id="876d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们的电子商务网站是静态生成的，但是我们有动态元素，包括添加新产品和更新产品！这是个好消息——Next在这些场景中为我们提供了两个世界的最佳选择。</p><p id="ca45" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mh">编辑:我在本系列中提到过，静态生成的一大好处是您的web服务器不在考虑范围内，所以您不必担心它会过载。请注意，对于这种增量静态生成的情况，虽然CDN层在提供生成的内容方面至关重要，但在这种情况下，web服务器会缓慢地创建产品页面，并不时地重新生成页面。</em></p><p id="0398" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="mh">关于电子商务网站</em> </strong>的“购物车”说明</p><p id="a5ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，上面讨论的所有内容都只涉及每个人都可以看到的公共信息。但是购物车只与特定的用户相关。因此，您最多可以呈现页面的某些部分，但最终，需要在请求时找到关于用户购物车中有什么的数据。你可以在这里使用SSR，但是<a class="ae ks" href="https://vercel.com/blog/nextjs-server-side-rendering-vs-static-generation#shopping-cart-page-static-generation-without-data,-combined-with-client-side-fetching" rel="noopener ugc nofollow" target="_blank">同一个Vercel帖子</a>推荐<strong class="kv io">无数据+客户端抓取的静态生成。</strong></p><p id="ad56" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着Next将静态生成购物车页面的通用部分(布局、样式等。)，可以缓存在CDN中。然后，由浏览器在请求时向服务器请求购物车细节。由于性能的原因，这比SSR更受欢迎——如果用户导航到他们的购物车，他们会很快看到<em class="mh">的一些</em>内容，并加载实际购物车细节的UI。使用SSR，在构建整个购物车之前，页面上不会有任何内容。重要的是，在这种情况下，这都是私人用户信息，所以我们可以忽略任何SEO优化，而是为用户快速看到<em class="mh">东西</em>进行优化。</p><p id="1903" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Next.js中，你可以为每个页面选择你想要的预渲染和数据获取策略，所以你可以有一个混合的方法。也看看<a class="ae ks" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank"> Vercel </a>吧。他们是Next.js的创造者，他们让部署Next应用变得非常容易。</p></div></div>    
</body>
</html>