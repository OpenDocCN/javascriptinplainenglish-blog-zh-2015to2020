<html>
<head>
<title>Using Images in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React Native中使用图像</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-images-in-react-native-668e3a835858?source=collection_archive---------1-----------------------#2020-12-29">https://javascript.plainenglish.io/using-images-in-react-native-668e3a835858?source=collection_archive---------1-----------------------#2020-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ba8ea4bbf406e401bb8a56670face16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tsd6bDqynxJN1daI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@alex_andrews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Andrews</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="044b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几个小时前，我正在编写一段React本机代码，这段代码需要从文件系统中导出动态图像。当然，我从React原生图像文档开始:<a class="ae jz" href="https://reactnative.dev/docs/image" rel="noopener ugc nofollow" target="_blank">https://reactnative.dev/docs/image</a></p><p id="0ded" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React Native有一些很棒的文档，所以读完这篇文章后，我觉得这应该是小菜一碟。</p><p id="c0a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">具体来说，我想做的是创建一个包含数据的JSON文件，并在该数据中创建一个包含图像信息的图像列表。我不知道有多少图像，或者有多少提前的数据。</p><p id="b73d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在仔细阅读了React原生文档后，我意识到有几种方法可以包含图像，所有这些方法都非常简单明了。但是没有一个能让我不做额外的工作就直接从本地文件系统上的JSON中读取图像。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="1dfb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，是古老而经典的“要求”:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="1179" class="lo lp in lk b gy lq lr l ls lt">&lt;Image style={{height: 50, width: 50}} source={require('./assets/images/photo1.jpg')} /&gt;</span></pre><p id="2028" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据React本地文档，这有几个作用:</p><ol class=""><li id="0d4b" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx lz ma mb mc bi translated">这使用了CommonJS函数‘require ’, Metro查找该函数以了解何时将照片放入我们的包中。它设置Metro bundler(也称为打包程序或Metro服务器),根据“require”关键字的存在将文件photo1.jpg包含到包中。</li><li id="c8d3" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">Metro将资产(jpg文件)转换成可以由<Image/>组件显示的对象。</li><li id="fd2d" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">Require本身返回一个对象，该对象用作图像的源。</li><li id="2782" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">这种情况下的对象是一个整数，Metro在映像加载时将它解析到一个位置。</li></ol><p id="cf4b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，这个很简单。</p><p id="759d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然它不是很有活力。</p><p id="72fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很好，因为每次使用新图像的代码更新都会自动将图像构建到捆绑器中，并传输到设备上。您不必担心文件系统路径或uri或任何类似的东西。更新代码中的图像，嘣，您就更新了包中的图像。</p><p id="c97e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将是很好的，如果我们有一个文件列表，像一个闪屏和其他一些资产，我们想显示。我们肯定不想下载它们，用户应该能够在安装后使用应用程序，没有额外的麻烦。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="3199" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以这样做，让它更有活力一点:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="c327" class="lo lp in lk b gy lq lr l ls lt">const DATA = [<br/>{<br/>   text: “man”,<br/>   image: require(‘./assets/images/photo1.jpg’)<br/>},<br/>{<br/>   text: “woman”,<br/>   image: require(‘./assets/images/photo2.jpg’)<br/>}<br/>]</span></pre><p id="bbc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将信息存储在一个数组中。请注意,“require”不是文本字符串。它仍然是一个将返回对象的已执行代码行——因此这个JS对象的image属性是另一个JS对象。</p><p id="0e7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不相信我？记录图像属性的输出:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="03d6" class="lo lp in lk b gy lq lr l ls lt">[Info] 12–24 06:02:42.359 27376 27440 I ReactNativeJS: 1</span><span id="a88a" class="lo lp in lk b gy mi lr l ls lt">[Info] 12–24 06:02:45.256 27376 27440 I ReactNativeJS: 2</span></pre><p id="b28a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是对资产的引用，可以用来代替数据[0]。图像属性——可以直接设置<code class="fe mj mk ml lk b">&lt;Image source={1} /&gt;</code>。</p><p id="a546" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，回到我们的应用程序，我们添加了以下代码:</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9573" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里发生了什么？</p><ol class=""><li id="6a1e" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx lz ma mb mc bi translated">第1–10行，我们创建了一个数据数组来保存我们的图像和文本。</li><li id="0dfa" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">第13行—我们使用了反应状态机制来存储当前imageVar的状态。这将返回一个包含两个变量的数组—第一个变量是imageVar，即当前图像。我们用useState(0)函数初始化这个变量，将状态设置为0。这是一个称为钩子的特殊函数，它允许您钩入React特性，向它添加状态。其次，它返回setImageVar，这是一个用于访问状态和更改值的函数。这相当于一个setattr。</li><li id="44d0" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">然后，在第19行，我们设置了一个Image组件，并将初始源指定为DATA[imageVar].image中的对象。image属性是由“require”语句返回的对象——在本例中，是资产索引的一个int。</li><li id="410d" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">第20行对文本做了同样的事情。</li><li id="8c9e" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">第21行设置了一个按钮组件—这个按钮使用前面返回的setImageVar函数来调整值。(显式地，如果imageVar与我们的数组大小相同，我们重置为0，否则我们添加1)</li></ol><p id="7fef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的神奇之处在于React Native仅重新呈现为提高性能而更改的组件。在这种情况下，React状态的使用仅在状态已更改的组件(此处为图像和文本按钮)上触发重新呈现。把它想象成一个巨大的回调，说“我正在注册使用这个状态。当它发生变化时，我需要得到通知。”</p><p id="4d65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，你仍然需要指定你加载到这个数组中的每一个图像，并在某个地方包含这个数组。没有任何东西会被自动拾取，因为它在某个目录中，但是不需要担心构建步骤，您在代码中需要的任何图像都会自动包含在您的包中。如果您需要更改图像，只需更改您的需求代码列表，新的图像将由图像组件拾取，而无需跟踪10个不同的位置。这对代码维护来说非常好。</p><figure class="lf lg lh li gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/fa1b390d47b2f92d65f1eb3480dd5839.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/1*fI314swK66ZGs9Qz0bn8Jw.gif"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="fe18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的，我们已经设法通过一个数组动态地加载图片，但是…我们必须指出一个问题。</p><p id="a137" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仔细检查我们的数组，我们可以看到“image”属性仍然是一个对象——也就是说，Babel仍然可以将这个“require”调用转换成一个JavaScript对象，确保图像被加载到静态资产中。</p><p id="84fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这与JSON文件的区别在于，JSON文件需要对其数据进行转义。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="9015" class="lo lp in lk b gy lq lr l ls lt">const DATA = ‘{ “image1”: { “text”: “man”, “image”: “./assets/images/photo1.jpg” }, “image2”: { “text”:”woman”, “image”:”./assets/images/photo2.jpg” }}’;</span></pre><p id="d568" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一种混乱的说法…我们有一组名称\值对。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8365" class="lo lp in lk b gy lq lr l ls lt">“image1”: {</span><span id="0ec4" class="lo lp in lk b gy mi lr l ls lt"> “text”: “man”,</span><span id="93a1" class="lo lp in lk b gy mi lr l ls lt"> “photo”: “assets/images/photo2.jpg”</span><span id="979b" class="lo lp in lk b gy mi lr l ls lt">}</span></pre><p id="5802" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们已经删除了需求。requires对我们没有帮助——JSON是名称\值对，所以对于Metro打包程序来说，它看起来只是一个字符串。这意味着我们的文件不在系统中—它不再被打包。</p><p id="cebc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要想办法把那个文件放到系统里。</p><p id="81e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同时，让我们继续解析JSON:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d564" class="lo lp in lk b gy lq lr l ls lt">let parsedData = JSON.parse(DATA);</span></pre><p id="d922" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">搞定了。现在我们可以简单地这样做:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="1396" class="lo lp in lk b gy lq lr l ls lt">console.log(parsedData.image1.text);</span></pre><p id="5b31" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">得到这样的回应:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="3990" class="lo lp in lk b gy lq lr l ls lt">[Info] 12-24 09:31:11.988 21250 22480 I ReactNativeJS: man</span></pre><p id="f413" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">维奥拉。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="dc68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将我们的图像组件更改为:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6ae4" class="lo lp in lk b gy lq lr l ls lt">&lt;Image style={{height: 50, width: 50}} source={parsedData[imageVar].image}/&gt;</span></pre><p id="a28e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">导致此错误:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="4932" class="lo lp in lk b gy lq lr l ls lt">[Info] 12-24 09:35:19.832 21250 22480 E ReactNativeJS: TypeError: undefined is not an object (evaluating 'parsedData[imageVar].image')</span></pre><p id="eccc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为source属性应该是一个对象，相反，我们直接从JSON解析中传递一个字符串。(记住，源对象最终是一个指向资源索引的整数。)</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="30ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用字符串，我们需要使用一种叫做URI的东西，或者“统一资源标识符”。你实际上一直都在使用这个——在你的网络浏览器中，这是你去“http://”时使用的。它告诉浏览器这是一个“http”类型。您可以尝试使用“file://”作为本地文件。</p><p id="c10d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React Native支持同样的东西。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="2d40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要了解静态资源保存在哪里。要做到这一点，我们需要了解应用程序的基本文件系统。</p><p id="4d95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从古老的react-native-fs开始，这是访问react-native文件系统的正确方法:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="a9a4" class="lo lp in lk b gy lq lr l ls lt">npm ERR! Could not resolve dependency:<br/>npm ERR! peer react-native@"^0.59.5" from react-native-fs@2.16.6<br/>npm ERR! node_modules/react-native-fs<br/>npm ERR!   react-native-fs@"*" from the root project</span></pre><p id="ff83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不对不对。嗯，看起来我们不能在react的最新版本中使用react-native-fs了。或者它需要更新。从问题页面，很难知道。</p><p id="11ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论如何，我们将暂时转移到世博图书馆，稍后我们会看到原因，但现在让我们先把这个问题放一放:</p><p id="b346" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们将转向Expo文件系统模块。除此之外，要在React-Native项目中安装它，您需要使用unibrow模块…我指的是unimodules。<a class="ae jz" href="https://docs.expo.io/versions/latest/sdk/filesystem/#supported-uri-schemes-1" rel="noopener ugc nofollow" target="_blank">https://docs . Expo . io/versions/latest/SDK/file system/# supported-uri-schemes-1</a></p><p id="a04c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这看起来很吓人，但是很简单。一旦你这样做了，你的项目可能就不工作了。</p><p id="1368" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我必须加载Android studio，在那里重新链接项目，然后重启打包程序和我的Android模拟器，这与添加新包时发生的情况非常一致。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="5708" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">文件系统模块让我们可以访问一个调用— readDirectoryAsync()。</p><p id="8dc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用它来看看我们的文件系统中发生了什么:</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="97bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个简单的按钮可以嵌入到代码中的某个地方，并将返回如下输出:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="f4a8" class="lo lp in lk b gy lq lr l ls lt">[Info] 12–28 05:44:41.645 7127 10775 I ReactNativeJS: Reading :file:///data/user/0/com.uritest/files/</span><span id="ff26" class="lo lp in lk b gy mi lr l ls lt">[Info] 12–28 05:44:41.650 7127 10775 I ReactNativeJS: File: sonar</span><span id="87c2" class="lo lp in lk b gy mi lr l ls lt">12–28 05:44:41.650 7127 10775 I ReactNativeJS: File: ReactNativeDevBundle.js</span></pre><p id="e023" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哼。不是我们所期望的。</p><p id="8b21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我本以为会有更多的资产——我的意思是，我们的代码中有下面一行:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2afc" class="lo lp in lk b gy lq lr l ls lt">const foo = require(‘./assets/images/photo1.jpg’);</span></pre><p id="365a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，好吧——让我们再深入挖掘一下。React Native从哪里获得资产？</p><p id="4319" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React本机映像库包含以下调用:Image.resolveAssetSource()。</p><p id="4ed5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个调用允许我们看到bundler中任何静态资产(在这个例子中是图像)背后的URI。</p><p id="9966" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们试一试:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2312" class="lo lp in lk b gy lq lr l ls lt">const foo = require(‘./assets/images/photo1.jpg’);</span><span id="2a11" class="lo lp in lk b gy mi lr l ls lt">const fooURI = Image.resolveAssetSource(foo).uri;</span><span id="cda5" class="lo lp in lk b gy mi lr l ls lt">console.log(“FooURI: “ + fooURI);</span></pre><p id="5519" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打印输出:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="a352" class="lo lp in lk b gy lq lr l ls lt">[Info] 12–28 05:54:20.289 7127 10775 I ReactNativeJS: FooURI: <a class="ae jz" href="http://10.0.2.2:8081/assets/assets/images/photo1.jpg?platform=android&amp;hash=25052dcebf6333bef4fa5c380130eccd" rel="noopener ugc nofollow" target="_blank">http://10.0.2.2:8081/assets/assets/images/photo1.jpg?platform=android&amp;hash=25052dcebf6333bef4fa5c380130eccd</a></span></pre><p id="a576" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这很有道理。这是一个模拟器，而不是一个已发布的应用程序，可以随时部署。在部署中，这将解析到本地资源，但在开发中，我们希望能够快速改变事情。所以一切都在本地web服务器上解决，这解释了为什么本地文件系统是空白的。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="85bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，让我们在本地下载资源，这样我们就可以使用URI加载它。</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c748" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码做了几件事:</p><ol class=""><li id="698d" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx lz ma mb mc bi translated">使用Image.resolveAssetSource()调用来获取该特定资产的URI。</li><li id="14e9" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">将文件下载到本地资源—下载调用采用URI和本地文件URI。</li><li id="f1b5" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">使用downloadAsync函数传入的{uri} return参数打印文件下载到的位置。这应该和我们传进去的URI吻合。</li><li id="8415" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">读取目录，看看我们是否得到了文件。</li></ol><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="be99" class="lo lp in lk b gy lq lr l ls lt">[Info] 12–28 06:24:46.329 7127 10775 I ReactNativeJS: Using :file:///data/user/0/com.uritest/files/</span><span id="74ea" class="lo lp in lk b gy mi lr l ls lt">[Info] 12–28 06:24:46.355 7127 10775 I ReactNativeJS: Finished downloading to file:///data/user/0/com.uritest/files/photo1.jpg</span><span id="6c4a" class="lo lp in lk b gy mi lr l ls lt">[Info] 12–28 06:24:46.358 7127 10775 I ReactNativeJS: File: sonar</span><span id="056b" class="lo lp in lk b gy mi lr l ls lt">12–28 06:24:46.358 7127 10775 I ReactNativeJS: File: ReactNativeDevBundle.js</span><span id="374f" class="lo lp in lk b gy mi lr l ls lt">12–28 06:24:46.358 7127 10775 I ReactNativeJS: File: photo1.jpg</span></pre><p id="d721" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所见，它成功了！</p><p id="8c98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们函数末尾读取的目录显示‘photo 1 . jpg’在这里显然是可用的。</p><p id="e866" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mp">注意—指定的本地文件URI必须已经创建了所有目录，也就是说，如果您指定DocDir+"/dir1/dir2/a.jpg "，则" dir1/dir2 "必须已经存在。</em></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="d7be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，让我们加载图片。</p><p id="d38f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们将使用以下代码:</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ad1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在这里抽出一些亮点。</p><p id="6c7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">忽略第3-6行:他们在本地获得URI。我们可以很容易地从任何地方下载任何URI。事实上，当使用http时，我们可以直接从URI加载图像。在这一步中，我只是将此作为在设备上获取文件的一种简单方法。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="2066" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，当我们没有下载图像时，我们不想呈现图像组件。为此，我们:</p><ol class=""><li id="2622" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx lz ma mb mc bi translated">在第8行，设置一个新的状态钩子，让我们能够知道我们是否已经下载了图像。我们将其初始化为0(假)。</li><li id="e472" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">在第12行，我们有d image——一个根据状态有条件地分配给某个占位符文本或实际图像的对象。</li><li id="ad50" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">在第52行，我们包含了为dlImage设置组件引用的JavaScript它将基于imageDownloaded的状态进行呈现。这允许我们有条件地渲染图像。</li><li id="6367" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">在第30行，下载完图像后，我们将imageDownloaded的状态设置为1。</li><li id="feb4" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx lz ma mb mc bi translated">当用户点击按钮时，这将重新呈现应用程序组件(使用这个特定的状态变量注册)，这一次，我们刚刚下载的图像被包括在内。</li></ol><figure class="lf lg lh li gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/55810a9305ae4c90e383f01a64d54bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AYtDs82nCx1tx862vY7xSA.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Pretty Cool, eh? It’s all dynamic and stuff!</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="e05f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">做完这一切后，我们有能力在本地下载文件，并使用URI加载图像(或其他资产)。</p><p id="2861" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第10行将图像URI设置为本地文件。</p><p id="1553" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第13行加载这个本地文件。神奇的是“file://”，这是本地文件系统的URI指示器。然后，在这之后，我们需要提供一个存在的路径，应用程序可以访问。</p><p id="1651" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个很大的进步，但是让我们不要失去我们最初的目标——我们希望能够直接从我们的JSON文件中获取图像文件并加载它们，而不是使用由需求指定的资源位置。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="ffa7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们继续之前，让我们先做一个简单的实验，看看在生产的包中有什么或者没有什么。这将有助于我们了解正在发生的事情，这对以后是很好的知识。</p><p id="5ed6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在React本机根目录、资产和捆绑包之上创建2个目录。</p><p id="6c2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，从React本机根目录运行以下命令，将您的目录替换为d:\gitrepos\assets和d:\gitrepos\bundle。这是最终将被打包用于部署构建的内容。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="bec0" class="lo lp in lk b gy lq lr l ls lt">PS D:\gitrepos\uritest&gt; npx react-native bundle — assets-dest d:\gitrepos\assets — entry-file d:\gitrepos\uritest\index.js — bundle-output d:\gitrepos\bundle\out.bundle — verbose<br/> Welcome to React Native!<br/> Learn once, write anywhere</span><span id="9727" class="lo lp in lk b gy mi lr l ls lt">info Writing bundle output to:, d:\gitrepos\bundle\out.bundle<br/>info Done writing bundle output<br/>info Copying 8 asset files<br/>info Done copying assets</span></pre><p id="2302" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您没有在您的项目中添加“require”调用，我们将在d:\gitrepos\assets目录下看不到assets\images目录。(或者您赋予assets-dest选项的任何目录。</p><p id="8d14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确保您已经在电话中添加了设置要求:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="ac51" class="lo lp in lk b gy lq lr l ls lt">const foo = require('./assets/images/photo1.jpg');</span></pre><p id="56eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">突然，那里出现了一个./assets/images/photo1.jpg文件！</p><p id="5a35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然不是唯一的验证方法，但这肯定是一种方法！(例如，我们可以打开android包，转到localhost:8081位置。我只是觉得这更容易。)</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="922d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此时此刻，我们已经完成了以下工作:</p><ul class=""><li id="e719" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated">展示了我们可以从文件系统本地加载图像。</li><li id="44c5" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">显示了我们不能加载包中没有的图像。</li><li id="46cd" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">显示了“require”命令在JSON中不起作用。</li><li id="5bca" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">显示“require”命令返回一个对象。</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="32ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这给我们留下了一个基本问题:我们如何将我们的资产转移到设备上，以便我们可以使用它们——同时在JSON文件中指定它们，这并不解释JSON的要求——以便它们存在于本地，用户可以立即使用我们的应用程序？</p><p id="c5d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有多种方法可以解决这个问题，所以让我们来看看每一种方法，以及它们的一些优缺点。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="124a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们*可以*将它们指定为Android和iOS中的资产，使用Gradle文件来传输它们。这将把它们视为特定于操作系统的资产，它们必须符合每个平台的规则，包括大小、命名和特征。</p><p id="d616" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它可以使用Gradle构建脚本自动完成——这很好。Ie —从这个目录中取出它们，并将它们移动到这些特定的位置。这仍然使我们能够为我们的图像提供单一的真实来源——但命名会随着时间的推移而改变，因此将资产反向映射回其来源会更加困难。</p><p id="21fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果可能的话，我想让捆扎机正确地拾取它们——似乎没有必要做任何特殊处理。这利用了让打包程序做它应该做的事情的能力。</p><p id="d91e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于我的目的，我将使用我的assets/images目录中的所有文件，因此应该可以对目录中的所有内容使用requires。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="e5c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们尝试动态使用“require ”:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="63a3" class="lo lp in lk b gy lq lr l ls lt">for (var key in parsedData) {<br/>   console.log(parsedData[key].text);<br/>   imgObjects.push(require(parsedData[key].image));<br/>}</span></pre><p id="4e75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这应该是很明显的，但这是你由此得到的错误:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b8d3" class="lo lp in lk b gy lq lr l ls lt">[Thu Dec 24 2020 10:44:55.200]  ERROR    TypeError: undefined is not an object (evaluating 'parsedData[imageVar].image')</span></pre><p id="bbee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Require是编译时函数，而不是运行时函数。也就是说，它不知道任何关于程序流或执行的事情，它只是寻找需要加载的模块。(也就是说，代码是在打包程序运行之后运行的，并且代码和资产已经在Android设备上了。)</p><p id="f741" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那不行，我们需要设备上的资产。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="2fef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决这个问题的另一种方法是设置一个单独的index.js文件，并通过使用字典将“require”映射到一个键，然后我们就可以这样使用图像了。index.js文件是用于为React Native定义模块的JavaScript代码。这允许您指定模块的导入和导出以及其他默认设置。</p><p id="8ad7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，这意味着图像需要在两个不同的位置列出，一个在JSON中，一个在index.js中。</p><p id="8433" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不理想。这并不理想，因为我们必须维护两个独立的清单——一个在JSON中，一个在JavaScript源文件中。这也意味着我们需要有一种方法来将一个位置列表转换成‘require’对象或索引id。</p><p id="6844" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不喜欢在两个不同的位置管理相同的数据，这总是会导致一整天都在试图找出为什么图像不在一个地方或另一个地方。一个有经验的开发人员的口头禅是，代码和资源不应该重复，也就是说，一个开发人员已经花了数周的时间试图找出一个特定的错误。</p><p id="37ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，注意，如果有足够的构建魔力，index.js可以从JSON动态构建。或者JSON可以直接从头部生成。或者两者都可以从图像目录本身生成。</p><p id="c355" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，永远记住— <strong class="kc io">有了足够的建造魔法，几乎任何事情都可以被克服。这更多的是一个建造魔法是否是正确的事情的问题。</strong></p><p id="7dd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一个好处，这给我们留下了一个简单的require格式的所有图像，很容易与React-native一起使用。它还为我们提供了一个很好的文本字符串，可以在我们的源格式中使用。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b3be" class="lo lp in lk b gy lq lr l ls lt">{<br/>   img1: require('foo.jpg');<br/>}<br/>&lt;Image source=img1 /&gt;</span></pre><p id="f160" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您在应用程序构建时有一组静态图像，并且您只希望在构建新应用程序时更改它们，这将非常有用。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="a7d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们转向require . context——这个功能允许我们在使用require时指定一个glob。本质上，这允许我们指定一个目录，并要求目录结构中的某一类型的所有文件。一个glob是一个通配符或其他贪婪的说明符，很像你在命令行中使用的。(即—要求*。js)</p><p id="9c66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不利的一面是:</p><ul class=""><li id="0926" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated">目前它似乎对巴别塔不起作用——但是将来会改变的。</li><li id="0a6f" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">你不知道你映射了什么资产。没有好的数组或组件字典。因此，您可以映射它们，但是如果没有间接性，使用它们会变得更加困难。这就产生了代码清洁问题。这对于模块来说很好，但是对于资产来说就不那么好了，因为资产需要在以后加载时被引用，而模块可以通过名字来使用。</li></ul><p id="41bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">否则，这与“require”完全相同——静态的，在应用程序构建时。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="ce47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能已经猜到了，但是正如我们在上面看到的，我们可以下载一个文件，并将该文件用作图像。</p><p id="af9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">绕过这一限制的一种方法是下载整个图像包\档案。这可以很容易地从CDN或其他机制提供。(当然，您需要对您的归档文件进行版本控制，以便您可以检查最新的更新。)</p><p id="1aee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个包中可以有一个JSON描述文件，描述每个图像，或者提供其他元数据，包括文件位置。</p><p id="6832" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下载完成后，包将被解压缩，然后像上面一样使用——使用“file://”URI指示器加载映像。</p><p id="7327" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果需要的话，这具有动态的优点。这些图片可以即时更新，而不必重新发布应用程序并让用户更新。</p><p id="95d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它有一个缺点，即在用户进行额外的步骤来下载图像之前，图像是不可用的。对于使用受限或慢速连接的用户来说，这可能是一个重大的不利因素——我总是希望我的应用程序在我第一次安装时就准备好了。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="4453" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们可以指定一个资产包，在构建期间构建或者作为一个单独的步骤构建，包含我们的资产和JSON。如果我们可以将这个包转移到应用程序中，它将允许我们解包这个包，并从JSON本机使用资产。</p><p id="c24e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实现这一目标的方法之一是使用新的世博会“资产”模块。这将把您的归档文件指定为一项资产，然后您可以在本地解压缩该归档文件。所有文件都可以在你的应用程序启动时获得，不需要下载。您的应用程序可以提供可选的“检查更新”功能来获取新资产。</p><p id="f6bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将下载资产与静态资产更新方法结合起来。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="5de0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这就结束了这篇相当长的文章，它本来应该是很短的。:)</p><p id="b0fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于我的目的，我将使用资产捆绑方法，这将允许我将每个逻辑单元放在它自己的捆绑包中，必要时解包。</p><p id="67f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或许有必要再写一篇文章，探讨捆绑资产的最佳方法。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="9f42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">链接</strong></p><p id="4bb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码:</p><ul class=""><li id="2e55" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated"><a class="ae jz" href="https://gist.github.com/AllanGraves/cb480125764d469b968b9d989e2d7188" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Allan graves/CB 480125764d 469 b 968 b9d 989 e2d 7188</a></li><li id="ab55" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated"><a class="ae jz" href="https://gist.github.com/AllanGraves/b720bc9a479553a3f349ec94d7704278" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Allan graves/b 720 BC 9a 479553 a3 f 349 EC 94d 7704278</a></li><li id="e920" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated"><a class="ae jz" href="https://gist.github.com/AllanGraves/193a11bfe88d5b53eafa11b7213cf55d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Allan graves/193 a11 bfe 88 d5b 53 eafa 11 b 7213 cf 55d</a></li><li id="99f2" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">所有代码，分3个分支:<a class="ae jz" href="https://dev.azure.com/allangraves/Public%20React%20Native%20Code/_git/ReactNativeDynamicImageLoading" rel="noopener ugc nofollow" target="_blank">https://dev . azure . com/Allan graves/Public % 20 react % 20 native % 20 Code/_ git/ReactNativeDynamicImageLoading</a></li></ul><p id="1640" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">地铁:</p><ul class=""><li id="ad52" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated"><a class="ae jz" href="https://stackoverflow.com/questions/51116811/what-is-metro-bundler-in-react-native" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/51116811/what-is metro-bundler-in-react-native</a></li><li id="d479" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated"><a class="ae jz" href="https://facebook.github.io/metro/docs/concepts/" rel="noopener ugc nofollow" target="_blank">https://facebook.github.io/metro/docs/concepts/</a></li><li id="8d8e" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">根目录外的文件:<a class="ae jz" href="https://github.com/facebook/metro/issues/7" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/metro/issues/7</a></li></ul><p id="339c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript:</p><ul class=""><li id="3e5b" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated">要求vs导入:<a class="ae jz" href="https://stackoverflow.com/questions/31354559/using-node-js-require-vs-es6-import-export" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/31354559/using-node-js-require-vs-es6-Import-export</a></li><li id="fb6c" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">获取URI:<a class="ae jz" href="https://dev.to/fdefreitas/how-to-obtain-a-uri-for-an-image-asset-in-react-native-with-expo-7bm" rel="noopener ugc nofollow" target="_blank">https://dev . to/fdefreitas/how-to-obtain-a-uri-for-a-image-asset-in-react-native-with-Expo-7bm</a></li><li id="0e2f" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">https://github.com/wilsonlewis/require-context#readme<a class="ae jz" href="https://github.com/wilsonlewis/require-context#readme" rel="noopener ugc nofollow" target="_blank"/></li><li id="fe45" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">使用index.js文件和图片:<a class="ae jz" href="https://stackoverflow.com/questions/43050468/react-native-image-uri-doesnt-work" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/43050468/react-native-image-uri-donts-work</a></li><li id="c215" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">三元运算符:<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional _ Operator</a></li><li id="4808" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">动态包含:<a class="ae jz" href="https://stackoverflow.com/questions/30854232/react-native-image-require-module-using-dynamic-names" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/30854232/react-native-image-require-module-using-dynamic-names</a></li><li id="8373" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">更多关于Requires:<a class="ae jz" href="https://stackoverflow.com/questions/9901082/what-is-this-javascript-require#:~:text=The%20require()%20method%20is,use%20the%20require()%20method" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/9901082/what-is-this-JavaScript-require #:~:text = The % 20 require()% 20 method % 20 is，use % 20 The % 20 require()% 20 method</a></li><li id="5296" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">require . context:ttps://stack overflow . com/questions/54059179/what-is-require-context</li></ul><p id="e170" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图片:</p><ul class=""><li id="d411" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated">使用React本地和本地URI:<a class="ae jz" href="https://stackoverflow.com/questions/50755784/react-native-unable-to-use-local-tmp-file-path-for-image-source-ios" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/50755784/React-Native-unable-to-use-local-tmp-file-path-for-image-source-IOs</a></li><li id="97fc" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated"><a class="ae jz" href="https://stackoverflow.com/questions/52398714/react-native-requireimage-returns-number" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/52398714/react-native-require image-returns-number</a></li></ul><p id="b7ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">文件系统:</p><ul class=""><li id="a0ff" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated"><a class="ae jz" href="https://docs.expo.io/bare/installing-unimodules/" rel="noopener ugc nofollow" target="_blank">https://docs.expo.io/bare/installing-unimodules/</a></li><li id="2e16" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated"><a class="ae jz" href="https://docs.expo.io/versions/latest/sdk/filesystem/" rel="noopener ugc nofollow" target="_blank">https://docs.expo.io/versions/latest/sdk/filesystem/</a></li><li id="0711" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">React本地文件系统:<a class="ae jz" href="https://github.com/itinance/react-native-fs" rel="noopener ugc nofollow" target="_blank">https://github.com/itinance/react-native-fs</a></li></ul><p id="204e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反应自然:</p><ul class=""><li id="602f" class="lu lv in kc b kd ke kh ki kl lw kp lx kt ly kx mr ma mb mc bi translated">世博资产指南:【https://docs.expo.io/guides/preloading-and-caching-assets/ T2】</li><li id="b2f7" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">管理静态资产:<a class="ae jz" href="https://willowtreeapps.com/ideas/react-native-tips-and-tricks-2-0-managing-static-assets-with-absolute-paths" rel="noopener ugc nofollow" target="_blank">https://willowtreeapps . com/ideas/react-native-tips-and-tricks-2-0-managing-Static-Assets-with absolute-paths</a></li><li id="e79d" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">条件渲染:<a class="ae jz" href="https://stackoverflow.com/questions/51404335/append-a-react-component-in-another-on-button-click" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/51404335/append-a-react-component-in-another-on-button-click</a></li><li id="8d1f" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">条件渲染:<a class="ae jz" href="https://reactjs.org/docs/conditional-rendering.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/conditional-rendering.html</a></li><li id="70db" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">图片:<a class="ae jz" href="https://reactnative.dev/docs/image" rel="noopener ugc nofollow" target="_blank">https://reactnative.dev/docs/image</a></li><li id="cf08" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">在各种场景中使用图像:<a class="ae jz" href="https://reactnative.dev/docs/images" rel="noopener ugc nofollow" target="_blank">https://reactnative.dev/docs/images</a></li><li id="577c" class="lu lv in kc b kd md kh me kl mf kp mg kt mh kx mr ma mb mc bi translated">钩子和状态:<a class="ae jz" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-state.html</a></li></ul></div></div>    
</body>
</html>