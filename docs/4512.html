<html>
<head>
<title>Instantiating Typescript classes with properties using inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用继承实例化具有属性的Typescript类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/instantiating-typescript-classes-using-inherited-partials-46a2a72f67e5?source=collection_archive---------2-----------------------#2020-12-17">https://javascript.plainenglish.io/instantiating-typescript-classes-using-inherited-partials-46a2a72f67e5?source=collection_archive---------2-----------------------#2020-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/8743f3ea4d4c9ed84a7a570d02cb0219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mj5i_XXprvVf4tLX8g6tiw.png"/></div></div></figure><div class=""/><p id="e69e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我将向您展示如何在Typescript中编写继承构造函数的类，该构造函数允许实例化该类并在一行中为其属性赋值。这对于希望将请求的JSON主体实例化为一个类而不必使用Object.assign或逐行分配属性的情况非常有用。它还允许我们将属性赋值严格地输入到类的构造函数中，而Object.assign不允许在类外使用。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="4c6e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要理解这种方法试图解决什么问题。假设您有一个用户类</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ef9b" class="lj lk iy lf b gy ll lm l ln lo">export class User {<br/>    public email: string;<br/>    public firstName: string;<br/>    public lastName: string;<br/>}</span></pre><p id="cc23" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，假设我们有一个GET请求，它返回一个JSON体，其中包含这些值。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c540" class="lj lk iy lf b gy ll lm l ln lo">fetch(myUserEndpoint)<br/>    .then(res =&gt; res.json())<br/>    .then((userData: Partial&lt;User&gt;) =&gt; {<br/>        // Do something with userData<br/>    });</span></pre><p id="be19" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只有上面的代码，我们只有两个选项来将请求返回的数据填充到新的用户类中。</p><p id="793c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选项1:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c367" class="lj lk iy lf b gy ll lm l ln lo">fetch(myUserEndpoint)<br/>    .then(res =&gt; res.json())<br/>    .then((userData: Partial&lt;User&gt;) =&gt; {<br/>        const user = new User();<br/>        user.firstName = userData.firstName;<br/>        user.lastName = userData.lastName;<br/>        user.email = userData.email;<br/>    });</span></pre><p id="e12c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">显然，上面的方法有问题，首先，如果类用户需要添加更多的属性，您将不得不回到这个承诺，为新属性添加一行。这造成了长期的可维护性问题。</p><p id="4409" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选项2:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b326" class="lj lk iy lf b gy ll lm l ln lo">fetch(myUserEndpoint)<br/>    .then(res =&gt; res.json())<br/>    .then((userData: Partial&lt;User&gt;) =&gt; {<br/>        const user = Object.assign(new User(), userData);<br/>    });</span></pre><p id="34b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法要好得多，尽管调用Object.assign(new Class()，partial)可能会变得很麻烦并妨碍可读性。这种特殊的方法也不能对提供给类的分部进行类型检查。</p><p id="9edc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们需要一种干净的、可重用的方法来将常规的JavaScript对象转换成类。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="a953" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建将被继承的泛型类，并添加构造函数。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="599d" class="lj lk iy lf b gy ll lm l ln lo">export class AbstractEntity&lt;T&gt; {<br/>    constructor(protected partial: Partial&lt;T&gt;) {<br/>        Object.assign(this, this.partial);<br/>    }<br/>}</span></pre><p id="3d1f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该注意的第一件事是AbstractEntity旁边的<t>泛型声明。当我们声明继承这个类的另一个类时，我们将需要声明与泛型相同的类，以便构造函数(以及任何其他依赖于类类型的继承方法)可以根据继承这个类的类来输出分部。</t></p><p id="cc3c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，编辑用户类以继承AbstractEntity类</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="16ff" class="lj lk iy lf b gy ll lm l ln lo">export class User extends AbstractEntity&lt;User&gt; {<br/>    public email: string;<br/>    public firstName: string;<br/>    public lastName: string;<br/>}</span></pre><p id="5040" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对一些人来说，这可能会令人困惑。为什么我们要扩展AbstractEntity类，然后将User类传递到它的泛型声明中？回头看看AbstractEntity类来寻找答案。</p><p id="1d14" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构造函数使用泛型声明来输出部分参数，该部分参数将由用户类以及扩展我们的AbstractEntity类的任何其他类继承。</p><p id="48b8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看如何在上面的例子中使用这种方法</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d5a6" class="lj lk iy lf b gy ll lm l ln lo">fetch(myUserEndpoint)<br/>    .then(res =&gt; res.json())<br/>    .then((userData: Partial&lt;User&gt;) =&gt; new User(userData))<br/>    .then((user: User) =&gt; {<br/>        // Do something with your new User class object<br/>    });</span></pre><p id="6725" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用这种方法，我们不需要重复使用Object.assign，并且我们确保我们可以在不需要对应用程序的API层进行更改的情况下从我们的用户类中添加和删除属性。同样，在我们需要实例化新用户的任何其他领域，我们可以确保作为partial提供的参数类型正确！</p></div></div>    
</body>
</html>