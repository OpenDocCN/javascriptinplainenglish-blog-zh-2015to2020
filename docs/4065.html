<html>
<head>
<title>A Journey through React Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React渲染之旅</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-journey-through-react-rendering-be174acac5e7?source=collection_archive---------9-----------------------#2020-11-13">https://javascript.plainenglish.io/a-journey-through-react-rendering-be174acac5e7?source=collection_archive---------9-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/51073e4bd4963d5887b4115549a4f48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*frxMyorphPVxAaPX"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk"><a class="ae jd" href="https://unsplash.com/@kumpan_electric" rel="noopener ugc nofollow" target="_blank">@kumpan_electric</a> unsplash.com</figcaption></figure><div class=""/><div class=""><h2 id="fc0a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">React如何在页面上呈现的深入概述</h2></div><p id="2de3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们头脑中获得反应模型所必需的理解中，渲染的概念是关键。我们使用JSX的语法来设计我们的用户界面，并将其转化为屏幕上的输出，这就是渲染。</p><p id="ce62" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在假设在一个HTML文档中有<code class="fe lr ls lt lu b">&lt;div id="root&gt; &lt;/div&gt;</code>。我们可以用它来创建React应用程序。</p><p id="32a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们称之为根DOM节点。事实上，应用程序只在React中构建，通常只有一个根DOM节点。</p><p id="4b25" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从React应用程序最简单的构建块开始，我们有了元素，它们是在JSX中创建的，可以在页面上呈现。随着复杂性的增加，我们将元素捆绑成一个组件。该组件变得很多，并且这些组件通常包含在一个更大的组件下，我们创造性地称之为“App”。</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lv"><img src="../Images/19078a7b5adbba91955f622cc546a228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZee21x2OUeobrs7TTp0Dw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Relationship between the HTML and React Components</figcaption></figure><p id="0617" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用React创建的所有东西都在这个“根”DOM节点中得到管理。在我们进入复杂的兔子洞之前，首先我们应该理解如何在谈论呈现组件之前呈现一个元素。我们将理解React管理这个<code class="fe lr ls lt lu b">&lt;div&gt;</code>元素中的一切是什么意思。</p><h1 id="9d08" class="ma mb jg bd mc md me mf mg mh mi mj mk km ml kn mm kp mn kq mo ks mp kt mq mr bi translated">呈现元素</h1><p id="2529" class="pw-post-body-paragraph kv kw jg kx b ky ms kh la lb mt kk ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">所以我们知道，React必须将JSX翻译成最终将出现在屏幕上的东西。我们称之为渲染。React有一个名为<code class="fe lr ls lt lu b">ReactDOM.render()</code>的函数，它允许我们将React元素作为一个参数，以及我们想要在HTML中放置代码的位置。ReactDOM是一个React库，它有许多处理DOM的函数。</p><p id="6a0d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ReactDOM方法用在应用程序的顶部。它为代码提供了一种逸出并显示在页面上的方法。它是React和DOM之间的主要网关。</p><p id="9513" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看这是如何工作的</p><pre class="lw lx ly lz gt mx lu my mz aw na bi"><span id="74b2" class="nb mb jg lu b gy nc nd l ne nf">const element = &lt;h1&gt; Hello World &lt;/h1&gt;<br/>ReactDOM.render(element, document.getByElementId('root'))</span></pre><p id="6ac5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">屏幕输出</p><pre class="lw lx ly lz gt mx lu my mz aw na bi"><span id="857f" class="nb mb jg lu b gy nc nd l ne nf">Hello World</span></pre><p id="ab25" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们应该知道，React元素是不可变的，它每次只提供潜在用户界面的快照。你可以想象这真的不是一种制作应用程序的方式！</p><p id="715c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们先讨论一下<code class="fe lr ls lt lu b">render()</code>功能。它需要的参数如下</p><ol class=""><li id="0d1b" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">反应元素</li><li id="1dd0" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">要追加到的选定DOM节点</li><li id="d409" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">回调函数(可选)</li></ol><p id="69f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个选定的DOM节点充当所有react元素的树结构的根。正是这种结构允许多个组件被视为根React元素的子元素。下图显示了这一点。</p><p id="dae1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在应该说，渲染可以由组件内部发生的事情触发，实际上也只是在屏幕上显示一个静态页面。这种“重新渲染”可能是我们希望在网页上发生的变化，并且这些重新渲染可以多次发生，这就是React的妙处。它允许发生许多变化或存储数据以供最终使用，而不会变得复杂。</p><p id="6975" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从JSX来到屏幕上。React呈现一个新的虚拟DOM，并将其与旧的虚拟DOM进行比较。一个叫做diffing的过程会计算这些虚拟DOM之间的差异。然后将它与实际的DOM进行比较，只对DOM进行需要的更改。这个过程叫做和解。在本文中，我们不会深入探讨这个问题，只是对渲染所达到的效果有一个高层次的概述。</p><h1 id="b459" class="ma mb jg bd mc md me mf mg mh mi mj mk km ml kn mm kp mn kq mo ks mp kt mq mr bi translated">为什么要用render()？</h1><p id="a484" class="pw-post-body-paragraph kv kw jg kx b ky ms kh la lb mt kk ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">现在我们知道了它的作用以及我们能从它的使用中得到什么。</p><p id="6120" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">单页应用</strong></p><p id="0699" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你一定听说过单页应用程序。React非常适合这种类型的应用程序。我们可以有一个几乎空白的HTML页面，在那里我们可以直接将应用程序添加到div容器中，就像我们上面解释的那样。React允许我们多次修改DOM上的内容，而不必刷新页面。我们通过在React应用程序中多次触发重新呈现来做到这一点，按照我们想要的方式更新页面。这使我们能够在页面上创建动态内容，而不必无缝地刷新它。为了充分理解这一点，我们必须深入研究状态的概念，这里不做探讨！</p><h1 id="ea08" class="ma mb jg bd mc md me mf mg mh mi mj mk km ml kn mm kp mn kq mo ks mp kt mq mr bi translated">结论</h1><p id="9cfd" class="pw-post-body-paragraph kv kw jg kx b ky ms kh la lb mt kk ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">ReactDOM充当React、组件树和DOM之间的接口。最常见的函数是render()函数。它充当React和DOM之间的媒介。</p><p id="7e0f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦React根元素和子组件树被呈现，协调过程就处理与页面更新相关的所有事情。如果我们决定更新其中一个子组件，那么只有该组件内的更改才会发生。</p><h1 id="5be6" class="ma mb jg bd mc md me mf mg mh mi mj mk km ml kn mm kp mn kq mo ks mp kt mq mr bi translated">其他文章</h1><div class="ip iq gp gr ir nu"><a href="https://medium.com/javascript-in-plain-english/why-you-should-care-about-how-the-browsers-work-in-react-749bcbecc32f" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd jh gy z fp nz fr fs oa fu fw jf bi translated">为什么您应该关心浏览器在React中的工作方式</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">了解DOM与JavaScript的关系</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ix nu"/></div></div></a></div><div class="ip iq gp gr ir nu"><a href="https://medium.com/javascript-in-plain-english/why-do-we-have-to-wrap-react-components-b168232dbd3a" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd jh gy z fp nz fr fs oa fu fw jf bi translated">为什么我们必须包装React组件？</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">理解React应用程序中的div包装！</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oj l of og oh od oi ix nu"/></div></div></a></div><div class="ip iq gp gr ir nu"><a href="https://medium.com/javascript-in-plain-english/why-you-should-be-using-react-fragments-a5d8314a59ff" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd jh gy z fp nz fr fs oa fu fw jf bi translated">为什么应该使用React片段</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">如何使用React提升React应用程序？碎片</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="ok l of og oh od oi ix nu"/></div></div></a></div><h1 id="22ca" class="ma mb jg bd mc md me mf mg mh mi mj mk km ml kn mm kp mn kq mo ks mp kt mq mr bi translated">关于作者</h1><p id="7758" class="pw-post-body-paragraph kv kw jg kx b ky ms kh la lb mt kk ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">我是一名执业医师和教育家，也是一名网站开发者。请看<a class="ae jd" href="https://dev.to/aaronsm46722627/www.coding-medic.com" rel="noopener ugc nofollow" target="_blank">这里</a>关于我在我的博客和其他帖子上关于项目的更多细节。如果你想和我联系，请在这里联系:<a class="ae jd" href="mailto:aaron.smith.07@aberdeen.ac.uk" rel="noopener ugc nofollow" target="_blank">aaron . Smith . 07 @ aberdeen . AC . uk</a>或者在推特上@aaronsmithdev。</p></div></div>    
</body>
</html>