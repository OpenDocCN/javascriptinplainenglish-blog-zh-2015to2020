# 节点数据访问模型

> 原文：<https://javascript.plainenglish.io/data-access-models-with-node-15b0e30807b4?source=collection_archive---------2----------------------->

![](img/837c808605e31389d30ead6e0fbbebd0.png)

Photo by [Maarten van den Heuvel](https://unsplash.com/@mvdheuvel?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

我们不必为需要访问的每个表编写 CRUD 方法，我们可以创建一个模块来提供数据，并且可以根据需要进行扩展。本文将详细介绍这一过程，并提供一个示例应用程序来总结这些步骤。

相关的存储库可以在[https://github.com/grovercoder/article-data-access-model](https://github.com/grovercoder/article-data-access-model)找到。

我已经编写了许多应用程序，几乎每一个都需要一个公共实体——特定于数据库表的数据访问模型。在过去，我已经在飞行中创建了这些，但这个问题不断出现，所以是时候让它变得更容易了。

我们也许可以通过使用一个像 [Squelize](https://sequelize.org/) 或 [Objection 这样的对象关系映射系统来完成这个任务。JS](https://vincit.github.io/objection.js/) 。这些是健壮的通用系统，可能比我们需要的要多得多。在某些情况下，向应用程序中添加另一个框架并不是最佳解决方案。在我的例子中，数据库需求要么非常基本，要么非常特定于应用程序和数据库。所以 ORM 通常不是正确的答案。

我们想要的是一个简单的通用模块，它提供通用的 CRUD 方法，并且可以扩展附加功能。

**注:**我们这里说的是抽象的想法。但是当谈到使用这些想法时，我们需要一个具体的例子。我们将假设一个简单的任务数据库，因为我们通过代码工作。该数据库将有两个表——组和任务。我们将在构建实例时使用这些。

# 要求

我们可能应该更详细地定义我们试图构建的内容，这样我们就知道什么时候完成了。

*   核心模块不应该了解数据库或表。
*   数据库连接和表模式(也就是字段及其数据类型的列表)应该被传递到模块中。
*   然后，该模块将使用模式信息来构建必要的函数。
*   该模块将导出一个对象，然后可以立即用于处理指定的表。
*   解决方案应该允许一些字段被“保护”。也就是说，当返回一个记录或记录集时，受保护的字段应该从输出中省略。(即，用户密码不应包含在默认使用模式中。)如果需要，受保护的字段仍然可以通过自定义方法使用。
*   CRUD 方法都应该在导出的对象上定义。
*   如果需要，可以覆盖 CRUD 方法。
*   导出的对象可以包括只读信息属性(即，反映出当前设置的表名、模式和保护值)。

# 草案初稿

基于这些要求，我们正在寻找看起来有点像这样的东西:

我们可以看到这立即失败了，因为我们没有办法指定表名、模式或保护值。我们可以通过导出函数而不是对象来解决这个问题。该函数将通过一个`config`参数接收所需的数据，并返回所需的对象。这是一个[工厂方法](https://en.wikipedia.org/wiki/Factory_method_pattern)的实现。

这里我们利用*依赖注入*来传递数据库连接和其他模型配置。我们的`_model.js`文件并不依赖于任何特定的东西。

为了继续，我们需要做出两个选择，这两个选择将决定将来如何使用该模块。

*   首先，我们需要决定如何指定表模式。
*   其次，我们需要决定数据库连接对象的外观。

两者都将这个版本的模块锁定在那些特定的决策上。例如，如果我们决定连接将是一个已配置的 Knex。JS 对象，那么我们就永远不能将这个模型定义用于 MongoDB 数据存储。(除非我们的 MongoDB 连接具有与 Knex 相同的方法。JS 对象。)通过一些努力，我们可以减轻这种情况，也许可以使用适配器模式。出于我们的目的，我们将保持事情(相对)简单，并假设我们只是创建一个不同的模块实例来处理不同的连接类型。所以我们可能会以`_model.knex.js`和`_model.mongo.js`结束。那么我们的应用程序模型可能只需要适当的基础模块。这只是一种选择。

## 定义模式

我们可以用一个数组，甚至一个对象数组来定义我们的模式。或逗号分隔的字符串。然而 [JSON Schema](https://json-schema.org/) 已经是一个很好的工具来满足这种需求。它不仅允许我们定义自己的字段和字段类型(以一种适用于 JS 的方式)，还允许我们使用标准系统，而不需要定义自己的系统。

我们将要求模型对象的所有实例都必须传入一个 JSON 模式对象，以定义表的字段列表。我们一会儿会看到一个例子。

## 定义数据库连接

如上所述，我们可以选择任何数据库连接对象。对于我们这里的例子，我们将使用 Knex.JS .只是因为我需要定期连接到 RDBMS 类型的数据库，我相信这是一个非常常见的任务。

## 创建更好的实例对象

到目前为止，我们只是在用法部分使用了我们的核心模型。但这不是我们真正要做的。相反，让我们为两个示例表——组和任务——创建一个实际的实例。

关于命名标准的简短说明。我的模型使用表名的单数时态来命名。表名是表包含的对象的复数时态。

这里，我们将“knex”对象与表名、模式和保护值一起传递到模型中。

我们已经为任务模型包含了“受保护”的值，这样我们就不需要在以后重新讨论它。假设`public_code`字段由数据库生成并在第三方系统中使用，但我们的代码并不真正需要它。通过将其标记为 guarded，它将从我们的模型函数的输出中省略。(我们还需要构建它)。因此，受保护的值只是一个与 JSON 模式对象的“属性”相匹配的字段名数组。空数组也是有效的，表明我们不需要保护任何字段。

该模式看起来很复杂，但它主要是剪切和粘贴现有的定义，并根据需要进行调整。对于 JSON 模式，我们可以做/指定更多的事情，但是此时我们最感兴趣的是属性列表。属性也非常有用，但是如果/当你需要的时候，我会留给你去扩展它。

我们的实例模型定义就完成了。从这里，我们可以访问 our _model.js 模块为我们展示的所有功能。不过现在这还很少。

## 向模型添加功能

有两个我们还没有谈到的必要功能:

*   `guard()`法。这个方法检查一个数据对象，并删除在`guarded`数组中命名的任何属性。这主要是一个内部函数，在需要的时候会被 CRUD 方法调用。
*   一种`populate()`方法。它接受一个数据对象，然后只提取与模式定义的属性相匹配的属性。这为我们提供了一个基本的验证过程，并确保生成的数据对象可以在我们的创建和更新方法中使用。不需要额外的检查来确保我们没有无意中通过一个不存在的字段。同样，这主要是一个内部方法。(尽管仍然强烈建议进行良好的验证，但这超出了本文的范围……)

我们将首先创建这两个方法，因为其余的依赖于它们，这两个方法都很好地定义了剩余 CRUD 函数的秘密。

首先，我们在工厂方法中定义两个函数— `_guard`和`_populate`。两者都是返回函数的函数。`config`参数(定义为模块工厂方法的一部分)被传递给这两个方法。这允许我们访问配置数据。如果没有这种方法，我们将需要以`MyModel.guard(config, record)`的形式调用函数，这是不自然的。相反，我们希望`MyModel.guard(record)`和“我的模型”对象应该已经知道什么配置信息是需要的。

`guard`方法非常简单。它返回的函数接受一个“记录”参数(它应该是任何普通的键/值对象)。它检查我们的模型配置是否定义了一个受保护的数组。如果是这样，它遍历受保护数组中的每个值，并从记录对象中删除该字段。然后返回记录对象，不包含不需要的字段。

populate 方法只是稍微复杂一点。它返回的函数接受一个“数据”对象。它检查模型是否定义了 schema.properties 对象。如果是这样，它从该对象中提取键并循环访问它们。属性对象是从模式中提取出来的—稍后将使用它来确保我们返回正确的数据类型。提取传入数据对象的当前值，我们将对此进行一些操作。如果提取的值被定义，那么我们将它与模式属性的类型进行比较，以确保它被设置为适当的 JS 数据类型。

如果/当需要时，此部分可以扩展到包括其他项目。例如，如果属性格式是“email”，您可能希望验证当前值是否是正确的电子邮件地址，或者将它包装在 mailto 锚标记中。如果需要，请随意扩展此部分。(当然，也可以是任何代码)。

对于每个 CRUD 操作，都要重复将 config 对象传递给一个函数的方法，该函数将返回该函数的最终版本。然后，它们执行必要的步骤来执行适当的 CRUD 操作，但是使用 config 对象进行设置。例如，findById 方法可以用命令`config.knex(config.tablename).where({id: passedInID}).first()`来完成。这是一个简单的 Knex。JS 命令。在下面的代码中，我调用了几个 Knex 方法，逻辑应该非常清楚。我建议看看 Knex。JS 文档来了解这里可以/应该做些什么。

## 私有与公共属性/方法

在我们模型的当前版本中，我们已经在返回的对象上设置了`guard`和`populate`方法。这些现在是对象的公共属性，可以被覆盖。我们的 CRUD 方法也将是公共的。这满足了我们可以覆盖它们的要求。

但是，我们有一个要求，我们应该有一些只读属性，公开 tablename、schema 和 guarded 的当前配置设置。我们可以通过使用原生的 JS [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 方法来实现这一点。我们可以将所需的对象放入一个临时变量中，添加只读属性，然后返回临时变量，而不是直接从工厂方法中返回。

```
const output = {...}  
Object.defineProperty(output, '_tablename', {value: config.tablename, writeable: false})return output
```

我们将稍微清理一下代码，并在分配完只读属性后分配方法。这将导致在对象上执行 console.log()时，只读项目位于对象的顶部。

因此，我们的 final _model.js 文件应该如下所示:

假设我们没有错误，并且数据库连接模块工作正常，我们将对我们为其定义实例模型的每个表进行完整的 CRUD 操作。

## 覆盖方法

我们的需求之一是 CRUD 方法可以被覆盖。让我们假设我们的任务模型需要 create 方法的一些附加功能——我们不希望创建一个名称为“Task”的任务。如果名称是“运行”,我们希望将名称更改为“自动任务”。我们仍然需要一个创建方法，我们只需要它的一个特殊版本。

我们从模型实例的相同定义开始。然后我们存储一个对最初的`create`方法的引用。接下来，我们为 Model.create 属性分配一个新函数。在该函数中，我们可以选择调用原始方法，或者我们可以在这里放置适当的 Knex 代码来完成我们的任务。这里的要点是我们已经替换了“核心”创建方法。

如果你尝试`Model._tablename = ‘new value'`，你会收到一个错误，因为这是一个只读属性。

## 样本储存库

我已经创建了一个[样本库](https://github.com/grovercoder/article-data-access-model)，其中包含了本文中定义的思想。这个示例代码演示了为什么 SQLite 不应该在生产中使用。我们在`_model.js`文件上的`create`和`update`方法调用 Knex 的`.returning()`方法。SQLite 不支持这一点，并阻止我们直接获取新的或更新的数据。我已经在一些应用程序中解决了这个问题，方法是立即对填充的记录数据执行`.find()`，减去任何自动生成的数据(比如 created_at 字段)。这可能看起来像下面这样:

```
async function create(data) {
  const record = _populate(data)
  await config.knex(config.tablename).insert(record)
  delete record.created_at
  const newRecord = await config.knex(config.tablename)
      .where(record)
      .first()
  return _guard(newRecord)
}
```

如果您正在使用 SQLite，或者不能依赖于`.returns()`方法，这可能对您有用。

## 结论

我们可以做很多事情来改善这一点。添加更好的验证和错误处理，处理数据库事务，为模型创建测试，或者只是根据我们的需要进行调整。这应该被视为您自己的应用程序需求的起点。

我欢迎评论/建议/问题来改进这一点。我只是一个人，几乎没有经过同行评议就建立了这个公司。尽管这个解决方案对我的应用程序有效。希望对你自己的应用有用。