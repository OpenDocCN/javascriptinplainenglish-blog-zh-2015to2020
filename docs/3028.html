<html>
<head>
<title>How “this” binds in regular functions and arrow functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“this”如何在JavaScript中绑定常规函数和箭头函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/this-binding-in-es6-arrow-function-70d80e216238?source=collection_archive---------1-----------------------#2020-08-21">https://javascript.plainenglish.io/this-binding-in-es6-arrow-function-70d80e216238?source=collection_archive---------1-----------------------#2020-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eb28c54677656002e45280168ac5c12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QLAQVO-gYWW_gyF1.jpg"/></div></div></figure><h1 id="b744" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Arrow语法自动将其绑定到周围代码的上下文中。</h1><p id="6e63" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我解释一下那是什么意思！为此，我们必须首先了解使用箭头函数可以解决什么问题。</p><p id="553e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们讨论一下使用普通函数而不是箭头函数的场景。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/247b563fca40fd96b340b025e549eada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIxt8b38CZAdPEgGPKUkCA.png"/></div></div></figure><p id="2b27" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里的<strong class="ky ir"> Person </strong>函数是一个构造函数。我们正在通过新的关键字创建一个对象<strong class="ky ir"> person1 </strong>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5be0" class="mj jz iq mf b gy mk ml l mm mn">var person1 = new Person('Joey Smith', 25);</span></pre><ol class=""><li id="e58e" class="mo mp iq ky b kz lu ld lv lh mq ll mr lp ms lt mt mu mv mw bi translated">当执行这一行时，new关键字后面的构造函数Person被调用，它设置使用this.property_name新创建的空对象的属性，该属性包括<strong class="ky ir"> personName </strong>、<strong class="ky ir"> age、</strong>和函数<strong class="ky ir"> getDetails </strong>。该构造函数隐式返回一个对象，该对象存储在<strong class="ky ir"> person1 </strong>变量中。</li><li id="9f60" class="mo mp iq ky b kz mx ld my lh mz ll na lp nb lt mt mu mv mw bi translated">然后，我们可以调用person1对象的成员函数<strong class="ky ir"> getDetails </strong>，通过执行下面一行代码来控制person的详细信息。</li></ol><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cb07" class="mj jz iq mf b gy mk ml l mm mn">person1.getDetails()</span></pre><p id="c579" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">3.<strong class="ky ir"> getDetails </strong>有一个<strong class="ky ir"> setTimeout </strong>，它将在指定时间后执行传递给它的函数(time作为第二个参数传递给setTimeout函数)。在setTimeout中传递的回调是引用它的正常函数。</p><p id="fbec" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当执行上述代码时，会生成以下输出:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e167" class="mj jz iq mf b gy mk ml l mm mn">Name: undefined, Age: undefined</span></pre><p id="d587" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">名字和年龄都不确定。哎呀。！这肯定不是你所期望的。</p><p id="b8ee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">为什么会这样？</strong> <br/>不需要输出的原因是，在正常函数<strong class="ky ir">中，这个</strong>关键字代表调用该函数的对象。当我们的函数getDetails被正常调用<strong class="ky ir">时，这个</strong>关键字表示全局对象，在我们的例子中是窗口对象，并且在全局对象中没有名为<strong class="ky ir"> personName </strong>或<strong class="ky ir"> age </strong>的变量，由于这两个变量都是未定义的。</p><p id="bec7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是在执行堆栈中发生了什么呢？</p><p id="ae40" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先，全局执行上下文进入执行堆栈，在其变量环境中有一个构造函数Person和person1对象。person对象是通过new关键字由上面解释的步骤创建的，然后存储在Person中。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/8409f336a77108b89f4982d1ded40156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*zaJxWMCuqR1H5kSvPulAlQ.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Execution Stack</figcaption></figure><p id="96d6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">之后，全局执行上下文调用getDetails函数，该函数是person1对象的成员函数。当getDetails函数被调用时，它的执行上下文被创建并被推送到执行堆栈上。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f20b82a590574e04763200a73952fccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*psK0CPbDXfD6HPU-XdRDzw.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Execution Stack</figcaption></figure><p id="4fad" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">getDetails函数有一个setTimeout，它有一个回调函数，这个回调函数将进入回调队列(假设它是一个存放回调函数的存储区)，一旦执行上下文而不是全局执行上下文从执行上下文中弹出，这个回调函数就会被执行。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/39465cb096476d548694e839c8f9aa95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*SjRDni6BsVSKjyEa9Z8Ypw.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">The left side is execution Context and on the right side is the setTimeout function waiting for the specified time to pass</figcaption></figure><p id="bd83" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当堆栈变空时(除了全局执行上下文)，回调将被执行，新的执行上下文将被创建。即回调被正常调用，并且<strong class="ky ir">中的这个</strong>关键字代表全局上下文。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/dd17f916c793e9be6a9ff2df1b9b51d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*1XwQonIXGhpg5f0gOX0l0A.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">Execution Stack</figcaption></figure><p id="fe72" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在正常调用函数的情况下，<strong class="ky ir">这个</strong>关键字代表全局上下文，当在全局上下文中没有找到personName和age变量时，它给出未定义。</p><p id="49de" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这就是我们的问题，正常的函数调用代表的是调用函数的对象，而不是周围的上下文本身。</p><p id="f656" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">这怎么解决？</strong></p><p id="9976" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">JavaScript中的所有函数都可以独立访问一些特殊的方法，bind()、call()和apply()就是其中的几个。一种解决方案是使用这些bind()，call()或apply()。通过使用这些方法，我们可以控制这个最终代表什么<strong class="ky ir">。</strong></p><p id="b861" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，通过使用这些方法，我们可以将这个人绑定到回调函数，这样我们的问题就解决了。下面是在回调函数上使用bind方法并将其绑定到Person的示例。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/d553c25f8aa5055ef83c23057f24597b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkxrJG0OHm_ki2Jg4VY7IQ.png"/></div></div></figure><p id="d2e1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">同样，我们可以使用apply和call方法。</p><blockquote class="nk nl nm"><p id="6193" class="kw kx nn ky b kz lu lb lc ld lv lf lg no lw lj lk np lx ln lo nq ly lr ls lt ij bi translated">但是，当问题可以通过改变语法来解决时，为什么要经历这么多麻烦呢？</p></blockquote><p id="fa4f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这种情况下，Arrow函数用其简单的语法来拯救我们。</p><p id="a1b8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们使用箭头函数作为回调函数，而不是普通函数，我们的问题就解决了。让我们看看代码。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/ab29fdb183d84e84242efcba4419402f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CT4ZFxDUf-e7OXnBh-0_Pg.png"/></div></div></figure><p id="1fd7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在执行代码时，我们得到以下输出。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a9fe" class="mj jz iq mf b gy mk ml l mm mn">Name: Chandler, Age: 25</span></pre><p id="7786" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">基本上在arrow函数中，这总是代表定义Arrow函数的对象。Arrow语法自动将<strong class="ky ir"> <em class="nn"> this </em> </strong>绑定到周围代码的上下文中。在Arrow函数中，它不依赖于它们是如何被调用的，而是依赖于周围的上下文。</p></div></div>    
</body>
</html>