<html>
<head>
<title>How to use Readline in Node to read test cases.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Node中的Readline读取测试用例？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-read-test-cases-from-stdin-and-files-using-readline-in-node-js-cf5ef37e6b5e?source=collection_archive---------0-----------------------#2019-04-15">https://javascript.plainenglish.io/how-to-read-test-cases-from-stdin-and-files-using-readline-in-node-js-cf5ef37e6b5e?source=collection_archive---------0-----------------------#2019-04-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/00ef4df43d8f562f30ebc716adb98457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wJnLR1-GurZP6FRR"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@maxchen2k?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Chen</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="a3c0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时当我们在一个在线挑战平台上解决一个编码问题时，我们需要用不同的测试用例或者测试用例的许多文件来测试我们的算法。</p><p id="88ae" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我试着写了一个<a class="ae ja" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="kc je">二分搜索法</strong> </a> <strong class="kc je"> </strong>算法，它允许在一个排序的数组中找到一个元素的索引，我使用来自stdin和一个文本文件的一些测试用例来测试它。</p><p id="9e26" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以让我们从编写二分搜索法算法开始我们的例子；</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="e63e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们检查数组是否为空，并返回-1表示该元素不存在。</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="28ae" class="lj lk jd lf b gy ll lm l ln lo">// verify if the array is not null and contains elements  <br/>if (!array || !array.length) {<br/>    return -1;    <br/>}</span></pre><p id="0afa" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们声明两个变量<code class="fe lp lq lr lf b">start</code>和<code class="fe lp lq lr lf b">end</code>，并通过数组的第一个和最后一个索引来初始化它们。</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="526f" class="lj lk jd lf b gy ll lm l ln lo">let start = 0;    <br/>let end = array.length - 1;</span></pre><p id="d8cd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，我们迭代数组，直到条件<code class="fe lp lq lr lf b">start &lt; end</code>无效；</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="f0fe" class="lj lk jd lf b gy ll lm l ln lo">while (start &lt; end) {        <br/>const middle = parseInt((start + end) / 2, 10);        <br/>if (array[middle] === element) {            <br/>     return middle;        <br/>} else if (array[middle] &lt; element) { <br/>     start = middle + 1;        <br/>} else {            <br/>     end = middle;        <br/>}    <br/>}</span></pre><p id="a2d4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们检查最后一个案例时的<code class="fe lp lq lr lf b">start = end</code></p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="a7ac" class="lj lk jd lf b gy ll lm l ln lo">// end condition: start === end    <br/>if (start !== array.length &amp;&amp; array[start] === element) return start</span></pre><p id="6ee6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当数组中不存在该元素时，我们返回-1。</p><p id="18cd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在实现了我们的基本算法之后，现在让我们进入主要部分；</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="faaf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了读取测试用例，我们使用模块<code class="fe lp lq lr lf b">readline</code>，它提供了一个接口，用于从<a class="ae ja" href="https://nodejs.org/api/stream.html#stream_readable_streams" rel="noopener ugc nofollow" target="_blank">可读的</a>流(比如<code class="fe lp lq lr lf b"><a class="ae ja" href="https://nodejs.org/api/process.html#process_process_stdin" rel="noopener ugc nofollow" target="_blank">process.stdin</a></code>)中一次一行地读取数据。所以我们必须使用<code class="fe lp lq lr lf b">createInterface()</code>方法从<code class="fe lp lq lr lf b">readline.Interface</code>类创建一个实例。</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="b8b2" class="lj lk jd lf b gy ll lm l ln lo">// create an interface<br/>const rl = readline.createInterface({    <br/>  input: process.stdin, // readable Stream: stdin<br/>});</span></pre><p id="3e6d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，接口应该监听<code class="fe lp lq lr lf b">line</code>事件，每当<code class="fe lp lq lr lf b">input</code>流接收到一个行尾输入(<code class="fe lp lq lr lf b">\n</code>、<code class="fe lp lq lr lf b">\r</code>或<code class="fe lp lq lr lf b">\r\n</code>)时就会发出该事件。这通常发生在用户按下<code class="fe lp lq lr lf b">&lt;Enter&gt;</code>或<code class="fe lp lq lr lf b">&lt;Return&gt;</code>键时。</p><p id="66af" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，测试用例具有这样的格式:1≤T≤100；1≤ N ≤ 1000</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="8a2d" class="lj lk jd lf b gy ll lm l ln lo">T<br/>N target<br/>e1 e2 e3 ...... eN</span></pre><p id="7770" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们设置了我们的接口，并创建了一个监听器来获取新行存在时的行值；</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="01a2" class="lj lk jd lf b gy ll lm l ln lo">rl.on('line', (line) =&gt; {   <br/>// Extract the first line value = T<br/>if (!T) {        <br/>T = line        <br/>return    <br/>}    <br/>count++<br/>// Get the value of N and the element to fetch in the array</span><span id="ce95" class="lj lk jd lf b gy ls lm l ln lo">if (count % 2) {        <br/>[ N, element ] = line.split(' ').map(e =&gt; Number(e));    <br/>}    <br/>if (!(count % 2)) {   <br/>// extract the array element from the line <br/>   <br/>const array = line.split(' ').map(e =&gt; Number(e)); </span><span id="d1a0" class="lj lk jd lf b gy ls lm l ln lo">// fetch the element's index in the array    <br/>   <br/>const fetchedIndex = binarySearch(array, element); <br/>   <br/>console.log(`Case #${parseInt(count / 2, 10)}:`, fetchedIndex)            }  <br/>// close the interface when the number or lines exceeds 2 * T</span><span id="d288" class="lj lk jd lf b gy ls lm l ln lo">if (count &gt;= 2 * T){        <br/>rl.close();    <br/>}   <br/>})</span></pre><p id="28a7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们从文件中读取值时，唯一的区别是输入属性的初始化；</p><pre class="ky kz la lb gt le lf lg lh aw li bi"><span id="d3b6" class="lj lk jd lf b gy ll lm l ln lo">// Creation of readline instanceconst <br/>rl = createInterface({  <br/>input: fs.createReadStream(filePath), // readable Stream: file  crlfDelay: Infinity});</span></pre><p id="e0bf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">总结</strong></p><p id="38a8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们遇到了一个简单的例子，我们使用<a class="ae ja" href="https://nodejs.org/api/readline.html#readline_readline" rel="noopener ugc nofollow" target="_blank"><strong class="kc je"><em class="lt">readline</em></strong></a><strong class="kc je"><em class="lt"/></strong>从stdin或文件中读取数据。</p><p id="be27" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在打字或代码错误的情况下，请随时给我留下评论。</p><p id="d5d8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码:</p><div class="im in gp gr io lu"><a href="https://github.com/slim-hmidi/readline" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd je gy z fp lz fr fs ma fu fw jc bi translated">超薄HMI di/读取线</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">一个使用realine接口从标准输入或文件中获取数据的例子</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">github.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi iu lu"/></div></div></a></div></div></div>    
</body>
</html>