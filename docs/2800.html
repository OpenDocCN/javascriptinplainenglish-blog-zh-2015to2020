<html>
<head>
<title>TypeScript Best Practices — Interfaces vs Type Aliases and Unnecessary Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript最佳实践—接口与类型别名和不必要的语法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-best-practices-interfaces-vs-type-aliases-and-unnecessary-syntax-cd1526a926cb?source=collection_archive---------3-----------------------#2020-07-25">https://javascript.plainenglish.io/typescript-best-practices-interfaces-vs-type-aliases-and-unnecessary-syntax-cd1526a926cb?source=collection_archive---------3-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eaa5bcc6ed55119b2aadab3e35692f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CEPAGbhYtrm4CnIE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Gold</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2ee0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="068d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类名大小写</h1><p id="cc55" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript类名应该是PascalCase。</p><p id="06be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也适用于接口。</p><p id="ff5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5625" class="mn lc iq mj b gy mo mp l mq mr">class Foobar {}</span></pre><p id="232e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="669c" class="mn lc iq mj b gy mo mp l mq mr">interface FooBar {}</span></pre><h1 id="b7b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对文件使用UTF-8编码</h1><p id="336e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该对文件使用UTF 8编码。</p><p id="8e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，在任何地方使用该文件都不会有任何问题。</p><h1 id="ad50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">文件名大小写</h1><p id="aeab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该用一致的大小写命名我们的文件。</p><p id="01df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以坚持骆驼案，帕斯卡案，烤肉串案，或蛇案。</p><p id="6c35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">骆驼案是<code class="fe ms mt mu mj b">fileName.ts</code>。</p><p id="afa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">帕斯卡格是<code class="fe ms mt mu mj b">FileName.ts</code>，</p><p id="f462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">烤肉串案是<code class="fe ms mt mu mj b">file-name.ts</code>。</p><p id="f9a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">蛇案是<code class="fe ms mt mu mj b">file_name.ts</code>。</p><p id="d7c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只对所有文件使用一个。</p><h1 id="fb7e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用显式递增或递减运算符</h1><p id="d1b1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用显式的递增或递减操作符，以确保我们只分配新值，而不使用返回值。</p><p id="3e92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5b3d" class="mn lc iq mj b gy mo mp l mq mr">++i;<br/>i++;<br/>--j;<br/>j--;</span></pre><p id="6383" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数返回值并执行递增或递减操作，我们编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b815" class="mn lc iq mj b gy mo mp l mq mr">i += 1;<br/>i -= 1;<br/>j += 1;<br/>j -= 1;</span></pre><h1 id="8cf3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">连接</h1><p id="63e8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可能希望拥有以<code class="fe ms mt mu mj b">I</code>开头的界面，以区别于其他实体。</p><p id="cb9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可能想写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b484" class="mn lc iq mj b gy mo mp l mq mr">interface IFoo {<br/>  bar: string;<br/>}</span></pre><h1 id="d0a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在类型文本上使用接口</h1><p id="7473" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接口可以被实现、扩展和合并，所以它们比文字类型更受欢迎。</p><p id="7b9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3698" class="mn lc iq mj b gy mo mp l mq mr">type Alias = {<br/>  num: number<br/>}</span></pre><p id="fa4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c011" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {<br/>  num: number;<br/>}</span></pre><h1 id="3036" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">匹配默认导出名称</h1><p id="ab23" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个默认导出，那么我们的默认导入应该匹配导出的名称。</p><p id="bec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这减少了混淆。</p><p id="6a5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><p id="905f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">bar.ts</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9a96" class="mn lc iq mj b gy mo mp l mq mr">export default foo;</span></pre><p id="a169" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="af7a" class="mn lc iq mj b gy mo mp l mq mr">import foo from bar;</span></pre><h1 id="9865" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">每个链接调用换行</h1><p id="6ce5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一连串的方法调用，那么我们可能希望将它们放在一个新的行中，这样就不会溢出页面。</p><p id="f0aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2cc0" class="mn lc iq mj b gy mo mp l mq mr">foo.bar().baz();</span></pre><p id="3f6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9471" class="mn lc iq mj b gy mo mp l mq mr">foo<br/>  .bar()<br/>  .baz();</span></pre><h1 id="1033" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有尖括号类型断言</h1><p id="fa49" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该将<code class="fe ms mt mu mj b">as</code>用于类型断言，因为除了<code class="fe ms mt mu mj b">.ts</code>文件之外，我们还可以将它用于<code class="fe ms mt mu mj b">.tsx</code>文件中的类型断言。</p><p id="46c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a7e4" class="mn lc iq mj b gy mo mp l mq mr">const foo = &lt;Bar&gt;bar;</span></pre><p id="2ca2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="76fb" class="mn lc iq mj b gy mo mp l mq mr">const foo = bar as Bar;</span></pre><h1 id="d9ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有布尔文字比较</h1><p id="38ca" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该和布尔文字比较，因为它们是多余的。</p><p id="54ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以缩短:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="758f" class="mn lc iq mj b gy mo mp l mq mr">if (x === true)</span></pre><p id="b32f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收件人:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f98c" class="mn lc iq mj b gy mo mp l mq mr">if (x)</span></pre><h1 id="ff7b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参数属性的使用</h1><p id="301c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在类型脚本代码中包含参数属性。</p><p id="df13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们让我们传入<code class="fe ms mt mu mj b">constructor</code>参数，同时给它赋值。</p><p id="21bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c022" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  constructor(private numLegs: number) {}<br/>}</span></pre><p id="ac1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e902" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  private numLegs: number = 2;<br/>  constructor(numLegs: number) {<br/>    this.numLegs = numLegs;<br/>  }<br/>}</span></pre><h1 id="abf6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有引用导入</h1><p id="08f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用<code class="fe ms mt mu mj b">import</code>就不要用<code class="fe ms mt mu mj b">reference</code>。</p><p id="261b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b53d" class="mn lc iq mj b gy mo mp l mq mr">&lt;reference path="foo.bar" /&gt;</span></pre><p id="9ad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3e51" class="mn lc iq mj b gy mo mp l mq mr">import { bar } from 'foo';</span></pre><p id="6f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它更加标准，我们不再需要<code class="fe ms mt mu mj b">reference</code>从类型定义文件中提取类型定义。</p><h1 id="9c7b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有无用的回调包装</h1><p id="2f30" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中不应该有无用的回调包装器。</p><p id="c7a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3dbe" class="mn lc iq mj b gy mo mp l mq mr">const handleContent = (content) =&gt; console.log('do something with', content);</span><span id="e9d7" class="mn lc iq mj b gy mv mp l mq mr">promise.then((content) =&gt; handleContent(content))</span></pre><p id="f221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1bab" class="mn lc iq mj b gy mo mp l mq mr">const handleContent = (content) =&gt; console.log('do something with', content);</span><span id="e0aa" class="mn lc iq mj b gy mv mp l mq mr">promise.then(handleContent)</span></pre><p id="b59f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干净多了。</p><h1 id="45b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不必要的初始化器</h1><p id="6d60" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该将变量设置为<code class="fe ms mt mu mj b">undefined</code>。</p><p id="d648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0ffa" class="mn lc iq mj b gy mo mp l mq mr">let x =  undefined;</span></pre><p id="59f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ca02" class="mn lc iq mj b gy mo mp l mq mr">let x;</span></pre><h1 id="ed84" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有对象文字键引号</h1><p id="003d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果一个对象文字有有效的标识符作为属性名，那么我们就不需要在名称两边加引号。</p><p id="cc41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="75d7" class="mn lc iq mj b gy mo mp l mq mr">const obj = { 'foo': 1 };</span></pre><p id="a3ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="10d4" class="mn lc iq mj b gy mo mp l mq mr">const obj = { foo: 1 };</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/167eeb81852de384042e51a4e282c53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_6mF2cqylCU88MJR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brunabranco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bruna Branco</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1e16" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5326" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该有一个一致的文件名大小写。</p><p id="0f6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该在代码中使用不必要的语法。</p><p id="904d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导入应该用于从外部来源提取数据类型定义。</p><p id="e025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无用的回调包装器也应该被移除。</p><p id="e6e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该使用接口而不是类型别名，因为它们更通用。</p><h1 id="a6b6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="90d4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>