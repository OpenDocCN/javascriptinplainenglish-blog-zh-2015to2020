<html>
<head>
<title>Mastering concurrency with JavaScript / NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript / NodeJS掌握并发性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mastering-concurrency-with-javascript-nodejs-289816acc641?source=collection_archive---------1-----------------------#2020-06-06">https://javascript.plainenglish.io/mastering-concurrency-with-javascript-nodejs-289816acc641?source=collection_archive---------1-----------------------#2020-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" rel="noopener ugc nofollow" target="_blank">并发</a>是一个程序、算法或问题的不同部分或单元不按顺序或按部分顺序执行，而不影响结果的能力。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5a133202521999079a0d0db505829a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kx2aFGAx94HQUcQN"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Photo by <a class="ae kl" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Science in HD</a> on <a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a05f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript引入的<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>和<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步</a>函数在I/O(如网络调用或使用事件循环读取文件等)期间执行代码而不阻塞线程，而不是等到操作完成。一旦操作完成，它就解决了。NodeJS使用<a class="ae kl" href="http://docs.libuv.org/en/v1.x/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">libuv</strong></a><strong class="jp ir"/>来管理事件循环和I/O操作。</p><p id="9d79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在日常生活中，我们有许多可能需要串行或并行运行这些异步函数的用例。</p><h1 id="1c19" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">串行运行异步功能</strong></h1><p id="40b1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设我们需要对数组中的每个元素应用异步函数。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/c39c67c45abbf5d2a357fba5beeabbde" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/c39c67c45abbf5d2a357fba5beeabbde</a></figcaption></figure><p id="47bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>代替for循环。reduce的一个属性是当前值依赖于以前的值，所以我们串行运行它们。</p><p id="3e05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们播种了<code class="fe mh mi mj mk b">[]</code> ( <em class="ml">空数组</em>)的诺言。我们解析先前的值(<em class="ml">最初为空数组)。然后我们执行作为参数的函数<code class="fe mh mi mj mk b">fn</code>。</em></p><p id="d33c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将函数或错误的结果推送到数组中，并返回数组。因为给reduce的回调是一个异步函数，它返回一个新数组的承诺。</p><p id="204d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个要连续执行的样本代码。</p><p id="89b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用睡眠功能来等待一些东西</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/629c8cf3d2178a5d0ce04ae8ba0fe1c7" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/629c8cf3d2178a5d0ce04ae8ba0fe1c7</a></figcaption></figure><p id="566e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将使用一些实用函数来演示执行的本质。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/129ecdbb72c9f0f81827eb421260a8da" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/129ecdbb72c9f0f81827eb421260a8da</a></figcaption></figure><p id="ab27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">measure</code>用来衡量一个承诺</p><p id="f2c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">logPromise</code>用于记录承诺的结果</p><p id="877a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">chunk</code>用于将卡盘阵列转换成多个阵列</p><p id="1187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">range</code>是一个生成<code class="fe mh mi mj mk b">n</code>数字的小工具</p><p id="c3ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">promisify</code> HoF ( <a class="ae kl" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank"> <em class="ml">高阶函数</em> </a>)将回调时尚转换为承诺时尚。</p><p id="4cd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">noOp</code>是一个空函数</p><pre class="kn ko kp kq gt mm mk mn mo aw mp bi"><span id="119a" class="mq ld iq mk b gy mr ms l mt mu">// Example code to run in series<br/>// Let's take an array<br/>const input = range(4, 1);</span><span id="be46" class="mq ld iq mk b gy mv ms l mt mu">// This function sleep for timeout seconds<br/>async function callback1(timeout) {<br/>  console.log(timeout);<br/>  await sleep(timeout * 1000);<br/>}</span><span id="3885" class="mq ld iq mk b gy mv ms l mt mu">// Executing this array in series <br/>// Sleep for 1 second<br/>// Sleep for 2 seconds<br/>// ....<br/>// Sleep for 4 seconds<br/>measure(inSeries(input, callback1));</span><span id="2f92" class="mq ld iq mk b gy mv ms l mt mu">// Output:  Time taken 10s<br/>// Above function callback1 is executed in series<br/>// Time taken = sum( time taken by each promise)</span></pre><h1 id="fcc7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">并行运行异步功能</strong></h1><p id="e790" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们有很多可能需要并行运行这些异步函数的用例。<br/>示例:假设我们需要调用两个API和一个数据库调用，而这两个操作没有依赖关系，即API调用的结果不依赖于数据库，反之亦然。<br/>在这种情况下，连续进行这些调用会降低应用程序的速度。我们可以利用异步函数的能力，因为它们是I/O操作。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/e49c1853ebceacbd3ab6f725c42b4ba6" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/e49c1853ebceacbd3ab6f725c42b4ba6</a></figcaption></figure><p id="31a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Map" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">map</strong></a><strong class="jp ir"/>数组的方法来并行执行异步函数。</p><p id="d02d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们将元素数组映射到承诺数组，并使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/All" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">promise . all</strong></a><strong class="jp ir"/>方法等待所有承诺被解析。</p><pre class="kn ko kp kq gt mm mk mn mo aw mp bi"><span id="ea9a" class="mq ld iq mk b gy mr ms l mt mu">// Example for using inParallel function<br/>// We are using same input and callback1 function used to demonstrate inSeries</span><span id="1e20" class="mq ld iq mk b gy mv ms l mt mu">measure(inParallel(input, callback1));</span><span id="9ef5" class="mq ld iq mk b gy mv ms l mt mu">// Output: Time taken 4s<br/>// 4s was the highest timeout and promises were executed in parallel<br/>// Since we waited for all promises to resolve the time taken is 4s<br/>// Time taken = max( time taken by promise promises)</span></pre><p id="5798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">inParallel</code>对于有限的数据量是一个非常好的工具。让我们考虑一个例子，其中我们压缩在给定路径下的所有子路径中存在的图像。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/6cf01898dc91f9f814db86edde61787c" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/6cf01898dc91f9f814db86edde61787c</a></figcaption></figure><p id="671a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码片段用于对单个图像进行优化，并将优化后的图像存储回目的地。</p><p id="4e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于存在I/O操作，我们可以利用异步来提高速度</p><pre class="kn ko kp kq gt mm mk mn mo aw mp bi"><span id="4713" class="mq ld iq mk b gy mr ms l mt mu">// Consider we run this whole process in<br/>// globby is npm package to list files with regexp <br/>const globby = require('globby');</span><span id="7e59" class="mq ld iq mk b gy mv ms l mt mu">async function run() {<br/>  // List all images under images directory with ext png, jpg and jpeg<br/>  const files = globby('./images/**/*.{png,jpg,jpeg}');<br/>  <br/>  // Process everything in parallel and store the file in same place<br/>  await inParallel(files, file =&gt; optimizeImage(file, file));<br/>}</span><span id="b7a8" class="mq ld iq mk b gy mv ms l mt mu">logPromise(run());</span></pre><p id="dc25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出会是什么？</p><p id="52c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果只有几个文件，那么它可能会成功完成操作。</p><p id="64c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果有成千上万张图片会怎么样？</strong></p><p id="e4a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">系统会因为多种原因崩溃，如<em class="ml">内存不足</em>或<em class="ml">打开的最大文件数</em>错误等。</p><p id="f52d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在大多数批量操作中都是一样的。API会有速率限制，或者数据库会有连接限制(假设没有实现池)。</p><p id="f350" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以结论是我们总是需要控制并发性，也就是说，我们需要并行运行操作，我们可以限制可以并行运行的操作的数量。我们并行运行阵列的一个子集，每个子集串行运行。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/6d5aac83a4ec5a6976be06f8626552d5" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/6d5aac83a4ec5a6976be06f8626552d5</a></figcaption></figure><p id="f990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以结合上面的函数<code class="fe mh mi mj mk b">inSeries</code>和<code class="fe mh mi mj mk b">inParallel</code>来限制并发。<br/>我们使用<code class="fe mh mi mj mk b">chunk</code>函数将数组转换成二维数组，其中数组的每个元素都是大小为<code class="fe mh mi mj mk b">concurrency</code>的数组。</p><pre class="kn ko kp kq gt mm mk mn mo aw mp bi"><span id="fde3" class="mq ld iq mk b gy mr ms l mt mu">// Rewriting above code to optimize the images</span><span id="5d4b" class="mq ld iq mk b gy mv ms l mt mu">async function run() {<br/>  // List all images under images dir with ext png, jpg and jpeg<br/>  const files = globby('./images/**/*.{png,jpg,jpeg}');<br/>  <br/>  // Process with concurrency of 10<br/>  measure(inParallelWithLimit(files, 10, file =&gt; optimizeImage(file, file)));<br/>}</span><span id="443b" class="mq ld iq mk b gy mv ms l mt mu">// Output: Time taken 160s</span></pre><p id="d565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有200张图片，它转换成一个20的数组，其中每个数组的元素大小为10。<br/>因此，我们最终连续执行20个元素(即20批)，其中每次执行我们并行优化10个图像(即每批并行)。</p><p id="4f3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">那么现在代码优化了吗？编号</strong></p><p id="f7c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为在上面的<code class="fe mh mi mj mk b">inParallel</code>演示中我们看到并行执行所花费的时间是<code class="fe mh mi mj mk b">max(time taken)</code>。<br/>考虑在一个批处理中，我们有一个巨大的图像，比如说大小为<em class="ml"> 2MB </em>并且所有其他文件都小于<em class="ml"> 200KB </em>并且优化图像关闭<em class="ml"> 200KB </em>所花费的时间大约为<em class="ml"> 1秒</em>，2MB图像所花费的时间大约为<em class="ml"> 8秒。<br/> </em>考虑我们在所有批次中都有大约2MB大小的巨大图像</p><p id="42a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以很容易地得出结论，完成每一批的时间是8s，20批大约是160s。由于一个批处理中的所有内容都是并行运行的，优化9个图像所用的时间大约是1s，我们没有开始新的批处理，因为我们最终要为一个承诺等待8s。<br/>所以9个承诺是在浪费这些无所事事的8的时间。</p><p id="7a06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何优化这一渠道？<br/> 我们使用的是<strong class="jp ir">推送模型</strong>，在这里我们提供数据并等待结果。<br/>相反，我们可以使用<strong class="jp ir">拉模型</strong>，在这里我们定义并发性，每个实体可以在空闲时拉新项目进行处理。</p><p id="afa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们称这个每个处理实体为<strong class="jp ir">工作者</strong>。<br/>和数据队列作为<strong class="jp ir">通道</strong>。<br/>我们开始<strong class="jp ir"> x </strong>数量的工作线程并行使用同一个通道。<br/>一个<em class="ml">工人</em>在空闲时从<em class="ml">通道</em>中拾取要加工的工件，并将结果放回同一个<em class="ml">通道。<br/> </em>在这种情况下<strong class="jp ir">并发=活动工作者的数量</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/48e9d4cfd3af96d9db11921822ae7a16" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/48e9d4cfd3af96d9db11921822ae7a16</a></figcaption></figure><p id="d59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义一个阶级<code class="fe mh mi mj mk b">Channel</code>。它的构造函数接受一个参数<code class="fe mh mi mj mk b">data</code>即要处理的数据列表。</p><p id="f452" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">push</code>运行时用于添加更多项目(作业)的方法。</p><p id="ecde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">clear</code>用于清除通道中数据的方法。</p><p id="2eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">results</code> getter用于获取已处理作业的结果。</p><p id="55fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">next</code>方法被<em class="ml">工人</em>用来从<em class="ml">通道获得下一个作业。</em></p><p id="7770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">_callback</code>方法是一个<strong class="jp ir"> <em class="ml"> HoF </em> </strong>帮助在结果数组中存储该作业的结果。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/8e2653f6a298e3aef67227816d18dbbb" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/8e2653f6a298e3aef67227816d18dbbb</a></figcaption></figure><p id="d149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">Worker</code>类构造函数接受两件事。<br/> 1。通道(通道对象):获取数据并存储结果<br/> 2。fn(函数):需要应用于每个项目或作业的函数。</p><p id="0676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">setOnStop</code>:停止回调时设置的帮助器方法</p><p id="3105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">start</code>:开始处理从频道中挑选的作业。此方法是一个异步函数，一旦它不再有任何要处理的作业，就会被解析。</p><p id="e76b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">channel.next()</code>返回包含<br/> 1的数组。job exists: true/false，如果不存在，只通知worker停止并从start方法返回。<br/> 2。作业数据:是一个数组，有<em class="ml">项</em>和它的<em class="ml">索引<br/> </em> 3。callback: callback是一个函数，使用作业的结果调用它，将结果设置回通道中。</p><p id="c30d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">stop</code>:阻止工人加工的帮手。</p><p id="61d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们看到代码，我们就从通道中提取数据。</p><p id="a2ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用一个样本代码来利用worker。</p><pre class="kn ko kp kq gt mm mk mn mo aw mp bi"><span id="9f8f" class="mq ld iq mk b gy mr ms l mt mu">// Lets consider the same image optimization code</span><span id="23b9" class="mq ld iq mk b gy mv ms l mt mu">async function run() {<br/>  // List all images under images dir with ext png, jpg and jpeg<br/>  const files = globby('./images/**/*.{png,jpg,jpeg}');<br/>  <br/>  // fn to optimize image<br/>  const processor = file =&gt; optimizeImage(file, file);</span><span id="4347" class="mq ld iq mk b gy mv ms l mt mu">  // Create new channel with all files<br/>  const channel = new Channel(files);</span><span id="bf49" class="mq ld iq mk b gy mv ms l mt mu">  // Create 10 workers<br/>  const workers = range(10)<br/>        .map(() =&gt; new Worker(channel, processor));<br/>  <br/>  // Start all workers in parallel and wait.<br/>  // Start method will resolve after no jobs left to execute<br/>  measure(inParallel(workers, w =&gt; w.start()));<br/>}</span><span id="8f75" class="mq ld iq mk b gy mv ms l mt mu">// Output :  Time taken 90s</span></pre><p id="efc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建一个包含文件列表的通道。我们创建了10个工人，所以并发数是10。我们并行启动所有10个工人，等待他们全部完成。</p><p id="c6dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相同数量的图像花费了<em class="ml">90秒</em>，比之前的方法花费的160秒快了<em class="ml"> ~43% </em>。</p><p id="e56c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以重构上面的代码，使整个过程通用化。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk"><a class="ae kl" href="https://gist.github.com/Deepak13245/865cc54dc2975834ab16c22296d724dc" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Deepak13245/865cc54dc2975834ab16c22296d724dc</a></figcaption></figure><p id="efef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">WorkerManager</code>类抽象了worker和channel的创建，使我们能够在启动worker后将作业排队，并以最佳的并发量运行。</p><p id="f4dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">constructor</code>接受三个参数。<br/> 1。并发性:在任何时刻可以存在的最大工作线程数。<br/> 2。fn:这与<em class="ml">工人</em>构造器参数相同。要应用于每个项目的函数。<br/> 3。数据:作业列表，这是可选的。因为我们甚至可以在启动管理器后添加作业。</p><p id="ed3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">length</code> : getter用于检索该时刻活动工作线程的数量。</p><p id="b76b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">results</code>:它是代理getter，用于通道检索结果。</p><p id="1ac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">_createWorker</code>:创建新<em class="ml">工作者</em>并附加onStop回调的Helper方法。</p><p id="1adf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">_createWorkers</code>:创建多个工人的助手。</p><p id="dd77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">_startWorkers</code>:助手启动给定的工作队列</p><p id="e1d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">_onStop</code>:用于在工作者停止时管理阵列中的工作者。<br/>它接受<code class="fe mh mi mj mk b">worker</code>对象作为参数。</p><p id="8098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">start</code>:启动管理器。它依次启动工人。</p><p id="3d9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">enqueue</code>:向频道添加新作业。</p><p id="6b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">finish</code>:与<code class="fe mh mi mj mk b">worker</code>的start方法不同，<code class="fe mh mi mj mk b">manager</code>的start方法不会返回一个等待完成的承诺。<br/>你需要等待<em class="ml">完成</em>方法来知道是否所有的工作都完成了。<br/>它接受一个参数<em class="ml">等待时间</em>。它持续轮询活动工作进程的长度<em class="ml">等待时间</em>毫秒数。一旦发现活动的工作线程为零，它就进行解析。</p><pre class="kn ko kp kq gt mm mk mn mo aw mp bi"><span id="775b" class="mq ld iq mk b gy mr ms l mt mu">// Rewriting the image optimization code with using manager class.</span><span id="cac0" class="mq ld iq mk b gy mv ms l mt mu">async function run() {<br/>  // List all images under images dir with ext png, jpg and jpeg<br/>  const files = globby('./images/**/*.{png,jpg,jpeg}');<br/>  <br/>  // Process with concurrency of 10<br/>  const processor = file =&gt; optimizeImage(file, file);<br/>  <br/>  // Create new manager<br/>  const manager = new WorkerManager(10, processor, files);<br/>  manager.start();</span><span id="994e" class="mq ld iq mk b gy mv ms l mt mu">  // Wait till all the jobs are executed<br/>  measure(manager.finish());<br/>}</span><span id="ab42" class="mq ld iq mk b gy mv ms l mt mu">// Output:  Time taken 90s</span></pre><p id="161a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">花费的时间没有变化。这只是代码重构的一个例子，以使工人通用和可重用。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="1477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong></p><p id="c9d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">)(我)(们)(都)(没)(想)(到)(这)(样)(,)(我)(们)(还)(没)(想)(到)(这)(样)(,)(我)(们)(就)(没)(想)(到)(这)(样)(了)(,)(我)(们)(就)(没)(想)(到)(这)(样)(。</p><p id="e715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如: WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB WEB</p></div></div>    
</body>
</html>