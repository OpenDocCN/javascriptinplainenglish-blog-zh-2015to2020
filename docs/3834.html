<html>
<head>
<title>Testing React Router with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest测试React路由器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-react-router-with-jest-bc13d367bad?source=collection_archive---------2-----------------------#2020-10-28">https://javascript.plainenglish.io/testing-react-router-with-jest-bc13d367bad?source=collection_archive---------2-----------------------#2020-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fe11" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何编写单元测试来检查您是否使用React Router with Jest正确地路由请求</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8d004544c9c183bf91ce9d963903aeb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z9gwSs7HtvuLS3MV"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jipy32?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jean-Philippe Delberghe</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3934" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编写一个单元测试来检查React Router是否被正确配置为在您的应用程序中路由请求，这看起来很简单。不可否认，这样做并不需要太多代码。但这并不意味着很容易弄清楚。我的在线搜索没有产生任何现成的代码示例，我花了几个小时试图为这个问题找到一个像样的解决方案。</p><p id="a1a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你正面临同样的挑战，以下是你需要注意的地方。请注意，该解决方案是为使用功能组件的React应用程序编写的。所以如果你正在使用类组件，你可能需要稍微调整一下。</p><p id="dd7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一部分将解释我得出的最终解决方案。后面的章节将关注潜在的问题，并提供一个更深入的解释，解释为什么我最终会以我的方式做事。</p><h1 id="d579" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">解决方案的想法</h1><p id="34c3" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">本文要测试的应用程序包含以下<code class="fe mm mn mo mp b">App.js</code>文件:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b7ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">应用程序的PageHeader组件针对每条路线进行渲染。<code class="fe mm mn mo mp b">HomePage</code>、<code class="fe mm mn mo mp b">ArticlePage</code>和<code class="fe mm mn mo mp b">AuthorPage</code>每个都有与该页面匹配的指定路线。如果路线不匹配，就会显示一个<code class="fe mm mn mo mp b">PageNotFound</code>组件。这是测试应该涵盖的预期行为。</p><p id="1c89" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如简介中提到的，所有列出的组件都是作为React中的功能组件实现的。</p><p id="2b2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将请求路由到所需组件的单元测试不应该测试或依赖于组件的内容。这是一个独立的行为，应该在每个单独组件的单元测试中进行测试。</p><p id="a824" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个解决方案背后的想法是通过模仿组件来避免对组件的依赖。为了查看是否呈现了正确的组件，我设置了模拟来返回硬编码的字符串，而不是它们的正常值。每个组件返回不同的硬编码字符串。然后，测试断言，在呈现某个路由的<code class="fe mm mn mo mp b">App</code>时，可以在呈现结果中找到属于适当组件的硬编码字符串。</p><p id="583f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于<code class="fe mm mn mo mp b">PageHeader</code>总是被渲染而不考虑路线，我决定在每个测试中检查它的存在。然而，创建一个单独的测试，只检查<code class="fe mm mn mo mp b">PageHeader</code>是否被渲染，并从其他测试中忽略它，在这种情况下也是一个有效的解决方案。</p><p id="518b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是如何实现这一点的逐步指南。</p><h1 id="b89e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">履行</h1><p id="1c6b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">首先，我们需要模拟路由器路由到的所有组件的模块。包含组件的模块需要导入，然后使用<code class="fe mm mn mo mp b">jest.mock</code>功能模拟。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b723" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，我们可以开始为具体的例子编写测试。第一个测试将检查在没有指定路线(意味着路线是<code class="fe mm mn mo mp b">“/”</code>)时<code class="fe mm mn mo mp b">HomePage</code>组件和<code class="fe mm mn mo mp b">PageHeader</code>是否被渲染。</p><p id="2195" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">安排这个测试的第一步是将<code class="fe mm mn mo mp b">HomePage</code>和<code class="fe mm mn mo mp b">PageHeader</code>的返回值模拟成硬编码的字符串值，以便我们以后搜索。注意不要对它们使用相同的值，因为这样会使测试无效。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8b43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，<code class="fe mm mn mo mp b">mockImplementation</code>调用是在测试中进行的，硬编码的字符串被包装在<code class="fe mm mn mo mp b">div</code>中。这两者都是解决方案正常工作所必需的，我将在后面的章节中解释原因。</p><p id="69ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦模拟完成，我们就可以调用<code class="fe mm mn mo mp b">render</code>函数。为了将路径传递给<code class="fe mm mn mo mp b">App</code>组件，我使用了一个<code class="fe mm mn mo mp b">MemoryRouter</code>。<code class="fe mm mn mo mp b">MemoryRouter</code>有一个名为<code class="fe mm mn mo mp b">initialEntries</code>的参数，它将一组初始路线作为输入。如果没有给定路径，<code class="fe mm mn mo mp b">App</code>应该呈现用于空路径的组件<code class="fe mm mn mo mp b">“/”</code>。</p><p id="4239" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，我们不需要向MemoryRouter传递任何东西，因为我们想要测试默认路由的行为。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4aa5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们通过断言在呈现的文档中有一个包含我们之前设置的字符串的元素，来检查是否呈现了正确的组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="80b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是测试<code class="fe mm mn mo mp b">App.js</code>中所有组件的完整代码。对于其他组件，<code class="fe mm mn mo mp b">MemoryRouter</code>的<code class="fe mm mn mo mp b">initialEntries</code>参数被填充了适当的路线。对于<code class="fe mm mn mo mp b">PageNotFound</code>组件，可以使用任何不属于另一个组件的路线。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="82ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你想了解创建这个解决方案的背景，你可以在这里查看应用程序的git库。</p><p id="2c29" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个解决方案的一个小缺点是，理论上，<code class="fe mm mn mo mp b">App.js</code>(或另一个组件)可以包含一个具有相同硬编码字符串的元素，该字符串被设置为mock的返回值。因此，测试将是无效的，因为它可以找到具有给定文本的元素，而不管组件模拟是否已经被呈现。所以你不应该从你的应用程序中选择一个现有的文本作为测试中的硬编码字符串。</p><h1 id="85a2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">为什么文本要用div包装？</h1><p id="cb39" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">它不一定是一个<code class="fe mm mn mo mp b">div</code>，但是mock返回的文本应该包装在一个单独的HTML元素中。元素不应该包含除文本以外的任何内容。</p><p id="bf37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mm mn mo mp b">screen.getByText</code>函数寻找一个HTML元素，它包含给定文本的精确匹配，并且不包含任何其他内容。(这种行为可以通过传递不同的选项来修改。更多细节见<a class="ae ks" href="https://testing-library.com/docs/dom-testing-library/api-queries" rel="noopener ugc nofollow" target="_blank">文档</a>。)</p><p id="b1c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我最初试图匹配精确的文本，但是没有将返回值包装在HTML元素中，如下所示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f101" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种方法的问题是<code class="fe mm mn mo mp b">PageHeader</code>和<code class="fe mm mn mo mp b">HomePage</code>在<code class="fe mm mn mo mp b">App.js</code>的同一个容器中呈现。这意味着redner的结果将看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cd87" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">容器元素现在包含了<code class="fe mm mn mo mp b">PageHeader</code> mock和<code class="fe mm mn mo mp b">HomePage</code> mock的文本。所以<code class="fe mm mn mo mp b">screen.getByText</code>不会认为这个容器是匹配的。</p><h1 id="9d50" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">为什么在每个测试中都要调用mockImplementation函数？</h1><p id="33a0" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果您查看上面测试的最终代码，您会注意到在每个测试中都调用了<code class="fe mm mn mo mp b">mockImplementation</code>函数来模拟返回值。这为<code class="fe mm mn mo mp b">PageHeader</code>模拟引入了相当多的冗余(和出错的空间)。它被设置为在每次测试中返回相同的值。</p><p id="df96" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为模拟创建一个全局定义不是更好吗？还是只在describe部分定义一次？</p><p id="f07e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我两者都尝试过，但没有成功。它产生一条错误消息，指出:<code class="fe mm mn mo mp b">Invalid variable access: _jsxFileName</code>。</p><p id="be42" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在撰写本文时，GitHub 上有一个针对此问题的<a class="ae ks" href="https://github.com/facebook/create-react-app/issues/9896" rel="noopener ugc nofollow" target="_blank">未决问题。</a></p><h1 id="e747" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">检查组件是否已呈现</h1><p id="cf5b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我最初的想法是直接测试渲染<code class="fe mm mn mo mp b">App</code>是否会为选定的路线渲染合适的组件。这是一个稍微好一点的解决方案，因为它避免了将硬编码的字符串作为返回值添加到模拟组件中，然后搜索它们。</p><p id="0207" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，我找不到一种方法来模拟React中的功能组件，然后检查模拟是否在测试中呈现。</p><p id="6398" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我在网上找到的测试这种功能的解决方案主要是使用酶。他们中的大多数人建议使用Enzyme的<code class="fe mm mn mo mp b">shallow</code>函数来渲染父组件(在本例中为<code class="fe mm mn mo mp b">App</code>)。然而，浅层对React路由器不起作用——深度渲染对测试这一点是必要的。</p><p id="26cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我发现了一篇关于如何使用Jest和Enzyme测试路由器的文章，这篇文章使用了Enzyme的<code class="fe mm mn mo mp b">mount</code>函数。该函数应该使您能够执行深度渲染，并检查是否渲染了正确的组件。</p><p id="b7bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你在开玩笑的时候使用酶，<a class="ae ks" href="https://medium.com/@antonybudianto/react-router-testing-with-jest-and-enzyme-17294fefd303" rel="noopener">这篇文章</a>可能是有用的读物。</p><p id="3950" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文的评论部分还包含一些有趣的潜在改进。但是，要注意文章是2017年写的。</p><h1 id="4393" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结束语</h1><p id="f783" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我希望这篇文章对你有所帮助。如果您有改进此解决方案的建议，请随时联系我。我可能会用潜在的改进或人们可能面临的问题来更新文章。</p><p id="390c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>