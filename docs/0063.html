<html>
<head>
<title>How to use Async Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用异步Await</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/async-await-javascript-5038668ec6eb?source=collection_archive---------0-----------------------#2019-01-10">https://javascript.plainenglish.io/async-await-javascript-5038668ec6eb?source=collection_archive---------0-----------------------#2019-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/78a3f99b17ba2a5473dc13b8822bd019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeSreLBdn5kB1rQtLnV6tg.jpeg"/></div></div></figure><h2 id="eb57" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">JavaScript有点像编程世界的无面人。</h2><p id="02b4" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">它可以是异步的。它可以是功能性的。可以是面向对象的。它可以是客户端的。可以是服务器端的。这样的例子不胜枚举。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/31946db9c3fc6b71b6fadb89ae39297d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*aPHYycN_A6OJnrQvggapiQ.jpeg"/></div></figure><p id="debb" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">本文将关注异步JavaScript。</p><h2 id="c5fa" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">但是等等，JavaScript是同步语言！</strong></h2><p id="1d2d" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">这意味着一次只能执行一个操作。但这并不是全部情况。JavaScript为我们提供了许多方法，让我们能够像异步语言一样工作。其中之一是Async-Await子句。</p><h2 id="4f58" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是<strong class="ak">异步等待</strong>？</h2><p id="f58d" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Async和Await是承诺的扩展。如果你不清楚承诺的概念，你可以参考我以前的帖子<a class="ae lw" href="https://medium.com/javascript-in-plain-english/truly-understanding-promises-in-javascript-cb31ee487860" rel="noopener">如何用JavaScript写承诺</a>。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/db9cf970bda35084d781b0b9607fe9d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*QJpDCVVeYhklYJ3uJGNRXQ.jpeg"/></div></figure><h1 id="544d" class="ly jw in bd jx lz ma mb ka mc md me kd mf mg mh kh mi mj mk kl ml mm mn kp mo bi translated">异步ˌ非同步(asynchronous)</h1><p id="17dc" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">异步函数使我们能够编写基于承诺的代码，就像它是同步的一样，但不会阻塞执行线程。它通过事件循环异步运行。异步函数总是会返回值。使用<code class="fe mp mq mr ms b">async</code>仅仅意味着一个承诺将被返回，如果一个<code class="fe mp mq mr ms b">promise </code>没有被返回，JavaScript自动将它和它的值包装在一个已解析的<code class="fe mp mq mr ms b">promise</code>中。</p><pre class="ln lo lp lq gt mt ms mu mv aw mw bi"><span id="5e3f" class="jv jw in ms b gy mx my l mz na">async function firstAsync() {<br/>  return 27;<br/>}<br/><br/>firstAsync().then(alert); // 27</span></pre><p id="2c85" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">运行上面的代码给出的警告输出为27，这意味着返回了一个<code class="fe mp mq mr ms b">promise</code>，否则<code class="fe mp mq mr ms b">.then()</code>方法根本不可能。</p><h1 id="78bc" class="ly jw in bd jx lz ma mb ka mc md me kd mf mg mh kh mi mj mk kl ml mm mn kp mo bi translated">等待</h1><p id="64f4" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">await操作符用于等待承诺。它只能在异步块中使用。关键字Await让JavaScript一直等到promise返回结果。必须注意的是，它仅使<code class="fe mp mq mr ms b">async</code>功能块等待，而不是整个程序执行。</p><p id="0689" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">下面的代码块展示了异步Await的用法。</p><pre class="ln lo lp lq gt mt ms mu mv aw mw bi"><span id="f903" class="jv jw in ms b gy mx my l mz na">async function firstAsync() {<br/>    <!-- -->let promise = new Promise((res, rej) =&gt; {<br/>        setTimeout(() =&gt; res("Now it's done!"), 1000)<br/>    });<br/><br/>    // wait until the promise returns us a value<br/>    let result = await promise; <br/>  <br/>    // "Now it's done!"<br/>    alert(result); <br/>    }<br/>};</span><span id="e884" class="jv jw in ms b gy nb my l mz na">firstAsync();</span></pre><h1 id="a01f" class="ly jw in bd jx lz ma mb ka mc md me kd mf mg mh kh mi mj mk kl ml mm mn kp mo bi translated">使用异步Await时要记住的事情</h1><h2 id="32be" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们不能在常规函数中使用<code class="fe mp mq mr ms b">await </code>关键字。</h2><pre class="ln lo lp lq gt mt ms mu mv aw mw bi"><span id="bea0" class="jv jw in ms b gy mx my l mz na">function firstAsync() {<br/>  let promise = Promise.resolve(10);<br/>  let result = await promise; // Syntax error<br/>}<br/></span></pre><p id="5bc5" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">为了让上面的函数正常工作，我们需要在函数<code class="fe mp mq mr ms b">firstAsync();</code>之前添加<code class="fe mp mq mr ms b">async </code></p><h2 id="4664" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">异步等待使执行顺序化</h2><p id="8e9a" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">这不一定是件坏事，但是并行执行要快得多。</p><p id="934f" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">例如:</p><pre class="ln lo lp lq gt mt ms mu mv aw mw bi"><span id="264d" class="jv jw in ms b gy mx my l mz na">async function sequence() {<br/>  await promise1(50); // Wait 50ms…<br/>  await promise2(50); // …then wait another 50ms.<br/>  return "done!";<br/>}</span></pre><p id="04f1" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">以上需要100毫秒才能完成，时间不多，但仍然很慢。</p><p id="9652" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">这是因为它是按顺序发生的。返回两个承诺，都需要50毫秒完成。第二个承诺仅在第一个承诺解决后执行。这不是一个好的做法，因为大型请求可能非常耗时。我们必须平行执行。</p><p id="76aa" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">这可以通过使用<code class="fe mp mq mr ms b">Promise.all() </code>来实现。</p><p id="bb50" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">根据MDN:</p><blockquote class="nc"><p id="1791" class="nd ne in bd nf ng nh ni nj nk nl ll dk translated">当作为iterable传递的所有承诺都已解析或iterable不包含承诺时，<code class="fe mp mq mr ms b"><strong class="ak">Promise.all()</strong></code>方法返回一个解析的<code class="fe mp mq mr ms b">Promise</code>。它用拒绝的第一个承诺的理由拒绝。</p></blockquote><h2 id="a4e8" class="jv jw in bd jx jy nm dn ka kb nn dp kd ke no kg kh ki np kk kl km nq ko kp kq bi translated">Promise.all()</h2><pre class="ln lo lp lq gt mt ms mu mv aw mw bi"><span id="c2a1" class="jv jw in ms b gy mx my l mz na">async function sequence() {<br/>    await Promise.all([promise1(), promise2()]);  <br/>    return "done!";<br/>}</span></pre><p id="fd27" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">当iterable中的所有承诺都被解析时,<code class="fe mp mq mr ms b">promise.all()</code>函数进行解析，然后返回结果。</p><p id="9bb4" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">另一种方法:</p><pre class="ln lo lp lq gt mt ms mu mv aw mw bi"><span id="5f00" class="jv jw in ms b gy mx my l mz na">async function parallel() {</span><span id="344d" class="jv jw in ms b gy nb my l mz na">    <em class="nr">// Start a 500ms timer asynchronously…</em><br/>    const wait1 = promise1(50); </span><span id="e0c4" class="jv jw in ms b gy nb my l mz na"><em class="nr">    // …meaning this timer happens in parallel.</em><br/>    const wait2 = promise2(50); <br/>  <br/><em class="nr">    // Wait 50ms for the first timer…</em><br/>    await wait1; <br/>    <br/><em class="nr">    // …by which time this timer has already finished.</em><br/>    await wait2; <br/>  <br/>    return "done!";</span><span id="1219" class="jv jw in ms b gy nb my l mz na">}</span></pre><p id="7117" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">Async Await非常强大，但是它们带有警告。但是如果我们正确地使用它们，它们有助于使我们的代码非常可读和高效。</p><p id="6167" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">希望你学到了新的东西！如果你觉得这篇文章有用，一定要分享，关注和支持！</p><p id="b86a" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated">如果你正在寻找<a class="ae lw" href="https://cwassignments.com/java-assignment-help.html" rel="noopener ugc nofollow" target="_blank"> Java作业帮助</a>，你来对地方了！我们经验丰富的程序员团队可以在异步编码任务、编程项目等方面提供帮助。</p><p id="47aa" class="pw-post-body-paragraph kr ks in kt b ku lr kw kx ky ls la lb ke lt ld le ki lu lg lh km lv lj lk ll ig bi translated"><em class="nr">更多内容看</em> <a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> <em class="nr">说白了就是io </em> </strong> </a> <em class="nr">。报名参加我们的</em> <a class="ae lw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> <em class="nr">免费周报</em> </strong> </a> <em class="nr">。关注我们关于</em> <a class="ae lw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> <em class="nr">推特</em> </strong> </a>，<a class="ae lw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> <em class="nr">领英</em></strong></a><strong class="kt io"><em class="nr"/></strong><em class="nr">和</em> <a class="ae lw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kt io"> <em class="nr">不和</em> </strong> </a> <strong class="kt io"> <em class="nr">。</em>T50】</strong></p><blockquote class="ns nt nu"><p id="57a4" class="kr ks nr kt b ku lr kw kx ky ls la lb nv lt ld le nw lu lg lh nx lv lj lk ll ig bi translated"><a class="ae lw" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fwww.linkedin.com%2Fpulse%2Fasync-await-javascript-ashay-mandwarya%2F%3Fpublished%3Dt" rel="noopener ugc nofollow" target="_blank">在LinkedIn上分享这篇文章！</a></p></blockquote></div></div>    
</body>
</html>