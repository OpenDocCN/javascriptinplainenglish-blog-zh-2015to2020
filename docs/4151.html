<html>
<head>
<title>Avoid Common JavaScript Hoisting Issues By Mastering Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过掌握变量来避免常见的JavaScript提升问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-es6-var-let-or-const-88da65f3a0df?source=collection_archive---------8-----------------------#2020-11-20">https://javascript.plainenglish.io/javascript-es6-var-let-or-const-88da65f3a0df?source=collection_archive---------8-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c358" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Var，Let，和Const进行深度检查！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/67cb4e594c476f2001fdb70d85729a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6AFUwjoKDrNRkdMVw810Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://pixabay.com/de/photos/kaffee-kaffeebohnen-pokal-171653/" rel="noopener ugc nofollow" target="_blank">s</a>ource: <a class="ae kv" href="https://pixabay.com/de/users/christoph-47781/" rel="noopener ugc nofollow" target="_blank">Christoph</a> by <a class="ae kv" href="https://pixabay.com/de/photos/kaffee-kaffeebohnen-pokal-171653/" rel="noopener ugc nofollow" target="_blank">pixabay</a> (CC0)</figcaption></figure><h1 id="71b0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">序文</h1><p id="ecb9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">变量的类型由它所保存的值来设置。这就是JavaScript中类型系统的动态本质的来源。例如，在C#中，我们得到了强类型变量，而它的行为正好相反。该类型被分配给变量。因此，C#知道一个已声明但未初始化的变量，而JavaScript必须返回一个未定义的变量作为通用答案，而不是null。</p><p id="696f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是这与const、let和var有什么共同之处呢？</p><h1 id="7c3a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">提升</h1><p id="754b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">要回答这个问题，我们应该研究一下在JavaScript中声明变量的方法。我们只有三个选择。</p><ol class=""><li id="17a7" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">定义变量</li><li id="9e29" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">让</li><li id="b955" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">常数</li></ol><p id="db67" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Var是它们的真正来源，因为let和const是ES2015附带的。Var是一个非常常见的关键字，即使在我们得到let和const的今天也是如此。不过，最好不要使用它。因为用var定义的变量就像C#中的局部变量一样。它只能在声明它的函数内部使用。</p><p id="ba04" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里有什么不同？我给你举了两个例子。第一个在方法中间声明变量，并立即初始化它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fb5e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第二个例子展示了声明和初始化变量的不同点，但在技术上是相同的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="df2f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个变量在被声明之前就存在并不直观，但是在JavaScript中，这是事实。这个变量可以在这个函数的开始使用，尽管它可以在函数体的最后一行声明。这里要提到的是，在执行初始化代码行之前，变量是未定义的。</p><p id="0596" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这种行为通常被称为“吊装”。可用性被提升到函数的入口点。有问题的一点是:JavaScript在后台进行这种提升，你在源代码中看不到这种效果。</p><p id="a6dc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个解决方法是在每个函数的开头收集所有的变量，就像你在C#中可能知道的那样，以便知道这个函数是关于什么的，它需要什么。一方面，源代码的可读性降低，而变量的范围更容易识别。</p><p id="1f77" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于循环，这种“提升”变得相关，导致错误，并照顾屏幕前好奇的面孔。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a72f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这段代码不会像您可能首先假设的那样，将两个项目“HealingPotion”和“Gold”打印到控制台。我们得到的是2倍的“未定义”。这就是证据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7173760005b0e7580867bd97f54ed146.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*3h4LyiQZMbzN6ibWR7alQQ.png"/></div></figure><p id="f297" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它是怎么来的？函数可以定义变量的作用域。一个块(也就是我们的for循环)不能定义作用域。只允许方法/函数这样做。运行索引“I”在整个“LootItems()”方法中只存在一次。不是块的每次迭代一次。由于setTimeout将暂停执行“I”乘以1000毫秒，因此在打印输出之前，运行索引“I”的值将为2。Items-Array只有2个元素，它们的索引是0和1。结果返回undefined。在C#中，我们现在会因为一个“IndexOutOfBounds”异常而有一个程序中断。</p><p id="ee4c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">闭包会有所帮助，您可以将循环的内容放在匿名函数中，并使用运行索引作为参数来调用它。这使得外部块的状态被保存到setTimeout的内部块中，即匿名函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ee184ad99fdf5f56e10650965cfeb0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*wvHDRwkMB1NqtYnnWf97Hw.png"/></div></figure><h1 id="839d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">let比var好</h1><p id="0937" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">从ES2015开始，我们就在为反对“让”而欢呼。它定义了新的规则，并不适用“吊装”。但是它也将块结构提升到了变量的作用域。</p><p id="28cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将“let”更改为“var”会导致下面这段简单的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7e03" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">记住“var”？声明可以在方法中的任何地方，但它可以在函数的顶部访问，尤其是在声明变量之前。只有这个变量的定义(赋值)在代码执行到那一行时才有效。对于“let ”,只有当执行程序到达最终初始化变量的那一行时，两者才有效。预先访问会导致“引用错误”。</p><p id="771f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">“var”的另一个奇怪行为是允许我们多次声明同一个变量。忽略每个声明，从第二个声明开始。尽管一个函数应该只有20行长，以保持<a class="ae kv" href="https://www.perforce.com/blog/qac/what-cyclomatic-complexity" rel="noopener ugc nofollow" target="_blank">圈复杂度</a>较低，并遵循<a class="ae kv" href="https://medium.com/unity-hub/unity-solid-s-single-responsibility-6707d9569e73" rel="noopener">固-S </a>原则。但是有些方法可能会出现很长时间，特别是对于遗留代码，您需要修复一个错误，用var声明一个临时变量。如果这已经存在，您将不会得到任何错误？去你的，JavaScript。</p><blockquote class="nh"><p id="9d06" class="ni nj iq bd nk nl nm nn no np nq mj dk translated">如果让这种情况不发生，就会导致“语法错误”。</p></blockquote><p id="6bc0" class="pw-post-body-paragraph lo lp iq lq b lr nr jr lt lu ns ju lw lx nt lz ma mb nu md me mf nv mh mi mj ij bi translated">这里继续For-Loops“let”也是不同的。我提到过，当你使用“let”时，块结构也可以定义作用域。此外，这将为每次迭代创建一个已定义变量的新实例。</p><p id="1685" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">改变我们的旧循环，打印出未定义的，我们现在得到一个工作函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8cdf1d8aa91bcd68b4de520c2529e6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*N4gRl8TatUq7-7gNZuyW8w.png"/></div></figure><p id="709d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这也适用于for-in和for-of循环。</p><p id="b057" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">需要知道的最重要的事实是，当您使用JavaScript“严格模式”时，“let”只作为保留的语言关键字出现。对于遗留代码，有机会将变量命名为“let ”,但在现代代码中，这已经不可能了。</p><p id="1830" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在所有其他物品中，let表现得像“var ”,而linters确实有“no-var”规则，这并不是为了好玩。它使代码稳定，因为没有奇怪的行为和错误，这需要很长时间，直到他们被调试。</p><h1 id="6740" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">但是const更好</h1><p id="5e50" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">“let”和“const”之间的区别是，使用“const”不能再进行重新分配，它们必须在同一行中声明和定义。此外，ES2015中引入了“const”。</p><p id="e496" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的部分是允许的，下面的部分会导致错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="02d2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一个代码语句对const来说是正确的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2fcf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在实际编码中，“const”应该是你的选择。对于棉短绒也有一个规则，它会告诉你“常量”是更好的选择，叫做“首选常量”。此外，对代码的分析可以让您意识到将变量重新分配给已经声明的变量。</p><h1 id="aa73" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">经验法则</h1><p id="5dba" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">经验法则，对于我们的const、let、var三剑客来说就是:更喜欢“CONST”，然后是“LET”，然后是“VAR”。按照这个顺序。</p><p id="6a88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">注意:“</strong> Const”并不意味着这个变量是常数，它只意味着分配给它的值，以后不能改变。但是当分配一个引用时，内容可以很容易地被改变。只有引用不能改。来自C#？那你就知道它和C#的“const”是一样的。</p><h1 id="0139" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="9225" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">“Var”是一个遗产，但主要被新来者使用，因为它似乎是最好的/第一选择，或者你很久以前就开始编写JavaScript了，当时甚至没有选择。然而，“var”很容易被误解为“variable”或“variant”的简称，我在2015年刚接触JavaScript时，甚至不知道自己在做什么就使用了这个词。</p><p id="7848" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">今天，不再使用它是不可取的。从您的工具集中禁止它，或者至少将它锁定在遗留代码中，在那里损害可能已经发生了。为了处理遗留代码，关于提升和“var”的知识是必须的。</p><p id="a5ad" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如今，如果配置得当，linters会让我们的生活变得更加轻松，即使配置不当，也可以慢慢使用“const”&gt;“let”&gt;“var”。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="8c74" class="kw kx iq bd ky kz od lb lc ld oe lf lg jw of jx li jz og ka lk kc oh kd lm ln bi translated">链接和参考</h1><h2 id="329c" class="oi kx iq bd ky oj ok dn lc ol om dp lg lx on oo li mb op oq lk mf or os lm ot bi translated">Gists</h2><p id="8666" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://gist.github.com/ArnoldATProJanitorDevs/b5edc1ad81f43e13d61cf7e54b2831aa#file-cx_0_declaringvar-js" rel="noopener ugc nofollow" target="_blank">CX _ 0 _ declaring var . js</a><br/>T3】CX _ 0 _ declaring var . js<br/><a class="ae kv" href="https://gist.github.com/ArnoldATProJanitorDevs/d428c7f27f89a4b587a67a30868cab84#file-cx_1_hoistingloop-js" rel="noopener ugc nofollow" target="_blank">CX _ 1 _ hoistingloop . js</a><br/><a class="ae kv" href="https://gist.github.com/ArnoldATProJanitorDevs/59ea94f24fafad7052756937deccc71e#file-cx_1_hoistingloop-js" rel="noopener ugc nofollow" target="_blank">CX _ 1 _ hoistingloop . js</a><br/>T12】CX _ 2 _ Let&amp;var . js<br/>T15】CX _ 3 _ Let loops . js<br/><a class="ae kv" href="https://gist.github.com/ArnoldATProJanitorDevs/c5a07e3e21d8cccd8aed3fefe0b6f837#file-cx_4_constvslet-js" rel="noopener ugc nofollow" target="_blank">CX _ 4 _ constvslet</a></p></div></div>    
</body>
</html>