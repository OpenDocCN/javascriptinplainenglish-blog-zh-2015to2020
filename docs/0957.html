<html>
<head>
<title>What is a Monorepo?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是单向回购？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/monorepo-what-is-it-really-ade13aede0cc?source=collection_archive---------8-----------------------#2020-01-06">https://javascript.plainenglish.io/monorepo-what-is-it-really-ade13aede0cc?source=collection_archive---------8-----------------------#2020-01-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f714193399b6ba0889eb72a619abfeff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQdIyxayeVFfdxnP5aFiRQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The photo was taken from Costiero Shipping</figcaption></figure><p id="26d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当一个项目开始时，我们在VSTS/Github/bitbucket中创建一个新的源代码库，并开始向其中添加所有的代码。每次我们添加新的模块/可重用组件时，我们都会创建另一个存储库并使用它。这被称为多方回购。这个过程将继续下去，直到我们最终创建许多存储库，因为我们每个包需要一个存储库。一段时间后，这变得不可收拾。</p><p id="62e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在继续之前，让我们尝试使用ExpressJs创建一个小应用程序。</p><p id="b935" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在新创建的文件夹中执行下面的命令。这将创建package.json文件。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4ec4" class="lg lh in lc b gy li lj l lk ll">npm init</span></pre><p id="7bd4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">新的应用程序包含两条路线，并且非常简单明了。我们把它命名为server.js吧。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="9e75" class="lg lh in lc b gy li lj l lk ll">const logger = require('./logger');<br/>const express = require('express');</span><span id="2a0a" class="lg lh in lc b gy lm lj l lk ll">const app = express();<br/>app.use(function (req, res, next) {<br/> logger.log(req.originalUrl, "Middleware");<br/> next()<br/>});<br/>app.get('/', (req, res) =&gt; {<br/> console.log("Hello work");<br/> res.send('Hello World!');<br/>});<br/>app.get('/info', (req, res) =&gt; {<br/> console.log("Info");<br/> res.send('This is info!');<br/>});<br/>app.listen(8080, function () {<br/> console.log("Server is running");<br/>});</span></pre><p id="59de" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后添加一个记录器来跟踪每个请求。下面是logger.js的内容。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6c37" class="lg lh in lc b gy li lj l lk ll">const fsPromises = require('fs').promises</span><span id="e37b" class="lg lh in lc b gy lm lj l lk ll">const log = async (value, context) =&gt; {<br/>    const valueToBeLogged = `${new Date()}---${context}---${value}\n`;<br/>    await fsPromises.appendFile("C://logger" + "//" + "track_data.log", valueToBeLogged);<br/>};</span><span id="4c4a" class="lg lh in lc b gy lm lj l lk ll">exports.log = log;</span></pre><p id="f470" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这将没有任何问题。整个代码可以驻留在一个存储库中。但是现在让我们假设logger需要与另一个ExpressJs项目共享。我们有两个选择</p><ul class=""><li id="2fc4" class="ln lo in kb b kc kd kg kh kk lp ko lq ks lr kw ls lt lu lv bi translated">将logger.js复制/粘贴到另一个项目中。</li><li id="9237" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw ls lt lu lv bi translated">将logger.js移动到单独的存储库中，并将其打包。</li></ul><p id="18d9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们显然选择了第二种。但是我们最终只为单个文件创建了一个新的存储库。但不是这样。我们需要复制整个代码质量规则，如ESlint，测试配置等。</p><p id="36e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是我们进行单一回购的时候。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="6706" class="mi lh in bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">什么是Monorepo？</h1><blockquote class="nf ng nh"><p id="c5a6" class="jz ka ni kb b kc kd ke kf kg kh ki kj nj kl km kn nk kp kq kr nl kt ku kv kw ig bi translated">在版本控制系统中，mono repo(monolithic repository的音节缩写)是一种软件开发策略，其中许多项目的代码存储在同一个库中。—维基百科</p></blockquote><p id="66bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">简而言之，把你所有的源代码放在一个库中。</p><p id="27e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">💡Monorepo并不强调单一的软件设计。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="aaee" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这并不是一个新概念，包括谷歌、脸书、微软、优步、Airbnb、Twitter在内的许多公司已经在效仿。</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/8f267040e1cdd416e82f8ec86d6e646c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zEEucs3vtQXDO66uZZAWQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Google repository statistics</figcaption></figure><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Why Google Stores Billions of Lines of Code in a Single Repository?</figcaption></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="3d9a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们探索一下google是如何在单一存储库中维护不同的angular包的。这种方法被称为多包单一回购。</p><p id="7e1a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用命令“ng new <app>”创建一个新的angular应用程序，并检查package.json文件。你可以看到像@angular/core、@angular/animations等包。</app></p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c3e7b699508984d4da222e954d46de75.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*vKlNI1-4WqcvjuROgew1SA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">From <a class="ae nq" href="https://github.com/angular/angular" rel="noopener ugc nofollow" target="_blank">https://github.com/angular/angular</a></figcaption></figure><p id="69f7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在查看angular<a class="ae nq" href="https://github.com/angular/angular" rel="noopener ugc nofollow" target="_blank">https://github.com/angular/angular</a>的源代码，并检查包文件夹。</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/161d5aecaba02342648c1d5db324846b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*n0fJvD5vlYmOmfuL6clh0g.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">From <a class="ae nq" href="https://github.com/angular/angular" rel="noopener ugc nofollow" target="_blank">https://github.com/angular/angular</a></figcaption></figure><p id="4437" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以为每个包找到单独的文件夹。另外，请查看主页。您可以发现配置文件就在主页中，这些文件对于所有的包都是通用的。</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/007108e3f531691bb0d1a1190df93942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*LSUMBrxlRwmR6Xz0v4nv_A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">From <a class="ae nq" href="https://github.com/angular/angular" rel="noopener ugc nofollow" target="_blank">https://github.com/angular/angular</a></figcaption></figure><p id="92ba" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里最好的事情是每个包可以单独发布为一个包或与同一文件夹中的其他包共享，而不用发布到NPM。</p><p id="ac65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是在Multirepo中，如果你想在这些包之间共享一些代码，你唯一能做的就是把代码发布到NPM并使用它。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="2c34" class="lg lh in bd mj nt nu dn mn nv nw dp mr kk nx ny mv ko nz oa mz ks ob oc nd od bi translated">使用Lerna管理Monorepo</h2><figure class="kx ky kz la gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/09329a4766d83b0aa9eee037a9e73257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v8-d1m9JREmkl-u-.png"/></div></div></figure><p id="8d76" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">将所有源代码保存在一个存储库中可能看起来更简单。但事实并非如此。我们应该能够有效地维护包和代码提交的版本。为此，我们可以使用一个名为Lerna的工具。</p><div class="of og gp gr oh oi"><a href="https://lerna.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">一个用多个包管理JavaScript项目的工具。</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">将大型代码库分割成单独的独立版本包对于代码共享非常有用…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">lerna.js.org</p></div></div></div></a></div><p id="3cfa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们使用Lerna尝试同一个logger应用程序示例。</p><p id="7db0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">lerna需要首先安装在您的机器上。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="afa4" class="lg lh in lc b gy li lj l lk ll">npm install --global lerna</span></pre><p id="fea5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦安装了lerna，使用Lerna初始化新文件夹中的新项目。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3557" class="lg lh in lc b gy li lj l lk ll">lerna init</span></pre><p id="5364" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你打开文件夹，你可以看到下面的文件。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="43ea" class="lg lh in lc b gy li lj l lk ll">packages/<br/>  package.json<br/>  lerna.json</span></pre><ul class=""><li id="1dd7" class="ln lo in kb b kc kd kg kh kk lp ko lq ks lr kw ls lt lu lv bi translated">导航到packages文件夹，创建名为app的文件夹，并添加server.js、package.json文件。</li><li id="1b05" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw ls lt lu lv bi translated">在packages文件夹中创建另一个名为logger的文件夹，并添加logger.js，然后运行npm init进行初始化。这将创建package.json。将package.json中的名称设置为“logger”，版本设置为“1.0.0”。</li></ul><p id="6a56" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">整个文件夹结构如下所示。</p><figure class="kx ky kz la gt jo gh gi paragraph-image"><div class="gh gi or"><img src="../Images/135b2cab0a83c6288a992f6d6545999f.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*lhZIHYgK8xUKhJqq3ctwmA.png"/></div></figure><ul class=""><li id="b3f8" class="ln lo in kb b kc kd kg kh kk lp ko lq ks lr kw ls lt lu lv bi translated">打开app文件夹内的package.json，并在dependencies部分添加logger。</li></ul><figure class="kx ky kz la gt jo gh gi paragraph-image"><div class="gh gi os"><img src="../Images/36460e0e6829d1467372ec0e29c4004a.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*ko2x1TLrASgoPHpcS7_Rsw.png"/></div></figure><ul class=""><li id="91dc" class="ln lo in kb b kc kd kg kh kk lp ko lq ks lr kw ls lt lu lv bi translated">执行以下代码来安装依赖项，并将日志记录器链接到应用程序。</li></ul><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b2a8" class="lg lh in lc b gy li lj l lk ll">lerna bootstrap</span></pre><p id="cd88" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">就是这样。现在，您可以通过导航到应用程序文件夹来运行应用程序。如果您检查应用程序文件夹的node_modules，您可以看到logger文件夹参考。</p><p id="e180" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你愿意，你甚至可以直接将日志发布到NPM，而不用转移到单独的存储库。</p><p id="c032" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完整的代码可以在<a class="ae nq" href="https://github.com/thangaraja/monorepo" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae nq" href="https://github.com/thangaraja/multirepo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="dcf3" class="lg lh in bd mj nt nu dn mn nv nw dp mr kk nx ny mv ko nz oa mz ks ob oc nd od bi translated">与不在当前存储库中的项目共享包</h2><p id="1f88" class="pw-post-body-paragraph jz ka in kb b kc ot ke kf kg ou ki kj kk ov km kn ko ow kq kr ks ox ku kv kw ig bi translated">使用Lerna的一个很酷的地方是它使得发布包变得非常容易。你可以使用NPM注册表，如果你想共享你的软件包公开，没有特殊的配置需要，或使用自己的注册表，如果你想保持软件包的私人。只需运行下面的命令来启动包发布过程。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5892" class="lg lh in lc b gy li lj l lk ll">lerna publish</span></pre><p id="2bbd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该命令将执行以下操作</p><ol class=""><li id="af96" class="ln lo in kb b kc kd kg kh kk lp ko lq ks lr kw oy lt lu lv bi translated">提交代码</li><li id="a4b8" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw oy lt lu lv bi translated">更改package.json文件中的版本</li><li id="7917" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw oy lt lu lv bi translated">在存储库中创建一个标记。</li><li id="a40b" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw oy lt lu lv bi translated">将包发布到npm注册表。</li><li id="05f9" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw oy lt lu lv bi translated">将代码推送到存储库。</li></ol></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="0d28" class="lg lh in bd mj nt nu dn mn nv nw dp mr kk nx ny mv ko nz oa mz ks ob oc nd od bi translated">单一回购的优点</h2><ul class=""><li id="6488" class="ln lo in kb b kc ot kg ou kk oz ko pa ks pb kw ls lt lu lv bi translated">维护项目之间的依赖关系很容易。代码可以重用，无需发布到NPM。</li><li id="cd8f" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw ls lt lu lv bi translated">为多个项目应用相同的编码/格式很容易。</li><li id="e74f" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw ls lt lu lv bi translated">让代码共享变得简单。您可以创建一个用户并将其分配给一个存储库。</li></ul><h2 id="83c2" class="lg lh in bd mj nt nu dn mn nv nw dp mr kk nx ny mv ko nz oa mz ks ob oc nd od bi translated">Monorepo的缺点</h2><ul class=""><li id="ba90" class="ln lo in kb b kc ot kg ou kk oz ko pa ks pb kw ls lt lu lv bi translated">当源代码很大时，从存储库中提取代码可能需要时间。</li><li id="a9ee" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw ls lt lu lv bi translated">将项目加载到IDE或源代码编辑器可能需要一些时间。</li><li id="24e7" class="ln lo in kb b kc lw kg lx kk ly ko lz ks ma kw ls lt lu lv bi translated">同一个代码库被多个开发者共享，这使得所有权变得非常困难。</li></ul><p id="b47a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">如果你喜欢这篇文章，你可以看看我的另一篇文章。</strong></p><div class="of og gp gr oh oi"><a href="https://medium.com/only-javascript/how-javascript-conquered-the-web-1-6462e5f3d2c0" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">JavaScript是如何征服网络的？第一部分</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">“幸运胜于聪明”——道格拉斯·克洛克福特谈JavaScript</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph jt oi"/></div></div></a></div></div></div>    
</body>
</html>