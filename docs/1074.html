<html>
<head>
<title>What are these strict compiler options in TypeScript: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:第2部分中这些严格的编译器选项是什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-these-strict-compiler-options-in-typescript-part-2-a7e974b13e54?source=collection_archive---------6-----------------------#2020-01-25">https://javascript.plainenglish.io/what-are-these-strict-compiler-options-in-typescript-part-2-a7e974b13e54?source=collection_archive---------6-----------------------#2020-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4460282c1b3ba14deb2df3785f98228f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx5p_Ob5QOXJZoMUPB8eAw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Type system in TypeScript</figcaption></figure><blockquote class="jz ka kb"><p id="1983" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">那是<a class="ae lb" href="https://medium.com/javascript-in-plain-english/what-are-typescript-strict-compiler-options-part-1-5822c67c1df5" rel="noopener">上一篇</a>的第二部分。在这里，我将介绍TypeScript编译器的所有其他严格选项，尽可能保持文章的简单易懂，而不会涉及太多细节。</p></blockquote></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="c92f" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">- -严格函数类型</h1><p id="edd5" class="pw-post-body-paragraph kc kd in kf b kg mh ki kj kk mi km kn mj mk kq kr ml mm ku kv mn mo ky kz la ig bi translated">这个选项修复了在我看来是TypeScript编译器中的一个错误。如果这不是一个错误，那么这只是一个糟糕的设计决策，一个新的编译器选项的出现证明了我的观点。让我们从一个例子开始，默认情况下，下一个代码将被编译，没有任何问题:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="02a8" class="my lk in mu b gy mz na l nb nc"><em class="ke">// Focus all your attention on callback signature<br/>// It has </em>date parameter which is <em class="ke">a union type</em></span><span id="380f" class="my lk in mu b gy nd na l nb nc"><strong class="mu io">function </strong>getCurrentYear(callback: (date: <strong class="mu io">string | number</strong>) =&gt; <strong class="mu io">void</strong>) {<br/>   callback((Math.random() &gt; 0.5) ? '2020' : 2020);<br/>}</span><span id="76ef" class="my lk in mu b gy nd na l nb nc"><em class="ke">// note that we ignored the fact that in 50% cases our callback returns </em><strong class="mu io"><em class="ke">string</em></strong><em class="ke"> type instead of </em><strong class="mu io"><em class="ke">number</em></strong><em class="ke">.</em></span><span id="36c2" class="my lk in mu b gy nd na l nb nc">getCurrentYear((date: <strong class="mu io">string</strong>) =&gt; {<br/>    console.log(date.charAt(0)); <em class="ke">// in 50% it is </em><strong class="mu io"><em class="ke">RUNTIME ERROR</em></strong><br/>});</span></pre><p id="0c78" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mj kp kq kr ml kt ku kv mn kx ky kz la ig bi translated">所以传递给<em class="ke"> getCurrentYear </em>的arrow函数缩小了“date”参数的类型，而TypeScript并不关心它。然而，同样的技巧在不同的上下文中使用变量时，即使没有任何严格的规则也会产生错误:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2c03" class="my lk in mu b gy mz na l nb nc"><strong class="mu io">let </strong>x: <strong class="mu io">string </strong>| <strong class="mu io">number </strong>= (Math.random() &gt; 0.5) ? '2020' : 2020;<br/><strong class="mu io">const </strong>y: <strong class="mu io">number</strong> = x; <em class="ke">// </em><strong class="mu io"><em class="ke">COMPILE TIME ERROR</em></strong></span></pre><p id="e76f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mj kp kq kr ml kt ku kv mn kx ky kz la ig bi translated">这更有意义，启用<code class="fe ne nf ng mu b">--strictFunctionTypes</code>将要求编译器在回调函数中遵循相同的行为。这肯定会帮助你防止大项目中的一些错误。</p><h1 id="388f" class="lj lk in bd ll lm nh lo lp lq ni ls lt lu nj lw lx ly nk ma mb mc nl me mf mg bi translated">--严格的NullChecks</h1><p id="3f98" class="pw-post-body-paragraph kc kd in kf b kg mh ki kj kk mi km kn mj mk kq kr ml mm ku kv mn mo ky kz la ig bi translated">每一个有意识写代码的开发者都会遇到这样的情况，他不确定自己得到的值是否可以<strong class="kf io"> null </strong>，是否需要写处理它的代码。结果，如果你相当偏执，你最终会对空的<strong class="kf io">或未定义的<strong class="kf io">进行大量不必要的检查。</strong>另一方面，一些不关心这种小事的马虎程序员可能会创建一个运行时错误。启用<code class="fe ne nf ng mu b">--strictNullChecks</code>标志将使推理不熟悉的函数变得更容易，并将帮助每种开发人员在他们的代码库中适当地处理<strong class="kf io"> null </strong>和<strong class="kf io"> undefined </strong>。</strong></p><p id="5aa4" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mj kp kq kr ml kt ku kv mn kx ky kz la ig bi translated">为了举例，让我们假设下一个代码编译时没有这个标志:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="81bf" class="my lk in mu b gy mz na l nb nc">// some unfamiliar function from 3rd party module<br/><strong class="mu io">function </strong>getUserId(isLogged: <strong class="mu io">boolean</strong>): <strong class="mu io">number</strong> {<br/>    <strong class="mu io">return </strong>isLogged ? 100 : null;<br/>}</span><span id="8d6c" class="my lk in mu b gy nd na l nb nc">// somewhere in your code<br/><strong class="mu io">const</strong> id: <strong class="mu io">number </strong>= getUserId(<strong class="mu io">false</strong>);</span><span id="da82" class="my lk in mu b gy nd na l nb nc">id.toString(); <strong class="mu io"><em class="ke">// RUNTIME ERROR</em></strong><em class="ke"> since id is null..</em></span></pre><p id="75c2" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mj kp kq kr ml kt ku kv mn kx ky kz la ig bi translated">我们没有注意到在这种情况下id可以为空，也没有做任何检查。但是如果我们用<code class="fe ne nf ng mu b">--strictNullChecks </code>标志编译，我们会在编译过程中得到下一个编译错误:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a40b" class="my lk in mu b gy mz na l nb nc"><strong class="mu io">ERROR</strong>: Type <strong class="mu io">'100 | null'</strong> is not assignable to type <strong class="mu io">'number'</strong>.<br/>  Type <strong class="mu io">'null'</strong> is not assignable to type <strong class="mu io">'number'</strong>.</span></pre><p id="1a09" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mj kp kq kr ml kt ku kv mn kx ky kz la ig bi translated">因此，如果我们，事实上，想从函数中返回空值<strong class="kf io"/>,那么我们需要像这样改变我们的类型注释:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="efc2" class="my lk in mu b gy mz na l nb nc"><strong class="mu io">function </strong>getUserId(isLogged: <strong class="mu io">boolean</strong>): <strong class="mu io">number | null</strong> {<br/>    <strong class="mu io">return </strong>isLogged ? 100 : null;<br/>}</span><span id="1116" class="my lk in mu b gy nd na l nb nc"><strong class="mu io">const</strong> id: <strong class="mu io">number | null </strong>= getUserId(<strong class="mu io">false</strong>);</span><span id="4cf6" class="my lk in mu b gy nd na l nb nc">id.toString(); <strong class="mu io"><em class="ke">// COMPILE TIME </em></strong><em class="ke">error since id can be null..</em></span></pre><h1 id="cd1b" class="lj lk in bd ll lm nh lo lp lq ni ls lt lu nj lw lx ly nk ma mb mc nl me mf mg bi translated">- -strictPropertyInitialization</h1><p id="a92f" class="pw-post-body-paragraph kc kd in kf b kg mh ki kj kk mi km kn mj mk kq kr ml mm ku kv mn mo ky kz la ig bi translated">该标志是前一个标志(<code class="fe ne nf ng mu b">--strictNullChecks</code>)的扩展，您必须启用这两个标志才能使其工作。它将相同的约束应用于类属性类型定义。如果我们在没有这条规则的情况下编译下一个例子，即使前面的标志(<code class="fe ne nf ng mu b">--strictNullChecks</code>)已经被启用，一切都会好的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8f8e" class="my lk in mu b gy mz na l nb nc"><strong class="mu io">class </strong>User {<br/>   name: <strong class="mu io">string</strong>;</span><span id="6497" class="my lk in mu b gy nd na l nb nc">setName(name: <strong class="mu io">string</strong>) {<br/>      this.name = name;<br/>   }<br/>}</span><span id="1209" class="my lk in mu b gy nd na l nb nc"><strong class="mu io">const </strong>user = new User();<br/>user.setName('John');</span></pre><p id="ab33" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mj kp kq kr ml kt ku kv mn kx ky kz la ig bi translated">但是如果我们启用了<code class="fe ne nf ng mu b">--strictPropertyInitialization</code>,那么我们的代码将不会编译并产生下一个错误:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2e9c" class="my lk in mu b gy mz na l nb nc"><strong class="mu io">ERROR: Property 'name' has no initializer and is not definitely assigned in the constructor.</strong></span></pre><p id="cbe3" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mj kp kq kr ml kt ku kv mn kx ky kz la ig bi translated">其思想是，如果我们确实期望一个名字是<strong class="kf io">未定义的</strong>，在我们构造我们的对象之后，我们需要将<em class="ke">名字</em>字段类型定义为“<strong class="kf io">字符串|未定义”</strong>如果一个<strong class="kf io">未定义的</strong> <em class="ke">名字</em>是一个错误，那么你必须确保它有一些默认的非空值被分配或者在对象构造期间被初始化。所以这是可行的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="fe23" class="my lk in mu b gy mz na l nb nc"><strong class="mu io">class </strong>User {<br/>   name: <strong class="mu io">string = ""</strong>;</span><span id="76ec" class="my lk in mu b gy nd na l nb nc">setName(name: <strong class="mu io">string</strong>) {<br/>      this.name = name;<br/>   }<br/>}</span></pre><h1 id="c26a" class="lj lk in bd ll lm nh lo lp lq ni ls lt lu nj lw lx ly nk ma mb mc nl me mf mg bi translated">——永远严格</h1><p id="a05e" class="pw-post-body-paragraph kc kd in kf b kg mh ki kj kk mi km kn mj mk kq kr ml mm ku kv mn mo ky kz la ig bi translated">这个选择是最简单的。您的代码将在ECMAScript 5严格模式下解析，并且<code class="fe ne nf ng mu b">"use strict" </code>指令将被添加到每个输出模块的顶部。真的，这里没什么好解释的。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="bfcd" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="f0db" class="pw-post-body-paragraph kc kd in kf b kg mh ki kj kk mi km kn mj mk kq kr ml mm ku kv mn mo ky kz la ig bi translated">我希望现在您已经清楚地理解了严格模式的所有优点，并且只要有可能，就会使用它来编译您的下一个TypeScript项目。</p></div></div>    
</body>
</html>