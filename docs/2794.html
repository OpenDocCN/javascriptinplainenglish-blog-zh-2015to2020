<html>
<head>
<title>TypeScript Best Practices — Function and Array Types, Reducing Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript最佳实践—函数和数组类型，降低复杂性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-best-practices-function-and-array-types-reducing-complexity-a5c42ee226c?source=collection_archive---------6-----------------------#2020-07-24">https://javascript.plainenglish.io/typescript-best-practices-function-and-array-types-reducing-complexity-a5c42ee226c?source=collection_archive---------6-----------------------#2020-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/86e440ba0d7860a42694d0baba1834d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7TkaMaZG60vN6TTe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jcotten?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua J. Cotten</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="892d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="6439" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用isNaN检查NaN</h1><p id="a1bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">NaN</code>不等于它本身，所以我们不能用<code class="fe me mf mg mh b">===</code>或<code class="fe me mf mg mh b">!==</code>来检查<code class="fe me mf mg mh b">NaN</code>。</p><p id="987e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们使用<code class="fe me mf mg mh b">isNaN</code>函数来检查它。</p><p id="ce5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9e6f" class="mq lc iq mh b gy mr ms l mt mu">if (foo === NaN) {}</span></pre><p id="088b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0024" class="mq lc iq mh b gy mr ms l mt mu">if (isNaN(foo)) {}</span></pre><h1 id="1478" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">void的无效使用</h1><p id="fd40" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该注意<code class="fe me mf mg mh b">void</code>的无效使用。</p><p id="bf14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该把<code class="fe me mf mg mh b">void</code>和其他类型混在一起，因为<code class="fe me mf mg mh b">void</code>除了是一个显式类型的值之外什么都不是。</p><p id="7590" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要<code class="fe me mf mg mh b">undefined</code>，那么我们应该使用<code class="fe me mf mg mh b">undefined</code>型。</p><p id="641a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以输入像这样的表达式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="96ef" class="mq lc iq mh b gy mr ms l mt mu">Foo | void</span></pre><p id="1d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应替换为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4507" class="mq lc iq mh b gy mr ms l mt mu">Foo | undefined</span></pre><h1 id="be34" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">每个文件的最大类别数</h1><p id="5ede" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每个文件不应该有太多的类。</p><p id="a7eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们做的话，可能太复杂了。</p><p id="569a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用linter设置每个文件的最大类数。</p><h1 id="1c78" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最大文件行数</h1><p id="f5b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果一个文件有太多的行，那么它可能太复杂和难以阅读。</p><p id="20bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用linter设置文件中的最大文件行数。</p><h1 id="ff16" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">默认导出</h1><p id="a9f0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">默认导出并不清楚，所以我们应该避免使用它们。</p><p id="1054" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命名出口更清晰。</p><p id="28ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可能想避开它们。</p><h1 id="3b0f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">默认导入</h1><p id="5411" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像默认导出一样，默认导入不像命名导入那样清晰。</p><h1 id="2d45" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有重复的导入</h1><p id="ff78" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将来自同一个模块的多个import语句合并成一个<code class="fe me mf mg mh b">import</code>语句，所以我们应该这样做。</p><p id="ee64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ccfc" class="mq lc iq mh b gy mr ms l mt mu">import { foo } from 'module';<br/>import { bar } from 'module';</span></pre><p id="50db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dda0" class="mq lc iq mh b gy mr ms l mt mu">import { foo, bar } from 'module';</span></pre><h1 id="7b2a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有可合并的名称空间</h1><p id="3dca" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有两个同名的名称空间，这样我们就不必考虑如何将它们合并在一起。</p><p id="b9c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以用不同的名字命名不同的名称空间。</p><p id="3003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9b5f" class="mq lc iq mh b gy mr ms l mt mu">namespace Animals {<br/>  export class Dog {}<br/>}</span><span id="5487" class="mq lc iq mh b gy mv ms l mt mu">namespace Animals {<br/>  export interface Cat {<br/>    numberOfLegs: number;<br/>  }<br/>  export class Zebra {}<br/>}</span></pre><p id="c842" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="abf7" class="mq lc iq mh b gy mr ms l mt mu">namespace Pets {<br/>  export class Dog {}<br/>  export interface Cat {<br/>    numberOfLegs: number;<br/>  }<br/>}</span><span id="8aca" class="mq lc iq mh b gy mv ms l mt mu">name WildAnimals {<br/>  export class Zebra {}<br/>}</span></pre><h1 id="6d8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不需要进口</h1><p id="f20f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在ES模块已经广泛可用，我们可以用<code class="fe me mf mg mh b">import</code>代替<code class="fe me mf mg mh b">require</code>。</p><p id="3798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1f10" class="mq lc iq mh b gy mr ms l mt mu">const { bar } = require('foo');</span></pre><p id="dfb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用ES6模块版本的模块并编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c9a4" class="mq lc iq mh b gy mr ms l mt mu">import { bar } from 'foo';</span></pre><h1 id="7819" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用常量</h1><p id="2b1c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该尽可能使用<code class="fe me mf mg mh b">const</code>而不是<code class="fe me mf mg mh b">let</code>或<code class="fe me mf mg mh b">var</code>来声明变量。</p><p id="be03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，它们就不会意外地被赋予另一个值。</p><p id="1b89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3da2" class="mq lc iq mh b gy mr ms l mt mu">var x = 1;<br/>let y = 2;</span></pre><p id="673f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8b98" class="mq lc iq mh b gy mr ms l mt mu">const z = 3;</span></pre><h1 id="9a99" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将变量标记为只读</h1><p id="915b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果变量是私有的并且从未在构造函数之外被修改过，我们应该将它们标记为<code class="fe me mf mg mh b">readonly</code>。</p><p id="354f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不会不小心改变它们。</p><p id="d05d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f08f" class="mq lc iq mh b gy mr ms l mt mu">class Foo {<br/>  private bar = 1;<br/>}</span></pre><p id="a626" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a8fe" class="mq lc iq mh b gy mr ms l mt mu">class Foo {<br/>  private readonly bar = 1;<br/>}</span></pre><h1 id="0b98" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箭头返回速记</h1><p id="1383" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个箭头函数，它只有一个语句并返回一些东西，我们可以把它们变得更短。</p><p id="f991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fa96" class="mq lc iq mh b gy mr ms l mt mu">() =&gt; { return x; }</span></pre><p id="90ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2be0" class="mq lc iq mh b gy mr ms l mt mu">() =&gt; x</span></pre><h1 id="a2bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置数组类型</h1><p id="ce2e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该设置数组内容的类型，这样我们就可以限制进入数组的值的类型。</p><p id="5920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以设置泛型类型来使数组通用。</p><p id="ee62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cee2" class="mq lc iq mh b gy mr ms l mt mu">const arr = ['foo', 'bar', 1];</span></pre><p id="d0c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ea0c" class="mq lc iq mh b gy mr ms l mt mu">const arr: string[] = ['foo', 'bar', 'baz'];</span></pre><h1 id="9db3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可调用类型</h1><p id="146b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个只有调用签名的接口或文字类型，那么我们应该把它写成函数类型。</p><p id="973d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5200" class="mq lc iq mh b gy mr ms l mt mu">interface SearchFunc {<br/>  (source: string, subString: string): boolean;<br/>}</span></pre><p id="0faa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="029f" class="mq lc iq mh b gy mr ms l mt mu">(source: string, subString: string) =&gt; boolean</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/57f498fa71e5cae7eab8be4114a32f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fipDDSWnnW_vHlWR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jrduncan11?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">John Duncan</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6ee9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c520" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用函数类型，而不是只有函数签名的接口或文字类型。</p><p id="86a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组应该有一个类型，所以我们不能把任何类型的数据放进去。</p><p id="57ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该降低每个文件的复杂性。</p><p id="27f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">isNaN</code>应该用于检查<code class="fe me mf mg mh b">NaN</code>。</p></div></div>    
</body>
</html>