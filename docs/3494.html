<html>
<head>
<title>Implementing Context API in a React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用程序中实现上下文API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-context-api-in-a-react-application-8b9b156a4154?source=collection_archive---------2-----------------------#2020-10-04">https://javascript.plainenglish.io/implementing-context-api-in-a-react-application-8b9b156a4154?source=collection_archive---------2-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b5f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">全局状态管理解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e0d94ac6ba8f187ac4d5242c00cbb961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/0*QLAEhdGs5DzxlN1C"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Image from <a class="ae kr" href="https://www.freecodecamp.org/news/clever-react-context-tricks-using-typescript-not-redux-7e2b9c7e5bf6/" rel="noopener ugc nofollow" target="_blank">freecodecamp</a></figcaption></figure></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="1d06" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果您有使用React的经验，那么您应该熟悉在<code class="fe lv lw lx ly b">state</code>中存储数据的想法。每个组件都可以有自己的状态，但理想情况下，顶级组件将包含主要数据。随着应用程序的复杂性和组件的增加，将数据作为道具传递会变得棘手和乏味，因为数据必须找到返回到顶层组件并返回到子组件的路径。</p><p id="3fa3" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">已经有几种解决方案可以帮助管理和维护React中的<code class="fe lv lw lx ly b">state</code>。其中之一是流行的Redux库，它也可以与其他框架一起使用。另一个是Context API，React内置的状态管理。</p><p id="9ee4" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">本指南将介绍如何在React应用程序中实现上下文API。请参考<a class="ae kr" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>以获得关于上下文API的更深入的信息。如果你也想知道如何使用钩子实现Redux，这里是我的博客<a class="ae kr" href="https://levelup.gitconnected.com/react-redux-hooks-useselector-and-usedispatch-f7d8c7f75cdd" rel="noopener ugc nofollow" target="_blank">关于它的设置。</a></p><h1 id="d8ee" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置</h1><p id="e325" class="pw-post-body-paragraph kz la iq lb b lc mr jr le lf ms ju lh li mt lk ll lm mu lo lp lq mv ls lt lu ij bi translated">如前所述，上下文API包含在React中。一旦我们用<code class="fe lv lw lx ly b">create-react-app</code>创建了一个React应用程序，我们就可以导入并使用它。但在此之前，我们先创建一个<code class="fe lv lw lx ly b">reducer</code>。</p><h2 id="e994" class="mw ma iq bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">还原剂</h2><p id="b87c" class="pw-post-body-paragraph kz la iq lb b lc mr jr le lf ms ju lh li mt lk ll lm mu lo lp lq mv ls lt lu ij bi translated"><code class="fe lv lw lx ly b">reducer</code>将指定应用程序如何变化，并负责管理<code class="fe lv lw lx ly b">state</code>。它们也被称为<code class="fe lv lw lx ly b">pure functions</code>，其中输出仅由输入决定。在<code class="fe lv lw lx ly b">src</code>目录下，创建一个<code class="fe lv lw lx ly b">reducer.js</code>文件。在这个文件中，我们将输入以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">reducer.js</figcaption></figure><p id="9a3b" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在这个例子中，我们用默认值定义了应用程序的<code class="fe lv lw lx ly b">initialState</code>。我们还定义了我们的<code class="fe lv lw lx ly b">reducer</code>函数，它将接受两个参数，即<code class="fe lv lw lx ly b">state</code>和<code class="fe lv lw lx ly b">action</code>。一个<code class="fe lv lw lx ly b">action</code>是至少包含一个键、<code class="fe lv lw lx ly b">type</code>和其他可选键的对象。</p><pre class="kg kh ki kj gt nk ly nl nm aw nn bi"><span id="5737" class="mw ma iq ly b gy no np l nq nr">Ex. </span><span id="4081" class="mw ma iq ly b gy ns np l nq nr">{<br/>   type: "SET_VIEW",</span><span id="8103" class="mw ma iq ly b gy ns np l nq nr">   view: "Profile"<br/>}</span></pre><p id="baaa" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe lv lw lx ly b">reducer</code>函数将总是返回<code class="fe lv lw lx ly b">state</code>，无论是原始版本还是更改后的版本。一个<code class="fe lv lw lx ly b">switch</code>语句被用来确定<code class="fe lv lw lx ly b">state</code>将如何基于<code class="fe lv lw lx ly b">action</code>类型而改变。我们将在另一个文件中使用<code class="fe lv lw lx ly b">initialState</code>和<code class="fe lv lw lx ly b">reducer</code>，所以请务必使用<code class="fe lv lw lx ly b">export</code>。一个是<code class="fe lv lw lx ly b">default</code>输出，另一个可以是<code class="fe lv lw lx ly b">named</code>输出。我们有了<code class="fe lv lw lx ly b">reducer.js</code>文件设置，我们可以继续进行<code class="fe lv lw lx ly b">Context API</code>的设置。</p><h2 id="8b1c" class="mw ma iq bd mb mx my dn mf mz na dp mj li nb nc ml lm nd ne mn lq nf ng mp nh bi translated">上下文API</h2><p id="ab8f" class="pw-post-body-paragraph kz la iq lb b lc mr jr le lf ms ju lh li mt lk ll lm mu lo lp lq mv ls lt lu ij bi translated">仍然在<code class="fe lv lw lx ly b">src</code>目录下，让我们创建另一个文件<code class="fe lv lw lx ly b">GlobalState.js</code>。这是我们创建<code class="fe lv lw lx ly b">context</code>的地方。让我们输入以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">GlobalState.js</figcaption></figure><p id="ded4" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们分析一下这个文件中发生了什么。首先，我们从React、<code class="fe lv lw lx ly b">createContext</code>、<code class="fe lv lw lx ly b">useContext</code>和<code class="fe lv lw lx ly b">useReducer</code>导入一些<code class="fe lv lw lx ly b">named</code>导出。接下来，我们用<code class="fe lv lw lx ly b">createContext</code>创建上下文。快速注意，<code class="fe lv lw lx ly b">createContext</code>是一个不需要接受参数的函数，它返回一个上下文对象。</p><p id="6e48" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">然后我们有组件，<code class="fe lv lw lx ly b">Provider</code>，它将接受三个参数，<code class="fe lv lw lx ly b">reducer</code>、<code class="fe lv lw lx ly b">initialState,</code>和<code class="fe lv lw lx ly b">children</code>。<code class="fe lv lw lx ly b">reducer</code>和<code class="fe lv lw lx ly b">initialState</code>实际上是我们之前在<code class="fe lv lw lx ly b">reducer.js</code>文件中创建的。<code class="fe lv lw lx ly b">children</code>参数实际上代表子组件。我们最终要做的是<code class="fe lv lw lx ly b">import</code>和<code class="fe lv lw lx ly b">Provider</code>并插入我们想要作为子组件访问上下文的组件。我们稍后将再次讨论这种方法。</p><p id="dee5" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">每个上下文对象都有一个<code class="fe lv lw lx ly b">Provider React</code>组件，允许组件订阅上下文变化。澄清一下，这是我们创建的<code class="fe lv lw lx ly b">StateContext</code>中的<code class="fe lv lw lx ly b">Provider</code>，而不是我们此刻正在创建的<code class="fe lv lw lx ly b">Provider</code>。在<code class="fe lv lw lx ly b">Provider</code>组件中，我们正在创建内部组件<code class="fe lv lw lx ly b">StateContext.Provider</code>并插入<code class="fe lv lw lx ly b">children</code>组件。</p><p id="5e5b" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe lv lw lx ly b">StateContext.Provider</code>接受传递给其<code class="fe lv lw lx ly b">children</code>组件的<code class="fe lv lw lx ly b">value</code>道具。在这种情况下，我们希望<code class="fe lv lw lx ly b">children</code>能够访问全局<code class="fe lv lw lx ly b">state</code>，并且我们希望它们能够<code class="fe lv lw lx ly b">dispatch</code>一个动作。这就是<code class="fe lv lw lx ly b">useReducer</code>功能发挥作用的地方。当调用<code class="fe lv lw lx ly b">useReducer</code>时，我们传入<code class="fe lv lw lx ly b">reducer</code>函数和<code class="fe lv lw lx ly b">initialState</code>。如果你熟悉<code class="fe lv lw lx ly b">useState</code>，那么<code class="fe lv lw lx ly b">useReducer</code>也会返回一个包含两个元素的数组:函数<code class="fe lv lw lx ly b">state</code>和函数<code class="fe lv lw lx ly b">dispatch</code>。</p><p id="6598" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们已经创建并设置了<code class="fe lv lw lx ly b">context</code>，是时候使用它了。这个文件中要做的最后一步是利用<code class="fe lv lw lx ly b">useContext</code>函数，它接受一个参数<code class="fe lv lw lx ly b">StateContext</code>。我们将在另一个组件中使用这些函数，将它们导出为名称<code class="fe lv lw lx ly b">exports</code>。</p><h1 id="cf17" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在React中实现上下文</h1><p id="fefb" class="pw-post-body-paragraph kz la iq lb b lc mr jr le lf ms ju lh li mt lk ll lm mu lo lp lq mv ls lt lu ij bi translated">既然<code class="fe lv lw lx ly b">context</code>已经设置好了，是时候在React应用程序中使用它了。如果您以前在React中实现过Redux，方法是类似的。让我们打开<code class="fe lv lw lx ly b">src</code>目录下的<code class="fe lv lw lx ly b">index.js</code>文件。我们需要做的第一件事是导入一些我们之前创建的东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">index.js</figcaption></figure><p id="4b7e" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如前所述，这种方法包括在<code class="fe lv lw lx ly b">Provider</code>中插入一个组件，这样它就可以访问全局状态和调度。在本例中，我们将<code class="fe lv lw lx ly b">App</code>组件作为<code class="fe lv lw lx ly b">Provider</code>的子组件插入，并传入道具、<code class="fe lv lw lx ly b">initialState</code>和<code class="fe lv lw lx ly b">reducer</code>。这样，<code class="fe lv lw lx ly b">App</code>的所有子组件都可以访问上下文。它的结构类似于React Redux。</p><p id="19ad" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在React组件已经可以访问上下文了，让我们使用它。在每个组件中，我们将从之前在<code class="fe lv lw lx ly b">GlobalState.js</code>中创建的文件中导入<code class="fe lv lw lx ly b">globalStateValue</code>函数。在组件中，我们将按照类似于<code class="fe lv lw lx ly b">useState</code>的方式进行设置:</p><pre class="kg kh ki kj gt nk ly nl nm aw nn bi"><span id="34ff" class="mw ma iq ly b gy no np l nq nr">const [state, dispatch] = globalStateValue();</span></pre><p id="384a" class="pw-post-body-paragraph kz la iq lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">提醒一下，调用<code class="fe lv lw lx ly b">globalStateValue</code>会调用<code class="fe lv lw lx ly b">useContext</code>函数，该函数将返回一个包含<code class="fe lv lw lx ly b">state</code>和<code class="fe lv lw lx ly b">dispatch</code>函数的数组。就这样，组件可以访问全局状态，并可以发送调度操作来更改状态。下面是它的实现示例(参考<code class="fe lv lw lx ly b">src</code>目录下的<code class="fe lv lw lx ly b">Left.js</code>和<code class="fe lv lw lx ly b">Right.js</code>组件):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nj l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Code Sandbox Context API practice</figcaption></figure><h1 id="712e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结束语</h1><p id="e5a2" class="pw-post-body-paragraph kz la iq lb b lc mr jr le lf ms ju lh li mt lk ll lm mu lo lp lq mv ls lt lu ij bi translated">本指南介绍了使用附带的钩子在React应用程序中实现上下文API的一种可能方式。上下文API不需要第三方库。这并不意味着上下文API是更好的全局状态管理资源。然而，知道存在其他资源总是好的。另外，我也想表扬桑尼·桑加。我在观看他的一个教程视频时接触到了这种上下文API的方法。感谢您的阅读！</p></div></div>    
</body>
</html>