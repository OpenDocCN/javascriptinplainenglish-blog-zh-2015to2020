<html>
<head>
<title>React Best Practices — Props and Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应最佳实践—道具和组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-best-practices-props-and-components-570c9dca11b0?source=collection_archive---------6-----------------------#2020-06-24">https://javascript.plainenglish.io/react-best-practices-props-and-components-570c9dca11b0?source=collection_archive---------6-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/12149aa2e87bfe4bd42e94988c608cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zedSnTeofqvLm7P_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ximinvincible?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Suryaansh Maithani</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b5ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何种类的应用程序一样，React应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="d58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写React应用程序时的一些最佳实践。</p><h1 id="4bcb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">组件方法顺序</h1><p id="c47c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可能想要加强生命周期组件方法的顺序，这样我们总是可以很容易地找到代码。</p><p id="6cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以对静态方法属性、定制方法、<code class="fe me mf mg mh b">render</code>方法进行排序。</p><p id="fb9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以按照以下顺序保存生命周期方法:</p><p id="0204" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">displayName</code>，<code class="fe me mf mg mh b">propTypes</code>，<code class="fe me mf mg mh b">contextTypes</code>，<code class="fe me mf mg mh b">childContextTypes</code>，<code class="fe me mf mg mh b">mixins</code>，<code class="fe me mf mg mh b">statics</code>，<code class="fe me mf mg mh b">defaultProps</code>，<code class="fe me mf mg mh b">constructor</code>，<code class="fe me mf mg mh b">getDefaultProps</code>，<code class="fe me mf mg mh b">state</code>，<code class="fe me mf mg mh b">getInitialState</code>，<code class="fe me mf mg mh b">getChildContext</code>，<code class="fe me mf mg mh b">getDerivedStateFromProps</code>，<code class="fe me mf mg mh b">componentWillMount</code>，<code class="fe me mf mg mh b">UNSAFE_componentWillMount</code>，<code class="fe me mf mg mh b">componentDidMount</code>，<code class="fe me mf mg mh b">componentWillReceiveProps</code>，<code class="fe me mf mg mh b">UNSAFE_componentWillReceiveProps</code>，<code class="fe me mf mg mh b">shouldComponentUpdate</code>，<code class="fe me mf mg mh b">componentWillUpdate</code>，<code class="fe me mf mg mh b">UNSAFE_componentWillUpdate</code>，<code class="fe me mf mg mh b">getSnapshotBeforeUpdate</code>，<code class="fe me mf mg mh b">componentDidUpdate</code>，<code class="fe me mf mg mh b">componentDidCatch</code>，<code class="fe me mf mg mh b">componentWillUnmount</code></p><p id="90ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一致的排序顺序使东西更容易找到。</p><h1 id="5154" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按字母顺序排序PropType声明</h1><p id="3fe0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对适当类型进行排序，以便更容易地找到它们，就像生命周期方法一样。</p><p id="6ba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f3fb" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends React.Component {<br/>  static propTypes = {<br/>    a: PropTypes.string,<br/>    b: PropTypes.number,<br/>    c: PropTypes.any<br/>  }<br/>  render() {<br/>    return &lt;div /&gt;;<br/>  }<br/>}</span></pre><p id="e36c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以毫不费力地找到他们。</p><h1 id="6746" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">状态初始化样式</h1><p id="cd08" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们使用普通的JavaScript，那么我们必须写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="605a" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = { bar: 1 }<br/>  }<br/>  render() {<br/>    return &lt;div&gt;Foo&lt;/div&gt;<br/>  }<br/>}</span></pre><p id="3adc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们使用TypeScript，我们也可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4b90" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends React.Component {<br/>  state = { bar: 0 }<br/>  render() {<br/>    return &lt;div&gt;Foo&lt;/div&gt;<br/>  }<br/>}</span></pre><p id="d64b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以选择并坚持一个一致性。</p><h1 id="5e43" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">静态方法的定位</h1><p id="f7d4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用最新版本的JavaScript将静态方法放入类中。</p><p id="bb38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4af7" class="mq lc iq mh b gy mr ms l mt mu">class Component extends React.Component {<br/>  static get displayName() { /*...*/ }<br/>  static get defaultProps() { /*...*/ }<br/>  static get propTypes() { /*...*/ }<br/>}</span></pre><p id="cf4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以把它们放在外面:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="12df" class="mq lc iq mh b gy mr ms l mt mu">class Component extends React.Component { /*...*/ }<br/>Component.displayName = "Hello";<br/>Component.defaultProps = { /*...*/ };<br/>Component.propTypes = { /*...*/ };</span></pre><p id="8dfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该选择并坚持使用一个来保持一致性。</p><h1 id="9bd9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">样式属性值应该是一个对象</h1><p id="49c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">道具应该有一个对象传入其中。</p><p id="0b32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f86e" class="mq lc iq mh b gy mr ms l mt mu">&lt;div style={{ color: "red" }} /&gt;</span></pre><p id="b138" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b9fc" class="mq lc iq mh b gy mr ms l mt mu">&lt;div style="color: 'red'" /&gt;</span></pre><p id="4259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象是React理解的对象，而不是字符串。</p><h1 id="45b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Void DOM元素不应该有子元素</h1><p id="f656" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像<code class="fe me mf mg mh b">&lt;img /&gt;</code>和<code class="fe me mf mg mh b">&lt;br /&gt;</code>这样的Void DOM元素不应该有子元素或者开始和结束标签。</p><p id="b581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该有这样的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="faea" class="mq lc iq mh b gy mr ms l mt mu">&lt;br&gt;Children&lt;/br&gt;<br/>&lt;br children='foo' /&gt;<br/>&lt;br dangerouslySetInnerHTML={{ __html: 'HTML' }} /&gt;</span></pre><p id="3ed7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="22ea" class="mq lc iq mh b gy mr ms l mt mu">&lt;br /&gt;</span></pre><h1 id="76d3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSX的布尔属性符号</h1><p id="33be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了使布尔属性更清晰，我们应该加入<code class="fe me mf mg mh b">true</code>,而不是省略布尔属性的值。</p><p id="e06a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9306" class="mq lc iq mh b gy mr ms l mt mu">const Hello = &lt;Hello personal={true} /&gt;;</span></pre><p id="de32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们知道<code class="fe me mf mg mh b">personal</code>就是<code class="fe me mf mg mh b">true</code>。</p><h1 id="efbf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在JSX，花括号内没有空格</h1><p id="5612" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React移除元素之间无关的换行符，因此元素之间的空格不会被渲染。</p><p id="22af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们真的不需要它们之间的空间。</p><p id="fa80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要空格，我们必须在花括号内添加一个字符串。</p><p id="c982" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5158" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>  hello<br/>  {' '}<br/>  &lt;b&gt;world&lt;/b&gt;<br/>&lt;/div&gt;</span></pre><h1 id="7ae1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSX文的右括号符号</h1><p id="a6a9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们的组件或元素跨越多行，我们应该将右括号放在靠近左括号的水平位置。</p><p id="bc69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如说。我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d1ed" class="mq lc iq mh b gy mr ms l mt mu">&lt;Hello firstName="john" lastName="smith" /&gt;;</span></pre><p id="82fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="43a2" class="mq lc iq mh b gy mr ms l mt mu">&lt;Hello<br/>  firstName="jane"<br/>  lastName="doe"<br/>/&gt;;</span></pre><p id="64ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得我们的代码更整洁，更容易阅读。</p><h1 id="210e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JSX的结束标记位置</h1><p id="17f0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该把结束标签放在和开始标签相同的水平位置。</p><p id="ddd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9350" class="mq lc iq mh b gy mr ms l mt mu">&lt;Hello&gt;<br/>  hello<br/>&lt;/Hello&gt;</span></pre><p id="6d9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它更整洁，更容易阅读。</p><h1 id="f0cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有多余的花括号</h1><p id="0446" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当组件或元素之间有字符串时，我们不应该有多余的花括号。</p><p id="127f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0965" class="mq lc iq mh b gy mr ms l mt mu">&lt;App&gt;{'Hello world'}&lt;/App&gt;;</span></pre><p id="8798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1ee2" class="mq lc iq mh b gy mr ms l mt mu">&lt;App&gt;Hello world&lt;/App&gt;;</span></pre><p id="df5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们做同样的事情，所以花括号和引号是无关的。</p><h1 id="d540" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">花括号中的换行符</h1><p id="878c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在花括号中有长表达式，我们应该添加换行符，这样我们就不必水平滚动来阅读整行。</p><p id="0b1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c51f" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>  {<br/>    foo &amp;&amp;<br/>    foo.bar<br/>  }<br/>&lt;/div&gt;</span></pre><p id="7aef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保持线条简洁。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8bdebae6662f8fffe7d9abd3735cef95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WF-nRlqImTkg2nVp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pcristina18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">cristina pop</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5e2e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="edce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中应该有无关的字符。我们不需要花括号来包装文本。</p><p id="e4ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该在标签中有孩子。</p><p id="78c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能还想对属性和方法进行排序，以便更容易阅读。</p><h2 id="907f" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="daff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> plainenglish.io </strong> </a>和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">找到它们订阅我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>