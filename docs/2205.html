<html>
<head>
<title>Embedding translations in your JS bundles with ngx-translate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ngx-translate在JS包中嵌入翻译</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/embedding-translations-in-your-js-bundles-with-ngx-translate-526ce847acab?source=collection_archive---------3-----------------------#2020-05-30">https://javascript.plainenglish.io/embedding-translations-in-your-js-bundles-with-ngx-translate-526ce847acab?source=collection_archive---------3-----------------------#2020-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9a89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能不总是希望通过额外的HTTP请求来获取翻译。让我向您展示如何使用TypeScript和<a class="ae kl" href="http://www.ngx-translate.com/" rel="noopener ugc nofollow" target="_blank"> ngx-translate </a>安全地将它们嵌入JS包中。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/345ba8c8171f36ba833ee28f6c2ccf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_nt4aG22-Ntb0hdW9ryOg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Image courtesy of <a class="ae kl" href="https://unsplash.com/@maybritt" rel="noopener ugc nofollow" target="_blank">Maybritt Devriese</a></figcaption></figure><p id="0f3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">据我所知，似乎大多数人更喜欢在运行时加载当前语言的翻译，在应用程序启动时通过HTTP请求，甚至在用户决定切换到另一种语言时。不过，在我的应用程序中，我选择在主JS包中包含所有的翻译。</p><p id="2b0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这种方法，以后就不需要加载翻译了；一切从一开始就存在。这确实增加了初始加载时间，但是因为这是一个离线优先的应用程序，所以对我来说这不是一个大问题。还可以对其进行优化，例如通过将翻译隔离在它们自己的包中，限制影响并允许长期缓存。不过我不打算在这里讨论这个问题。</p><p id="4139" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将描述我是如何实现这一点的。此外，我还将分享我在TypeScript中使用的类型，以防止一些错误。</p><h1 id="25f5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">翻译文件</h1><p id="35f4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，让我们创建两个翻译文件。这里我假设en_US和fr_BE:</p><p id="d8c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">en_US.json:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0f11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fr_BE.json:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="545e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，这里没什么特别的。我只是将所有翻译包装在一个“I18N”对象中，这样所有翻译都以“I18N”为前缀无论何时在应用程序中使用它们；使得以后很容易找到它们。</p><h1 id="d7b1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">编译时安全导入翻译</h1><p id="fb4d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了在我们的包中包含这些翻译，我们首先要使用TypeScript来加载它们:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的导入语句利用了TypeScript 2.9 中引入的一个特性<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#new---resolvejsonmodule" rel="noopener ugc nofollow" target="_blank">，称为“resolveJsonModule”，它允许轻松地导入JSON文件。可以通过将tsconfig.json中的相应属性设置为<code class="fe mh mi mj mk b">true</code>来启用此功能:</a></p><pre class="kn ko kp kq gt ml mk mm mn aw mo bi"><span id="27d6" class="mp ld iq mk b gy mq mr l ms mt">"resolveJsonModule": true,</span></pre><p id="c895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一行很有趣，因为它创建了一个表示翻译文件形状的自定义类型。我将马上使用它来确保所有的翻译文件都具有相同的形状，这样我就可以确保我没有忘记用应用程序支持的语言之一来翻译一些东西。虽然不完美，但还是有帮助的。我所做的是，我先写“主”翻译(英语)，然后我翻译成其他支持的语言。</p><p id="d0c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加载后，我将翻译添加到地图/字典结构中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ed2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意与映射中每个键相关联的类型；这确实是我们根据英语翻译文件创建的自定义类型。这就是我如何确保所有的翻译文件都有预期的<em class="mu">形状</em>。如果任何翻译文件与“主文件”不一致，此代码将无法编译。</p><p id="6cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是单一语言的表示。我已经从我当前的项目中1:1地得到了这个；您可以随意丰富或简化它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="122f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它只是给出了一种语言的基本信息:</p><ul class=""><li id="3df1" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">一个ISO(ISO 639-1+ISO 3166-1阿尔法-2)代码</li><li id="7631" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">它的每个部分都是独立的(代码和地区)</li><li id="6181" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">语言的翻译关键字:对语言更改组件有用)(例如，英语)</li><li id="7448" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">语言的简短翻译关键字:对于压缩的语言更改组件(例如EN)非常有用</li></ul><p id="01bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以定义一个类来保存语言列表:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="86ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类很有用，因为它允许获得一种具有良好/可读语法的特定语言:</p><pre class="kn ko kp kq gt ml mk mm mn aw mo bi"><span id="6d4b" class="mp ld iq mk b gy mq mr l ms mt">Languages.EN_US</span></pre><p id="56e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，由于有了<code class="fe mh mi mj mk b">supportedLanguages</code>数组，我们可以很容易地实现一个基于代码或ISO代码查找<code class="fe mh mi mj mk b">Language</code>对象的函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e8a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，现在我们有了简单且类型安全的方法来访问我们的语言和翻译。</p><h1 id="c064" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">额外收获:注意到缺失的翻译</h1><p id="8853" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">有时，我们太专注于下一个任务，以至于忘记添加所需的翻译。如果我们这样做了，那么我们需要看到他们失踪了。</p><p id="c761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让遗漏的翻译更加明显的一个方法是实现ngx-translate的<code class="fe mh mi mj mk b">MissingTranslationHandler</code>接口:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至少这不会被忽视太久；-)</p><h1 id="6298" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">将我们的翻译注入ngx-translate</h1><p id="d13e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，让我们看看如何将我们的翻译注入ngx-translate。</p><p id="197b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，ngx-translate有一个<a class="ae kl" href="https://github.com/ngx-translate/core/blob/master/projects/ngx-translate/core/src/lib/translate.loader.ts" rel="noopener ugc nofollow" target="_blank"> TranslateLoader </a>的概念。该接口的目标是提供检索给定语言翻译的方法。</p><p id="1399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ngx-translate默认使用<a class="ae kl" href="https://github.com/ngx-translate/http-loader" rel="noopener ugc nofollow" target="_blank"> HTTP loader </a>，它使用Angular的HttpClient通过HTTP请求在运行时检索翻译。由于我们想跳过这一步并嵌入我们的翻译，我们需要一个自定义实现:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fca5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们已经导入了我们的翻译，所以没有必要获取它们；我们只需要从翻译地图中提取相应的语言。</p><p id="80d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了配置ngx-translate，我们需要创建一个<code class="fe mh mi mj mk b">TranslateModuleConfig</code>对象:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="80a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了使用它，我们需要在导入模块时传递它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，注意我在最后对Angular的<code class="fe mh mi mj mk b">registerLocaleData</code>方法的调用。这就是我们如何加载Angular提供的附加语言环境信息，如果你使用像<code class="fe mh mi mj mk b">DatePipe</code>、<code class="fe mh mi mj mk b">CurrencyPipe</code>、<code class="fe mh mi mj mk b">DecimalPipe</code>或<code class="fe mh mi mj mk b">PercentPipe</code>这样的东西，这是必要的。默认情况下，Angular只包含en-US的区域设置数据。因为我们已经通过<code class="fe mh mi mj mk b">Languages</code>类在应用程序中对此进行了编码，所以我们可以很容易地在这里重用它。如果你想了解更多，请查看Angular 的<a class="ae kl" href="https://angular.io/guide/i18n" rel="noopener ugc nofollow" target="_blank">国际化指南。</a></p><h1 id="82d2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="0ee9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在本文中，我分享了我在当前应用程序中静态加载翻译并将它们作为主要JS包的一部分的代码。</p><p id="4883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我解释了如何使用定制加载器将静态翻译与ngx-translate集成。对于像<a class="ae kl" href="https://ngneat.github.io/transloco/" rel="noopener ugc nofollow" target="_blank"> Transloco </a>这样的库来说，这应该也是可能的，但是我还没有深入研究这个库；-)</p><p id="5e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我还解释了如何利用一些很酷的TypeScript特性来避免忘记一些翻译。</p><p id="42d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p><p id="5d26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你想学习大量关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的其他很酷的东西，那么不要犹豫<a class="ae kl" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">去拿一本我的书</a>并订阅<a class="ae kl" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的时事通讯</a>！</p><h1 id="7c50" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="b590" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kl" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae kl" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅我们的YouTube频道</strong> </a> <strong class="jp ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>