<html>
<head>
<title>React 17: New JSX Transform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应17:新JSX变换</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-17-new-jsx-transform-c6f983f3464d?source=collection_archive---------3-----------------------#2020-12-16">https://javascript.plainenglish.io/react-17-new-jsx-transform-c6f983f3464d?source=collection_archive---------3-----------------------#2020-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9eee" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">新JSX变换集成指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/737191f756fc9458651bd0732fbc6d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cFzvvLcrnITSzGu-"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lukechesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luke Chesser</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="03d3" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="54d3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">任何依赖项的每个主要发布都会导致“哦，天哪，我希望这个主要升级不会太痛苦”的想法。当我看到React已经在<code class="fe mh mi mj mk b">npm outdated</code>发布的时候，我的反应也没什么不同。但是在看了他们的<a class="ae ks" href="https://reactjs.org/blog/2020/10/20/react-v17.html" rel="noopener ugc nofollow" target="_blank"> React 17发布博客</a>后，我松了一口气——没有突破性的变化或新功能。但是，它提到了一个有趣的可选变化:新的JSX变换。</p><h1 id="fb87" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">JSX变换</h1><p id="f71c" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">JSX变换是必要的，这样你的源代码可以被转换成浏览器可以理解的代码。这就是Babel或TypeScript等编译器的用武之地——它们将开发人员友好的代码转换成浏览器友好的代码。旧的JSX转换需要你导入React，因为这会告诉你的编译器这个文件需要一些React JSX魔法。否则，编译将会失败。这就是为什么ESLint插件<code class="fe mh mi mj mk b"><a class="ae ks" href="https://www.npmjs.com/package/eslint-plugin-react" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react</a></code>包括并推荐了<code class="fe mh mi mj mk b">react/react-in-jsx-scope</code>和<code class="fe mh mi mj mk b">react/jsx-uses-react</code>规则。</p><p id="b1ad" class="pw-post-body-paragraph ll lm in ln b lo ml jo lq lr mm jr lt lu mn lw lx ly mo ma mb mc mp me mf mg ig bi translated">然而，新的JSX变换不再需要React导入。编译仍然可以工作，不需要对你的JSX代码做任何改动！在内部，转换魔术的工作方式不同，但最终结果是相同的——您的代码在浏览器中的工作方式与之前完全一样。</p><h1 id="58a6" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">反应效用</h1><p id="5528" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">虽然您不再需要导入React，但是如果您使用React实用程序、挂钩和其他工具，您可能仍然需要导入它们。这些应该通过它们的命名导入来导入。</p><pre class="kd ke kf kg gt mq mk mr ms aw mt bi"><span id="d8b4" class="mu ku in mk b gy mv mw l mx my">import { Component, lazy, Suspense, useState } from 'react';</span></pre><h1 id="91c8" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">埃斯林特</h1><p id="759f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">这个新的转换将与一些ESLint规则相冲突。如果你正在使用<code class="fe mh mi mj mk b">react/react-in-jsx-scope</code>或<code class="fe mh mi mj mk b">react/jsx-uses-react</code>，无论是显式的还是通过普通配置(比如<a class="ae ks" href="https://www.npmjs.com/package/eslint-config-airbnb" rel="noopener ugc nofollow" target="_blank"> Airbnb的ESLint配置</a>或<code class="fe mh mi mj mk b">eslint-plugin-react</code>的推荐)，它们都需要被禁用。</p><pre class="kd ke kf kg gt mq mk mr ms aw mt bi"><span id="02e5" class="mu ku in mk b gy mv mw l mx my">// .eslintrc.js<br/>module.exports = {<br/>  rules: {<br/>    'react/react-in-jsx-scope': 'off',<br/>    '<!-- -->react/jsx-uses-react<!-- -->': 'off'<br/>  }<br/>}</span></pre><h1 id="77a6" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">配置</h1><p id="398c" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">不过这个特性确实需要一点配置。如果你用的是Create React App的<code class="fe mh mi mj mk b">react-scripts</code>，那就不得不不幸的咬紧牙关升级到4.0。</p><p id="d3a9" class="pw-post-body-paragraph ll lm in ln b lo ml jo lq lr mm jr lt lu mn lw lx ly mo ma mb mc mp me mf mg ig bi translated">如果您正在手动设置Babel，支持这种转换至少需要Babel 7.9和在您的Babel配置文件中使用自动运行时的<code class="fe mh mi mj mk b">@babel/preset-react</code>或<code class="fe mh mi mj mk b">@babel/plugin-transform-react-jsx</code>。</p><pre class="kd ke kf kg gt mq mk mr ms aw mt bi"><span id="fd2a" class="mu ku in mk b gy mv mw l mx my">// for @babel/preset-react<br/>{<br/>  "presets": [<br/>    ["@babel/preset-react", {<br/>      "runtime": "automatic"<br/>    }]<br/>  ]<br/>}</span><span id="a9ed" class="mu ku in mk b gy mz mw l mx my">// for @babel/plugin-transform-react-jsx<br/>{<br/>  "plugins": [<br/>    ["@babel/plugin-transform-react-jsx", {<br/>      "runtime": "automatic"<br/>    }]<br/>  ]<br/>}</span></pre><h1 id="3efb" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">Codemod</h1><p id="bfa8" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为了支持这种迁移，React团队幸运地为我们提供了一个codemod:</p><pre class="kd ke kf kg gt mq mk mr ms aw mt bi"><span id="764b" class="mu ku in mk b gy mv mw l mx my">npx react-codemod update-react-imports</span></pre><p id="2b31" class="pw-post-body-paragraph ll lm in ln b lo ml jo lq lr mm jr lt lu mn lw lx ly mo ma mb mc mp me mf mg ig bi translated">在对您的环境提出一些问题之后，如果您使用任何React实用程序，这个脚本应该会自动删除默认的React导入并添加命名导入。当然，验证这些变化，因为这个codemod可能并不完美。</p><p id="d45f" class="pw-post-body-paragraph ll lm in ln b lo ml jo lq lr mm jr lt lu mn lw lx ly mo ma mb mc mp me mf mg ig bi translated">注意:我个人遇到了一个MODULE_NOT_FOUND ( <em class="na">错误:找不到模块' @ babel/runtime-corejs 3/helpers/interopRequireDefault '</em>)的问题，至今还没有找到问题的根本原因。但是我确实找到了一个临时删除(或注释掉)babel配置文件的解决方法。</p><h1 id="5dae" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">支持的版本</h1><p id="b51f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">除了React 17之外，React团队还将该功能向后移植到React 16.14、React 15.7和React 0.14.10，这样您就可以利用该功能，而无需进行重大升级。但是如果你在React 16上，升级到React 17是没有痛苦的。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h1 id="578b" class="kt ku in bd kv kw ni ky kz la nj lc ld jt nk ju lf jw nl jx lh jz nm ka lj lk bi translated">最后的想法</h1><p id="d17e" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">这样有什么好处吗？不完全是。但是我喜欢这种改变吗？是的，绝对的。我总是觉得很愚蠢，我会导入一些没有(明确地)使用的东西，就好像它是一个未使用的导入或变量。由于新的JSX变换只需要很少的配置更改，并且有一个codemod来自动重构一切，所以您也可以开始使用它。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h1 id="c541" class="kt ku in bd kv kw ni ky kz la nj lc ld jt nk ju lf jw nl jx lh jz nm ka lj lk bi translated">资源</h1><ul class=""><li id="2fc2" class="nn no in ln b lo lp lr ls lu np ly nq mc nr mg ns nt nu nv bi translated"><a class="ae ks" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" rel="noopener ugc nofollow" target="_blank">JSX转型官方博文</a></li></ul></div></div>    
</body>
</html>