<html>
<head>
<title>Building a Classic Arcade Game with JavaScript and HTML5 Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript和HTML5画布构建经典街机游戏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-classic-arcade-game-with-javascript-and-html5-canvas-18494e4201ba?source=collection_archive---------1-----------------------#2019-09-06">https://javascript.plainenglish.io/building-a-classic-arcade-game-with-javascript-and-html5-canvas-18494e4201ba?source=collection_archive---------1-----------------------#2019-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a16b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Tron Light在240行JavaScript中循环</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69b7bbf1720f164d5ab52c3461a0975f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynfk2fJ2Wz0rgIHENRUvSQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@cadop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mathew Schwartz</a> on <a class="ae kv" href="https://unsplash.com/search/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>, with my own edits</figcaption></figure><p id="4e8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在学校发现了创光循环游戏。学校IT部门禁止了大多数游戏网站，但我们总是能找到黑名单之外的网站:其中一个网站有Tron Light Cycles的Flash版本。尽管以现代标准来看这很简单，但这个1982年的游戏仍然让人上瘾——而且竞争相当激烈！</p><p id="bf63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，Flash即将被弃用，而HTML和JavaScript却一如既往地强大。因此，在本文中，我们将使用HTML <code class="fe ls lt lu lv b">canvas</code>和JavaScript重新创建一个轻量级的多人版Tron Light Cycles游戏。</p><h1 id="aba9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们将创造什么</h1><p id="0dc6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在深入研究代码之前，让我们先看看我们将要创建什么。</p><p id="a81f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Tron是一个双人游戏，目标是比你的对手活得更久。不能碰墙，不能碰自己的小道，不能碰对手的小道！</p><p id="23d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">玩家1使用箭头键，玩家2使用WASD:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This tutorial’s version of Tron Light Cycles, but a bit smaller (so it fits inside the CodePen!)</figcaption></figure><p id="81c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将深入研究与此相关的代码。如果你发现自己在教程中迷失了，看看这里的最终回购:<a class="ae kv" href="https://github.com/BretCameron/tron-light-cylces" rel="noopener ugc nofollow" target="_blank">https://github.com/BretCameron/tron-light-cylces</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/87c51915a7938976b8beeb7a543dfeaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*XuLOS8EJFPBDXyCARsL5aQ.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An original Tron arcade game</figcaption></figure><h1 id="99f7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤HTML和CSS</h1><h2 id="8882" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">index.html</h2><p id="d55d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将使用的HTML大部分是样板文件。我们的游戏唯一需要的标签是<code class="fe ls lt lu lv b">canvas</code>——另外我们需要确保链接到我们的<code class="fe ls lt lu lv b">style.css</code>和<code class="fe ls lt lu lv b">tron.js</code>文件:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="5bd6" class="mw lx iq lv b gy nm nn l no np">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;</span><span id="4886" class="mw lx iq lv b gy nq nn l no np">&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;<br/>  <strong class="lv ir">&lt;title&gt;Tron Light Cycles&lt;/title&gt;<br/>  &lt;link rel="stylesheet" href="style.css"&gt;<br/>  &lt;link href="https://fonts.googleapis.com/css?family=Bungee&amp;display=swap" rel="stylesheet"&gt;<br/></strong>&lt;/head&gt;</span><span id="cfae" class="mw lx iq lv b gy nq nn l no np">&lt;body&gt;</span><span id="b25f" class="mw lx iq lv b gy nq nn l no np"><strong class="lv ir">  &lt;canvas id="tron" width="750" height="750"&gt;&lt;/canvas&gt;<br/>  &lt;script src="tron.js"&gt;&lt;/script&gt;</strong></span><span id="50ef" class="mw lx iq lv b gy nq nn l no np">&lt;/body&gt;</span><span id="6475" class="mw lx iq lv b gy nq nn l no np">&lt;/html&gt;</span></pre><h2 id="df5a" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">style.css</h2><p id="a404" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">为了向原作致敬，我们将在黑暗的背景上制作我们版本的创光循环。这是一些初始的样式，所以我们可以看到我们在做什么:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="4697" class="mw lx iq lv b gy nm nn l no np">body {<br/>  background: #000;<br/>  text-align: <em class="nr">center</em>;<br/>  font-family: 'Bungee', <em class="nr">cursive</em>;<br/>}</span><span id="38b3" class="mw lx iq lv b gy nq nn l no np">#tron {<br/>  border: 1px <em class="nr">solid</em> #777;<br/>  outline: 1px <em class="nr">solid</em> #333;<br/>  outline-offset: 5px;<br/>}</span></pre><p id="5aae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，我们做的几乎所有事情都将发生在我们的<code class="fe ls lt lu lv b">tron.js</code>文件中。</p><h1 id="0366" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤2:设置画布和上下文</h1><p id="4589" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">当使用HTML5 canvas元素时，我们需要选择用来绘制元素的上下文。我们的游戏将是2D，所以打开<code class="fe ls lt lu lv b">tron.js</code>并输入以下代码:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="3939" class="mw lx iq lv b gy nm nn l no np">const canvas = document.getElementById('tron');<br/>const context = canvas.getContext('2d');<br/>const unit = 15;</span></pre><p id="a148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面，我还添加了一个<code class="fe ls lt lu lv b">unit</code>变量，因为这将在我们代码的多个点上有所帮助。我们的网格将由15px的正方形组成，我们也希望我们的光周期一次移动15px。</p><h1 id="031d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">步骤3:定义玩家和控制</h1><h2 id="3d57" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">演员</h2><p id="8c35" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们将从两名球员开始，但最终，我们可能需要多达四名球员。因此，为了便于创建玩家，我们将使用一个类:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="9473" class="mw lx iq lv b gy nm nn l no np">class Player {<br/>  constructor(x, y, color) {<br/>    <em class="nr">this.</em>color = color || '#fff';<br/>    <em class="nr">this</em>.dead = false;<br/>    <em class="nr">this</em>.direction = '';<br/>    <em class="nr">this</em>.key = '';<br/>    <em class="nr">this</em>.x = x;<br/>    <em class="nr">this</em>.y = y;<br/>    <em class="nr">this</em>.startX = x;<br/>    <em class="nr">this</em>.startY = y;</span><span id="9a5b" class="mw lx iq lv b gy nq nn l no np">    <em class="nr">this</em>.constructor.counter = (<em class="nr">this</em>.constructor.counter || 0) + 1;<br/>    <em class="nr">this</em>._id = <em class="nr">this</em>.constructor.counter;<br/><br/>    Player.allInstances.push(<em class="nr">this</em>);<br/>  };<br/>};</span><span id="fc0a" class="mw lx iq lv b gy nq nn l no np">Player.allInstances = [];</span></pre><p id="52c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">Player</code>类有很多属性:</p><ul class=""><li id="ea1d" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated"><code class="fe ls lt lu lv b">color</code>告诉我们每个玩家的颜色，</li><li id="b575" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe ls lt lu lv b">dead</code>是一个布尔值，告诉我们玩家是否还活着，</li><li id="ae40" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe ls lt lu lv b">direction</code>告诉我们玩家实际前进的方向，</li><li id="6edd" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe ls lt lu lv b">key</code>告诉我们玩家<em class="nr">尝试</em>进入的最后一个方向，</li><li id="3213" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe ls lt lu lv b">x</code>和<code class="fe ls lt lu lv b">y</code>在任一时刻给我们玩家的坐标，</li><li id="1f8b" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe ls lt lu lv b">startX</code>和<code class="fe ls lt lu lv b">startY</code>在游戏开始时记录玩家的坐标，这样我们可以很容易地重置游戏</li><li id="7493" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated"><code class="fe ls lt lu lv b">_id</code>根据玩家开始游戏的时间，给他们一个号码。</li></ul><p id="6a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在类下面，我们还创建了一个包含所有播放器实例的数组。每次调用<code class="fe ls lt lu lv b">constructor</code>时，它都会将新玩家添加到我们的数组中。这将有助于我们确定有多少玩家，并对每个玩家实例应用动作。</p><p id="c03a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备创建我们的前两个玩家:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="33db" class="mw lx iq lv b gy nm nn l no np">let p1 = new Player(unit * 6, unit * 6, '#75A4FF');<br/>let p2 = new Player(unit * 43, unit * 43, '#FF5050');</span></pre><h2 id="7516" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">设定玩家的方向</h2><p id="4c0b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们需要一个通用函数来控制玩家的移动。它们可以在2D平面上向任何方向移动，但是它们不能立即返回:例如，如果你要向左走，你不能不先向上或向下就立即向右走。</p><p id="cdd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把这些规则放在一个通用函数中。这意味着我们可以轻松地选择一个玩家，并为<code class="fe ls lt lu lv b">up</code>、<code class="fe ls lt lu lv b">right</code>、<code class="fe ls lt lu lv b">down</code>和<code class="fe ls lt lu lv b">left</code>分配键码:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="394d" class="mw lx iq lv b gy nm nn l no np">function setKey(key, player, up, right, down, left) {<br/>  switch (key) {<br/>    case up:<br/>      if (player.direction !== 'DOWN') {<br/>        player.key = 'UP';<br/>      } <br/>      break;<br/>    case right:<br/>      if (player.direction !== 'LEFT') {<br/>        player.key = 'RIGHT';<br/>      } <br/>      break;<br/>    case down:<br/>      if (player.direction !== 'UP') {<br/>        player.key = 'DOWN';<br/>      } <br/>      break;<br/>    case left:<br/>      if (player.direction !== 'RIGHT') {<br/>        player.key = 'LEFT';<br/>      } <br/>      break;<br/>    default:<br/>      break;<br/>  };<br/>};</span></pre><p id="623f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">setKey</code>功能被设计为可重复使用。该功能将允许我们使用容易理解的字符串来引用动作，而不是被键码所迷惑:<code class="fe ls lt lu lv b">'UP'</code>、<code class="fe ls lt lu lv b">'RIGHT'</code>、<code class="fe ls lt lu lv b">'DOWN'</code>和<code class="fe ls lt lu lv b">'LEFT'</code>。</p><p id="e9af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为了让我们的<code class="fe ls lt lu lv b">setKey</code>函数生效，我们需要指定哪些键将影响哪些播放器，并创建一个事件监听器来监听那些被按下的键:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="b8a7" class="mw lx iq lv b gy nm nn l no np">function handleKeyPress(event) {<br/>  let key = event.keyCode;</span><span id="da66" class="mw lx iq lv b gy nq nn l no np">  if (key === 37 || key === 38 || key === 39 || key === 40) {<br/>    event.preventDefault();<br/>  };</span><span id="27e6" class="mw lx iq lv b gy nq nn l no np">  setKey(key, p1, 38, 39, 40, 37); <em class="nr">// arrow keys<br/>  </em>setKey(key, p2, 87, 68, 83, 65); <em class="nr">// WASD<br/></em>};</span><span id="8ad3" class="mw lx iq lv b gy nq nn l no np">document.addEventListener('keydown', handleKeyPress);</span></pre><p id="9b09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们分配了箭头键来控制玩家1，分配了<code class="fe ls lt lu lv b">WASD</code>来控制玩家2。我们还防止了箭头键的默认行为，停止不必要的滚动。</p><h1 id="ee4e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">第四步:建立董事会</h1><h2 id="fdaa" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">确定可播放的单元格</h2><p id="87b6" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在游戏真正开始之前，我们能做的计算越多，性能就越好。一种策略是在开始时创建一个包含所有可播放单元的<code class="fe ls lt lu lv b">Set</code>。</p><p id="a0f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当每个玩家遍历棋盘时，我们将从列表中删除一个单元格。然后，我们不用依靠复杂的<code class="fe ls lt lu lv b">if</code>或<code class="fe ls lt lu lv b">switch</code>语句来确定一个玩家是否已经死亡，我们可以简单地看到他们是否在一个可玩的细胞上！</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="80cb" class="mw lx iq lv b gy nm nn l no np">function getPlayableCells(canvas, unit) {<br/>  let playableCells = new Set();<br/>  for (let i = 0; i &lt; canvas.width / unit; i++) {<br/>    for (let j = 0; j &lt; canvas.height / unit; j++) {<br/>      playableCells.add(`${i * unit}x${j * unit}y`);<br/>    };<br/>  };<br/>  return playableCells;<br/>};</span><span id="91f0" class="mw lx iq lv b gy nq nn l no np">let playableCells = getPlayableCells(canvas, unit);</span></pre><h2 id="f277" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">制作背景</h2><p id="7ef7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们终于可以把视觉元素放到屏幕上了！使用这段代码创建了一个微妙的网格模式:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="fa88" class="mw lx iq lv b gy nm nn l no np">function drawBackground() {<br/>  context.strokeStyle = '#001900';<br/>  for (let i = 0; i &lt;= canvas.width / unit + 2; i += 2) {<br/>    for (let j = 0; j &lt;= canvas.height / unit + 2; j += 2) {<br/>      context.strokeRect(0, 0, unit * i, unit * j);<br/>    };<br/>  };</span><span id="06cd" class="mw lx iq lv b gy nq nn l no np">  context.strokeStyle = '#000000';<br/>  context.lineWidth = 2;<br/>  for (let i = 1; i &lt;= canvas.width / unit; i += 2) {<br/>    for (let j = 1; j &lt;= canvas.height / unit; j += 2) {<br/>      context.strokeRect(0, 0, unit * i, unit * j);<br/>    };<br/>  };<br/>  context.lineWidth = 1;<br/>};</span><span id="7a9b" class="mw lx iq lv b gy nq nn l no np">drawBackground();</span></pre><p id="5144" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也是确定我们球员首发位置的一个好点:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="b4f5" class="mw lx iq lv b gy nm nn l no np">function drawStartingPositions(players) {<br/>  players.forEach(p =&gt; {<br/>    context.fillStyle = p.color;<br/>    context.fillRect(p.x, p.y, unit, unit);<br/>    context.strokeStyle = 'black';<br/>    context.strokeRect(p.x, p.y, unit, unit);<br/>  });<br/>};</span><span id="501b" class="mw lx iq lv b gy nq nn l no np">drawStartingPositions(Player.allInstances);</span></pre><p id="a6d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经注意到，我们将许多流程包装在它们自己的函数中。除了是好的实践，这允许我们稍后在我们的<code class="fe ls lt lu lv b">resetGame</code>函数中重用代码。</p><h1 id="cde9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">第五步:游戏中的逻辑</h1><p id="8e62" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们现在准备好开始游戏的动态部分了。首先，我们将向全局名称空间添加三个新变量:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="b246" class="mw lx iq lv b gy nm nn l no np">let outcome, winnerColor, playerCount = Player.allInstances.length;</span></pre><p id="1ef8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将创建一个<code class="fe ls lt lu lv b">draw</code>函数，它以100毫秒的固定间隔重复触发:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="c58c" class="mw lx iq lv b gy nm nn l no np">function draw() {<br/>  if (Player.allInstances.filter(p =&gt; !p.key).length === 0) {</span><span id="63fa" class="mw lx iq lv b gy nq nn l no np"><em class="nr">  // in-game logic...</em></span><span id="7bfa" class="mw lx iq lv b gy nq nn l no np">  };<br/>};</span><span id="191b" class="mw lx iq lv b gy nq nn l no np">const game = setInterval(draw, 100);</span></pre><p id="0c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，<code class="fe ls lt lu lv b">if</code>声明要求游戏只有在每个玩家都选择了开始键后才开始。</p><p id="67b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本节的剩余部分，我们将要讨论的所有代码都在<code class="fe ls lt lu lv b">draw</code>函数内部(以及<code class="fe ls lt lu lv b">if</code>语句内部)。我们准备开始移动我们的球员！</p><h2 id="3fa8" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">添加运动</h2><p id="06a0" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">draw</code>函数中，添加以下代码:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="96f4" class="mw lx iq lv b gy nm nn l no np">Player.allInstances.forEach(p =&gt; {</span><span id="306f" class="mw lx iq lv b gy nq nn l no np">  if (p.key) {</span><span id="6922" class="mw lx iq lv b gy nq nn l no np">    p.direction = p.key;</span><span id="3896" class="mw lx iq lv b gy nq nn l no np">    context.fillStyle = p.color;<br/>    context.fillRect(p.x, p.y, unit, unit);<br/>    context.strokeStyle = 'black';<br/>    context.strokeRect(p.x, p.y, unit, unit);</span><span id="5af0" class="mw lx iq lv b gy nq nn l no np">    if (!playableCells.has(`${p.x}x${p.y}y`) &amp;&amp; p.dead === false) {<br/>      p.dead = true;<br/>      p.direction = '';<br/>      playerCount -= 1;<br/>    }</span><span id="b22a" class="mw lx iq lv b gy nq nn l no np">    playableCells.delete(`${p.x}x${p.y}y`);</span><span id="cb76" class="mw lx iq lv b gy nq nn l no np">    if (!p.dead) {<br/>      if (p.direction == "LEFT") p.x -= unit;<br/>      if (p.direction == "UP") p.y -= unit;<br/>      if (p.direction == "RIGHT") p.x += unit;<br/>      if (p.direction == "DOWN") p.y += unit;<br/>    };</span><span id="05ca" class="mw lx iq lv b gy nq nn l no np">  };</span><span id="26b6" class="mw lx iq lv b gy nq nn l no np">});</span></pre><p id="c158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试按箭头键或<code class="fe ls lt lu lv b">WASD</code>。我们的光周期现在移动了！</p><p id="2780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们分解上面的代码，我们会注意到每次<code class="fe ls lt lu lv b">draw</code>函数运行时:</p><ul class=""><li id="53c0" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated">我们为每个玩家画一个新的正方形，在他们选择的方向上1个单位。</li><li id="8806" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">如果一个玩家移动到一个不可玩的格子上，我们把它标记为死亡。</li><li id="98f7" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">我们从集合<code class="fe ls lt lu lv b">playableCells</code>中移除刚刚被遍历的单元。</li></ul><p id="4727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个功能也只有在每个玩家都选择了一个键的情况下才运行(防止玩家因为保持静止而杀死自己)。</p><p id="e44f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们就要完成了，但是游戏仍然没有结束的可能！</p><h2 id="97e5" class="mw lx iq bd ly mx my dn mc mz na dp mg lf nb nc mi lj nd ne mk ln nf ng mm nh bi translated">结束游戏</h2><p id="5c7f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们现在将检查游戏是否已经结束。在<code class="fe ls lt lu lv b">draw</code>函数的顶部，添加以下代码:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="2fc1" class="mw lx iq lv b gy nm nn l no np">if (playerCount === 1) {<br/>  const alivePlayers = Player.allInstances.filter(p =&gt; p.dead === false);<br/>  outcome = `Player ${alivePlayers[0]._id} wins!`;<br/>} else if (playerCount === 0) {<br/>  outcome = 'Draw!';<br/>}</span><span id="d6e3" class="mw lx iq lv b gy nq nn l no np">if (outcome) {<br/>  console.log(outcome);<br/>  clearInterval(game);<br/>}</span></pre><p id="50fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦调用<code class="fe ls lt lu lv b">draw</code>函数，它将检查玩家人数是否已降至<code class="fe ls lt lu lv b">1</code>或<code class="fe ls lt lu lv b">0</code>。在<code class="fe ls lt lu lv b">1</code>，它宣布最后一名活着的玩家为获胜者。如果玩家数量下降到<code class="fe ls lt lu lv b">0</code>，则意味着剩余玩家在同一帧中死亡。</p><p id="9ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！您的结果现在应该被记录到控制台，但是当然，您可以将它发送到您喜欢的任何地方。你现在有一个功能游戏！</p><h1 id="cf74" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">第6步:结果和重置</h1><p id="d6ad" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">最后，不要简单地登录到控制台，让我们创建一个可视化的方法来告诉我们的玩家谁赢了，以及一个让他们重置游戏的方法。</p><p id="106a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用HTML创建我们的结果页面，但是我之前说过我们会坚持使用JavaScript，所以我已经走过了冗长的JavaScript路线…</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="5468" class="mw lx iq lv b gy nm nn l no np">function createResultsScreen(color) {<br/>  const resultNode = document.createElement('div');<br/>  resultNode.id = 'result';<br/>  resultNode.style.color = color || '#fff';<br/>  resultNode.style.position = 'fixed';<br/>  resultNode.style.top = 0;<br/>  resultNode.style.display = 'grid';<br/>  resultNode.style.gridTemplateColumns = '1fr';<br/>  resultNode.style.width = '100%';<br/>  resultNode.style.height = '100vh';<br/>  resultNode.style.justifyContent = 'center';<br/>  resultNode.style.alignItems = 'center';<br/>  resultNode.style.background = '#00000088'</span><span id="cf4a" class="mw lx iq lv b gy nq nn l no np">  const resultText = document.createElement('h1');<br/>  resultText.innerText = outcome;<br/>  resultText.style.fontFamily = 'Bungee, cursive';<br/>  resultText.style.textTransform = 'uppercase';</span><span id="069d" class="mw lx iq lv b gy nq nn l no np">  const replayButton = document.createElement('button');<br/>  replayButton.innerText = 'Replay (Enter)';<br/>  replayButton.style.fontFamily = 'Bungee, cursive';<br/>  replayButton.style.textTransform = 'uppercase';<br/>  replayButton.style.padding = '10px 30px';<br/>  replayButton.style.fontSize = '1.2rem';<br/>  replayButton.style.margin = '0 auto';<br/>  replayButton.style.cursor = 'pointer';<br/>  replayButton.onclick = resetGame;</span><span id="607f" class="mw lx iq lv b gy nq nn l no np">  resultNode.appendChild(resultText);<br/>  resultNode.appendChild(replayButton);<br/>  document.querySelector('body').appendChild(resultNode);</span><span id="4aaf" class="mw lx iq lv b gy nq nn l no np">  document.addEventListener('keydown', (e) =&gt; {<br/>    let key = event.keyCode;<br/>    if (key == 13) // 'Enter'<br/>      resetGame();<br/>  });<br/>};</span></pre><p id="455e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让reset按钮更加用户友好，我添加了一个事件监听器，这样就可以通过按下<code class="fe ls lt lu lv b">Enter</code>键来触发它。</p><p id="b38d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在需要一个<code class="fe ls lt lu lv b">resetGame</code>函数。因为我们将代码分解成可重用的函数，所以我们节省了大量的工作:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="e451" class="mw lx iq lv b gy nm nn l no np">function resetGame() {</span><span id="e30e" class="mw lx iq lv b gy nq nn l no np"><em class="nr">  // Remove the results node<br/>  </em>const result = document.getElementById('result');<br/>  if (result) result.remove();</span><span id="9b8d" class="mw lx iq lv b gy nq nn l no np"><em class="nr">  // Remove background then re-draw it<br/>  </em>context.clearRect(0, 0, canvas.width, canvas.height);<br/>  drawBackground();<br/>  <br/>  <em class="nr">// Reset playableCells<br/>  </em>playableCells = getPlayableCells(canvas, unit);</span><span id="0219" class="mw lx iq lv b gy nq nn l no np"><em class="nr">  // Reset players<br/>  </em>Player.allInstances.forEach(p =&gt; {<br/>    p.x = p.startX;<br/>    p.y = p.startY;<br/>    p.dead = false;<br/>    p.direction = '';<br/>    p.key = '';<br/>  });<br/>  playerCount = Player.allInstances.length;<br/>  drawStartingPositions(Player.allInstances);</span><span id="43cd" class="mw lx iq lv b gy nq nn l no np"><em class="nr">  // Reset outcome<br/>  </em>outcome = '';<br/>  winnerColor = '';</span><span id="8b7f" class="mw lx iq lv b gy nq nn l no np"><em class="nr">  // Ensure draw() has stopped, then re-trigger it<br/>  </em>clearInterval(game);<br/>  game = setInterval(draw, 100);</span><span id="96ad" class="mw lx iq lv b gy nq nn l no np">};</span></pre><p id="227f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，记得呼叫<code class="fe ls lt lu lv b">createResultsScreen</code>，回到我们呼叫<code class="fe ls lt lu lv b">console.log(outcome)</code>的地方。</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="b542" class="mw lx iq lv b gy nm nn l no np">if (outcome) {<br/>  createResultsScreen(winnerColor);<br/>  clearInterval(game);<br/>};</span></pre><p id="094d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样结束了！你现在有一个功能的双人游戏！</p><p id="d051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看这段代码的工作版本，请查看我的GitHub库:<a class="ae kv" href="https://github.com/BretCameron/tron-light-cylces" rel="noopener ugc nofollow" target="_blank">https://github.com/BretCameron/tron-light-cylces</a>。</p><h1 id="a154" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">接下来呢？</h1><p id="ccac" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">有很多方法可以扩展我们已经创建的代码。</p><p id="7ca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，对于四人游戏，您可以创建以下玩家:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="4934" class="mw lx iq lv b gy nm nn l no np">const p1 = new Player(unit * 6, unit * 6, 'blue');<br/>const p2 = new Player(unit * 43, unit * 43, 'red');<br/>const p3 = new Player(unit * 43, unit * 6, 'green');<br/>const p4 = new Player(unit * 6, unit * 43, 'orange');</span></pre><p id="02f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以编辑我们的<code class="fe ls lt lu lv b">handleKeyPress</code>功能，为我们的四个玩家提供以下控制:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="9fd2" class="mw lx iq lv b gy nm nn l no np">function handleKeyPress(event) {<br/>  let key = event.keyCode;<br/>  setKey(key, p1, 38, 39, 40, 37); <em class="nr">// arrow keys<br/>  </em>setKey(key, p2, 87, 68, 83, 65); <em class="nr">// WASD<br/>  </em>setKey(key, p3, 73, 76, 75, 74); <em class="nr">// IJKL<br/>  </em>setKey(key, p4, 104, 102, 101, 100); <em class="nr">// numpad 8456<br/></em>};</span></pre><p id="fccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种选择是通过调用<code class="fe ls lt lu lv b">new Image()</code>和<code class="fe ls lt lu lv b">new Audio()</code>来添加艺术和声音。</p><p id="a611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很想补充一点——但还没有掌握——电脑控制的播放器。到目前为止，我的尝试有一个习惯，那就是很快就会遇到问题。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="fc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章。特别是，如果你是HTML5画布或浏览器内游戏编码的新手，我希望这有助于向你展示什么是可能的。如果有任何问题，一定要留下评论！</p></div></div>    
</body>
</html>