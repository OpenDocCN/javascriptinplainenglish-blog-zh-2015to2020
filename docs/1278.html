<html>
<head>
<title>A Guide to Binary Trees (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树指南(第一部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-to-binary-trees-part-1-13660ade0343?source=collection_archive---------7-----------------------#2020-02-23">https://javascript.plainenglish.io/a-guide-to-binary-trees-part-1-13660ade0343?source=collection_archive---------7-----------------------#2020-02-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在编程领域中有许多类型的数据结构。大多数新程序员都知道诸如数组和散列之类的结构，但是另一方面，二叉树，尤其是对于一个新兵训练营的毕业生来说，并不为人所熟知和/或理解。本系列将解释什么是二叉树，为什么使用它们，以及如何遍历它们，并展示一些在它们的实现中的真实例子。</p><p id="facc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本系列的第1部分中，我们将讨论以下内容:</p><p id="0228" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是树？</p><p id="9bf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一棵树和二叉查找树有什么不同？</p><p id="2d85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何实现二叉查找树？</p><p id="b84f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，什么是树？</p><p id="b1a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">树是一种数据结构，这种数据结构由父子关系中的<strong class="jm io">节点</strong>组成，父子关系可以由任意数量的节点组成。更容易想象一棵真正的树是从一个“根”分支出来的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cbfb06d565b71dabdd95613db01af39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ikAYtbp7ljEkhEKz"/></div></div></figure><p id="305a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ku" href="https://unsplash.com/@mahkeo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马赫凯奥</a>在<a class="ae ku" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p><p id="aecc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个树节点可以指向多个节点或者根本没有节点！就像链表(另一种数据结构，我将在以后的文章中介绍)一样，我们可以在每个节点中存储数据。另一件要记住的事情是树是非线性的。</p><p id="d301" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是非线性？这意味着数据项不是按顺序组织的。换句话说，非线性数据结构的数据元素可以连接到一个以上的元素，以反映它们之间的特殊关系。非线性数据结构中的所有数据元素不能在一次运行中被遍历。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/e1bf82344a1647772898f5040ac665c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/0*HZjcr9FeRqjal5ta"/></div></figure><p id="cf98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个树形数据结构的例子</p><p id="1647" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，树和二叉查找树有什么区别？</p><p id="08d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以二叉查找树有几个不同的原因。首先，父节点不能有两个以上的子节点。同样，左边的子节点总是比父节点大&lt; than the parent node, while the right child will always be &gt;。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/8aa6cb6558bda28d1adbfbb4e7108688.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/0*rLspiY47hGj9Kpux"/></div></figure><p id="0962" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个真正的二叉查找树</p><p id="5147" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以让我们实现我们的树吧！</p><p id="d0c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们创建BinarySearchTree类并初始化根</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/89e8f8e3f9046c6a899a90dbb045f201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/0*76Ijk4Xj5OjVTeiA"/></div></figure><p id="b99b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根用null值初始化</p><p id="bb41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，让我们创建我们的节点类，并用值和拥有左右子节点的能力初始化它</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/11def9b4d8df91f98193734802e7c7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*NQy54CuyL0UUBtgA"/></div></figure><p id="585b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们将值插入我们的二叉查找树。但是首先，让我们伪代码我们的过程。</p><p id="5f4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个新节点。然后，从根节点开始，让我们检查是否有根节点，如果没有，那么根节点就变成了新的节点！如果有根，检查新节点的值是大于还是小于根的值。</p><ul class=""><li id="1394" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">如果它更大</li><li id="09c9" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">检查右侧是否有节点</li><li id="593e" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">如果有，移动到该节点并重复这些步骤</li><li id="0f59" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">如果没有，请将该节点添加为右侧属性</li><li id="b165" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">如果少…重复以上两步</li></ul><p id="d820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们用Javascript把它写出来</p><pre class="kj kk kl km gt ln lo lp lq aw lr bi"><span id="65a4" class="ls lt in lo b gy lu lv l lw lx">class Node {<br/>  constructor(val) {<br/>    this.val = val<br/>    this.left = null<br/>    this.right = null<br/>  }<br/>}class BST {<br/>  constructor() {<br/>    this.root = null<br/>  }<br/>  insert(val) {<br/>    let newNode = new Node(val);<br/>    if (this.root === null) {<br/>      this.root = newNode;<br/>      return this;<br/>    } else {<br/>      let current = this.root;<br/>      while (true){<br/>        if (val &lt; current.val) {<br/>          if (current.left == null){<br/>            current.left = newNode;<br/>            return this<br/>          } else { current = current.left}<br/>        } else if (val &gt; current.val) {<br/>          if (current.right == null){<br/>            current.right = newNode;<br/>            return this;<br/>          } else {current = current.right}<br/>        }<br/>      }<br/>    }<br/>  }<br/>}let tree = new BST()<br/>tree.insert(5)<br/>tree.insert(7)<br/>tree.insert(3)<br/>console.log(tree)</span></pre><p id="e6a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们做了第一棵树！在第2部分中，我们将学习如何使用几种不同的技术遍历树。我们还将讨论每种技术的重要时刻，并开始将我们的知识应用到现实世界的例子中。</p></div></div>    
</body>
</html>