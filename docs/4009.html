<html>
<head>
<title>3 Core React Concepts Every Web Developer Should Understand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Web开发人员都应该理解的3个核心概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-core-react-concepts-every-web-developer-should-understand-17c85648247b?source=collection_archive---------6-----------------------#2020-11-10">https://javascript.plainenglish.io/3-core-react-concepts-every-web-developer-should-understand-17c85648247b?source=collection_archive---------6-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7991" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">掌握这些将有助于你更容易地深入这个框架</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/71027e7debdaef2d02054c7afb7a4dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvGapKhj3D9sxW-OyVYV5Q.png"/></div></div></figure><p id="795e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在React中，您将学到许多概念。以下是你无论如何都应该理解的三个重要的核心概念。</p><p id="2e95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始吧。</p><h1 id="b2bc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">1.组件生命周期</h1><p id="62be" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">组件生命周期是React框架的核心概念。</p><p id="6c8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React应用程序由许多单独的组件组成。像这个世界上的所有东西一样，每个React组件都有自己的生命周期。这意味着他们出生，开始生活，然后在某个时候死去。</p><p id="78c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组件生命周期的每个部分都被定义为一个方法。当组件存在时，它们在不同的阶段被调用。</p><p id="3a26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">根据你正在处理的阶段，你将做特定的任务来达到特定的目的。</p><p id="9d41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，这些阶段是什么？</p><p id="e095" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1。componentWillMount() </strong></p><p id="111b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在呈现之前调用此方法。在屏幕上显示任何UI元素之前，使用这个方法来做好一切准备。</p><p id="7955" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组件尚未安装。这个阶段没有DOM。您不应该使用<code class="fe mk ml mm mn b">this.setState()</code>进行任何异步操作或更改数据。不用急，下一阶段你会全部做完的。</p><p id="d972" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2。componentidmount()</strong></p><p id="572a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一次<code class="fe mk ml mm mn b">render()</code>完成后，<code class="fe mk ml mm mn b">componentDidMount()</code>功能将被执行。这是变化可能发生的时候。</p><p id="2d55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您可以从API获取数据或更新状态。</p><p id="7c73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要在这个阶段修改数据，可以使用<code class="fe mk ml mm mn b">setState()</code>方法，这将触发另一个渲染。</p><p id="6858" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 3。componentwillreceiveprops()</strong></p><p id="12ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个阶段发生在道具更新之后，在执行下一个<code class="fe mk ml mm mn b">render()</code>之前<em class="mo">。</em></p><p id="1d5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 4。shouldComponentUpdate() </strong></p><p id="b484" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用此方法来确定组件是否应该更新。默认值为<code class="fe mk ml mm mn b">true</code>。</p><p id="d965" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了性能，如果你确定一个组件不需要更新，那么就返回<code class="fe mk ml mm mn b">false</code>。这样，它将保持与先前的状态相同，没有渲染发生。</p><p id="5107" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 5。componentWillUpdate() </strong></p><p id="a57c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此方法将在呈现前调用。</p><p id="4c5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6。componentDidUpdate() </p><p id="db65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">渲染后，将调用此方法。</p><p id="3ba8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您也可以在这个阶段更新DOM。但是请记住检查先前状态的属性更改，以确保不会出现无限循环。</p><p id="588b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">7。componentWillUnmount() </p><p id="61f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当组件从DOM中卸载时，这个方法将被调用。</p><p id="6e97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想释放任何资源，你应该使用这个方法。</p><h1 id="cbe8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">2.setState()</h1><p id="9fd6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">React应用程序初始化UI后，<code class="fe mk ml mm mn b">setState()</code>是唯一合法的更改UI的方式。</p><p id="b722" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有一个按钮，每次点击它的时候都需要更新标签。</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="94ff" class="mt lo iq mn b gy mu mv l mw mx">class Button extends React.Component {<br/>  constructor(props) {<br/>    super(props)</span><span id="77c5" class="mt lo iq mn b gy my mv l mw mx">    this.state = {<br/>      buttonLabel: ‘On’<br/>    };<br/>  }</span><span id="535a" class="mt lo iq mn b gy my mv l mw mx">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button&gt;{this.state.buttonLabel}&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="729b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按钮标签的初始值是<code class="fe mk ml mm mn b">On</code>，赋给<code class="fe mk ml mm mn b">this.state.buttonLabel</code>。我们将添加一个名为<code class="fe mk ml mm mn b">toggleButton()</code>的函数，并使用<code class="fe mk ml mm mn b">setState()</code>来更新<code class="fe mk ml mm mn b">buttonLabel</code>的值。</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="9131" class="mt lo iq mn b gy mu mv l mw mx">toggleButton() {<br/>  this.setState({ buttonLabel: this.state.buttonLabel === ‘On’ ? ‘Off’ : ‘On’ });<br/>}</span></pre><p id="6116" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们在<code class="fe mk ml mm mn b">render()</code>函数中处理按钮的点击事件。</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="7ef7" class="mt lo iq mn b gy mu mv l mw mx">&lt;button onClick={this.toggleButton.bind(this)}&gt;<br/>  { this.state.buttonLabel }<br/>&lt;/button&gt;</span></pre><p id="d3a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">整个实现应该如下所示:</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="fc08" class="mt lo iq mn b gy mu mv l mw mx">class Button extends React.Component {<br/>  constructor(props) {<br/>    super(props)</span><span id="8b2c" class="mt lo iq mn b gy my mv l mw mx">    this.state = {<br/>      buttonLabel: ‘On’<br/>    };<br/>  }</span><span id="c40a" class="mt lo iq mn b gy my mv l mw mx">  toggleButton() {<br/>    this.setState({ buttonLabel: this.state.buttonLabel === ‘On’ ?   <br/>                    ‘Off’ : ‘On’ });<br/>  }</span><span id="0708" class="mt lo iq mn b gy my mv l mw mx">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button onClick={this.toggleButton.bind(this)}&gt;<br/>          { this.state.buttonLabel }<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="2fdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们点击按钮时，会调用<code class="fe mk ml mm mn b">toggleButton()</code>功能。然后执行<code class="fe mk ml mm mn b">setState()</code>函数来更新<code class="fe mk ml mm mn b">buttonLabel</code>的值，这将触发UI的改变。</p><p id="bd32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也可以传递一个函数给<code class="fe mk ml mm mn b">setState()</code>而不是一个对象。</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="2003" class="mt lo iq mn b gy mu mv l mw mx">toggleButton() {<br/>  this.setState((prevState, props) =&gt; {<br/>    return {<br/>      buttonLabel: prevState.buttonLabel === ‘On’ ? ‘Off’ : ‘On’}<br/>    }<br/>  );<br/>}</span></pre><p id="eb5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么为什么要传递函数而不是对象呢？对象不是更简单吗？</p><p id="99f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，一个对象更简单。</p><p id="3202" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是你必须明白<code class="fe mk ml mm mn b">setState()</code>不会立即更新状态。它是异步的。为了获得更好的性能，React将把多个<code class="fe mk ml mm mn b">setState()</code>调用批处理成一个更新。因此，依赖当前状态可能会导致意想不到的结果。</p><p id="af13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="20c0" class="mt lo iq mn b gy mu mv l mw mx">increase() {<br/>  // Initialize this.state.counter = 1<br/>  this.setState({counter: this.state.counter + 1});<br/>  this.setState({counter: this.state.counter + 1});<br/>}</span></pre><p id="3b9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">调用<code class="fe mk ml mm mn b">increase()</code>后你期待什么结果？<code class="fe mk ml mm mn b">this.state.counter === 3</code>对吧？但事实并非如此。<code class="fe mk ml mm mn b">this.state.counter</code>的实际结果是<code class="fe mk ml mm mn b">2</code>，因为这两个<code class="fe mk ml mm mn b">setState()</code>调用是异步运行的。</p><p id="8daf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要修复它，请将一个函数传递给<code class="fe mk ml mm mn b">setState()</code>。该函数将以前的状态作为参数，并将对<code class="fe mk ml mm mn b">setState()</code>调用进行排队，以便它们按顺序运行。</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="fce9" class="mt lo iq mn b gy mu mv l mw mx">increase() {<br/>  // Initialize this.state.counter = 1<br/>  this.setState((prevState, props) =&gt; {<br/>    return { counter: prevState.counter + 1 }<br/>  });</span><span id="bfca" class="mt lo iq mn b gy my mv l mw mx">  this.setState((prevState, props) =&gt; {<br/>    return { counter: prevState.counter + 1 }<br/>  });<br/>}</span></pre><p id="5e30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这一次，<code class="fe mk ml mm mn b">this.state.counter</code>果然是<code class="fe mk ml mm mn b">3</code>。</p><p id="9324" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，当你像上面两个例子一样使用当前状态来设置新状态时，你应该传递一个函数。否则，为simpler传递一个对象。</p><h1 id="ec12" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">3.高阶组件</h1><p id="3e12" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可能会在函数式编程中听到高阶函数的概念。它是一个以其他函数作为参数并返回一个函数作为结果的函数。</p><p id="c701" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">说到反应，我们有一个类似的概念，高阶分量。这是一个接受一个组件并返回一个新组件的函数。</p><p id="9884" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个概念为您提供了基于现有组件创建新的扩展组件的能力，我们将保留它们的原始逻辑。</p><p id="b3bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><pre class="kg kh ki kj gt mp mn mq mr aw ms bi"><span id="5a26" class="mt lo iq mn b gy mu mv l mw mx">// LoadingHOC.jsx<br/>const addLoader = (data) =&gt; (WrappedComponent) =&gt; {<br/>  return class LoadingIndicator extends React.Component {<br/>    render() {<br/>      return data === null <br/>             ? &lt;Loader /&gt; <br/>             : &lt;WrappedComponent { ...this.props }/&gt;<br/>    }<br/>  }<br/>}</span><span id="2b8d" class="mt lo iq mn b gy my mv l mw mx">// UserList.jsx<br/>class UserLoader extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;UserListWithLoadingIndicator users={this.state.users} /&gt;<br/>    );<br/> }<br/>}</span><span id="b089" class="mt lo iq mn b gy my mv l mw mx">const UserList = ({ users }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      { /* show users */ }<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="8c5d" class="mt lo iq mn b gy my mv l mw mx">const UserListWithLoadingIndicator = addLoader(‘users’)(UserList);</span></pre><p id="ead0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面这个简单的例子中，我们检查了<code class="fe mk ml mm mn b">data</code>是否可用。如果它是空的，我们显示一个装载指示器，直到数据被更新。</p><p id="2469" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">HOC非常有用，因为它允许我们通过添加额外的特性来扩展现有的组件。这就像给基于Wordpress的博客添加插件的最小版本。</p><h1 id="d148" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="e7a5" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">那么，以上几点你都懂了吗？</p><p id="cca1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它们是React中的基本概念，在深入研究这个框架之前，您应该清楚地理解它们。</p><p id="a74b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后但同样重要的是，保持与官方文档的同步更新，因为它会不断变化。甚至一些生命周期方法现在也遭到了反对。自从2016年我第一次进入这个伟大的框架以来，它一直在不断发展和壮大。现在更成熟了。</p><p id="8759" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kt ir">！</strong></p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="323c" class="mt lo iq bd lp nh ni dn lt nj nk dp lx la nl nm lz le nn no mb li np nq md nr bi translated">进一步阅读</h2><div class="ns nt gp gr nu nv"><a href="https://medium.com/javascript-in-plain-english/11-javascript-concepts-every-web-developer-should-know-to-take-their-skills-to-the-next-level-37ef6693111a" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">每个Web开发人员都应该知道的11个JavaScript概念，让他们的技能更上一层楼</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">不了解这些概念，就无法掌握JavaScript。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div></div></div>    
</body>
</html>