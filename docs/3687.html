<html>
<head>
<title>JavaScript: Reverse Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:反向链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-reverse-linked-list-a2d235d64548?source=collection_archive---------2-----------------------#2020-10-18">https://javascript.plainenglish.io/javascript-reverse-linked-list-a2d235d64548?source=collection_archive---------2-----------------------#2020-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f3ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在许多公司，这是一个常见的面试问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/582077a65221e04be047282fa516f15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WB7STYW-yj02dHT3gieYkQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JJ Ying</a> on <a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本周，我们将从LeetCode的顶级面试问题列表中涵盖另一个流行的技术面试问题；<a class="ae kv" href="https://leetcode.com/problems/reverse-linked-list/" rel="noopener ugc nofollow" target="_blank">反向链表</a>:</p><p id="17ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">反转单链表。</em></p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="6959" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir">Example:</strong></span><span id="36ca" class="ly lz iq lu b gy me mb l mc md"><strong class="lu ir">Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br/><strong class="lu ir">Output:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></pre><p id="0261" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文不会给出很多关于链表的细节，但这里有一个快速复习:<strong class="ky ir">链表</strong>是表示一系列节点的数据结构，其中每个<strong class="ky ir">节点</strong>包含两条信息:节点的<strong class="ky ir">值</strong>和指向列表中下一个节点<strong class="ky ir">的指针/引用。列表的开头称为<strong class="ky ir">头</strong>，列表末尾的节点称为<strong class="ky ir">尾</strong>，指向空值；<strong class="ky ir">空</strong>。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/49771c0d63f2e5f0dda6f8f88edd284c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ReSYwX-z-n4jWPCRSxqBw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/data-structures/linked-list/</a></figcaption></figure><p id="4b96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与数组相比，链表的主要优点是更容易在列表中插入或移除节点。另一方面，不允许对数据进行随机访问，因为与数组不同，链表没有索引。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="4fa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的问题是要求我们写一个方法来原地反转一个单链表，并返回反转后链表的新头。列表的头部将作为输入给出。我们可以迭代或递归地反转一个链表，但是我们将通过以下步骤来重点解释今天的迭代方法:</p><ol class=""><li id="ee1e" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr ms mt mu mv bi translated">初始化三个指针；<code class="fe mw mx my lu b">prev</code>、<code class="fe mw mx my lu b">current</code>和<code class="fe mw mx my lu b">next</code>:</li></ol><ul class=""><li id="79cc" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr mz mt mu mv bi translated"><code class="fe mw mx my lu b">prev</code>:这个指针将跟踪当前节点的前一个节点，我们将把它设置为<code class="fe mw mx my lu b">null</code>，因为<em class="ls">一个单链表</em>节点没有对其前一个节点的引用。</li><li id="7063" class="mn mo iq ky b kz na lc nb lf nc lj nd ln ne lr mz mt mu mv bi translated"><code class="fe mw mx my lu b">current</code>:这个将从列表的<code class="fe mw mx my lu b">head</code>开始，跟踪我们当前所在的节点。</li><li id="0aca" class="mn mo iq ky b kz na lc nb lf nc lj nd ln ne lr mz mt mu mv bi translated"><code class="fe mw mx my lu b">next</code>:该指针将在其引用被改变之前存储下一个节点，并且最初被设置为<code class="fe mw mx my lu b">null</code>。</li></ul><p id="0ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.遍历所有节点，只要有一个节点就遍历列表，并在每次迭代中执行以下操作:</p><ul class=""><li id="b118" class="mn mo iq ky b kz la lc ld lf mp lj mq ln mr lr mz mt mu mv bi translated">将<code class="fe mw mx my lu b">next</code>设置为<code class="fe mw mx my lu b">current.next</code>(我们需要在改变之前存储电流的下一个节点)。</li><li id="4b8e" class="mn mo iq ky b kz na lc nb lf nc lj nd ln ne lr mz mt mu mv bi translated">将<code class="fe mw mx my lu b">current.next</code>设置为等于<code class="fe mw mx my lu b">prev</code>(我们现在可以通过反转链接来改变下一个电流)。</li><li id="d7db" class="mn mo iq ky b kz na lc nb lf nc lj nd ln ne lr mz mt mu mv bi translated">将<code class="fe mw mx my lu b">prev</code>设置为<code class="fe mw mx my lu b">current</code>(该步骤将前一个节点向前移动)。</li><li id="5911" class="mn mo iq ky b kz na lc nb lf nc lj nd ln ne lr mz mt mu mv bi translated">设置<code class="fe mw mx my lu b">current</code>等于<code class="fe mw mx my lu b">next</code>(该步骤将当前节点向前移动)。</li><li id="99b0" class="mn mo iq ky b kz na lc nb lf nc lj nd ln ne lr mz mt mu mv bi translated">对所有节点重复步骤2。</li></ul><p id="ef9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.返回<code class="fe mw mx my lu b">prev</code>指针作为反转列表的新头。</p><p id="1562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于以上所述，您可以看到我们的链表将如何在下面的图表的帮助下反转，我构建这个图表是为了让您更容易可视化:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/514263aa17ba7be5744c8051c9f937d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*GP_a_jF5Zjv1ZaFQJjZ69Q.jpeg"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/dd2838e73b4987b621f606e994d8257e.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*q9BJfeve07r1Fbc_SFObug.jpeg"/></div></figure><p id="a626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是上述逻辑在JavaScript中的实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c683a3e4dcaf2e76200780c168dcf16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*yCRRWPptGtXIc0Fa_PXHiw.png"/></div></figure><p id="e9de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的目标是用指向<code class="fe mw mx my lu b">head</code>的给定指针来反转链表。我们需要通过改变引用来反转列表，使下一个元素指向前一个元素。我们首先存储上一个和下一个元素的引用。当我们在循环中重新排列节点时，我们将当前节点的下一个值存储到我们的<code class="fe mw mx my lu b">next</code>变量中，因为我们不想在从<code class="fe mw mx my lu b">current</code>中断开该节点后丢失这个指针。然后，我们将当前节点的下一个指针设置为指向前一个节点，通过断开<code class="fe mw mx my lu b">current</code>和<code class="fe mw mx my lu b">current.next</code>之间的链接并将指针指向<code class="fe mw mx my lu b">prev</code>来实际反转值。接下来，我们将<code class="fe mw mx my lu b">prev</code>和<code class="fe mw mx my lu b">current</code>指针移位一个节点:<code class="fe mw mx my lu b">prev</code>更新到下一个节点(<code class="fe mw mx my lu b">current</code>),<code class="fe mw mx my lu b">current</code>更新到下一个节点(<code class="fe mw mx my lu b">next</code>)。它们在每次迭代中向前移动一步，直到<code class="fe mw mx my lu b">current</code>到达<code class="fe mw mx my lu b">null</code>并且while循环终止。最后，我们返回<code class="fe mw mx my lu b">prev</code>指针，它现在是循环结束时反向链表的新头。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="d7ee" class="ly lz iq bd ni nj nk dn nl nm nn dp no lf np nq nr lj ns nt nu ln nv nw nx ny bi translated">复杂性</h2><p id="c39e" class="pw-post-body-paragraph kw kx iq ky b kz nz jr lb lc oa ju le lf ob lh li lj oc ll lm ln od lp lq lr ij bi translated">迭代求解该算法导致<strong class="ky ir">的时间复杂度</strong>为<strong class="ky ir"> O(n) </strong>，因为我们只遍历列表一次(<code class="fe mw mx my lu b">n</code>是列表中的节点数)。这个解决方案的空间复杂度是O(1) ,因为我们的方法是就地反转列表，并且不使用任何额外的空间。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="dc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望本文中一个流行的链表面试问题的解决方案能有所帮助。感谢您的阅读！</p><p id="03c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>