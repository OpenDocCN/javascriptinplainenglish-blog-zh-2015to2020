<html>
<head>
<title>Maintainable JavaScript — Removing Methods and Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可维护的JavaScript —删除方法和继承</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/maintainable-javascript-removing-methods-and-inheritance-8915bea1adf5?source=collection_archive---------13-----------------------#2020-09-28">https://javascript.plainenglish.io/maintainable-javascript-removing-methods-and-inheritance-8915bea1adf5?source=collection_archive---------13-----------------------#2020-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f44f4fd091f94a324eb1d63cd97da520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iz37WQxrpBvZz6Xz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@joeyc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joe Caione</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="705c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想继续使用代码，创建可维护的JavaScript代码是很重要的。</p><p id="9221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过避免改变我们不拥有的对象来了解创建可维护的JavaScript代码的基础。</p><h1 id="8c3e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要删除方法</h1><p id="5f78" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从我们没有创建的对象中移除方法也很容易。</p><p id="2260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a88c" class="mn lc iq mj b gy mo mp l mq mr">document.getElementById = null;</span></pre><p id="06b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们制造了<code class="fe ms mt mu mj b">document.getElementById</code> <code class="fe ms mt mu mj b">null</code>。</p><p id="c8bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">getElementById</code>现在不再是一个功能。</p><p id="2e87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不能称之为。</p><p id="69bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们用<code class="fe ms mt mu mj b">delete</code>运算符调用删除属性。</p><p id="cee1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">delete</code>算子作用于正则对象，所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0f65" class="mn lc iq mj b gy mo mp l mq mr">let person = {<br/>  name: "james"<br/>};<br/>delete person.name;</span></pre><p id="f251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们去掉了<code class="fe ms mt mu mj b">name</code>属性，所以<code class="fe ms mt mu mj b">person.name</code>将是<code class="fe ms mt mu mj b">undefined</code>。</p><p id="9ccd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，此运算符对内置的库方法没有影响。</p><p id="b2a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="210c" class="mn lc iq mj b gy mo mp l mq mr">delete document.getElementById</span></pre><p id="583e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那没有效果。</p><p id="7aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">移除现有的方法绝对是一种糟糕的做法。</p><p id="2ac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发人员希望该对象具有库文档中描述的方法。</p><p id="e99d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现有的代码可能正在使用这些方法，因为每个人都希望它们在那里。</p><p id="baea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想删除一个方法，那么我们应该反对它们，这样它们就不会被用于新的代码，并且会从现有的代码中删除。</p><p id="19b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦它们都消失了，我们就可以移除它。</p><p id="f31a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">移除将是最后一步。</p><h1 id="4c3b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更好的解决方案</h1><p id="f22c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">修改对象绝对不是一个好主意。</p><p id="4515" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该采用一些常见的设计模式来避免修改我们不拥有的对象。</p><h1 id="3e82" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基于对象的继承</h1><p id="68eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">扩展现有对象的一种方法是创建一个新的对象，用我们想要的任何对象作为原型。</p><p id="1f85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ffdf" class="mn lc iq mj b gy mo mp l mq mr">const person = {<br/>  name: "jane",<br/>  sayName() {<br/>    console.log(this.name);<br/>  }<br/>};</span><span id="e65f" class="mn lc iq mj b gy mv mp l mq mr">const student = Object.create(person);</span></pre><p id="42bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称<code class="fe ms mt mu mj b">Object.create</code>为<code class="fe ms mt mu mj b">person</code>对象，以此作为<code class="fe ms mt mu mj b">student</code>对象的原型。</p><p id="f34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以在<code class="fe ms mt mu mj b">student</code>对象上调用<code class="fe ms mt mu mj b">sayName</code>，因为它是从<code class="fe ms mt mu mj b">person</code>继承的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1a46" class="mn lc iq mj b gy mo mp l mq mr">student.sayName();</span></pre><p id="2d40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe ms mt mu mj b">'jane'</code>日志。</p><p id="a30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在<code class="fe ms mt mu mj b">student</code>上通过书写定义我们自己的<code class="fe ms mt mu mj b">sayName</code>方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d60f" class="mn lc iq mj b gy mo mp l mq mr">const person = {<br/>  name: "jane",<br/>  sayName() {<br/>    console.log(this.name);<br/>  }<br/>};</span><span id="9a5b" class="mn lc iq mj b gy mv mp l mq mr">const student = Object.create(person);<br/>student.sayName = function() {<br/>  console.log('joe');<br/>}</span><span id="7efb" class="mn lc iq mj b gy mv mp l mq mr">student.sayName()</span></pre><p id="5eed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会看到<code class="fe ms mt mu mj b">'joe'</code>被记录而不是<code class="fe ms mt mu mj b">'jane'</code>。</p><p id="5eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦物体被创造出来，我们就拥有它。</p><p id="652c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以用它做任何我们想做的事情，而不会影响其他代码片段和使人困惑。</p><h1 id="100d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">基于类型的继承</h1><p id="614f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">基于类型的继承的工作方式类似于基于对象的继承。</p><p id="1281" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从原型继承属性。</p><p id="8db2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们创建子类或构造函数，而不是对象。</p><p id="4f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了ES6，我们可以使用<code class="fe ms mt mu mj b">extends</code>关键字创建子类。</p><p id="efa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来创建<code class="fe ms mt mu mj b">Error</code>的子类:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d504" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="c4d8" class="mn lc iq mj b gy mv mp l mq mr">class Author extends Person {}</span></pre><p id="63ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe ms mt mu mj b">Author</code>类，它是<code class="fe ms mt mu mj b">Person</code>的子类。</p><p id="9cd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">extends</code>关键字表明它是一个子类。</p><p id="70c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以灵活地创建对象。</p><p id="29a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在子类中定义任何新的属性和方法来扩展<code class="fe ms mt mu mj b">Person</code>类。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/30e323e5ab81810a973c505e57098f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IPhez1oCK8iJMbXq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@celine_sayuri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Celine Sayuri Tagami</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0cfb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9429" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该从我们不拥有的对象中移除方法，这样就不会有人感到困惑。</p><p id="f1ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不想破坏现有的代码。</p><p id="8aef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以扩展对象和类来创建我们想要的对象和类。</p></div></div>    
</body>
</html>