<html>
<head>
<title>Async vs Sync in Node.js: A Simple Benchmark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的异步与同步:一个简单的基准</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/async-vs-sync-nodejs-a-simple-benchmark-f99be70cab03?source=collection_archive---------8-----------------------#2020-07-05">https://javascript.plainenglish.io/async-vs-sync-nodejs-a-simple-benchmark-f99be70cab03?source=collection_archive---------8-----------------------#2020-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="71e0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Node.js中异步和同步模式的基准测试</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dd4c6e8a8c7467bb4338dc9d8cfd5e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZDn6R6Hlge9_DS5h.png"/></div></div></figure><p id="de69" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Async和sync可能是JavaScript开发人员听到最多的两个词，它们分别指异步和同步编程。JavaScript中的异步编程可以使用<code class="fe lk ll lm ln b">callbacks</code>、<code class="fe lk ll lm ln b">Promise</code>、<code class="fe lk ll lm ln b">async</code>和<code class="fe lk ll lm ln b">await</code>来完成。</p><p id="d1a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript借助<a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">事件循环</a>处理异步任务。我们知道它提高了性能，并且不会阻塞其余的代码。但是一切都是理论上的，我们怎么知道它真的能提高性能呢？</p><p id="7436" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过做一些基准测试！</p><p id="8577" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我们不会讨论如何异步或同步编程，相反，我们将针对<code class="fe lk ll lm ln b">sync</code>和<code class="fe lk ll lm ln b">async</code>方法运行一些基准测试。</p><p id="be41" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于测试用例，我们将使用具有sync和async方法的<code class="fe lk ll lm ln b">bcrypt</code>包来散列一个给定的字符串。我们还需要<code class="fe lk ll lm ln b">express</code>。</p><p id="78e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们从安装依赖项开始。</p><pre class="kd ke kf kg gt lp ln lq lr aw ls bi"><span id="a6ca" class="lt lu in ln b gy lv lw l lx ly">yarn add express bcrypt</span></pre><p id="ed9e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以下脚本可用于基准测试。</p><pre class="kd ke kf kg gt lp ln lq lr aw ls bi"><span id="2240" class="lt lu in ln b gy lv lw l lx ly">import express from 'express'<br/>import bcrypt from 'bcrypt'<br/><br/>const app = express()<br/><br/>app.get('/sync', (req, res) =&gt; {<br/>    let hashed = bcrypt.hashSync('secret', 10)<br/>    return res.send(hashed)<br/>})<br/><br/>app.get('/async', async (req, res) =&gt; {<br/>    let hashed = await bcrypt.hash('secret', 10)<br/>    return res.send(hashed)<br/>})<br/><br/>app.listen(3000, () =&gt; console.log('Server started on port 3000'))</span></pre><p id="4286" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个简单的express应用程序，有两条路径，都将返回字符串“secret”的散列值。<code class="fe lk ll lm ln b">/sync</code> route将使用<code class="fe lk ll lm ln b">bcrypt.hashSync()</code>方法同步散列值，而<code class="fe lk ll lm ln b">/async</code> route使用<code class="fe lk ll lm ln b">bcrypt.hash()</code>方法异步散列值。</p><p id="bc23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在可以使用<a class="ae lo" href="https://httpd.apache.org/docs/2.4/programs/ab.html" rel="noopener ugc nofollow" target="_blank"> apache bench </a>运行基准测试。</p><p id="5746" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lz"> Apache bench是一个HTTP服务器基准测试工具。</em></p><h1 id="1a99" class="ma lu in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">同步模式基准</h1><p id="8112" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">以下命令用于运行同步模式的基准测试。</p><pre class="kd ke kf kg gt lp ln lq lr aw ls bi"><span id="93d3" class="lt lu in ln b gy lv lw l lx ly">ab -k -c 20 -n 250 "http://localhost:3000/sync"</span></pre><p id="aa69" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您不知道上面的命令是做什么的，它只是简单地调用apache bench ( <code class="fe lk ll lm ln b">ab</code>)，使用要进行基准测试的URL(<a class="ae lo" href="http://localhost:3000/sync" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/sync</a>)作为输入，并使用一些选项(<code class="fe lk ll lm ln b">-k</code>、<code class="fe lk ll lm ln b">-c</code>、<code class="fe lk ll lm ln b">-n</code>)。</p><ul class=""><li id="3cdc" class="mw mx in kq b kr ks ku kv kx my lb mz lf na lj nb nc nd ne bi translated"><code class="fe lk ll lm ln b">-k</code> -启用HTTP KeepAlive功能</li><li id="a7c2" class="mw mx in kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne bi translated"><code class="fe lk ll lm ln b">-c</code> -一次执行多个请求的次数。</li><li id="f05f" class="mw mx in kq b kr nf ku ng kx nh lb ni lf nj lj nb nc nd ne bi translated"><code class="fe lk ll lm ln b">-n</code> -为基准测试会话执行的请求数量</li></ul><p id="b621" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">结果如下所示。</p><pre class="kd ke kf kg gt lp ln lq lr aw ls bi"><span id="e5da" class="lt lu in ln b gy lv lw l lx ly">Concurrency Level:      20<br/>Time taken for tests:   23.247 seconds<br/>Complete requests:      250<br/>Failed requests:        0<br/>Keep-Alive requests:    250<br/>Total transferred:      66250 bytes<br/>HTML transferred:       15000 bytes<br/>Requests per second:    10.75 [#/sec] (mean)<br/>Time per request:       1859.754 [ms] (mean)<br/>Time per request:       92.988 [ms] (mean, across all concurrent requests)<br/>Transfer rate:          2.78 [Kbytes/sec] received<br/><br/>Connection Times (ms)<br/>              min  mean[+/-sd] median   max<br/>Connect:        0    0   1.6      0      10<br/>Processing:    90 1783 414.3   1804    3655<br/>Waiting:       90 1783 414.4   1804    3655<br/>Total:         90 1783 414.5   1804    3655</span></pre><h1 id="3630" class="ma lu in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">异步模式基准</h1><p id="c898" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">现在让我们对异步模式进行基准测试。</p><pre class="kd ke kf kg gt lp ln lq lr aw ls bi"><span id="9417" class="lt lu in ln b gy lv lw l lx ly">ab -k -c 20 -n 250 "http://localhost:3000/async"</span></pre><p id="ec09" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">结果如下。</p><pre class="kd ke kf kg gt lp ln lq lr aw ls bi"><span id="11ab" class="lt lu in ln b gy lv lw l lx ly">Concurrency Level:      20<br/>Time taken for tests:   10.141 seconds<br/>Complete requests:      250<br/>Failed requests:        0<br/>Keep-Alive requests:    250<br/>Total transferred:      66250 bytes<br/>HTML transferred:       15000 bytes<br/>Requests per second:    24.65 [#/sec] (mean)<br/>Time per request:       811.281 [ms] (mean)<br/>Time per request:       40.564 [ms] (mean, across all concurrent requests)<br/>Transfer rate:          6.38 [Kbytes/sec] received<br/><br/>Connection Times (ms)<br/>              min  mean[+/-sd] median   max<br/>Connect:        0    0   0.5      0       3<br/>Processing:    97  776 120.5    802     874<br/>Waiting:       95  776 120.6    802     874<br/>Total:         97  776 120.3    802     874</span></pre><h1 id="e56e" class="ma lu in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">比较</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e610" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如你所见，<code class="fe lk ll lm ln b">async</code>模式比<code class="fe lk ll lm ln b">sync</code>模式表现更好。<code class="fe lk ll lm ln b">async</code>模式处理的请求/秒比<code class="fe lk ll lm ln b">sync</code>模式多，其时间/请求比<code class="fe lk ll lm ln b">sync</code>模式少。</p><h1 id="3a71" class="ma lu in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">结论</h1><p id="c0c9" class="pw-post-body-paragraph ko kp in kq b kr mr jo kt ku ms jr kw kx mt kz la lb mu ld le lf mv lh li lj ig bi translated">根据基准测试结果，<code class="fe lk ll lm ln b">async</code>模式在执行I/O时比<code class="fe lk ll lm ln b">sync</code>模式性能更好(即使测试用例不执行任何I/O操作)。使用<code class="fe lk ll lm ln b">bcrypt</code>散列是CPU密集型操作，当在异步模式下使用bcrypt散列字符串时，它使用线程池，不会阻塞事件循环。</p><p id="f0fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当您的代码需要执行一些阻塞I/O操作时，请始终使用<code class="fe lk ll lm ln b">async</code>模式，因为它不会阻塞事件循环。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="f3d5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lz">最初发表于</em><a class="ae lo" href="https://jinoantony.com/blog/async-vs-sync-nodejs-a-simple-benchmark" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://jinoantony.com</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>