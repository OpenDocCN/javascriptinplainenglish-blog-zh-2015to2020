<html>
<head>
<title>The Hardest Parts of Learning Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Angular最难的部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-hardest-parts-of-learning-angular-5b9ba1a4bbb6?source=collection_archive---------0-----------------------#2020-11-04">https://javascript.plainenglish.io/the-hardest-parts-of-learning-angular-5b9ba1a4bbb6?source=collection_archive---------0-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="da3c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">有角的</h2><div class=""/><div class=""><h2 id="df95" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Angular没有学习曲线，它有学习悬崖。但是哪些部分最难把握呢？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b12da004e90c7d49eaf850edcc39362b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQtPsHT-wxsEQjPNUNwiTg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Sitting on the Angular Learning Cliff</figcaption></figure><blockquote class="le"><p id="f998" class="lf lg iq bd lh li lj lk ll lm ln lo dk translated">“Angular适合初学者”</p><p id="c9ca" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">—没有一个人</p></blockquote><h1 id="9bf5" class="lu lv iq bd lw lx ly lz ma mb mc md me kf mf kg mg ki mh kj mi kl mj km mk ml bi translated">一个完整的JavaScript Web框架</h1><h2 id="88da" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">是什么让Angular与众不同？</h2><p id="9b8e" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">Angular是最流行的JavaScript框架之一。它由Google开发和维护，用于构建现代的单页应用程序(SPA)和渐进式Web应用程序(PWA)。</p><p id="a456" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">作为一个完整的框架，<strong class="nc ja">它拥有JavaScript web应用程序所需的一切。</strong></p><p id="e0d4" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">它提供了自以为是的架构，通过在组件、服务、指令、管道和模块之间划分应用程序结构，实现了关注点的完全分离。这些是提供独特特征和功能的不同类型的<code class="fe nx ny nz oa b">class</code>。这种架构使得可扩展的开发&amp;在大型团队中运行良好。</p><p id="3737" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><strong class="nc ja">它提供web开发的完整MVC</strong>。它提供了支持高级动态渲染的内置组件和模板，以及能够使用延迟加载来分割包大小的模块&amp;减少前期主包大小。</p><p id="c5c6" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">作为一名web开发人员，使用Angular可以继承所面临的最常见问题的解决方案。这些解决方案内置于框架中。这是它区别于React 和其他“聚焦视图”库<strong class="nc ja">的地方。</strong></p><p id="4346" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">Angular提供的开箱即用的最重要和最有价值的功能是Angular CLI、智能IDE工具、动态渲染、模板、依赖注入、AOT-JIT、路由、动画、通用服务器端渲染(SSR)、测试、可访问性、国际化、安全功能、PWA支持、Web-Workers等等。</p><p id="11ce" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><strong class="nc ja">这些内置功能和工具展示并鼓励以有角度的方式做事</strong>。这些都是你必须学会充分利用框架的东西。</p><h2 id="7cf2" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">TypeScript增加了复杂性</h2><p id="5db8" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">Angular的web开发概念方法是通过对常见有用的JavaScript模式进行高级抽象来实现的。对于使用Angular的web开发人员来说，这涉及到从这些抽象中学习语法。</p><p id="8744" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">对于那些不熟悉TypeScript或者还没有学习过它的人来说，<strong class="nc ja"> TypeScript对陡峭的学习曲线</strong>有很大的帮助。</p><p id="0351" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">Angular和TypeScript的结合有时让它感觉像是自己的编程语言。</p><p id="146a" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">它使用实验性的decorators为其NgModules和类类型提供注释，作为其架构的一部分。在Angular中，装饰器赋予类在应用程序中的用途。Angular中每个支持的类类型都用它的名字来修饰(例如<code class="fe nx ny nz oa b">@Component</code>)。</p><h2 id="9855" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">这需要心态的转变</h2><p id="efba" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">作为一名Angular开发新手，您发现您必须改变您的编程心态。这需要时间和一个令人沮丧的过程。它极大地降低了您的开发效率。</p><p id="1123" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><strong class="nc ja">这是由于……</strong>的综合作用</p><ul class=""><li id="06d6" class="ob oc iq nc b nd ns ng nt mr od mu oe mx of lo og oh oi oj bi translated">反应式方法</li><li id="9795" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">独特的架构(NgModules)</li><li id="2b3c" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">具有单一职责的角类(装饰者)</li></ul><blockquote class="op oq or"><p id="23fe" class="na nb os nc b nd ns ka nf ng nt kd ni ot nu nk nl ou nv nn no ov nw nq nr lo ij bi translated">这个想法是，当你熟悉这个框架时，你最终会收到你的投资回报(ROI)。</p></blockquote><p id="df4e" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">由于Angular CLI的脚手架功能，Angular ROI以快速应用程序开发的形式出现。</p><p id="1059" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">直到你熟悉了这个架构，并且自动知道什么时候应该使用<code class="fe nx ny nz oa b">Directive</code> vs <code class="fe nx ny nz oa b">Component</code> vs <code class="fe nx ny nz oa b">Service</code> vs <code class="fe nx ny nz oa b">Pipe</code>，没有什么可能是<strong class="nc ja"><em class="os"/></strong>。</p><p id="70eb" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">一旦你跨越了学习的悬崖，你会觉得你实际上又可以估计开发时间了(就像你平时一样)。你不太可能被Angular在《引擎盖下》中所做的事情绊倒。</p><p id="de3c" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">但在那之前，你必须经历学习角度最困难的部分。</p><blockquote class="le"><p id="2eb6" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">但是学习Angular最难的部分是什么？</p></blockquote><h1 id="6668" class="lu lv iq bd lw lx ly lz ma mb mc md me kf mf kg mg ki mh kj mi kl mj km mk ml bi translated">1)固执己见的架构和独特的语法</h1><p id="a2da" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">特定于角度的抽象提供了支持高级交互和功能的语法糖。这可以从使用TypeScript装饰器定义<strong class="nc ja">模块和组件</strong>的方式中看出。</p><p id="d84f" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">这意味着开发者省去了复杂性，将细节留在“引擎盖下”。</p><p id="71a7" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">Angular严重影响你构建项目的方式。获得Angular所能提供的最大价值意味着了解模块、组件、指令、服务、管道等之间的区别。这些是角度应用的基本部分。例如，在类的上方使用一个装饰符来表示它是一个<code class="fe nx ny nz oa b">@Component</code>还是一个<code class="fe nx ny nz oa b">@Directive</code>。</p><h2 id="f94a" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">组件和指令</h2><p id="074f" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">组件是角度应用程序的构建块。一个应用程序主要由许多组件组成。您通过组件模板编写UI，组件模板通过TypeScript类与业务逻辑进行交互。</p><p id="0812" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">Angular提供组件接口，通过实现函数来启用某些功能。这些可以以生命周期挂钩的形式出现，比如使用TypeScript接口实现的<code class="fe nx ny nz oa b">NgOnInit</code>。</p><p id="4a3b" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">对我来说，<strong class="nc ja">最难理解的是它是如何联系起来并组合成一个web应用程序的。</strong></p><p id="f27c" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">使用组件vs服务的时间很容易确定，一开始在组件vs指令之间选择有点困难，但是<strong class="nc ja">知道创建指令的正确情况是困难的。</strong></p><blockquote class="le"><p id="9472" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">我经常发现我自己增加了组件的复杂性，而我本应该将该功能指定给一个指令。</p></blockquote><p id="3428" class="pw-post-body-paragraph na nb iq nc b nd ow ka nf ng ox kd ni mr oy nk nl mu oz nn no mx pa nq nr lo ij bi translated">此外，指令可以是<strong class="nc ja">结构</strong>或<strong class="nc ja">属性</strong>指令<strong class="nc ja">。</strong></p><p id="699e" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">第一次使用指令时，通过指令与应用程序交互的方式是最难学习的。Angular通过更具体的语法和TypeScript装饰器(如<code class="fe nx ny nz oa b">@HostBinding</code>和<code class="fe nx ny nz oa b">@HostListener</code>)以独特的方式访问DOM和主机。</p><p id="8f2e" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">Angular中的指令是考虑DOM的一种独特方式，需要一些时间来适应。</p><h2 id="d392" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">接口</h2><p id="441f" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">Angular提供的接口使用起来相对简单，但是<strong class="nc ja">有几百个</strong>。困难在于知道在某些情况下应该实现哪个接口。了解可用的接口并将接口与某些功能相关联通常是通过花费在堆栈溢出或查看其他代码上的时间来积累的。</p><p id="5ad1" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">对于初学者来说，理解使用特定接口的正确环境几乎不可能从文档中推断出来。</p><h2 id="deae" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">模块</h2><p id="2d34" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">在Angular中，模块是<code class="fe nx ny nz oa b">@NgModule</code>的。有各种模块，如域功能模块、路由功能模块、路由模块、服务功能模块、小部件功能模块。了解其中的区别是很棘手的，因为肯定会有重叠，特别是如果您正在快速开发您的应用程序，或者没有无数开发人员来分担工作量。</p><blockquote class="op oq or"><p id="16da" class="na nb os nc b nd ns ka nf ng nt kd ni ot nu nk nl ou nv nn no ov nw nq nr lo ij bi translated">如果你不小心根据模块的类型来组织模块，你最终会创建复杂的混合模块，这些模块几乎可以做任何事情。</p></blockquote><h2 id="9a53" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">Angular文档引用了这些模块类型:</h2><ul class=""><li id="d9ab" class="ob oc iq nc b nd ne ng nh mr pb mu pc mx pd lo og oh oi oj bi translated">领域功能模块。</li><li id="b5b7" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">布线特征模块。</li><li id="ed06" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">路由模块。</li><li id="3f96" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">服务功能模块。</li><li id="a145" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">小部件功能模块。</li></ul><p id="15b0" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">了解这些类型之间的区别以及它们应该是什么样子，将会提高可读性以及其他开发人员对应用程序的理解。这也有助于重构和调整你的应用程序。当您想要重构应用程序的某些部分时，知道从哪里开始可以节省时间。</p><h2 id="1065" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">服务和依赖注入</h2><p id="e894" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">另一方面，服务非常容易理解。<strong class="nc ja">它们应该包含“业务逻辑”。</strong></p><p id="8454" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">为每个特定目的创建一个新服务。这意味着他们应该严格遵守单一责任原则。如果您想要一个服务来处理身份验证，您可以称它为<code class="fe nx ny nz oa b">AuthService</code>并且它将专门处理身份验证，<strong class="nc ja">仅此而已</strong>。如果您决定需要处理用户操作，您应该创建一个名为<code class="fe nx ny nz oa b">UserService</code>的新服务。</p><blockquote class="le"><p id="beaf" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">服务应该是<a class="ae pe" href="https://dzone.com/articles/software-design-principles-dry-and-kiss" rel="noopener ugc nofollow" target="_blank">干的</a>(不要重复自己)</p></blockquote><p id="90f1" class="pw-post-body-paragraph na nb iq nc b nd ow ka nf ng ox kd ni mr oy nk nl mu oz nn no mx pa nq nr lo ij bi translated">服务是通过依赖注入初始化的类。</p><p id="e948" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">要使用服务，通过<code class="fe nx ny nz oa b">constructor</code>将服务作为依赖注入，就像<code class="fe nx ny nz oa b">constructor (private authService: AuthService)</code>一样。</p><p id="6cdc" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">此后，您将通过<code class="fe nx ny nz oa b">this.authService</code>进入<code class="fe nx ny nz oa b">AuthService</code>。</p><p id="19b3" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">将服务视为“业务逻辑”可以很容易理解何时使用服务。</p><p id="ce2c" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">虽然这很容易概念化，但<strong class="nc ja">服务会变得复杂。</strong></p><h2 id="5c38" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">服务的复杂性</h2><p id="883f" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">当服务相互交互以及与应用程序的其他部分交互时，服务变得复杂起来。起初，服务的提供者范围可能很难理解。</p><p id="8286" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">最终，有两种类型的服务:</p><ul class=""><li id="d24d" class="ob oc iq nc b nd ns ng nt mr od mu oe mx of lo og oh oi oj bi translated">一个</li><li id="c8b8" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">非独生子女</li></ul><h2 id="e8c9" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">一个</h2><p id="9848" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">Singleton Services是应用程序范围的服务，在应用程序中只有一个服务实例。这意味着当在不同的组件中使用服务时，您将共享变量；<strong class="nc ja">您正在使用相同的实例</strong>。</p><p id="dac7" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">您可以使用服务装饰器<code class="fe nx ny nz oa b">providedIn: 'root'</code>创建应用程序范围的服务。或者您可以将其保留为<code class="fe nx ny nz oa b">providedIn: 'any'</code>，Angular将自动将其实例化为单例，此外，如果它没有被当前的捆绑包使用，那么您将从树摇动中受益。</p><h2 id="6867" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">非单身</h2><p id="5e17" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">在整个应用程序中，非单例服务可以有同一个服务的多个实例。这意味着当在两个不同的组件中使用服务时，不会共享变量。</p><p id="c29c" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">在组件或指令元数据(装饰器)中使用<code class="fe nx ny nz oa b">providers: [UserService]</code>将提供一个新的服务实例。</p><p id="3cff" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">因此，您可以通过单例、非单例和应用程序的其余部分之间的交互来了解复杂性会出现在哪里。</p><p id="e0a6" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">很重要的一点是，要明确一个服务是否应该是单例的。您的大多数服务可能是单个的，所以这应该会在一定程度上限制复杂性。</p><h1 id="7f6b" class="lu lv iq bd lw lx ly lz ma mb mc md me kf pf kg mg ki pg kj mi kl ph km mk ml bi translated">2)动态模板引擎</h1><p id="5693" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">Angular的主要特点之一是其独特的HTML模板，集成了定制元素，类似于XML。<strong class="nc ja">你与这些HTML模板的交互方式是特定于角度的</strong>，与React或其他流行框架中的交互方式不同。Angular提供自定义属性和HTML元素，支持HTML的动态呈现。</p><p id="487a" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">对有角度的HTML元素的依赖意味着需要学习一些新概念。这些是<code class="fe nx ny nz oa b">ng-content</code>、<code class="fe nx ny nz oa b">ng-container</code>和<code class="fe nx ny nz oa b">ng-template</code>。这些为DOM提供了不同的功能。然而，它们的共同点是都引用DOM中的一个元素。</p><blockquote class="op oq or"><p id="8678" class="na nb os nc b nd ns ka nf ng nt kd ni ot nu nk nl ou nv nn no ov nw nq nr lo ij bi translated">这些元素看起来就像魔法一样，直到你完全理解它们是如何“在引擎盖下”工作的。</p></blockquote><h2 id="2a1b" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">ng内容、ng容器、ng模板之间的区别</h2><p id="9c8f" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">它们用于向Angular指示动态加载组件的位置。</p><h2 id="cff5" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated"><code class="fe nx ny nz oa b">ng-content</code></h2><p id="cbdc" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">这用于内容投影。这对于构建可重用的组件是必不可少的。它允许您通过从外部投影到组件中来扩展和定制组件。</p><h2 id="3453" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated"><code class="fe nx ny nz oa b">ng-container</code></h2><p id="2f0e" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">这是不干扰DOM的分组元素。它只是被插入到被引用的地方。基于条件和模板表达式排除和包含HTML是最简单的方法。可以在<code class="fe nx ny nz oa b">if else</code>语法和模板变量中用<code class="fe nx ny nz oa b">ng-container</code>引用<code class="fe nx ny nz oa b">ng-templates</code>。</p><h2 id="4b94" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">ng模板</h2><p id="4006" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">这用于保存模板引用。您可以在<code class="fe nx ny nz oa b">ng-template</code>中包装一个模板，通过使用它的模板引用有条件地将其插入DOM。</p><blockquote class="op oq or"><p id="26fe" class="na nb os nc b nd ns ka nf ng nt kd ni ot nu nk nl ou nv nn no ov nw nq nr lo ij bi translated">没有通过条件显示的元素被保存为一个<code class="fe nx ny nz oa b">ng-template</code>，直到它们被有条件地插入。</p></blockquote><p id="44da" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><strong class="nc ja">结构化指令是根据业务逻辑和应用程序数据有条件地将元素插入DOM </strong>的最有用的方法。</p><p id="9852" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">它们包括:</p><ul class=""><li id="a8c1" class="ob oc iq nc b nd ns ng nt mr od mu oe mx of lo og oh oi oj bi translated">NgIf</li><li id="633c" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">NgFor</li><li id="68d7" class="ob oc iq nc b nd ok ng ol mr om mu on mx oo lo og oh oi oj bi translated">NgSwitch</li></ul><blockquote class="op oq or"><p id="62e6" class="na nb os nc b nd ns ka nf ng nt kd ni ot nu nk nl ou nv nn no ov nw nq nr lo ij bi translated">如果这些没有提供您想要的功能，您甚至可以自己编写。</p></blockquote><p id="8cf6" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">与任何单页面应用程序(SPA)一样，动态呈现是应用程序的核心。它描述了HTML动态插入DOM的方式。理解Angular在幕后是如何工作的，使得开发Angular应用程序变得简单明了，并且尽可能地可预测。</p><p id="eacd" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">但是同样，Angular做了很多“幕后”的事情，让你作为开发人员的生活变得更容易。因此，<strong class="nc ja">事情一开始并不那么容易预测</strong>。</p><h1 id="178b" class="lu lv iq bd lw lx ly lz ma mb mc md me kf pf kg mg ki pg kj mi kl ph km mk ml bi translated">3) RXJS烘焙</h1><p id="f894" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">在整个Angular框架中，都依赖于<a class="ae pe" href="https://github.com/ReactiveX/rxjs" rel="noopener ugc nofollow" target="_blank"> RxJS库</a> (JavaScript反应式扩展)。</p><p id="e81a" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">你基本上可以假设RXJS是Angular的一部分。原因是Angular本身就是用RXJS搭建的。</p><p id="c021" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><strong class="nc ja">你无法逃避它。</strong></p><p id="7a37" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">由于这个原因，当你开始学习Angular时，你会立即注意到对反应式编程的强调。这是一个观察和承诺无处不在的框架。您将看到在HTTP客户端、路由器事件和其他Angular提供的服务中使用的Observables。</p><p id="27f5" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">你会注意到，如果不处理数据流，你将一事无成<strong class="nc ja">，这并不是一件坏事</strong>。</p><p id="f0d1" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">但是，它确实逼着你深入学习RxJS特别是Angular与数据流交互的方式。</p><p id="686e" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">虽然RXJS很棒，而且对于Angular中的反应式编程来说是必不可少的，但是它极大地缩短了学习曲线。</p><blockquote class="op oq or"><p id="d261" class="na nb os nc b nd ns ka nf ng nt kd ni ot nu nk nl ou nv nn no ov nw nq nr lo ij bi translated">单独学习RXJS是很费时间的，<strong class="nc ja">所以同时学习Angular和RXJS必然是一个令人生畏的过程。</strong></p></blockquote><p id="5911" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">起初，RxJS的核心概念很容易掌握，但你会遇到未被发现的错误，几天后你会抓耳挠腮，最终意识到你并没有像在RXJS上想象的那样牢固掌握。</p><p id="7093" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">随着代码开始变得越来越复杂，RXJS操作符的内部工作方式将会让你措手不及。</p><blockquote class="le"><p id="e673" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">如果你对RXJS运算符做出假设，你最终会被发现</p></blockquote><p id="8a1a" class="pw-post-body-paragraph na nb iq nc b nd ow ka nf ng ox kd ni mr oy nk nl mu oz nn no mx pa nq nr lo ij bi translated">如果你不熟悉数据流，这需要改变思维模式。虽然RxJS是特定于JavaScript的，<a class="ae pe" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"><strong class="nc ja">react vex</strong></a>，但是包含RxJS、Rx.NET和RxJava等实现的库很可能有您的语言的实现。所以你可能熟悉反应式编程和处理数据流。</p><p id="a2de" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">处理数据流本身并不困难。困难的部分是理解操作者如何工作。很难理解RxJS操作符是如何转换数据流和修改行为的。</p><p id="61fb" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">调试RxJS流时，不仅要观察发出的数据，还要观察发出的顺序、时间、数据类型以及其他方面的行为。</p><p id="4dd0" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">如果您没有完全理解RxJS，这可能会使调试您的应用程序变得困难。为了调试您的代码，您必须理解预期的行为，以及实际的行为是如何偏离的，以便能够有效地进行测试。</p><h2 id="0184" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">角度反应式编程</h2><p id="c0ab" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">反应式编程意味着把一切都看成是异步的，对随时间发生的事件做出反应，而不一定是按顺序。你认为数据是从数据流中产生的，带有可观察到的信息，并承诺一直到达目的地。</p><p id="3fe3" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">在Angular中，这意味着从API一直到模板的<strong class="nc ja">。</strong></p><blockquote class="le"><p id="0163" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">你越早意识到一切都应该是一条溪流，越好</p></blockquote><p id="18ac" class="pw-post-body-paragraph na nb iq nc b nd ow ka nf ng ox kd ni mr oy nk nl mu oz nn no mx pa nq nr lo ij bi translated">在任何实际工作进入应用程序之前认识到数据流的重要性意味着您可以从一开始就使用'<strong class="nc ja"> RxJS </strong> x <strong class="nc ja"> Angular </strong>最佳实践，构建真正的端到端反应式应用程序。</p><blockquote class="le"><p id="3a28" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">在这个上下文中，端到端意味着数据开始和结束都是通过模板中的<code class="fe nx ny nz oa b">async</code>管道解包的可观察数据；避免手动订阅。</p></blockquote><p id="1403" class="pw-post-body-paragraph na nb iq nc b nd ow ka nf ng ox kd ni mr oy nk nl mu oz nn no mx pa nq nr lo ij bi translated">幸运的是，Angular是一个鼓励反应式编程的框架。在使用RxJS和Angular时，您将开始意识到作为标准库一部分的<code class="fe nx ny nz oa b">async</code>管道是您最常用的Angular管道之一。</p><p id="0d78" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><strong class="nc ja">在Angular中，异步管道是端到端反应式应用的最佳工具。在你的模板中使用<code class="fe nx ny nz oa b">data$ | async</code>可以自动处理观察值的订阅和取消订阅。</strong></p><p id="fcb9" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">在RxJS中，防止在组件类中使用<code class="fe nx ny nz oa b">subscribe()</code>手动订阅是一个众所周知的最佳实践。异步管道是符合这一最佳实践的最佳工具。RxJS提供了一个全面的库，其中包含用于转换、组合、创建和过滤数据流的操作符，因此大多数时候您应该能够找到一种方法来防止手动订阅。</p><p id="607e" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">您需要了解<a class="ae pe" href="https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339" rel="noopener">热和</a>冷观察值之间的区别，RxJS流的<a class="ae pe" href="https://rxmarbles.com/" rel="noopener ugc nofollow" target="_blank">大理石图</a>，组件的不同方法(智能或非智能)，以及如何实现端到端的反应式web应用程序。</p><p id="aded" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">开始了解RxJS的最佳途径是通过<a class="ae pe" href="http://learnrxjs.io" rel="noopener ugc nofollow" target="_blank"> learnrxjs </a>。</p><div class="pi pj gp gr pk pl"><a href="https://www.learnrxjs.io/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ja gy z fp pq fr fs pr fu fw iz bi translated">介绍</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">是当今web开发中最热门的库之一。提供强大的功能方法来处理…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">www.learnrxjs.io</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ky pl"/></div></div></a></div><p id="ce8d" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">如果您更喜欢视觉学习，可视化数据流和RxJS操作符的一个好方法是通过大理石图。</p><p id="8e5a" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">大理石图显示了发射的顺序以及运算符如何影响可观测数据流的行为。</p><div class="pi pj gp gr pk pl"><a href="https://rxmarbles.com/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ja gy z fp pq fr fs pr fu fw iz bi translated">Rx marbles:Rx可观测量的交互图</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">在可观测量上学习、构建和测试Rx函数</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">rxmarbles.com</p></div></div></div></a></div><h1 id="5a3c" class="lu lv iq bd lw lx ly lz ma mb mc md me kf pf kg mg ki pg kj mi kl ph km mk ml bi translated">最重要的是心态的转变</h1><p id="b408" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">由于Angular给web开发带来了一系列的新概念，思维模式需要转变。Angular的工作方式鼓励采用反应性方法，并以RxJS作为反应性催化剂。</p><p id="ab38" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">除了新概念、方法、语法和RxJS，您还必须考虑影子DOM。<strong class="nc ja">Angular用“Angular方式”做任何事情的原因是因为shadow DOM和NgZone </strong>。</p><blockquote class="le"><p id="e522" class="lf lg iq bd lh li lp lq lr ls lt lo dk translated">NgZone是跨异步任务持续存在的执行上下文</p></blockquote><p id="eab2" class="pw-post-body-paragraph na nb iq nc b nd ow ka nf ng ox kd ni mr oy nk nl mu oz nn no mx pa nq nr lo ij bi translated">Angular在与DOM交互时提供解决方案，因为它确保任务在Angular区域内执行。这对变化检测很重要。</p><p id="9bd9" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><strong class="nc ja">不在区域内执行的任务有被Angular检测不到的风险。</strong>这意味着由于Angular使用shadow DOM和NgZone的方式，对DOM的更新不会如期进行。</p><p id="e69a" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">NgZone的存在为开发应用程序提供了一个额外的视角。这意味着你必须考虑任务是“在范围内”还是“在范围外”。</p><p id="713f" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">这也意味着你很少会偏离Angular的做事方式而不在不知不觉中产生一个bug。它迫使你学习Angular的做事方式，并完全遵循Angular的web开发方法。因此，你不能真的推迟学习Angular的某些部分。</p><p id="7683" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">当开始学习Angular时，一开始一切都似乎很陌生，尤其是如果你来自纯JavaScript背景。如果你习惯了打字稿，会有一些熟悉，但就连你也未必能幸免。</p><p id="ee39" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">使用Angular构建web应用程序最终是有回报的，但前提是你已经搞清楚了什么是“幕后”。</p><h2 id="8e24" class="mm lv iq bd lw mn mo dn ma mp mq dp me mr ms mt mg mu mv mw mi mx my mz mk iw bi translated">学习Angular之前你应该知道什么</h2><p id="2833" class="pw-post-body-paragraph na nb iq nc b nd ne ka nf ng nh kd ni mr nj nk nl mu nm nn no mx np nq nr lo ij bi translated">作为一个初学棱角分明的人，<strong class="nc ja">认知超负荷会是一种熟悉的心理状态。</strong></p><p id="c144" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">但是一旦你掌握了语法，隐藏在引擎盖下的东西将会困扰你。</p><p id="0c5f" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">不幸的是，你不知道它什么时候会绊倒你，知道Angular中什么是重要的唯一方法是通过亲身经历。</p><p id="0841" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">这意味着一次又一次的失败。这需要耐心。</p><p id="cd41" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated">但是<strong class="nc ja">一旦你解决了，一切都开始变得有意义，</strong>回报是巨大的。</p><p id="aa91" class="pw-post-body-paragraph na nb iq nc b nd ns ka nf ng nt kd ni mr nu nk nl mu nv nn no mx nw nq nr lo ij bi translated"><em class="os">感谢阅读！有任何问题，请在评论中告诉我。</em></p></div></div>    
</body>
</html>