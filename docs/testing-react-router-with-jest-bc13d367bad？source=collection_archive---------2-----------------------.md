# 用 Jest 测试 React 路由器

> 原文：<https://javascript.plainenglish.io/testing-react-router-with-jest-bc13d367bad?source=collection_archive---------2----------------------->

## 如何编写单元测试来检查您是否使用 React Router with Jest 正确地路由请求

![](img/8d004544c9c183bf91ce9d963903aeb4.png)

Photo by [Jean-Philippe Delberghe](https://unsplash.com/@jipy32?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

编写一个单元测试来检查 React Router 是否被正确配置为在您的应用程序中路由请求，这看起来很简单。不可否认，这样做并不需要太多代码。但这并不意味着很容易弄清楚。我的在线搜索没有产生任何现成的代码示例，我花了几个小时试图为这个问题找到一个像样的解决方案。

如果你正面临同样的挑战，以下是你需要注意的地方。请注意，该解决方案是为使用功能组件的 React 应用程序编写的。所以如果你正在使用类组件，你可能需要稍微调整一下。

第一部分将解释我得出的最终解决方案。后面的章节将关注潜在的问题，并提供一个更深入的解释，解释为什么我最终会以我的方式做事。

# 解决方案的想法

本文要测试的应用程序包含以下`App.js`文件:

应用程序的 PageHeader 组件针对每条路线进行渲染。`HomePage`、`ArticlePage`和`AuthorPage`每个都有与该页面匹配的指定路线。如果路线不匹配，就会显示一个`PageNotFound`组件。这是测试应该涵盖的预期行为。

正如简介中提到的，所有列出的组件都是作为 React 中的功能组件实现的。

将请求路由到所需组件的单元测试不应该测试或依赖于组件的内容。这是一个独立的行为，应该在每个单独组件的单元测试中进行测试。

这个解决方案背后的想法是通过模仿组件来避免对组件的依赖。为了查看是否呈现了正确的组件，我设置了模拟来返回硬编码的字符串，而不是它们的正常值。每个组件返回不同的硬编码字符串。然后，测试断言，在呈现某个路由的`App`时，可以在呈现结果中找到属于适当组件的硬编码字符串。

由于`PageHeader`总是被渲染而不考虑路线，我决定在每个测试中检查它的存在。然而，创建一个单独的测试，只检查`PageHeader`是否被渲染，并从其他测试中忽略它，在这种情况下也是一个有效的解决方案。

下面是如何实现这一点的逐步指南。

# 履行

首先，我们需要模拟路由器路由到的所有组件的模块。包含组件的模块需要导入，然后使用`jest.mock`功能模拟。

之后，我们可以开始为具体的例子编写测试。第一个测试将检查在没有指定路线(意味着路线是`“/”`)时`HomePage`组件和`PageHeader`是否被渲染。

安排这个测试的第一步是将`HomePage`和`PageHeader`的返回值模拟成硬编码的字符串值，以便我们以后搜索。注意不要对它们使用相同的值，因为这样会使测试无效。

注意，`mockImplementation`调用是在测试中进行的，硬编码的字符串被包装在`div`中。这两者都是解决方案正常工作所必需的，我将在后面的章节中解释原因。

一旦模拟完成，我们就可以调用`render`函数。为了将路径传递给`App`组件，我使用了一个`MemoryRouter`。`MemoryRouter`有一个名为`initialEntries`的参数，它将一组初始路线作为输入。如果没有给定路径，`App`应该呈现用于空路径的组件`“/”`。

在这种情况下，我们不需要向 MemoryRouter 传递任何东西，因为我们想要测试默认路由的行为。

最后，我们通过断言在呈现的文档中有一个包含我们之前设置的字符串的元素，来检查是否呈现了正确的组件。

下面是测试`App.js`中所有组件的完整代码。对于其他组件，`MemoryRouter`的`initialEntries`参数被填充了适当的路线。对于`PageNotFound`组件，可以使用任何不属于另一个组件的路线。

如果你想了解创建这个解决方案的背景，你可以在这里查看应用程序的 git 库。

这个解决方案的一个小缺点是，理论上，`App.js`(或另一个组件)可以包含一个具有相同硬编码字符串的元素，该字符串被设置为 mock 的返回值。因此，测试将是无效的，因为它可以找到具有给定文本的元素，而不管组件模拟是否已经被呈现。所以你不应该从你的应用程序中选择一个现有的文本作为测试中的硬编码字符串。

# 为什么文本要用 div 包装？

它不一定是一个`div`，但是 mock 返回的文本应该包装在一个单独的 HTML 元素中。元素不应该包含除文本以外的任何内容。

`screen.getByText`函数寻找一个 HTML 元素，它包含给定文本的精确匹配，并且不包含任何其他内容。(这种行为可以通过传递不同的选项来修改。更多细节见[文档](https://testing-library.com/docs/dom-testing-library/api-queries)。)

我最初试图匹配精确的文本，但是没有将返回值包装在 HTML 元素中，如下所示。

这种方法的问题是`PageHeader`和`HomePage`在`App.js`的同一个容器中呈现。这意味着 redner 的结果将看起来像这样:

容器元素现在包含了`PageHeader` mock 和`HomePage` mock 的文本。所以`screen.getByText`不会认为这个容器是匹配的。

# 为什么在每个测试中都要调用 mockImplementation 函数？

如果您查看上面测试的最终代码，您会注意到在每个测试中都调用了`mockImplementation`函数来模拟返回值。这为`PageHeader`模拟引入了相当多的冗余(和出错的空间)。它被设置为在每次测试中返回相同的值。

为模拟创建一个全局定义不是更好吗？还是只在 describe 部分定义一次？

我两者都尝试过，但没有成功。它产生一条错误消息，指出:`Invalid variable access: _jsxFileName`。

在撰写本文时，GitHub 上有一个针对此问题的[未决问题。](https://github.com/facebook/create-react-app/issues/9896)

# 检查组件是否已呈现

我最初的想法是直接测试渲染`App`是否会为选定的路线渲染合适的组件。这是一个稍微好一点的解决方案，因为它避免了将硬编码的字符串作为返回值添加到模拟组件中，然后搜索它们。

然而，我找不到一种方法来模拟 React 中的功能组件，然后检查模拟是否在测试中呈现。

我在网上找到的测试这种功能的解决方案主要是使用酶。他们中的大多数人建议使用 Enzyme 的`shallow`函数来渲染父组件(在本例中为`App`)。然而，浅层对 React 路由器不起作用——深度渲染对测试这一点是必要的。

我发现了一篇关于如何使用 Jest 和 Enzyme 测试路由器的文章，这篇文章使用了 Enzyme 的`mount`函数。该函数应该使您能够执行深度渲染，并检查是否渲染了正确的组件。

如果你在开玩笑的时候使用酶，[这篇文章](https://medium.com/@antonybudianto/react-router-testing-with-jest-and-enzyme-17294fefd303)可能是有用的读物。

本文的评论部分还包含一些有趣的潜在改进。但是，要注意文章是 2017 年写的。

# 结束语

我希望这篇文章对你有所帮助。如果您有改进此解决方案的建议，请随时联系我。我可能会用潜在的改进或人们可能面临的问题来更新文章。

感谢您的阅读。