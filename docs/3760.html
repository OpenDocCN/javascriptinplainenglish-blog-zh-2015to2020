<html>
<head>
<title>How to Create a Dynamic Sitemap using Firestore and Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Firestore和云功能创建动态网站地图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-dynamic-sitemap-using-firestore-and-cloud-functions-5ff05fc2c9d8?source=collection_archive---------0-----------------------#2020-10-23">https://javascript.plainenglish.io/how-to-create-a-dynamic-sitemap-using-firestore-and-cloud-functions-5ff05fc2c9d8?source=collection_archive---------0-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f7fa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Firebase Firestore数据自动创建sitemap.xml文件的简单方法，反映了我们不断增长的web内容。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3490a8803e6810ce2af4036c800bbf4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzUivVb2CmNmBAiAPLc5Bg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Reading your Firestore data</figcaption></figure><h1 id="5da4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">现代网站地图需要自动化</h1><p id="f90c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">sitemap.xml文件是搜索引擎机器人和蜘蛛最重要的文件之一。它提供了关于页面以及页面之间关系的信息。这是机器人在访问你的网站时首先要看的东西。</p><p id="b82d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">机器人(爬虫)寻找这个文件来理解你的站点的结构和抓取哪些页面。它提供了内容布局的直接表示。</p><p id="ad6f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Google和Bing等搜索引擎使用sitemap来更有效地索引您的站点，并确定从哪里开始爬行。因此，如果你想提高你的网站在谷歌搜索中被高度索引的机会，一个反映你的网站状态的结构良好的网站地图是一个很好的起点。</p><p id="5d39" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="mo">它们也可以用来通知搜索引擎，他们应该重新搜索你的网站，以确定和索引任何变化。</em></p><h2 id="d5c1" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">现代网络应用的问题是</h2><p id="49d2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">尽管你可能认为这不是什么大问题，但现代web应用程序的动态本质已经重新定义了创建站点地图的方式。</p><p id="e7f4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们的动态内容会立即导致sitemap.xml成为我们站点的过时表示。尤其是当你的网站产生越来越多的用户生成的内容时，比如文章、事件和个人资料。</p><h2 id="df65" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">静态网站可以手动创建网站地图</h2><p id="9688" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">静态网站，比如那些支持本地企业的网站，通常不是在线内容的创造者。这意味着你可以用在线工具如<a class="ae nb" href="https://www.xml-sitemaps.com/" rel="noopener ugc nofollow" target="_blank"> xml-sitemaps </a>手工生成网站地图。静态站点地图只需要偶尔添加或修改，这取决于你对站点结构的更新程度。</p><p id="a596" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你的网站有一些动态部分，你甚至可能会幸运地使用<a class="ae nb" href="https://www.screamingfrog.co.uk/xml-sitemap-generator/" rel="noopener ugc nofollow" target="_blank">尖叫青蛙网站地图生成器</a>。</p><p id="9f3f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这个工具会抓取你的站点，并可能抓取动态URL(如果你的站点有很好的内部链接)。话虽如此，我只在你不想用细粒度控制完全自动化过程时才使用这些工具。</p><p id="7113" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">自动创建站点地图的工具的唯一问题(不需要你自己编写代码的工具)是，很可能你不得不在完成后自己编辑站点地图。这就引入了人工因素。</p><p id="83ee" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">没有人喜欢<strong class="lp ir">任何</strong>中的手动元素。</p><h2 id="52ba" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">解决方案是动态构建一个站点地图</h2><p id="cf6e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">由于我们都喜欢自动化(并且自己做的工作更少)，我将向您展示一种基于动态数据可靠地生成站点地图的方法，您可以将动态数据作为<strong class="lp ir"> cron触发器运行，</strong>和<strong class="lp ir">提交给Google和Bing </strong>以便它们可以立即接收更新。</p><p id="3694" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">由于我们将使用Firebase来获取动态数据以通知我们的站点地图结构，我将向您展示如何将数据转换为站点地图。我们将使用博客文章作为动态数据，我们希望在站点地图中得到反映。</p><p id="49cc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">我们还将通过配置firebase重写</strong>来服务站点地图，以执行一个函数来服务我们已经保存到firebase存储中的生成的站点地图。</p><p id="5a45" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还将使用<a class="ae nb" href="https://www.npmjs.com/package/sitemap" rel="noopener ugc nofollow" target="_blank">站点地图npm包</a>来帮助使用我们的数据构建我们的站点地图。它提供了一种简单的方法来生成带有类型的站点地图并将其转换为字符串。</p><div class="nc nd gp gr ne nf"><a href="https://www.npmjs.com/package/sitemap" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">网站地图</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">是一个高级流站点地图生成库/CLI，使创建站点地图XML文件变得容易。什么是网站地图…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.npmjs.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt kp nf"/></div></div></a></div><h1 id="c307" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">1)创建Firebase函数Cron触发器</h1><p id="6620" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">首先，我们将创建Firebase调度程序函数，该函数创建一个<a class="ae nb" href="https://cloud.google.com/pubsub/" rel="noopener ugc nofollow" target="_blank"> Google Cloud发布/订阅主题</a>，该主题通过一个C <a class="ae nb" href="https://cloud.google.com/scheduler/" rel="noopener ugc nofollow" target="_blank"> loud调度程序</a>按照定义的时间表运行。</p><p id="7178" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将它设置为每天下午2:00运行。我还将时区设置为我的时区(欧洲/伦敦)，以确保它实际运行在下午2:00(我的时间)。</p><p id="3dd0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果您想将其设置为在不同的时间运行，您可以使用<a class="ae nb" href="https://cloud.google.com/appengine/docs/standard/python/config/cronref" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">app engine cron . YAML</strong></a><strong class="lp ir">语法</strong>指定一个替代时间</p><p id="74d7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">函数的主体非常简单。它包含对我们稍后将创建的<code class="fe nu nv nw nx b">writeSitemap()</code>的调用。</p><p id="c637" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还想导出这个函数，这样我们就可以在我们的<code class="fe nu nv nw nx b">index.ts</code> firebase函数文件中重新导出它。这使得Firebase云功能知道触发器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The Schedule (Cron) function that will generate a new sitemap</figcaption></figure><h1 id="9164" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">2)生成静态应用程序URL</h1><p id="99a9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">并非所有的URL路径都是动态的，都依赖于数据驱动的内容。这些页面包括主页<code class="fe nu nv nw nx b">/</code>，关于页面<code class="fe nu nv nw nx b">/about</code>，博客页面<code class="fe nu nv nw nx b">/blog</code>。</p><p id="6bfe" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们需要在数据库中定义一些静态路径，我们将在<code class="fe nu nv nw nx b">sitemap/static</code>将这些路径写入Firestore文档。</p><p id="3609" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将创建文档并将一组静态路径添加到一个<code class="fe nu nv nw nx b">urls</code>属性中。使用<a class="ae nb" href="http://console.firebase.google.com" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>创建这个文档会更容易，因为我们只需要手动创建一次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9f180812702f3c5b8c534ca763d96882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHm2v2eTfddGgVtDIUVCAg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Manually saving our static URLs to Firestore</figcaption></figure><p id="b2b5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们收集站点地图所需数据的第一步是从数据库中获取这些静态URL。所以我们将创建函数<code class="fe nu nv nw nx b">getAppURLs()</code>来从我们刚刚创建的文档中获取主要的静态URL。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A function that appends the static app URLs to the sitemap</figcaption></figure><p id="69bc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">所以在这个函数中，我们循环遍历ID为<code class="fe nu nv nw nx b">static</code>的文档中定义的URL，并创建一个由<code class="fe nu nv nw nx b">ISitemapItemOptionsLoose</code>对象组成的数组，这些对象是从<code class="fe nu nv nw nx b">sitemap/dist/lib/types</code>导入的。</p><p id="bb18" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">值得注意的是，站点地图中使用的所有时间戳都必须符合ISO标准。幸运的是，我们可以在<code class="fe nu nv nw nx b">Date</code>对象上使用方便的<code class="fe nu nv nw nx b">toISOString()</code>函数。</p><p id="34ea" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你没有使用正确的日期时间格式，你的站点地图将会出错，谷歌将无法正确读取。</p><h1 id="a592" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">3)基于Web内容生成动态URL</h1><p id="23b1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是自动化必不可少的部分，因为博客帖子的数量越来越多，需要越来越多的URL指向它们。</p><p id="72e5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们创建<code class="fe nu nv nw nx b">getBlogPostURLs()</code>函数。</p><p id="5628" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们假设我们的博客文章存储在集合<code class="fe nu nv nw nx b">blog_posts</code>中，并在数据库中查询我们所有的博客文章。</p><p id="3b65" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们使用一个异步函数，这样我们就可以使用<strong class="lp ir"> <em class="mo"> await </em> </strong>来处理Firebase作为承诺返回的数据。我们初始化一个<code class="fe nu nv nw nx b">ISitemapItemOptionsLoose</code>条目的数组来存储从文章数据生成的站点地图条目。</p><p id="e443" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">然后我们需要遍历帖子，获取一些值:</strong></p><ul class=""><li id="7625" class="ob oc iq lp b lq mj lt mk lw od ma oe me of mi og oh oi oj bi translated">使用<code class="fe nu nv nw nx b"><strong class="lp ir">slug</strong></code>值的URL</li><li id="6b5d" class="ob oc iq lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated">主图像<code class="fe nu nv nw nx b"><strong class="lp ir">imageURL</strong></code></li><li id="4fcc" class="ob oc iq lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><code class="fe nu nv nw nx b"><strong class="lp ir">title</strong></code></li><li id="d5af" class="ob oc iq lp b lq ok lt ol lw om ma on me oo mi og oh oi oj bi translated"><code class="fe nu nv nw nx b"><strong class="lp ir">updatedAt</strong></code>值。</li></ul><p id="d3b3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">同样，我们将<code class="fe nu nv nw nx b">updatedAt</code>值(一种<code class="fe nu nv nw nx b"><strong class="lp ir">number</strong></code>类型)转换为<code class="fe nu nv nw nx b">Date</code>对象，这样我们就可以使用<code class="fe nu nv nw nx b">toISOString()</code>函数来确保日期时间格式是兼容的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A function that takes the blog post data and appends them to the sitemap</figcaption></figure><p id="9fdb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">该函数只返回一个带有sitemap项目数组的承诺。</p><p id="d000" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们导出这个函数，因为我们需要在下一步中导入它。</p><h1 id="4c84" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">4)结合静态和动态URL来准备站点地图</h1><p id="758a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一个站点地图由我们所有的URL组成，除非你有大量的URL并且需要一个指向多个站点地图的索引(但是那是另外一个话题)。</p><p id="f179" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">因此，我们需要组合到目前为止已经生成的站点地图条目，以形成我们完整的站点地图。所以这意味着我们的静态和动态网址。</p><p id="d99a" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为此，我们创建了<code class="fe nu nv nw nx b">getAllURLs()</code>函数，它返回一个包含所有站点地图条目的承诺。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A function that combines the static + dynamic URLs</figcaption></figure><h1 id="3e27" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">5)编写网站地图并上传到Firebase存储器</h1><p id="7eb4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是我们写站点地图的地方。我们需要从<strong class="lp ir">站点地图</strong>包<strong class="lp ir">中导入<code class="fe nu nv nw nx b">createSitemap</code>函数。</strong>主机名应该与您的网站地址相匹配，并带有一个前导斜杠，因为网站地图路径将被附加到主机名后以形成网站地图。</p><p id="d9c0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们需要<strong class="lp ir"> <em class="mo">等待</em> </strong>我们在上一步中创建的<code class="fe nu nv nw nx b">getAllURLs()</code>函数的结果，将结果作为<code class="fe nu nv nw nx b">urls</code>属性提供给sitemap对象。</p><p id="3e09" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们希望将新创建的站点地图保存到Firebase存储中，保存为<code class="fe nu nv nw nx b">sitemap.xml</code>，用contentType压缩为<code class="fe nu nv nw nx b">text/xml</code>。</p><h2 id="5b26" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">让我们首先创建<code class="fe nu nv nw nx b">uploadFile</code>函数。</h2><p id="ba1f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这个函数将负责上传<code class="fe nu nv nw nx b">sitemap.xml</code>文件到我们的Firebase存储桶。这是一个通用函数，当使用函数上载不同的数据类型时，它可以确保类型安全。</p><p id="677d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">类型<code class="fe nu nv nw nx b">SaveOptions</code>的选项包括<strong class="lp ir">内容类型</strong>和是否将<strong class="lp ir">压缩</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A function that will upload the data to a file in Firebase Storage</figcaption></figure><p id="4f28" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您可能还想将站点地图的当前状态保存到Firestore文档<strong class="lp ir">，使用当前时间作为文档ID的时间戳</strong>，因此我们在成功上传后设置该数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Write the Sitemap and Upload to Firebase Storage</figcaption></figure><p id="fc0c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们需要通过使用sitemap对象上的<code class="fe nu nv nw nx b">toString()</code>函数将成功创建的sitemap对象转换为字符串。这是准备我们的站点地图上传到Firebase存储的最后一步。</p><h1 id="023b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">6)如何提供网站地图</h1><p id="1f43" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了在使用Firebase托管时提供站点地图服务，我们必须为sitemap.xml文件设置一个重写。这绕过了提供托管的sitemap.xml的通常行为。</p><p id="d59e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将对sitemap.xml文件的请求重写为一个名为<code class="fe nu nv nw nx b">serveSitemap()</code>的函数，该函数将从Firebase存储中下载sitemap并提供内容来代替静态的sitemap.xml文件。</p><p id="9a79" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在此之前，我们将创建一个新函数，从Firebase存储中下载字符串。</p><h2 id="16f9" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">从Firebase存储器下载一个字符串</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A function that downloads a string from Firebase Storage</figcaption></figure><p id="9e9c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这里，我们提供一个文件路径作为参数(这将是我们的<code class="fe nu nv nw nx b">sitemap.xml</code>文件)，指定bucket，并使用<code class="fe nu nv nw nx b">Buffer.from(...result)</code>和缓冲区上的<code class="fe nu nv nw nx b">toString()</code>方法下载和转换结果为一个字符串。</p><p id="d21e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">从缓冲区到字符串的转换是必要的，因为Firebase存储返回一个缓冲区数组。</p><h2 id="238f" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">配置Firebase重写以服务于站点地图</h2><p id="a83f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们在firebase JSON文件中插入嵌套在托管 属性的<strong class="lp ir"> <em class="mo">中的重写。来源是<code class="fe nu nv nw nx b">/sitemap.xml</code>，因为这是我们想要覆盖的文件请求。</em></strong></p><p id="8d1d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">提供的功能是<code class="fe nu nv nw nx b">serveSitemap()</code>，它将负责下载和提供我们动态<code class="fe nu nv nw nx b">sitemap.xml</code>的内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Firebase.json file where we specify the rewrite to our sitemap function</figcaption></figure><h2 id="3fd9" class="mp kw iq bd kx mq mr dn lb ms mt dp lf lw mu mv lh ma mw mx lj me my mz ll na bi translated">创建serveSitemap函数作为HTTP触发器</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The serveSitemap function that serves our dynamic sitemap</figcaption></figure><p id="6c96" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们从存储器中下载站点地图，并将其作为参数提供给云HTTP触发器的<code class="fe nu nv nw nx b">res.send()</code>函数。这将返回站点地图文件的内容作为响应。</p><p id="3ffd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">就是这样！我们有一个动态的网站地图，反映我们不断变化的内容。</p><h1 id="1eac" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">奖金🚀用新的网站地图搜索谷歌和必应</h1><p id="8f62" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">厌倦了每次网站地图改变时都要去谷歌搜索控制台手动提交吗？</p><p id="de21" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">好吧，你可以用你更新后的网站地图连接谷歌和必应，只要它有了额外的云功能。</p><p id="1002" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将使用axios——NodeJS中基于promise的HTTP客户端——发出HTTP请求来ping我们的站点地图。</p><div class="nc nd gp gr ne nf"><a href="https://www.npmjs.com/package/axios" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">axios</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">基于Promise的浏览器和node.js的HTTP客户端</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">www.npmjs.com</p></div></div><div class="no l"><div class="op l nq nr ns no nt kp nf"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Ping sitemap to Search Engines — Google and Bing</figcaption></figure><p id="f255" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们可以创建<code class="fe nu nv nw nx b">pingSitemap()</code>，它用<code class="fe nu nv nw nx b">?sitemap=</code>参数向<code class="fe nu nv nw nx b"><a class="ae nb" href="https://www.google.com/ping" rel="noopener ugc nofollow" target="_blank">https://www.google.com/ping</a></code>和<code class="fe nu nv nw nx b">https://www.bing.com/ping</code>发出GET请求，指向我们的站点地图的位置。</p><p id="e018" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">调用这个函数的最佳时机是在站点地图创建之后，或者我们刚刚部署了web应用程序的更新时</p><p id="126d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">感谢阅读！有什么问题吗？给我留言吧。</strong></p></div></div>    
</body>
</html>