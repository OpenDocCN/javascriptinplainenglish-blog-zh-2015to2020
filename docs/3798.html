<html>
<head>
<title>The JavaScript Cheatsheet you need in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年你需要的JavaScript Cheatsheet</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-javascript-cheatsheet-you-need-in-2020-d81b3dd89e09?source=collection_archive---------1-----------------------#2020-10-26">https://javascript.plainenglish.io/a-javascript-cheatsheet-you-need-in-2020-d81b3dd89e09?source=collection_archive---------1-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6408c144d96b48ab36c82114438a7cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqgh4-fLTH8uriS5C_xImw.jpeg"/></div></div></figure><p id="3fc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我很确定我不是唯一一个在面试中遇到一些令人不舒服的技术问题的人，我觉得我知道T2发生了什么，但T4却无法解释。</p><p id="61ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经对这些问题和概念做了一段时间的总结，并选择了最具挑战性的20个。尽情享受吧！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="344d" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">【Arrow和常规函数有什么区别？</h2><ul class=""><li id="f323" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir"> This </strong> value (context):在常规函数中，<em class="kw"> this </em>的值与定义它的类无关；相反，它取决于被<strong class="ka ir"> <em class="kw">调用的对象</em></strong>；在箭头函数<em class="kw">中，这个</em>值总是等于来自外部函数的<em class="kw">这个</em>值</li><li id="2299" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">构造函数</strong>:常规函数可以轻松构造对象，而箭头函数不能作为构造函数使用</li><li id="5644" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir"> Arguments </strong> object:是一个特殊的类似数组的对象，包含调用函数所用的参数列表，在arrow函数中<em class="kw"> arguments </em> object是按词法解析的:它从外部函数中访问参数</li><li id="2d20" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">隐式返回</strong>:常规函数使用return expression语句——否则它只会返回undefined，而对于arrow函数，如果它们包含一个表达式并且函数的花括号丢失了，那么表达式就会隐式返回</li><li id="220e" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://dmitripavlutin.com/differences-between-arrow-and-regular-functions/" rel="noopener ugc nofollow" target="_blank">阅读更多</a></li></ul><h2 id="ff86" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated"><strong class="ak"><em class="mo">这个</em>是怎么工作的？</strong></h2><ul class=""><li id="004f" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir"> <em class="kw">这个</em> </strong>关键字指的是一个对象，这个对象正在执行javascript代码的当前位</li><li id="5159" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">每个javascript函数在执行时都有一个对其当前执行上下文的引用，称为<strong class="ka ir"><em class="kw"/></strong>——执行上下文在这里意味着函数是如何被调用的</li><li id="2e01" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">要理解<strong class="ka ir"> <em class="kw">这个</em> </strong>关键字，我们只需要知道函数是如何、何时以及从哪里被调用的，函数是如何以及在哪里被声明或定义的并不重要</li><li id="e109" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://codeburst.io/all-about-this-and-new-keywords-in-javascript-38039f71780c" rel="noopener" target="_blank">阅读更多&amp;参见示例</a></li></ul><h2 id="25d3" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">回调和关闭</strong>？</h2><ul class=""><li id="d7ce" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir">回调</strong>:可由另一个函数访问并在第一个函数之后调用的函数——如果第一个函数完成的话</li><li id="b22b" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://www.freecodecamp.org/news/javascript-callback-functions-what-are-callbacks-in-js-and-how-to-use-them/" rel="noopener ugc nofollow" target="_blank">阅读更多关于回调的</a></li><li id="ba7e" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">闭包</strong>:每当在当前作用域之外定义的变量从某个内部作用域中被访问时，就会创建闭包——它让你可以从内部函数访问外部函数的作用域</li><li id="4408" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">要使用闭包，只需在另一个函数中定义一个函数并公开它</li><li id="1369" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#:~:text=A%20closure%20is%20the%20combination,scope%20from%20an%20inner%20function." rel="noopener ugc nofollow" target="_blank">阅读更多关于闭包的</a></li></ul><h2 id="dd66" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">匿名函数</strong>？</h2><ul class=""><li id="f086" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">声明时没有任何函数名标识符来引用它的函数——它通常在最初创建后就不可访问了。这些函数是在运行时创建的</li><li id="3642" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://www.javascripttutorial.net/javascript-anonymous-functions/" rel="noopener ugc nofollow" target="_blank">阅读更多</a></li></ul><h2 id="19c1" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">高阶函数</strong>？</h2><ul class=""><li id="9f21" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">函数r <strong class="ka ir">接收一个函数作为参数</strong>或<strong class="ka ir">返回一个函数作为输出</strong></li><li id="c773" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">例如，Array.prototype.map、Array.prototype.filter和Array.prototype.reduce是该语言内置的一些高阶函数。</li><li id="52ff" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://blog.bitsrc.io/understanding-higher-order-functions-in-javascript-75461803bad" rel="noopener ugc nofollow" target="_blank">更多在此</a></li></ul><h2 id="d49b" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">JS中的<strong class="ak">“严格”模式</strong>是什么？</h2><ul class=""><li id="00be" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">严格模式支持代码中更严格的错误检查，并使调试更容易</li><li id="70d7" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">您通过添加“使用严格”来启用严格模式；在文件的开头</li><li id="c136" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://www.educative.io/edpresso/what-is-use-strict-in-javascript?utm_source=Google%20AdWords&amp;aid=5082902844932096&amp;utm_medium=cpc&amp;utm_campaign=kb-dynamic-edpresso&amp;gclid=CjwKCAjwoc_8BRAcEiwAzJevtZyt8ueI8zRKbsnF5_b0OYQXvsk4kA5GMACgxLhBfJQH-XNfPt_WmRoCC0wQAvD_BwE" rel="noopener ugc nofollow" target="_blank">阅读更多</a></li></ul><h2 id="3e19" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated"><strong class="ak">承诺vs异步/等待</strong>？</h2><ul class=""><li id="6261" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir">作用域</strong>:在一个承诺中，只有承诺链是异步的——不阻塞执行；对于async/await，整个包装函数是异步的</li><li id="8451" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">逻辑</strong>:在一个承诺中，可以在同一个回调中处理同步工作，使用Promise.all可以处理多个承诺；使用async/await，同步工作需要放在回调之外，并且可以用更简单的变量处理多个承诺</li><li id="d48e" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">错误处理</strong>:承诺:<em class="kw">然后，捕捉，最后</em>；异步/等待:<em class="kw">尝试，捕捉，最后</em></li><li id="2cc5" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://levelup.gitconnected.com/async-await-vs-promises-4fe98d11038f" rel="noopener ugc nofollow" target="_blank">参见此处示例</a></li></ul><h2 id="1dd1" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">JS中<strong class="ak">可变</strong> vs <strong class="ak">不可变</strong></h2><ul class=""><li id="26b0" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">不可变和可变的区别:如果一个项目是可变的，当改变引用变量的值时，它也会影响原始引用变量的值</li><li id="cf57" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">原始数据类型</strong>如数字、字符串和布尔类型<strong class="ka ir">是不可变的</strong>——不可能通过改变引用来改变这些类型的值——你可以组合它们并从中派生出新的值，但当你分配一个特定的值时，该值将始终保持不变；您可以让变量名指向一个新值，但是以前的值仍然保存在内存中</li><li id="8403" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">可变</strong>是一种可以通过引用改变的变量——在JS中只有<strong class="ka ir">对象和数组</strong>是可变的:你可以改变它们的属性；例如:使单个对象值在不同时间具有不同的内容</li><li id="8072" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://gomakethings.com/mutable-vs.-immutable-in-javascript/" rel="noopener ugc nofollow" target="_blank">阅读更多内容并查看示例</a></li></ul><h2 id="f646" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">类型语言</strong>？</h2><ul class=""><li id="9324" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">这些值与值相关联，而不是与变量相关联——它可以是静态的<em class="kw">或动态的</em></li><li id="bba0" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">静态</strong>:变量只能保存一种类型，就像在Java中一样:声明为string的变量只能接受一组字符，除此之外什么也不能</li><li id="4126" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">动态</strong>:变量可以包含多种类型——就像在JS中一样:一个变量可以包含数字、字符等</li></ul><h2 id="778d" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">吊装</strong>？</h2><ul class=""><li id="ef00" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">JavaScript的默认行为是将所有声明移动到当前作用域的顶部(当前脚本或当前函数的顶部)</li><li id="c5eb" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">JavaScript只提升<em class="kw">声明</em>，不提升<em class="kw">初始化</em></li></ul><h2 id="eece" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">JS中的<strong class="ak">事件委托</strong>是什么？</h2><ul class=""><li id="7a2d" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">一种简单的技术，通过这种技术可以向父元素添加单个事件处理程序，从而避免向多个子元素添加事件处理程序</li><li id="d379" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">使用事件委托，可以向一个元素添加一个事件处理程序，等待一个事件从一个子元素中冒泡出来，并很容易地确定事件来自哪个元素</li><li id="f0c2" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://www.sitepoint.com/javascript-event-delegation-is-easier-than-you-think/#:~:text=JavaScript%20event%20delegation%20is%20a,handlers%20to%20multiple%20child%20elements." rel="noopener ugc nofollow" target="_blank">例题</a></li></ul><h2 id="42fa" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated"><strong class="ak">调用</strong>，<strong class="ak">应用&amp;绑定有什么区别？</strong></h2><ul class=""><li id="ad01" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">通过使用它们，你可以明确地确定这个应该引用什么<strong class="ka ir"/></li><li id="c230" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">当您想使用事件来访问一个类中另一个类的属性时，绑定会特别有用</li><li id="e7e0" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">主要区别在于，<strong class="ka ir"> apply </strong>立即执行函数，而<strong class="ka ir"> bind </strong>返回函数</li><li id="0a09" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">调用</strong>和<strong class="ka ir">应用</strong>非常相似——它们调用一个具有指定<em class="kw">上下文和可选参数的函数</em></li><li id="fb04" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">不同的是<strong class="ka ir">调用</strong>需要参数一个一个传入，而<strong class="ka ir">应用</strong>将参数作为数组</li><li id="0e90" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://www.taniarascia.com/this-bind-call-apply-javascript/" rel="noopener ugc nofollow" target="_blank">阅读更多内容并查看示例</a></li></ul><h2 id="9de1" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated"><strong class="ak">主机</strong>和<strong class="ak">原生对象</strong>有什么区别？</h2><ul class=""><li id="ae3e" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">根据环境和语言的不同，对象可以分为这两大类</li><li id="1e77" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">主体对象:特定于环境—例如。浏览器提供某些对象，如窗口，节点提供节点列表等。</li><li id="ebd3" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">原生/内置对象:JS提供的标准对象——有时也称为全局对象；JS主要由这些分类的本地对象(字符串、数字等)构成</li></ul><h2 id="4a01" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">库里功能</strong>？</h2><ul class=""><li id="b461" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">Currying是函数式编程中的一个过程，在这个过程中，我们可以将一个具有多个参数的函数转换为一系列嵌套函数——它返回一个新函数，该函数需要内联下一个参数</li><li id="f2a8" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">将函数从可调用的f(a，b，c)转换为可调用的f(a)(b)(c)的函数变换</li><li id="2890" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">它让我们很容易得到部分变量，避免多次传递同一个变量</li><li id="dc1c" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">它根据函数的参数数量创建嵌套函数，因此每个函数都接收一个参数:如果没有参数，就没有currying。</li><li id="a43c" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://javascript.info/currying-partials" rel="noopener ugc nofollow" target="_blank">阅读更多</a></li><li id="daf0" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://dev.to/suprabhasupi/currying-in-javascript-1k3l" rel="noopener ugc nofollow" target="_blank">阅读更多2 </a></li></ul><h2 id="1c7e" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">事件循环</strong>？</h2><ul class=""><li id="bf8c" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">在大多数浏览器中，每个浏览器标签都有一个<strong class="ka ir">事件循环，以使每个进程相互隔离，避免一个具有无限循环或繁重处理的网页阻塞整个浏览器</strong></li><li id="3fe2" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">该环境管理多个并发事件循环，以处理API调用</li><li id="27fe" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">Web工作者也在他们自己的事件循环中运行</li><li id="72d8" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">你主要需要关注的是你的代码将在一个<strong class="ka ir">单事件循环</strong>上运行，并在编写代码时牢记这一点以避免阻塞它</li><li id="5040" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">任何花费太长时间将控制返回给事件循环的JavaScript代码都将<strong class="ka ir">阻塞页面中任何JavaScript代码的执行</strong>，甚至阻塞UI线程，并且用户不能四处点击、滚动页面等等</li><li id="530d" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://flaviocopes.com/javascript-event-loop/#:~:text=The%20event%20loop%20continuously%20checks,executes%20each%20one%20in%20order." rel="noopener ugc nofollow" target="_blank">阅读更多</a></li></ul><h2 id="6b74" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">事件传播</strong>？</h2><ul class=""><li id="4ba6" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">事件传播是一种机制，它定义了事件如何通过DOM树传播或传播以到达其目标，以及之后会发生什么</li><li id="0488" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">在现代浏览器中，事件传播分两个阶段进行:<strong class="ka ir">捕获</strong>，以及<strong class="ka ir">冒泡</strong>阶段</li><li id="df3f" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir"> <em class="kw">捕获</em> </strong>:事件从窗口向下通过DOM树传播到目标节点——仅在第三个参数设置为<strong class="ka ir"> true </strong>时，与用<strong class="ka ir"> addEventListener() </strong>方法注册的事件处理程序一起工作</li><li id="bd85" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir"><em class="kw"/></strong>冒泡:在这个阶段，事件沿着DOM树向上传播或冒泡，从目标元素一直到窗口，逐个访问目标元素的所有祖先——所有浏览器都支持，并且它适用于所有处理程序，不管它们是如何注册的，例如使用<strong class="ka ir"> onclick </strong>或<strong class="ka ir"> addEventListener() </strong></li><li id="debf" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://www.tutorialrepublic.com/javascript-tutorial/javascript-event-propagation.php#:~:text=Event%20propagation%20is%20a%20mechanism,what%20happens%20to%20it%20afterward." rel="noopener ugc nofollow" target="_blank">阅读更多</a></li></ul><h2 id="98a6" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">Cookies、本地存储和会话存储有什么区别？</h2><ul class=""><li id="c174" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">浏览器<strong class="ka ir">存储</strong>:数据不会传输到服务器&amp;只能在客户端读取；存储限制约为5MB</li><li id="217e" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">会话与本地存储</strong>:会话只是临时的——数据存储到标签/浏览器关闭；本地没有截止日期</li><li id="da6e" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">储存缺点:不安全，仅限于绳子，对XSS有危险</li><li id="9d9c" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir"> Cookie </strong>:存储有截止日期的数据，存储限制约为4KB，针对每个请求发送到服务器，在客户端和服务器端均可读取/写入&amp;(如果只有http，则客户端脚本无法访问)</li></ul><h2 id="37d7" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">内容安全策略(CSP) </strong>？</h2><ul class=""><li id="cc49" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">内容安全策略(CSP)是一个<strong class="ka ir"> HTTP头</strong>，它允许站点运营商对他们站点上的资源可以从哪里加载进行细粒度控制。</li><li id="cd1b" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">使用此标头是防止跨站脚本(XSS)漏洞的最佳方法。</li><li id="3361" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">由于将CSP改造成现有网站的难度很大，CSP对于所有新网站都是<strong class="ka ir">强制性的</strong>，并且强烈建议所有现有的高风险网站都采用CSP。</li><li id="3949" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" rel="noopener ugc nofollow" target="_blank">阅读更多</a></li></ul><h2 id="ae27" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">跨站脚本(XSS) </strong>？</h2><ul class=""><li id="acf7" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">跨站点脚本(XSS)是一种<strong class="ka ir">攻击</strong>，当攻击者使用web应用程序向不同的最终用户发送恶意代码时，通常以浏览器端脚本的形式出现</li><li id="af5d" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">当有人请求时，服务器提供的页面是不变的；相反，XSS攻击利用了页面中的一个<strong class="ka ir">弱点</strong>，该页面包含一个在请求中提交的变量，该变量以原始形式出现在响应中</li><li id="4af1" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Cross-site_scripting_XSS" rel="noopener ugc nofollow" target="_blank">阅读更多关于攻击的信息</a></li></ul><h2 id="95dd" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是<strong class="ak">CORS</strong>？</h2><ul class=""><li id="887f" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir">跨源资源共享</strong> ( <a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>)是一种<strong class="ka ir">机制</strong>，它使用额外的<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" rel="noopener ugc nofollow" target="_blank"> HTTP </a>头来告诉浏览器让运行在一个<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Glossary/origin" rel="noopener ugc nofollow" target="_blank">源</a>的web应用程序访问来自不同源的选定资源</li><li id="1762" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">当一个web应用程序请求一个与它自己的<strong class="ka ir">来源</strong>(域、协议或端口)不同的资源时，它执行一个跨来源的HTTP请求</li><li id="e34f" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">阅读更多</a></li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="cfb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，也可以看看这些:</p><div class="mp mq gp gr mr ms"><a rel="noopener  ugc nofollow" target="_blank" href="/html-css-concepts-you-might-have-missed-7f49893daaaf"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">解释了20个HTML和CSS概念</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">我一直对网页开发的视觉方面充满热情，在谈到…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jw ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a rel="noopener  ugc nofollow" target="_blank" href="/5-essential-third-party-tools-for-web-developers-cc4b3d04f924"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">Web开发人员必备的5个第三方工具</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">如今，软件生态系统充满了不可或缺的工具，无论何时我们想要构建什么，我们都依赖这些工具…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng jw ms"/></div></div></a></div></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="ae46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得遗漏了一些问题，并认为它们应该在那里，或者如果你想分享你的反馈，请在评论中告诉我！</p><p id="f13b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇文章有所帮助，非常感谢您的阅读！编码快乐！</p><p id="82fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">帮助我建立这个总结的一些来源:</p><div class="mp mq gp gr mr ms"><a href="https://www.fullstack.cafe/blog/front-end-developer-interview-questions" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">50个常见前端开发者面试问题【2019版】| FullStack。咖啡馆</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">前端开发包括为web应用程序构建网页和用户界面。前端开发人员…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.fullstack.cafe</p></div></div><div class="nb l"><div class="ni l nd ne nf nb ng jw ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://tsh.io/blog/frontend-interview-questions/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">前端面试问题——2020年开发者小贴士| TSH.io</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">随着对前端开发的高需求的持续，技术来来去去和需求的变化，典型的…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">tsh.io</p></div></div><div class="nb l"><div class="nj l nd ne nf nb ng jw ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://www.bestinterviewquestion.com/front-end-developer-interview-questions" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">2020年前20个以上前端开发人员面试问题</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">一个前端开发人员应该具有功能知识和工作能力的所有方面涉及…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.bestinterviewquestion.com</p></div></div><div class="nb l"><div class="nk l nd ne nf nb ng jw ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/interview-q.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">前端面试问题</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">前端开发人员手册是了解前端开发整个范围的有用资源…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">frontendmasters.com</p></div></div><div class="nb l"><div class="nl l nd ne nf nb ng jw ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://h5bp.org/Front-end-Developer-Interview-Questions/questions/javascript-questions/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">JavaScript问题★前端工作面试问题</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">一个有用的前端相关问题列表，你可以用来面试潜在的候选人，测试自己或…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">h5bp.org</p></div></div><div class="nb l"><div class="nm l nd ne nf nb ng jw ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://dev.to/devabhijeet/all-front-end-interview-questions-asked-during-my-recent-job-hunt-1kge" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">我最近找工作时问的所有前端面试问题。</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">这份自述是我最近在新冠肺炎找工作时被问到的所有问题的汇编。我还附上了一份清单…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">开发到</p></div></div><div class="nb l"><div class="nn l nd ne nf nb ng jw ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://www.edureka.co/blog/interview-questions/javascript-interview-questions/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">2020年50大JavaScript面试问答| Edureka</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">这个JavaScript面试问题博客将为你提供一个关于JavaScript的深入知识，并为你做好准备…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.edureka.co</p></div></div><div class="nb l"><div class="no l nd ne nf nb ng jw ms"/></div></div></a></div></div></div>    
</body>
</html>