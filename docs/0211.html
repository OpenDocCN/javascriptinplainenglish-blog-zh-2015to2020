<html>
<head>
<title>React context API (Part 2) — Updating state through a Consumer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上下文API(第2部分)——通过消费者更新状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-context-api-part-2-updating-state-through-a-consumer-7be723b54d7b?source=collection_archive---------0-----------------------#2019-08-15">https://javascript.plainenglish.io/react-context-api-part-2-updating-state-through-a-consumer-7be723b54d7b?source=collection_archive---------0-----------------------#2019-08-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bd5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗨，欢迎回到React上下文API系列的第2部分。在第一部分中，我们讨论了如何利用React的上下文API将状态值传递给子组件。现在，在第2部分中，我们将看看如何通过消费者更新状态？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10154e7747f3d022e1b3cb3c45229d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xv8X9df2wojULtL4Gx9sg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@emilep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Émile Perron</a> on <a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3a7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个项目的回购可以在这里找到<a class="ae ky" href="https://github.com/arevaldez/Context-Tutorial-Pt2" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f545" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想了解更多的背景知识，我强烈建议阅读我的第一篇文章。我会多解释一些为什么上下文也是有用的。</p><h1 id="17a6" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">你会做什么</h1><p id="ae5d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">让我们看看你会做什么。看看下面的图片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/fdeaa6bd0fefbb3d445b2fe97bfd0ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*dqCkReRyxN2ZqQjCkloD1Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Child Component</figcaption></figure><p id="7345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这看起来眼熟吗？这是第一部分中的同一个子组件！<em class="md">但是等等……有按钮？为什么，是的。是的有。让我们看看它能做什么！</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/906fc954a3a84225c8950749f98fdc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*EFXkWfgKMKAFgpMuXQA_DA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Toggled GrandChild Component</figcaption></figure><p id="8e25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太棒了。我们现在能够切换孙组件。我们稍后会看到如何做到这一点。<em class="md">但是等等……还有</em> <strong class="jm io"> <em class="md">另一个</em> </strong> <em class="md">按钮。</em>为什么，是的。是的有。你能猜出这个按钮是干什么的吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/ddbe7db1c8193591ddee52c240140ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*QyXAmbjQr47xG_ygnE0EyQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Toggled Name</figcaption></figure><p id="299e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你猜它触发了一个名字，你就猜对了。它在<strong class="jm io"> <em class="md"> Bob </em> </strong>和<strong class="jm io"> <em class="md"> Mark </em> </strong>之间切换每个组件的名字。你猜怎么着？这都是<em class="md">通过上下文</em>完成的！让我们来看看如何。</p><h1 id="1581" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">辅导的</h1><p id="4445" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><strong class="jm io">创建上下文</strong>。首先，让我们再次创建一个Context.js文件，它将创建我们需要的提供者和消费者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Context.js</figcaption></figure><p id="5363" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从react导入<em class="md">创建上下文</em>。这让我们可以创建上下文对象。然后，创建<em class="md">提供者</em>和<em class="md">消费者</em>。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="0be1" class="mn la in mj b gy mo mp l mq mr">const { Provider, Consumer } = createContext()</span></pre><p id="1eb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单提醒一下。这一步<strong class="jm io">很重要</strong>。通过创建提供者和消费者，我们可以在保存状态的父组件之外订阅状态更改。</p><p id="abf8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">父</strong>。好了，我们已经创建了上下文对象。我们创造了提供者和消费者。让我们创建保存状态的<em class="md">父</em>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Parent.js</figcaption></figure><p id="a597" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，这里发生了很多事。我们先来看看状态项。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="cb12" class="mn la in mj b gy mo mp l mq mr">state = {</span><span id="af61" class="mn la in mj b gy ms mp l mq mr">  toggleGrandChild: false,</span><span id="5543" class="mn la in mj b gy ms mp l mq mr">  toggleName: false,</span><span id="c11b" class="mn la in mj b gy ms mp l mq mr">  people: [</span><span id="5d8d" class="mn la in mj b gy ms mp l mq mr">     { id: 0, name: “Bob”, age: 24 },</span><span id="8ef6" class="mn la in mj b gy ms mp l mq mr">     { id: 1, name: “Jack”, age: 22 },</span><span id="3de5" class="mn la in mj b gy ms mp l mq mr">     { id: 2, name: “Jill”, age: 26 },</span><span id="afb5" class="mn la in mj b gy ms mp l mq mr">  ],</span><span id="0eca" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="461e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一项是<code class="fe mt mu mv mj b">toggleGrandChild</code>。这让我们知道孙组件是否被切换。该值以false开头。这是改变状态的函数。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="d64c" class="mn la in mj b gy mo mp l mq mr">toggleComponent = () =&gt; {</span><span id="b963" class="mn la in mj b gy ms mp l mq mr">  this.setState({</span><span id="4b4f" class="mn la in mj b gy ms mp l mq mr">    toggleGrandChild: !this.state.toggleGrandChild,</span><span id="9eab" class="mn la in mj b gy ms mp l mq mr">  })</span><span id="eb29" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="bce1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mt mu mv mj b">toggleComponent</code>使<code class="fe mt mu mv mj b">toggleGrandChild</code>的状态变为与其电流值相反的状态。因此，如果其当前值为假并且调用了<code class="fe mt mu mv mj b">toggleComponent</code>，则该值将变为真。该函数将用于切换孙子组件。</p><p id="eee1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们有<code class="fe mt mu mv mj b">toggleName</code>状态值。你猜对了。它用于切换名称。<code class="fe mt mu mv mj b">toggleName</code>亦始于假的价值。让我们看看它的相应功能。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="5234" class="mn la in mj b gy mo mp l mq mr">switchNameHandler = newName =&gt; {</span><span id="53bb" class="mn la in mj b gy ms mp l mq mr">     this.setState({</span><span id="aca5" class="mn la in mj b gy ms mp l mq mr">          toggleName: !this.state.toggleName,</span><span id="fd47" class="mn la in mj b gy ms mp l mq mr">          people: [</span><span id="6050" class="mn la in mj b gy ms mp l mq mr">            { id: 0, name: newName, age: 24 },</span><span id="a577" class="mn la in mj b gy ms mp l mq mr">            { id: 1, name: “Jack”, age: 22 },</span><span id="ba05" class="mn la in mj b gy ms mp l mq mr">            { id: 2, name: “Jill”, age: 26 },</span><span id="1b6f" class="mn la in mj b gy ms mp l mq mr">          ],</span><span id="876c" class="mn la in mj b gy ms mp l mq mr">     })</span><span id="874c" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="03a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">A <code class="fe mt mu mv mj b">newName</code>正在传入<code class="fe mt mu mv mj b">switchNameHandler</code>。这个处理程序负责更改第一个人的名字。首先，切换<code class="fe mt mu mv mj b">toggleName</code>值。接下来，它将新名称插入到第一个人对象的名称值中。请注意，其他名称保持不变。这是为了表明其他人的对象将保持不变。不过，从技术上来说，您正在用相同的初始值更新对象。</p><p id="114a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们有人民的对象。人们拥有每个人的目标。<code class="fe mt mu mv mj b">Bob</code>是以后打开的名称。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="e6e8" class="mn la in mj b gy mo mp l mq mr">people: [</span><span id="0eb0" class="mn la in mj b gy ms mp l mq mr">    { id: 0, name: "Bob", age: 24 },</span><span id="0307" class="mn la in mj b gy ms mp l mq mr">    { id: 1, name: "Jack", age: 22 },</span><span id="0dd5" class="mn la in mj b gy ms mp l mq mr">    { id: 2, name: "Jill", age: 26 },</span><span id="6a43" class="mn la in mj b gy ms mp l mq mr">]</span></pre><p id="dc46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提供方</strong>。让我们进入提供商。请记住，提供者将包装包含消费者的组件。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="e7ec" class="mn la in mj b gy mo mp l mq mr">&lt;Provider</span><span id="0c9d" class="mn la in mj b gy ms mp l mq mr">    value={{</span><span id="32b5" class="mn la in mj b gy ms mp l mq mr">          state: this.state,</span><span id="d131" class="mn la in mj b gy ms mp l mq mr">          toggleComponent: this.toggleComponent,</span><span id="d45e" class="mn la in mj b gy ms mp l mq mr">          switchNameHandler: e =&gt; this.switchNameHandler(e)</span><span id="d736" class="mn la in mj b gy ms mp l mq mr">    }}&gt;</span><span id="1c41" class="mn la in mj b gy ms mp l mq mr">            &lt;Child /&gt;</span><span id="1ffb" class="mn la in mj b gy ms mp l mq mr">&lt;/Provider&gt;</span></pre><p id="7cd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，包装的组件是子组件。子组件中还包含孙子组件。稍后会有更多相关信息。</p><p id="a2c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看提供商内部的<code class="fe mt mu mv mj b">value</code>。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="5c2d" class="mn la in mj b gy mo mp l mq mr">value={{</span><span id="ff72" class="mn la in mj b gy ms mp l mq mr">    state: this.state,</span><span id="f257" class="mn la in mj b gy ms mp l mq mr">    toggleComponent: this.toggleComponent,</span><span id="7376" class="mn la in mj b gy ms mp l mq mr">    switchNameHandler: e =&gt; this.switchNameHandler(e)</span><span id="1177" class="mn la in mj b gy ms mp l mq mr">}}</span></pre><p id="8e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这看起来很熟悉。然而，它与教程的第一部分有点不同。第一部分的原始提供者值如下所示。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="ea24" class="mn la in mj b gy mo mp l mq mr">value={this.state}</span></pre><p id="8a03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="md">那么，为什么这个不同呢？</em>我们在第一部分谈了一点，但是让我们再看一遍。如果我们想将一个函数传递给我们的上下文消费者，我们必须传递包含所需函数的变量。这就是为什么我们有像<code class="fe mt mu mv mj b">switchNameHandler: e =&gt; this.switchNameHandler(e)</code>这样的项目。让我们看看Child组件，看看我们是如何利用它的。</p><p id="05e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">子组件</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Child.js</figcaption></figure><p id="5588" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，整个组件再次被消费者上下文对象包装起来。消费者内部是<code class="fe mt mu mv mj b">{context =&gt; (...)}</code>。这将消费者中的项目连接到提供方的<code class="fe mt mu mv mj b">value= ...</code>项目。这是因为消费者已经订阅了提供者中的值。<strong class="jm io">注意:“上下文”是任意的名称，可以是任何名称。它不必是“上下文”。</strong></p><p id="10d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看消费者。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="6978" class="mn la in mj b gy mo mp l mq mr">&lt;Consumer&gt;</span><span id="1b68" class="mn la in mj b gy ms mp l mq mr">   {context =&gt; (</span><span id="1065" class="mn la in mj b gy ms mp l mq mr">     &lt;div&gt;</span><span id="0eb4" class="mn la in mj b gy ms mp l mq mr">       &lt;h1&gt;Child Component&lt;/h1&gt;</span><span id="8aaf" class="mn la in mj b gy ms mp l mq mr">       {context.state.people.map(person =&gt; {</span><span id="b204" class="mn la in mj b gy ms mp l mq mr">          return (</span><span id="e873" class="mn la in mj b gy ms mp l mq mr">          &lt;p key={person.id}&gt; Hi, I am {person.name} and I am        </span><span id="b0ab" class="mn la in mj b gy ms mp l mq mr">          {person.age} years old. &lt;/p&gt;</span><span id="abc8" class="mn la in mj b gy ms mp l mq mr">          )</span><span id="8a3d" class="mn la in mj b gy ms mp l mq mr">        })}</span><span id="fc2c" class="mn la in mj b gy ms mp l mq mr">       &lt;button onClick={() =&gt; context.toggleComponent()}&gt;</span><span id="a9c5" class="mn la in mj b gy ms mp l mq mr">          Toggle Component &lt;/button&gt;</span><span id="04d5" class="mn la in mj b gy ms mp l mq mr">       {context.state.toggleGrandChild ? &lt;GrandChild /&gt; : null}</span><span id="6364" class="mn la in mj b gy ms mp l mq mr">     &lt;/div&gt;</span><span id="b159" class="mn la in mj b gy ms mp l mq mr">   )}</span><span id="884c" class="mn la in mj b gy ms mp l mq mr">&lt;/Consumer&gt;</span></pre><p id="d900" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们映射包含在父组件状态中的people对象。<em class="md">我们如何接触人们？</em>简单。我们用<code class="fe mt mu mv mj b">context.state.people</code>。还记得我们在父组件值中设置的<code class="fe mt mu mv mj b">state: this.state</code>吗？这就是为什么我们能接触到<code class="fe mt mu mv mj b">context.state</code>。如果我们写了<code class="fe mt mu mv mj b">context.state.toggleGrandChild</code>，那么我们就可以访问<code class="fe mt mu mv mj b">toggleGrandChild</code>状态值。</p><p id="1003" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到通过people对象进行映射。我们像第一部分一样映射对象并返回<code class="fe mt mu mv mj b">Hi, I am {person.name} and I am {person.age} years old.</code>，但是，现在它下面有一个按钮。让我们来看看。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="6101" class="mn la in mj b gy mo mp l mq mr">&lt;button onClick={() =&gt; context.toggleComponent()}&gt;Toggle Component&lt;/button&gt;</span></pre><p id="8cfb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你能猜到这是干什么的吗？它调用父组件中的函数<code class="fe mt mu mv mj b">toggleComponent</code>。还记得这个函数是做什么的吗？</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="fe3b" class="mn la in mj b gy mo mp l mq mr">toggleComponent = () =&gt; {</span><span id="e6e4" class="mn la in mj b gy ms mp l mq mr">    this.setState({</span><span id="e081" class="mn la in mj b gy ms mp l mq mr">        toggleGrandChild: !this.state.toggleGrandChild,</span><span id="3d62" class="mn la in mj b gy ms mp l mq mr">    })</span><span id="d72a" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="4406" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它切换<code class="fe mt mu mv mj b">toggleGrandChild</code>的状态值。让我们看看按钮下面一点。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="b3e8" class="mn la in mj b gy mo mp l mq mr">context.state.toggleGrandChild ? &lt;GrandChild /&gt; : null</span></pre><p id="8976" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这对你来说很陌生，不要担心。这只是一种写if else语句的奇特的速记方式。很容易写成这样。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="4e39" class="mn la in mj b gy mo mp l mq mr">if context.state.toggleGrandChild === true {</span><span id="1998" class="mn la in mj b gy ms mp l mq mr">    &lt;GrandChild /&gt;</span><span id="501a" class="mn la in mj b gy ms mp l mq mr">} else {</span><span id="fadb" class="mn la in mj b gy ms mp l mq mr">    null</span><span id="fa1c" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="7eb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简写符号只是节省了一些空间，但是标准的if else语句也能很好地工作。</p><p id="1ed2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，这部分在做什么？它从父组件状态中获取<code class="fe mt mu mv mj b">toggleGrandChild</code>的值。如果值为true，那么它将呈现孙组件。如果该值为false，则不会呈现任何内容。</p><p id="3516" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你按下按钮时，它将调用父组件中的<code class="fe mt mu mv mj b">toggleComponent</code>函数。这是因为您在父组件的提供者的value部分传递了<code class="fe mt mu mv mj b">toggleComponent: this.toggleComponent</code>。这个函数是做什么的？哦，对了。它改变<code class="fe mt mu mv mj b">toggleGrandChild</code>的值。哇！太神奇了。您刚刚从子组件中更改了状态。恭喜你，我的朋友。</p><p id="68f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">孙组件</strong>。好了，我们到了最后阶段。我们已经学习了如何通过子组件更新状态。但是，我们只是切换了一个值true或false。那不是非常有趣或令人兴奋的。让我们继续更新一个字符串值。首先，我们将查看孙子组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">GrandChild.js</figcaption></figure><p id="81bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个组件中也有很多内容。乍一看，它与子组件非常相似。它通过people对象映射并打印相同的<code class="fe mt mu mv mj b">Hi, I am {person.name} and I am {person.age} years old.</code>。还有一个按钮。但是，按钮似乎在做不同的事情？让我们来看看。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="e270" class="mn la in mj b gy mo mp l mq mr">&lt;button</span><span id="50f0" class="mn la in mj b gy ms mp l mq mr">   onClick={</span><span id="1d7f" class="mn la in mj b gy ms mp l mq mr">     context.state.toggleName ? e =&gt;</span><span id="a19b" class="mn la in mj b gy ms mp l mq mr">     context.switchNameHandler("Bob") : e =&gt; <br/>          <br/>     context.switchNameHandler("Mark") }&gt;</span><span id="7a94" class="mn la in mj b gy ms mp l mq mr">   Toggle Name</span><span id="8bb4" class="mn la in mj b gy ms mp l mq mr">&lt;/button&gt;</span></pre><p id="905b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们不是仅仅调用一个函数来切换真或假，而是实际上将一个值传递给一个函数。让我们回头看看在父组件的提供者中作为值传递的<code class="fe mt mu mv mj b">switchNameHandler</code>。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c465" class="mn la in mj b gy mo mp l mq mr">value={{</span><span id="b48f" class="mn la in mj b gy ms mp l mq mr">   state: this.state,</span><span id="eddc" class="mn la in mj b gy ms mp l mq mr">   toggleComponent: this.toggleComponent,</span><span id="10d3" class="mn la in mj b gy ms mp l mq mr">   switchNameHandler: e =&gt; this.switchNameHandler(e)</span><span id="90ac" class="mn la in mj b gy ms mp l mq mr">}}</span></pre><p id="87c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们将值<code class="fe mt mu mv mj b">switchNameHandler</code>赋给<code class="fe mt mu mv mj b">e =&gt; this.switchNameHandler(e)</code>。这让我们可以在上下文消费者中使用<code class="fe mt mu mv mj b">context.switchNameHandler({value})</code>。目前，我们正在传递一个名字。让我们再来看看<code class="fe mt mu mv mj b">switchNameHandler</code>函数。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c267" class="mn la in mj b gy mo mp l mq mr">switchNameHandler = newName =&gt; {</span><span id="52d5" class="mn la in mj b gy ms mp l mq mr">    this.setState({</span><span id="8b6f" class="mn la in mj b gy ms mp l mq mr">       toggleName: !this.state.toggleName,</span><span id="70ea" class="mn la in mj b gy ms mp l mq mr">       people: [</span><span id="0671" class="mn la in mj b gy ms mp l mq mr">          { id: 0, name: newName, age: 24 },</span><span id="8378" class="mn la in mj b gy ms mp l mq mr">          { id: 1, name: "Jack", age: 22 },</span><span id="a390" class="mn la in mj b gy ms mp l mq mr">          { id: 2, name: "Jill", age: 26 },</span><span id="b041" class="mn la in mj b gy ms mp l mq mr">       ],</span><span id="701a" class="mn la in mj b gy ms mp l mq mr">     })</span><span id="18ad" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="ff6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将toggleName的值切换为true或false。接下来，我们再次为每个people对象分配id、姓名和年龄。但是，这一次，对于第一个人对象，我们传入值<code class="fe mt mu mv mj b">newName</code>。这是从函数传递的值。让我们跳回调用该函数的孙儿组件。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="3a23" class="mn la in mj b gy mo mp l mq mr">onClick={</span><span id="af56" class="mn la in mj b gy ms mp l mq mr">    context.state.toggleName</span><span id="5520" class="mn la in mj b gy ms mp l mq mr">    ? e =&gt; context.switchNameHandler(“Bob”)</span><span id="864a" class="mn la in mj b gy ms mp l mq mr">    : e =&gt; context.switchNameHandler(“Mark”)</span><span id="ace4" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="0516" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住，这只是一个花哨的if else语句。很容易写成这样。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="e6fd" class="mn la in mj b gy mo mp l mq mr">if context.state.toggleName === true {</span><span id="8767" class="mn la in mj b gy ms mp l mq mr">    e =&gt; context.switchNameHandler("Bob")</span><span id="e3c2" class="mn la in mj b gy ms mp l mq mr">} else {</span><span id="9d8c" class="mn la in mj b gy ms mp l mq mr">    e =&gt; context.switchNameHandler("Mark")</span><span id="e067" class="mn la in mj b gy ms mp l mq mr">}</span></pre><p id="710d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将根据父组件中的状态检查<code class="fe mt mu mv mj b">toggleName</code>的值。如果为真，那么它将把<code class="fe mt mu mv mj b">Bob</code>传递给<code class="fe mt mu mv mj b">switchNameHandler</code>函数。然后，这将第一个人对象的名称更新为<code class="fe mt mu mv mj b">Bob</code>。然后，它会将<code class="fe mt mu mv mj b">toggleName</code>更新为false。注意，如果您按下<code class="fe mt mu mv mj b">Toggle Component</code>按钮，它仍然会切换孙组件。但是，它不会改变<code class="fe mt mu mv mj b">toggleName</code>的状态值。因此，无论孙组件是否可见，该名称都将保留。</p><h1 id="e204" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="2e3d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">因此，我们已经了解了如何使用React的上下文API，不仅从子组件读取父组件的状态，还从子组件更新父组件的状态。子组件中的使用者订阅从父组件中的提供者传递的值。现在，您可以利用上下文来读取和更新状态。去做些伟大的事情吧！</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="7366" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="md">原载于</em><a class="ae ky" href="https://techflip.netlify.com/react-context-api-part-2/" rel="noopener ugc nofollow" target="_blank"><em class="md">https://techflip.netlify.com</em></a><em class="md">。</em></p></div></div>    
</body>
</html>