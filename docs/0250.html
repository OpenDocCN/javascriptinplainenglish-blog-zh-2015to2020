<html>
<head>
<title>Recursion Explained With Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归举例说明</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recursion-explained-with-example-62473f311230?source=collection_archive---------5-----------------------#2019-09-05">https://javascript.plainenglish.io/recursion-explained-with-example-62473f311230?source=collection_archive---------5-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88985db7cc687d518f28c2c83fc4cac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6NXlNl-Sactz_PXaMo24A.png"/></div></div></figure><p id="ed69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大部分程序员都听说过这个概念，都很恐惧。他们倾向于远离它。这是一个可怕的话题，但它并不一定如此！我花了几个星期才恍然大悟，希望我能为其他人加快这个过程。为了真正理解递归，你必须对不同的思考和解决问题的方式敞开心扉。</p><h1 id="f49c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是递归？</h1><p id="b211" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">递归是函数调用自己。我知道这听起来很奇怪。当一个人在编码时，你自己进行函数调用是很不寻常的，但是它可能是有用的。它经常出现在二分搜索法树上。下面是一个简单问题的递归示例:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e546" class="mi kx iq me b gy mj mk l ml mm">//Returns the sum of all numbers from 0 to a given integer<br/>function sumRange(num){<br/>    if (num === 0){<br/>        return 0<br/>    }<br/>    <br/>    return num + sumRange(num -1)<br/>}</span></pre><p id="0626" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于递归，要记住的重要一点是，它是一种<strong class="ka ir">不同的</strong>思维方式。代码不是从头到尾都被求解的，它实际上是从末尾向后求解的。以下是计算机解决这个问题的方法:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/90e0ce26f22da861ec5ecda78b05cca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qrW9yCu5g69o6nIh.gif"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Recursion Example</figcaption></figure><p id="e407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是计算机递归解决问题的方式。希望我没有失去你。这样做的好处是，你实际上不需要一次又一次地解决迭代，你只需要给函数一个可以遵循的模式。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d4d6" class="mi kx iq me b gy mj mk l ml mm">//Returns the sum of all numbers from 0 to a given integer<br/>function sumRange(num){<br/>    if (num === 0){<br/>        return 0<br/>    }<br/>    <br/>    return num + sumRange(num -1)<br/>}</span></pre><p id="909d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将解释递归思维的思维模式。让我们回头看看代码。</p><p id="4d67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以将代码分为两部分:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6d88" class="mi kx iq me b gy mj mk l ml mm">if (num === 0){<br/>    return 0<br/>}</span></pre><p id="35df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1-基本情况。</p><p id="00dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是你的模式的终点。在这种情况下，我们将从0到整数的所有数字相加。不管整数是1、10还是100，我们总是把每个数字相加，当我们到达0时停止。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="087f" class="mi kx iq me b gy mj mk l ml mm">return num + sumRange(num -1)</span></pre><p id="4a6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2-主模式</p><p id="a786" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是函数根据特定问题的模式调用自身的地方。很常见的是，函数每次都用更小的<strong class="ka ir">号</strong>和更小的<strong class="ka ir">号</strong>来调用自己，直到它最终到达你的<strong class="ka ir">基用例</strong>。在这种情况下，我们用相同的数字减一再次调用该函数。这个数字会一直变小，直到达到我们的<strong class="ka ir">基数</strong>，0。</p><p id="ecf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是递归的全部内容。递归思考实际上就是思考一个问题并把它分成两件事:它的基本情况是什么？它的模式是什么？</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="8cf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">原载于2019年9月5日</em><a class="ae na" href="https://kyoung90.github.io/recursion_explained_with_example" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://kyoung 90 . github . io</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>