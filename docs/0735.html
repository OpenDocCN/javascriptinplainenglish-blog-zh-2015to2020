<html>
<head>
<title>How to build a simple Task Manager with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用React构建一个简单的任务管理器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-simple-task-manager-with-react-8895d4526b2e?source=collection_archive---------6-----------------------#2019-12-03">https://javascript.plainenglish.io/how-to-build-a-simple-task-manager-with-react-8895d4526b2e?source=collection_archive---------6-----------------------#2019-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/970326b474d50f508ef785e8426143d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*qss-JZ9HZriMWjBHaBRCyA.gif"/></div></figure><p id="6436" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于“<em class="ks">你有什么反应？”这个问题，我厌倦了用“<em class="ks">不</em>来回答。所以我决定学习它，用这篇文章记录我构建的项目，并希望帮助其他面临同样挑战的人学习React。</em></p><p id="5ec6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当学习新东西时，我选择从最简单的例子开始，这次是一个<em class="ks">待办事项列表</em>，即<em class="ks">任务管理器。</em></p><p id="32bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顺便说一句，在这个旅程中，我意识到了React为什么是一个令人惊叹的库！:)</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="4cec" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置</h1><p id="813c" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">我们将使用运行React应用程序所需的<a class="ae md" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node.js </a>和<a class="ae md" href="https://www.npmjs.com/get-npm" rel="noopener ugc nofollow" target="_blank"> npm </a>(它们在一起)。</p><p id="6555" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，我们将使用一个公共API来发出一些获取和存储数据的请求。有问题的API是<a class="ae md" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>。</p><p id="6ca2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将通过运行以下命令创建一个React应用程序:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a7df" class="mn lb iq mj b gy mo mp l mq mr"><strong class="mj ir"><em class="ks">npx</em></strong><em class="ks"> </em><strong class="mj ir"><em class="ks">create-react-app &lt;name-of-your-app&gt;</em></strong></span></pre><blockquote class="ms mt mu"><p id="bc83" class="ju jv ks jw b jx jy jz ka kb kc kd ke mv kg kh ki mw kk kl km mx ko kp kq kr ij bi translated"><a class="ae md" href="https://medium.com/javascript-in-plain-english/yes-its-npx-not-npm-the-difference-explained-58cbb202ec33" rel="noopener">没错，是</a> <code class="fe my mz na mj b"><a class="ae md" href="https://medium.com/javascript-in-plain-english/yes-its-npx-not-npm-the-difference-explained-58cbb202ec33" rel="noopener"><em class="iq">npx</em></a></code> <a class="ae md" href="https://medium.com/javascript-in-plain-english/yes-its-npx-not-npm-the-difference-explained-58cbb202ec33" rel="noopener">，不是</a> <code class="fe my mz na mj b"><a class="ae md" href="https://medium.com/javascript-in-plain-english/yes-its-npx-not-npm-the-difference-explained-58cbb202ec33" rel="noopener"><em class="iq">npm</em></a></code> <a class="ae md" href="https://medium.com/javascript-in-plain-english/yes-its-npx-not-npm-the-difference-explained-58cbb202ec33" rel="noopener"> :) </a> <br/>顺便说一下，<a class="ae md" href="https://www.npmjs.com/package/npx" rel="noopener ugc nofollow" target="_blank"> npx </a>是从npm5.2版本开始捆绑npm来执行节点包的工具。</p></blockquote><p id="9141" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好了，现在我们已经初始化了React应用程序，我们可以开始创建所需的组件了。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="7402" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实施</h1><p id="6798" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">出于任务管理器的目的，我们将只创建<strong class="jw ir">三个组件</strong> ( <strong class="jw ir"> <em class="ks">任务列表</em> </strong>、<strong class="jw ir"> <em class="ks">加载器</em> </strong>和主<strong class="jw ir"> <em class="ks"> TaskApp </em> </strong>)只是为了简单明了。</p><h2 id="98f6" class="mn lb iq bd lc nb nc dn lg nd ne dp lk kf nf ng lo kj nh ni ls kn nj nk lw nl bi translated">任务列表组件</h2><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Task List Component</figcaption></figure><p id="10ee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的TaskList组件实际上是一个无序列表<code class="fe my mz na mj b">&lt;ul&gt;</code>。</p><p id="972e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它由一个<em class="ks">构造器</em>、<em class="ks">三个方法</em>和默认的<em class="ks">渲染</em>方法组成。<br/>为了更清楚地了解每种方法的作用:</p><ul class=""><li id="00a6" class="ns nt iq jw b jx jy kb kc kf nu kj nv kn nw kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks">构造函数</em> </strong>:调用<em class="ks"> super(props) </em>，它引用父类构造函数及其属性，同样，这里我们将<code class="fe my mz na mj b">this</code>实例绑定到使用TaskList组件状态的方法，这样我们就可以在这些方法中访问它；</li></ul><blockquote class="ms mt mu"><p id="9bdb" class="ju jv ks jw b jx jy jz ka kb kc kd ke mv kg kh ki mw kk kl km mx ko kp kq kr ij bi translated">如果我们在某些方法中不需要<strong class="jw ir">状态</strong>，那么<strong class="jw ir">就不需要</strong>将<code class="fe my mz na mj b"><strong class="jw ir"><em class="iq">this</em></strong></code>实例绑定到它上面。</p></blockquote><ul class=""><li id="e8ca" class="ns nt iq jw b jx jy kb kc kf nu kj nv kn nw kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks"> displayTask: </em> </strong>这个方法，顾名思义，就是显示一个特定的任务，实际上就是在任务列表中添加一个<code class="fe my mz na mj b">&lt;li&gt;</code>项目。<br/>它接收一个<em class="ks">任务</em>作为参数，这个参数是我们从任务列表中得到的一个对象，它是作为对API请求的响应而接收的。这个对象是我们获取所有需要的数据的来源，这些数据应该显示在单个任务上，如<em class="ks"> id </em>、<em class="ks">标题</em>、任务完成后的<em class="ks">信息、</em>等；</li><li id="f633" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"><em class="ks">updateTaskStatus:</em></strong>该方法接收一个<em class="ks">任务</em>作为参数，并通过向API发送一个请求，将其状态设置为<em class="ks">已完成</em>，其中<em class="ks">已完成</em>字段为<em class="ks">真，</em>并且在请求成功时，我们删除任务，表示现在任务已完成；</li><li id="1e9c" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks"> finishTask: </em> </strong>该方法接收一个<em class="ks">事件</em>作为参数，从中我们得到<em class="ks">当前选中的任务</em>并将其传递给<strong class="jw ir"><em class="ks">updateTaskStatus</em></strong>方法；</li><li id="c420" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks">渲染</em> : </strong>默认的渲染方法有定义组件渲染时发生什么的代码。在这种情况下，当呈现TaskList组件时，会发生以下情况:</li></ul><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a7b6" class="mn lb iq mj b gy mo mp l mq mr"><strong class="mj ir">1.</strong> We check if the number of items (<em class="ks">tasks</em>) is not equal to zero i.e. if the array of items is not empty;</span><span id="cc67" class="mn lb iq mj b gy og mp l mq mr"><strong class="mj ir">2.</strong> If true, we loop through all of them and we display each <em class="ks">task</em>   i.e. we call the <strong class="mj ir"><em class="ks">displayTask </em></strong>method for each task;</span><span id="5d9c" class="mn lb iq mj b gy og mp l mq mr"><strong class="mj ir">3.</strong> Else, we’re showing a notification to the user that they don’t have any tasks at the moment.</span></pre><h2 id="d9cd" class="mn lb iq bd lc nb nc dn lg nd ne dp lk kf nf ng lo kj nh ni ls kn nj nk lw nl bi translated">加载器组件</h2><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Loader Component</figcaption></figure><p id="1745" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">加载器组件是必需的，因此我们可以向用户显示在发送请求的同时正在做什么。</p><p id="9f13" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该组件由两种方法组成:</p><ul class=""><li id="2fb0" class="ns nt iq jw b jx jy kb kc kf nu kj nv kn nw kr nx ny nz oa bi translated"><strong class="jw ir"><em class="ks">updateLoaderVisibility:</em></strong>更新<em class="ks">加载器</em> ( <code class="fe my mz na mj b">true -&gt; Visible</code> &amp; <code class="fe my mz na mj b">false -&gt; Hidden</code>)的<em class="ks">可见</em>属性的状态；</li><li id="0907" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks"> render: </em> </strong>定义加载器本身的HTML结构，并根据<code class="fe my mz na mj b">visible</code>属性的当前状态设置加载器是否隐藏；</li></ul><h2 id="518e" class="mn lb iq bd lc nb nc dn lg nd ne dp lk kf nf ng lo kj nh ni ls kn nj nk lw nl bi translated">任务应用程序组件</h2><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Task App Component</figcaption></figure><p id="079f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">TaskApp组件在我们的例子中是父组件，它由多个<em class="ks">方法</em>、<em class="ks">构造器</em>和默认的<em class="ks">呈现</em>方法组成。<br/>下面详细介绍了它们的功能:</p><ul class=""><li id="c119" class="ns nt iq jw b jx jy kb kc kf nu kj nv kn nw kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks">构造器:</em> </strong>和往常一样，这里我们调用<em class="ks"> super(props) </em>并将<code class="fe my mz na mj b">this</code>实例绑定到TaskApp组件的方法上。<br/>同样，在这个构造函数中，我们设置了属性的默认<em class="ks">状态</em>，这些属性是items ( <em class="ks"> tasks </em>)、current <em class="ks"> task </em>和对<em class="ks"> Loader </em>组件的<em class="ks">引用</em>以及对<em class="ks"> task input </em>的<em class="ks">引用</em>。在构造函数中可以看到，这三个属性的默认状态是:<code class="fe my mz na mj b">items=[]</code> ( <em class="ks">我们默认没有任务</em>)和<code class="fe my mz na mj b">task=''</code> ( <em class="ks">我们默认没有要添加的任务</em>)。</li></ul><blockquote class="ms mt mu"><p id="c654" class="ju jv ks jw b jx jy jz ka kb kc kd ke mv kg kh ki mw kk kl km mx ko kp kq kr ij bi translated"><strong class="jw ir"> React引用</strong>是一种访问和操作DOM节点或React组件的方式。</p></blockquote><p id="2561" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的例子中，我们使用它们:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f51d" class="mn lb iq mj b gy mo mp l mq mr"><strong class="mj ir">1.</strong> To change Loader’s <em class="ks">visibility</em> <em class="ks">state</em> i.e. to switch the Loader component from hidden to shown and vice versa;</span><span id="197f" class="mn lb iq mj b gy og mp l mq mr"><strong class="mj ir">2. </strong>To focus the task input when needed;</span></pre><blockquote class="ms mt mu"><p id="0617" class="ju jv ks jw b jx jy jz ka kb kc kd ke mv kg kh ki mw kk kl km mx ko kp kq kr ij bi translated">更多关于React Refs <a class="ae md" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">的信息请点击</a>。</p></blockquote><ul class=""><li id="1431" class="ns nt iq jw b jx jy kb kc kf nu kj nv kn nw kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks"> render: </em> </strong>在这个组件的render方法中，我们包含了<em class="ks"> Loader </em>组件，它定义了<em class="ks"> loaderInstance </em>的<em class="ks"> Ref </em>，以及<em class="ks"> TaskList </em>组件，我们与它共享<code class="fe my mz na mj b">items</code>的当前状态以及一个<em class="ks">表单</em>，我们将使用它向列表添加新任务。表单本身非常简单，仅由一个<em class="ks">文本输入</em>和一个<em class="ks">提交按钮</em>组成。<br/>在输入改变时，我们调用<strong class="jw ir"><em class="ks">On inputchange</em></strong>方法，输入的值是<code class="fe my mz na mj b">task</code>属性的当前状态。在提交表单时，我们调用<strong class="jw ir"> <em class="ks"> addTask </em> </strong>方法。</li><li id="49e6" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"><em class="ks">on input change:</em></strong>该方法接收<em class="ks">事件</em>作为参数，从中获取输入的当前<em class="ks">值</em>，并将<code class="fe my mz na mj b">task</code>的当前状态设置为等于该值；</li><li id="7fce" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks"> addTask: </em> </strong>这个方法是在点击表单的提交按钮时执行的。顺便说一下，它还接收事件作为参数，这只是为了防止提交表单事件的默认行为。除此之外，该函数还会检查<code class="fe my mz na mj b">task</code>的当前值是否为空，如果是，它会警告用户任务(任务输入)的值不能为空，否则，如果不为空，它会显示加载程序，然后调用<strong class="jw ir"> <em class="ks"> storeTask </em> </strong>方法，最后它会将<code class="fe my mz na mj b">task</code>的当前<em class="ks">状态</em>设置为空字符串，这样就为下一个应该添加的任务做好了准备。</li><li id="65bc" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks"> storeTask: </em> </strong>这个方法向API发出一个POST请求，我们用它来存储任务和所有需要的数据。<br/>所有<em class="ks">任务</em>默认保存为<em class="ks">未完成</em>，默认<em class="ks"> userId </em>(任务所属的用户)<em class="ks"> </em>为<em class="ks"> 1 </em>。<br/>在请求的<em class="ks">成功</em>时，我们得到响应，其中包含存储的任务，我们将它添加到<code class="fe my mz na mj b">items</code>的数组中，即我们将<code class="fe my mz na mj b">items</code>属性的当前状态更改为多一个任务。</li><li id="08bd" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"> <em class="ks"> fetchTasks: </em> </strong>该方法向API发出GET请求，通过该请求我们得到一个<em class="ks">任务</em>列表，这些任务是<code class="fe my mz na mj b"><em class="ks">user</em></code><code class="fe my mz na mj b"><em class="ks">id=1</em></code><em class="ks"/>的任务，当<em class="ks">请求成功</em>时，我们将<code class="fe my mz na mj b">items</code>的当前状态设置为等于我们从请求中得到的响应列表，最后，我们隐藏了被设置为在<strong class="jw ir"> <em class="ks">组件中显示的加载程序</em></strong></li><li id="7bb0" class="ns nt iq jw b jx ob kb oc kf od kj oe kn of kr nx ny nz oa bi translated"><strong class="jw ir"><em class="ks">componentDidMount:</em></strong>这个方法是TaskApp组件渲染后执行的方法。在这里，我们只显示加载程序并调用<strong class="jw ir"> <em class="ks"> fetchTasks </em> </strong>方法。基本上，这是这个小应用程序的主页加载时发生的事情。</li></ul><h1 id="9ed5" class="la lb iq bd lc ld oh lf lg lh oi lj lk ll oj ln lo lp ok lr ls lt ol lv lw lx bi translated">CSS组织</h1><p id="4082" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">简单解释一下CSS文件的组织。</p><p id="fd9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">也就是说，为了遵循基于组件的开发原则，我们已经创建了<em class="ks">三个</em>单独的css文件(每个组件一个:<a class="ae md" href="https://github.com/siljanoskam/react-task-manager-app/blob/master/src/TaskList.css" rel="noopener ugc nofollow" target="_blank"> TaskList.css </a>、<a class="ae md" href="https://github.com/siljanoskam/react-task-manager-app/blob/master/src/Loader.css" rel="noopener ugc nofollow" target="_blank"> Loader.css </a>和<a class="ae md" href="https://github.com/siljanoskam/react-task-manager-app/blob/master/src/App.css" rel="noopener ugc nofollow" target="_blank"> App.css </a>)，并且我们正在为每个组件分别导入相应的所需CSS样式。</p><h1 id="d8b1" class="la lb iq bd lc ld oh lf lg lh oi lj lk ll oj ln lo lp ok lr ls lt ol lv lw lx bi translated">结论</h1><p id="3cf4" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">构建这个小小的应用程序很有趣，希望跟随它你也能学到一些东西。</p><p id="80f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">像任何应用程序一样，有一些改进要做，请随意使用和编辑它。你可以在这个<a class="ae md" href="https://github.com/siljanoskam/react-task-manager-app" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> Github repo </strong> </a>里找到代码。</p><p id="b7e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何被省略的步骤都可以在<strong class="jw ir">报告</strong>的<strong class="jw ir">自述文件</strong>中找到，或者你可以在评论中询问。</p><p id="fd7b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">继续编码，做令人敬畏的事情，保持快乐！😊</p></div></div>    
</body>
</html>