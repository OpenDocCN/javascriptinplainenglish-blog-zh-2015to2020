<html>
<head>
<title>How I reduced the code in my Redux app by using Redux Hooks.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何通过使用Redux钩子来减少Redux应用程序中的代码的。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-i-reduced-the-amount-of-code-in-my-redux-app-by-using-redux-hooks-b19c926419ea?source=collection_archive---------1-----------------------#2019-11-15">https://javascript.plainenglish.io/how-i-reduced-the-amount-of-code-in-my-redux-app-by-using-redux-hooks-b19c926419ea?source=collection_archive---------1-----------------------#2019-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d83a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">下面是如何简化所有组件中的Redux绑定，以帮助减少React Redux样板文件。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6114f87da5f5ebcd6b45e98b9860f3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3f2EAG-s3L7Z0mkvQIUJA.png"/></div></div></figure><h2 id="0036" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我最近写了一篇文章，比较了用React和React + Redux 构建的完全相同的应用。</h2><p id="af83" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt kx lu lv lw lb lx ly lz lf ma mb mc md ig bi translated">Redux应用程序的代码使用<code class="fe me mf mg mh b">connect()</code>绑定将我们的组件连接到我们的商店。这意味着我们需要像<code class="fe me mf mg mh b">mapStateToProps</code>和<code class="fe me mf mg mh b">mapDispatchToProps</code>这样的东西给我们的每个容器组件添加几行代码。</p><p id="ad6e" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><em class="mn">*容器组件通常是我们Redux商店的入口点。然后，这些文件将Redux存储状态作为道具传递给子组件。在我们的例子中，我们的容器组件是</em> <strong class="ln io"> <em class="mn"> App.js </em> </strong> <em class="mn">。但是如果您使用React路由器，您可能会决定将每个路由(例如</em><strong class="ln io"><em class="mn">index . js</em></strong><em class="mn">，</em><strong class="ln io"><em class="mn">about . js</em></strong><em class="mn">等)视为一个容器组件。单词“容器”的使用仅仅是一个语义单词，帮助开发人员将其与“常规”组件区分开来。这两个组件的创建方式没有区别，尽管如果您愿意，可以选择将容器组件放在应用程序目录中的</em> <strong class="ln io"> <em class="mn">容器</em> </strong> <em class="mn">文件夹中。</em></p><h2 id="9ce7" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">无论如何，一些人提到我应该使用钩子来简化Redux绑定。</h2><p id="8817" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt kx lu lv lw lb lx ly lz lf ma mb mc md ig bi translated">现在请记住，这不是一篇旨在鼓吹您应该去重写您以前所有的Redux代码的文章——因为如果它已经完美地工作了，您绝对不应该浪费时间重写。然而，我确实认为，如果用新的基于钩子的绑定替换旧的Redux绑定，那么让代码看起来像什么是个好主意。这样，您就可以利用这些新的绑定来开发下一个新项目。</p><p id="43d9" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><strong class="ln io"> <em class="mn">注意</em> </strong> <em class="mn">:我们不会深入到我们的动作、reducers或store(或任何其他通常位于</em><strong class="ln io"><em class="mn">redux</em></strong><em class="mn">文件夹中的文件)中使用的代码。由于这是上一篇文章</em>   <em class="mn">的延续，如果你想了解Redux的底层部分是如何工作的，我们建议你去阅读那篇文章。</em> <strong class="ln io"> <em class="mn">这里的链接可以找到</em></strong><a class="ae lk" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-with-react-and-redux-here-are-the-differences-6d8d5fb98222" rel="noopener"><strong class="ln io"><em class="mn"/></strong></a><em class="mn">。</em></p><p id="6883" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><em class="mn">注意:你仍然需要用react-redux </em> <code class="fe me mf mg mh b"><em class="mn">&lt;Provider&gt;</em></code> <em class="mn">组件包装你的应用。供参考，这是我们的</em><strong class="ln io"><em class="mn">src/index . js</em></strong><em class="mn">文件的样子:</em></p><pre class="kd ke kf kg gt mo mh mp mq aw mr bi"><span id="6bd3" class="ko kp in mh b gy ms mt l mu mv">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { Provider } from "react-redux";<br/>import configureStore from "./redux/store/configureStore";<br/>import App from "./App";</span><span id="7774" class="ko kp in mh b gy mw mt l mu mv">const store = configureStore(); </span><span id="7586" class="ko kp in mh b gy mw mt l mu mv">ReactDOM.render(<br/>  &lt;Provider store={store}&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Provider&gt;,<br/>  document.getElementById("root")<br/>);</span></pre><h1 id="86e1" class="mx kp in bd kq my mz na kt nb nc nd kw jt ne ju la jw nf jx le jz ng ka li nh bi translated">开始吧！</h1><p id="96e9" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt kx lu lv lw lb lx ly lz lf ma mb mc md ig bi translated">现在我们的待办事项应用程序非常简单，所以幸运的是我们只有一个需要使用Redux <code class="fe me mf mg mh b">connect()</code>绑定的文件。这个文件也不需要从我们的Redux store/actions中提取太多东西。然而，该文件看起来仍然很乱，正如我们从下图中看到的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/4b21627cb898abbbe60d8e77cf409b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcDWAjCp9TJUPdlG-T4Q0A.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Our app when using connect() bindings</figcaption></figure><p id="98b7" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">下面是我们新的<strong class="ln io"> App.js </strong>文件使用我们的Redux Hooks绑定后的样子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/a8442463a564e6cba18eb28008552da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7VETy-j5kgvwUr3avHMU_w.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Our app when using Redux Hooks</figcaption></figure><p id="5224" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">这两个截图之间的一个直接区别是，在第一个截图中，我们使用了<code class="fe me mf mg mh b">connect()</code>绑定，所有内容都被分离出来，而在第二个截图中，当我们使用Redux挂钩时，所有内容都被封装在我们的<code class="fe me mf mg mh b">App</code>变量中。这种封装是必需的，因为很简单，我们不能在React功能组件之外使用钩子。</p><p id="fbf2" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">那么，这个小问题解决了，让我们仔细阅读一下<code class="fe me mf mg mh b">App</code>中的五行代码，来理解这一切是如何工作的:</p><h1 id="45bb" class="mx kp in bd kq my mz na kt nb nc nd kw jt ne ju la jw nf jx le jz ng ka li nh bi translated">使用选择器()</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/191c43bb9615ed9d258d6295d91fee91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6P-0S7uyxgIxcfEleBu08g.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">useSelector()</figcaption></figure><p id="a48a" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><code class="fe me mf mg mh b">useSelector()</code>是一个钩子，它提供了对Redux存储状态的访问。这个钩子接受一个选择器函数作为参数。用存储状态调用选择器。所以这里我们调用我们的参数<code class="fe me mf mg mh b">store</code>，然后访问我们的<code class="fe me mf mg mh b">appReducer</code>，它的状态中有一个<code class="fe me mf mg mh b">list</code>对象。如果你很想知道这些部分是如何连接的，<a class="ae lk" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-with-react-and-redux-here-are-the-differences-6d8d5fb98222" rel="noopener">我建议你阅读之前的文章。通过使用<code class="fe me mf mg mh b">useSelector()</code>，我们有效地取代了使用<code class="fe me mf mg mh b">mapStateToProps()</code>的需要，使我们能够直接挂钩到Redux store，而不需要从更高级的组件传递状态作为道具。</a></p><p id="93ab" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">简而言之，这个钩子创建了对我们州的那个特定部分的引用。然后，我们可以在我们的应用程序中传递它，每当Redux更新它时，我们的引用也会更新。</p><p id="b82f" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">好的，我们可以通过钩子访问我们的状态，但是如何访问我们的调度函数呢？</p><h1 id="30d8" class="mx kp in bd kq my mz na kt nb nc nd kw jt ne ju la jw nf jx le jz ng ka li nh bi translated">使用Dispatch()</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4986964534937aba8ea5235687e97155.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*1-vByNfR_2L2C8O44F7C8g.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">useDispatch()</figcaption></figure><p id="e914" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><code class="fe me mf mg mh b">useDispatch()</code>是一个钩子，它为我们提供了对redux <code class="fe me mf mg mh b">dispatch</code>函数的访问。在上面的截图中，你可以看到我们把<code class="fe me mf mg mh b">useDispatch()</code>赋给了一个叫做<code class="fe me mf mg mh b">dispatch</code>的<code class="fe me mf mg mh b">const</code>。</p><p id="6aec" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">然后我们再创建两个<code class="fe me mf mg mh b">const</code>，它们与我们想要创建引用的分派函数具有相同的名称。你可以选择怎么称呼他们，但这是我选择的道路:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nq"><img src="../Images/d96c92c1aace3513dc09ae2ee88b63be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAgj0_V-0iFfboxYgzow-Q.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Our dispatch functions</figcaption></figure><p id="1b13" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">这可能一开始看起来有点混乱，所以让我们进一步分解它。我们正在创建接受参数的函数，<code class="fe me mf mg mh b">redux_add</code>函数中的<code class="fe me mf mg mh b">todo</code>和<code class="fe me mf mg mh b">redux_delete</code>函数中的<code class="fe me mf mg mh b">id</code>。这些基本上是我们的调度功能所需的有效载荷。然后我们的函数返回最初被赋予值<code class="fe me mf mg mh b">useDispatch()</code>的<code class="fe me mf mg mh b">dispatch</code>。</p><p id="88ee" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">由于它是对Redux dispatch函数的引用，我们基本上只是传入我们想要调用的函数，在<code class="fe me mf mg mh b">redux_add</code>的情况下，是位于<code class="fe me mf mg mh b">appActions</code>内部的<code class="fe me mf mg mh b">redux_add</code>函数，它被导入到文件的顶部。您还可以注意到，我们传入了<code class="fe me mf mg mh b">todo</code> param作为它的有效负载。我们对<code class="fe me mf mg mh b">redux_delete</code>函数做了同样的事情。</p><p id="c286" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">现在你可以选择其他方式来写这个。例如，我可以这样写:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/cda1db975b4c37d90fef9b660d9e8f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDlIcd1dMnkyN0I477SKiA.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">An alternative way to writing our dispatch functions</figcaption></figure><p id="341c" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">这实现了完全相同的事情，并且基本上是您最终会在<strong class="ln io"> appActions.js </strong>文件的每个函数中找到的内容。如果您选择第二种方式，请确保导入您的操作类型，而不是您的应用程序操作，这意味着导入:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/e9c1fa519315199b6e1cfb521213863b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2Z_UdYSPw7hv1w8u819pQ.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">importing actionTypes</figcaption></figure><p id="6760" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">而不是这个:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/4fca4ae6dad177e568569d80835f2349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrdBfBHCwRIDaPZphFSvpw.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">importing appActions</figcaption></figure><p id="920f" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">简而言之，我们使用<code class="fe me mf mg mh b">useDispatch()</code>来创建对特定调度函数的本地引用。这取代了我们使用<code class="fe me mf mg mh b">mapDispatchToProps()</code>的需要。</p><p id="2ad6" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">然后我们如何将这些值传递给我们的组件？</p><h1 id="9ba9" class="mx kp in bd kq my mz na kt nb nc nd kw jt ne ju la jw nf jx le jz ng ka li nh bi translated">小道具</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/2a617b3a3c1412c0facdbaadfd5e3ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4r58azbViYo7zrXavKgrw.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">How we passed in our props to the ToDo component</figcaption></figure><p id="fd42" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">这最后一点并不完全必要，因为我可以像这样将每一项传递给<code class="fe me mf mg mh b">&lt;ToDo/&gt;</code>组件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/ff3972d0cbfaca4066d13bc02402ae3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HH--T0KuSjuNvk77GZ7xWQ.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">An alternative approach to passing in our props.</figcaption></figure><p id="1482" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">但是我通常不喜欢这个样子，并且希望用于<code class="fe me mf mg mh b">connect()</code>绑定版本和Redux挂钩版本的props对象的代码看起来尽可能的相似——这是通过创建<code class="fe me mf mg mh b">props</code>对象实现的。</p><h1 id="1436" class="mx kp in bd kq my mz na kt nb nc nd kw jt ne ju la jw nf jx le jz ng ka li nh bi translated">所以我们有它！</h1><p id="367d" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt kx lu lv lw lb lx ly lz lf ma mb mc md ig bi translated">我们已经减少了Redux应用中的一些样板文件。除了冗余心智模型之外，样板文件可能是新开发人员需要考虑的问题。希望Redux挂钩可以帮助减少头部包装的数量。我们再也不用担心在<code class="fe me mf mg mh b">connect()</code>高阶组件中包装我们的组件了！</p><p id="aa3a" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated">现在，您可以像异步动作创建者一样，将注意力集中在更紧迫的问题上了！</p><p id="ea56" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><strong class="ln io"> <em class="mn">对比React与React-Redux的原文，可以在这里找到:</em></strong><a class="ae lk" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-with-react-and-redux-here-are-the-differences-6d8d5fb98222" rel="noopener">https://medium . com/JavaScript-in-plain-English/I-created-The-exact-same-app-with-React-and-Redux-here-is-The-The-differences-6 D8 D5 FB 98222</a></p><p id="ef97" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><strong class="ln io"> <em class="mn">如果你想回顾一下本文中用到的回购，可以在这里找到:【https://github.com/sunil-sandhu/redux-hooks-todo-2019】</em></strong><a class="ae lk" href="https://github.com/sunil-sandhu/redux-hooks-todo-2019" rel="noopener ugc nofollow" target="_blank"/></p><p id="3441" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt kx mk lv lw lb ml ly lz lf mm mb mc md ig bi translated"><strong class="ln io"> <em class="mn">你也可以在这里和原来使用旧绑定的Redux回购进行对比:</em></strong><em class="mn"/><a class="ae lk" href="https://github.com/sunil-sandhu/redux-todo-2019" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/redux-todo-2019</a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/388fb16639c684ff699d634d6b1d0cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygIsuDBleB-R036Im6_TXw.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">A screenshot of the app but cropped a bit so that we can use it for the featured image thing</figcaption></figure></div></div>    
</body>
</html>