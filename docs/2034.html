<html>
<head>
<title>How to deal with async/await in the array functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理数组函数中的async/await</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-deal-with-async-await-in-the-array-functions-4f592f1c0091?source=collection_archive---------3-----------------------#2020-05-14">https://javascript.plainenglish.io/how-to-deal-with-async-await-in-the-array-functions-4f592f1c0091?source=collection_archive---------3-----------------------#2020-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/aa8980d14dda925f75f5c8ef4da2d9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*Ll3gp9Y1tDfbCI1D-EfTnA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk"><a class="ae jy" href="https://icons8.com/icons/set/javascript" rel="noopener ugc nofollow" target="_blank">JavaScript icon</a> icon by <a class="ae jy" href="https://icons8.com/" rel="noopener ugc nofollow" target="_blank">Icons8</a></figcaption></figure><p id="4b68" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当我的一个朋友问我如何在map的回调中等待异步函数结果时，我萌生了写这篇文章的想法。我向他解释了他可以如何解决这个问题，然后想到很多人可能都有同样的问题，所以下一步对我来说很明显，写下来并与他人分享！</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="90df" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这篇文章是关于什么的？</h1><p id="7157" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">在本文中，我将分享我对如何处理JavaScript集合中的异步函数的想法。我将通过展示代码的例子来解释这一点，这对我来说是最好的，你也可以在我的<a class="ae jy" href="https://github.com/kwdowik/async-await-loops" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> github </em> </a>库中找到。</p><p id="afe1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们将使用通过ids返回用户的fake a API来模拟对real API的异步调用，基于此，我们将讨论几个示例，重点是:</p><ul class=""><li id="a534" class="mi mj iq kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">对于循环，</li><li id="e40f" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">对于每个人，</li><li id="536d" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">为了…的，</li><li id="1813" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">地图，</li><li id="3b5d" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">过滤器，</li><li id="8827" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">减少</li></ul><p id="6e9d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为了简化和主要关注你的主题，每个例子都有相同的主要步骤:</p><ul class=""><li id="6a54" class="mi mj iq kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">开始程序，</li><li id="5362" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">开始测量时间，</li><li id="c4ed" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">调用getUsers方法，</li><li id="6adf" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">结束测量时间，</li><li id="5e2e" class="mi mj iq kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">执行测试，</li></ul><p id="89bc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">此外，在一个并行方法中，为了更好地显示异步操作，增加了计数到10。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="2f7c" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们编码</h1><h2 id="d45b" class="mw lf iq bd lg mx my dn lk mz na dp lo kk nb nc ls ko nd ne lw ks nf ng ma nh bi translated"><strong class="ak">例1 </strong></h2><p id="7cb2" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated"><strong class="kb ir">使用for循环遍历回调</strong></p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ea5e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">测试<em class="mh">(第23行)</em>期望接收四个用户，但是当执行这个代码<em class="mh"> (node async-cb.js </em>)时将返回错误。如果我们记录用户，就会发现数组是空的，这是因为我们只是遍历了所有的id，而没有等待响应。我们可以通过注释掉测试<em class="mh">(第23行)</em>并添加日志API回调<em class="mh">(第9 -11行)</em>来证明这一点，然后您会看到我们实际上从我们的API接收了数据，因此正如您所看到的，主要问题是等待来自getUsers方法的数据，在接下来的每个示例中，我们将尝试解决这个问题。</p><h2 id="e277" class="mw lf iq bd lg mx my dn lk mz na dp lo kk nb nc ls ko nd ne lw ks nf ng ma nh bi translated"><strong class="ak">例2 </strong></h2><p id="0225" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated"><strong class="kb ir">使用<em class="mh"> for </em>循环</strong>遍历承诺</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dc6e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这个例子包含了另一个测试<em class="mh">(第22行)</em>，它主要检查从<em class="mh"> getUsers </em>方法返回的数据的格式。如果您执行这段代码，请注意这次测试通过了，此外您还会看到计数到10，以标记我们对API的调用是异步的。综上所述，添加在for循环内部调用的承诺保证在对数据执行任何操作之前等待数据，但是如果我们想使用像<em class="mh"> forEach、filter、map、reduce </em>这样的数组方法呢？</p><p id="e9ea" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们看看会发生什么。</p><h2 id="fa13" class="mw lf iq bd lg mx my dn lk mz na dp lo kk nb nc ls ko nd ne lw ks nf ng ma nh bi translated"><strong class="ak">例3 </strong></h2><p id="7392" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated"><strong class="kb ir">使用<em class="mh">forEach</em>T33】遍历承诺</strong></p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="45ce" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这个例子中，我们只替换了<em class="mh"> forEach </em>上的循环的<em class="mh">，但是当你执行这个代码时，你会看到我们的测试失败了，当你记录从<em class="mh"> getUsers </em>方法返回的用户时，你会看到数组是空的，所以基本上我们回到了起点，但是抬头，因为我们碰到了基础问题，这对于我们将要讨论的<em class="mh"> filter，map，reduce </em>方法也是一样的。</em></p><p id="f603" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">空用户数组是因为<em class="mh"> forEach </em>本身不等待回调，而是遍历所有对象，然后返回空用户数组，因为此时API没有做出任何响应。</p><p id="8f63" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在，我们将重点关注如何处理这种行为，并处理数组上的不同类型的操作，这些操作在回调中包含异步函数。</p><p id="019f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在我们进入下一个例子之前，请尝试执行以下代码</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="414e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们几乎没有将<em class="mh"> forEach </em>替换为<em class="mh">for……of，</em>检查结果并尝试回答自己为什么会这样？</p><h2 id="9197" class="mw lf iq bd lg mx my dn lk mz na dp lo kk nb nc ls ko nd ne lw ks nf ng ma nh bi translated"><strong class="ak">例4 </strong></h2><p id="1fe9" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated"><strong class="kb ir">使用<em class="mh">映射</em> </strong>遍历承诺</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="08e2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">由于使用了map，我们不必在遍历ids之前声明users数组，现在map本身根据工作原理返回用户，但这是真的吗？注意解决所有的承诺<em class="mh">(第10行)</em>是必需的，很多时候缺乏这一点，导致我们的问题，但为什么是必需的呢？map本身并不返回数据，但是它并不返回一个承诺数组，而是像在<em class="mh"> forEach </em>中一样与相同的事实相关联，<em class="mh"> map </em>不会等待每个承诺被解决，而是返回一个待定的承诺。</p><p id="641d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我想提醒您注意<em class="mh"> getUsers </em>的执行时间，让我们将它与循环的<em class="mh">进行比较</em></p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/f326605836c3e34bfd4d6b0f741f23ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*bsUCyl0NWxt86-ZvCXGEgA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">map time</figcaption></figure><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/086318005a92d83214f4f448f2f1c47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*NQobngt1-4CqSzPsXj2Dig.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">for loop time</figcaption></figure><p id="64d5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这种差异从何而来？这个方法中的每一个都为相同的用户id集执行四个请求，更准确地说，我们的API请求是大约500ms后返回用户的<em class="mh"> setTimeout </em>方法(或多或少是因为<em class="mh"> setTimeout </em>保证至少在500ms后执行回调，而不是正好在500 ms内，这不是本文的主题，所以要得到为什么我鼓励更熟悉事件循环的答案)。回到这个问题，不同之处在于map一个接一个地设置所有四个请求，而不等待每个响应</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0ab5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">之后，我们得到我们的用户<em class="mh"> (Promise.all) </em>，时间等于最长的承诺请求，在这种情况下对所有请求都是一样的，大约等于500ms，而for循环以这种方式工作:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="f219" class="mw lf iq bd lg mx my dn lk mz na dp lo kk nb nc ls ko nd ne lw ks nf ng ma nh bi translated">实例5</h2><p id="f86f" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated"><strong class="kb ir">使用<em class="mh">过滤器</em> </strong>遍历承诺</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a4ee" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这个例子中，我们的任务是只获得成年用户，知道如何从我们的API获得每个用户，达到我们的目标，我们只需要按年龄过滤这些用户<em class="mh">(第13行)</em>。通过引入<em class="mh">管道</em>方法，可以以一种更加功能化的方式实现我们的目标。在这个例子中，它将是<em class="mh">管道异步</em>，让我们看看代码将如何处理变更</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="dcaf" class="mw lf iq bd lg mx my dn lk mz na dp lo kk nb nc ls ko nd ne lw ks nf ng ma nh bi translated">实例6</h2><p id="2625" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated"><strong class="kb ir">使用<em class="mh"> reduce </em> </strong>遍历承诺</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="27c7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在我们的任务是合计用户帐户余额，如果您试图执行此代码，您将收到一个错误，让我们在第18行添加日志来检查总和</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nu"><img src="../Images/e2961f6b39c739e423f5416b2fc9926a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BM9DuFBABqp-GECvtZHsQ.png"/></div></div></figure><p id="a98c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="mh">【对象承诺】40000 </em>哪里来的？原来，40000值是最后一个用户的帐户余额(您可以在<em class="mh"> lib/api.js第5行</em>中查看)，但为什么我们会收到<em class="mh">【对象承诺】</em>，这与reduce的回调<em class="mh">(第6行)</em>中的一个异步关键字有关，每个异步函数都返回承诺，所以在我们的例子中<em class="mh"> prev </em>变量不等于特定值而是承诺，为了获得实际值，我们必须使用await关键字</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ddaf" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在测试通过了，但是我想让你注意一下执行时间</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nv"><img src="../Images/4d1cbe0503f81cda6dd134d83b3d9ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgeFXhdROe_Nd8fCRgIhMA.png"/></div></div></figure><p id="290d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为什么又超过了2000毫秒？看起来我们又回到了这个执行命令上</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e2b1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这是真的，因为引入了变量<em class="mh">prev sum</em>T22】(第3行)因为现在每个回调都必须等待上一个值才能发出API请求，为了解决这个问题，只需要交换第3行和第4行，让我们来看看结果</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nv"><img src="../Images/45b2bd74f12a45194cf96d3022ef72cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHOx1MBSYGct5mflP72tOg.png"/></div></div></figure><p id="a11c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">仅仅通过交换两行代码，我们就将代码的性能提高了75%!由此可见，理解好异步编程是多么重要。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="43bb" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">下一步是什么？</h1><p id="e68f" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">鼓励您查看我在<a class="ae jy" href="https://github.com/kwdowik/async-await-loops" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> github </em> </a>上的知识库，我在那里为您准备了一些练习，以提高您对async/await的信心。</p><p id="cea4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这就是我想给你看的，我希望你能从这篇文章中找到一些东西，我准备的练习会给你更多！</p><p id="05f8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你喜欢这篇文章，请鼓掌，如果你有任何问题，请在评论中留下，或者通过<a class="ae jy" href="https://twitter.com/k_wdowik" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> twitter </em> </a>与我保持联系！</p><p id="81c3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">推特:<a class="ae jy" href="https://twitter.com/k_wdowik" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> k_wdowik </em> </a></p><p id="d852" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一如既往，欢迎任何意见！</p><h1 id="f6e9" class="le lf iq bd lg lh nw lj lk ll nx ln lo lp ny lr ls lt nz lv lw lx oa lz ma mb bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="f681" class="pw-post-body-paragraph jz ka iq kb b kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击 点击<a class="ae jy" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kb ir">查看我们，并确保订阅该频道😎</strong></a></p></div></div>    
</body>
</html>