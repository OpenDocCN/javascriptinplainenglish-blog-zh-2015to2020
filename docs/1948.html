<html>
<head>
<title>Static Factory Method: An Alternative to Constructor Overloading in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">静态工厂方法:JavaScript中构造函数重载的替代方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/js-using-static-factory-method-as-an-alternative-of-constructor-overloading-473b67de6133?source=collection_archive---------6-----------------------#2020-05-06">https://javascript.plainenglish.io/js-using-static-factory-method-as-an-alternative-of-constructor-overloading-473b67de6133?source=collection_archive---------6-----------------------#2020-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="07a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构造函数重载是为一个类创建多个构造函数并在不同的上下文中使用不同的构造函数的能力。您可能已经知道，由于JavaScript的设计，它不支持真正的重载。我们唯一能做的就是在唯一的一个构造函数内部添加一些条件，在不同的构造逻辑之间切换。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="5be2" class="ku kv iq kq b gy kw kx l ky kz">class Transaction {<br/>  paymentType;<br/>  amount;<br/>  settleDate;</span><span id="4f14" class="ku kv iq kq b gy la kx l ky kz">  constructor(<em class="lb">paymentType</em>, <em class="lb">paymentObject</em>) {<br/>    this.paymentType = paymentType;</span><span id="8b23" class="ku kv iq kq b gy la kx l ky kz">    if (paymentType === 'CASH') {<br/>      this.amount = paymentObject.amount;<br/>      this.settleDate = new Date();<br/>    }<br/>    else if (paymentType === 'CREDIT_CARD') {<br/>      this.amount = paymentObject.creditAmount;<br/>      this.settleDate = paymentObject.settleDate;<br/>    }<br/>}</span></pre><p id="547d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这种方法在某些情况下并不理想。</p><figure class="kl km kn ko gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/27b9989c6eca3443b863b406fa068f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bufco1dIc0horb39tsezqA.jpeg"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Image from <a class="ae lo" href="http://www.builderintruro.com/" rel="noopener ugc nofollow" target="_blank">builderintruro.com</a></figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="459a" class="lw kv iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">问题</h1><p id="e3d3" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">将多个构造逻辑放在构造函数内部主要有两个问题。首先，当有许多案件要处理时，管理会变得困难。这是因为参数实例化不清楚。就像上面的例子一样，<code class="fe my mz na kq b">paymentObject</code>依赖于<code class="fe my mz na kq b">paymentType</code>，如果不查看代码的其余部分，我们是不会知道的。</p><p id="2490" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个问题是灵活性。当你希望基于不同的上下文有不同数量的参数时，就会变得很麻烦。当你想在不同的上下文中实例化对象时，有时你需要在参数中填充<code class="fe my mz na kq b">null</code>。当你需要更新你的构造函数的参数时，这是一个噩梦，因为它会影响所有现有的用法。因此，我想介绍静态工厂方法，这是一个更好的选择。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="83f5" class="lw kv iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">什么是静态工厂方法？</h1><p id="10fe" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">它指的是使用静态方法实例化对象而不是直接使用构造函数的技术。这里我想用一个例子来说明:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="610e" class="ku kv iq kq b gy kw kx l ky kz">class TestClass {<br/>  testValA;<br/>  testValB;</span><span id="59e0" class="ku kv iq kq b gy la kx l ky kz">  constructor(valA, valB) {<br/>    this.testValA = valA;<br/>    this.testValB = valB;<br/>  }<br/> <br/>  static testFactory(val) {<br/>    return new TestClass(val, val);<br/>  }<br/>}</span></pre><p id="4991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，<code class="fe my mz na kq b">testFactory</code>方法是一个静态工厂方法，它接受一个值并使用它来构造和返回一个<code class="fe my mz na kq b">TestClass</code>对象。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="c6cc" class="lw kv iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">运用这种方法</h1><p id="df36" class="pw-post-body-paragraph jn jo iq jp b jq mt js jt ju mu jw jx jy mv ka kb kc mw ke kf kg mx ki kj kk ij bi translated">下面是我们的<code class="fe my mz na kq b">Transaction</code>类在应用静态工厂方法后的样子:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="8cc2" class="ku kv iq kq b gy kw kx l ky kz">class Transaction {<br/>  paymentType;<br/>  amount;<br/>  settleDate;</span><span id="ffe1" class="ku kv iq kq b gy la kx l ky kz">  static withCash(cashObject) {<br/>    const transaction = new Transaction();<br/>    transaction.paymentType = 'CASH';<br/>    transaction.amount = cashObject.amount;<br/>    transaction.settleDate = new Date();<br/>    return transaction;<br/>  }</span><span id="80fd" class="ku kv iq kq b gy la kx l ky kz">  static withCreditCard(creditCardObject) {<br/>    const transaction = new Transaction();<br/>    transaction.paymentType = 'CREDIT_CARD';<br/>    transaction.amount = creditCardObject.creditAmount;<br/>    transaction.settleDate = creditCardObject.settleDate;<br/>    return transaction;<br/>  }<br/>}</span></pre><p id="3419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于实例化:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="b884" class="ku kv iq kq b gy kw kx l ky kz">//Previously<br/>console.log(new Transaction('CASH', cashObject));<br/>console.log(new Transaction('CREDIT_CARD', creditCardObject));</span><span id="1af4" class="ku kv iq kq b gy la kx l ky kz">//Now<br/>console.log(Transaction.withCash(cashObject));<br/>console.log(Transaction.withCreditCard(creditCardObject));</span></pre><p id="5af0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已！干净多了，不是吗？</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="1a9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！请随意留下评论，我将不胜感激。</p><p id="f3c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lb">更多内容请看</em><a class="ae lo" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lb">plain English . io</em></a></p></div></div>    
</body>
</html>