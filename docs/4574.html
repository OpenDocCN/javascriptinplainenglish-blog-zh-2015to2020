<html>
<head>
<title>JavaScript Basics: Execution Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:执行上下文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-basics-execution-context-bd79ede1ccdd?source=collection_archive---------20-----------------------#2020-12-21">https://javascript.plainenglish.io/javascript-basics-execution-context-bd79ede1ccdd?source=collection_archive---------20-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3086" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">运行JavaScript代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09e83c183c812ef9bbdee06e5b4193ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNrkK5WfvHQ8V5NBDGj06w.jpeg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="5631" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我们将讨论编译和执行JavaScript代码时会发生什么。</p><p id="643b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">每当在JavaScript中执行代码时，它都在所谓的<code class="fe lu lv lw lx b">execution context</code>中运行。<code class="fe lu lv lw lx b">execution context</code>被定义为Javascript执行的上下文或环境。可以把它想象成一个帮助管理正在运行的代码的包装器。</p><h1 id="6959" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">全局执行上下文</h1><p id="dd27" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">基地<code class="fe lu lv lw lx b">execution context</code>被称为<code class="fe lu lv lw lx b">global execution context</code>。它总是在JavaScript代码最初执行时创建。把<code class="fe lu lv lw lx b">global</code>想象成任何不在函数内部的代码。在JavaScript文件中的任何地方都可以访问<code class="fe lu lv lw lx b">global</code>级别中的所有代码。</p><p id="46ee" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">global execution content</code>创造了两件事:</p><ol class=""><li id="b0cf" class="mv mw iq la b lb lc le lf lh mx ll my lp mz lt na nb nc nd bi translated">全局对象</li><li id="f264" class="mv mw iq la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">变量，<code class="fe lu lv lw lx b">this</code></li></ol><p id="522e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当一个JavaScript文件被创建并运行时，一个<code class="fe lu lv lw lx b">execution context</code>将被创建，即使该文件没有代码。对于浏览器，“全局对象”将被称为<code class="fe lu lv lw lx b">window</code>对象。特殊变量<code class="fe lu lv lw lx b">this</code>也将指向<code class="fe lu lv lw lx b">window</code>对象。对于<code class="fe lu lv lw lx b">Node.js</code>，该“全局对象”将被称为<code class="fe lu lv lw lx b">global</code>对象。</p><p id="4ea7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在JavaScript中，当在全局级别创建一个函数时，它会被附加到全局对象上。举个例子，</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="bc93" class="nn lz iq lx b gy no np l nq nr">function sample(){</span><span id="d0c3" class="nn lz iq lx b gy ns np l nq nr">   console.log('sample')</span><span id="721d" class="nn lz iq lx b gy ns np l nq nr">}</span><span id="7426" class="nn lz iq lx b gy ns np l nq nr">window.sample() // logs out "sample"</span></pre><h1 id="4e18" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">执行上下文:创建和执行</h1><p id="758c" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">当JavaScript代码运行时，变量和函数在某种程度上是可用的，即使它们是在代码的后面编写的。这个概念背后的推理发生在<code class="fe lu lv lw lx b">execution context</code>正在被创建的过程中，这发生在两个阶段。</p><h2 id="c6f4" class="nn lz iq bd ma nt nu dn me nv nw dp mi lh nx ny mk ll nz oa mm lp ob oc mo od bi translated">创造</h2><p id="6220" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">在<code class="fe lu lv lw lx b">creation</code>阶段，我们有<code class="fe lu lv lw lx b">global object</code>和<code class="fe lu lv lw lx b">this</code>，它们是在内存中设置的。当解析器运行代码并翻译编写的代码时，它通过关键字<code class="fe lu lv lw lx b">var</code>、<code class="fe lu lv lw lx b">let</code>、<code class="fe lu lv lw lx b">const</code>和<code class="fe lu lv lw lx b">function</code>识别变量和函数是在哪里创建的。</p><p id="8da2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">变量和函数的存储空间在<code class="fe lu lv lw lx b">creation</code>阶段设置。这就是所谓的<code class="fe lu lv lw lx b">hoisting</code>。在开始逐行执行代码之前，JavaScript引擎已经为变量和函数留出了内存空间。整个函数都放在内存中。然而，对于变量，JavaScript引擎直到执行时才知道它的值是多少。取而代之的是，分配一个占位符值<code class="fe lu lv lw lx b">undefined</code>。</p><p id="41ee" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">undefined</code>是JavaScript中的一个特殊值/关键字，表示变量尚未设置。它是变量在<code class="fe lu lv lw lx b">creation</code>阶段得到的值。如果变量由定义，</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="a859" class="nn lz iq lx b gy no np l nq nr">let sample;</span></pre><p id="33a5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">默认情况下，<code class="fe lu lv lw lx b">sample</code>的值为<code class="fe lu lv lw lx b">undefined</code>，即使在<code class="fe lu lv lw lx b">creation</code>阶段之后也是如此，因为它从未被赋值。</p><h2 id="5aa0" class="nn lz iq bd ma nt nu dn me nv nw dp mi lh nx ny mk ll nz oa mm lp ob oc mo od bi translated">执行</h2><p id="d25f" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated"><code class="fe lu lv lw lx b">execution</code>阶段拥有<code class="fe lu lv lw lx b">creation</code>阶段的所有可用内容。这个阶段逐行运行编写的代码，并调用它运行的任何函数。</p><p id="a33f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">顺便提一下，JavaScript是<code class="fe lu lv lw lx b">single threaded</code>，这意味着它按照出现的顺序一次运行一行代码。</p><h1 id="9a30" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">函数调用和执行堆栈</h1><p id="74ac" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">到目前为止，我们知道每当运行一个JavaScript文件时，都会创建一个<code class="fe lu lv lw lx b">global execution context</code>，它在创建阶段为函数和变量提供<code class="fe lu lv lw lx b">this</code>变量、全局对象(<code class="fe lu lv lw lx b">window</code>)和内存空间。</p><p id="9a73" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<code class="fe lu lv lw lx b">execution</code>阶段，当它到达一行调用<code class="fe lu lv lw lx b">function</code>的代码时会发生什么？让我们检查以下内容:</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="f05c" class="nn lz iq lx b gy no np l nq nr">let global = 'variable';</span><span id="af3e" class="nn lz iq lx b gy ns np l nq nr">function sample(){</span><span id="68fa" class="nn lz iq lx b gy ns np l nq nr">   let a = 1;<br/>   other();</span><span id="c98a" class="nn lz iq lx b gy ns np l nq nr">}</span><span id="d934" class="nn lz iq lx b gy ns np l nq nr">function other(){</span><span id="1cdb" class="nn lz iq lx b gy ns np l nq nr">   let b = 'hey';<br/>}</span><span id="b2b8" class="nn lz iq lx b gy ns np l nq nr">sample();</span></pre><p id="9284" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当一个函数被调用时，一个新的<code class="fe lu lv lw lx b">execution context</code>被创建并被放置在所谓的<code class="fe lu lv lw lx b">execution stack</code>上。可以把<code class="fe lu lv lw lx b">execution stack</code>看作是跟踪正在运行的代码的东西。<code class="fe lu lv lw lx b">execution stack</code>遵循<strong class="la ir">后进先出(LIFO) </strong>原则。让我们使用上面的示例代码来可视化这种方法:</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="2964" class="nn lz iq lx b gy no np l nq nr">//EXECUTION STACK</span><span id="1ecd" class="nn lz iq lx b gy ns np l nq nr">other() Execution Context<br/>sample() Execution Context<br/>Global Execution Context // initial code run</span></pre><p id="c0a2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一个进入堆栈的是<code class="fe lu lv lw lx b">global execution context</code>，它包含变量<code class="fe lu lv lw lx b">global</code>和函数<code class="fe lu lv lw lx b">sample</code>和<code class="fe lu lv lw lx b">other</code>。一旦进入堆栈，它就逐行运行代码。当它到达调用<code class="fe lu lv lw lx b">sample()</code>的行时，另一个<code class="fe lu lv lw lx b">execution context</code>被创建，它包含变量<code class="fe lu lv lw lx b">a</code>。</p><p id="9a39" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于要从堆栈中移除的<code class="fe lu lv lw lx b">global execution context</code>，它必须完成所有代码行的执行，现在包括<code class="fe lu lv lw lx b">sample()</code>。因此，从<code class="fe lu lv lw lx b">sample()</code>创建的<code class="fe lu lv lw lx b">execution context</code>被添加到仍然包含<code class="fe lu lv lw lx b">global</code>的现有堆栈中。</p><p id="bc13" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们现在在<code class="fe lu lv lw lx b">sample()</code>的上下文中，它在代码块中运行两行代码。但是在它完成之前，它调用另一个函数<code class="fe lu lv lw lx b">other()</code>，创建另一个<code class="fe lu lv lw lx b">execution context</code>并将其添加到堆栈中。</p><p id="1c53" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">other()</code>代码块中的一行代码运行并结束。然后它被弹出并从栈顶移除。因为它是最后添加的执行上下文，所以也被删除。然后<code class="fe lu lv lw lx b">sample()</code>结束，并且<code class="fe lu lv lw lx b">execution context</code>从堆栈中移除。最后，<code class="fe lu lv lw lx b">global execution context</code>也被移除。一旦<code class="fe lu lv lw lx b">execution stack</code>被清空，代码就完成了运行。</p><p id="0137" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们看看同一个例子，但有一些变化:</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="fc20" class="nn lz iq lx b gy no np l nq nr">let global = 'variable';</span><span id="b589" class="nn lz iq lx b gy ns np l nq nr">function sample(){<br/>   let a = 1;<br/>}</span><span id="8285" class="nn lz iq lx b gy ns np l nq nr">function other(){<br/>   let b = 'hey';<br/>}</span><span id="622b" class="nn lz iq lx b gy ns np l nq nr">sample();<br/>other();</span></pre><p id="977b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当代码一行一行地运行<strong class="la ir">时，你认为<code class="fe lu lv lw lx b">execution stack</code>会是什么样子？</strong></p><h1 id="e2ad" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">功能、上下文和可变环境</h1><p id="eb50" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">每一次函数调用都会导致一个<code class="fe lu lv lw lx b">execution context</code>的创建，在那个环境中定义了它自己的一组变量和函数。这些变量和函数不能在上下文之外访问。让我们探索一下变量在内存中的位置以及它们之间的关系。假设我们有以下代码:</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="b058" class="nn lz iq lx b gy no np l nq nr">function b(){<br/>   let myVar;<br/>   console.log(myVar); // undefined<br/>}</span><span id="0e74" class="nn lz iq lx b gy ns np l nq nr">function a(){<br/>   let myVar = 2;<br/>   console.log(myVar); // 2<br/>   b();   <br/>}</span><span id="7b94" class="nn lz iq lx b gy ns np l nq nr">let myVar = 30;<br/>console.log(myVar); // 30</span><span id="d37f" class="nn lz iq lx b gy ns np l nq nr">a();<br/>console.log(myVar); //30</span></pre><p id="ecd2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们在不同的行中定义了变量<code class="fe lu lv lw lx b">myVar</code>。每个<code class="fe lu lv lw lx b">myVar</code>的值是多少？让我们想象一下代码运行时<code class="fe lu lv lw lx b">execution stack</code>的样子。</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="dcba" class="nn lz iq lx b gy no np l nq nr">// EXECUTION STACK</span><span id="6cab" class="nn lz iq lx b gy ns np l nq nr">b() Execution Context // myVar = undefined</span><span id="44c5" class="nn lz iq lx b gy ns np l nq nr">a() Execution Context // myVar = 2</span><span id="a6ff" class="nn lz iq lx b gy ns np l nq nr">Global Execution Context // myVar = 30</span></pre><p id="1e43" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在最初的代码执行中，我们总是有<code class="fe lu lv lw lx b">global execution context</code>，在那个上下文中，我们有一个<code class="fe lu lv lw lx b">myVar</code>被声明并赋给30。因此，上下文中的<code class="fe lu lv lw lx b">console.log(myVar)</code>将输出30。</p><p id="fe9a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我们调用函数<code class="fe lu lv lw lx b">a()</code>时，我们创建了一个<code class="fe lu lv lw lx b">execution context</code>，它自己的<code class="fe lu lv lw lx b">myVar</code>在上下文中声明并被赋值为2。当那个<code class="fe lu lv lw lx b">console.log(myVar)</code>运行时，它将打印2。</p><p id="953e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当最后一个函数<code class="fe lu lv lw lx b">b()</code>被调用时，另一个<code class="fe lu lv lw lx b">execution context</code>将被创建，并且声明的<code class="fe lu lv lw lx b">myVar</code>没有被赋值，默认情况下该值将被赋值给<code class="fe lu lv lw lx b">undefined</code>。该上下文中的<code class="fe lu lv lw lx b">console.log(myVar)</code>将打印出<code class="fe lu lv lw lx b">undefined</code>。<code class="fe lu lv lw lx b">b()</code>随后从堆栈中弹出，随后是<code class="fe lu lv lw lx b">a()</code>。</p><p id="17ae" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是函数<code class="fe lu lv lw lx b">a()</code>执行完之后的最后一个<code class="fe lu lv lw lx b">console.log(myVar)</code>会怎么样呢？那个<code class="fe lu lv lw lx b">console.log()</code>在全局上下文中，它的<code class="fe lu lv lw lx b">myVar</code>赋值为30，这将导致打印30。我们看到的每个变量都是在它自己的<code class="fe lu lv lw lx b">execution context</code>中定义的。因此，每个上下文都在其范围内寻找变量。</p><p id="5965" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然而，如果我们对代码做了一点小小的改动，就会影响打印出来的内容。如果我们移除<code class="fe lu lv lw lx b">a()</code>内的<code class="fe lu lv lw lx b">let</code>，现在将打印2。但是为什么呢？</p><h2 id="734b" class="nn lz iq bd ma nt nu dn me nv nw dp mi lh nx ny mk ll nz oa mm lp ob oc mo od bi translated">变量声明</h2><p id="87bf" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">在回答这个问题之前，我们先来快速定义一下<code class="fe lu lv lw lx b">let and const, and var</code>这样的关键词是做什么的。有了这些关键字，我们就<code class="fe lu lv lw lx b">declaring</code>了一个新变量，并赋予了一个新值。因此，如果我们删除关键字<code class="fe lu lv lw lx b">let</code>，我们就不再是内存中的一个新变量，我们只是重新分配一个现有的变量。</p><p id="72aa" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有关<code class="fe lu lv lw lx b">let, const, and var</code>的更深入信息，请参考<a class="ae oe" href="https://ui.dev/var-let-const/" rel="noopener ugc nofollow" target="_blank">https://ui.dev/var-let-const/</a></p><p id="05c7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这就引出了另一个问题:JavaScript如何知道要重新分配哪个<code class="fe lu lv lw lx b">myVar</code>？</p><h1 id="f052" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">范围链</h1><p id="9b58" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">当我们用变量做一些事情时，JavaScript不仅仅是查看当前<code class="fe lu lv lw lx b">execution context</code>的变量环境。每个<code class="fe lu lv lw lx b">execution context</code>都有一个对“外部”环境的引用。</p><p id="aa2e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">外部环境指的是<code class="fe lu lv lw lx b">lexical environment</code>。它是你写的代码中的物理位置。从前面的例子来看，</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="c9f2" class="nn lz iq lx b gy no np l nq nr">function b(){<br/>   let myVar;<br/>   console.log(myVar);<br/>}</span><span id="d3fd" class="nn lz iq lx b gy ns np l nq nr">function a(){<br/>   myVar = 2;<br/>   console.log(myVar);<br/>   b();   <br/>}</span><span id="bae6" class="nn lz iq lx b gy ns np l nq nr">let myVar = 30;<br/>console.log(myVar);</span><span id="5a96" class="nn lz iq lx b gy ns np l nq nr">a();<br/>console.log(myVar);</span></pre><p id="6823" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">function a(), b(), and let myVar</code>都位于全球环境的顶端。JavaScript关心每个<code class="fe lu lv lw lx b">execution context</code>获得的外部引用的<code class="fe lu lv lw lx b">lexical environment</code>。</p><p id="c2b9" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当引用一个变量时，如果在当前的<code class="fe lu lv lw lx b">execution context</code>中找不到变量，JavaScript将会查看外部引用。<code class="fe lu lv lw lx b">Scope Chain</code>是下到<code class="fe lu lv lw lx b">execution stack</code>直到到达<code class="fe lu lv lw lx b">global execution context</code>寻找变量的过程。</p><p id="dba6" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了解决前面的问题，当我们在<code class="fe lu lv lw lx b">a()</code>内部引用<code class="fe lu lv lw lx b">myVar</code>变量，而JavaScript无法在该上下文中找到它时，它会通过外部引用来找到它。在这种情况下，<code class="fe lu lv lw lx b">a()</code>的外部引用是全局上下文。它找到定义的<code class="fe lu lv lw lx b">myVar</code>并重新赋值。</p><p id="bc65" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们再看一个关于<code class="fe lu lv lw lx b">scope chain</code>的例子。</p><pre class="kg kh ki kj gt nj lx nk nl aw nm bi"><span id="7828" class="nn lz iq lx b gy no np l nq nr">function a(){<br/>    console.log('inside')<br/>    function inner(){<br/>       myVar = 'hello'<br/>    }<br/>    inner()<br/>}</span><span id="fbf4" class="nn lz iq lx b gy ns np l nq nr">let myVar = 'goodbye'<br/>a()</span></pre><p id="f1ed" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个例子中，我们有一个函数<code class="fe lu lv lw lx b">a()</code>，它包含另一个函数<code class="fe lu lv lw lx b">inner()</code>。当<code class="fe lu lv lw lx b">inner()</code>在某个点被调用时，它将重新分配<code class="fe lu lv lw lx b">myVar</code>的值。然而，JavaScript并不是简单地引用<code class="fe lu lv lw lx b">global execution context</code>来找到<code class="fe lu lv lw lx b">myVar</code>变量。它经历了参照外部环境的过程。</p><p id="9487" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这种情况下，<code class="fe lu lv lw lx b">inner()</code>的外部参考是<code class="fe lu lv lw lx b">a()</code>。然而，<code class="fe lu lv lw lx b">a() execution context</code>不包含对<code class="fe lu lv lw lx b">myVar</code>变量的引用。JavaScript继续到<code class="fe lu lv lw lx b">a()</code>的外部引用，也就是<code class="fe lu lv lw lx b">global execution context</code>。当确定外部引用时，是在<code class="fe lu lv lw lx b">execution context</code>中创建函数，即谁创建了函数？</p><h1 id="870d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="591f" class="pw-post-body-paragraph ky kz iq la b lb mq jr ld le mr ju lg lh ms lj lk ll mt ln lo lp mu lr ls lt ij bi translated">我们已经讨论了JavaScript代码是如何在内部运行的。很好地理解或接触提到的概念有助于在更深层次上理解其他JavaScript概念，如提升、闭包和作用域。</p><p id="ceba" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>