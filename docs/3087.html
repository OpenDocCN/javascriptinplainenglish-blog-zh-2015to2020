<html>
<head>
<title>Write React functional components and hooks in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中编写React函数组件和钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/write-react-functional-components-and-hooks-with-typescript-cd1539e2bc2a?source=collection_archive---------5-----------------------#2020-08-27">https://javascript.plainenglish.io/write-react-functional-components-and-hooks-with-typescript-cd1539e2bc2a?source=collection_archive---------5-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fb28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript是一种静态类型语言，它符合JavaScript。静态类型的代码更容易维护，也更难破解。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/219d518f0bf84f1a50608c172a16231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfCTE6kZArxc0Nr_MybXPQ.png"/></div></div></figure><p id="b1fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文假设您已经对React和TypeScript有所了解。如果你不是，那么不要担心，我会保护你。在阅读本文之前，请浏览下面的参考资料并尝试一些例子:</p><ul class=""><li id="1feb" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><a class="ae lg" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank"> React教程</a></li><li id="ab67" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><a class="ae lg" href="https://medium.com/front-end-weekly/learn-typescript-in-15-minutes-bf921cf355f5" rel="noopener">15分钟学会打字稿</a></li></ul><p id="6234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会浪费你的时间，现在就直接进入正题。</p><h1 id="768a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">设置项目👨‍💻️</h1><p id="cc74" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在本文中，我们不讨论如何从零开始用TypeScript建立一个React项目。开始时保持事情简单总是好的。我已经为您准备了GitHub模板，无需任何设置即可开始使用。你可以决定分叉回购或只是使用模板开始一个新的项目。<a class="ae lg" href="https://github.com/theBstar/react-typescript-starter" rel="noopener ugc nofollow" target="_blank">这个回购已经配备了更漂亮，eslint，TypeScript和React设置。和CRA一起成长。在这里找到它。</a>如果你想<a class="ae lg" href="https://reactjs.org/docs/static-type-checking.html#typescript" rel="noopener ugc nofollow" target="_blank">做自己的React +打字稿设置</a>，请查看官方React文档。</p><h1 id="683f" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">TypeScript泛型刷新程序</h1><p id="7c69" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">泛型是构建可重用软件的工具。这给了我们不将片段与类型紧密耦合的灵活性。允许我们在维护类型安全的同时重用不同类型的代码。</p><p id="66d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TypeScript中，泛型就像是可以动态插入的类型的占位符。举个例子就能把事情说清楚。</p><p id="5a70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在实现一个名为SimpleStack的小函数，用于保存一些项目的列表。如果我们在没有泛型的情况下实现它，我们的SimpleArray声明将只能保存一种类型的值。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="f5fd" class="mu ln iq mq b gy mv mw l mx my">type SimpleStackType = {<br/>  data: Array&lt;string&gt;;<br/>  push: (item: string) =&gt; number;<br/>  pop: () =&gt; string;<br/>};</span></pre><p id="0f28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的声明只允许我们创建一个字符串堆栈。如果我们想用上面的方法生成一个数字堆栈，我们需要声明一个新的类型，用数字类型替换字符串类型。现在让我们看看通用示例。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="3178" class="mu ln iq mq b gy mv mw l mx my">type SimpleStackType&lt;T&gt; = {<br/>  data: Array&lt;T&gt;;<br/>  push: (item: T) =&gt; number;<br/>  pop: () =&gt; T;<br/>};</span></pre><p id="e35e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面代码中的t是一个类型的占位符。我们可以将任何东西传递给T，SimpleStackType将作为T的类型工作。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5b8f" class="mu ln iq mq b gy mv mw l mx my">let stringStack: SimpleStackType&lt;string&gt;; // this like the first example with strict type of string<br/>// but we are not limitted.</span><span id="720d" class="mu ln iq mq b gy mz mw l mx my">let numberStack: SimpleStackType&lt;number&gt;;</span><span id="4f6f" class="mu ln iq mq b gy mz mw l mx my">type Person = {<br/>  name: string;<br/>  age: number;<br/>};</span><span id="d599" class="mu ln iq mq b gy mz mw l mx my">let personStack: SimpleStackType&lt;Person&gt;;</span></pre><p id="3cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，如果你不熟悉泛型，你可能已经问过了，我们不能使用类型<strong class="jp ir">和</strong>吗？与<strong class="jp ir">任何</strong>有何不同，有何优势？</p><p id="9621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我再举个例子来回答一下。所以任何类型的堆栈</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="86a2" class="mu ln iq mq b gy mv mw l mx my">type AnyStack = {<br/>  data: Array&lt;any&gt;;<br/>  push: (item: any) =&gt; number;<br/>  pop: () =&gt; any:<br/>};</span></pre><p id="1a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现AnyStack允许我们在堆栈中存储任何东西，但是它不提供类型安全。此外，我们不确定数据项上有哪些可用的方法或属性。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5528" class="mu ln iq mq b gy mv mw l mx my">let anyStack: AnyStack;<br/>// initialized anyStack here</span><span id="50cb" class="mu ln iq mq b gy mz mw l mx my">anyStack.data.map(item =&gt; { <br/>  console.log('Item is of type any'); <br/>  console.log('We are not certain about the type, that means we can access any properties or methods on the item. But if we don' want to break it, we should check the everything before calling it on item.');</span><span id="442d" class="mu ln iq mq b gy mz mw l mx my">// We are accessing toLowerCase method on item. We can do it, typescript won't complain because item is of type any.<br/>  // But item can be of anything, what if item is of type nunowmber?</span><span id="d625" class="mu ln iq mq b gy mz mw l mx my">});</span></pre><p id="49c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您可能确信any并不是您真正喜欢的类型，因为它不提供类型安全！这就是泛型出现的原因。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="4021" class="mu ln iq mq b gy mv mw l mx my">let stringStack: SimpleStackType&lt;string&gt;;<br/>// initialized here</span><span id="ebf7" class="mu ln iq mq b gy mz mw l mx my">stringStack.map(item =&gt; {<br/>  console.log('Item is of type string here);<br/>  console.log('You can even access .toLowerCase here! Should not be a surprise. You already knew it, right?');<br/>});</span></pre><p id="8257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你一定已经注意到，我们使用的<strong class="jp ir">数组&lt;someType&gt;T1】语法也是泛型的一种实现，你可以看到泛型的强大、安全和灵活性。是时候做出反应了。</strong></p><h1 id="61c8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">React应用程序的构建模块，组件</h1><p id="5da9" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">组件是任何React应用程序的构建块。由于本文是关于在TypeScript中反应函数组件的，我们将只讨论函数组件和一些其他类型声明。</p><h2 id="bcd1" class="mu ln iq bd lo na nb dn ls nc nd dp lw jy ne nf ma kc ng nh me kg ni nj mi nk bi translated">功能组件</h2><p id="ac12" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">一个反应函数组件就像一个返回有效JSX的普通函数。下面的类型推理函数是一个非常有效的React组件。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="ff1f" class="mu ln iq mq b gy mv mw l mx my">function SomeComponent() {<br/>  return (<br/>    &lt;div&gt; Hello from a react component!&lt;/div&gt;<br/>  );<br/>}</span></pre><p id="8aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想更明确，那么React提供了FC(或者使用FunctionComponent，二者相同)类型，这是一个泛型。你可以传递一个类型，这个类型是函数将要接受的道具的类型。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5f00" class="mu ln iq mq b gy mv mw l mx my">type Props = {<br/>  name: string;<br/>};</span><span id="c100" class="mu ln iq mq b gy mz mw l mx my">const AnotherComponent: FC&lt;Props&gt; = ({name}) =&gt; &lt;div&gt;Hi {name}&lt;/div&gt;;</span></pre><p id="7497" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过在道具上定义其他字段来在道具上定义它们。您可以通过在它们前面使用问号来使它们可选。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="1dd1" class="mu ln iq mq b gy mv mw l mx my">type Props = {<br/>  name: string;<br/>  optionalProp?: number;<br/>};</span><span id="0051" class="mu ln iq mq b gy mz mw l mx my">const OneMoreComponent: FC&lt;Props&gt; = ({name}) =&gt; &lt;div&gt;Hi {name}&lt;/div&gt;;</span></pre><h2 id="1f17" class="mu ln iq bd lo na nb dn ls nc nd dp lw jy ne nf ma kc ng nh me kg ni nj mi nk bi translated">其他类型声明</h2><p id="1430" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在我们已经熟悉了基本的功能组件，但是有时我们可能需要与类组件交互，React中还有一些其他重要的类型值得了解。</p><p id="ed9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nl">做出反应。ReactNode </em> </strong>可以用作返回JSX的函数的返回类型。用于反应迟钝的儿童。您可以定义一个返回ReactNode的函数来输入您的渲染属性。有一个例子可以说明这一点:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="a78a" class="mu ln iq mq b gy mv mw l mx my">type Props = {<br/>  nameRenderer: (name: string) =&gt; React.ReactNode;<br/>};</span></pre><p id="dafa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nl">做出反应。Component &lt; PropType，StateType &gt; </em> </strong>语法用于声明类组件。</p><p id="695e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nl">做出反应。如果你只关心组件和它接受的属性，而不关心它是一个函数组件还是一个类组件，那么可以使用ComponentType </em> </strong> <em class="nl">。下面是它的声明:</em></p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="6fcb" class="mu ln iq mq b gy mv mw l mx my">// This is a type from react, use FC for functional component and Component for class components.</span><span id="2533" class="mu ln iq mq b gy mz mw l mx my">type React.ComponentType&lt;P = {}&gt; = React.ComponentClass&lt;P, any&gt; | React.FunctionComponent&lt;P&gt;</span></pre><h1 id="5fa6" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">React挂钩:打字版本</h1><p id="2ab2" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">既然说的是函数组件，不说说钩子肯定是不完整的。但这绝对不是React hooks的介绍。</p><h2 id="4b62" class="mu ln iq bd lo na nb dn ls nc nd dp lw jy ne nf ma kc ng nh me kg ni nj mi nk bi translated">使用状态</h2><p id="dc1f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">可以将类型传递给使用状态，就像将类型传递给泛型一样。如果您的状态类型在应用程序的整个过程中没有改变，那么您可以简单地将初始状态传递给useState，TypeScript将推断出类型。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="3699" class="mu ln iq mq b gy mv mw l mx my">const [counter, setCounter] = useState(0);</span></pre><p id="f8ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，计数器的类型总是数字。如果你需要更复杂的类型，比如用户:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="a201" class="mu ln iq mq b gy mv mw l mx my">const [user, setUser] = useState({name: 'Binod', age: 1, ageUnit: 'month' });</span></pre><p id="c90a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，TypeScript也会推断类型。但是，如果您的用户数据是动态设置的，比如在登录事件之后，用户最初为空，您将如何处理它？</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5da0" class="mu ln iq mq b gy mv mw l mx my">const [user, setUser] = useState(null);</span></pre><p id="b5d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不完全是这样，因为TypeScript会将用户的类型推断为null，并且当您试图将其设置为另一种类型的值时会报错。显然，你可以使用任何类型，但你想要类型安全，不是吗？</p><p id="b256" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想得有点难，或者你已经想通了，我们可以在这里使用一个联合类型。是的，我们现在将使用通用语法。</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="e3a9" class="mu ln iq mq b gy mv mw l mx my">type User = {<br/>  name: string,<br/>  age: number,<br/>  ageUnit: string, // or better 'month' | 'year' | 'day' | 'week' <br/>};</span><span id="fbfd" class="mu ln iq mq b gy mz mw l mx my">const [user, setUser] = useState&lt;User | null&gt;(null);</span></pre><p id="7a9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从技术上来说，我们可以用<strong class="jp ir"> <em class="nl">非空断言</em> </strong> <strong class="jp ir"> <em class="nl">操作符</em> </strong>实现类似的东西，但不能完全满足用例。</p><p id="fd96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们还需要知道useState返回的setUser的类型，如果我们正在传递它的话。传递setValue有点酷，因为React保证了引用。他们的类型是:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="4d0f" class="mu ln iq mq b gy mv mw l mx my">React.Dispatch&lt;React.SetStateAction&lt;StateType&gt;</span></pre><p id="0be3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nl"> useMemo、useCallback、useDispatch和useContext、useRef、</em> </strong>在处理类型方面都差不多。它们都接受与它们接受的参数数量相对应的类型。所以说实话，我们不会讨论它们。useCallback只是返回您传递给它的函数，类型保持不变。如果编译器不知怎么搞混了，你可以使用泛型语法。我见过一些使用useMemo的案例，但是还没有使用useCallback。</p><h1 id="e6b3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">自定义挂钩</h1><p id="fcac" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们将计数器逻辑写成一个自定义挂钩:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="c7fe" class="mu ln iq mq b gy mv mw l mx my">function useCounter(initialValue: number) {<br/>  const [counter, setCounter] = useState(initialValue);<br/>  const increment = useCallback(() =&gt; setCounter(c =&gt; c + 1), []);<br/>  const decrement = useCallback(() =&gt; setCounter(c =&gt; c - 1), []);<br/>  return [counter, increment, decrement];<br/>}</span></pre><p id="59b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是TypeScript并不能很好的播放上面的代码。挂钩的推断返回类型将是数组元素类型的并集。所以，当你试图调用增量或减量函数时，TypeScript会报错。因为TypeScript将其视为:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="d1bb" class="mu ln iq mq b gy mv mw l mx my">type Increment: number | () =&gt; void | () =&gt; void;</span></pre><p id="57b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且联合中的一个类型是不可调用的。你需要明确定义钩子的返回类型。让我们为一个简单的元组类型做这件事:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5169" class="mu ln iq mq b gy mv mw l mx my">Type Counter = [number, () =&gt; void, () =&gt; void];</span></pre><p id="c617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用计数器类型作为自定义钩子的返回类型，我们就完成了。如果你的钩子返回多个值，比如超过3个，那么你应该返回一个对象。它帮助你在更长的时间内维护代码。</p><p id="5f25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该足够让你开始了。您可以根据需要查找更多信息。</p><p id="a294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，并且对前端开发、TypeScript、JavaScript和React感兴趣，你可以考虑关注我。我通常一周发表一篇文章。</p><p id="3e11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有任何问题或反馈吗？求你了。我会欣喜若狂地回应。😊</p><p id="0769" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">留给你打字稿反应操场👋—<a class="ae lg" href="https://www.typescriptlang.org/play?jsx=2&amp;esModuleInterop=true&amp;q=423#example/typescript-with-react" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/play?jsx=2&amp;esModuleInterop = true&amp;q = 423 # example/typescript-with-react</a></p></div></div>    
</body>
</html>