<html>
<head>
<title>Highly Reusable React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高度可重复使用的反应组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-highly-reusable-react-components-learn-by-creating-an-accordion-list-b32d150eb649?source=collection_archive---------0-----------------------#2020-07-17">https://javascript.plainenglish.io/creating-highly-reusable-react-components-learn-by-creating-an-accordion-list-b32d150eb649?source=collection_archive---------0-----------------------#2020-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3eef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们用React构建一个accordion复合组件。儿童API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/af80f9b47a6c79e99fda58c672e326eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c7UgX_V634696vQc"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@picsbyjameslee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Lee</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d04a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将重点关注创建高度可重用的React组件。我的目标是让它成为任何想要了解React更多信息以及它的一些特性是如何工作的人的一个坚实的切入点。</p><p id="5cb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将从头开始创建一个定制的accordion复合组件。如果你不确定我说的<em class="ls">手风琴是什么意思，</em>想象一下一个项目列表，当点击时，它会展开显示额外的内容。</p><p id="0dcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我强烈建议先阅读整篇文章，但是在文章的最后还有一个视频版本，以及一些代码片段。</p><p id="f58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，如果你喜欢这篇文章，可以看看我在<a class="ae kv" href="https://dzuz14.medium.com/simple-file-uploading-with-react-hooks-fe89c225db57" rel="noopener">上传文件的文章，点击这里</a>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e9df" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">第一印象</h1><p id="454d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">乍一看，构建一个accordion组件似乎是一项微不足道的任务。只要添加一些状态来跟踪哪个项目是打开的，添加一个点击处理程序，传递一些道具，我们就完成了，对吗？当然，我们也许可以一起为一个非常特定的用例工作，但这不是我们这里的目标。</p><p id="7366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们应该让我们的组件适应各种各样的用例。它应该只需要很少的设置工作，并且不需要额外的代码就可以工作。用户应该能够“设置它，然后忘记它。”</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1397" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">规划我们的手风琴组件</h1><p id="d6d7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们将把手风琴设计成复合组件。如果你曾经使用过像<a class="ae kv" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> React Bootstrap </a>这样的库，那么复合组件语法应该对你来说非常熟悉。</p><p id="45f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我的设想:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4a56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的accordion将支持显示多个项目组件。它可以手动添加，也可以通过迭代数据结构(如数组)以编程方式生成。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="05fb" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">入门指南</h1><p id="672f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在我们已经定义了我们的组件层次结构，让我们从根<code class="fe mz na nb nc b">Accordion</code>组件开始。现在，我们需要做的就是创建一个基本的React组件，接受孩子作为道具。有了这些，我们可以直接进入创建下一个组件，<code class="fe mz na nb nc b">Item</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="30b2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">手风琴。'项目'</h1><p id="8e68" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在React中，当您在一个父元素中呈现多个元素时，您需要确保两个元素都驻留在一个公共的包装器元素中。例如，此语句将在React中产生一个错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2c20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们很可能会遇到一个错误，声称“相邻的JSX表达式必须包含一个父表达式。”为了解决这个问题，我们可以执行以下任一操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c1c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我看来，强迫用户添加一些他们自己的语法以使我们的组件工作(尽管只是很小的添加)似乎不太专业。因此，我建议我们创建一个简单的包装组件，让他们开箱即用。</p><p id="5b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们的<code class="fe mz na nb nc b">Item</code>组件非常简单，我们甚至不需要为它创建一个新文件。相反，我们可以在与<code class="fe mz na nb nc b">Accordion</code>相同的文件中声明它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="aa08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有需要做的就是将<code class="fe mz na nb nc b">Item</code>指定为一个箭头函数，接受孩子作为道具，我们现在有了一个容易识别的包装组件，可以通过点符号在<code class="fe mz na nb nc b">Accordion</code>中使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8a61" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">手风琴。'折叠'</h1><p id="91b7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们的下一个任务是显示一个<code class="fe mz na nb nc b">Item</code>的折叠内容。理想情况下，这将在它自己的文件中创建，并导入到根<code class="fe mz na nb nc b">Accordion</code>组件中。所需要的就是显示它的子元素，并应用一些非常基本的样式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a66e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">手风琴。'扩展'</h1><p id="d0a6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><code class="fe mz na nb nc b">Expanded</code>组件也很简单，只涉及显示子元素。除此之外，还需要一些基本的造型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准备就绪后，让我们更新我们的<code class="fe mz na nb nc b">Accordion</code>组件，以包含新的<code class="fe mz na nb nc b">Collapsed</code>和<code class="fe mz na nb nc b">Expanded</code>组件。鉴于JavaScript中的一切都是对象(甚至React组件)，使用点符号就像我们在<code class="fe mz na nb nc b">Item</code>中做的一样简单，将这些组件作为<code class="fe mz na nb nc b">Accordion</code>的一部分包含进来！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="58d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，如果我们真的想将它导入到一个文件中并使用它，我们至少能够看到放置在<code class="fe mz na nb nc b">Collapsed</code>和<code class="fe mz na nb nc b">Expanded</code>组件中的任何内容。但是我不建议你在本教程结束之前尝试运行这个<code class="fe mz na nb nc b">Accordion</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="93ac" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">显示几个折叠项</h1><p id="038e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">一个只显示一个项目的手风琴显然是非常无聊的。</p><p id="4b86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程的剩余部分，我们将使用下面的模拟数据来呈现几个项目。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了显示数据，我们只需创建一个<code class="fe mz na nb nc b">Accordion</code>，映射整个数组，并为每个数组元素生成一个<code class="fe mz na nb nc b">Item</code>、<code class="fe mz na nb nc b">Collapsed</code>和<code class="fe mz na nb nc b">Expanded</code>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="11d7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">跟踪展开的项目</h1><p id="c60a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">出于功能性的考虑，当点击<code class="fe mz na nb nc b">Collapsed</code>组件时，我们需要考虑两种情况:</p><ul class=""><li id="7dbb" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">如果单击的项目没有展开，则显示其展开的内容。此外，如果展开了另一个项目，请确保将其关闭。</li><li id="3408" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">如果单击的项目已经展开，请关闭它</li></ul><p id="fdd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了跟踪这一点，如果我们使用一个存储在状态变量中的字符串呢？当一个特定的项目被点击时，我们可以从中提取某种类型的惟一值，并使用它来确定它的展开状态。</p><h2 id="32d6" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated"><em class="od">但是这个独特的价值是什么，它将从哪里来？</em></h2><p id="a7a6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">一个简单的解决方案<strong class="ky ir"> </strong>就是给<code class="fe mz na nb nc b">Collapsed</code>增加一个名为<code class="fe mz na nb nc b">id</code>的新道具。我们希望<code class="fe mz na nb nc b">id</code>道具对于每个<code class="fe mz na nb nc b">Collapsed</code>组件都是唯一的，所以我们可以在模拟数据中使用每个对象的<code class="fe mz na nb nc b">summary</code> <em class="ls"> </em>键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0903" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回到我们的<code class="fe mz na nb nc b">Collapsed</code>组件代码，并确保我们更新它来接受这个新的道具。现在，我们可以将<code class="fe mz na nb nc b">id</code>作为一个数据属性附加上去，然后忘掉它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f189" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">处理点击</h1><p id="39ef" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了在点击<code class="fe mz na nb nc b">Collapsed</code>组件时执行状态更新，我们将创建一个函数来处理它。我们可以在根<code class="fe mz na nb nc b">Accordion</code>组件中定义这个函数，并将其作为道具传递给<code class="fe mz na nb nc b">Collapsed</code>。</p><p id="958f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在要在我们的<code class="fe mz na nb nc b">Accordion</code>代码中实现上一节的状态和这个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">状态变量<code class="fe mz na nb nc b">open</code>最初将被设置为空字符串(这意味着不会展开任何项目)。在随后的点击中，它会根据函数中的逻辑进行更新。</p><p id="6b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在结束本节之前，我们需要再次访问<code class="fe mz na nb nc b">Collapsed</code>组件，并更新它以接受<code class="fe mz na nb nc b">handleOpen</code>作为道具。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="34db" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">拦截拉手风琴的孩子</h1><p id="8310" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我知道你们都是精明的读者，我将假设你们已经注意到了根<code class="fe mz na nb nc b">Accordion</code>组件中我们的代码有问题。忽略到目前为止我们添加到该组件的所有附加代码，让我们看下面一行:</p><pre class="kg kh ki kj gt oe nc of og aw oh bi"><span id="4234" class="nr mb iq nc b gy oi oj l ok ol">return &lt;div&gt;{children}&lt;/div&gt;</span></pre><p id="0096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们没有在代码中显式地将道具传递给<code class="fe mz na nb nc b">Collapsed</code>,我们该如何传递呢？既然我们将<code class="fe mz na nb nc b">Item</code>、<code class="fe mz na nb nc b">Collapsed</code>和<code class="fe mz na nb nc b">Expanded</code>的实现留给了组件的用户，那么我们刚刚创建的状态和点击处理程序不是完全无用吗？</p><p id="d582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果React没有为我们提供一种在孩子被渲染之前与他们互动的方式，那么答案将是“是”。然而，对我们来说幸运的是，React为我们提供了一种简单的方法来做到这一点。我们将特别关注的React API的两个特性是:</p><ul class=""><li id="7f8c" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><code class="fe mz na nb nc b"><a class="ae kv" href="https://reactjs.org/docs/react-api.html#reactchildren" rel="noopener ugc nofollow" target="_blank">React.Children</a></code></li><li id="54cf" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><code class="fe mz na nb nc b"><a class="ae kv" href="https://reactjs.org/docs/react-api.html#cloneelement" rel="noopener ugc nofollow" target="_blank">React.cloneElement</a></code></li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="176b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">做出反应。'儿童地图'</h1><p id="ae50" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了拦截子节点传递给我们的<code class="fe mz na nb nc b">Accordion</code>组件，我们可以利用<em class="ls"/><em class="ls"><em class="ls"/>提供的功能。这个函数将允许我们在渲染每个子组件之前对其进行迭代，并定制最终将显示在屏幕上的内容。</em></p><p id="79f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mz na nb nc b">map</code>流程中，我们的两个优先事项是:</p><ul class=""><li id="1a83" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">拦截每一个<code class="fe mz na nb nc b">Collapsed</code>组件，并作为道具传递给它一个函数。这将是我们之前创建的<code class="fe mz na nb nc b">handleOpen</code>函数。</li><li id="b1c6" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">基于状态中<code class="fe mz na nb nc b">open</code>变量的当前值，有条件地渲染每个<code class="fe mz na nb nc b">Expanded</code>组件</li></ul><p id="a02a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解<code class="fe mz na nb nc b">map</code>函数，让我们看看可以传递给它的两个参数:</p><ul class=""><li id="fbbe" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">要迭代的子对象</li><li id="e8f0" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">对每个孩子执行的函数</li></ul><p id="e43f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，用一些代码开始研究这个问题可能更容易。在这个代码片段中，我已经排除了我们的<code class="fe mz na nb nc b">Accordion</code>组件中的大部分代码，只关注<em class="ls"> </em> <code class="fe mz na nb nc b">React.Children</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f20b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，第一个参数<code class="fe mz na nb nc b">children</code>永远不会改变。它在那里充当我们想要迭代的子数组。第二个参数需要是一个由我们创建的函数，它将使我们能够访问每个单独的孩子，并且将是所有神奇事情发生的地方。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1532" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">React是递归的</h1><p id="7d70" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果这种方式有助于您将其形象化，您可以将React组件视为具有递归行为。组件可以有子组件，它们的子组件可以有子组件，这些子组件可以一直有子组件，直到我们到达一个基础案例<strong class="ky ir"> </strong>(没有更多的元素留下来渲染)。</p><h2 id="5b85" class="nr mb iq bd mc ns nt dn mg nu nv dp mk lf nw nx mm lj ny nz mo ln oa ob mq oc bi translated"><strong class="ak">让我们来看看引擎盖下的孩子们发生了什么</strong></h2><p id="66ac" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果我们在第二个参数的函数中添加一个<code class="fe mz na nb nc b">console.log</code>,我们应该期望控制台中显示一个包含四个元素的数组。</p><p id="dcc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在查看控制台输出之前，您能猜出数组中的每个元素是什么吗？</p><pre class="kg kh ki kj gt oe nc of og aw oh bi"><span id="98aa" class="nr mb iq nc b gy oi oj l ok ol">{React.Children.map(children, child =&gt; {<br/>  console.log(children)<br/>  return &lt;div&gt;&lt;/div&gt;<br/>})}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/eb42985a36b0b290710ef4a9aca78ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6SYqSRQlue_5-S6dglUVw.jpeg"/></div></div></figure><p id="f813" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您猜到每个元素将是一个<code class="fe mz na nb nc b">Item</code>组件，那么您猜对了！如果这还不清楚，让我们再看看我们的组件层次结构——它应该开始变得有意义了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8ba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不再假设<code class="fe mz na nb nc b">React.Children.map</code>在直接子级运行，并且只有一个<code class="fe mz na nb nc b">Item</code>组件可以是<code class="fe mz na nb nc b">Accordion</code>的直接子级，那么它返回给我们四个<code class="fe mz na nb nc b">Item</code>组件是有意义的。</p><p id="f560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，正如我们之前了解到的，每个孩子也可以有自己的孩子。因此，我们需要深入到层次结构中去寻找我们想要的组件。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c05e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">查找“折叠”和“展开”</h1><p id="1162" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">既然我们已经确定我们正在处理一组<code class="fe mz na nb nc b">Item</code>组件，我们如何找到<code class="fe mz na nb nc b">Collapsed</code>和<code class="fe mz na nb nc b">Expanded</code>？如果我们检查我们阵列中的一个<code class="fe mz na nb nc b">Item</code>组件，看看它的道具会怎么样？</p><p id="52cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不记录<code class="fe mz na nb nc b">children</code>，让我们记录<code class="fe mz na nb nc b">child</code> <em class="ls"> </em>来代替。</p><pre class="kg kh ki kj gt oe nc of og aw oh bi"><span id="4349" class="nr mb iq nc b gy oi oj l ok ol">{React.Children.map(children, child =&gt; {<br/>  console.log(child)<br/>  return &lt;div&gt;&lt;/div&gt;<br/>})}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/6725f65de190af6c708a599fc5e81b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9--I_FN3YeoA7iGsTJ51Q.jpeg"/></div></div></figure><p id="c1c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据控制台输出，我们的孩子正好有<strong class="ky ir"> <em class="ls">两个孩子</em> </strong> <em class="ls">。如果我是一个爱赌博的人，我会忍不住拿房子打赌，那两个孩子是我们长期寻找的<code class="fe mz na nb nc b">Collapsed</code>和<code class="fe mz na nb nc b">Expanded</code>组件！有了这些信息，我们可以添加完成我们的<code class="fe mz na nb nc b">Accordion</code>所需的其余逻辑。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="83fc" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">收起手风琴</h1><p id="7035" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在我展示完整代码的片段之前，让我们深入了解一下需要添加到我们的<code class="fe mz na nb nc b">map</code>语句中的内容。我们只需要几行代码，就完成了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9563" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使代码更整洁、更易于维护，我决定创建一些描述性变量，而不是在没有明确说明代码在做什么的情况下将所有内容都放入return语句中。</p><p id="f908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe mz na nb nc b">id</code>和<code class="fe mz na nb nc b">Expanded</code>变量，我们从<code class="fe mz na nb nc b">Collapsed</code>组件(<code class="fe mz na nb nc b">child.props.children[0]</code>)中提取ID，并使用它来有条件地呈现<code class="fe mz na nb nc b">Expanded</code>组件(<code class="fe mz na nb nc b">child.props.children[1]</code>)。这确保了一个<code class="fe mz na nb nc b">Expanded</code>组件只有在ID和打开状态变量匹配时才会被呈现。</p><p id="94f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于<code class="fe mz na nb nc b">Collapsed</code>变量，我们通过传入当前的<code class="fe mz na nb nc b">Collapsed</code>组件(<code class="fe mz na nb nc b">child.props.children[0]</code>)来使用<code class="fe mz na nb nc b">React.cloneElement</code>作为第一个参数，并传入我们想要添加到它的任何道具作为第二个参数。使用<code class="fe mz na nb nc b">cloneElement</code>将导致我们的<code class="fe mz na nb nc b">Collapsed</code>变量成为<code class="fe mz na nb nc b">Collapsed</code>的新副本，而<code class="fe mz na nb nc b">handleOpen</code>函数合并到它的道具<em class="ls">中。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="aca1" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">这就是了，女士们先生们</h1><p id="c2c7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这是最辉煌的最终代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f4ac" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">摘要</h1><p id="8b20" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">非常感谢您阅读这篇文章。你可以通过查看我的<a class="ae kv" href="https://github.com/dzuz14" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或者如我所承诺的，查看本教程的视频来更深入地了解。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo my l"/></div></figure></div></div>    
</body>
</html>