<html>
<head>
<title>What’s New in TypeScript 4.0?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.0有什么新功能？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-new-in-typescript-4-0-7676fd61f456?source=collection_archive---------14-----------------------#2020-09-15">https://javascript.plainenglish.io/whats-new-in-typescript-4-0-7676fd61f456?source=collection_archive---------14-----------------------#2020-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db5e8d07622a1a1f1f7acba5451e7f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZkNDywYmmL70mvFK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@amadorloureiroblanco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Amador Loureiro</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="745f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript 4.0提供了许多新特性，使得JavaScript开发更加容易。</p><p id="d07e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究TypeScript 4的最佳特性。</p><h1 id="0a0c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可变元组</h1><p id="c210" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript 4.0附带了元素数量可变的元组的数据类型。</p><p id="8539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用spread操作符创建一个类型，其中包含我们希望在元组中包含的元素。</p><p id="c8a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d828" class="mn lc iq mj b gy mo mp l mq mr">type Strings = [string, string];<br/>type Numbers = number[];</span><span id="4e4c" class="mn lc iq mj b gy ms mp l mq mr">type Unbounded = [...Strings, ...Numbers, boolean];</span></pre><p id="c42c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个<code class="fe mt mu mv mj b">Unbounded</code>数据类型来添加一个包含字符串、数字和布尔值的元组类型。</p><p id="b75b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推断过程也是自动的，因此如果我们有两个相同顺序的字符串、数字和一个布尔值，TypeScript将推断元组具有<code class="fe mt mu mv mj b">Unbounded</code>类型。</p><h1 id="ed8d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">标记元组元素</h1><p id="cdbc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以标记元组元素。</p><p id="64be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bcbc" class="mn lc iq mj b gy mo mp l mq mr">type Range = [start: number, end: number];</span></pre><p id="d9d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">限制<code class="fe mt mu mv mj b">args</code>有一个字符串和一个数字。</p><p id="30b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0b53" class="mn lc iq mj b gy mo mp l mq mr">type Foo = [first: number, second?: string, ...rest: any[]];</span></pre><p id="68a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的元组中有rest条目。</p><p id="fe1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的元组有类型<code class="fe mt mu mv mj b">Foo</code>，那么元组以一个数字和一个字符串开始。</p><p id="76ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么其余的条目可以是任何东西。</p><p id="dd11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标签不要求我们在析构时用不同的名字命名变量。</p><p id="ebb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a178" class="mn lc iq mj b gy mo mp l mq mr">function foo(x: [first: string, second: number]) {<br/>  const [a, b] = x;<br/>}</span></pre><p id="f83e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以给析构变量起任何我们想要的名字。</p><h1 id="3c6f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从构造函数推断类属性</h1><p id="76a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript 4.0可以从构造函数推断类属性的类型。</p><p id="8371" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="64ca" class="mn lc iq mj b gy mo mp l mq mr">class Square {<br/>  area;<br/>  length;<br/><br/>  constructor(length: number) {<br/>    this.length = length;<br/>    this.area = length ** 2;<br/>  }<br/>}</span></pre><p id="dad8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后TypeScript 4.0自动知道<code class="fe mt mu mv mj b">this.length</code>和<code class="fe mt mu mv mj b">this.area</code>是数字。</p><p id="d699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们的值有可能是<code class="fe mt mu mv mj b">undefined</code>，那么TypeScript编译器会通知我们。</p><p id="c108" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0730" class="mn lc iq mj b gy mo mp l mq mr">class Square {<br/>  length;</span><span id="7e54" class="mn lc iq mj b gy ms mp l mq mr">  constructor(length: number) {<br/>    if (Math.random()) {<br/>      this.length = length;<br/>    }<br/>  }</span><span id="3fd4" class="mn lc iq mj b gy ms mp l mq mr">  get area() {<br/>    return this.length  ** 2;<br/>  }<br/>}</span></pre><p id="69b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那我们就知道<code class="fe mt mu mv mj b">this.length</code>可能是<code class="fe mt mu mv mj b">undefined</code>。</p><p id="dad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个类型断言，即使我们知道它总是被定义的。</p><p id="405f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8768" class="mn lc iq mj b gy mo mp l mq mr">class Square {<br/>  length!: number;</span><span id="2b38" class="mn lc iq mj b gy ms mp l mq mr">  constructor(length: number) {<br/>    this.initialize(length);<br/>  }</span><span id="e102" class="mn lc iq mj b gy ms mp l mq mr">  initialize(length: number) {<br/>    this.length = length;<br/>  }</span><span id="32e4" class="mn lc iq mj b gy ms mp l mq mr">  get area() {<br/>    return this.length ** 2;<br/>  }<br/>}</span></pre><p id="2300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用符号<code class="fe mt mu mv mj b">!</code>将<code class="fe mt mu mv mj b">length</code>设置为非空，并将其类型显式设置为<code class="fe mt mu mv mj b">number</code>，以确保<code class="fe mt mu mv mj b">this.length</code>始终是一个数字。</p><h1 id="1c17" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">短路赋值运算符</h1><p id="5fcd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript 4.0有新的赋值运算符shorthands。</p><p id="313f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们用简写写逻辑AND、逻辑OR和看涨合并运算符。</p><p id="4dd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ce55" class="mn lc iq mj b gy mo mp l mq mr">a = a &amp;&amp; b;<br/>a = a || b;<br/>a = a ?? b;</span></pre><p id="0d2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3973" class="mn lc iq mj b gy mo mp l mq mr">a &amp;&amp;= b;<br/>a ||= b;<br/>a ??= b;</span></pre><h1 id="30de" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">unknown</code>关于<code class="fe mt mu mv mj b">catch</code>条款绑定</h1><p id="3e9f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将<code class="fe mt mu mv mj b">catch</code>子句的绑定变量指定为<code class="fe mt mu mv mj b">unknown</code>类型，而不是<code class="fe mt mu mv mj b">any</code>类型。</p><p id="fb1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe mt mu mv mj b">unknown</code>类型，我们必须在使用它之前显式地转换异常对象。</p><p id="2d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c579" class="mn lc iq mj b gy mo mp l mq mr">try {<br/>  // ...<br/>} catch (e: unknown) {<br/>  if (typeof e === "string") {  <br/>    console.log(e.toUpperCase());<br/>  }<br/>}</span></pre><p id="e076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在对它调用<code class="fe mt mu mv mj b">toUpperCase</code>之前检查<code class="fe mt mu mv mj b">e</code>是否是一个字符串。</p><h1 id="4611" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a536" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript 4.0提供了许多新的语言特性，我们可以用它们来检查类型。</p><p id="90eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型推断也得到了改进。</p><h2 id="1994" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="6568" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>