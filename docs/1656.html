<html>
<head>
<title>JavasScript Promises and the Micro Task Queue.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavasScript Promises和微任务队列。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javasscript-promises-and-the-micro-task-queue-6111f7452f05?source=collection_archive---------4-----------------------#2020-04-11">https://javascript.plainenglish.io/javasscript-promises-and-the-micro-task-queue-6111f7452f05?source=collection_archive---------4-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c11b6e4d4ac7cf9d9ace252254004647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pWvsvbzZpfNO-ZZSylijg.png"/></div></div></figure><p id="875e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">异步代码定义</strong>:当你读取代码的顺序与代码执行的顺序不同时。</p><p id="ac32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在ES6的世界中，我在这里<a class="ae kw" href="https://medium.com/@camfeg/asynchronous-javascript-explained-a4c1133f5544" rel="noopener">解释的异步模型发生了什么变化</a>，我建议在阅读这篇文章之前阅读一下。</p><p id="e256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES6带来了<strong class="ka ir">承诺</strong>。</p><p id="0d9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">的前提承诺</strong>给出如下代码</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="31d8" class="lg lh iq lc b gy li lj l lk ll">function printHello(){ console.log("Hello") }<br/>function blockFor1Sec(){<br/>    // Blocks the JavasCript thread for 1 second<br/>    // Imagine a for loop that goes to a million<br/>    for(i=0; i &lt; 15000; i++){<br/>        console.log("i is: ", i)<br/>    }<br/>}<br/>​<br/>setTimeout(printHello, 0);<br/>blockFor1Sec();<br/>console.log("Me First")</span></pre><p id="5706" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是:</p><p id="682f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器中，仅调用<code class="fe lm ln lo lc b">setTimeout</code> <strong class="ka ir">会产生后果。因为它是一个<strong class="ka ir">外观</strong>功能。</strong></p><p id="e27d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，它的后果是在浏览器中，这意味着我们真的没有任何办法在JavaScript中跟踪它。</p><p id="b2d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们无法在内存中看到的数据状态和浏览器中发生的事情之间保持一致，没有办法将浏览器中发生的事情映射到JavaScript中发生的事情。</p><p id="d0c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开发可扩展的应用程序时，这并不理想。</p><p id="4590" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以<strong class="ka ir"> Promises </strong>最有价值的特性是希望/能够说，当你在后台(后台是浏览器)触发某个东西时，不要只是把它扔在那里，还要让它在JavaScript内存中产生某种后果。</p><p id="308f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在ES6中，我们引入了新的“双管齐下”的<strong class="ka ir">门面功能</strong> <code class="fe lm ln lo lc b">fetch</code>。“双管齐下”的意思是做两件事。</p><ul class=""><li id="def0" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">从浏览器触发网络请求。</li><li id="6107" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">在Javascript领域，它将返回一种特殊的对象，称为<strong class="ka ir"> Promise对象</strong>。</li></ul><p id="63ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当后台工作完成时，它将用来自网络请求的数据填充并更新那个<strong class="ka ir">承诺对象</strong>。</p><p id="551c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那个<strong class="ka ir"> Promise对象</strong>将允许我们在Javascript中，在我们的本地或全局内存中，跟踪我们在网络浏览器中触发的东西的状态。</p><p id="de00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个例子，并讨论一下发生了什么:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="bfc5" class="lg lh iq lc b gy li lj l lk ll">function display(data){<br/>    console.log(data)<br/>}<br/>const futureData = fetch('https://twitter.com/will/tweets/1')<br/>futureData.then(display);<br/>​<br/>console.log("Me first !");</span></pre><ul class=""><li id="061c" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">第1行:定义一个函数<code class="fe lm ln lo lc b">display</code></li><li id="2053" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">第4行:运行fetch，将<strong class="ka ir">承诺对象</strong>存储在<code class="fe lm ln lo lc b">const futureData</code>中</li></ul><p id="7923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">fetch立即返回一个<strong class="ka ir"> Promise对象</strong>，它有两个属性。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="c6ed" class="lg lh iq lc b gy li lj l lk ll">{ value: nil, onFulfilled: [] }</span></pre><p id="b97b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lc b">fetch</code>还在web浏览器中触发了一个<strong class="ka ir">网络请求</strong>，我们将在这里设置一个XHR，它代表XML，HTTP，request。XML是我们通过互联网发送数据的数据格式，HTTP是我们如何在浏览器和服务器之间发送消息的一套规则。</p><p id="d533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更深入地看看运行<code class="fe lm ln lo lc b">fetch</code>时会发生什么</p><p id="3fb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">网络请求是否已完成？布尔型。</p><ul class=""><li id="481b" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">0毫秒:完成？是<code class="fe lm ln lo lc b">false</code></li><li id="2bc5" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">0 ms:我们向twitter发送一个请求，我们知道这一点，因为我们传入了URL:“<a class="ae kw" href="https://twitter.com/will/tweets/1" rel="noopener ugc nofollow" target="_blank">https://twitter.com/example/tweets/1</a>”。它的域名是:<code class="fe lm ln lo lc b">twitter.com</code>，我们告诉它通过设置路由<code class="fe lm ln lo lc b">example/tweets/1</code>来获取“示例”的第一条tweet</li></ul><p id="7a90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与Twitter的API通信需要时间，所以我们不知道何时会有响应。</p><ul class=""><li id="c8f0" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">季克</li><li id="7130" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">肾结核</li><li id="dd98" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">季克</li><li id="2fbb" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">肾结核</li><li id="e15f" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">当Twitter发回响应对象时，完成？变成了<code class="fe lm ln lo lc b">true</code>，并用来自Twitter的响应对象更新了<strong class="ka ir">承诺对象</strong>的<code class="fe lm ln lo lc b">value</code>属性。</li><li id="79a9" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">270 ms:我们接收从Twitter返回的数据，并存储在futureData中，这将触发我们的<code class="fe lm ln lo lc b">display</code>函数。</li></ul><h2 id="f2c7" class="lg lh iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">我们向Twitter请求数据来使用它，因此我们必须告诉JavaScript如何处理这些数据。当数据从Twitter返回时，我们希望自动运行一些代码来使用这些数据，这随时都可能发生。</h2><h2 id="6aa9" class="lg lh iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">这就是承诺对象的<code class="fe lm ln lo lc b">onFulfilled</code> <strong class="ak"> </strong>属性发挥作用的地方。</h2><p id="62a3" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">属性负责在数据返回时保持运行的功能。当<code class="fe lm ln lo lc b">value</code>属性更新时，该数组中的任何函数都将被触发运行。不仅如此，Twitter的返回值将作为参数传入，以填充存储在<code class="fe lm ln lo lc b">onFulfilled</code>数组中的任何函数的参数。</p><p id="d345" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们需要做的是让我们的<code class="fe lm ln lo lc b">display</code>函数在那个数组中。但是我们不能使用像<code class="fe lm ln lo lc b">push</code>那样向数组添加元素的常用工具，因为<code class="fe lm ln lo lc b">onFulfilled</code>属性是<strong class="ka ir"> Promise对象</strong>上的<code class="fe lm ln lo lc b"><strong class="ka ir">hidden</strong></code>属性。</p><p id="46ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此我们使用<code class="fe lm ln lo lc b">.then</code>。</p><h2 id="3741" class="lg lh iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">当我们的Promise对象上的<code class="fe lm ln lo lc b">value</code>属性被来自我们的网络请求的响应数据填充时，我们传递给<code class="fe lm ln lo lc b">.then</code>的回调不仅仅是运行。</h2><h2 id="a6b4" class="lg lh iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">为了解释发生了什么，我们必须引入两个队列，回调队列和微任务队列，它们由JavaScript的事件循环管理，负责对代码执行的顺序进行排序。</h2><p id="b3c8" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">让我们用下面的代码来说明事件的顺序。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d93e" class="lg lh iq lc b gy li lj l lk ll">function display(data){ console.log(data) }<br/>function printHello(){ console.log ("Hello!") }<br/>function blockFor300ms(){ <br/>    for(i=0; i &lt; 25000 ; i++){<br/>        console.log("i is: ", i)<br/>    }<br/>}<br/>setTimeout(printHello, 0);<br/>​<br/>const futureData = fetch("https://twitter.com/example/tweets/1")<br/>futureData.then(display)<br/>​<br/>blockFor300ms()<br/>console.log("Me first !")</span></pre><ul class=""><li id="ede7" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">0 ms: <code class="fe lm ln lo lc b">setTimeout</code>被调用，它向浏览器传递一个回调函数，这里是<code class="fe lm ln lo lc b">printHello</code>，并触发一个定时器，定时器到期时，将把<code class="fe lm ln lo lc b">printHello</code>推送到<strong class="ka ir">回调队列</strong>。由于这里传递给<code class="fe lm ln lo lc b">setTimeout</code>的定时器持续时间是0 ms，<code class="fe lm ln lo lc b">printHello</code>被立即推送到<strong class="ka ir">回调队列</strong>，但是还没有执行，因为我们知道，所有同步代码必须在JavaScript的事件循环将代码从<strong class="ka ir">回调队列</strong>推送到<strong class="ka ir">调用栈</strong>之前执行。</li><li id="2d88" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">1 ms:我们的<strong class="ka ir">双叉门面函数，</strong> <code class="fe lm ln lo lc b"><strong class="ka ir">fetch</strong></code>在<code class="fe lm ln lo lc b">const futureData</code>中存储一个<strong class="ka ir">承诺对象</strong>，并触发Twitter的API的XHR。</li><li id="a532" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">2 ms:一个回调，这里<code class="fe lm ln lo lc b">display</code>被添加到我们<code class="fe lm ln lo lc b">futureData</code> <strong class="ka ir">承诺对象</strong>的<code class="fe lm ln lo lc b">value</code>键中</li><li id="3440" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">3 ms: <code class="fe lm ln lo lc b">blockFor300ms</code>被调用，导致Javascript线程被阻塞300 ms。</li><li id="3e13" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">季克</li><li id="fcd0" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">除草醚</li><li id="fcfd" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">季克</li><li id="5350" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">除草醚</li><li id="186b" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">270 ms:我们的网络请求返回了数据，该数据立即存储在我们的<code class="fe lm ln lo lc b">const futureData</code> <strong class="ka ir">承诺对象</strong>的<code class="fe lm ln lo lc b">value</code>键中。</li><li id="6124" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">300 ms:我们的<code class="fe lm ln lo lc b">blockFor300ms</code>函数已经完成了对Javascript线程的阻塞。</li><li id="0e5c" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">301毫秒:我们执行<code class="fe lm ln lo lc b">console.log("Me first !")</code>。</li></ul><h2 id="af1f" class="lg lh iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">现在出现了一个问题，先执行什么？我们的回调传递给了<code class="fe lm ln lo lc b">setTimeout</code>还是传递给了我们<code class="fe lm ln lo lc b">futureData</code>承诺对象的<code class="fe lm ln lo lc b">.value</code>键？</h2><p id="6267" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">接下来是<strong class="ka ir">微任务队列</strong>，它是在承诺对象的<code class="fe lm ln lo lc b">.onFulfilled</code>数组中找到的回调队列。</p><p id="0a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，负责从<strong class="ka ir">回调队列</strong>向调用堆栈添加回调的事件循环，也负责添加在<strong class="ka ir">微任务队列</strong>中找到的回调。</p><p id="c724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以决定哪些回调首先被允许返回JavaScript的是<strong class="ka ir">事件循环</strong>检查我们两个队列的顺序。</p><p id="6a11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">.</p><p id="ea39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">.</p><p id="ce81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">.</p><p id="ccad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">事件循环</strong>首先检查<strong class="ka ir">微任务队列</strong>，然后检查C <strong class="ka ir"> allback队列</strong>，因此M <strong class="ka ir">微任务队列</strong>中的回调将总是在<strong class="ka ir">回调队列</strong>中的回调之前执行。</p><p id="fc22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到我们的例子:</p><ul class=""><li id="cf38" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">302毫秒:我们执行<code class="fe lm ln lo lc b">display</code></li><li id="5b1e" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">303毫秒:我们执行<code class="fe lm ln lo lc b">printHello</code></li></ul><p id="a992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">博客灵感来源于<a class="ae kw" href="https://frontendmasters.com/" rel="noopener ugc nofollow" target="_blank">前端大师</a> / <a class="mz na ep" href="https://medium.com/u/1b199ed2dfd?source=post_page-----6111f7452f05--------------------------------" rel="noopener" target="_blank">前端大师</a>，<a class="mz na ep" href="https://medium.com/u/c211a09475?source=post_page-----6111f7452f05--------------------------------" rel="noopener" target="_blank">教授的JavaScript:难的部分v2将会提交一份清单</a>，这篇文章就是由此而来。对于那些想大幅增加他们的前端编程知识的人来说，这是一个惊人的资源。</p><p id="b426" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p><p id="fd20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">爱，光，代码❤️</p><h2 id="a2a0" class="lg lh iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">用简单英语写的JavaScript的注释</h2><p id="4eee" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kw" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka ir">AI in Plain English</strong></a><a class="ae kw" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka ir">UX in Plain English</strong></a><a class="ae kw" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka ir">Python in Plain English</strong></a><strong class="ka ir"/>—谢谢，继续学习！</p><p id="ee00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kw" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">submissions @ plain English . io</strong></a><strong class="ka ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>