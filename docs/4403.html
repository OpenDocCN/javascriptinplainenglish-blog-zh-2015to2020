<html>
<head>
<title>Moving to Non-Relational Database? Here is what you should know as a developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转向非关系数据库？作为开发人员，您应该知道以下内容</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-differences-between-relational-and-non-relational-databases-that-most-developers-dont-know-8fad25ae2575?source=collection_archive---------10-----------------------#2020-12-08">https://javascript.plainenglish.io/the-differences-between-relational-and-non-relational-databases-that-most-developers-dont-know-8fad25ae2575?source=collection_archive---------10-----------------------#2020-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b31da9284cedf15da2037f64eabb9733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgyPcKGSzmzaHzEjVISwqg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@valeriydmi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Valeriy Khan</a> on <a class="ae kc" href="https://unsplash.com/s/photos/programmer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aee2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NoSQL DBs现在在初创企业和大公司中非常受欢迎。然而，仍然有相当多的开发人员努力去理解它是如何工作的，并且可能影响项目的架构决策。因此，我创建了一个旅程，强调数据库如何完全改变我们解决开发问题的方式，如数据结构、数据完整性、微服务、性能和查询。这个想法是为了提供一个关于DB的类型如何影响你的代码设计的观点。</p><h2 id="e071" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">SQL数据库如何工作</strong></h2><p id="e0b2" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在我们讨论非关系数据库之前，让我们花点时间来理解关系数据库的概念，以及非关系模型与它有什么不同。考虑一个DRM，其中有两个实体:客户和国家。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/9494a1ba8521b2ab330a976777dcc0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*bFHnriEsrm7HrjN3_e-2BQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Academic DRM</figcaption></figure><p id="24a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关系非常简单:一个客户可以有一个国家，一个国家可以有很多客户。要使用此模型查询客户，您必须执行以下操作:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="aa84" class="lb lc iq mf b gy mj mk l ml mm">select * from customer cu, country co where cu.CountryId == co.CountryId</span></pre><p id="935a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，每次查询客户时，都会读取两个表:客户和国家。这是因为它们是相关的，并且国家/地区的详细信息是在国家/地区表中定义的。现在，让我们忘记技术角度，从一个不同的角度来观察这个模型:一个人一生中多久搬到一个不同的国家？我相信很少有人会说超过4，我想现在你明白我的意思了。如果值几乎不变，我为什么要从两个表中读取呢？</p><p id="ffc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您认为解决方案是将CountryName作为一个独立的字段添加到客户的表中，我相信您仍然没有理解这一点。尽管这可能是上述问题的解决方案(稍后讨论),但不幸的是，它可能会造成数据的不一致。如果您创建一个开放字段，为了按国家查询报告，您很可能会找到“AUS”、“AU”、“AUSTRALIA”、“Australia”等。肯定不是我们想要的。而且，上面的例子只是学术上的。在现实生活中，客户DRM看起来更像这样:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/dbc260ecf225f2585acecd3f80cc6d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ul5NOoERw0rK3U13Y_oaDQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Real Life DRM 😱</figcaption></figure><p id="a9d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来像是我过度构建了上面的DRM，但是相信我，还有更糟糕的。现在想象一下，查询所有这些表来获取一个客户的配置文件的成本。这就是关系数据库的工作方式，也是创建非关系数据库的原因之一:降低代码执行期间从不同表中查询细节的成本。另一方面，关系数据库为构建业务报表和复杂查询提供了更好的支持。</p><h2 id="e5f1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">这个架构在非关系数据库中会是什么样子？</strong></h2><p id="1ee6" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在noSQL模型中，我们有集合而不是表，它们是不相关的。什么？😱。是的，没有关系。他们只是自己独立游荡。最重要的是，集合的文档不必维护相同的数据结构，这意味着更大的灵活性。主要区别在于，如果需要提取实体，单个集合将包含所有必要的信息。大概是这样的:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a6b8" class="lb lc iq mf b gy mj mk l ml mm">{<br/>    "_id": "b28f459c-8ad3-11ea-bc55-0242ac130003",<br/>    "name": "Test Name",<br/>    "country": {<br/>      "_id": "b28f459c-8ad3-11ea-bc55-0242ac130004",<br/>      "name": "Australia"<br/>    }<br/>}</span></pre><p id="1f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我们仍然有两个集合(Customer和Country)，但是Customer的新记录不仅包含国家的Id，还包含名称。这样，您可以轻松获得国家的名称，而无需查询其集合。</p><h2 id="19b3" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">但是如果客户的国家名称改变了呢？</h2><p id="d8e8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在这开始变得有趣起来，因为没有一个数据库特性来镜像数据。对于非关系数据库，有几种方法可以解决这个问题(如果这确实是一个问题的话)，下面是一些可以根据业务决策使用的选项:</p><ol class=""><li id="efb6" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">不要让客户更改国家的名称，而是创建一个脚本，一次更新国家和客户。例如:</li></ol><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="26d0" class="lb lc iq mf b gy mj mk l ml mm">Customer.update(<br/>    { "_id": "b28f459c-8ad3–11ea-bc55–0242ac130003" },<br/>    { "country.name": "new_country_name" }<br/>)<br/>Country.update(<br/>    { "_id": "b28f459c-8ad3–11ea-bc55–0242ac130004" },<br/>    { "name": "new_country_name" }<br/>)</span></pre><ol class=""><li id="2544" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">执行一个任务(cronjob、lambda或message queuing ),该任务将检查已更改的国家，并用该国家更新所有客户。这将保持一致性，但需要不断更新数据。</li><li id="b0eb" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">保留旧数据，直到有人更新客户。这种解决方案不仅可以保持一致性，而且成本非常低。换句话说，UI将具有新的名称，当客户被更新时，它将具有新的正确的国家名称。</li><li id="7521" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">更新国家名称的相同代码函数也将更新客户。这将保持一致性，但UX的成本很高，因为用户/客户端需要等待整个后端事务完成，而且这也是一个难以维护的解决方案。</li><li id="fc07" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">忽略数据库中的数据，只在客户机上更改它。例如，如果DB返回“AUS”或“AU”，则显示“澳大利亚”。如果必须更改许多客户端，这种解决方案将无法保持一致性，并且成本很高。</li></ol><p id="eae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个想法不是告诉如何解决问题，而是强调方法如何根据DB类型而变化。每个选项都适用于不同的情况。例如，选项3可能是最好的选择，因为在1949年，这个国家<strong class="kf ir">暹罗</strong>变成了<strong class="kf ir">泰国</strong>，而且并不是每个人都从第一天开始就采用新名字。我相信即使是老前辈也会使用以前的名字，那么为什么要花费时间和精力这么快就改变呢？</p><h2 id="f7cb" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">好的。客户x国家很简单，但是在第二个复杂的例子中，客户有几个关系呢？</strong></h2><p id="d79a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">实际上，在非关系架构中，由于灵活的数据结构，这些实体不太可能是数据库中的独立文档。在大多数情况下，它们只是一个带有一些预定义值的枚举。因为noSQL DB中的文档可以有任何结构，所以在代码级定义它的模式是很常见的。当然，如果您想让客户能够灵活地自己管理数据，这并不适用，这意味着在这种情况下，SQL DB可能是更好的选择。如果我们考虑这个复杂的例子，ODM看起来会像这样:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1125" class="lb lc iq mf b gy mj mk l ml mm"><strong class="mf ir">var</strong> customer = new Schema({<br/>    name: {<br/>        type: String<br/>    },<br/>    DOB: {<br/>      type: Date,<br/>      required: true<br/>    },<br/>    country: new Schema({<br/>        name: {<br/>            type: String<br/>        }<br/>    }),<br/>    membershipType: {<br/>        type: String,<br/>        enum: ['Gold', 'Silver', 'Premium']<br/>    },<br/>    employmentStatus: {<br/>        type: String,<br/>        enum: ['Casual', 'Full-time', 'Part-time', 'Retired']<br/>    },<br/>    maritalStatus: {<br/>        type: String,<br/>        enum: ['Married', 'Divorced', 'DeFacto', 'Single']<br/>    }<br/>});</span></pre><p id="cfd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，因为选项是预定义的，所以将对任何输入值的尝试进行验证。想象一下，我们需要将事实上的<strong class="kf ir">变成事实上的</strong>和<strong class="kf ir"/>。可以对已经存在的记录执行更新查询，并更新代码。</p><blockquote class="nc nd ne"><p id="b355" class="kd ke nf kf b kg kh ki kj kk kl km kn ng kp kq kr nh kt ku kv ni kx ky kz la ij bi translated">因为nonSQL是灵活的，所以数据模式可以在代码级别定义，并且很容易更改、验证和重用。换句话说，没有DB变化。</p></blockquote><p id="231e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于上例中的国家/地区详细信息，从客户集合的角度来看，该数据是来自另一个集合还是任何其他来源并不重要。重要的是它需要一个代码(在创建新模式时由一些ODM隐式创建)和一个名称。事实上，它可能有创建日期、更新日期、客户语言、以前的国家等。你可以灵活地创造任何你想要的东西。</p><h2 id="cff2" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">我会一直更新我的收藏以保持数据的一致性吗？</strong></h2><p id="c47a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">到目前为止，我们一直在谈论不同的实体以及如何保持它们的变化一致。但是如果一致性实际上意味着不改变数据呢？😕。好吧，我来解释一下。让我们考虑一个经典的产品订单，其中一个订单可能包含几个产品。在关系数据库中，它将包含:产品、客户、订单、产品订单列表等。但是，因为我们不会关联数据，所以在非关系数据库中，顺序应该是这样的:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c773" class="lb lc iq mf b gy mj mk l ml mm"><strong class="mf ir">var</strong> Order = new Schema({<br/>    customer: {<br/>        customerId: UUID,<br/>        <strong class="mf ir">membershipType</strong>: String,<br/>        <strong class="mf ir">maritalStatus</strong>: String //or a list of predefined values<br/>    },<br/>    date: {<br/>        type: Date,<br/>        required: true<br/>    },<br/>    total: {<br/>        type: Number,<br/>        required: true<br/>    },<br/>    Products: [{<br/>        productId: UUID,<br/>        <strong class="mf ir">name</strong>: String,<br/>        <strong class="mf ir">price</strong>: Number,<br/>        discount: Number,<br/>    }],<br/>});</span></pre><p id="8dfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你仔细观察，在上面的例子中，我突出显示了一些属性，因为实际上它们是我们不想改变的信息，以防原始源发生变化。什么🤪？是的。假设零售商根据会员资格提供折扣，有时也根据婚姻状况提供折扣。在这种情况下，我们不想让这些数据与客户的数据保持镜像，因为订单代表了客户购买时的快照，这是我们想要知道的会员信息。因此，如果客户升级他们的会员资格，我们将知道他们在以前的订单中有“基本”类型。</p><p id="d00e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令人惊讶的是，要对关系数据库执行相同的查询，需要使用几个连接，其中包括:</p><ul class=""><li id="2e2a" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la nj mu mv mw bi translated">拥有会员身份和婚姻身份的客户，</li><li id="dab0" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nj mu mv mw bi translated">和有订单的客户，</li><li id="9ad7" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nj mu mv mw bi translated">Order with membershipStatus和with maritalStatus，(是的，我们必须复制这个关系，因为它对客户来说是不可变的)</li><li id="7411" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nj mu mv mw bi translated">等等</li></ul><p id="ba6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是从订单中提取客户详细信息。如果我们还需要查询其他属性的话，查询会一直持续下去。</p><h2 id="6c78" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">但是如果我想查询所有客户的详细信息呢？</h2><p id="d02c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">相信我的写作的功效，在这一点上，我们理解目标是减少数据库查询成本。换句话说:性能。理想情况下，应该在架构设计期间检查预期要检索的数据，但是如果结论是分别从两个不同的实体收集数据，那么解决方案将是执行2个或更多查询。但是，如何执行查询将取决于您的代码架构。让我们看几个例子:</p><ul class=""><li id="be8d" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la nj mu mv mw bi translated">微服务:如果实体不属于微服务，那么，客户端UI将需要从每个微服务中检索数据。</li><li id="9899" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la nj mu mv mw bi translated">Monolithic:如果这是一个非常常用的请求，并且所有数据都被消耗，那么可以创建一个端点来检索所有数据。如果不经常使用，并且存在风险，或者根据不同场合部分使用客户详细信息，则可以为每个案例创建不同的端点。</li></ul><p id="8276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更重要的是，尽管noSQL DB没有关系概念，但Mongoose有一个名为<a class="ae kc" href="https://mongoosejs.com/docs/populate.html" rel="noopener ugc nofollow" target="_blank">填充</a>的特性，它允许使用与SQL DB相同的概念进行连接。然而，即使这个功能非常方便，也有一些人反对使用它，因为这不是一个非关系数据库应该使用的方式。</p><h2 id="754b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">数据库的类型如何影响微服务架构？</strong></h2><p id="eda8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><a class="ae kc" href="https://microservices.io/patterns/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务</a>的一个原则就是松耦合，也就是说每个微服务都要完全独立和隔离。我不打算详细介绍这个模式(也许我应该写一整篇关于这个主题的文章)，但是我想你可以明白我的意思。每个服务都应该有自己的数据库，这些数据库不应该与其他数据库相关，这使我们得出结论，nonSQL数据库是微服务的最佳选择。我从未在微服务中使用过SQL DB，但我觉得复制与多个表相关的表并不有趣。此外，对所有微服务使用相同的数据库是一种反模式。如果你使用过关系数据库的微服务，请留下你的经验评论。</p><blockquote class="nc nd ne"><p id="4490" class="kd ke nf kf b kg kh ki kj kk kl km kn ng kp kq kr nh kt ku kv ni kx ky kz la ij bi translated">与其他服务松散耦合:使团队能够大部分时间独立地工作于他们的服务，而不受其他服务变更的影响，也不会影响其他服务</p></blockquote><p id="de4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不久前，我写了一篇关于在将AWS Lambda函数连接到数据库之前应该知道的<a class="ae kc" href="https://medium.com/javascript-in-plain-english/serverless-things-i-wish-i-had-known-part-2-dynamodb-x-mongodb-x-aurora-serverless-1053cfddff36" rel="noopener">事情的文章，其中我强调了我选择MongoDB而不是DynamoDB作为无服务器应用程序的原因。然而，出于同样的原因，考虑到每个表都被视为完全独立的实体，DynamoDB将是微服务的最佳调用。这将有助于保持为每个服务维护不同DB(在dynamoDB中，它们是表)的模式。</a></p><h2 id="00d1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">总而言之</strong></h2><p id="5a94" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在构建应用程序时，有几种数据库可供选择，它们基本上分为NoSQL和SQL。尽管NoSQL已经接管了市场，但了解它如何改变我们设计应用程序、解决日常问题的方式，以及它是否满足项目的业务需求是非常重要的。</p><p id="7d57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里还有一个表格，总结了本文涉及的主要领域:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/c20cb11e23c4153f8e5ce59f71a72052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0qGWhylrckftzrIUwe8uw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Main differences with the answers</figcaption></figure><p id="e935" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">词汇</strong></p><p id="e019" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DRM →数据关系模型<br/> ODM →对象文档映射器</p><p id="9811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">参考文献</strong></p><p id="1669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://mongoosejs.com/docs/populate.html" rel="noopener ugc nofollow" target="_blank">https://mongoosejs.com/docs/populate.html</a><br/>T12】https://microservices.io/patterns/microservices.html</p></div></div>    
</body>
</html>