<html>
<head>
<title>3 Express.js features you need to know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要知道的3个Express.js特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-express-js-features-you-need-to-know-8f78b0035f33?source=collection_archive---------2-----------------------#2020-02-02">https://javascript.plainenglish.io/3-express-js-features-you-need-to-know-8f78b0035f33?source=collection_archive---------2-----------------------#2020-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f624" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">即使是复杂的web应用程序也可以用Express.js很好地实现——尤其是有了这些有用的特性。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a215447f351736f231eab14fed245650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XP-mZOrIqX7OsFInN2ngRQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Express.js — the most famous framework for Node.js</figcaption></figure><p id="a87f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">任何使用过Node.js的人都应该知道Express.js，几乎所有主要的Node.js apps都依赖于这个框架，就像我对自己的项目一样。是的，Express肯定不是无与伦比的，但它已经成为动态web应用程序的标准，使用Express实现起来要容易得多。</p><p id="f8cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，即使Express已经广为人知，这里还是有一些你应该知道的重要特性。</p><h1 id="2920" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">1.)创建自己的Express中间件</h1><p id="646a" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">中间件还没告诉你什么？没问题，你会喜欢的。</p><p id="86d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">中间件是在任何路由请求之后执行的功能。在中间件中，我们可以像往常一样访问请求和响应，并使用它们来输出内容、检查URL等。<br/>与普通app.get的主要区别在于中间件具有<strong class="kx ir"> next() </strong>功能。<br/>如果这个被执行，任务被转发到<strong class="kx ir"> app.get </strong>函数，该函数在中间件被执行后实际负责路由。</p><p id="a11a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个简单的例子:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="56ab" class="mt ls iq mp b gy mu mv l mw mx">app.use((req, res, next) =&gt; {<br/>  console.log(‘Middleware triggered’, req.url)<br/>  next()<br/>})</span><span id="104a" class="mt ls iq mp b gy my mv l mw mx">app.get(‘/’, (req, res) =&gt; {<br/>  res.send(‘landing page’)<br/>})</span><span id="7c4a" class="mt ls iq mp b gy my mv l mw mx">app.get(‘/start’, (req, res) =&gt; {<br/>  res.send(‘start page’)<br/>})</span></pre><p id="8706" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当你运行这个应用程序时，浏览器会做该做的事情。两条独立的路线，每条路线都输出文本。<br/>但是在后端，每次你调用两个路由中的一个，就会通过中间件执行一个<strong class="kx ir"> console.log </strong>，其中请求的路由通过<strong class="kx ir"> req </strong>对象输出，中间件可以像访问两个<strong class="kx ir"> app.get </strong>函数一样访问这个对象。<br/>对<strong class="kx ir"> next() </strong>的调用使得看起来好像什么都没发生。运行中间件后，app.get函数再次接管。</p><p id="c84e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的第一个例子中，我们现在有了中间件，它在对服务器的每个请求上执行。我们还可以专门为路由创建中间件——通过简单地定义路由，这对于基本路由“/”不起作用。此外，<strong class="kx ir"> req.url </strong>默认设置为“/”，即使我们要访问的路径是“/start”:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="d82a" class="mt ls iq mp b gy mu mv l mw mx">app.use(‘/start’, (req, res, next) =&gt; {<br/>  console.log(‘You called /start’, req.url)<br/>  next()<br/>})</span><span id="5271" class="mt ls iq mp b gy my mv l mw mx">app.get(‘/’, (req, res) =&gt; {<br/>  res.send(‘landing page’)<br/>})</span><span id="25f7" class="mt ls iq mp b gy my mv l mw mx">app.get(‘/start’, (req, res) =&gt; {<br/>  res.send(‘start page’)<br/>})</span></pre><p id="a524" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过有意使用<strong class="kx ir"> next() </strong>我们可以更深入地介入应用程序的流程——不仅仅是通过<strong class="kx ir"> req </strong>对象:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="bfc8" class="mt ls iq mp b gy mu mv l mw mx">app.use((req, res, next) =&gt; {<br/>  console.log(‘Middleware triggered’)</span><span id="06bc" class="mt ls iq mp b gy my mv l mw mx">  if (req.url === ‘/’) {<br/>    res.send(‘Landing page. Greetings from  middleware’)<br/>  } else {<br/>    next()<br/>  }<br/>})</span><span id="517c" class="mt ls iq mp b gy my mv l mw mx">app.get(‘/’, (req, res) =&gt; {<br/>  res.send(‘landing page’)<br/>})</span><span id="c9a1" class="mt ls iq mp b gy my mv l mw mx">app.get(‘/start’, (req, res) =&gt; {<br/>  res.send(‘start page’)<br/>})</span></pre><p id="784b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你现在在浏览器中进入<strong class="kx ir">"/</strong>，app.get的代码永远不会在后端执行，因为正如你所看到的，我们在调用<strong class="kx ir">"/</strong>时专门在中间件中捕捉。<br/>因为我们从不执行<strong class="kx ir"> next() </strong>，所以我们已经可以在中间件中执行一个响应了。<br/> <strong class="kx ir">注意:</strong>在中间件响应后执行<strong class="kx ir"> next() </strong>会导致错误。</p><p id="a21d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">结论:</strong>中间件非常强大，可以深入我们的app，简化流程，拦截错误甚至保护某些路线。</p><h1 id="d424" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">2.)使用app.use提供静态资产</h1><p id="ea50" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">你有没有尝试过通过你的Node.js应用让静态内容比如图像甚至CSS文件变得可用？<br/>当然你可以为每个CSS文件创建一个单独的路径，但是你也可以使用Express来使整个文件夹及其内容静态可用。</p><p id="a9c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是文件夹结构:对于静态内容，我创建了文件夹“<strong class="kx ir"> static </strong>”。<br/>├──app . js<br/>├──package-lock . JSON<br/>├──package . JSON<br/>└──静态<br/> └── styles.css</p><p id="42b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是<strong class="kx ir"> app.js </strong>:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="d92a" class="mt ls iq mp b gy mu mv l mw mx">const express = require(‘express’)<br/>const app = express()</span><span id="951c" class="mt ls iq mp b gy my mv l mw mx">app.use(‘/static’, express.static(‘./static’))</span><span id="33e9" class="mt ls iq mp b gy my mv l mw mx">app.listen(8080)</span></pre><p id="3e3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过<strong class="kx ir"> app.use </strong>我们定义了通过哪条路线可以得到某些东西。其次，我们传递了<strong class="kx ir"> express.static </strong>函数，这是使静态内容可用的实际特性。<br/>因此，我们将从路径<a class="ae mz" href="http://localhost:8080/static/styles.css/" rel="noopener ugc nofollow" target="_blank"> <em class="na">下的<strong class="kx ir">静态</strong>文件夹中获取CSS文件http://localhost:8080/static/styles . CSS/</em></a></p><h1 id="6d27" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">3.)将路线文件分割成单个文件</h1><p id="636d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在我早期的一个项目中，我不熟悉这种技术，这只是导致我最终得到了一个大约300行的app.js文件。<br/> 300行？怎么做呢？通过在一个文件中使用所有的路由函数。当然，到处都有app.get()的会导致巨大的混乱。在Express中有一个解决方案:我们可以很容易地将我们的单独路线分割成单独的文件。这是它的工作原理。</p><p id="4bc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">项目结构:<br/>├──app . js<br/>├──package-lock . JSON<br/>├──package . JSON<br/>└──航线<br/> └── home.js</p><p id="c68a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">单个路线的所有文件进入我们的<strong class="kx ir"> /routes </strong>文件夹，我们导入&amp;并在主文件<strong class="kx ir"> app.js </strong>中使用它们。</p><p id="f367" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> home.js: </strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="39cb" class="mt ls iq mp b gy mu mv l mw mx">const express = require(‘express’)<br/>const Router = express.Router()</span><span id="f8b2" class="mt ls iq mp b gy my mv l mw mx">Router.get(‘/home’, (req, res) =&gt; {<br/>  res.send(‘from the home.js’)<br/>})</span><span id="0a7d" class="mt ls iq mp b gy my mv l mw mx">module.exports = Router</span></pre><p id="97e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> app.js: </strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="9f62" class="mt ls iq mp b gy mu mv l mw mx">const express = require(‘express’)<br/>const app = express()</span><span id="8c93" class="mt ls iq mp b gy my mv l mw mx">const homeRoute = require(‘./routes/home’)</span><span id="b3be" class="mt ls iq mp b gy my mv l mw mx">app.use(homeRoute)</span><span id="9c8f" class="mt ls iq mp b gy my mv l mw mx">app.get(‘/’, (req, res) =&gt; {<br/>  res.send(‘from our main file’)<br/>})</span><span id="b609" class="mt ls iq mp b gy my mv l mw mx">app.listen(8080)</span></pre><p id="f633" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决我们的问题，快递提供了<strong class="kx ir">快递。路由器()</strong>。<br/>这允许我们像往常一样使用我们的路线，然后导出它们以使它们可用。<br/>在我们的<strong class="kx ir"> app.js </strong>中，我们可以导入我们的路线处理文件，并通过app.use使用它们。<br/>结果与我们通过<strong class="kx ir"> app.js </strong>处理所有路线是一样的。</p><h2 id="1bae" class="mt ls iq bd lt nb nc dn lx nd ne dp mb le nf ng md li nh ni mf lm nj nk mh nl bi translated">迷你功能，感谢评论中的建议:)</h2><p id="c596" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">为了避免重复，我们可以将几个应该使用相同功能的路由合并到一个数组中。因此，如果我们希望在“/”和“/start”处得到相同的输出，我们可以这样做:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="9b17" class="mt ls iq mp b gy mu mv l mw mx">app.get([‘/’, ‘/start’], (req, res) =&gt; {<br/>  res.send(‘/ or /start’)<br/>})</span></pre><h1 id="9859" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">关于Express的更多信息:</h1><div class="nm nn gp gr no np"><a href="https://medium.com/javascript-in-plain-english/express-handlebars-dd2fb85e265d" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">Express.js和把手——3个有用的功能</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">HTML变得更加高效和有趣</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kp np"/></div></div></a></div><h1 id="146c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">到目前为止就是这样——但是如果你想了解更多关于Node &amp; Express的知识，我这里有一些提示给你。</h1><p id="3311" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">首先感谢您阅读这篇文章。记得给我留点掌声，免费的:)</p><p id="040b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是我的建议，如果你想了解更多关于Node和co。</p><ul class=""><li id="9897" class="oe of iq kx b ky kz lb lc le og li oh lm oi lq oj ok ol om bi translated">在<a class="ae mz" href="https://medium.com/javascript-in-plain-english" rel="noopener"> JS in plain English </a>上，你可以找到更多与Node.js、Express &amp; co .相关的精彩文章。</li><li id="1abf" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">查看我的个人资料，我也非常关注Node.js内容</li><li id="e563" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">Node.js上Maximilian Schwarzüller &amp; Stephen Grider的Udemy课程很不错。</li><li id="4c8a" class="oe of iq kx b ky on lb oo le op li oq lm or lq oj ok ol om bi translated">就我个人而言，我喜欢大量阅读，因为不用看屏幕对眼睛来说更舒服。因此，我可以向您强烈推荐亚马逊上的这本<br/> <a class="ae mz" href="https://geni.us/louisbooks" rel="noopener ugc nofollow" target="_blank">节点&amp;快递圣经</a>。</li></ul><h2 id="c5ca" class="mt ls iq bd lt nb nc dn lx nd ne dp mb le nf ng md li nh ni mf lm nj nk mh nl bi translated"><a class="ae mz" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank">加入我的邮件，接收你感兴趣的一切</a></h2><h1 id="8719" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated"><strong class="ak">关于我，作者:)</strong></h1><p id="be6f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">嗨！再次感谢您的阅读，我叫路易斯，是一名来自德国的18岁学生。我热爱Web开发，包括后端和前端。我最喜欢的技术是React，Vue，React Native和Node.js. <br/>请务必关注我，了解更多与这些相关的内容，并随时查看我的IG @ Louis . jsx&amp;@ codingcultureshop<br/>祝您愉快！</p></div></div>    
</body>
</html>