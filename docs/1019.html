<html>
<head>
<title>Frontend Development with Docker: A simplified guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker进行前端开发:简化指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/frontend-development-with-docker-a-simplified-guide-c869f6ee0fe8?source=collection_archive---------1-----------------------#2020-01-16">https://javascript.plainenglish.io/frontend-development-with-docker-a-simplified-guide-c869f6ee0fe8?source=collection_archive---------1-----------------------#2020-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/74e3383dbcdf214f392e26dfedc2cbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlRxQy1tyOuWfaG2SJlppg.png"/></div></div></figure><p id="6f48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker是一个很棒的工具，可以帮助开发人员以标准化的方式更有效地构建、部署和运行应用程序。对于前端应用程序，我们只需要Docker映像进行本地开发，因为我们将它部署到一个静态托管提供商。在这种情况下，我们能没有自定义Docker图像吗？我们能有没有Docker时同样的开发体验吗？是的，这比你想象的要容易。</p><h1 id="51f8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">要求</h1><p id="10ba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设一个应用程序，我们只需按下start，一切都在运行。该设置可以是React、Vue、Angular CLI生成的任何应用程序。出于演示的目的，我将使用我的<a class="ae lz" href="https://github.com/blacksonic/todoapp-vue" rel="noopener ugc nofollow" target="_blank"> Vue Todo应用程序</a>。</p><p id="f1c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开发过程中，我们将执行以下步骤:</p><ul class=""><li id="e75c" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">使用<code class="fe mj mk ml mm b">npm install</code>安装依赖项</li><li id="16d7" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">用<code class="fe mj mk ml mm b">npm start</code>启动应用程序</li><li id="0d7b" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">修改文件并在浏览器中检查更改</li><li id="c5b4" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">在编辑器中使用模块的代码补全</li><li id="4729" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">向<code class="fe mj mk ml mm b">package.json</code>添加一个新的依赖项并安装它</li></ul><h1 id="0860" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">自定义Docker文件</h1><p id="4c0e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果你用Docker在网上搜索前端开发，你可以找到很多使用自定义Docker图片的文章。让我们来看看它是如何工作的。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/8f031a8f90ee3ca17525f9e53d072d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4yfovbVB2wAUmGjw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Dockerfile</figcaption></figure><p id="d9da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://github.com/blacksonic/todoapp-vue/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Docker文件</a>从定义我们将要构建的基础映像(Node.js 12.x)开始(<code class="fe mj mk ml mm b">FROM</code>，并将工作目录设置为<code class="fe mj mk ml mm b">/app</code>文件夹(<code class="fe mj mk ml mm b">WORKDIR</code>)。以<code class="fe mj mk ml mm b">RUN</code>或<code class="fe mj mk ml mm b">CMD</code>开头的每个命令都将这个文件夹作为默认工作目录。</p><p id="d7a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是复制源文件(<code class="fe mj mk ml mm b">COPY</code>)并安装依赖项。我们将<code class="fe mj mk ml mm b">package.json</code>与其他文件分开复制。为什么？因为Docker在多次构建映像时会缓存Dockerfile的每一步。当不修改任何内容并再次构建映像时，它不会做任何事情，因为步骤已被缓存。如果我们改变一个Javascript文件，Docker将运行来自<code class="fe mj mk ml mm b">COPY . /app</code>的命令。当我们修改<code class="fe mj mk ml mm b">package.json</code>文件时，Docker将重新运行来自<code class="fe mj mk ml mm b">COPY package.json /app</code>的命令。</p><p id="6a64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，运行在容器内部特定端口上的应用程序在主机上不可用。我们必须使端口可用(<code class="fe mj mk ml mm b">EXPOSE</code>)。只有在这之后，我们才能在我们的浏览器中键入URL(<a class="ae lz" href="http://localhost:8900" rel="noopener ugc nofollow" target="_blank">http://localhost:8900</a>)并看到结果。</p><p id="58aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要运行这个映像，我们必须构建它并运行创建的容器。</p><pre class="mt mu mv mw gt nb mm nc nd aw ne bi"><span id="0e6f" class="nf kx iq mm b gy ng nh l ni nj"># Build the image: docker build -t &lt;image-name&gt; &lt;relative-path-to-dockerfile&gt;<br/>docker build -t client . <br/># Run the image: docker container run -p &lt;host port:container port&gt; &lt;image-name&gt;  <br/>docker container run -p 8900:8900 client</span></pre><h1 id="1007" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">不足之处</h1><p id="93fb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上面的Docker图像可以工作，但是有多个缺点:</p><ul class=""><li id="45aa" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">容器内生成的文件在主机上不可见，只能在容器内看到。这意味着我们在主机上看不到<code class="fe mj mk ml mm b">node_modules</code>文件夹，正因为如此，我们失去了编辑器中的代码完成功能。我们不能将生成的<code class="fe mj mk ml mm b">package.lock.json</code>提交到源代码控制，因为它在主机上也不可用。</li><li id="9876" class="ma mb iq ka b kb mn kf mo kj mp kn mq kr mr kv mf mg mh mi bi translated">我们必须停止、构建和重新运行依赖关系和文件变更的容器。我们失去了实弹射击的能力。</li></ul><h1 id="04ea" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">会见码头工人作曲</h1><p id="8897" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Docker可以构建单个映像并运行构建的容器。Docker Compose步骤更进一步，因为它可以同时构建和运行多个映像。在本教程中，我们不会使用众多的构建功能；我们将只使用它来克服前一个例子的缺点。</p><p id="73eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我们可以使用之前的<code class="fe mj mk ml mm b">Dockerfile</code>来运行Docker Compose，但我们将使用它来跳过自定义图像的编写。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/2c19e9be1b0da3f370bd518d7591d976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ms-C9e4b5WSa-84Bz_v2qw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Docker Compose</figcaption></figure><p id="ec43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker Compose使用<a class="ae lz" href="https://github.com/blacksonic/todoapp-vue/blob/master/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> YAML配置文件格式</a>，而不是用一系列命令定义图像。在<code class="fe mj mk ml mm b">services</code>键下，Vue应用程序的图像被命名为<code class="fe mj mk ml mm b">client</code>。它相当于<code class="fe mj mk ml mm b">docker build -t &lt;image-name&gt;</code>命令中的命名。这里的描述以同样的方式开始:定义基础映像(<code class="fe mj mk ml mm b">image</code>)和设置工作目录(<code class="fe mj mk ml mm b">working_dir</code>)。</p><p id="8abb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关键的区别来自于<code class="fe mj mk ml mm b">volumes</code>属性。通过使用它，本地文件夹与容器同步。如果我们在容器中执行<code class="fe mj mk ml mm b">npm install</code>命令，那么<code class="fe mj mk ml mm b">node_modules</code>文件夹也会出现在主机上:我们得到代码完成和锁文件。</p><p id="c555" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序也在容器中启动(<code class="fe mj mk ml mm b">command: sh -c "npm install &amp;&amp; npm start"</code>)，将端口暴露给主机对于浏览器访问是必要的(<code class="fe mj mk ml mm b">ports</code>)。</p><p id="67c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要运行这个设置，我们必须构建它并运行构建的容器。</p><pre class="mt mu mv mw gt nb mm nc nd aw ne bi"><span id="1f87" class="nf kx iq mm b gy ng nh l ni nj"># Build the image and start the container <br/>docker-compose up</span></pre><p id="86f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你看一下这两个解决方案，它们几乎是一样的。在<code class="fe mj mk ml mm b">Dockerfile</code>中的命令和<code class="fe mj mk ml mm b">docker-compose.yml</code>配置文件中的配置字段之间有很大的相关性。唯一的区别是它们如何处理挂载的文件，这解决了我们的同步问题。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/9a0e6f78c9fe6e6e04b697e6975915de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2-PPrm7W3vO4rGDyaxhNw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Docker Compose vs Dockerfile</figcaption></figure><h1 id="9f82" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="ab44" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当进行本地开发时，拥有快速反馈循环和代码完成是很重要的。如果我们采用纯Docker解决方案，我们将失去这两者。我们不得不寻求Docker老大哥Docker Compose的帮助，帮助我们进行其文件夹同步。通过将我们的设置迁移到Docker Compose，我们恢复了速度和代码完成。希望这一招对你有帮助，节省一吨开发时间。</p><p id="f5fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特别感谢<a class="ae lz" href="https://twitter.com/iben12" rel="noopener ugc nofollow" target="_blank"> iben </a>帮我进行设置。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="da32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nr">原载于2020年1月16日</em><a class="ae lz" href="https://dev.to/blacksonic/frontend-development-with-docker-simplified-254i" rel="noopener ugc nofollow" target="_blank"><em class="nr">https://dev . to</em></a><em class="nr">。</em></p></div></div>    
</body>
</html>