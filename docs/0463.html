<html>
<head>
<title>A Better Way to Organize Your React-Redux Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组织反应的更好方法——Redux钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-redux-hooks-organization-2aa38755d8fb?source=collection_archive---------0-----------------------#2019-10-19">https://javascript.plainenglish.io/react-redux-hooks-organization-2aa38755d8fb?source=collection_archive---------0-----------------------#2019-10-19</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><figure class="gm go jm jn jo jp gi gj paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gi gj jl"><img src="../Images/15758a8a6aab0703579bc809bfec15c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AlIz1u2BKjx3822p"/></div></div></figure><p id="8202" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">钩子无疑是惯用反应的未来。作为一名软件工程团队的领导者，我的任务是确保我的团队能够及时了解当今有意义的技术。就钩子而言，我的团队已经开始在新项目中采用它们。因此，我认为深入了解社区在他们周围形成的一些最新特征会很有用。</p><p id="ca81" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">钩子范例允许所有组件都是功能组件，并且从无状态组件到具有本地状态的组件的转换是无缝的。在reactor-redux模块中引入钩子后，与商店相连的组件(或者我们认为的“容器”)也是如此。</p><p id="898c" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">考虑预挂钩范例中的一个连接组件:</p><figure class="ku kv kw kx gu jp"><div class="bz fq l di"><div class="ky kz l"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk"><strong class="ak">Listing 1</strong> — Connected component without hooks.</figcaption></figure><p id="65c3" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">因为我的团队使用Typescript来确保类型安全，所以在这种情况下，我们创建一个组件，为已经定义的类型定义一个接口(在redux action generator中),作为组件支柱的类型定义，然后我们将组件包装在一个更高级的连接组件中，该组件使用两个函数——一个将状态映射到其对应的支柱接口，一个将我们想要分派的任何函数映射到其对应的支柱接口。我们不仅不必要地重新定义我们的接口，并编写额外的函数来将实体映射到这些接口(我们倾向于为需要使用相同实体的每个容器重新编写)，而且我们还用包装的组件污染了虚拟DOM，这使得检查更加困难。考虑用浏览器中的反应工具检查的这个容器的虚拟DOM:</p><figure class="ku kv kw kx gu jp gi gj paragraph-image"><div class="gi gj le"><img src="../Images/b63342d2a440a0708ddf4e3f2c7f1b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*iQwppi_GrG36ZbwI-GFp5A.png"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk"><strong class="bd lf">Figure 1</strong> — Virtual DOM with higher-ordered component wrappers.</figcaption></figure><p id="daee" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">在检查这个虚拟DOM时，您可以看到我们有包装整个应用程序的原始提供程序，将商店链接到我们的应用程序，后面是2个连接的组件(容器)，第一个是父级应用程序容器，第二个是我们的导航容器，在清单1中引用。您会注意到，每个连接的组件在虚拟DOM的组件树上创建了3个级别:1)组件被上下文提供者包装后的默认导出；2)上下文提供者本身来自react-redux中的“connect”函数；3)您想要连接的实际组件。正如您所看到的，从声明性编程的角度来看，这可能会用树中不必要的组件污染虚拟DOM。如果您导入到应用程序中的组件是实际的基本组件，而不是通过用更高级的连接组件包装该组件而创建的默认导出，那么这种模式也会产生出错的机会。那么，我们能做得更好吗？</p><p id="4f9b" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">React-redux在它们的库中实现了新的钩子来替换这个连接包装器(如果使用Typescript，请确保安装了7.1.0或更高版本，并且安装的类型声明匹配)。它们是<em class="lg">使用选择器</em>挂钩和<em class="lg">使用分配器</em>挂钩。<em class="lg"> useSelector </em>钩子从总体提供者包装器中提供的存储中返回值。该值将在存储更新时更新，并导致组件重新呈现。<em class="lg"> useDispatch </em>钩子提供了一个分派函数，该函数连接到总体提供者包装器中提供的存储。使用这些挂钩，我们可以简化我们的连接组件，如下所示:</p><figure class="ku kv kw kx gu jp"><div class="bz fq l di"><div class="ky kz l"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk"><strong class="ak">Listing 2</strong> — Simplified component with react-redux hooks.</figcaption></figure><p id="d9a8" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">这段代码的样板文件要少得多，也更容易理解。它消除了导入错误组件的可能性，因为该文件中只有一个可导出的组件。您也不必重新声明选择器和分派函数的类型，因为它们隐含在动作生成器/选择器中。使用钩子还提供了一个额外的好处，即在使用非连接组件，突然需要将它转换成容器时，可以更容易地重构。在这种情况下，你需要做的就是添加你想要的钩子，然后你就自动连接上了。在这种情况下，相比之下，redux工具中的组件树也将更加清晰:</p><figure class="ku kv kw kx gu jp gi gj paragraph-image"><div class="gi gj lh"><img src="../Images/f6a3a484b600183abb058dd916859557.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*vX3U33VNob1NO6pdqEHgIg.png"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk">Figure 2 — Virtual DOM with react-redux hooks.</figcaption></figure><p id="ead0" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">这显然更容易检查。</p><p id="7c05" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">一旦我的团队意识到这些好处，我就更进一步，提出了一种新的设计模式，围绕如何在项目中组织这些react-redux挂钩。使用定制钩子，我们只需编写一次选择器/调度钩子，然后根据需要将它们分解成我们的功能组件。考虑这些在名为user.ts的文件(对应于用户操作文件和用户缩减文件)中创建的定制钩子，并放置在项目的钩子文件夹中:</p><figure class="ku kv kw kx gu jp"><div class="bz fq l di"><div class="ky kz l"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk">Listing 3 — Custom hooks to centralize dispatch and selectors.</figcaption></figure><p id="1cda" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">这些自定义钩子返回包含react-redux钩子的对象。我们可以根据需要将这些定制挂钩分解到我们的连接组件中，这样我们就不必在每个连接组件中重写它们。查看使用这些自定义挂钩重构的组件:</p><figure class="ku kv kw kx gu jp"><div class="bz fq l di"><div class="ky kz l"/></div><figcaption class="la lb gk gi gj lc ld bd b be z dk">Listing 4 — Connected component refactored with custom hooks.</figcaption></figure><p id="ddb7" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">正如您所看到的，这个新的连接组件更简单，更容易转换，更不容易出错，并且选择器和调度器更加模块化。我们只需要在我们的定制钩子中编写一次选择器和调度钩子，然后我们在组件中使用钩子，只析构我们需要的选择器和调度钩子。</p></div><div class="ab cl li lj hs lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ih ii ij ik il"><h1 id="0397" class="lp lq io bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="8d98" class="pw-post-body-paragraph jw jx io jy b jz mn kb kc kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ih bi translated"><strong class="jy ip">高阶连接组件的问题</strong>(包装在react-redux连接函数中的组件):</p><p id="e8c5" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">1)为每个连接的组件不必要地重写接口和映射函数</p><p id="8ffa" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">2)用react工具检查时污染的组件树</p><p id="ed52" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">3)导入连接组件时出错的机会</p><p id="8394" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated">4)将非连接组件重构为连接组件需要大量痛苦的样板代码。</p><p id="90c0" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated"><strong class="jy ip">解决方案</strong>是使用react-redux <em class="lg"> useSelector </em>和<em class="lg"> useDispatch </em>钩子以及自定义钩子。</p><p id="9caf" class="pw-post-body-paragraph jw jx io jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ih bi translated"><em class="lg">更多内容请看</em><a class="ae ms" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jy ip"><em class="lg">plain English . io</em></strong></a></p></div></div>    
</body>
</html>