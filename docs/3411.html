<html>
<head>
<title>Using React Hook Form in component tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在组件测试中使用React钩子形式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-react-hook-form-in-component-tests-497180abf3c0?source=collection_archive---------2-----------------------#2020-09-27">https://javascript.plainenglish.io/using-react-hook-form-in-component-tests-497180abf3c0?source=collection_archive---------2-----------------------#2020-09-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e235fe2a3bcab9178dfb8f36541071da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNxKt-9OmzfjFsPv6LfEKQ.png"/></div></div></figure><p id="c596" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React Hook Form 是一个非常有用的包，可以构建从简单到复杂的web表单。本文展示了我们团队组织和测试嵌套表单组件的方法，使用React Hook表单的<code class="fe ku kv kw kx b">&lt;FormProvider /&gt;</code>和<code class="fe ku kv kw kx b">useFormContext()</code>钩子，然后用<a class="ae kt" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>测试表单组件。</p><h1 id="cced" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">标准反应挂钩形式设置</h1><p id="d5b6" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">当我们的表单很小并且正在原型化时，按照React Hook表单的<a class="ae kt" href="https://react-hook-form.com/get-started" rel="noopener ugc nofollow" target="_blank">文档</a>以标准方式初始化它是合理的。</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="699f" class="mj kz in kx b gy mk ml l mm mn">import React from "react"; <br/>import { useForm } from "react-hook-form";</span><span id="c3fe" class="mj kz in kx b gy mo ml l mm mn">export default function App() { <br/>  const { register, handleSubmit, watch, errors } = useForm();<br/>  const onSubmit = data =&gt; console.log(data);</span><span id="ff8f" class="mj kz in kx b gy mo ml l mm mn">  return (<br/>    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;<br/>      &lt;input name="firstName" defaultValue="Zoe" ref={register} /&gt;<br/>      &lt;input type="submit" /&gt;<br/>    &lt;/form&gt;<br/>  );  <br/>  <br/>}</span></pre><h1 id="7479" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">组织复杂的表单</h1><p id="ed7f" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">随着数据收集应用程序的增长，每个表单中深度嵌套的子组件的数量也会增加。创建嵌套组件对于组织表单内容、重用代码、维护可访问性以及在整个应用程序中加强一致的样式非常有用。</p><p id="8703" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个普通的例子来说明我们的一些表单是如何设置的。我们的存储库应用程序包含有30-50个元素的元数据表单，从简单的输入，到提前输入下拉列表，到字段数组(多值)输入，等等。</p><p id="ea94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们把复杂的、单一的形式分成几个部分。</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="34de" class="mj kz in kx b gy mk ml l mm mn">// The form<br/>&lt;form onSubmit={handleSubmit(onSubmit)}&gt;</span><span id="bec4" class="mj kz in kx b gy mo ml l mm mn">  {/* Won't repeat, but initially we explicitly drilled React Hook Form props down to any and all child components which may need them.  Not good:) */}<br/>  &lt;CoreMetadata register={register} errors={errors} {...etc} /&gt;<br/>  <br/>  &lt;ControlledTerms /&gt;<br/>  &lt;DescriptiveMetadata /&gt;<br/>  ...<br/>  &lt;input type="submit" /&gt;<br/>&lt;/form&gt;</span></pre><p id="599b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">截面组件:</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="bcc6" class="mj kz in kx b gy mk ml l mm mn">// CoreMetadata.js<br/>...<br/>return (<br/>  &lt;&gt;<br/>   &lt;SubCategory1 register={register} errors={errors} {...etc} /&gt;<br/>   &lt;SubCategory2 /&gt;<br/>   &lt;SubCategory3 /&gt;<br/>  &lt;/&gt;<br/>);</span></pre><p id="ca03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嵌套组件:</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="4c3f" class="mj kz in kx b gy mk ml l mm mn">// SubCategory1.js<br/>...<br/>return(<br/>  &lt;&gt;  <br/>    &lt;UIFormInput name="yo" required register={register} errors={errors} /&gt;<br/>    &lt;UIFormSelect name="bigList" options={listOfOptions} required /&gt;<br/>  <br/>    {/* Maybe some element goes here which dynamically renders depending on form values or state of the form? */}<br/>  &lt;/&gt;<br/>);</span></pre><p id="e8cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后是一个“叶级”子组件，我们将React Hook Form连接到Form元素。</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="e3e7" class="mj kz in kx b gy mk ml l mm mn">// UIFormInput.js<br/><br/>function UIFormInput({name, type, register, errors}) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;input <br/>        name={name} <br/>        type={type} <br/>        ref={register &amp;&amp; register({ required })} <br/>        className={`input ${errors[name] ? "is-danger" : ""}`<br/>        {...passedInProps} <br/>      /&gt;</span><span id="dd6b" class="mj kz in kx b gy mo ml l mm mn">{errors[name] &amp;&amp; (<br/>        &lt;p data-testid="input-errors" className="help is-danger"&gt;<br/>          {label || name} field is required<br/>        &lt;/p&gt;<br/>      )}<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="9afd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初的向下钻取模式将钩子形式的方法作为<code class="fe ku kv kw kx b">props</code>反应到组件堆栈中的每个子组件，这种模式被一遍又一遍地复制，我们复制了这种低效的模式，因为它工作得很好，但感觉不太好。</p><h1 id="f443" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用FormContext进行救援</h1><p id="988e" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">最近，我们将React Hook表单实现和子组件转换为使用<a class="ae kt" href="https://react-hook-form.com/api#useFormContext" rel="noopener ugc nofollow" target="_blank"> useFormContext </a>。由于我们倾向于使用自己的组件库并寻找一致的解决方案，现在我们用上下文来设置表单:</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="5fd2" class="mj kz in kx b gy mk ml l mm mn">// Updated Form<br/>import React from "react"; <br/>import { useForm, FormProvider } from "react-hook-form";</span><span id="1fab" class="mj kz in kx b gy mo ml l mm mn">export default function App() { <br/>  const methods = useForm();<br/>  const onSubmit = data =&gt; console.log(data);</span><span id="f2da" class="mj kz in kx b gy mo ml l mm mn">return(<br/>    &lt;FormProvider {...methods}&gt;<br/>      &lt;form onSubmit={handleSubmit(onSubmit)}&gt;<br/>        &lt;CoreMetadata {...PASS_WHATEVER_PROPS_HERE} /&gt;<br/>        &lt;ControlledTerms /&gt;<br/>        &lt;DescriptiveMetadata /&gt;<br/>      &lt;/form&gt;<br/>    &lt;/FormProvider&gt;<br/>  );  <br/>  <br/>}</span></pre><p id="3a32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法遵循React上下文/提供者模式，如果需要，祖先树中的任何子组件都可以从上下文中获取React钩子。不在乎<code class="fe ku kv kw kx b">register</code>或者<code class="fe ku kv kw kx b">error</code>的中级组件被解放出来，从行李道具中解放出来。</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="4609" class="mj kz in kx b gy mk ml l mm mn">import React from "react";<br/>import { useFormContext } from "react-hook-form";</span><span id="4bda" class="mj kz in kx b gy mo ml l mm mn">const UIFormInput = ({ name, required, ...passedInProps}) =&gt; { <br/>  // All these values are from the component's parent &lt;form /&gt;<br/>  const { control, errors, register } = useFormContext();</span><span id="4d32" class="mj kz in kx b gy mo ml l mm mn">  return (<br/>    &lt;&gt;<br/>      &lt;input <br/>        name={name} <br/>        ref={register({ required })} <br/>        className={`input ${errors[name] ? "is-danger" : ""}`<br/>        {...passedInProps} <br/>      /&gt;</span><span id="6e85" class="mj kz in kx b gy mo ml l mm mn">      {errors[name] &amp;&amp; (<br/>        &lt;p data-testid="input-errors" className="help is-danger"&gt;<br/>          {label || name} field is required<br/>        &lt;/p&gt;<br/>      )}<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="f5ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，如果您的应用程序中有多个表单呢？使用React Hook表单上下文，无论组件位于哪个表单中，都是组件通过钩子接收的表单数据。这也通过将任何想要的上下文形式传递到每个测试中，设置了更容易测试的组件。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="d348" class="ky kz in bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv bi translated">测试</h1><p id="546a" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">好了，现在我们组件中的代码少多了。<a class="ae kt" href="https://github.com/nulib/meadow/pull/1239/files" rel="noopener ugc nofollow" target="_blank">看看这个PR </a>。哇，好多了。让我们继续用<a class="ae kt" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>测试React Hook Form <code class="fe ku kv kw kx b">useContext()</code>组件。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0278" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个<code class="fe ku kv kw kx b">renderWithReactHookForm</code>助手函数的行为与其他测试库方法的行为相同，通过返回测试库的<code class="fe ku kv kw kx b">render()</code>函数将返回的内容。例如<a class="ae kt" href="https://testing-library.com/docs/example-react-router" rel="noopener ugc nofollow" target="_blank">这是测试库用React路由器包装的方法。</a></p><p id="c4e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe ku kv kw kx b">renderWithReactHookForm</code>的样本测试可能看起来像:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="823b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的测试中，我们用React Hook表单的<code class="fe ku kv kw kx b">&lt;FormProvider /&gt;</code>包装了正在测试的组件，并且可以用一些默认值初始化表单。</p><p id="1638" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么这会有帮助？</p><p id="3854" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">使用默认值渲染</strong></p><p id="6657" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您有一个收集值列表的表单，但是有起始值。(我们也有相当数量的复杂表单实现，它们利用了React Hook表单的<a class="ae kt" href="https://react-hook-form.com/api#useFieldArray" rel="noopener ugc nofollow" target="_blank"> useFieldArray钩子</a>)。</p><p id="0bc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，表单数据可能如下所示:</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="ced3" class="mj kz in kx b gy mk ml l mm mn">// Super simplified example HTML<br/>&lt;input name="multiValueField[0].url" /&gt;<br/>&lt;select name="multiValueField[0].category&gt;<br/>  ...<br/>&lt;/select&gt;<br/></span><span id="4b04" class="mj kz in kx b gy mo ml l mm mn">// How React Hook Form keeps track of the form data<br/>multiValueField[0].url<br/>multiValueField[0].category<br/>multiValueField[1].url<br/>multiValueField[1].category</span><span id="82e7" class="mj kz in kx b gy mo ml l mm mn">...and so forth</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/55131d741affcf88b9a5cac68e04cbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRdNdWVV81gUhYGTid8W8Q.png"/></div></div></figure><p id="4c6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ku kv kw kx b">&lt;UIFormRelatedURL /&gt;</code>表单组件显示从API获取的现有值的列表，用户可以删除这些值。用户还可以随意添加任意多的附加值。在测试中，我们将默认值注入React Hook形式，与代码实际做的一样。因此我们可以测试我们的组件实际上显示了正确的起始值。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="c79b" class="ky kz in bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv bi translated">与其他供应商联合</h1><p id="432a" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">假设您在应用程序中使用其他工具，如GraphQL w/ Apollo Client或React Router，您的应用程序如下所示:</p><pre class="mb mc md me gt mf kx mg mh aw mi bi"><span id="959a" class="mj kz in kx b gy mk ml l mm mn">...</span><span id="da26" class="mj kz in kx b gy mo ml l mm mn">export default class Root extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;ReactiveBase<br/>        app={ELASTICSEARCH_INDEX_NAME}<br/>        url={ELASTICSEARCH_PROXY_ENDPOINT}<br/>      &gt;<br/>        &lt;AuthProvider&gt;<br/>          &lt;BatchProvider&gt;<br/>            &lt;BrowserRouter&gt;<br/>              &lt;Switch&gt;<br/>                &lt;Route exact path="/login" component={Login} /&gt;    <br/>                &lt;PrivateRoute exact path="/project/list" component={ScreensProjectList}<br/>                /&gt;<br/>                ...</span></pre><p id="5fa1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在测试一个被其他测试提供商包装的组件，比如Apollo Client，React Router，ElasticSearch等等。我们可以将<code class="fe ku kv kw kx b">renderWithReactHookForm</code>模式重新定位为一个更高阶的组件，它返回一个常规的<code class="fe ku kv kw kx b">Component</code>而不是React测试库的<code class="fe ku kv kw kx b">render()</code>函数。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1536" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将如下使用它:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><h1 id="0940" class="ky kz in bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv bi translated">延伸<code class="fe ku kv kw kx b">renderWithReactHookForm()</code></h1><p id="d53e" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">既然我们可以在测试组件时设置单独的表单上下文，我们也可以扩展<code class="fe ku kv kw kx b">renderWithReactHookForm</code>来测试组件如何响应特定的表单上下文值，而无需提交表单，这在测试不呈现<code class="fe ku kv kw kx b">&lt;form /&gt;</code>元素或<code class="fe ku kv kw kx b">submit</code>按钮的深度嵌套组件时是不可能的。</p><p id="45f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:我不是100%确定这是一个好主意或模式，但是它允许你至少测试嵌套组件表单验证以及UI应该如何响应错误的表单数据。也许你可以把这个想法提炼出来，用于你的用例，或者以某种方式让它变得更好…只是实验。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第18行，你会注意到<code class="fe ku kv kw kx b">toPassBack</code>，这是一个React钩子形式方法的数组，例如<code class="fe ku kv kw kx b">setError</code>。</p><p id="38fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第24–26行，我们将方法添加到我们的辅助对象<code class="fe ku kv kw kx b">reactHookFormMethods</code>。</p><p id="aa29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后在第32行，我们包含了一个额外的对象，<code class="fe ku kv kw kx b">reactHookFormMethods</code>，它被添加到测试库的<code class="fe ku kv kw kx b">render()</code>函数返回的内容中(与<code class="fe ku kv kw kx b">getByTestId</code>等方法一起)。</p><p id="3526" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个大概的例子来说明如何使用它:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="6bb5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="b308" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">也许您会发现这个帮助器包装函数在某种程度上很有帮助。<a class="ae kt" href="https://react-hook-form.com/" rel="noopener ugc nofollow" target="_blank"> React Hook Form </a>和<a class="ae kt" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank"> Testing Library </a>是顶级React包，开发人员在其上构建了许多东西，因此很高兴看到如何使测试更容易。任何想法/评论/意见都非常欢迎。</p><p id="4cb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想在开源的Elixir/React应用程序环境中查看示例代码，这里有一个Github repo的链接:</p><div class="nf ng gp gr nh ni"><a href="https://github.com/nulib/meadow" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd io gy z fp nn fr fs no fu fw im bi translated">努里布/梅多</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">安装Erlang和Elixir Install Node.js(可以使用nvm (brew install nvm)或asdf安装Node)安装libffi…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jt ni"/></div></div></a></div><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk"><a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>