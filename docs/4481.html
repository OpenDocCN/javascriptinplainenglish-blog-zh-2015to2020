<html>
<head>
<title>Let’s Create A Nest, Nx, GraphQL, Prisma Single Data Model Definition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们创建一个Nest，Nx，GraphQL，Prisma单数据模型定义</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nx-nest-prisma-graphql-single-data-model-definition-e601eaa372c6?source=collection_archive---------3-----------------------#2020-12-15">https://javascript.plainenglish.io/nx-nest-prisma-graphql-single-data-model-definition-e601eaa372c6?source=collection_archive---------3-----------------------#2020-12-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c926" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个框架和库似乎都有自己的数据模型SDL格式。这在最好的情况下会导致模型定义的重复，在最坏的情况下会导致完全的混乱。</p><p id="9748" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文详细介绍了一种方法，当您的库和应用程序都需要跨业务领域共享数据模型时，这种方法非常简单和有用。</p><p id="6b16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所选的DMF(数据模型格式)是Prisma的模式，我将从该模式向您展示它如何管理您的SQL DB模型、API服务器和React客户端数据模型，以及如何将模型绑定到生成的GraphQL服务，并对暴露的模型属性进行应用程序级控制。听起来比实际更复杂。</p><p id="ad5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">陈述完毕，让我们开始吧！</p><h2 id="5c8e" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">第一部分。我们在做什么</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/7de453a1fc8c05866ed88166edc8f9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWu-QWNucv0w9sXw5HYH1w.png"/></div></div></figure><p id="9d8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了再次说明我们的目标，我们要做的是设置我们的项目工作区，这样我们就有了一个保存数据模型的单个节点库，任何导入该数据模型库的应用程序都可以快速、轻松地设置和公开GraphQL api端点以及它选择管理的模型部分。人们希望对数据模型有一个单一的定义，并让所有的“实现系统”都使用这个单一的模型定义。这将允许我们避免数据模型定义重复，并简化我们数据管理的某些方面。</p><p id="1d5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使这成为一个完整的例子，我将详细介绍一些Nx工作空间的基本设置(不全面)。<a class="ae ln" href="https://nx.dev/" rel="noopener ugc nofollow" target="_blank">在这里阅读Nx</a>。对于这个示例设置，我们将使用一个<a class="ae ln" href="https://www.npmjs.com/package/sqlite" rel="noopener ugc nofollow" target="_blank"> sqlite3数据库</a>，但是在生产中，您可能想要使用postgres或类似的数据库。此外，请注意，我们将在本例中使用的数据模型是一个从<a class="ae ln" href="https://www.prisma.io/docs/concepts/components/prisma-schema#example" rel="noopener ugc nofollow" target="_blank"> Prisma示例模式</a>中借用的最小模型，稍加修改即可在Sqlite上运行(删除了Role的enum)。</p><h2 id="6e36" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">第二部分。设置工作空间</strong></h2><p id="e731" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">第一步是设置我们的目录，创建工作空间，生成框架应用程序和库，然后安装所需的npm模块。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="a4b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">至此，我们已经有了一个工作区设置的框架。我们需要向我们的工作区添加一些任务，以简化我们的数据模型迁移步骤。现在让我们开始吧——在项目目录中打开名为workspace.json的文件</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2b14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看上面的第85-125行。我添加了这些任务来完成Prisma迁移。这是一个预览功能(之前——就像上周写这篇文章时——它还处于试验阶段，所以很可能在不久的将来它会成为一个完整的功能)。</p><p id="c073" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，正如我提到的，对于这个示例项目，我们将使用sqlite —您应该打开文件<em class="lv">&lt;project-root&gt;/libs/data-model/prisma/schema . prisma</em></p><p id="c6c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我的文件的样子:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="e739" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这个文件和对我们的workspace.json所做的修改，现在你需要做的就是修改<project-root> /libs/data-mode/。env文件具有以下内容，这将告诉我们的Prisma模式它所使用的环境变量的值应该是什么:</project-root></p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="4829" class="ki kj in lx b gy mb mc l md me">DATABASE_URL="file:./dev.db"</span></pre><p id="e20e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，从项目根目录运行以下命令:</p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="aca2" class="ki kj in lx b gy mb mc l md me">nx run data-model:migrate-up</span></pre><p id="306f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您执行此任务时，您应该会看到如下内容:</p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="4680" class="ki kj in lx b gy mb mc l md me">&gt; nx run data-model:migrate-up <br/>Environment variables loaded from .env<br/>Prisma schema loaded from prisma/schema.prisma<br/>Datasource "db": SQLite database "dev.db" at "file:./dev.db"</span><span id="2108" class="ki kj in lx b gy mf mc l md me">SQLite database dev.db created at file:./dev.db</span><span id="78b8" class="ki kj in lx b gy mf mc l md me">The following migration(s) have been created and applied from new schema changes:</span><span id="3066" class="ki kj in lx b gy mf mc l md me">migrations/<br/>  └─ 20201214205941_/<br/>    └─ migration.sql</span><span id="5953" class="ki kj in lx b gy mf mc l md me">✔ Generated Prisma Client (2.13.0) to ./../../node_modules/@prisma/client in 97ms</span></pre><p id="4617" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以通过运行以下命令来检查其状态:</p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="f846" class="ki kj in lx b gy mb mc l md me">&gt; nx run data-model:migrate-status <br/>Environment variables loaded from .env<br/>Prisma schema loaded from prisma/schema.prisma<br/>Datasource "db": SQLite database "dev.db" at "file:./dev.db"</span><span id="abd8" class="ki kj in lx b gy mf mc l md me">Status<br/>1 migration found in prisma/migrations</span><span id="cf55" class="ki kj in lx b gy mf mc l md me">Database schema is up to date!</span></pre><p id="c25a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时，您可能倾向于编写一个小脚本来播种您的数据库，这样做是正确的，但是在我们的示例中，我们将跳过这一步，设置一个GraphQL变体，这样我们就可以使用api插入和读取数据。这是我们到目前为止已经设置好的部分:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/5bd5ca28b5d99f9554aab844b723c859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEH_vw1VEBTC_OuCT17KMg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">What we have setup so far in our example workspace</figcaption></figure><p id="f77e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我的工作空间在目录和文件方面的样子:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/30be70885ff57b6cd16d1b3e9b83e340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*IO5fiddz-poGEPDbsowqKA.png"/></div></figure><p id="f4a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第三部分。连接我们的Prisma模式并公开一个GraphQL API </strong></p><p id="dff1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是我们例子的核心部分——设置从Prisma模式和客户机自动生成丰富的GraphQL api。对于这个例子，我使用的是NestJS(尽管您可以使用另一个框架或者简单地使用您自己的方法——milage可能会有所不同)。还记得我们第一次设置项目工作环境时创建的应用程序吗？对，那个叫“我的api”的应用。</p><p id="c566" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在开始编写代码之前，我们应该安装一些额外的库:</p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="bd19" class="ki kj in lx b gy mb mc l md me">npm i @nestjs/graphql @nexus/schema@0.19.2 graphql-scalars apollo-server-express --save</span></pre><p id="05a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快速补充说明—如果您在任何时候看到一个关于类型不匹配的错误，如下所示:</p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="95d5" class="ki kj in lx b gy mb mc l md me">The types of 'config.fieldDefTypes' are incompatible between these types.</span></pre><p id="a1bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着你可能有一个不兼容的(或损坏的)版本的nexus插件prisma node nodule。在这个例子中，我使用了:</p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="5fd3" class="ki kj in lx b gy mb mc l md me">"nexus-plugin-prisma": "^0.26.0"</span><span id="d677" class="ki kj in lx b gy mf mc l md me">and</span><span id="6028" class="ki kj in lx b gy mf mc l md me">"@nexus/schema": "^0.19.2"</span></pre><p id="670d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原来0.27.0此刻坏了。你要知道。</p><p id="575e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，现在让我们来做有趣的部分，写一些实际的代码。打开<em class="lv"> &lt;项目根目录&gt; /apps/my-api/src/app </em>目录下的<em class="lv"> app.module.ts </em>文件。更改文件，使其看起来像:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="5f54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">app模块从nestjs导入GraphQL库，并定义graphql api的配置(模式、类型和解析器)来自GraphqlConfigService类。这个服务类是我们接下来要创建的。</p><p id="77b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在同一个目录中创建一个名为gql.config.ts的新文件，神奇的事情就发生在这个文件中。下面是您应该在源文件中放置的内容:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="1a77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在这里发生了很多事情。TL；DR；总结一下，这个类基于生成的prisma客户机中的可用内容为GraphQL api定义了一个可注入的配置，prisma客户机是在我们从模式中“构建”数据模型时创建的。</p><p id="7594" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先要注意的是，我们使用nexus/schema模块根据我们提供的config对象创建一个模式。配置对象包括插件nexus-plugin-prisma(见第32行)。我们将一个配置传递给插件，告诉它生成crud操作——这些操作来自基于schema.prisma的生成的Prisma客户机代码，我们在前面的库中设置了这些代码。</p><p id="21d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二件值得注意的事情是，我们定义了应用程序将使用的类型(第36–78行),以及我们希望应用程序公开的一组查询和变化。这是分离关注点的一个很好的方法，虽然数据模型模式中有轻微的重复，但这是可以原谅的，因为它能够选择性地选择graphql api将从模型定义中公开什么。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/4c8188101a1b0ec29da626ec06adbd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2efo7QzkifXL2iy2A-TqA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">This is the section we just completed</figcaption></figure><p id="840b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在准备使用刚刚设置的GraphQL API插入数据。让我们启动服务器并插入我们的第一个用户。</p><pre class="lc ld le lf gt lw lx ly lz aw ma bi"><span id="802a" class="ki kj in lx b gy mb mc l md me">nx serve my-api</span></pre><p id="ab06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您应该会在控制台中看到一些输出，告诉您服务器正在监听h<a class="ae ln" href="http://localhost:3333/api" rel="noopener ugc nofollow" target="_blank">TTP://localhost:3333/API</a>—打开浏览器并转到<a class="ae ln" href="http://localhost/graphql" rel="noopener ugc nofollow" target="_blank"> http://localhost/graphql </a>，您将看到graphql playground。让我们创建一个新用户:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ml"><img src="../Images/498d63b27787b8931679194c4ebe1f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dlle6lunZOUgZAZW1934bw.png"/></div></div></figure><p id="320d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经创建了一些用户，我们也可以查询他们</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mm"><img src="../Images/131ef2793d1a712f8b85ed4e28cfe672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVEnrqwQ_QYSlkBlMS32Yw.png"/></div></div></figure><p id="8f56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以将db换成postgres或MySQL db(可能使用docker容器或其他服务提供商)。您只受到Prisma所支持的内容的限制，即使这样，也没有什么可以阻止您为当前不支持的数据库创建适配器(也许是大查询？还是弹性的？)</p><p id="a774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这方面做很多事情——虽然我想在这里更深入，但这篇文章已经很长了。我必须停止写更多，并相信我们所涵盖的内容是有意义的(为它鼓掌，或者留下评论，如果这对你有用的话)。</p><p id="36b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，你将何去何从？尝试这些资源:</p><ul class=""><li id="e7d2" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">【https://www.prisma.io/ T4】</li><li id="921e" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><a class="ae ln" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/</a></li><li id="b6f8" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><a class="ae ln" href="https://github.com/graphql-nexus/nexus-plugin-prisma" rel="noopener ugc nofollow" target="_blank">https://github.com/graphql-nexus/nexus-plugin-prisma</a></li><li id="61a9" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><a class="ae ln" href="https://github.com/graphql-nexus/nexus" rel="noopener ugc nofollow" target="_blank">https://github.com/graphql-nexus/nexus</a></li><li id="a5c0" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><a class="ae ln" href="https://nx.dev/" rel="noopener ugc nofollow" target="_blank">https://nx.dev/</a></li><li id="2763" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><a class="ae ln" href="https://rollout.io/blog/database-migration/" rel="noopener ugc nofollow" target="_blank">https://rollout.io/blog/database-migration/</a></li><li id="3028" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated"><a class="ae ln" href="https://medium.com/dooboolab/why-our-team-chose-prisma2-nexus-schema-for-graphql-apollo-server-40ed42a26c37" rel="noopener">https://medium . com/dooboolab/why-our-team-choose-prisma 2-nexus-schema-for-graph QL-Apollo-server-40 ed 42 a 26 c 37</a></li><li id="af2e" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">NestJS Discord:<a class="ae ln" href="https://discord.com/channels/520622812742811698/527853342152458287" rel="noopener ugc nofollow" target="_blank">https://Discord . com/channels/520622812742811698/527853342152458287</a></li></ul></div></div>    
</body>
</html>