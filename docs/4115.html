<html>
<head>
<title>The State of State Management in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的状态管理状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-state-of-state-management-in-react-9d4909124c15?source=collection_archive---------7-----------------------#2020-11-17">https://javascript.plainenglish.io/the-state-of-state-management-in-react-9d4909124c15?source=collection_archive---------7-----------------------#2020-11-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/13f4d482aa2e21c9e2884d25755373d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QO9AAtrGQp-_luEG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0fe8" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="84a3" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如今，随着React挂钩的引入，状态管理变得更加简单，改变了开发人员在他们的React组件中管理状态的方式。</p><p id="2a8d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">以前，为特定组件定义状态很复杂(我将在下面讨论)，但是现在，创建一个像useUserLogin这样的抽象钩子来跨组件共享状态逻辑就很容易了。</p><p id="6d8c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们将在hooks之前和使用hooks的时候看一下状态管理，为什么你可能想要使用状态管理库，以及今天一些常见的状态管理库。</p><h1 id="8bb0" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在反应钩子之前</h1><p id="c680" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在React hooks之前，状态管理是相当二进制的。有两种选择:在组件中定义局部状态，或者使用状态管理框架来处理全局状态。</p><h2 id="9a32" class="mb kb in bd kc mc md dn kg me mf dp kk lj mg mh ko ln mi mj ks lr mk ml kw mm bi translated">本地状态(挂钩前)</h2><p id="4b8f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">让我们看看钩子之前的本地状态。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="41ff" class="mb kb in ms b gy mw mx l my mz">export class TodoList extends Component {<br/>    state = {<br/>        isLoading: false,<br/>        hasError: false,<br/>        todos: []<br/>    }<br/><br/>    searchTodos(searchValue) {<br/>        this.setState({isLoading: true});<br/><br/>        api.get(`/todos?searchKey=${searchValue}`)<br/>            .then((data) =&gt; this.setState({todos: data}))<br/>            .catch(() =&gt; this.setState({hasError: true}))<br/>            .finally(() =&gt; this.setState({loading: false}));<br/>    }<br/><br/>    render() {<br/>        if (this.state.isLoading) {<br/>            // render loading spinner<br/>        }<br/>        <br/>        if (this.state.hasError) {<br/>            // render error message<br/>        }<br/><br/>        return (<br/>            &lt;div&gt;<br/>                &lt;input onChange={(event) =&gt; searchTodos(event.target.value)} /&gt;<br/>            &lt;/div&gt;<br/>        )<br/>       <br/>    }<br/>}</span></pre><p id="ee82" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这种情况下，我们可以通过<code class="fe na nb nc ms b">this.setState</code>属性非常有效地处理本地状态。</p><p id="4586" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然而，假设您不希望state上的<code class="fe na nb nc ms b">loading</code>属性被约束到这个组件。现在，您必须引入一个像Redux这样的库来处理跨各种组件的全局状态。</p><p id="8715" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在这种方法可行了，但是这种方法有几个问题:</p><ol class=""><li id="5dd2" class="nd ne in la b lb lw lf lx lj nf ln ng lr nh lv ni nj nk nl bi translated">更多样板代码</li><li id="8889" class="nd ne in la b lb nm lf nn lj no ln np lr nq lv ni nj nk nl bi translated">复杂/错综复杂的流程</li><li id="ffa1" class="nd ne in la b lb nm lf nn lj no ln np lr nq lv ni nj nk nl bi translated">全球状态无处不在，可能会产生奇怪的副作用</li></ol><p id="e3db" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果您是一名在React hooks之前从事代码库工作的开发人员，您应该知道Redux和全局状态在大型应用程序中会变得多么复杂，导致大量样板代码，使您的项目更难调试。</p><h1 id="1730" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">反应钩</h1><p id="4c3e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在React 16.8中引入了钩子。现在，在组件之间共享状态行为变得容易多了，让我们看看如何在上面的组件中实现钩子:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4110" class="mb kb in ms b gy mw mx l my mz">import {useState} from 'react';<br/><br/>const useRequestHandler = () =&gt; {<br/>    const [isLoading, setLoading] = useState(false);<br/>    const [hasError, setError] = useState(false);<br/>    const [data, setData] = useState(null);<br/><br/>    const handleRequest = (request) =&gt; {<br/>        setLoading(true);<br/>        setError(false);<br/><br/>        return api.get(request)<br/>            .then(setData)<br/>            .catch(() =&gt; setError(true))<br/>            .finally(() =&gt; setLoading(false))<br/>    };<br/><br/>    return {isLoading, hasError, data, handleRequest};<br/>};<br/><br/><br/>const UserList = () =&gt; {<br/>    const {data, isLoading, hasError, handleRequest} = useRequestHandler();<br/>    <br/>    const searchUsers = (value) =&gt; handleRequest(`/todos?searchKey=${value}`);<br/>  <br/>    return (<br/>        &lt;React.Fragment&gt;<br/>            {data.map(u =&gt; &lt;p&gt;{u.name}&lt;/p&gt;)}<br/>        &lt;/React.Fragment&gt;<br/>    )</span></pre><p id="bd32" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，加载和获取数据行为被抽象出来，允许您在应用程序中重用该功能。</p><p id="c5af" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然而，我们仍然有一个问题。将状态保存在钩子中并不意味着它成为一个单体，状态只绑定到一个组件。在某些情况下，我们可能只想保存一个状态实例(例如，只获取一次用户信息)。这就是状态管理框架证明其价值的地方。</p><h1 id="c855" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">如何决定状态保存在哪里</h1><p id="5545" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">既然可以跨组件共享状态逻辑，那么我们如何决定是将状态保存在组件中(本地)还是全局呢？这取决于您是否希望在组件之间共享状态，比如跨多个组件本地跟踪用户的待办事项。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/7ca36afe1772b74a340d92f8085d104b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m6-9Ex3ZogNcXI5-"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2089" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">全球国家管理框架</h1><p id="976a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">虽然我不会对这些框架进行全面的深入研究，但我会链接每个框架的网站。</p><ol class=""><li id="1023" class="nd ne in la b lb lw lf lx lj nf ln ng lr nh lv ni nj nk nl bi translated"><a class="ae jz" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> React-Redux </a></li><li id="e38c" class="nd ne in la b lb nm lf nn lj no ln np lr nq lv ni nj nk nl bi translated"><a class="ae jz" href="https://github.com/mobxjs/mobx-react" rel="noopener ugc nofollow" target="_blank"> Mobx </a></li><li id="9b44" class="nd ne in la b lb nm lf nn lj no ln np lr nq lv ni nj nk nl bi translated"><a class="ae jz" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank">通量</a></li><li id="b0c2" class="nd ne in la b lb nm lf nn lj no ln np lr nq lv ni nj nk nl bi translated"><a class="ae jz" href="https://github.com/jamiebuilds/unstated" rel="noopener ugc nofollow" target="_blank">未说明</a></li><li id="6290" class="nd ne in la b lb nm lf nn lj no ln np lr nq lv ni nj nk nl bi translated"><a class="ae jz" href="https://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a></li></ol><h1 id="ca64" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="98f0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">尽管React挂钩改变了React开发人员处理状态的方式，但它们并不是灵丹妙药。这并不意味着我们需要全局地保留每个状态——大多数情况下，最好将其保留在组件级别，但是有大量的解决方案可以使管理全局状态变得更容易。</p><h1 id="6959" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">保持联络</h1><p id="25dd" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">有很多内容，我很感谢你读我的。我是一名年轻的企业家，我写的是软件开发以及我经营和发展公司的经历。你可以在这里注册我的简讯<a class="ae jz" href="https://newsletter.cometcode.io/" rel="noopener ugc nofollow" target="_blank"/></p><p id="5a07" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">请随时联系我，在Linkedin或Twitter上与我联系。</p></div></div>    
</body>
</html>