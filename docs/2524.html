<html>
<head>
<title>The Differences Between Arrow and Regular Functions You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Arrow和常规函数的区别你应该知道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-differences-between-arrow-and-regular-functions-you-should-know-401c4bf22ad3?source=collection_archive---------5-----------------------#2020-07-02">https://javascript.plainenglish.io/the-differences-between-arrow-and-regular-functions-you-should-know-401c4bf22ad3?source=collection_archive---------5-----------------------#2020-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8dfe" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">它们都很有用，但不要混淆</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/46c8f6fc069050ce2fc5e98b68ef279e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xsl5pg7A7jVHZcUm"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shahadat Rahman</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="15f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在JavaScript中，可以用多种方式定义函数。</p><p id="0587" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一种通常的方法是使用<code class="fe lp lq lr ls b">function</code>关键字:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="4588" class="lx ly in ls b gy lz ma l mb mc">// Function declaration<br/>function greet(who) {<br/>  return `Hello, ${who}!`;<br/>}</span><span id="da75" class="lx ly in ls b gy md ma l mb mc">// Function expression<br/>const greet = function(who) {<br/>  return `Hello, ${who}`;<br/>}</span></pre><p id="d51a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我要引用的函数声明和函数表达式是一个常规函数。</p><p id="85c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二种方法，从ES2015开始可用，是<em class="me">箭头函数</em>语法:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="926c" class="lx ly in ls b gy lz ma l mb mc">const greet = (who) =&gt; {<br/>  return `Hello, ${who}!`;<br/>}</span></pre><p id="bdb1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然常规语法和箭头语法都定义函数，但是什么时候你会选择一个而不是另一个呢？这个问题问得好。</p><p id="70ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这篇文章中，我将展示两者之间的主要区别，这样你就可以根据自己的需要选择正确的语法。</p><h1 id="12b9" class="mf ly in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">1.这个值</h1><h2 id="a972" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">1.1常规功能</h2><p id="6ea4" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">在常规JavaScript函数内部，<code class="fe lp lq lr ls b">this</code>值(也称为执行上下文)是动态的。</p><p id="84f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">动态上下文意味着<code class="fe lp lq lr ls b">this</code>的值取决于函数是如何被调用的。在JavaScript中，有4种方法可以调用常规函数。</p><p id="83c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在一个<em class="me">简单调用</em>期间，<code class="fe lp lq lr ls b">this</code>的值等于全局对象(或者如果函数在严格模式下运行，则等于<code class="fe lp lq lr ls b">undefined</code>):</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="0ac6" class="lx ly in ls b gy lz ma l mb mc">function myFunction() {<br/>  console.log(this);<br/>}</span><span id="d00d" class="lx ly in ls b gy md ma l mb mc">// Simple invocation<br/>myFunction(); // logs global object (window)</span></pre><p id="ff45" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<em class="me">方法调用</em>期间，<code class="fe lp lq lr ls b">this</code>的值是拥有该方法的对象:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="42e1" class="lx ly in ls b gy lz ma l mb mc">const myObject = {<br/>  method() {<br/>    console.log(this);<br/>  }<br/>};<br/>// Method invocation<br/>myObject.method(); // logs myObject</span></pre><p id="210f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在使用<code class="fe lp lq lr ls b">myFunc.call(thisVal, arg1, ..., argN)</code>或<code class="fe lp lq lr ls b">myFunc.apply(thisVal, [arg1, ..., argN])</code>的<em class="me">间接调用</em>期间，<code class="fe lp lq lr ls b">this</code>的值等于第一个参数:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="2abf" class="lx ly in ls b gy lz ma l mb mc">function myFunction() {<br/>  console.log(this);<br/>}</span><span id="35af" class="lx ly in ls b gy md ma l mb mc">const myContext = { value: 'A' };</span><span id="92d1" class="lx ly in ls b gy md ma l mb mc">myFunction.call(myContext);  // logs { value: 'A' }<br/>myFunction.apply(myContext); // logs { value: 'A' }</span></pre><p id="aa4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在使用<code class="fe lp lq lr ls b">new</code>关键字<code class="fe lp lq lr ls b">this</code>的<em class="me">构造函数调用</em>期间，等于新创建的实例:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="4efc" class="lx ly in ls b gy lz ma l mb mc">function MyFunction() {<br/>  console.log(this);<br/>}</span><span id="776a" class="lx ly in ls b gy md ma l mb mc">new MyFunction(); // logs an instance of MyFunction</span></pre><h2 id="5e0e" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">1.2箭头功能</h2><p id="cceb" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">箭头函数内部的<code class="fe lp lq lr ls b">this</code>行为与常规函数的<code class="fe lp lq lr ls b">this</code>行为有很大不同。</p><p id="89ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无论在何处或以何种方式执行，箭头函数内的<code class="fe lp lq lr ls b">this</code>值总是等于外部函数的<code class="fe lp lq lr ls b">this</code>值。换句话说，arrow函数在词汇上解析<code class="fe lp lq lr ls b">this</code>。换句话说，arrow函数没有定义自己的执行上下文。</p><p id="f0d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在下面的例子中，<code class="fe lp lq lr ls b">myMethod()</code>是<code class="fe lp lq lr ls b">callback()</code>箭头函数的外部函数:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="c67b" class="lx ly in ls b gy lz ma l mb mc">const myObject = {<br/>  myMethod(items) {<br/>    console.log(this); // logs myObject    const callback = () =&gt; {<br/>      console.log(this); // logs myObject    };<br/>    items.forEach(callback);<br/>  }<br/>};</span><span id="5b10" class="lx ly in ls b gy md ma l mb mc">myObject.myMethod([1, 2, 3]);</span></pre><p id="d3b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">this</code>箭头函数<code class="fe lp lq lr ls b">callback()</code>内的值等于外部函数<code class="fe lp lq lr ls b">myMethod()</code>的<code class="fe lp lq lr ls b">this</code>。</p><p id="a79a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">按词法解析是arrow函数的一大特点。当在方法内部使用回调时，你可以确定arrow函数没有定义自己的<code class="fe lp lq lr ls b">this</code>:没有更多的<code class="fe lp lq lr ls b">const self = this</code>或<code class="fe lp lq lr ls b">callback.bind(this)</code>变通方法。</p><p id="fe44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">与常规函数相反，使用<code class="fe lp lq lr ls b">myArrowFunc.call(thisVal)</code>或<code class="fe lp lq lr ls b">myArrowFunc.apply(thisVal)</code>间接调用arrow函数不会改变<code class="fe lp lq lr ls b">this</code>的值:上下文值总是按词汇解析的。</p><h1 id="2bbd" class="mf ly in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">2.构造器</h1><h2 id="09be" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">2.1常规功能</h2><p id="a64d" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">正如上一节所看到的，正则函数可以很容易地构造对象。</p><p id="0945" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，<code class="fe lp lq lr ls b">Car()</code>函数创建一辆汽车的实例:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="a310" class="lx ly in ls b gy lz ma l mb mc">function Car(color) {<br/>  this.color = color;<br/>}</span><span id="9675" class="lx ly in ls b gy md ma l mb mc">const redCar = new Car('red');<br/>redCar instanceof Car; // =&gt; true</span></pre><p id="22da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">Car</code>是一个常规函数，当用<code class="fe lp lq lr ls b">new</code>关键字调用时，它会创建<code class="fe lp lq lr ls b">Car</code>类型的新实例。</p><h2 id="85ad" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">2.2箭头功能</h2><p id="7e3c" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated"><code class="fe lp lq lr ls b">this</code>的词法解析的结果是箭头函数不能用作构造函数。</p><p id="ee0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您试图调用以<code class="fe lp lq lr ls b">new</code>关键字为前缀的箭头函数，JavaScrip会抛出一个错误:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="48de" class="lx ly in ls b gy lz ma l mb mc">const Car = (color) =&gt; {<br/>  this.color = color;<br/>};</span><span id="e247" class="lx ly in ls b gy md ma l mb mc">const redCar = new Car('red'); // TypeError: Car is not a constructor</span></pre><p id="5877" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">调用<code class="fe lp lq lr ls b">new Car('red')</code>，其中<code class="fe lp lq lr ls b">Car</code>是一个箭头函数，抛出<code class="fe lp lq lr ls b">TypeError: Car is not a constructor</code>。</p><h1 id="ba8b" class="mf ly in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">3.参数对象</h1><h2 id="87ff" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">3.1常规功能</h2><p id="d242" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">在常规函数体中，<code class="fe lp lq lr ls b">arguments</code>是一个特殊的类似数组的对象，包含调用函数所用的参数列表。</p><p id="19c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用两个参数调用<code class="fe lp lq lr ls b">myFunction</code>函数:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="1a41" class="lx ly in ls b gy lz ma l mb mc">function myFunction() {<br/>  console.log(arguments);<br/>}</span><span id="56fa" class="lx ly in ls b gy md ma l mb mc">myFunction('a', 'b'); // logs { 0: 'a', 1: 'b'}</span></pre><p id="c219" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">arguments</code>类数组对象包含调用参数:<code class="fe lp lq lr ls b">'a'</code>和<code class="fe lp lq lr ls b">'b'</code>。</p><h2 id="3e87" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">3.2箭头功能</h2><p id="a3a1" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">另一方面，在箭头函数中没有定义<code class="fe lp lq lr ls b">arguments</code>特殊关键字。</p><p id="1d98" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再次说明(与<code class="fe lp lq lr ls b">this</code>值相同)，<code class="fe lp lq lr ls b">arguments</code>对象被词法解析:arrow函数从外部函数访问<code class="fe lp lq lr ls b">arguments</code>。</p><p id="8019" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们尝试访问箭头函数内部的<code class="fe lp lq lr ls b">arguments</code>:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="61f9" class="lx ly in ls b gy lz ma l mb mc">function myRegularFunction() {<br/>  const myArrowFunction = () =&gt; {    <br/>     console.log(arguments); <br/>  }<br/>  myArrowFunction('c', 'd');<br/>}</span><span id="8e17" class="lx ly in ls b gy md ma l mb mc">myRegularFunction('a', 'b'); // logs { 0: 'a', 1: 'b' }</span></pre><p id="75b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">箭头函数<code class="fe lp lq lr ls b">myArrowFunction()</code>由参数<code class="fe lp lq lr ls b">'c'</code>、<code class="fe lp lq lr ls b">'d'</code>调用。尽管如此，在它的主体内部，<code class="fe lp lq lr ls b">arguments</code>对象等同于<code class="fe lp lq lr ls b">myRegularFunction()</code>调用的自变量:<code class="fe lp lq lr ls b">'a'</code>，<code class="fe lp lq lr ls b">'b'</code>。</p><p id="18fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您想访问arrow函数的直接参数，那么您可以使用rest参数特性:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="4e5e" class="lx ly in ls b gy lz ma l mb mc">function myRegularFunction() {<br/>  const myArrowFunction = (...args) =&gt; {    console.log(args);  }<br/>  myArrowFunction('c', 'd');<br/>}</span><span id="7e40" class="lx ly in ls b gy md ma l mb mc">myRegularFunction('a', 'b'); // logs { 0: 'c', 1: 'd' }</span></pre><p id="62ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">...args</code> rest参数收集arrow函数的执行参数:<code class="fe lp lq lr ls b">{ 0: 'c', 1: 'd' }</code>。</p><h1 id="4d2e" class="mf ly in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">4.隐性回报</h1><h2 id="9417" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">4.1常规功能</h2><p id="37ef" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">只需使用<code class="fe lp lq lr ls b">return expression</code>语句从函数中返回一个结果:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="1adf" class="lx ly in ls b gy lz ma l mb mc">function myFunction() {<br/>  return 42;<br/>}</span><span id="cf56" class="lx ly in ls b gy md ma l mb mc">myFunction(); // =&gt; 42</span></pre><p id="4d4e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果缺少<code class="fe lp lq lr ls b">return</code>语句，或者return语句后没有表达式，正则函数隐式返回<code class="fe lp lq lr ls b">undefined</code>:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="e7e2" class="lx ly in ls b gy lz ma l mb mc">function myEmptyFunction() {<br/>  42;<br/>}</span><span id="5427" class="lx ly in ls b gy md ma l mb mc">function myEmptyFunction2() {<br/>  42;<br/>  return;<br/>}</span><span id="cd04" class="lx ly in ls b gy md ma l mb mc">myEmptyFunction();  // =&gt; undefined<br/>myEmptyFunction2(); // =&gt; undefined</span></pre><h2 id="3b18" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">4.2箭头功能</h2><p id="8a85" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">可以像从常规函数中返回值一样从arrow函数中返回值，但有一个有用的例外。</p><p id="e431" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果arrow函数包含一个表达式，并且您省略了函数的花括号，那么表达式将显式返回。这些是内嵌箭头函数。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="bd9e" class="lx ly in ls b gy lz ma l mb mc">const increment = (num) =&gt; num + 1;</span><span id="68dc" class="lx ly in ls b gy md ma l mb mc">increment(41); // =&gt; 42</span></pre><p id="c3b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">increment()</code>箭头只包含一个表达式:<code class="fe lp lq lr ls b">num + 1</code>。该表达式由arrow函数隐式返回，不使用<code class="fe lp lq lr ls b">return</code>关键字。</p><h1 id="f0db" class="mf ly in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">5.方法</h1><h2 id="3370" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">5.1常规功能</h2><p id="c0f4" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">正则函数是在类上定义方法的常用方式。</p><p id="cabe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在下面的类<code class="fe lp lq lr ls b">Hero</code>中，使用常规函数定义了方法<code class="fe lp lq lr ls b">logName()</code>:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="d484" class="lx ly in ls b gy lz ma l mb mc">class Hero {<br/>  constructor(heroName) {<br/>    this.heroName = heroName;<br/>  }</span><span id="fffe" class="lx ly in ls b gy md ma l mb mc">  logName() {    <br/>     console.log(this.heroName);  <br/>  }<br/>}</span><span id="45de" class="lx ly in ls b gy md ma l mb mc">const batman = new Hero('Batman');</span></pre><p id="e9b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通常，常规函数作为方法是可行的。</p><p id="8999" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有时你需要提供一个回调方法，比如给<code class="fe lp lq lr ls b">setTimeout()</code>或者一个事件监听器。在这种情况下，您可能会遇到访问<code class="fe lp lq lr ls b">this</code>值的困难。</p><p id="922f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，让我们使用use <code class="fe lp lq lr ls b">logName()</code>方法作为对<code class="fe lp lq lr ls b">setTimeout()</code>的回调:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="123f" class="lx ly in ls b gy lz ma l mb mc">setTimeout(batman.logName, 1000);<br/>// after 1 second logs "undefined"</span></pre><p id="85ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1秒钟后，<code class="fe lp lq lr ls b">undefined</code>登录到控制台。<code class="fe lp lq lr ls b">setTimeout()</code>执行对<code class="fe lp lq lr ls b">logName</code>(其中<code class="fe lp lq lr ls b">this</code>是全局对象)的简单调用。这就是方法与对象分离的时候。</p><p id="1846" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们手动将<code class="fe lp lq lr ls b">this</code>值绑定到正确的上下文:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="a545" class="lx ly in ls b gy lz ma l mb mc">setTimeout(batman.logName.bind(batman), 1000);<br/>// after 1 second logs "Batman"</span></pre><p id="cafb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">batman.logName.bind(batman)</code>将<code class="fe lp lq lr ls b">this</code>值绑定到<code class="fe lp lq lr ls b">batman</code>实例。现在您确定方法不会失去上下文。</p><p id="7cec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">手动绑定<code class="fe lp lq lr ls b">this</code>需要样板代码，尤其是如果有很多方法的话。还有一个更好的方法:箭头充当类字段。</p><h2 id="6ec6" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">5.2箭头功能</h2><p id="1522" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">由于<a class="ae ks" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">类字段的建议</a>，您可以使用箭头函数作为类内的方法。</p><p id="e95e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，与常规函数相反，使用箭头定义的方法在词汇上把<code class="fe lp lq lr ls b">this</code>绑定到类实例。</p><p id="de86" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们将箭头函数用作字段:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="5269" class="lx ly in ls b gy lz ma l mb mc">class Hero {<br/>  constructor(heroName) {<br/>    this.heroName = heroName;<br/>  }</span><span id="979c" class="lx ly in ls b gy md ma l mb mc">  logName = () =&gt; {    console.log(this.heroName);  }}</span><span id="4239" class="lx ly in ls b gy md ma l mb mc">const batman = new Hero('Batman');</span></pre><p id="669d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在您可以使用<code class="fe lp lq lr ls b">batman.logName</code>作为回调，而无需对<code class="fe lp lq lr ls b">this</code>进行任何手动绑定。<code class="fe lp lq lr ls b">this</code>在<code class="fe lp lq lr ls b">logName()</code>方法中的值总是类实例:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="1b0c" class="lx ly in ls b gy lz ma l mb mc">setTimeout(batman.logName, 1000);<br/>// after 1 second logs "Batman"</span></pre><h1 id="fbfa" class="mf ly in bd mg mh mi mj mk ml mm mn mo jt mp ju mq jw mr jx ms jz mt ka mu mv bi translated">6.摘要</h1><p id="f2dd" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">了解正则函数和arrow函数之间的差异有助于为特定需求选择正确的语法。</p><p id="1244" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">this</code>常规函数中的值是动态的，取决于调用。但是箭头函数内部的<code class="fe lp lq lr ls b">this</code>在词汇上是绑定的，等于外部函数的<code class="fe lp lq lr ls b">this</code>。</p><p id="298d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">arguments</code>正则函数内部的对象包含参数列表。相反，arrow函数没有定义<code class="fe lp lq lr ls b">arguments</code>(但是您可以使用rest参数<code class="fe lp lq lr ls b">...args</code>轻松访问arrow函数参数)。</p><p id="7b2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果arrow函数只有一个表达式，那么表达式将隐式返回，即使不使用<code class="fe lp lq lr ls b">return</code>关键字。</p><p id="81cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后但同样重要的是，您可以在类中使用arrow函数语法来定义方法。胖箭头方法将<code class="fe lp lq lr ls b">this</code>值绑定到类实例。</p><p id="effb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无论如何，胖箭头方法被调用，<code class="fe lp lq lr ls b">this</code>总是等于类实例，这在方法被用作回调时很有用。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><h2 id="5612" class="lx ly in bd mg mw mx dn mk my mz dp mo lc na nb mq lg nc nd ms lk ne nf mu ng bi translated">简单英语中的JavaScript</h2><p id="2c35" class="pw-post-body-paragraph kt ku in kv b kw nh jo ky kz ni jr lb lc nj le lf lg nk li lj lk nl lm ln lo ig bi translated">你知道我们有四个出版物和一个YouTube频道吗？在<a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">找到他们，点击</strong> </a>和<a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">订阅，我们的YouTube频道</strong> </a> <strong class="kv io">！</strong></p></div></div>    
</body>
</html>