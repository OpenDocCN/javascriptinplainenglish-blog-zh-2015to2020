<html>
<head>
<title>Six things you should know about Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于JavaScript中的对象，你应该知道的六件事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/six-things-you-should-know-about-objects-in-javascript-ccd11a9e1998?source=collection_archive---------0-----------------------#2020-03-27">https://javascript.plainenglish.io/six-things-you-should-know-about-objects-in-javascript-ccd11a9e1998?source=collection_archive---------0-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/141f27a3c2375b749b08e6bfb63d3ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*OI_DGW7YYQTPU7uYTzLbZQ.png"/></div></figure><h1 id="3678" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">1.对象方法&amp; <em class="ks">本</em></h1><ul class=""><li id="df12" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">方法只是保存函数值的属性</li></ul><h2 id="d796" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated"><strong class="ak"> —简单对象方法</strong></h2><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="a1d7" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="97c9" class="ll jv iq mv b gy mz na l nb nc">The rabbit says 'I'm alive.'</span></pre><h2 id="2e72" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—对象方法&amp; this</h2><ul class=""><li id="b319" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">当一个函数作为方法被调用时——作为属性被查找并立即被调用，如在<code class="fe nd ne nf mv b">object.method()</code>中——函数体中的特殊变量<code class="fe nd ne nf mv b">this</code>将指向被调用的对象</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="cfc4" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="1781" class="ll jv iq mv b gy mz na l nb nc">The white rabbit says 'Oh my ears and whiskers, how late it's getting!'</span></pre><h2 id="78d3" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—应用和呼叫</h2><ul class=""><li id="f142" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><code class="fe nd ne nf mv b">apply</code> &amp; <code class="fe nd ne nf mv b">call</code>可用于<code class="fe nd ne nf mv b">object.method()</code></li><li id="ab51" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated"><code class="fe nd ne nf mv b">apply</code> &amp; <code class="fe nd ne nf mv b">call</code>方法都采用第一个参数，该参数可用于模拟方法调用</li><li id="0639" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">第一个参数实际上用于给<code class="fe nd ne nf mv b">this</code>赋值</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5efc" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="ff03" class="ll jv iq mv b gy mz na l nb nc">The white rabbit says 'Burp!'<br/>The old rabbit says 'Oh my.</span></pre></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="7f6f" class="ju jv iq bd jw jx ns jz ka kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr bi translated">2.原型</h1><ul class=""><li id="7174" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">几乎所有的物体都有一个<code class="fe nd ne nf mv b">prototype</code></li><li id="26a7" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">原型是另一个用作属性后备来源的对象</li><li id="0e38" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">当一个对象请求一个它没有的属性时，将搜索它的原型来查找该属性，然后是原型的原型，依此类推</li></ul><h2 id="82bf" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—空对象的原型</h2><ul class=""><li id="e264" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">空物体的原型是伟大的祖先原型，几乎所有物体背后的实体，<code class="fe nd ne nf mv b">Object.prototype</code></li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="d299" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="0a63" class="ll jv iq mv b gy mz na l nb nc">[Function: toString]<br/>[object Object]</span></pre><h2 id="9356" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—其他对象的默认属性(数组、函数……)</h2><ul class=""><li id="9856" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">许多对象没有直接将<code class="fe nd ne nf mv b">Object.prototype</code>作为它们的原型，但是有自己的默认属性</li><li id="1788" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">函数来源于<code class="fe nd ne nf mv b">Function.prototype</code>数组来源于<code class="fe nd ne nf mv b">Array.prototype</code></li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="6bd5" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="d7f3" class="ll jv iq mv b gy mz na l nb nc">true<br/>true</span></pre><h2 id="182c" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">— Object.create创建具有特定原型的对象</h2><ul class=""><li id="89a7" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><em class="nx">原型兔子</em>充当所有兔子共享的属性的容器</li><li id="0977" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">单个rabbit对象，如killer rabbit，包含仅适用于自身的属性(在本例中为其类型),并从其原型派生共享属性</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e727" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="09d7" class="ll jv iq mv b gy mz na l nb nc">The killer rabbit says 'SKREEE!'</span></pre></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="6be5" class="ju jv iq bd jw jx ns jz ka kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr bi translated">3.构造器</h1><h2 id="ace6" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—构造器原型</h2><ul class=""><li id="96a8" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建从共享原型派生对象的更方便的方法是使用<strong class="kv ir">构造函数</strong></li><li id="e014" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">在JavaScript中，调用前面带有<code class="fe nd ne nf mv b">new</code>关键字的函数会导致它被视为构造函数</li><li id="19d4" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">构造函数将把它的<code class="fe nd ne nf mv b">this</code>变量绑定到一个新对象，除非它显式返回另一个对象值，否则这个新对象将从调用中返回</li><li id="1c2f" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">用<code class="fe nd ne nf mv b">new</code>创建的对象被称为其构造函数的<code class="fe nd ne nf mv b">instance</code></li><li id="b561" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">将构造函数的名字大写是一种惯例，这样可以很容易地将它们与其他函数区分开来</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="8250" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="1fa7" class="ll jv iq mv b gy mz na l nb nc">black</span></pre><h2 id="c714" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—默认情况下，构造函数具有Object.prototype</h2><ul class=""><li id="b9b3" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">构造函数(实际上是所有的函数)自动获得一个名为<code class="fe nd ne nf mv b">prototype</code>的属性，默认情况下，它保存一个从<code class="fe nd ne nf mv b">Object.prototype</code>派生的普通的空对象</li><li id="d13f" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">使用此构造函数创建的每个实例都将此对象作为其原型</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="187b" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="badd" class="ll jv iq mv b gy mz na l nb nc">The black rabbit says 'Doom...'</span></pre></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="0227" class="ju jv iq bd jw jx ns jz ka kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr bi translated">4.覆盖派生属性</h1><h2 id="cb39" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—相同的原型名称</h2><ul class=""><li id="22d1" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">如果原型中有一个同名的属性，这个属性不会改变</li><li id="33b3" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">属性被添加到对象本身</li><li id="f94c" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated"><code class="fe nd ne nf mv b">console.log(blackRabbit.teeth)</code>打印<code class="fe nd ne nf mv b">small</code>是因为<code class="fe nd ne nf mv b">blackRabbit</code>对象没有<code class="fe nd ne nf mv b">teeth</code>属性，它继承了<code class="fe nd ne nf mv b">Rabbit</code>对象自身的<code class="fe nd ne nf mv b">teeth</code>属性，即<code class="fe nd ne nf mv b">small</code></li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="e003" class="ju jv iq bd jw jx ns jz ka kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr bi translated">5.原型干扰</h1><h2 id="1a20" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">—可计数与不可计数</h2><ul class=""><li id="0e82" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><code class="fe nd ne nf mv b">toString</code>没有出现在<code class="fe nd ne nf mv b">for/in</code>循环中，但是<code class="fe nd ne nf mv b">in</code>操作符为其返回了<code class="fe nd ne nf mv b">true</code></li><li id="1642" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">这是因为JavaScript区分了<strong class="kv ir">可枚举的</strong>和<strong class="kv ir">不可枚举的</strong>属性</li><li id="d41d" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">我们通过简单地给它们赋值而创建的所有属性都是可枚举的</li><li id="23c4" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated"><code class="fe nd ne nf mv b">Object.prototype</code>中的标准属性都是不可数的，这就是为什么它们没有出现在这样的<code class="fe nd ne nf mv b">for/in</code>循环中</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3af5" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="578a" class="ll jv iq mv b gy mz na l nb nc">pizza<br/>touched tree<br/>nonsense<br/>true<br/>true</span></pre><ul class=""><li id="63d5" class="kt ku iq kv b kw mf ky mi la ny lc nz le oa lg lh li lj lk bi translated">使用<code class="fe nd ne nf mv b">Object.defineproperty</code>功能可以定义我们自己的不可数属性，这允许我们控制我们正在创建的属性的类型</li><li id="999b" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">在这个例子中，属性在那里<code class="fe nd ne nf mv b">map.hiddenNonsense</code>，但是它不会在一个循环中出现</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="a76c" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="0054" class="ll jv iq mv b gy mz na l nb nc">pizza<br/>touched tree<br/>hi</span></pre><h2 id="bee7" class="ll jv iq bd jw lm ln dn ka lo lp dp ke la lq lr ki lc ls lt km le lu lv kq lw bi translated">— hasOwnProperty与中的对象</h2><ul class=""><li id="81cb" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><code class="fe nd ne nf mv b">hasOwnProperty</code>方法告诉我们对象<strong class="kv ir">本身</strong>是否具有该属性，而无需查看其原型</li><li id="fbad" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">这通常比<code class="fe nd ne nf mv b">in</code>操作符给我们的信息更有用</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3ecc" class="pw-post-body-paragraph md me iq kv b kw mf mg mh ky mi mj mk la ml mm mn lc mo mp mq le mr ms mt lg ij bi translated">产量为</p><pre class="lx ly lz ma gt mu mv mw mx aw my bi"><span id="1ba4" class="ll jv iq mv b gy mz na l nb nc">true<br/>false</span></pre><ul class=""><li id="4cc2" class="kt ku iq kv b kw mf ky mi la ny lc nz le oa lg lh li lj lk bi translated">因此，当您担心有人可能已经破坏了基于对象的原型时，我建议您像这样编写您的<code class="fe nd ne nf mv b">for/in</code>循环</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="ebb7" class="ju jv iq bd jw jx ns jz ka kb nt kd ke kf nu kh ki kj nv kl km kn nw kp kq kr bi translated">6.无原型对象</h1><ul class=""><li id="63f8" class="kt ku iq kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><code class="fe nd ne nf mv b">Object.create</code>函数允许我们创建一个具有特定原型的对象</li><li id="3867" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">你可以传递<code class="fe nd ne nf mv b">null</code>作为原型来创建一个没有原型的新对象</li><li id="495b" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">因此，我们不再需要<code class="fe nd ne nf mv b">hasOwnProperty</code>,因为对象拥有的所有属性都是它自己的属性</li><li id="c591" class="kt ku iq kv b kw ng ky nh la ni lc nj le nk lg lh li lj lk bi translated">现在我们可以安全地使用<code class="fe nd ne nf mv b">for/in</code>循环，不管人们对<code class="fe nd ne nf mv b">Object.prototype</code>做了什么</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div></div>    
</body>
</html>