<html>
<head>
<title>Frameworks will never be as fast as Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">框架永远不会像普通JavaScript那样快</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-frameworks-performance-60f71d321693?source=collection_archive---------1-----------------------#2020-10-06">https://javascript.plainenglish.io/javascript-frameworks-performance-60f71d321693?source=collection_archive---------1-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d803" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在大多数情况下——这很好</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/87c59977c09d93f4c57766f05e266454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4DHgsHgyxg4UjvaWqJzaLg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="e452" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像React.js、Vue、Angular这样的框架和库，其实是每个web开发者知识中固定的一部分。在开始一个新项目之前，通常不再有使用哪个框架的问题。是用Angular，Vue，还是React.js，往往是一个口味问题。然后，您只需要决定应该使用哪些附加工具和哪个后端。</p><p id="b144" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看向您展示如何使用JS框架的平台就可以证实这一点——世界上大多数最重要的网站都是建立在复杂的框架和库之上的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/74d1a3f5bb1edd092615323374e08995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxLCJFZdSB6fvUQajXEVdA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Souce: <a class="ae ls" href="https://www.wappalyzer.com/technologies/javascript-frameworks/react/" rel="noopener ugc nofollow" target="_blank">Wappalyzer</a></figcaption></figure><p id="dec3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是一次又一次，古老的讨论出现了:<br/><strong class="kx ir">JavaScript框架能和普通的JS web应用一样快吗？</strong>T3答案是<strong class="kx ir">否</strong>。这其中的原因以及为什么它一点也不差——这篇文章会给你答案。</p><h1 id="c1dd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">即使使用服务器端渲染也不行…</h1><p id="5b22" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">JavaScript框架能和Vanilla-JS一样快吗？</p><p id="bb4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">服务器端渲染和客户端渲染的讨论显然是偏向一方的。在大多数情况下，服务器端呈现，或者不需要JavaScript呈现的静态页面更优越。</p><p id="3f2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么会这样很容易解释。</p><p id="f8c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">服务器端渲染(rendered) /静态:</strong>将完成HTML结构的页面发送到客户端浏览器。客户端浏览器通过HTML结构直接知道它应该显示什么。</p><p id="33be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">客户端渲染:</strong>服务器向客户端浏览器发送HTML模板，该模板还没有完成的结构。HTML模板被读取和处理，它请求一个或多个大的JavaScript文件。这些也是送的。当处理JavaScript时，建立页面的HTML结构。只有这样，浏览器才能直观地显示它应该显示的内容。</p><p id="dc1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以客户端渲染显然走了弯路，这通常会对性能产生负面影响。</p><p id="58b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">许多人错误地认为，服务器端渲染将React.js或Vue应用程序变成了一个HTML结构的页面，只加载最必要的JavaScript代码。但这并不完全正确。<br/>根据这篇论文，React.js和Next.js中的同一个应用程序(一次CSR，一次SSR)在Next.js的情况下必须小得多——因为React.js背后的所有逻辑都将被丢弃。但事实并非如此。</p><p id="193a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了证明这一点，我在Next.js和React.js中编写了完全相同的应用程序——这两个应用程序都被制作成了生产版本，并在谷歌Chrome的网络选项卡中查看哪个更大。就是Next.js app。</p><p id="a8f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">差不多大了50 kb。</p><p id="5851" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我用纯普通JS再次实现了同一个应用程序。大小为2.5kb。总尺寸。Next.js与客户端呈现的React.js应用程序大小相同的原因是因为仍然包含所有React.js逻辑。例如状态和虚拟DOM所需的所有逻辑。</p><p id="b53d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们面对它——服务器端渲染加速了网站的第一次内容绘制，但框架本身仍然必须在后台加载。</p><p id="76fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们面对它——服务器端渲染加速了网站的第一次内容绘制，但框架本身仍然必须在后台加载。因此，服务器端渲染永远不会像vanilla-JS中实现的相同应用程序那样快。通常情况下——为什么框架仍然有它们的权限，我们现在将谈到这一点。</p><h1 id="d494" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">最佳实践和安全性</h1><p id="0261" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我刚刚提到，普通的JS应用程序应该总是比用框架实现的相同应用程序更快。对于正常情况，我指的是非常重要的一点:香草JS应用程序正确实现的情况。</p><p id="f4d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是贯穿整个技术领域的东西。每个人都在谈论性能，但几乎没有人谈论它是如何实现的。他们很快表示，编程语言A比编程语言B性能更好。但这只有在正确编程的情况下才成立。<strong class="kx ir">如果你写了糟糕的代码，并且打中了自己的膝盖，那么纸上的性能有什么用？</strong></p><p id="5450" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我在Next.js、React.js和Vanilla JS中实现的小应用程序只能显示一个可以通过按钮增加的数字。使用这样的框架完全是夸大其词，因为您可以用几行JavaScript实现onClick事件和DOM操作。</p><p id="2e60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是即使是我的例子也是从用什么来更新DOM中的数字这个问题开始的。<code class="fe mq mr ms mt b">innerHTML</code>、<code class="fe mq mr ms mt b">innerText</code>还是<code class="fe mq mr ms mt b">textContent</code>？</p><p id="9a13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Vanilla-JS中有很多方法可以实现同样的事情。对于选择DOM元素，也有不好的做法和好的做法。糟糕的决策总是会导致更糟糕的表现。</p><p id="0868" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大多数JavaScript框架要简单得多。它们不仅是我们可以使用的功能的集合，也是它们自己的哲学，为我们如何正确做事提供了一个框架。这是我真正欣赏他们的地方。</p><p id="c18f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，JavaScript框架提供了一系列特性，使我们更容易构建应用程序——最重要的是，更容易构建高性能的应用程序。<br/>以下是一些更有用的功能，其中大部分都包括在内:</p><p id="0598" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是许多框架提供的更有用的特性:</p><h2 id="e078" class="mu lu iq bd lv mv mw dn lz mx my dp md le mz na mf li nb nc mh lm nd ne mj nf bi translated">组件模型</h2><p id="43b4" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">如果没有它，很难想象用可重用的组件来构建所有东西。它让一切变得更愉快、更快捷、更好维护。这个概念不仅用在JavaScript框架中，也用在其他技术中。例如，即使在后端，视图渲染框架也可以用来实现MVC模型，并将应用程序的所有可视部分分解成组件。</p><p id="9640" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">多亏了组件，我们不仅节省了大量的精力，而且它们还允许我们将视觉与状态同步——这在几乎任何框架中都是可能的。在Vue.js中有用于此目的的数据，在React.js中有状态。</p><p id="1e56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我发现组件模型特别好的一点是，在某个时候你开始用它来思考。每当我对一个应用程序有了新的想法，我都会绘制一些草图，并组织组件结构。</p><h2 id="e14b" class="mu lu iq bd lv mv mw dn lz mx my dp md le mz na mf li nb nc mh lm nd ne mj nf bi translated">惰性装载</h2><p id="88da" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">只在我们需要的时候加载web应用程序的一部分是非常强大的。所以初始负载越小，需要做的渲染就越少。惰性加载是一个特性，已经包含在许多框架中，并且易于使用。尤其是许多框架的面向组件的理念使得使用延迟加载非常有用。</p><h2 id="a2cd" class="mu lu iq bd lv mv mw dn lz mx my dp md le mz na mf li nb nc mh lm nd ne mj nf bi translated">记忆化</h2><p id="ef9d" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">React.js中已经包含的另一个特性——当然，您也可以在vanilla JS中实现内存化，但是框架或库的官方特性总是首选方式。对于React，带有React.memo的技术是可用的，其他技术也提供类似的功能，或者可能很快就会推出。</p><h2 id="1ed9" class="mu lu iq bd lv mv mw dn lz mx my dp md le mz na mf li nb nc mh lm nd ne mj nf bi translated">随时可以工作的环境</h2><p id="31de" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在一个私人项目中，有一天我注意到了这一点——我想完全使用普通的JavaScript。但这也意味着一切都要从头开始——不仅是代码，尤其是配置。在通常的CLI中，几乎所有内容都已包含在内。</p><p id="38a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从TypeScript到JavaScript和从Sass到CSS的代码转换很快就可以完成，并且可以非常容易地集成到框架引导的世界中。甚至最小化和代码转换通常也包括在内——这对初学者来说很好。</p><h1 id="98dc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">摘要</h1><p id="5a31" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">JavaScript框架很棒。他们有他们的理由，他们的优势是香草JS的劣势。就性能而言，反之亦然。但是性能真的那么差吗？不，我不这么认为。服务器端渲染、缓存、延迟加载&amp;压缩为加速JavaScript框架提供了坚实的帮助。当然，它总是以某种方式变得更好——但在某一点上，进一步优化没有意义，因为毫秒并不会真正影响用户体验。</p><p id="0665" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一次又一次，你会看到一些人想要开始一个新的项目，并直接努力追求完美——所以他们完全用普通的JS构建他们的应用程序——这比他们简单地使用一个框架要花费更长的时间。此外，对错误的敏感性通常更高。</p><p id="4e06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么这么多大公司也依赖JavaScript框架？不是因为他们没有技术专长来构建一个完整的普通js应用程序，而是因为它易于使用，并且他们可以节省很多钱。</p><h2 id="d0e5" class="mu lu iq bd lv mv mw dn lz mx my dp md le mz na mf li nb nc mh lm nd ne mj nf bi translated">例外</h2><p id="0336" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">还记得标题说在大多数情况下框架总是比普通JS慢吗？这只有在Vanilla JS开发得当的前提下才成立。</p><p id="51fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">框架的问题在于，它们提供了大量的代码，其中一部分根本没有使用或者使用得太少。然而，从高度的复杂性来看，即使是一个普通的JS应用程序也会变得非常大——而且错误率也更高。一个普通的JS开发人员不太可能比每个框架背后的团队工作得更干净。</p><h2 id="df18" class="mu lu iq bd lv mv mw dn lz mx my dp md le mz na mf li nb nc mh lm nd ne mj nf bi translated">清晰的线条</h2><p id="b3f4" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在我看来，每个项目都有一条清晰的界线，什么时候使用框架有意义，什么时候没有。<br/>这个限制可以通过考虑<strong class="kx ir">专业知识、时间、性能和应用</strong>的复杂性来确定。当然，对于一个有经验的普通JS开发人员来说，在没有框架的情况下实现一个计算身体质量指数的应用程序更有意义。</p><p id="6c3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，有这样一种情况，许多开发人员不再想在没有NPM包和框架的情况下工作。当我在React.js中实现一个只有一个组件的小应用程序时，我自己也犯了这个错误。当然，完全没有必要。</p><p id="f9ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读:)</p><p id="52d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae ls" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">加入我的邮件列表保持联系</strong> </a></p><p id="86d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于React.js的更多信息:</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/javascript-in-plain-english/4-useful-javascript-shorthands-you-can-use-in-react-js-ca9d2600bf3f" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">您可以在React.js中使用的4个有用的JavaScript简写</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">以下是我最喜欢的提供更少更清晰代码的短手。而且不仅仅在React.js中</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://medium.com/javascript-in-plain-english/react-typescript-813b02ff3672" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">React + TypeScript入门</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">结合两者的基本好处</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx kp nj"/></div></div></a></div></div></div>    
</body>
</html>