<html>
<head>
<title>5 Ways to Optimize Your Functional React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化功能反应元件的5种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-ways-to-optimize-your-functional-react-components-cb3cf6c7bd68?source=collection_archive---------0-----------------------#2020-08-10">https://javascript.plainenglish.io/5-ways-to-optimize-your-functional-react-components-cb3cf6c7bd68?source=collection_archive---------0-----------------------#2020-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6af794b293f5e13100661eaa8cc159b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzjyfmPq9QgV9KNvrfDa0g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Original Photo by <a class="ae jz" href="https://unsplash.com/@leorivas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Leo Rivas</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><ol class=""><li id="a236" class="ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><a class="ae jz" href="#a5b8" rel="noopener ugc nofollow">尽可能避免箭头功能</a></li><li id="aac2" class="ka kb in kc b kd ks kf kt kh ku kj kv kl kw kn ko kp kq kr bi translated"><a class="ae jz" href="#6a2b" rel="noopener ugc nofollow">使用useMemo缓存昂贵的计算结果</a></li><li id="18e2" class="ka kb in kc b kd ks kf kt kh ku kj kv kl kw kn ko kp kq kr bi translated"><a class="ae jz" href="#9433" rel="noopener ugc nofollow">用碎片代替空地</a></li><li id="3d6e" class="ka kb in kc b kd ks kf kt kh ku kj kv kl kw kn ko kp kq kr bi translated"><a class="ae jz" href="#ab1e" rel="noopener ugc nofollow">使用油门防止过度执行</a></li><li id="a529" class="ka kb in kc b kd ks kf kt kh ku kj kv kl kw kn ko kp kq kr bi translated"><a class="ae jz" href="#fb7b" rel="noopener ugc nofollow">使用useRef避免组件重新渲染</a></li></ol><h1 id="a5b8" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.尽可能避免使用箭头函数</h1><p id="203c" class="pw-post-body-paragraph lv lw in kc b kd lx ly lz kf ma mb mc kh md me mf kj mg mh mi kl mj mk ml kn ig bi translated">你很可能听说过使用arrow函数比使用要好。绑定，这绝对是正确的。但在使用functional reactor时，我们在许多情况下也可以避免使用arrow函数，因为每次重新呈现组件时，它们都会创建一个新函数。我们可以通过使用function关键字而不是使用箭头来简单地定义一个函数。<br/> <br/>例如，此组件使用3个箭头函数:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b856" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">但我们可以对其进行优化，改为使用0个arrow函数:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="edbf" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">这将防止在每次重新呈现时创建新函数，并且您仍然可以完全访问所需的任何变量。</p><p id="e13b" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">注意:如果传递给子组件的回调函数有多个参数，则可以使用arrow函数作为支柱，但内部函数可以保留为函数。例如:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="6a2b" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.使用useMemo缓存昂贵的计算</h1><p id="edc4" class="pw-post-body-paragraph lv lw in kc b kd lx ly lz kf ma mb mc kh md me mf kj mg mh mi kl mj mk ml kn ig bi translated"><a class="ae jz" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usememo</a></p><p id="1a5b" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">useMemo是一个很好的方法，可以防止在组件的每次重新呈现时调用代价高昂的函数，就像在更新状态时一样。相反，您可以告诉useMemo监视某些变量(即函数实际使用的变量)，并且仅在这些变量发生更改时重新计算。</p><p id="be16" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">这里有一个简单的例子:无论何时更改a、b或c，都会调用calc函数，即使c与计算无关:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ce4b" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">如果使用useMemo，则仅在a或b发生变化时进行计算，而不会在c:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a483" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">这可以扩展到许多不同的使用情形；例如，您可以返回一个JSX组件而不是一个值，这意味着您可以确定何时希望页面的某些部分重新呈现或保持不变。所以，下次当你需要根据一个变量的变化来更新你的组件，并开始按习惯键入“useEffect”时，花点时间考虑一下在这种情况下useMemo是否会更好地工作。</p><h1 id="9433" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3.使用碎片而不是空的div</h1><p id="c392" class="pw-post-body-paragraph lv lw in kc b kd lx ly lz kf ma mb mc kh md me mf kj mg mh mi kl mj mk ml kn ig bi translated"><a class="ae jz" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/fragments.html</a></p><p id="adea" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">从函数返回的任何JSX都必须在一个容器中，所以经常使用一个空的div(没有属性)来分组多个元素。但是React建议使用片段，这不会给DOM结构增加额外的节点。这使得阅读和调试代码变得更加容易，尤其是当您从浏览器中检查元素时。</p><p id="e603" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">例如，代替这个:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e42c" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">你可以用这个:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="ab1e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">4.使用节流来防止过度执行</h1><p id="0a6f" class="pw-post-body-paragraph lv lw in kc b kd lx ly lz kf ma mb mc kh md me mf kj mg mh mi kl mj mk ml kn ig bi translated"><a class="ae jz" href="https://reactjs.org/docs/faq-functions.html#throttle" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/faq-functions.html#throttle</a></p><p id="b2c0" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">您可以使用lodash中的throttle函数来防止一个函数在给定的时间范围内被执行多次。这在处理搜索、加载或基本上任何类型的交互时非常方便，在这些交互中，用户(<strong class="kc io"> <em class="mv">或甚至另一段代码</em> </strong>)可以在第一次执行结束之前多次调用一个函数。</p><p id="64bf" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">ReactJS在上面的链接中有一个非常好的例子，你每秒只能点击一次按钮；在这里，它被转换为功能组件:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2d41" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">注意:lodash的去抖功能可以以类似的方式在指定的时间后执行一个功能(对于处理快速/多个键盘事件特别有用)</p><h1 id="fb7b" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">5.使用useRef来避免组件重新呈现</h1><p id="83ec" class="pw-post-body-paragraph lv lw in kc b kd lx ly lz kf ma mb mc kh md me mf kj mg mh mi kl mj mk ml kn ig bi translated">我在多个应用程序中多次遇到的一个问题是，输入的onChange事件导致整个组件在每次键盘点击后重新呈现。大多数时候，React和现代浏览器(如Chrome和Firefox)可以很好地处理这种更新，你不会注意到任何延迟。但是当一个组件变得有数百(如果不是数千)行长，有几十个状态变量和函数时，渲染延迟开始变得非常明显，特别是如果你必须支持IE11这样的旧浏览器。这可能从几百毫秒到几秒钟不等。</p><p id="fc38" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">一种解决方案(尽管是非标准的方式)是使用useRef来更新目标值，而不使用useState。例如，考虑这个组件:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bc7c" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">在每次按键输入时，您将看到控制台日志被执行，整个组件将重新呈现。但是我们可以通过使用useRef来防止这种情况:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c43e" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">这里，屏幕上显示的文本会更新，而无需重新呈现整个组件。这可以显著提高大型组件的速度。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="0663" class="pw-post-body-paragraph lv lw in kc b kd ke ly lz kf kg mb mc kh ms me mf kj mt mh mi kl mu mk ml kn ig bi translated">希望这五点能让你在处理复杂问题时有更多的工具和选择。快乐函数式React编码！</p></div></div>    
</body>
</html>