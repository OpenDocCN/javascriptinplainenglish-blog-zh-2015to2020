<html>
<head>
<title>Render Props vs React Hooks: Which Is More Efficient?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">渲染道具vs React钩子:哪个效率更高？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/render-props-vs-hooks-a73ec72180ed?source=collection_archive---------3-----------------------#2020-07-10">https://javascript.plainenglish.io/render-props-vs-hooks-a73ec72180ed?source=collection_archive---------3-----------------------#2020-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c4dd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">你能猜出哪个代码片段效率更高吗？为什么？</h2></div><div class="kc kd ke kf gt ab cb"><figure class="kg kh ki kj kk kl km paragraph-image"><img src="../Images/73f335801fa0e7d4eb3e6df0905971fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*-HSvmBuoU_he-9isr-dHQw.png"/></figure><figure class="kg kh kp kj kk kl km paragraph-image"><img src="../Images/97c1e9d640aeb68f323c5f60c2b77714.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*xYu8oeQDjKSBJhgvz6K6gQ.png"/></figure></div><p id="d198" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">我用同样的问题开始了一个<a class="ae lm" href="https://twitter.com/moubi/status/1271429303574556672" rel="noopener ugc nofollow" target="_blank"> twitter讨论</a>，试图了解人们是否对钩子和渲染道具有强烈的意见。把两者对立起来不是空想，而是来自于一种现实的关切。</p><p id="a2f1" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><strong class="ks io">说到状态管理<em class="ln">渲染道具组件</em> : </strong></p><p id="4fc9" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">-通常<strong class="ks io">比纯钩子解决方案更灵活，更不容易出错</strong></p><p id="30f9" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">——仍然适用于<strong class="ks io">常见的</strong>情况</p><p id="4084" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">现实中，钩子和渲染道具握手言和，配合得很好。但是，如果你必须在两者之间做出选择，让我们把这个决定放在压力上。</p><p id="1051" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">想看看最终基准吗？跳到<em class="ln">“行动中的比较”</em>部分，否则请继续阅读…</p><p id="cde5" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><em class="ln">如果你对钩子和渲染道具模式不熟悉——不要担心——一个好的起点是</em> <a class="ae lm" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln">渲染道具</em> </a> <em class="ln">，</em> <a class="ae lm" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank"> <em class="ln">使用渲染道具！</em></a><em class="ln"/><a class="ae lm" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"><em class="ln">挂钩一目了然</em> </a> <em class="ln">。最后还提供了一个资源列表。</em></p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><h1 id="7285" class="lv lw in bd lx ly lz ma mb mc md me mf jt mg ju mh jw mi jx mj jz mk ka ml mm bi translated">渲染道具没有死</h1><p id="51d5" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">埃里克·拉斯姆森(Erik Rasmussen)的一次演讲引发了我的写作。它概述了我们如何从HoCs到hooks。看着它，它应该让事情变得更清楚。</p><p id="b591" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">我记得我脑海中的声音按下了React Europe视频的播放按钮:<em class="ln">“等等，我是不是应该重新编写我的库，去掉我非常喜欢的渲染道具”</em>。那时 <a class="ae lm" href="https://github.com/moubi/enform" rel="noopener ugc nofollow" target="_blank"> <strong class="ks io">的<strong class="ks io"> v2的Enform </strong> </strong></a>发布了，我很满意。立即重写v3会破坏我的动机。</p><p id="641f" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><strong class="ks io">可能是你:</strong></p><p id="828e" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">-使用钩子，但不要完全理解它们</p><p id="f93d" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">-将挂钩视为神奇的解决方案</p><p id="b867" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">-想用钩子重写吗</p><p id="8edb" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">如果是这样，那么接下来的事情可能会让人大吃一惊。</p><h1 id="b918" class="lv lw in bd lx ly ms ma mb mc mt me mf jt mu ju mh jw mv jx mj jz mw ka ml mm bi translated">问题是</h1><p id="4d53" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">钩子和渲染道具可以解决同样的问题。从概念上讲，它是将状态从你的组件中移走，这样它就可以被重用。问题是哪一个做得更好？什么时候？既然我们已经有了hooks API，那么为包装组件和渲染道具而烦恼又有什么关系呢？</p><p id="9779" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">为了回答这个问题，让我们在整个过程中使用下面的通用表单示例。这很简单，你可能已经看过很多次了:</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">The form is intentionally kept simpler.</figcaption></figure><p id="5e72" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">片段可能会迫使你思考:<em class="ln">“这是一个灾难的配方”</em>。对，州政府是主要嫌疑人。除此之外，通常表单中涉及更多的字段，需要处理验证、提交、API调用和错误消息。当然，结果是<strong class="ks io">你的组件将会增长，你可能需要通过抽象来减轻状态逻辑</strong>。</p><h1 id="97e7" class="lv lw in bd lx ly ms ma mb mc mt me mf jt mu ju mh jw mv jx mj jz mw ka ml mm bi translated">用钩子处理状态抽象</h1><p id="c694" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">请看这段简化的代码:</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Try it out in <a class="ae lm" href="https://codesandbox.io/embed/controlled-form-with-hooks-1e9o7?expanddevtools=1&amp;fontsize=14&amp;hidenavigation=1&amp;module=%2Fsrc%2FApp.js&amp;theme=dark" rel="noopener ugc nofollow" target="_blank">codesandbox</a></figcaption></figure><p id="a50c" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">它是相同的表单组件，但是使用了函数而不是类和<code class="fe nd ne nf ng b">useState</code>钩子。简单的动作已经让事情变得更好了。在这个受控表单中包含更多的字段就像在组件中处理更多的状态一样简单。</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2d52" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">使用钩子和功能组件已经是一种胜利。好的，但是你会遇到另一个麻烦——组件状态是和表单一起生长的。从这一点来看，有两个选择。创建一个单独的表单组件或一个自定义钩子来保持状态重载。</p><h2 id="5541" class="nh lw in bd lx ni nj dn mb nk nl dp mf kz nm nn mh ld no np mj lh nq nr ml ns bi translated">表单自定义挂钩</h2><p id="6484" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">我想你知道如何建造一个。有很多例子，所以我们不要关注下面的<code class="fe nd ne nf ng b">useForm</code>实现。有趣的是它如何改善我们的组件，以及它是如何被消耗的。请记住，我们正在慢慢触及痛点——定制挂钩是否是这里的最佳方法。</p><p id="bad6" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">最后，请再次原谅这种简单，因为这个想法只是为了说明模式。</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae lm" href="https://codesandbox.io/embed/controlled-form-with-custom-hook-f810j?expanddevtools=1&amp;fontsize=14&amp;hidenavigation=1&amp;module=%2Fsrc%2FApp.js&amp;theme=dark" rel="noopener ugc nofollow" target="_blank">This codesandbox</a> contains all the details.</figcaption></figure><p id="1b38" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">理想情况下，添加更多的逻辑将导致仅<code class="fe nd ne nf ng b">jsx</code>(渲染)部分增长，而<code class="fe nd ne nf ng b">useForm</code>为您管理状态。</p><p id="419f" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><strong class="ks io"> <em class="ln">侧注:</em> </strong></p><p id="dcd1" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><code class="fe nd ne nf ng b"><em class="ln">useForm()</em></code> <em class="ln">(挺常见的名字)可能会漏掉——参考你</em><a class="ae lm" href="https://github.com/react-hook-form/react-hook-form" rel="noopener ugc nofollow" target="_blank"><em class="ln">react——hook——form</em></a><em class="ln">。名字匹配，但理念不同。</em> <code class="fe nd ne nf ng b"><em class="ln">react-hook-form</em></code> <em class="ln">不是解决这里描述的状态问题，而是通过让形式成为不受控制的来避免。</em></p><p id="f3a8" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">回到我们的例子。添加错误和提交功能:</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3433" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">尽管如此，它的规模相当不错。您可以将更多的逻辑移入挂钩中，并使其可被项目中的所有表单组件重用。</p><p id="957d" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">状态不再驻留在<code class="fe nd ne nf ng b">&lt;Form /&gt;</code>中，但是组件将继续对场变化做出反应。最后，它是同样的<code class="fe nd ne nf ng b">useState</code>用法，但是被移到了<code class="fe nd ne nf ng b">useForm</code>。</p><p id="dc8e" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">这种方法的明显好处是直观(没有奇怪的语法)，可伸缩性很好，并且可能是React未来的一部分。</p><p id="3324" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">好吧，但是渲染道具呢？</p><h1 id="0b56" class="lv lw in bd lx ly ms ma mb mc mt me mf jt mu ju mh jw mv jx mj jz mw ka ml mm bi translated">通过渲染属性处理状态</h1><p id="3b6b" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">使用render props方法按状态卸载表单组件需要创建一个包装器组件。所以，表面上没有钩子，而是一个普通的组件。在这个例子中是<code class="fe nd ne nf ng b">children</code>作为渲染道具，但是你可以用<code class="fe nd ne nf ng b">render</code>(或者其他什么)来代替。</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Curious about <code class="fe nd ne nf ng b">FormManager’s</code> implementation? Here is the <a class="ae lm" href="https://codesandbox.io/embed/controlled-form-with-render-props-xvil0?expanddevtools=1&amp;fontsize=14&amp;hidenavigation=1&amp;module=%2Fsrc%2FApp.js&amp;theme=dark" rel="noopener ugc nofollow" target="_blank">codesandbox</a>.</figcaption></figure><p id="be90" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">以一种奇怪的方式将状态抽象出来，对吗？是的，就是这样。</p><p id="7b84" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">来自官方文件:</p><blockquote class="nt nu nv"><p id="4a3f" class="kq kr ln ks b kt ku jo kv kw kx jr ky nw la lb lc nx le lf lg ny li lj lk ll ig bi translated">术语“渲染道具”指的是使用其值为函数的道具在React组件之间共享代码的技术。</p></blockquote><p id="8da5" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><strong class="ks io"><em class="ln">“…使用一个值为函数的道具”</em></strong>——正是第一次看到渲染道具时显得笨拙的地方。除此之外，它的工作方式与<code class="fe nd ne nf ng b">useForm</code>相似，只是<code class="fe nd ne nf ng b">&lt;FormManager /&gt;</code>只是一个普通组件。这种模式可能很熟悉，尤其是当您正在使用第三方库时。</p><p id="19c6" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><strong class="ks io">渲染道具的方法和钩子有相似的好处，但是看起来很奇怪，有时不能有效扩展。</strong>为什么会这样？</p><p id="c11d" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">想象以下情况:</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">This snippet is actually a <a class="ae lm" href="https://github.com/moubi/flow-task/blob/master/src/components/Board/Board.js#L129" rel="noopener ugc nofollow" target="_blank">real example</a>.</figcaption></figure><p id="0e35" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">带有渲染属性的嵌套包装组件。哦，那看起来不是很有希望。它甚至会欺骗一些人，让他们相信这种模式已经过时，而支持<em class="ln">“用钩子做所有事情】</em>。钩子<a class="ae lm" href="https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components" rel="noopener ugc nofollow" target="_blank">不遭遇嵌套问题</a>，确实如此。</p><p id="04ac" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">但是如果渲染道具在钩子上没有优势，那么这篇文章将会走进一个死胡同。不过，还有一些与语法无关的东西。</p><p id="7d1b" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">继续…</p><h1 id="f569" class="lv lw in bd lx ly ms ma mb mc mt me mf jt mu ju mh jw mv jx mj jz mw ka ml mm bi translated">现状核实</h1><p id="36f7" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">让我们回顾一下。还记得开头这部分吗？</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8c4a" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">我有意在jsx中留下了更多的元素(<code class="fe nd ne nf ng b">&lt;h1 /&gt;</code>)，而不仅仅是<code class="fe nd ne nf ng b">&lt;form /&gt;</code>。这应该是一个提示，因为<strong class="ks io">在现实中，一些组件并不那么简单。通常他们会呈现更多你无法控制的代码。</strong></p><p id="1dfa" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">一个更现实的例子应该是这样的:</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="92bf" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">现在，我知道你可能会说:<em class="ln">谁会那样使用jsx？显然，您可以将表单逻辑提取到另一个组件中，并将其呈现在这里。是的，你可能是对的——这似乎是正确的做法，但并不总是如此。</em></p><p id="eead" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">挂钩有三个一般限制:</p><p id="25d1" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">1.你需要react@16.8.0(带钩子的那个)</p><p id="1ede" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">2.你必须使用功能组件</p><p id="a716" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">3.<strong class="ks io">你可能会陷入重新渲染的问题</strong></p><p id="9e3a" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">跳过前两个…如果你有类组件和react的较低版本，你显然不能使用钩子。<strong class="ks io">然而第三个，是决定挂钩和渲染道具时的基石。</strong></p><h2 id="6c80" class="nh lw in bd lx ni nj dn mb nk nl dp mf kz nm nn mh ld no np mj lh nq nr ml ns bi translated">您可能会遇到重新渲染的问题</h2><p id="2cf6" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">给定最后一个例子，每次你在表单中输入字段<code class="fe nd ne nf ng b">setValue</code>都会被调用，导致整个<code class="fe nd ne nf ng b">&lt;Page /&gt;</code>组件重新呈现。因为您正在更新状态，所以这是意料之中的。但不可取。<strong class="ks io">突然填表可能会成为一项非常昂贵的操作。</strong></p><p id="e9d6" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">React足够聪明，可以保护你免受不必要的渲染，但它不会违背自己的原则。每个组件都有自己的追赶，你需要解决这些问题，所以它对渲染是安全的。不幸的是，<code class="fe nd ne nf ng b">&lt;Header /&gt;</code>、<code class="fe nd ne nf ng b">&lt;Navigation /&gt;</code>和<code class="fe nd ne nf ng b">&lt;Footer /&gt;</code>可能就不是这样了，因为，让我们想象一下，你没有时间去重构它们。而有了<code class="fe nd ne nf ng b">&lt;SomeOtherThirdPartyComponent /&gt;</code>，你甚至可能做不到。</p><p id="39a8" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">这里没有太多选择。<strong class="ks io">从一个单独的组件中提取是使用钩子的方法</strong>。因此——你需要为项目中的每个表单重复这个步骤，迫使树不可避免地生长。</p><p id="333f" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">如果您正在构建一个导出类似于<code class="fe nd ne nf ng b">useForm</code>的钩子的表单库呢？你希望你的用户做上面额外的提取步骤吗？你可能会说这没什么大不了的。不是大的，是不太灵活的。</p><p id="ee86" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">钩子并不能解决所有的问题，它们也不是为了这个目的。上面假设的(或不假设的)初级读本就是你可能需要额外灵活性的情况之一。</p><p id="38a6" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">用钩子，但是加点糖。</p><h2 id="ad20" class="nh lw in bd lx ni nj dn mb nk nl dp mf kz nm nn mh ld no np mj lh nq nr ml ns bi translated">仅重新渲染相关的内容</h2><p id="b52f" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">渲染道具不会遭受相同的重新渲染问题挂钩。原因如下。</p><figure class="kc kd ke kf gt kh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9d05" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><code class="fe nd ne nf ng b"><strong class="ks io">&lt;FormManager /&gt;</strong></code> <strong class="ks io">确保无论表单中发生什么变化，它都将被隔离在该表单中。</strong> <code class="fe nd ne nf ng b">&lt;Page /&gt;</code>对不必要的渲染免疫。您可以添加更多的jsx而不会有副作用。</p><p id="114f" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">当然你总是可以打破有用的模式。想象一下，由于表单操作，更新了一些与<code class="fe nd ne nf ng b">&lt;Page /&gt;</code>相关的状态。这将导致额外的渲染。但是，这不是FormManager的错。</p><p id="0e80" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">现在，如果您表单库使用呈现属性导出组件，它的用户将获得额外的灵活性。他们不再被迫创建额外的组件。</p><h1 id="b50d" class="lv lw in bd lx ly ms ma mb mc mt me mf jt mu ju mh jw mv jx mj jz mw ka ml mm bi translated">行动比较</h1><p id="518b" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">挂钩和渲染道具并排:</p><figure class="kc kd ke kf gt kh gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ab0e26ed1e9005b9fea28d3017f5e741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*YfKIUPhRWoktMqlrT2C_MQ.gif"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">Feel free to play with <a class="ae lm" href="https://codesandbox.io/embed/forms-that-cause-re-render-issue-sd6tn?expanddevtools=1&amp;fontsize=14&amp;hidenavigation=1&amp;theme=dark" rel="noopener ugc nofollow" target="_blank">the set up</a>.</figcaption></figure><p id="070b" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">瞧。现在，您可以看到每个表单的渲染结果。左边的一个(自定义钩子)会导致所有页面子元素的重新渲染，而右边的一个(渲染道具)不会。</p><h1 id="bf8b" class="lv lw in bd lx ly ms ma mb mc mt me mf jt mu ju mh jw mv jx mj jz mw ka ml mm bi translated">最后的话</h1><p id="3520" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">如果您想隔离jsx的一部分，并注入一些状态，而不会给组件带来副作用，那么Render props非常有用。</p><p id="ca11" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">许多渲染道具实现在内部使用钩子是很常见的，所以说<em class="ln">“要么是钩子，要么什么都没有”</em>是极端的。钩子很好地支持了这种模式，并获得了它们在某些情况下缺乏的额外灵活性。这是在选择一种或另一种方法时要考虑的。</p><p id="adf3" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated">但是，你的表单库也可以导出包装组件和钩子。这也很常见。这让开源工作变得如此有趣。</p><p id="ac46" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><em class="ln">📩</em> <a class="ae lm" href="https://webup.org/blog/subscribe" rel="noopener ugc nofollow" target="_blank">订阅</a> <em class="ln">我的下一篇手工JavaScript/React写作。<br/>每月发行。</em></p><h1 id="f6d4" class="lv lw in bd lx ly ms ma mb mc mt me mf jt mu ju mh jw mv jx mj jz mw ka ml mm bi translated">资源</h1><p id="e12f" class="pw-post-body-paragraph kq kr in ks b kt mn jo kv kw mo jr ky kz mp lb lc ld mq lf lg lh mr lj lk ll ig bi translated">这里的列表并不全面。有些主题更高级，有些只是触及基础。<strong class="ks io">欢迎大家补充。</strong></p><ol class=""><li id="5c42" class="oa ob in ks b kt ku kw kx kz oc ld od lh oe ll of og oh oi bi translated"><a class="ae lm" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a> (React文档)</li><li id="a12e" class="oa ob in ks b kt oj kw ok kz ol ld om lh on ll of og oh oi bi translated"><a class="ae lm" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">一目了然</a> (React docs)</li><li id="cfbc" class="oa ob in ks b kt oj kw ok kz ol ld om lh on ll of og oh oi bi translated"><a class="ae lm" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">使用渲染道具！</a>(迈克尔杰克逊)</li><li id="f775" class="oa ob in ks b kt oj kw ok kz ol ld om lh on ll of og oh oi bi translated"><a class="ae lm" href="https://github.com/jaredpalmer/awesome-react-render-props" rel="noopener ugc nofollow" target="_blank">牛逼的React渲染道具</a>(贾里德·帕尔默)</li><li id="c2a2" class="oa ob in ks b kt oj kw ok kz ol ld om lh on ll of og oh oi bi translated"><a class="ae lm" href="https://www.youtube.com/watch?v=pn0pIgdQvhU&amp;list=PLCC436JpVnK0Q4WHoB85ZYBwcCyTaMgAl&amp;index=6" rel="noopener ugc nofollow" target="_blank">渲染道具没有死</a>(埃里克·拉斯姆森)</li></ol><p id="54d5" class="pw-post-body-paragraph kq kr in ks b kt ku jo kv kw kx jr ky kz la lb lc ld le lf lg lh li lj lk ll ig bi translated"><strong class="ks io"> <em class="ln">原贴于此:</em> </strong> <a class="ae lm" href="https://webup.org/blog/render-props-vs-hooks/" rel="noopener ugc nofollow" target="_blank"> <strong class="ks io"> <em class="ln">《渲染道具vs钩子》</em> </strong> </a> <strong class="ks io"> <em class="ln">。</em> </strong></p></div></div>    
</body>
</html>