<html>
<head>
<title>Chrono’s Typescript Rewrite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chrono的打字稿重写</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/chronos-typescript-rewrite-dcb33b04266?source=collection_archive---------6-----------------------#2020-08-10">https://javascript.plainenglish.io/chronos-typescript-rewrite-dcb33b04266?source=collection_archive---------6-----------------------#2020-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="33b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你没听说过，Chrono(【https://github.com/wanasit/chrono】T4)是JavaScript中的一种自然语言日期解析器。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/c6fadb6774c8a9f6ad25134da5eeb388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rudczV9pqc3nWOlwYI7IZw.png"/></div></div></figure><p id="eb63" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我在2012年写了第一个提交(想想jQuery和Bootstrap v1)。那也是我去东京读研究生的时候，也是我开始作为一名专业软件开发人员工作之前。从那以后，JavaScript (ES6，TypeScript，React，…)和我的编程经验都发生了很多变化。今年夏天，我终于有时间呆在家里重新设计图书馆。</p><p id="7398" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Chrono，v2，是这个项目用TypeScript几乎是从零开始重写的，考虑到了以下目标。</p><ul class=""><li id="ca67" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated">保持熟悉的API</li><li id="830a" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">减少重复代码和样板文件</li></ul><h1 id="68eb" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">保持熟悉的API</h1><p id="5de6" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">Chrono只做一件事——从文本中解析日期。因此，对于想要使用它的人来说，它应该是简单明了的。虽然隐藏了深层的解析复杂性，但Chrono一直保持最小的接口，即它的<code class="fe mz na nb nc b">parse()</code>函数。</p><p id="3b79" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">除了一些重要的差异(最重要的是地区处理)，Chrono v2拥有相同的极简API。</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="d230" class="nh md iq nc b gy ni nj l nk nl">import * as chrono from ‘chrono-node’;</span><span id="598c" class="nh md iq nc b gy nm nj l nk nl">chrono.parseDate(‘Today at 5 PM’) // Return a javascript Date object<br/>chrono.parse(’Today at 5 PM’)     // Return more detailed results</span></pre><p id="ff76" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您可以通过克隆基本设置和添加/删除<code class="fe mz na nb nc b">parsers</code>或<code class="fe mz na nb nc b">refiners</code>来自定义秒表计时:</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="3f74" class="nh md iq nc b gy ni nj l nk nl">import * as chrono from ‘chrono-node’;</span><span id="ecd5" class="nh md iq nc b gy nm nj l nk nl">const customChrono = new chrono.Chrono();<br/>// or const customChrono = chrono.en.clone();</span><span id="6e08" class="nh md iq nc b gy nm nj l nk nl">customChrono.parsers.push(...)</span></pre><p id="1fff" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你一直在使用Chrono，改变应该很简单。如果你不是，入门应该不难。</p><p id="f6f4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">同时，对于TypeScript项目，您可以获得Chrono新改进的类型系统的免费优势。</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="2272" class="nh md iq nc b gy ni nj l nk nl">class Chrono {</span><span id="fcab" class="nh md iq nc b gy nm nj l nk nl">    parsers: Array&lt;Parser&gt;<br/>    refiners: Array&lt;Refiner&gt;</span><span id="a034" class="nh md iq nc b gy nm nj l nk nl">    parse(<br/>        text: string, ref?: Date, option?: ParsingOption<br/>    ): ParsedResult[] { <br/>        ... <br/>    }</span><span id="3e30" class="nh md iq nc b gy nm nj l nk nl">}</span></pre><h1 id="4f17" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">减少重复代码和样板文件</h1><p id="5ebf" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">在ECMAScript 2015引入<code class="fe mz na nb nc b">class</code>之前，JavaScript项目需要依赖基于原型的继承。</p><p id="9904" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在Chrono中，由于没有良好的独立于语言的抽象(对于解析器和提炼器来说都是如此)，重复的代码也更加严重。我们鼓励贡献者从英语中复制并粘贴整个代码。</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="43d9" class="nh md iq nc b gy ni nj l nk nl">exports.Refiner = function ENMergeDateTimeRefiner() {</span><span id="de33" class="nh md iq nc b gy nm nj l nk nl">    Refiner.call(this);</span><span id="e6a2" class="nh md iq nc b gy nm nj l nk nl">    this.refine = function(text, results, opt) {<br/>        // check if there are results with unknown date and time<br/>        // check if the words between them meaningful<br/>        // merge them<br/>    }<br/>}</span><span id="fd0d" class="nh md iq nc b gy nm nj l nk nl">exports.Refiner = function FRMergeDateTimeRefiner() {</span><span id="49d3" class="nh md iq nc b gy nm nj l nk nl">    Refiner.call(this);</span><span id="a3e2" class="nh md iq nc b gy nm nj l nk nl">    this.refine = function(text, results, opt) {<br/>        // mostly same code, but check French words</span><span id="e044" class="nh md iq nc b gy nm nj l nk nl">    }<br/>}</span></pre><p id="efb6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在v2中，公共逻辑(例如日历和日期时间处理)被组织成独立于语言的公共类，而关键字和模式处理被分离并包含在它们自己的模块中(参见.`/common/…`和`/locales/en/…`)。</p><p id="bff5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">v2中相同的英国精炼商看起来像这样:</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="fc83" class="nh md iq nc b gy ni nj l nk nl">export default class ENMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {</span><span id="0b45" class="nh md iq nc b gy nm nj l nk nl">    patternBetween(): RegExp {</span><span id="6668" class="nh md iq nc b gy nm nj l nk nl">        return /^\s*(T|at|after|before|on|of|,|-)?\s*$/i;</span><span id="9f27" class="nh md iq nc b gy nm nj l nk nl">    }<br/>}</span></pre><p id="d842" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">新的抽象应该也使得定制Chrono更加容易。</p><p id="0391" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在v1中，这是自述文件中关于如何添加自定义解析器的示例:</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="a77c" class="nh md iq nc b gy ni nj l nk nl">var christmasParser = new chrono.Parser();<br/>christmasParser.pattern = function () { return /\bChristmas\b/i; };<br/>christmasParser.extract = function(text, ref, match, opt) { <br/>    return new chrono.ParsedResult({<br/>        ref: ref,<br/>        text: match[0],<br/>        index: match.index,<br/>        start: {    <br/>            day: 25, <br/>            month: 12, <br/>        }<br/>    });<br/>};</span><span id="8f65" class="nh md iq nc b gy nm nj l nk nl">var custom = new chrono.Chrono();<br/>custom.parsers.push(christmasParser);</span></pre><p id="f203" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，它是:</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="cf4c" class="nh md iq nc b gy ni nj l nk nl">const custom = chrono.casual.clone();<br/>custom.parsers.push({<br/>   pattern: () =&gt; { return /\bChristmas\b/i },<br/>   extract: () =&gt; {<br/>      return {<br/>         day: 25, month: 12<br/>      }<br/>   }<br/>});</span></pre><h1 id="4595" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">另一个重要的变化</h1><blockquote class="nn no np"><p id="a982" class="ks kt nq ku b kv kw jr kx ky kz ju la nr lc ld le ns lg lh li nt lk ll lm ln ij bi translated">&gt;…默认情况下，我们几乎没有理由尝试一次解析多种语言。这样做会导致一系列的极端情况，比如-#319-#318。多语言应用程序已经必须跟踪用户的语言，所以我不确定是否真的有必要尝试自动检测</p><p id="6199" class="ks kt nq ku b kv kw jr kx ky kz ju la nr lc ld le ns lg lh li nt lk ll lm ln ij bi translated">—本·奥宾，318号计时撰稿人</p></blockquote><p id="165e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">默认情况下，Chrono v1应用它支持的所有语言的所有日期模式/关键字，这被证明是一个糟糕的设计决策。</p><p id="0fef" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当Chrono只支持解析英语和日语时，它在一开始工作得很好。然而，在不得不解析更多语言(7种语言在<code class="fe mz na nb nc b">v1.3.7</code>中，感谢很多贡献者)之后，应用所有日期模式会导致很多不正确或意想不到的结果(例如，将德语缩写与英语混合)，并使维护和bug修复变得越来越困难。</p><p id="adac" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因此，从v2开始，Chrono将默认尝试只解析英语(美国国际)。</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="1923" class="nh md iq nc b gy ni nj l nk nl">chrono.parseDate('6/10/2018');    <br/>chrono.en.parseDate('6/10/2018');</span></pre><p id="db9b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当然，您可以通过同样易于使用的API在其他语言中使用Chrono解析。</p><pre class="kh ki kj kk gt nd nc ne nf aw ng bi"><span id="60cf" class="nh md iq nc b gy ni nj l nk nl">chrono.ja.parseDate('令和２年８月１０日');</span></pre></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="6af4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因此，现在我们可以以更可持续的方式支持多种语言或更多日期模式，欢迎您的任何贡献或反馈。</p><p id="398f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">请在Github 上查看<a class="ae kf" href="https://github.com/wanasit/chrono" rel="noopener ugc nofollow" target="_blank"> Chrono！</a></p></div></div>    
</body>
</html>