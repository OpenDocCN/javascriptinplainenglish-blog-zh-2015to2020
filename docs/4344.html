<html>
<head>
<title>How To Build Secure HTML Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建安全的HTML表单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-secure-html-forms-5e05086538c7?source=collection_archive---------12-----------------------#2020-12-04">https://javascript.plainenglish.io/how-to-build-secure-html-forms-5e05086538c7?source=collection_archive---------12-----------------------#2020-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae9ca7b85644ce61340edba1d74abd45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iW_xSkR9Wo_pDZOyagmehg.png"/></div></div></figure><p id="d2a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是系列文章的最后一篇，涵盖了为网络创建表单的各个方面。每篇文章都可以独立阅读，但我是按照最有意义的顺序写的。如果你没有读过其他的，我会鼓励你去看一看。</p><p id="3e9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本系列的最后一篇文章可以说是最重要的。它涵盖了安全。虽然其他文章主要集中在前端，但安全性超出了这个范围。我们必须考虑当前用户、其他用户和我们自己的安全性。因此，我们将研究从前端到后端以及更远的整个应用程序体系结构。</p><h1 id="ad96" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">加密流量(SSL)</h1><p id="fc1f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我们深入讨论之前，我将使用术语“SSL”来指代一种用于加密互联网流量的技术。从技术上讲，我指的是传输层安全性(TLS)，但“SSL”通常被使用并被理解为是同一意思。这就是为什么网站在URL栏上有一个绿色的小锁，以及为什么它们以“http ”( T2的“T3 ”)而不是“http”(没有“s”)开头。</p><p id="d092" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于几个原因，安装SSL证书是最佳做法，安全性是最重要的。拥有SSL证书可以让您加密客户端(您的用户)和服务器(您)之间传递的数据。</p><p id="27d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">窥探网络的黑客可以检查用户发送的数据包。如果没有SSL证书，这些数据很容易以纯文本形式读取。有了SSL证书，数据仍然可以被拦截，但它会以加密文本的形式发送，这几乎没有用。</p><ul class=""><li id="fe77" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">无SSL证书:用户名:<br/> <code class="fe mi mj mk ml b">NuggetTheMighty; password: ILoveSquirrels</code></li><li id="cb27" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">带有SSL证书(加密):<br/> <code class="fe mi mj mk ml b">SIUFJaYQNtsn+y73mfBYv3fVfjJ2GdHl4A7XnTJXxgUyd4/TrU3nN+g3aJ4BVXSJL/E7</code></li></ul><p id="ce03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在创建表单时尤其重要，因为表单的全部目的是发送数据。我们有责任保护用户的数据。</p><p id="f402" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取和安装SSL证书过去需要花费大量时间、金钱和一些技术知识。今天，许多托管服务将免费为您提供并安装证书。在许多情况下，他们甚至会自动这样做。</p><p id="0a4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的托管服务不提供SSL证书，还有其他选择:</p><ul class=""><li id="aca5" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><a class="ae mr" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>通过其DNS提供“灵活的”SSL。这很自由也很容易，但最好有自己的。</li><li id="e0a7" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">如果你的网站使用<a class="ae mr" href="https://wordpress.org/" rel="noopener ugc nofollow" target="_blank"> WordPress </a>，有几个<a class="ae mr" href="https://wordpress.org/plugins/ssl-zen/" rel="noopener ugc nofollow" target="_blank">插件</a>会在一分钟内通过<a class="ae mr" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">设置一个证书，让我们加密</a>。</li><li id="2017" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">您可以使用<a class="ae mr" href="https://certbot.eff.org/" rel="noopener ugc nofollow" target="_blank"> Certbot </a>通过<a class="ae mr" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>为您生成并安装一个证书。</li></ul><p id="6951" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您仍然没有SSL证书，因为您的主机没有提供证书，并且您没有对DNS或服务器代码的控制权…那么，您有点不走运。你将不得不切换主机，或者与你的服务器管理员交谈，或者做一些事情，因为这应该是当今任何项目的一个硬性要求。</p><h1 id="7a3c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">了解GET与POST</h1><p id="0052" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在之前的文章中，我说过您应该在表单中包含<code class="fe mi mj mk ml b">method</code>属性。<code class="fe mi mj mk ml b">method</code>属性告诉表单提交带有请求上的<code class="fe mi mj mk ml b">GET</code>或<code class="fe mi mj mk ml b">POST</code>HTTP头<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" rel="noopener ugc nofollow" target="_blank">的数据。如果您省略了<code class="fe mi mj mk ml b">method</code>，浏览器将默认使用<code class="fe mi mj mk ml b">GET</code>方法。这很重要，因为在<code class="fe mi mj mk ml b">GET</code>和<code class="fe mi mj mk ml b">POST</code>请求之间有很大的不同。</a></p><h1 id="bc6c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">获取请求</h1><p id="a4cc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用GET方法看一下下面的表单。当您提交表单时，数据将被提交给example.com(剧透一下，它实际上不做任何事情)。</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="742a" class="na kx iq ml b gy nb nc l nd ne">&lt;form action="https://example.com" method="GET" target="_blank"&gt;<br/>  &lt;label for="data"&gt;Send some sweet data&lt;/label&gt;<br/>  &lt;input id="data" name="some-sweet-data"/&gt;<br/>  &lt;button&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="daf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的关键是提交表单后的URL。虽然表单的<code class="fe mi mj mk ml b">action</code>是“example.com”，但是投稿网址是“example.com？一些甜蜜的数据 =blahblahblah。这些查询参数对应于表单输入名称属性。这就是使用<code class="fe mi mj mk ml b">GET</code>方法的表单传输数据的方式；查询字符串参数。</p><p id="5da9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将数据作为URL参数传递与安全性相关，原因有两个:</p><ol class=""><li id="8900" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nf mf mg mh bi translated">对于许多用户来说，URL会保存在浏览器的历史记录中。考虑一下，如果form通过查询参数发送信用卡号，而用户在公共计算机上，比如在图书馆。他们的私人数据可能会出现在浏览器的历史记录中，供下一个用户查看。</li><li id="333d" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">许多服务器保留接收流量的URL的日志。如果敏感信息出现在服务器日志文件中，任何有权访问这些文件的人都可以看到这些数据。</li></ol><h1 id="57e2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">发布请求</h1><p id="b9ad" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">幸运的是，您可以使用<code class="fe mi mj mk ml b">POST</code>方法来发送数据，而不使用查询参数。让我们看看同样的表单，但是使用<code class="fe mi mj mk ml b">POST</code>方法:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="d2db" class="na kx iq ml b gy nb nc l nd ne">&lt;form action="<a class="ae mr" href="https://example.com" rel="noopener ugc nofollow" target="_blank">https://example.com</a>" method="POST" target="_blank"&gt;<br/>  &lt;label for="data"&gt;Send some sweet data&lt;/label&gt;<br/>  &lt;input id="data" name="some-sweet-data"/&gt;<br/>  &lt;button&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="1b38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意提交这个表单也加载了example.com，但是这次查询参数中没有任何内容。这是因为在<code class="fe mi mj mk ml b">POST</code>请求中，数据是作为<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Request" rel="noopener ugc nofollow" target="_blank">请求</a>主体的一部分发送的。这使得意外泄露私人信息变得更加困难。</p><p id="d071" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据经验，出于上面列出的原因，我在所有表单上使用<code class="fe mi mj mk ml b">POST</code>方法。这个规则的少数例外是，如果我想让用户将他们提交的表单加入书签，或者与其他人共享。例如，查看将搜索提交给<a class="ae mr" href="https://duckduckgo.com/" rel="noopener ugc nofollow" target="_blank"> DuckDuckGo </a>的表单:</p><p id="e0b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提交表单后，DuckDuckGo将在URL中打开一个查询参数。然后，如果你愿意，你可以复制这个网址并与同事分享，或者将它加入书签以备后用。除非您正在处理敏感数据，否则记住这种模式非常有用。</p><h1 id="f845" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">防止垃圾邮件</h1><p id="e580" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">没有人喜欢垃圾邮件。我承认这和安全没什么关系。这里值得一提的是，任何时候我们向公共网页添加表单，都是在向垃圾邮件敞开大门。表格本来就是要填写的，但有时出于邪恶的原因，它们会被某人或某事填写。</p><p id="5699" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们如何预防呢？</p><h1 id="016d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">蜜罐</h1><p id="4dca" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一种防止垃圾邮件的基本方法叫做“蜜罐”，这个概念非常简单。如果您在表单中包含一个隐藏的输入，您就知道一个真正的人永远不会修改那个字段。因此，如果提交的表单包含该输入的数据，您可以认为它是一个机器人，并拒绝提交。</p><p id="b744" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，输入可能是这样的:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="63eb" class="na kx iq ml b gy nb nc l nd ne">&lt;input name="honeypot" class="visually-hidden" tabindex="-1" autocomplete="off"&gt;</span></pre><ul class=""><li id="6109" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><code class="fe mi mj mk ml b">name</code>很重要，所以你知道在后端要检查什么。我用了“蜜罐”,但大多数人会建议称它为听起来更合法的东西。</li><li id="5533" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">我使用了一个<code class="fe mi mj mk ml b">visually-hidden</code>类来隐藏用户的输入(你可以在关于<a class="ae mr" href="https://austingil.com/how-to-build-html-forms-right-accessibility/" rel="noopener ugc nofollow" target="_blank">可访问性</a>或<a class="ae mr" href="https://austingil.com/build-html-forms-right-styling/" rel="noopener ugc nofollow" target="_blank">样式</a>的文章中了解更多)。机器人仍然会看到它。</li><li id="76a9" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated"><code class="fe mi mj mk ml b">tabindex="-1"</code>从键盘导航中移除输入。这对辅助技术用户来说很重要(在<a class="ae mr" href="https://austingil.com/how-to-build-html-forms-right-accessibility/" rel="noopener ugc nofollow" target="_blank">可访问性文章</a>中有更多相关信息)。</li><li id="8f18" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">最后，我们想防止浏览器自动填充输入，所以我们禁用了<code class="fe mi mj mk ml b"><a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete" rel="noopener ugc nofollow" target="_blank">autocomplete</a></code>。</li></ul><p id="1548" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于这种方法的好消息是，它可以花费很少的时间和精力来实现。坏消息是，许多机器人足够聪明，可以判断输入何时是蜜罐，并跳过它。但是，即使这阻止了10%的垃圾邮件，这种努力也是值得的。</p><h1 id="7426" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安全挑战</h1><p id="fbde" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">防止垃圾邮件的一个更强大的方法是加入一个挑战，用户需要完成这个挑战来证明他们是人类。一些基本的例子是输入，要求你完成一个简单的数学问题，如“10 + 6是多少？”。只有具有正确答案的数据才会被接受。</p><p id="b2a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的问题是，再一次，机器人可以足够复杂来解决这些挑战。</p><p id="a06a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">垃圾邮件困境是一个不断演变的猫捉老鼠的游戏，随着时间的推移，挑战变得越来越复杂。首先是数学问题，然后检测图像中的字母或数字。</p><p id="4fbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可能最熟悉的安全挑战是<a class="ae mr" href="https://developers.google.com/recaptcha/" rel="noopener ugc nofollow" target="_blank"> reCAPTCHA </a>。这是谷歌现在拥有的一项服务，向用户展示一堆他们需要识别的图像。效果非常好，而且免费。如果你担心用户隐私，你可能不想使用谷歌产品。好消息是，还有另一项名为<a class="ae mr" href="https://www.hcaptcha.com/" rel="noopener ugc nofollow" target="_blank"> hCaptcha </a>的服务，它是一种上门服务。安全挑战技术并非没有缺点:</p><ul class=""><li id="989f" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">它们的实现更具技术性。</li><li id="80ff" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">您可能需要依赖第三方服务。</li><li id="9c87" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">它们会对<a class="ae mr" href="https://austingil.com/build-html-forms-right-user-experience/" rel="noopener ugc nofollow" target="_blank">用户体验</a>产生负面影响。</li></ul><h1 id="b021" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">WAF和API</h1><p id="a23f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果垃圾邮件成为您表单中的一个主要问题，您可能需要考虑寻求第三方服务。</p><p id="02c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种选择是建立一个<a class="ae mr" href="https://en.wikipedia.org/wiki/Web_application_firewall" rel="noopener ugc nofollow" target="_blank">网络应用防火墙(WAF) </a>。WAF位于您的服务器前面，首先阻止不良行为者访问您的网站。</p><p id="1e91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mr" href="https://www.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>是我的首选供应商。他们在DNS级别工作，有一个非常慷慨的免费层。我在我拥有的每个域名上都使用这个，到目前为止，我还没有遇到任何垃圾邮件的问题。</p><p id="74f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种选择是使用API服务来测试传入的表单提交。我知道的最常见的是<a class="ae mr" href="https://akismet.com/development/api/" rel="noopener ugc nofollow" target="_blank"> Akismet </a>，它是<a class="ae mr" href="https://automattic.com/" rel="noopener ugc nofollow" target="_blank">automatic</a>产品的一部分(他们制造<a class="ae mr" href="https://wordpress.org/" rel="noopener ugc nofollow" target="_blank"> WordPress </a>)。我在一些WordPress网站上用过这个，可以说效果不错。如果你不使用WordPress，他们也有一个API。CSS Tricks有<a class="ae mr" href="https://css-tricks.com/spam-detection-apis/" rel="noopener ugc nofollow" target="_blank">一篇文章</a>，如果你对其他选项感兴趣，这篇文章会更深入地介绍第三方垃圾API。</p><p id="f685" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不相信任何垃圾邮件预防技术是100%有保证的。这个领域在不断发展，垃圾邮件发送者每年都变得更加先进。然而，这也不是我想要解决的那种问题，直到我有了它。在这种情况下，你可以从一些唾手可得的果实开始，逐步找到一个更复杂的解决方案。</p><p id="a10b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到工作量、用户体验、成本和其他因素，我会这样做:</p><ol class=""><li id="cbdb" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nf mf mg mh bi translated">在您DNS(或其他一些WAF)上安装Cloudflare</li><li id="b94c" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">使用蜜罐</li><li id="7edc" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">集成垃圾邮件检测API</li><li id="d02b" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">设置hCaptcha(出于用户体验的考虑，这是最后一招)</li></ol><h1 id="322b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">验证数据</h1><p id="1588" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">验证是指当您强制您接收的数据与您期望的相匹配时。例如，如果我注册一个新用户，我想确保他们提供的电子邮件确实是一个电子邮件地址。</p><p id="5970" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常有两个地方可以验证数据:客户端和服务器端。</p><h1 id="ecd5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">客户端验证</h1><p id="4b68" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">前端的验证通常用HTML属性或JavaScript来完成。</p><p id="1683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果我们想要一个输入，它必须以最大长度的电子邮件形式填写，我们可以这样实现它:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="df07" class="na kx iq ml b gy nb nc l nd ne">&lt;form action="example.com" method="POST"&gt;<br/>  &lt;label for="email"&gt;Email<br/>  &lt;input id="email" name="email" type="email" required maxlength="20"&gt;<br/>  <br/>  &lt;button type="submit"&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="516e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户试图在不满足我们要求的情况下提交表单，浏览器会阻止并向用户显示一条错误消息。</p><p id="1430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们不想显示内置的验证UI，我们可以在表单中添加<code class="fe mi mj mk ml b"><a class="ae mr" href="https://www.w3schools.com/TAGs/att_form_novalidate.asp" rel="noopener ugc nofollow" target="_blank">novalidate</a></code>属性。这将阻止默认的验证逻辑，我们可以用自己的逻辑替换它。</p><p id="7e93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种方法是使用表单的<code class="fe mi mj mk ml b">checkValidity</code>方法来查看表单是否有任何无效输入。如果表单无效，我们可以对每个输入进行循环，并查看<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/ValidityState" rel="noopener ugc nofollow" target="_blank"> ValidityState API </a>到底违反了什么规则:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="b731" class="na kx iq ml b gy nb nc l nd ne">const form = document.querySelector('form');<br/>form.addEventListener('submit', (event) =&gt; {<br/>  const isValid = form.checkValidity()<br/>  <br/>  if (!isValid) {<br/>    const inputs = form.querySelectorAll('input')<br/>    <br/>    for (const input of inputs) {<br/>      // Do some validation logic with the input<br/>      console.log(input.validity)<br/>    }<br/>  }<br/>})</span></pre><p id="a92a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ml b">ValidityState</code>非常方便，因为它将为我们提供一个对象，其中每个键/值对代表一个验证属性及其有效性状态:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="411d" class="na kx iq ml b gy nb nc l nd ne">{<br/>  badInput: Boolean<br/>  customError: Boolean<br/>  patternMismatch: Boolean<br/>  rangeOverflow: Boolean<br/>  rangeUnderflow: Boolean<br/>  stepMismatch: Boolean<br/>  tooLong: Boolean<br/>  tooShort: Boolean<br/>  typeMismatch: Boolean<br/>  valid: Boolean<br/>  valueMissing: Boolean<br/>}</span></pre><p id="8c9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这会让我们走得很远。我们可以显示每个无效属性的特定错误消息，或者修改输入的类名(事实上，<a class="ae mr" href="https://vuetensils.stegosource.com/" rel="noopener ugc nofollow" target="_blank"> Vuetensils </a>就是这样进行验证的)。</p><p id="8d52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不能对你的实现做任何假设，所以你必须从这里开始。如果你需要更健壮的东西，你可以使用NPM 上<a class="ae mr" href="https://www.npmjs.com/search?q=validation&amp;ranking=popularity" rel="noopener ugc nofollow" target="_blank">众多JavaScript验证库中的一个。</a></p><p id="90d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论是您自己的实现还是第三方库，客户端都有一个主要缺陷。</p><p id="c309" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任何技术用户都可以修改HTML验证属性，或者通过在表单外部发出HTTP请求来完全绕过客户端验证。这就是为什么<strong class="ka ir">永远不要相信来自客户端</strong>的数据是很重要的。让我重复一遍。</p><blockquote class="ng nh ni"><p id="1366" class="jy jz nj ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">永远不要相信来自客户端的数据！</em></p></blockquote><p id="214a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">客户端验证应该通过提供即时反馈来改善用户体验。它不应该是保护您的应用程序的唯一防线。</p><h1 id="fe5a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">服务器端验证</h1><p id="1b81" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">因为我们不能信任来自客户端的数据，所以我们应该总是在服务器端验证数据。对于简单的应用程序，您可以创建自己的验证逻辑，但是对于严肃的项目，我建议使用专用的库。图书馆之所以伟大，有几个原因:</p><ol class=""><li id="66eb" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nf mf mg mh bi translated">验证是一个已经解决的问题。没有必要重新发明轮子。</li><li id="e062" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">库通常比定制实现工作得更好，因为它们已经在更多的项目中进行了测试。</li><li id="18c0" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">一个库可以满足未来的验证需求。它们可以提供我们现在不需要但以后可能需要的功能。</li><li id="efd6" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">对于服务器端项目，我们不需要担心捆绑包的大小。添加更多依赖项对客户端的影响没有那么大。</li></ol><p id="8901" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前我首选的验证库是<a class="ae mr" href="https://www.npmjs.com/package/yup" rel="noopener ugc nofollow" target="_blank">是的</a>。我<em class="nj">爱</em>它！</p><p id="da86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何完成服务器端验证取决于你自己。在任何情况下，都需要考虑一些与前端相关的重要事项。当您在服务器上遇到验证错误时，请考虑以下几点:</p><ul class=""><li id="a6b8" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">用适当的<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank"> HTTP状态代码</a>(大多数情况下为<code class="fe mi mj mk ml b">400</code>)进行响应。</li><li id="cdd5" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">提供某种关于什么是无效的明确信息。</li><li id="3e33" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">如果有很多东西需要验证(比如JSON对象)，那么验证整个包。对于第一个无效值，不要立即抛出错误。回答所有的验证问题，以避免多次请求。</li><li id="db29" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">提供唯一的错误代码(即<code class="fe mi mj mk ml b">{ error: INVALID_EMAIL }</code>)可以帮助前端为错误消息创建自己的字典。</li></ul><h1 id="35c1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">整理/逸出数据</h1><p id="8cf7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">像验证一样，数据净化(也称为转义)是一种属于服务器的实践。净化数据是指转换或删除危险的数据。它不同于验证，因为你不会拒绝输入。你修改它，所以它是安全的使用。</p><p id="fa61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设您有一个要求输入名字和姓氏的表单。用户可以输入以下内容:</p><p id="6b95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">名:<code class="fe mi mj mk ml b">l33t; DROP TABLE user</code> <br/>姓:<code class="fe mi mj mk ml b">&lt;script&gt;alert('h4x0r')&lt;/script&gt;</code></p><p id="d190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个人很可能是一个不应该被信任的骗子。此外，他们的数据可能会让你遭受两种类型的攻击:<a class="ae mr" href="https://en.wikipedia.org/wiki/SQL_injection" rel="noopener ugc nofollow" target="_blank"> SQL注入</a>和<a class="ae mr" href="https://en.wikipedia.org/wiki/Cross-site_scripting" rel="noopener ugc nofollow" target="_blank">跨站脚本(XSS) </a>。</p><p id="9933" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您尝试将用户的名字原样添加到数据库中，您可能会删除整个<code class="fe mi mj mk ml b">user</code>表。你好SQL注入。如果您按原样保存姓氏，您的数据库会很好，但是如果您将姓氏添加到HTML中，它可能会将任意JavaScript注入到页面中。示例中的JavaScript是无害的，但是如果它传输了用户机密呢？哦，XSS攻击。</p><p id="2f85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本系列侧重于HTML表单，所以我们不会深入XSS或SQL注入。为了深入预防，我将推荐<a class="ae mr" href="https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank"> XSS </a>和<a class="ae mr" href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank"> SQL注入</a>的<a class="ae mr" href="https://cheatsheetseries.owasp.org/" rel="noopener ugc nofollow" target="_blank"> OWASP备忘单系列</a>。</p><p id="6be1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想强调的一点是，我们可以通过净化数据来避免上述两种情况。我的建议还是那句话，依靠专门与数据库对话的库。</p><p id="ee05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于SQL数据库，我建议使用一个<a class="ae mr" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank">对象关系映射(ORM) </a>库，而不是编写原始SQL。其中许多会自动清理数据。对于JavaScript项目，我非常喜欢<a class="ae mr" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex.js </a>和<a class="ae mr" href="https://vincit.github.io/objection.js/" rel="noopener ugc nofollow" target="_blank"> Objection.js </a>。</p><p id="9a24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当您向HTML添加用户生成的内容时，您必须净化字符串以避免XSS攻击。我以前用过的一个库是XSS的。您可以在几个不同的地方整理内容:</p><ul class=""><li id="bccf" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">在将它保存到数据库之前。</li><li id="9f61" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">从你的数据库中读取后。</li><li id="1931" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">在将它写入HTML文档之前。</li></ul><p id="d2b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最安全的地方是在将内容添加到HTML文档之前对其进行整理。然而，我喜欢遵循<a class="ae mr" href="https://en.wikipedia.org/wiki/Zero_Trust_Networks" rel="noopener ugc nofollow" target="_blank">零信任</a>模式，只假设最坏的情况。在这种情况下，最好三个都做。说我多疑吧。</p><p id="335c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样值得一提的是，使用前端框架来创建HTML文档也会有所帮助。许多框架，如<a class="ae mr" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>和<a class="ae mr" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>会在将内容添加到页面之前自动对其进行转义，除非您明确告诉它们不要这样做。</p><h1 id="f3b6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">正确处理jwt</h1><p id="9450" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae mr" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web Tokens (JWT) </a>这是一项非常酷的技术，旨在解决向多个服务发送数据的现代挑战，同时避免使用集中式服务来检查数据的有效性。</p><p id="6446" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，我们可以将用户的身份验证细节存储在JWT中，并且我们可以确定令牌的内容不能被更改。然后，我们可以将这个令牌发送给一个API，该API不需要检查任何中央数据库来了解哪个用户发出了请求。API可以简单地打开JWT，查看用户的身份验证细节。太棒了。</p><p id="4f68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">身份验证是目前使用jwt的主要方式之一。然而，jwt也有一些明显的缺点:</p><ul class=""><li id="3d86" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">JWT的内容对任何获得访问权限的人来说都是不隐藏的。</li><li id="0702" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">jwt可以有一个截止日期，但是它们不能以编程方式失效。</li></ul><p id="a9b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这两个原因，我们在与JWT合作时应该特别深思熟虑。不幸的是，我看到的大多数教程都指导开发人员创建具有较长有效期的认证令牌(JWT)并将保存令牌存储在<code class="fe mi mj mk ml b">localStorage</code>中。我对此有异议。</p><p id="88f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在客户端(<code class="fe mi mj mk ml b"><a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">localStorage</a></code>、<code class="fe mi mj mk ml b"><a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" rel="noopener ugc nofollow" target="_blank">sessionStorage</a></code>、)的JWT中存储敏感数据的问题。)在于页面上的任何JavaScript都可以访问它。它可能是一个跨站点脚本，也可能是任何不是我们自己编写的脚本:库和框架、来自公共cdn的资产、第三方代码片段，甚至是浏览器扩展。</p><p id="b258" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的另一个问题与令牌过期有关。如果一个具有“管理员”角色的用户登录到我们的应用程序，他们将收到一个auth token，表明他们是“管理员”。因此，他们可以执行与“管理”相关的操作(如创建或删除其他用户)，直到令牌丢失或过期。如果我们的auth token有一周的到期时间，那么理论上我们所做的任何更改都需要一周才能完成。如果“ADMIN”角色是一个人为错误，而我们实际上打算将“GUEST”角色分配给这个用户，那该怎么办？你看出问题了吗？</p><p id="d4d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这让我想到了处理JWT问题的基本原则:</p><ol class=""><li id="d676" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv nf mf mg mh bi translated">任何包含敏感/私人/认证数据(用户ID、个人识别信息等)的JWT都只能存储在内存中。</li><li id="cafd" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv nf mf mg mh bi translated">每个JWT都应该有一个截止日期。任何用于<strong class="ka ir">认证</strong>或<strong class="ka ir">授权</strong>(‘auth’)的JWT都应该有一个非常短的有效期(即15分钟、24小时等。).</li></ol><p id="3370" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些规则解决了我们的安全问题，但也给我们带来了一些用户体验挑战。通过只在内存中存储身份验证令牌，用户将不得不在每次加载应用程序时登录。如果我们的身份验证令牌使用15分钟的过期时间，那么用户将有效地每15分钟“注销”一次。</p><p id="3924" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由<a class="ae mr" href="https://twitter.com/VladimirNovick" rel="noopener ugc nofollow" target="_blank"> Vladimir Novick </a>撰写的优秀文章《<a class="ae mr" href="https://hasura.io/blog/best-practices-of-using-jwt-with-graphql/" rel="noopener ugc nofollow" target="_blank">在前端客户端(GraphQL) </a>上处理jwt的终极指南》很好地解释了这些问题的解决方案。这有点复杂，但我会尽量用一个例子来简化事情:</p><ul class=""><li id="3b98" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">您创建了两条身份验证路由。一个用于登录应用程序(<code class="fe mi mj mk ml b">/login</code>)，一个用于生成新的认证令牌(<code class="fe mi mj mk ml b">/refresh</code>)。</li><li id="71b3" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">当用户登录时，返回包含授权请求所需的任何数据的auth token(例如<code class="fe mi mj mk ml b">{userId: 5, role: 'admin'}</code>)。它的有效期很短(例如15分钟)。</li><li id="c11d" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">登录响应还返回一个刷新令牌。该令牌仅包含重新创建新的身份验证令牌所需的信息(例如，<code class="fe mi mj mk ml b">{userId: 5}</code>)。它可以有一个更长的有效期，以匹配您希望用户保持“登录”的时间。假设一周。</li><li id="1c8d" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">用户通过将他们的凭证发送到登录路由来登录，作为回报，他们获得一个auth令牌和一个refresh令牌。</li><li id="ccee" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">auth令牌保存在内存中，refresh令牌可以放在<code class="fe mi mj mk ml b">localStorage</code>中(如果有人知道我的用户ID，这通常并不重要)。</li><li id="3e7c" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">登录后，我们还将时间间隔设置为14分钟(小于身份验证令牌到期时间)。在这个时间间隔，我们将刷新令牌发送到<code class="fe mi mj mk ml b">/refresh</code>路由，并将其交换为新的auth令牌。</li><li id="b3c0" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">这个新的身份验证令牌可以替换旧的身份验证令牌，并且用户保持“登录”。</li><li id="a5b9" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">最后一步是确保在应用程序启动时检查<code class="fe mi mj mk ml b">localStorage</code>中现有的刷新令牌。如果有刷新令牌，我们在应用程序加载之前点击<code class="fe mi mj mk ml b">/refresh</code>路径。这样，我们可以在多个会话中保持用户“登录”。</li></ul><p id="d79f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个JWT登录流程相当复杂，但我希望我做到了。要完全描述它需要一篇专门的文章，所以我邀请你阅读我上面提到的文章。太棒了。</p><h1 id="12cb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">抵御CSRF袭击</h1><p id="267c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank">跨站点请求伪造(CSRF) </a>攻击理解起来有点复杂，但它们的工作原理是诱骗用户代表攻击者发出请求。一个理论上的例子可能是最好的解释。</p><p id="904e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您的银行有一个表单，可以从您的帐户向另一个用户的帐户汇款。该表单通过向某个端点(如<code class="fe mi mj mk ml b">yourbank.com/send-money</code>)发出一个<code class="fe mi mj mk ml b">POST</code>请求来发送资金，该请求带有两个数据值:</p><ul class=""><li id="c165" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><code class="fe mi mj mk ml b">to</code>:收款的用户ID</li><li id="d769" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated"><code class="fe mi mj mk ml b">amount</code>:你要发的金额(很明显)。</li></ul><p id="7aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于安全原因，这只有在您登录的情况下才有效(显然也是如此)。服务器可以通过<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" rel="noopener ugc nofollow" target="_blank">HTTP cookie</a>认证请求。</p><p id="ec70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个假设的场景中，这个表单可能容易受到CSRF攻击。如果攻击者对银行后端的工作方式有足够的了解，他们可以创建一个伪装成按钮的表单。</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="b0e8" class="na kx iq ml b gy nb nc l nd ne">&lt;form action="<a class="ae mr" href="http://example.com/send-money" rel="noopener ugc nofollow" target="_blank">http://example.com/send-money</a>" method="POST"&gt;</span><span id="2bcb" class="na kx iq ml b gy nn nc l nd ne">&lt;input type="hidden" name="to" value="123456"/&gt;<br/>  &lt;input type="hidden" name="amount" value="100"/&gt;</span><span id="9e85" class="na kx iq ml b gy nn nc l nd ne">&lt;button type="submit"/&gt;Click for Kittens!!!&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="aced" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意上面的表单是如何利用几个输入值来设置<code class="fe mi mj mk ml b">to</code>和<code class="fe mi mj mk ml b">amount</code>数据的。对于一个不知情的用户来说，这个表单在视觉上会呈现为一个承诺小猫的按钮(邪恶，我知道)。</p><p id="7e66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您点击此按钮，它会将表单提交到您银行的<code class="fe mi mj mk ml b">/send-money</code>端点，如果您已经在浏览器中使用有效的cookie登录，该cookie将与表单一起发送。这足以诱使用户向其他人汇款。</p><p id="0201" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样值得注意的是，这种攻击可能以多种方式发生。它可以存在于一个随机的网站上、电子邮件中、浏览器扩展中等等。如果启用了JavaScript，这很有可能，它甚至可以在没有任何用户交互的情况下发生。那么，我们如何防范这种情况呢？</p><h1 id="e012" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">CSRF代币</h1><p id="40c6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">防止这种情况发生的一种方法是使用“CSRF代币”。这些是在服务器上生成的唯一值，只有服务器知道。它们被提供给表单，以便用作隐藏输入的值，如下所示:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="45db" class="na kx iq ml b gy nb nc l nd ne">&lt;input type="hidden" name="csrf-token" value="d4f3e48f-7ae3-4398-ba24-0dca81383e6c"&gt;</span></pre><p id="10f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">包含CSRF令牌的输入就绪后，可以提交表单，后端可以检查令牌的有效性。任何包含有效令牌的表单都可以继续请求。任何带有无效或缺失令牌的表单都会被拒绝。</p><p id="a854" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果黑客想要创建与上面相同的表单，他们将无法生成自己的CSRF令牌(假设您有验证令牌的方法)。</p><p id="7844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里棘手的部分是以别人无法做到的方式获得CSRF令牌。如果您在同一台服务器上创建表单，那么生成一个令牌并将其弹出到HTML中是非常容易的。如果您正在使用API，那么您需要一个提供有效CSRF令牌的路径。您应该将此路由配置为只允许来自已知域的流量。这样，你可以从一个有效的域请求一个令牌，但是黑客将不能。</p><h1 id="91af" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">验证请求来源</h1><p id="9821" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">防止CSRF攻击的一个基本但聪明的方法是检查请求的和/或报头。它们包含发出请求的URL。</p><p id="c782" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些头文件最好的一点是它们是由浏览器设置的，不能以编程方式修改。所以别开玩笑了。如何访问这些头取决于您使用的技术。例如，如果我正在使用<a class="ae mr" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>，我可以创建一个看起来像这样的<a class="ae mr" href="https://expressjs.com/en/guide/using-middleware.html#using-middleware" rel="noopener ugc nofollow" target="_blank">中间件</a>:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="d989" class="na kx iq ml b gy nb nc l nd ne">app.use((request, response, next) =&gt; {<br/>  const allowedHosts = new Set([request.headers.host]);<br/>  let referer = request.headers.host;<br/>  let origin = null;<br/><br/>  if (request.headers.referer) {<br/>    referer = new URL(request.headers.referer).host;<br/>  }<br/>  if (request.headers.origin) {<br/>    origin = new URL(request.headers.origin).host;<br/>  }<br/><br/>  if (!allowedHosts.has((origin || referer))) {<br/>    return next(new Error('Unallowed origin'));<br/>  }<br/><br/>  next();<br/>});</span></pre><ul class=""><li id="aa71" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">创建所有允许的主机的列表(在我们的例子中，只有我们相同的应用程序域是有效的)</li><li id="ef9c" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">检查<code class="fe mi mj mk ml b">referer</code>和/或<code class="fe mi mj mk ml b">origin</code>接头是否存在。如果有，获取他们的网址</li><li id="650d" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">如果<code class="fe mi mj mk ml b">origin</code>和<code class="fe mi mj mk ml b">referer</code>URL都不在我们允许的主机列表中，我们拒绝该请求。</li></ul><p id="0b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个代码片段是一个很好的例子，但是出于生产目的，您可能需要更健壮的代码。无论如何，它可以用几行代码实现，这是我一直欣赏的。</p><p id="5bde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于CSRF攻击的更多细节，OWASP有一篇优秀的文章有更多的描述。他们的备忘单系列中还有一篇文章，提供了更多防止CSRF攻击的细节。事实上，它们是与安全相关的极好资源，我强烈建议你花些时间通读它们的内容。</p><p id="3384" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我的JavaScript开发伙伴来说，<a class="ae mr" href="https://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>有一篇好文章<a class="ae mr" href="https://auth0.com/blog/cross-site-request-forgery-csrf/" rel="noopener ugc nofollow" target="_blank">专门针对Node.js开发和CSRF预防。</a></p><h1 id="16ab" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安全Cookies</h1><p id="7a62" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如上所述，CSRF攻击使用cookies作为其攻击媒介的一部分。因此，防范基于cookie的攻击的一个好方法是确保我们的cookie是安全的，这是有道理的。</p><p id="ffb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于那些不熟悉的人来说，cookie是一个HTTP头。更具体地说，cookies被分配了标题，看起来像这样:<code class="fe mi mj mk ml b">Set-Cookie: &lt;name&gt;=&lt;value&gt;; &lt;attributes&gt;</code>。</p><p id="8566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个例子可能是这样的:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="601c" class="na kx iq ml b gy nb nc l nd ne">Set-Cookie: sessionId=38afes7a8; Domain=example.com; Max-Age=2592000; Secure; HttpOnly; SameSite=strict;</span></pre><p id="26d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与安全性相关的一些属性包括:</p><ul class=""><li id="90b3" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><code class="fe mi mj mk ml b">Expires</code>和<code class="fe mi mj mk ml b">Max-Age</code>:允许您设置cookie有效期的时间限制。</li><li id="d25e" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">:确保仅在通过安全(HTTPS)连接发出请求时才发送cookie。对防止<a class="ae mr" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" rel="noopener ugc nofollow" target="_blank">中间人攻击</a>有用。</li><li id="b729" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">:防止JavaScript访问cookie。有助于防止XSS袭击。</li><li id="0332" class="lz ma iq ka b kb mm kf mn kj mo kn mp kr mq kv me mf mg mh bi translated">:可以设置为仅在请求来源与目标域匹配时发送cookies。有助于防止CSRF袭击。</li></ul><p id="cc36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些都是我认为与安全性相关的属性。但是如您所见，只有<code class="fe mi mj mk ml b">SameSite</code> cookie属性与CSRF攻击相关。这是一个相对较新的web平台，对于安全性来说是一个好消息。然而，因为它有点新，所以在旧的浏览器上不会有效。</p><p id="16b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于使用cookies的信息，我推荐<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" rel="noopener ugc nofollow" target="_blank"> MDN docs </a>。</p><h1 id="fedb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结束语</h1><p id="75c1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我意识到这篇文章中的一些内容与写作形式无关。这里的一些建议根本不是直接相关的形式。不过，我希望你同意这是相关信息。当我们为web编写表单时，我们必须记住这些事情。即使我们不是实现这些变化的人，我们也应该从整体上考虑我们的软件，以保证我们自己和我们用户的安全。</p><p id="8d28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章花了大约20个小时来研究和创作。向我展示你喜欢它的最好方式是<a class="ae mr" href="https://twitter.com/share?via=Stegosource" rel="noopener ugc nofollow" target="_blank">分享它</a>。你也可以<a class="ae mr" href="https://austingil.com/newsletter/" rel="noopener ugc nofollow" target="_blank">注册我的时事通讯</a>或者<a class="ae mr" href="https://twitter.com/Stegosource" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>如果你想第一个知道什么时候有新文章的话。</p><p id="1a64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您错过了任何其他文章，请考虑阅读它们。我想你也会喜欢的。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="6e7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nj">原载于</em><a class="ae mr" href="https://austingil.com/how-to-build-html-forms-right-security/" rel="noopener ugc nofollow" target="_blank"><em class="nj">https://austingil.com</em></a><em class="nj">。</em></p></div></div>    
</body>
</html>