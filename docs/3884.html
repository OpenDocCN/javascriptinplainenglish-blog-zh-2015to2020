<html>
<head>
<title>How to Control ‘this’ Better in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中更好地控制“this”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-control-this-better-in-javascript-dcacd54bcf97?source=collection_archive---------5-----------------------#2020-10-31">https://javascript.plainenglish.io/how-to-control-this-better-in-javascript-dcacd54bcf97?source=collection_archive---------5-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="328d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">使用call()、apply()和bind()方法</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de883975cae19664406c7501b24a293d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGyLBAYZgSEWjeEelc5BNw.jpeg"/></div></div></figure><p id="f6d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中处理<code class="fe ln lo lp lq b">this</code>很棘手。</p><p id="b58f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时，你使用<code class="fe ln lo lp lq b">this</code>，但它不是你期望的<code class="fe ln lo lp lq b">this</code>。很困惑，对吧？</p><p id="e5b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么JavaScript为我们提供了三种方法来更好地控制<code class="fe ln lo lp lq b">this</code>。它们是<code class="fe ln lo lp lq b">call()</code>、<code class="fe ln lo lp lq b">apply()</code>和<code class="fe ln lo lp lq b">bind()</code>。</p><p id="693e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它们都是JavaScript中预定义的方法。它们被链接到函数对象原型，这意味着一旦你定义了一个函数，它就有权限访问所有这些方法。</p><p id="1f09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看他们如何帮助我们对付<code class="fe ln lo lp lq b">this</code>。</p><h1 id="7d87" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">函数.原型.调用()</h1><p id="a5f3" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">语法:<code class="fe ln lo lp lq b">func.apply(thisArg, arg1, arg2, arg3,…)</code></p><p id="887e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">call()</code>是做什么的？</p><p id="4f5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以从它的名字猜到，它调用函数。</p><p id="7752" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="980c" class="ms ls iq lq b gy mt mu l mv mw">function sayHello() {<br/>  console.log(‘Hello’);<br/>}</span><span id="08f4" class="ms ls iq lq b gy mx mu l mv mw">sayHello.call(); // Hello</span></pre><p id="a1a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单吧？</p><p id="8b5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是为什么要写整个<code class="fe ln lo lp lq b">sayHello.call()</code>而我们可以只写<code class="fe ln lo lp lq b">sayHello()</code>？</p><p id="1b33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只是举个例子。我不认为有人会那样使用<code class="fe ln lo lp lq b">call()</code> <strong class="kt ir"> </strong>。</p><p id="ee90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了理解使用<code class="fe ln lo lp lq b">call()</code>的正确方法，请看下面的例子:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="46fc" class="ms ls iq lq b gy mt mu l mv mw">let book = {<br/>  title: ‘JavaScript Best Practices’<br/>}</span><span id="365a" class="ms ls iq lq b gy mx mu l mv mw">function showAuthorBook(author) {<br/>  console.log(`${author} is the author of “${this.title}”`);<br/>}</span></pre><p id="7c82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们正常调用<code class="fe ln lo lp lq b">showAuthorBook()</code>方法，<code class="fe ln lo lp lq b">this.title</code>将是未定义的，因为函数没有<code class="fe ln lo lp lq b">title</code>属性。</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="8188" class="ms ls iq lq b gy mt mu l mv mw">showAuthorBook(‘Amy’); Amy is the author of “undefined”</span></pre><p id="58c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，这个问题可以通过下面的方法解决:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="d011" class="ms ls iq lq b gy mt mu l mv mw">showAuthorBook.call(book, ‘Amy’); // Amy is the author of “JavaScript Best Practices”</span></pre><p id="0a10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生了什么？</p><p id="067c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">call()</code>方法允许为对象y分配和调用属于对象X的函数</p><p id="3c4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用<code class="fe ln lo lp lq b">call()</code>，您将<code class="fe ln lo lp lq b">this</code>的新值赋予函数，这样您就可以编写一次函数，然后在另一个对象中继承它。这就像改变一个函数的上下文。</p><p id="cbe2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，<code class="fe ln lo lp lq b">showAuthorBook()</code>函数是用一个给定的<code class="fe ln lo lp lq b">this</code>(即<code class="fe ln lo lp lq b">book</code>对象)和实际函数的参数<code class="fe ln lo lp lq b">Amy</code>调用的。现在，<code class="fe ln lo lp lq b">showAuthorBook()</code>函数中的上下文指向<code class="fe ln lo lp lq b">book</code>对象，而不再是函数。所以，<code class="fe ln lo lp lq b">showAuthorBook()</code>功能中的<code class="fe ln lo lp lq b">this.title</code>其实就是<code class="fe ln lo lp lq b">book.title</code>。</p><p id="9e38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样做的好处是，您不需要为<code class="fe ln lo lp lq b">book</code>对象重写另一个具有相同任务的函数，因为您可以利用现有的函数。</p><p id="c085" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ln lo lp lq b">call()</code>的一些实用方法:</p><p id="f703" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1。借用功能</strong></p><p id="3671" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看看下面的两个物体:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="8075" class="ms ls iq lq b gy mt mu l mv mw">const dog = {<br/>  name: ‘dog’,<br/>  bark: function() {<br/>    console.log(`I’m a ${this.name}`);<br/>    console.log(‘woof woof’);<br/>  }</span><span id="06f7" class="ms ls iq lq b gy mx mu l mv mw">};</span><span id="93c0" class="ms ls iq lq b gy mx mu l mv mw">const fish = {<br/>  name: ‘fish’,<br/>  swim: function() {<br/>    console.log(swimming);<br/>  }<br/>};</span></pre><p id="4d57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们给鱼一种叫的能力怎么样？</p><p id="9bc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于<code class="fe ln lo lp lq b">dog</code>对象有<code class="fe ln lo lp lq b">bark</code>函数，我们只是借用它来用于<code class="fe ln lo lp lq b">fish</code>对象，而没有定义另一个函数。</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="0ea2" class="ms ls iq lq b gy mt mu l mv mw">dog.bark.call(fish); // I’m a fish woof woof</span></pre><p id="9fac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2。对象的链构造函数</strong></p><p id="9545" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以使用<code class="fe ln lo lp lq b">call()</code>来链接一个对象的构造函数。在某种程度上，它类似于OOP中的继承。</p><p id="b666" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="5c06" class="ms ls iq lq b gy mt mu l mv mw">function Vehicle(nWheels) {<br/>  this.nWheels = nWheels;<br/>}</span><span id="a3e6" class="ms ls iq lq b gy mx mu l mv mw">function Car(color) {<br/>  Vehicle.call(this, 4);<br/>  this.color = color;<br/>}</span><span id="10d7" class="ms ls iq lq b gy mx mu l mv mw">function Bike(color) {<br/>  Vehicle.call(this, 2);<br/>  this.color = color;<br/>}</span><span id="cfd4" class="ms ls iq lq b gy mx mu l mv mw">let car = new Car(‘red’); // { nWheels: 4, color: “red” }<br/>let bike = new Bike(‘green’); // { nWheels: 2, color: “green” }</span></pre><h1 id="c3c8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">Function.prototype.apply()</h1><p id="4523" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">语法:<code class="fe ln lo lp lq b">func.apply(thisArg, [argsArray])</code></p><p id="1b07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">apply()</code>类似于<code class="fe ln lo lp lq b">call()</code>。这里的区别是<code class="fe ln lo lp lq b">apply()</code>接受实际函数的参数作为数组。</p><p id="2860" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="9006" class="ms ls iq lq b gy mt mu l mv mw">const normalUser = {<br/>  type: ‘normal’<br/>}</span><span id="00c3" class="ms ls iq lq b gy mx mu l mv mw">function showName(firstname, lastname) {<br/>  console.log(`I’m ${firstname} ${lastname}. I’m a ${this.job}.`);<br/>}</span><span id="c703" class="ms ls iq lq b gy mx mu l mv mw">showName.apply(normalUser, [‘Amy’, ‘Andrews’]); // I’m Amy Andrews. I’m a developer.</span></pre><p id="dd28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，第二个参数是一个数组，其中有元素将被传递给由<code class="fe ln lo lp lq b">apply()</code>方法调用的<code class="fe ln lo lp lq b">showName()</code>函数。</p><p id="d68d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ln lo lp lq b">apply()</code>的一些实用方法:</p><p id="b119" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1。合并数组</strong></p><p id="8cf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您需要将一个数组的元素推送到另一个数组:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="cfe4" class="ms ls iq lq b gy mt mu l mv mw">let group1 = [‘Joey’, ‘Chandler’, ‘Ross’];let group2 = [‘Monica’, ‘Phoebe’, ‘Rachel’];</span><span id="8e45" class="ms ls iq lq b gy mx mu l mv mw">group1.push(group2);<br/>console.log(group1); //[“Joey”, “Chandler”, “Ross”, [“Monica”, “Phoebe”, “Rachel”]]</span></pre><p id="c3f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成了。<code class="fe ln lo lp lq b">group2</code>数组的元素现在在<code class="fe ln lo lp lq b">group1</code>中。然而，问题是它将整个数组作为一个元素来推送，而不是单独的元素。</p><p id="30aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae my" href="https://medium.com/javascript-in-plain-english/8-ways-to-solve-javascript-array-issues-you-need-to-know-about-de4fb3770e5a" rel="noopener">合并数组</a>有很多种方法。但是这次我们用<code class="fe ln lo lp lq b">apply()</code>。通过稍微调整代码，我们将完成任务:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="bba3" class="ms ls iq lq b gy mt mu l mv mw">group1.push.apply(group1, group2);</span><span id="4ed4" class="ms ls iq lq b gy mx mu l mv mw">console.log(group1); // [“Joey”, “Chandler”, “Ross”, “Monica”, “Phoebe”, “Rachel”]</span></pre><p id="1d26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在其实已经做好了。</p><p id="48b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2。识别数字数组的最小值/最大值</strong></p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="6487" class="ms ls iq lq b gy mt mu l mv mw">let numbers = [3, 31, 12, 76, 243, 123, 55, 10];</span><span id="eb0a" class="ms ls iq lq b gy mx mu l mv mw">let min = Math.min.apply(null, numbers); // 3<br/>let max = Math.max.apply(null, numbers); // 243</span></pre><p id="20ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很方便，因为我们不需要把数组分成单个的数字。我们所要做的就是在<code class="fe ln lo lp lq b">apply()</code>的帮助下，将整个数组作为参数传递给<code class="fe ln lo lp lq b">min()/max()</code>函数。</p><p id="c6b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 3。借用功能</strong></p><p id="c4da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像<code class="fe ln lo lp lq b">call()</code>一样，我们可以使用<code class="fe ln lo lp lq b">apply()</code>从其他对象借用函数。</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="b9fb" class="ms ls iq lq b gy mt mu l mv mw">const calculationV1 = {<br/>  version: 1,<br/>  sum: function(a, b) {<br/>    console.log(`Calculation version ${this.version}. The sum of           <br/>                 ${a} and ${b} is ${a + b}`);<br/>  }<br/>};</span><span id="ad62" class="ms ls iq lq b gy mx mu l mv mw">const calculationV2 = {<br/>  version: 2<br/>}</span><span id="be1d" class="ms ls iq lq b gy mx mu l mv mw">let sumV1 = calculationV1.sum(1, 2); // Calculation version 1. The sum of 1 and 2 is 3</span><span id="9a7b" class="ms ls iq lq b gy mx mu l mv mw">let sumV2 = calculationV1.sum.apply(calculationV2, [4, 5]); // Calculation version 2. The sum of 4 and 5 is 9</span></pre><p id="e2d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，<code class="fe ln lo lp lq b">calculationV2</code>对象没有<code class="fe ln lo lp lq b">sum()</code>函数，但是我们可以从<code class="fe ln lo lp lq b">calculationV1</code>对象那里借用它。</p><h1 id="8b84" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">函数.原型.绑定()</h1><p id="8ffa" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">语法:<code class="fe ln lo lp lq b">func.bind(thisArg, arg1, arg2, arg3,…)</code></p><p id="c51d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">bind()</code>方法创建一个新的函数，其<code class="fe ln lo lp lq b">this</code>关键字设置为调用该函数时提供的值。要清楚地了解它，请查看以下示例:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="df08" class="ms ls iq lq b gy mt mu l mv mw">const book = {<br/>  title: ‘JavaScript’,<br/>  displayTitle: function () {<br/>    console.log(this.title);<br/>  }<br/>};</span><span id="0f6e" class="ms ls iq lq b gy mx mu l mv mw">function waitToDisplayTitle(displayFunc, time) {<br/>  setTimeout(displayFunc, time);<br/>}</span><span id="00a7" class="ms ls iq lq b gy mx mu l mv mw">book.displayTitle(); // JavaScript<br/>waitToDisplayTitle(book.displayTitle, 100); // undefined</span></pre><p id="ca24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们用传统的方式来调用<code class="fe ln lo lp lq b">displayTitle()</code>函数，它会完美地工作。但是当我们把它作为一个回调函数传递给另一个函数时，它就不再理解原来的<code class="fe ln lo lp lq b">this</code>了。上下文已更改。这就是为什么<code class="fe ln lo lp lq b">waitToDisplayTitle()</code>会打印<code class="fe ln lo lp lq b">undefined</code>。</p><p id="0c7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们使用如下的<code class="fe ln lo lp lq b">bind()</code>:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="af92" class="ms ls iq lq b gy mt mu l mv mw">waitToDisplayTitle(book.displayTitle.bind(book), 100); // JavaScript</span></pre><p id="d2f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">this</code>关键字返回到<code class="fe ln lo lp lq b">book</code>对象，现在一切都如预期的那样工作。</p><p id="e112" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你和我一样，使用<code class="fe ln lo lp lq b">bind()</code>最实际的方法是当你需要在基于反应的应用程序中处理<code class="fe ln lo lp lq b">this</code>时。不知何故，在那种应用中我们可能会遇到更多关于<code class="fe ln lo lp lq b">this</code>的问题。</p><p id="c1cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="af59" class="ms ls iq lq b gy mt mu l mv mw">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="abc6" class="ms ls iq lq b gy mx mu l mv mw">    this.state = {<br/>      isDarkMode: true<br/>    };<br/>  }</span><span id="d182" class="ms ls iq lq b gy mx mu l mv mw">  switchMode() {<br/>    this.setState({ isDarkMode: !this.state.isDarkMode });<br/>  }</span><span id="182b" class="ms ls iq lq b gy mx mu l mv mw">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button onClick={this.switchMode}&gt;<br/>          { this.state.isDarkMode ? ‘Dark’ : ‘Light’ }<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="34c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以上示例将呈现一个带有标签<code class="fe ln lo lp lq b">Dark</code>的按钮。我们的任务是点击按钮后在<code class="fe ln lo lp lq b">Dark</code>和<code class="fe ln lo lp lq b">Light</code>之间切换标签。让我们看看任务是否完成了？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/87d264f214e98c3e2a30b479c317a21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RrhsJd-hNB_PTVmv0lQGWg.gif"/></div></div></figure><p id="02f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您在上面的gif中看到的，无论我们点击按钮多少次，标签都保持<code class="fe ln lo lp lq b">Dark</code>。除此之外，我们还会得到一个错误。所以，我们还是有事情要做。</p><p id="088a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">错误很明显。当我们调用<code class="fe ln lo lp lq b">switchMode()</code>函数时，函数中<code class="fe ln lo lp lq b">this</code>的值为<code class="fe ln lo lp lq b">null</code>，不再指向应用状态。因此，我们需要用<code class="fe ln lo lp lq b">bind()</code>将其指向背面。</p><p id="5d53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是解决方案:</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="8cc3" class="ms ls iq lq b gy mt mu l mv mw">&lt;button onClick={this.switchMode.bind(this)}&gt;<br/>  { this.state.isDarkMode ? ‘Dark’ : ‘Light’ }<br/>&lt;/button&gt;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/5d3e1f5502b0f2e095eb5f8efdf441b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0NSfvi1_rmaDW17JFN-A8w.gif"/></div></div></figure><p id="d3a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，它现在工作了。</p><p id="5c15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是在这种情况下，我们可以使用<a class="ae my" href="https://medium.com/javascript-in-plain-english/9-es6-features-every-javascript-developer-should-know-b1f2915e7add" rel="noopener"> ES6 arrow函数</a>仍然可以达到同样的效果。</p><pre class="kg kh ki kj gt mo lq mp mq aw mr bi"><span id="8586" class="ms ls iq lq b gy mt mu l mv mw">&lt;button onClick={e =&gt; this.switchMode(e)}&gt;</span></pre><p id="01ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为arrow函数没有定义自己的上下文。它使用封闭函数范围的上下文作为其<code class="fe ln lo lp lq b">this</code>值。</p><p id="728b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们有箭头函数，为什么还要使用<code class="fe ln lo lp lq b">bind()</code>?在我看来，是关于<a class="ae my" href="https://dev.to/georgecoldham/using-arrow-functions-might-be-costing-you-performance-4fm6" rel="noopener ugc nofollow" target="_blank">性能问题</a>。你应该根据你的目的和经验明智地使用它。</p><h1 id="4c04" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="1548" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">如果您的应用程序变得更大，JavaScript中的控制<code class="fe ln lo lp lq b">this</code>可能会很困难。</p><p id="2de2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，到目前为止，你有三种方法来跟踪<code class="fe ln lo lp lq b">this</code>。所以，每当你需要改变上下文或者将<code class="fe ln lo lp lq b">this</code>指向另一个对象时，使用<code class="fe ln lo lp lq b">call()</code>、<code class="fe ln lo lp lq b">apply()</code>和<code class="fe ln lo lp lq b">bind()</code>。</p><p id="b6ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你在使用<code class="fe ln lo lp lq b">this</code>时会遇到什么问题吗？请在下面的评论中告诉我。</p><p id="37e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你喜欢这篇文章。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="e2be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">延伸阅读</strong></p><div class="nh ni gp gr nj nk"><a href="https://medium.com/javascript-in-plain-english/11-javascript-concepts-every-web-developer-should-know-to-take-their-skills-to-the-next-level-37ef6693111a" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">每个Web开发人员都应该知道的11个JavaScript概念，让他们的技能更上一层楼</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">不了解这些概念，就无法掌握JavaScript。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kp nk"/></div></div></a></div></div></div>    
</body>
</html>