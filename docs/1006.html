<html>
<head>
<title>Node.js FS Module — Truncating and Removing Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js FS模块-截断和删除文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-fs-module-truncating-and-removing-files-2435415015bc?source=collection_archive---------6-----------------------#2020-01-13">https://javascript.plainenglish.io/node-js-fs-module-truncating-and-removing-files-2435415015bc?source=collection_archive---------6-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/891e747019c98b8c38d10a547e5b828d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p2zImqHN23H8D-LE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@paul_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paul Hanaoka</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">操作文件和目录是任何程序的基本操作。因为Node.js是一个服务器端平台，可以直接与运行它的计算机交互，所以能够操作文件是一个基本特性。幸运的是，Node.js的库中内置了一个<code class="fe lb lc ld le b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。支持的文件和目录操作包括基本的操作，如操作和打开目录中的文件。同样，它也可以对文件做同样的事情。它可以同步和异步地做到这一点。它有一个异步API，其中包含支持承诺的函数。它还可以显示文件的统计数据。几乎所有我们能想到的文件操作都可以用内置的<code class="fe lb lc ld le b">fs</code>模块来完成。在本文中，我们将用<code class="fe lb lc ld le b">truncate</code>函数族截断文件，用<code class="fe lb lc ld le b">unlink</code>函数族删除文件和符号链接。</p><h1 id="2943" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用fs.truncate系列函数截断文件</h1><p id="a90a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用Node.js <code class="fe lb lc ld le b">truncate</code>系列函数来截断文件。截断文件是将文件缩小到指定的大小。要异步截断文件，我们可以使用<code class="fe lb lc ld le b">truncate</code>函数。该函数有3个参数。第一个参数是路径对象，可以是字符串、缓冲区对象或URL对象。当文件描述符而不是路径被传入第一个参数时，它将自动调用<code class="fe lb lc ld le b">ftruncate</code>来截断带有给定文件描述符的文件。传入文件描述符是不赞成的，将来可能会引发错误。第二个参数是文件的长度(以字节为单位),您希望将其截断。默认值为0。当大小小于原始大小时，任何大于指定大小的额外数据都会丢失。第三个参数是截断操作结束时运行的回调函数。它接受一个<code class="fe lb lc ld le b">err</code>参数，当截断操作成功时该参数为<code class="fe lb lc ld le b">null</code>，否则该参数包含一个带有错误信息的对象。</p><p id="7878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要用<code class="fe lb lc ld le b">truncate</code>函数截断一个文件，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="acbf" class="mq lg iq le b gy mr ms l mt mu">const fs = require("fs");<br/>const truncateFile = "./files/truncateFile.txt";</span><span id="b8a0" class="mq lg iq le b gy mv ms l mt mu">fs.truncate(truncateFile, 1, err =&gt; {<br/>  if (err) throw err;<br/>  console.log("File truncated");<br/>});</span></pre><p id="3edd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，您要截断的文件中应该只剩下一个字节的内容。</p><p id="924a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">truncate</code>函数的同步版本是<code class="fe lb lc ld le b">truncateSync</code>函数。该函数有两个参数。第一个参数是路径对象，可以是字符串、缓冲区对象或URL对象。当一个文件描述符而不是路径被传入第一个参数时，它会自动调用<code class="fe lb lc ld le b">ftruncateSync</code>来截断带有给定文件描述符的文件。传入文件描述符是不赞成的，将来可能会引发错误。第二个参数是文件的长度(以字节为单位),您希望将其截断。默认值为0。当大小小于原始大小时，任何大于指定大小的额外数据都会丢失。它返回<code class="fe lb lc ld le b">undefined</code>。</p><p id="490e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像下面的代码一样使用<code class="fe lb lc ld le b">truncateSync</code>函数:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a645" class="mq lg iq le b gy mr ms l mt mu">const fs = require("fs");<br/>const truncateFile = "./files/truncateFile.txt";</span><span id="eba6" class="mq lg iq le b gy mv ms l mt mu">try {<br/>  fs.truncateSync(truncateFile, 1);<br/>  console.log("File truncated");<br/>} catch (error) {<br/>  console.error(error);<br/>}</span></pre><p id="f8b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，您要截断的文件中应该只剩下一个字节的内容。</p><p id="038e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个<code class="fe lb lc ld le b">truncate</code>功能的承诺版本。该函数有两个参数。第一个参数是路径对象，可以是字符串、缓冲区对象或URL对象。第二个参数是文件的长度(以字节为单位),您希望将其截断。默认值为0。当大小小于原始大小时，任何大于指定大小的额外数据都会丢失。当操作成功时，它返回一个没有参数的解析承诺。</p><p id="ab38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用promise版本的<code class="fe lb lc ld le b">truncate</code>函数截断文件，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c1d3" class="mq lg iq le b gy mr ms l mt mu">const fsPromises = require("fs").promises;<br/>const truncateFile = "./files/truncateFile.txt";</span><span id="d0e7" class="mq lg iq le b gy mv ms l mt mu">(async () =&gt; {<br/>  try {<br/>    await fsPromises.truncate(truncateFile, 1);<br/>    console.log("File truncated");<br/>  } catch (error) {<br/>    console.error(error);<br/>  }<br/>})();</span></pre><p id="bf87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，在您截断的文件中应该还有一个字节的内容。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1322e0363a992dd4013d32c394d113fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tRh-dUrRmZ_Y5b-z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@snowboardinec?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Baskakov</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="282f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用fs.unlink函数族删除文件和符号链接</h1><p id="d6b1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用<code class="fe lb lc ld le b">unlink</code>函数删除一个文件或一个符号链接。该函数有两个参数。第一个参数是路径对象，可以是字符串、缓冲区对象或URL对象。第二个参数是一个回调函数，它接受一个<code class="fe lb lc ld le b">err</code>对象，当文件或符号链接删除操作成功时，该对象是<code class="fe lb lc ld le b">null</code>，如果操作失败，则包含错误数据。<code class="fe lb lc ld le b">unlink</code>函数在任何状态下都不能对目录起作用。要删除目录，我们应该使用<code class="fe lb lc ld le b">rmdir</code>函数。</p><p id="496a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用<code class="fe lb lc ld le b">unlink</code>函数删除一个文件，我们可以类似下面的代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="22f6" class="mq lg iq le b gy mr ms l mt mu">const fs = require("fs");<br/>const fileToDelete = "./files/deleteFile.txt";</span><span id="7ce7" class="mq lg iq le b gy mv ms l mt mu">fs.unlink(fileToDelete, err =&gt; {<br/>  if (err) {<br/>    throw err;<br/>  }<br/>  console.log("Removal complete!");<br/>});</span></pre><p id="ce72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，要删除的文件应该会消失。</p><p id="5992" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">unlink</code>函数的同步版本是<code class="fe lb lc ld le b">unlinkSync</code>函数。该函数接受一个参数。唯一的参数是路径对象，它可以是字符串、缓冲区对象或URL对象。它返回<code class="fe lb lc ld le b">undefined</code>。</p><p id="5133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在下面的代码中使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="25e6" class="mq lg iq le b gy mr ms l mt mu">const fs = require("fs");<br/>const fileToDelete = "./files/deleteFile.txt";</span><span id="c778" class="mq lg iq le b gy mv ms l mt mu">try {<br/>  fs.unlinkSync(fileToDelete);<br/>  console.log("Removal complete!");<br/>} catch (error) {<br/>  console.error(error);<br/>}</span></pre><p id="9d1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个<code class="fe lb lc ld le b">unlink</code>功能的承诺版。该函数接受一个参数。唯一的参数是路径对象，它可以是字符串、缓冲区对象或URL对象。当操作成功时，它返回一个没有任何参数的承诺。</p><p id="3a39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，要删除的文件应该会消失。</p><p id="3fc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在下面的代码中使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f2db" class="mq lg iq le b gy mr ms l mt mu">const fsPromises = require("fs").promises;<br/>const fileToDelete = "./files/deleteFile.txt";</span><span id="cc86" class="mq lg iq le b gy mv ms l mt mu">(async () =&gt; {<br/>  try {<br/>    await fsPromises.unlink(fileToDelete);<br/>    console.log("Removal complete!");<br/>  } catch (error) {<br/>    console.error(error);<br/>  }<br/>})();</span></pre><p id="334d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，要删除的文件应该会消失。</p><p id="3d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你想连续做多件事，包括调用<code class="fe lb lc ld le b">unlink</code>函数时，<code class="fe lb lc ld le b">unlink</code>函数的promise版本是比<code class="fe lb lc ld le b">unlinkSync</code>函数更好的选择，因为它不会占用整个程序，等待文件或符号链接删除操作完成后再继续编程程序的其他部分。</p><p id="0749" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们用<code class="fe lb lc ld le b">truncate</code>函数族截断文件，用<code class="fe lb lc ld le b">unlink</code>函数族删除文件和符号链接。<code class="fe lb lc ld le b">truncate</code>系列函数让我们在截断文件的其余部分时指定要保留的字节数。<code class="fe lb lc ld le b">unlink</code>系列函数删除文件和符号链接。如果我们想把这些操作和其他操作一起进行，这些函数的承诺版本。尽管该API仍处于试验阶段，但它比这些函数的同步版本好得多，因为它允许顺序和异步操作。此外，它有助于避免我们在太多层次嵌套承诺的回调地狱。</p></div></div>    
</body>
</html>