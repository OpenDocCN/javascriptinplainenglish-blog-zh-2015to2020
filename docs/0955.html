<html>
<head>
<title>Scaling Node.js JavaScript Microservices on Shared MongoDB Atlas Cloud Persistence Layers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在共享的MongoDB Atlas云持久层上扩展Node.js JavaScript微服务</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/scaling-node-js-javascript-microservices-on-shared-mongodb-atlas-cloud-persistence-layers-620bf975ebfd?source=collection_archive---------6-----------------------#2020-01-06">https://javascript.plainenglish.io/scaling-node-js-javascript-microservices-on-shared-mongodb-atlas-cloud-persistence-layers-620bf975ebfd?source=collection_archive---------6-----------------------#2020-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6e12c1b21d54e939356abf163cdbecab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7YhIwN76btivQjHZ.png"/></div></div></figure><p id="47b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用微服务架构在Node.js上构建JavaScript应用程序，使您能够通过添加更多服务实例来扩展应用程序，以响应不断增加的负载水平。但是当一个服务的多个实例处理相同的数据时，您的应用程序将有一个额外的设计需求:您将需要一个<em class="kw">持久层</em>，服务实例可以使用它来存储和共享数据。</p><p id="8528" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将向您展示如何使用数据库作为JavaScript微服务应用程序的持久层。您将看到该应用程序如何使用网飞尤里卡和网飞祖尔来进行服务发现和负载平衡。您将能够应用您在这里学到的技术来构建可以纵向扩展和横向扩展的应用程序，同时避免自己构建服务发现和负载平衡的复杂性。</p><p id="78be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还将获得使用<a class="ae kx" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>作为数据库即服务(DBaaS)的实践介绍。基于云的数据库是基于云的微服务应用程序的自然补充，MongoDB Atlas可以在Azure、AWS或Google Cloud上运行。</p><h1 id="ea83" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">先决条件</h1><p id="bbb4" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">为了完成这篇文章中的任务，你需要:</p><ul class=""><li id="0a29" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><a class="ae kx" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也会安装NPM。)</li><li id="39f4" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae kx" href="https://www.java.com/en/download/" rel="noopener ugc nofollow" target="_blank"> Java运行时环境SE </a></li><li id="86a5" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated"><a class="ae kx" href="https://cloud.mongodb.com/user" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas帐户</a>(选择了一个自由层集群)</li></ul><p id="543a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从这篇文章中最有效地学习，你应该具备以下条件:</p><ul class=""><li id="5c8f" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">JavaScript、Node.js和数据库的工作知识</li><li id="498b" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv mg mh mi mj bi translated">对HTTP协议有所了解</li></ul><p id="2746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给你一个好的开始，这篇文章是建立在本系列前两篇文章的代码和概念之上的:</p><p id="f638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://medium.com/swlh/building-javascript-microservices-with-node-js-d88bf0bb2b92" rel="noopener">使用Node.js构建JavaScript微服务</a> —介绍微服务的概念，并向您展示如何在Node.js上使用JavaScript构建微服务应用程序。</p><p id="0512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://medium.com/javascript-in-plain-english/implementing-eureka-and-zuul-for-service-discovery-and-dynamic-routing-in-javascript-microservices-45a7ac18837a?" rel="noopener">在Node.js上运行的JavaScript微服务中为服务发现和动态路由实现Eureka和Zuul</a>—演示如何将网飞Eureka服务注册中心和网飞Zuul的动态路由和负载平衡集成到微服务应用中。</p><p id="6a29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您对这些概念不熟悉，您可能想阅读这些帖子，并从它们开始一步一步地构建项目。如果您熟悉微服务，并希望专注于学习实现持久层，那么配套的资源库中有您开始这篇文章所需的代码。下面的说明将向您展示如何编写本系列前两篇文章中的代码。</p><p id="0423" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">案例研究项目包括四项服务。Node.js上运行着两个JavaScript服务:</p><p id="90a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">维护超级英雄的列表、他们的属性以及他们的忙/闲状态。</p><p id="8733" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">threats-service</code>–维护一个危险情况列表，以及负责应对各种威胁的英雄。</p><p id="e3ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些服务使用一个助手函数<code class="fe mp mq mr ms b">registerWithEureka</code>，这使得它们能够方便地连接到服务发现系统。这些组件共同构成了应用程序的功能方面。</p><p id="8e5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有两个Java服务为Node.js服务提供基础设施支持:</p><p id="4ffa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">网飞尤里卡</strong> —是一个服务注册和发现工具，使服务能够找到其他服务，而不需要知道它们在哪里运行。</p><p id="d2d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">网飞Zuul </strong> —是一个负载平衡器和动态路由服务，它从Eureka获取每个服务的可用实例列表，在服务之间路由请求，并在服务器实例之间平衡负载。</p><p id="4746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些Java服务是在Java归档文件中提供的。jar)文件:一旦安装了Java SE运行时环境，您需要做的就是运行它们。它们是打包的，所以您可以在自己的项目中使用它们，无需修改。</p><p id="302f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该项目的架构如下所示:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/80df72d16f5b5850cd7961672c561f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iMlSI2J2QWtWd_C6.jpg"/></div></div></figure><p id="0d6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您没有遵循之前的帖子并在这样做的同时构建了项目，或者您想要开始新的代码副本，那么您可以为这篇帖子从<a class="ae kx" href="https://github.com/maciejtreder/introduction-to-microservices" rel="noopener ugc nofollow" target="_blank"> GitHub仓库中克隆项目。</a></p><p id="5e0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在您想要创建项目目录的目录中执行以下命令来克隆它:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="a71d" class="nc kz iq ms b gy nd ne l nf ng">git clone <a class="ae kx" href="https://github.com/maciejtreder/introduction-to-microservices.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/introduction-to-microservices.git</a><br/>cd introduction-to-microservices/heroes<br/>git checkout step4<br/>npm install<br/>cd ../threats<br/>npm install<br/>cd ../eureka-helper<br/>npm install<br/>cd ..</span></pre><p id="451c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，这些步骤包括在适当的目录中安装所需的npm软件包。</p><p id="e698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在应用程序的根目录中执行以下命令行指令来启动Eureka。这将是<em class="kw">微服务简介</em>目录，除非您在克隆存储库时更改了目标目录。</p><p id="cab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Windows用户应该在Windows命令提示符(cmd.exe)窗口而不是PowerShell窗口中执行以下指令以及所有后续指令，除非另有说明。</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="ecc6" class="nc kz iq ms b gy nd ne l nf ng">java -jar eureka-service-0.0.1-SNAPSHOT.jar</span></pre><p id="371d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用程序的根目录中打开另一个控制台窗口，并通过执行以下命令行指令启动Zuul服务。这将是您打开的第二个控制台窗口:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="7490" class="nc kz iq ms b gy nd ne l nf ng">java -jar zuul-0.0.1-SNAPSHOT.jar --eureka.instance.leaseRenewalIntervalInSeconds=30</span></pre><p id="ae33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意启动Zuul时使用的参数。它减少了Zuul从Eureka检索服务信息的时间间隔。这在开发环境中很有用，但是在生产环境中，您应该坚持使用默认设置。Spring文档提供了为什么注册服务的过程相对<a class="ae kx" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_why_is_it_so_slow_to_register_a_service" rel="noopener ugc nofollow" target="_blank">缓慢</a>的背景。</p><p id="e7df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目根目录中打开第三个控制台窗口，并执行以下命令行指令:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="17a8" class="nc kz iq ms b gy nd ne l nf ng">node threats/threats.js 3000</span></pre><p id="472f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目根目录中打开第四个控制台窗口，并执行以下命令行指令:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="7cef" class="nc kz iq ms b gy nd ne l nf ng">node heroes/heroes.js 3001</span></pre><p id="5349" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在新的控制台窗口中从项目根目录执行下面的curl命令，检查是否一切正常。这将是您打开的第五个控制台窗口:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="ee2e" class="nc kz iq ms b gy nd ne l nf ng">curl -i --request POST --header "Content-Type: application/json" --data "{\"heroId\": 1, \"threatId\": 1}" localhost:8080/threats-service/assignment</span></pre><p id="546e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果服务运行正常，您应该会看到类似于curl的以下控制台输出的结果:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="034c" class="nc kz iq ms b gy nd ne l nf ng">HTTP/1.1 202 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"79-ER1WRPW1305+Eomgfjq/A/Cgkp8"<br/>Date: Fri, 05 Apr 2019 18:05:54 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="b9b5" class="nc kz iq ms b gy nh ne l nf ng">{"id":1,"displayName":"Pisa tower is about to collapse.","necessaryPowers":["flying"],"img":"tower.jpg","assignedHero":1}</span></pre><h1 id="59ed" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">秤婴儿秤！</h1><p id="09ba" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">一场UFO入侵即将降临地球！你的英雄们很快就会变得非常忙碌，所以你需要为<code class="fe mp mq mr ms b">heroes-service</code>增加的流量做好准备。有了尤利卡和祖尔，一切都变得简单了。您需要做的是添加另一个<code class="fe mp mq mr ms b">hero-service</code>实例，并向Eureka注册它。Zuul将自动检索关于新服务实例的信息。</p><p id="3e9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目的根目录中打开一个新的控制台窗口(6号),并执行以下命令行指令:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="2fd1" class="nc kz iq ms b gy nd ne l nf ng">node heroes/heroes.js 3002</span></pre><p id="840f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，<code class="fe mp mq mr ms b">heroes-service</code>的新实例被分配了一个不同的端口号3002，而服务的原始实例被分配了端口3001。虽然这对于在同一个Node.js服务器(或任何其他服务器)上使用同一个Eureka句柄的同一个服务的两个实例是必要的，但是在不同机器上运行的多个服务实例可以使用同一个端口号。</p><p id="b79b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">heroes-service</code>的新实例应该报告以下内容:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="c4f0" class="nc kz iq ms b gy nd ne l nf ng">Registering heroes-service with Eureka<br/>Heroes service listening on port 3002<br/>Registered with Eureka.</span></pre><p id="08e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还应该在其控制台窗口中看到向Eureka注册的新实例，该窗口将显示类似如下的状态消息:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="1b67" class="nc kz iq ms b gy nd ne l nf ng">2019-04-23 16:27:49.739  INFO 30580 --- [nio-8761-exec-3] c.n.e.registry.AbstractInstanceRegistry  : Registered instance HEROES-SERVICE/heroes-service-3002 with status UP (replication=false)<br/>2019-04-23 16:27:50.246  INFO 30580 --- [nio-8761-exec-5] c.n.e.registry.AbstractInstanceRegistry  : Registered instance HEROES-SERVICE/heroes-service-3002 with status UP (replication=true)<br/>2019-04-23 16:28:05.235  INFO 30580 --- [a-EvictionTimer] c.n.e.registry.AbstractInstanceRegistry  : Running the evict task with compensationTime 0ms</span></pre><p id="bf20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开浏览器选项卡，导航到<a class="ae kx" href="http://localhost:8761," rel="noopener ugc nofollow" target="_blank"> http://localhost:8761，</a>您在启动第一个Java时创建的Eureka实例的URL。罐子，上图。</p><p id="d21a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该看到尤里卡的<a class="ae kx" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>状态页面，如下所示。在当前向Eureka 注册的<em class="kw">实例下，您应该看到HEROES-SERVICE对于<em class="kw">可用性区域</em>的值为2，端口3001和3002处的两个实例在<em class="kw">状态</em>下列为“启动”。您还应该看到端口3000上显示为“UP”的威胁服务。</em></p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/9aa42e6d6ba0ad1da39e6cf602f4d8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gx0_Bu1cOJWskI5N.jpg"/></div></div></figure><p id="a8cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您需要给Zuul一个机会从Eureka检索关于新实例<code class="fe mp mq mr ms b">heroes-service</code>的信息。这不会花费超过30秒的时间(由启动Zuul时使用的参数<code class="fe mp mq mr ms b">--eureka.instance.leaseRenewalIntervalInSeconds=30</code>指定),并且将由类似如下的日志条目指示:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="f3f9" class="nc kz iq ms b gy nd ne l nf ng">2019-04-29 19:55:33.834  INFO 14446 --- [freshExecutor-0] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span></pre><p id="165b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当向<code class="fe mp mq mr ms b">heroes-service</code>发出请求时，Zuul使用循环算法从两个实例中选择一个来处理请求。</p><p id="923e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">排列您的桌面，以便您可以看到两个heroes-service实例的控制台窗口，以及您之前执行curl命令的窗口。每个<code class="fe mp mq mr ms b">heroes-service</code>实例应该每隔几秒钟显示以下消息:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="89b0" class="nc kz iq ms b gy nd ne l nf ng">Successfully sent heartbeat to Eureka.</span></pre><p id="2805" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在执行前面curl命令的控制台窗口中，多次执行下面的curl命令，同时在<code class="fe mp mq mr ms b">heroes-service</code>窗口中观察输出:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="c33d" class="nc kz iq ms b gy nd ne l nf ng">curl -i --request GET localhost:8080/heroes-service/heroes</span></pre><p id="0434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您重复执行curl命令时，您应该会看到在每个窗口中交替显示以下状态消息:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="2c0d" class="nc kz iq ms b gy nd ne l nf ng">Returning heroes list</span></pre><p id="c9be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这展示了Zuul的<a class="ae kx" href="https://github.com/Netflix/zuul/wiki/Core-Features#load-balancing" rel="noopener ugc nofollow" target="_blank">负载平衡</a>特性。使用循环算法，Zuul将请求发送给所请求服务的最可用实例。在这个简单的例子中，它(通常)将请求发送给它没有发送前一个请求的实例。</p><p id="10b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仔细查看一下<code class="fe mp mq mr ms b">heroes-service</code>实例的控制台日志。如您所见，请求被路由到这两个服务器:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/100d3fe097dd916f35498d20513be8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*KlRnsD6yVi4pBDKa.jpg"/></div></figure><p id="9ecd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在连续执行curl命令时，查看控制台窗口中的输出。您将看到，当Zuul在两个实例之间交替时，每个实例都有不同的响应，如下所示:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/f7a80cfe38d0290a1fee038a3fe3d0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eObCDBa64e4GBD-k.jpg"/></div></div></figure><p id="9b62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">heroes-service</code>的一个实例回应说主角“Cooper”很忙，而另一个实例说他不忙。你给他分配了一个威胁，但只有一个实例似乎得到了消息。</p><p id="cd77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么？因为两个实例都将关于<code class="fe mp mq mr ms b">heroes</code>对象的信息保存在内存中，并且不会在彼此之间共享关于状态变化的信息。每个实例只报告它所知道的关于它所执行的任务的信息。</p><h1 id="a8c3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用MongoDB添加持久层</h1><p id="afb1" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">为了解决服务实例在内存中保存独立数据集的问题，您可以添加一个<em class="kw">持久层</em>来保存由多个服务实例共享的数据元素的值。当响应更改数据的请求时，每个服务都将写入和读取持久层。</p><p id="60dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用数据库是向系统添加持久层的一种常见方式。它具有非易失性存储器的额外优势，这意味着即使其他系统组件没有运行，也可以从数据存储中读取系统状态。它还可以用来维护系统状态随时间变化的记录。例如，在这个项目中，了解一个英雄在一段时间内面临的威胁可能会有所帮助。</p><p id="f254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个项目中，持久层将存储关于哪些英雄被分配到特定威胁的信息。当英雄服务的一个实例将一个英雄分配给一个威胁时，其他实例会知道这一点，并且他们会知道一个英雄什么时候忙，所以他们不会试图同时给一个英雄分配两个威胁。</p><p id="fea8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">持久层还使您能够添加或减少特定服务的实例，以响应对这些服务的不同需求。当负载平衡器调用新实例时，它将使用数据库中的数据无缝地开始处理请求。相反，当需求较低时，可以从Eureka registry中撤回一个实例以降低处理成本:其最近处理的请求的结果将存储在数据库中。</p><p id="75a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下图描述了新的系统架构:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/3e47be3c556cb6a8b3e92aab49c44566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B-TymXf9pqIOTYi_.jpg"/></div></div></figure><p id="3a04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导航至<a class="ae kx" href="https://cloud.mongodb.com/user" rel="noopener ugc nofollow" target="_blank">https://cloud.mongodb.com/user</a>并登录您的账户。要注册新集群，请点击<em class="kw">构建新集群</em>，然后选择最合适的地区和云基础设施提供商。(您可以选择“可用的免费层”区域，以避免运营费用。)</p><p id="0d60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您的集群准备就绪时，单击<strong class="ka ir"> Connect </strong>按钮，并按照<em class="kw"> Connect to Cluster() </em>面板上的提示:1)将您的连接IP地址列入白名单，2)创建一个MongoDB用户。</p><p id="e989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">提示:</strong>创建密码时，避免使用在系统命令行中输入时必须进行URL编码的字符。请务必将您的MongoDB用户名和密码保存在安全的地方。</p><p id="f1e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="kw">选择连接方式</em>步骤中，选择<em class="kw">连接Mongo Shell </em>。按照适当的说明下载、安装和配置MongoDB Shell，以便在您的系统上运行。</p><p id="58b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您将MongoDB Shell配置为在您的系统上运行时，将提供的命令行指令复制到一个安全的地方。在<em class="kw">连接到集群()</em>对话框打开的情况下，保持该选项卡打开；你很快就会回来。</p><p id="1b10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在控制台窗口中执行命令行指令来启动shell。您需要输入刚刚创建的用户密码。</p><p id="5878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">给Windows用户的提示:</strong>在PowerShell窗口中执行下面的MongoDB命令行指令；这将使您能够在一个步骤中粘贴并执行整个指令块。</p><p id="0de8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成功连接到MongoDB实例后，通过执行以下MongoDB命令行指令向其添加数据:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bfb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回浏览器选项卡，打开<em class="kw">连接到集群()</em>对话框。</p><p id="ba58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击<strong class="ka ir">返回</strong>按钮返回到<em class="kw">选择连接方式</em>步骤。</p><p id="a365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击<strong class="ka ir">连接您的应用</strong>。</p><p id="4546" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="kw">选择您的驱动程序版本</em>下，选择的值应该是:</p><p id="e00f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">驱动程序:Node.js</p><p id="6330" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">版本:3.0或更高版本</p><p id="425a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅选择<strong class="ka ir">连接串</strong>，点击<strong class="ka ir">复制</strong>按钮。保存连接字符串；稍后您将使用它将Node.js服务连接到MongoDB Atlas数据库。</p><p id="cc4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据您选择的云服务，连接字符串应该如下所示:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="c8db" class="nc kz iq ms b gy nd ne l nf ng">mongodb+srv://youruserid:&lt;password&gt;@cluster0-se0aa.azure.mongodb.net/test?retryWrites=true</span></pre><h1 id="5427" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实现使用持久层的服务的新版本</h1><p id="da7f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">您已经创建了持久层，并在数据库中植入了相同的数据，这些数据被硬编码到当前版本的<code class="fe mp mq mr ms b">heroes-service</code>和<code class="fe mp mq mr ms b">threats-service</code>的源代码中，但是每个服务的代码都必须更新才能使用数据库。在传统的应用程序中，这将需要更新代码并部署它，停止应用程序的原始版本，并重新启动新版本。很难做到这一点而不给用户造成服务中断。</p><p id="05d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用微服务，您可以将新版本与当前版本一起部署，然后在您对新版本正常工作感到满意时，将旧版本脱机。用户体验到100%的正常运行时间和无缝集成到应用程序体验中的新功能。您可以通过启动其他实例来扩展新版本的服务。当您在代码中实现持久层功能时，您将看到这个过程的运行。</p><p id="f732" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用根目录下新建一个目录<em class="kw"> /heroes-v2 </em>。</p><p id="4593" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在<em class="kw"> /heroes-v2 </em>目录中执行以下命令行指令，初始化npm项目并安装所需的npm依赖项:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="c0cb" class="nc kz iq ms b gy nd ne l nf ng">npm init -y<br/>npm install body-parser express mongodb</span></pre><p id="9339" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在/ <em class="kw"> heroes-v2 </em>目录下创建一个新文件<em class="kw"> heroes.js </em>，并插入以下JavaScript代码:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="de34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用从MongoDB Atlas<em class="kw">Connect to Cluster</em>对话框中复制的连接字符串的URL部分替换<code class="fe mp mq mr ms b">dbUrl</code>赋值的占位符文本。连接字符串将类似于:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="d54c" class="nc kz iq ms b gy nd ne l nf ng">mongodb+srv://youruserid:&lt;password&gt;@cluster0-se0aa.azure.mongodb.net/test?retryWrites=true</span></pre><p id="2ca6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe mp mq mr ms b">threats-service</code>来说，过程是一样的。</p><p id="c1f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用程序根目录下创建一个新目录<em class="kw"> /threats-v2 </em>。</p><p id="0c78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在<em class="kw"> /threats-v2 </em>目录中执行以下命令行指令，初始化npm项目并安装所需的npm依赖项:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="ebb6" class="nc kz iq ms b gy nd ne l nf ng">npm init -y<br/>npm install body-parser express request mongodb</span></pre><p id="b738" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在/ <em class="kw"> threats-v2 </em>目录下创建一个新文件<em class="kw"> threats.js </em>，并插入以下JavaScript代码:</p><figure class="mu mv mw mx gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fb82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在/<em class="kw">threats-vs/threats . js</em>中，用MongoDB连接字符串替换<code class="fe mp mq mr ms b">dbUrl</code>占位符。</p><p id="df85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想使用GitHub存储库中的代码赶上这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="6dbc" class="nc kz iq ms b gy nd ne l nf ng">git clone <a class="ae kx" href="https://github.com/maciejtreder/introduction-to-microservices.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/introduction-to-microservices.git</a><br/>cd introduction-to-microservices/heroes<br/>git checkout step5<br/>npm install<br/>cd ../threats<br/>npm install<br/>cd ../eureka-helper<br/>npm install<br/>cd ../threats-v2<br/>npm install<br/>cd ../heroes-v2<br/>npm install<br/>cd ..</span></pre><h1 id="8d31" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">验证当前配置</h1><p id="6928" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">至此，您已经修改了许多文件并运行了许多程序。在继续之前，最好验证应用程序的所有部分都已就位并正确运行。</p><p id="adc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该有5个进程在单独的控制台窗口中运行。</p><p id="23f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两个Java应用程序:</p><p id="2d3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">java -jar eureka-service-0.0.1-SNAPSHOT.jar</code></p><p id="5eb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">java -jar zuul-0.0.1-SNAPSHOT.jar</code></p><p id="e8c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些程序将定期显示状态信息。</p><p id="fc50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">三个Node.js服务:</p><p id="8a1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">node threats/threats.js 3000</code></p><p id="aaf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">node heroes/heroes.js 3001</code></p><p id="9950" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">node heroes/heroes.js 3002</code></p><p id="4262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些服务将定期显示心跳状态消息。</p><p id="3b90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在浏览器中导航到<a class="ae kx" href="http://localhost:8761" rel="noopener ugc nofollow" target="_blank"> http://localhost:8761 </a>来验证所有服务是否已注册到Eureka。您应该看到这三个服务列在当前向Eureka 注册的<em class="kw">实例下。</em></p><p id="f3b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在控制台窗口中执行以下curl命令，检查服务是否可以相互通信。(Windows用户应该使用Windows命令提示符窗口，而不是PowerShell窗口。)</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="eca4" class="nc kz iq ms b gy nd ne l nf ng">curl -i --request POST --header "Content-Type: application/json" --data "{\"heroId\": 1, \"threatId\": 1}" localhost:8080/threats-service/assignment</span></pre><p id="0bd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令将hero 1分配给threat 1，并在HTTP标头后生成以下JSON输出:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="3e0d" class="nc kz iq ms b gy nd ne l nf ng">{"id":1,"displayName":"Pisa tower is about to collapse.","necessaryPowers":["flying"],"img":"tower.jpg","assignedHero":1}</span></pre><p id="3e7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在控制台窗口中执行您在<em class="kw"> Connect与Mongo Shell </em>中获得的命令行指令，启动MongoDB命令行界面。您需要输入创建连接时使用的密码。</p><p id="9592" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行以下CLI指令，验证所有三个数据集合都存在:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="a0b1" class="nc kz iq ms b gy nd ne l nf ng">MongoDB Enterprise Cluster0-shard-0:PRIMARY&gt; show collections</span></pre><p id="4574" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该看到列出了三个集合:<code class="fe mp mq mr ms b">heroes</code>、<code class="fe mp mq mr ms b">powers</code>和<code class="fe mp mq mr ms b">threats</code>。</p><p id="332e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用以下CLI说明验证每个集合:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="49f2" class="nc kz iq ms b gy nd ne l nf ng">MongoDB Enterprise Cluster0-shard-0:PRIMARY&gt; db.threats.find()<br/>MongoDB Enterprise Cluster0-shard-0:PRIMARY&gt; db.heroes.find()<br/>MongoDB Enterprise Cluster0-shard-0:PRIMARY&gt; db.powers.find()</span></pre><p id="b112" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个命令的输出应该与您在上面为<code class="fe mp mq mr ms b">threats</code>、<code class="fe mp mq mr ms b">heroes</code>和<code class="fe mp mq mr ms b">powers</code>集合添加的数据相对应。</p><p id="b114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让MongoDB CLI在这个控制台窗口中运行。稍后您将使用它来验证信息是否被正确地写入数据库。</p><h1 id="40e2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍更新的服务</h1><p id="b79a" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">有了持久层，您可以从微服务架构的优势之一中受益:在保持100%系统正常运行的同时，很容易更新服务。不用重新启动当前正在运行的服务实例，您可以用更新的代码启动新的实例，等待一段时间直到它们注册到Eureka，然后删除旧的服务实例。</p><p id="1ac5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法还使您能够在生产环境中测试新代码，而无需提交整个应用程序来使用它。您可以注册已更新服务的一个实例，并在更新其余实例之前监控其性能。如果新版本有错误或性能问题，只有一小部分服务请求会受到影响。</p><p id="f7f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先在新的控制台窗口(编号6)中启动更新的<code class="fe mp mq mr ms b">threats-service</code>的新实例:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="a2d5" class="nc kz iq ms b gy nd ne l nf ng">node threats-v2/threats.js 5000</span></pre><p id="f6ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大约30秒钟后，Zuul将从Eureka中检索关于这个新实例的信息，这将由一个类似如下的日志条目来指示:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="7ddd" class="nc kz iq ms b gy nd ne l nf ng">2019-03-20 16:20:37.469  INFO 50245 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span></pre><p id="da15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在两个新的控制台窗口(编号7和8)中执行以下命令行指令，启动新<code class="fe mp mq mr ms b">heroes-service</code>的两个新实例:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="5ac8" class="nc kz iq ms b gy nd ne l nf ng">node heroes-v2/heroes.js 5001<br/>node heroes-v2/heroes.js 5002</span></pre><p id="d3af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器中，导航至Eureka状态面板，网址为<a class="ae kx" href="http://localhost:8761." rel="noopener ugc nofollow" target="_blank"> http://localhost:8761。</a>您应该会看到四个<code class="fe mp mq mr ms b">heroes-service</code>实例和两个<code class="fe mp mq mr ms b">threats-service</code>实例。新版本在5XXX端口上运行，旧实例在3XXX系列端口上运行。</p><p id="3a52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您现在可以停止在端口3001和3002上运行的原始版本的实例和在端口3000上运行的原始版本的实例。您还可以关闭相关的控制台窗口，将打开的控制台窗口减少到更易于管理的五个。</p><p id="4fd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次检查Eureka状态页面，验证服务的旧实例是否已被取消注册。注销所有服务可能需要5分钟或更长时间。当尤里卡的服务被移除时，你可以继续这个项目。</p><p id="a663" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这些简单的操作，您已经将您的应用程序转换为第二版的<code class="fe mp mq mr ms b">heroes-service</code>和<code class="fe mp mq mr ms b">threats-service</code>。您的应用程序现在可以使用MongoDB持久层了。</p><p id="8c2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从体系结构的角度来看，更新服务的过程是这样的:</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/b1ca018d93d2f4489961b729fcd95ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PqyOfT4YW920C-8-"/></div></div></figure><h1 id="3f53" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">验证版本2服务正在更新持久层</h1><p id="a682" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">第1版服务将英雄分配给内存中的威胁，这导致了<code class="fe mp mq mr ms b">heroes-service</code>实例所知道的英雄分配状态之间的潜在冲突。版本2的服务将从数据库中获得英雄、威胁和力量的列表。他们也将在那里存储他们的分配数据。</p><p id="a7bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要给一个威胁分配一个英雄，在一个新的(或未被占用的)控制台窗口中执行以下curl命令:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="0314" class="nc kz iq ms b gy nd ne l nf ng">curl -i --request POST --header "Content-Type: application/json" --data "{\"heroId\": 1, \"threatId\": 1}" localhost:8080/threats-service/assignment</span></pre><p id="e650" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">curl命令应该从端口8080上的Zuul返回以下响应:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="4cc2" class="nc kz iq ms b gy nd ne l nf ng">HTTP/1.1 202 <br/>X-Application-Context: application:8080<br/>X-Powered-By: Express<br/>ETag: W/"79-ER1WRPW1305+Eomgfjq/A/Cgkp8"<br/>Date: Tue, 30 Apr 2019 13:38:42 GMT<br/>Content-Type: application/json;charset=utf-8<br/>Transfer-Encoding: chunked</span><span id="a861" class="nc kz iq ms b gy nh ne l nf ng">{"id":1,"displayName":"Pisa tower is about to collapse.","necessaryPowers":["flying"],"img":"tower.jpg","assignedHero":1}</span></pre><p id="b10a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在运行Mongo CLI的控制台窗口中运行以下MongoDB CLI命令，验证hero分配是否已存储在数据库中:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="ce35" class="nc kz iq ms b gy nd ne l nf ng">db.heroes.findOne({id:1})<br/>db.threats.findOne({assignedHero:1})</span></pre><p id="0603" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据库查询应该返回以下结果:</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="9e3a" class="nc kz iq ms b gy nd ne l nf ng">{<br/>        "_id" : ObjectId("5cc84fdb0df9400439fa6299"),<br/>        "id" : 1,<br/>        "type" : "spider-dog",<br/>        "displayName" : "Cooper",<br/>        "powers" : [<br/>                1,<br/>                4<br/>        ],<br/>        "img" : "cooper.jpg",<br/>        "busy" : true<br/>}</span><span id="b0c7" class="nc kz iq ms b gy nh ne l nf ng">{<br/>        "_id" : ObjectId("5cc814820df9400439fa628d"),<br/>        "id" : 1,<br/>        "displayName" : "Pisa tower is about to collapse.",<br/>        "necessaryPowers" : [<br/>                "flying"<br/>        ],<br/>        "img" : "tower.jpg",<br/>        "assignedHero" : 1<br/>}</span></pre><p id="fb40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您留意Eureka、Zuul和服务的控制台窗口，您可能会发现其中一个<code class="fe mp mq mr ms b">heroes-service</code>实例正在处理curl请求。</p><p id="d3c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过从持久层获取英雄的状态，验证两个<code class="fe mp mq mr ms b">heroes-services</code>实例是否返回威胁分配的一致结果。这样做的过程与您之前用来演示旧版本服务的实例返回不一致结果的过程相同。</p><p id="37d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有必要的话，花点时间整理一下你的桌面，这样你就可以看到三个服务的控制台窗口，Eureka，Zuul，以及你运行curl命令的窗口。</p><p id="c2fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重复执行下面的curl命令行指令，注意请求是通过Zuul、Eureka和某个<code class="fe mp mq mr ms b">heroes-service</code>实例传递的。这两个实例应该交替处理请求，因为它们被Zuul以循环方式调用。</p><pre class="mu mv mw mx gt my ms mz na aw nb bi"><span id="0348" class="nc kz iq ms b gy nd ne l nf ng">curl -i --request GET localhost:8080/heroes-service/heroes</span></pre><p id="6526" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仔细注意返回给curl请求的响应。您将会看到<code class="fe mp mq mr ms b">heroes-service</code>的每个实例都返回关于哪些英雄当前正忙的一致信息，并且这些信息与您之前执行的数据库查询的结果相匹配。如果所有这些结果在您的开发环境中都是正确的，那么您已经正确地实现了持久层。</p><p id="f0b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下图显示了应用程序中<em class="kw">请求</em>的流程。为简单起见，尤里卡服务不包括在内；因为它只提供服务注册，所以不会影响系统中的信息流。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/cc3dfb35e606db7ff33a38b1bfa9ba1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CjMGT5jgptpKHpVq.jpg"/></div></div></figure><p id="7002" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">描述了两种情况。</p><p id="441a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">蓝色箭头显示用户要求应用程序为一个威胁分配一个英雄:</p><ol class=""><li id="cc64" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv nn mh mi mj bi translated">一个HTTP POST请求到达位于<a class="ae kx" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>的Zuul，路由为<code class="fe mp mq mr ms b">threats-service</code>分配端点:<em class="kw">/分配</em>。POST请求包括一个JSON有效载荷，指定威胁和请求的英雄。</li><li id="92d4" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv nn mh mi mj bi translated">Zuul将POST请求转发给<code class="fe mp mq mr ms b">threats-service</code>实例(端口5000)。</li><li id="1412" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv nn mh mi mj bi translated">威胁服务<code class="fe mp mq mr ms b"> instance asks Zuul to perform a request to </code>英雄服务<code class="fe mp mq mr ms b"> and set the requested hero's status to busy.</code></li><li id="be3a" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv nn mh mi mj bi translated">Zuul选择一个可用的英雄-服务<code class="fe mp mq mr ms b"> instances and sends the request from </code>威胁-服务<code class="fe mp mq mr ms b">.</code></li><li id="14a8" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv nn mh mi mj bi translated">被选中的英雄-服务<code class="fe mp mq mr ms b"> instance updates the status of the hero in database.</code></li></ol><p id="071f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">红色箭头显示用户询问英雄列表:</p><ol class=""><li id="0464" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv nn mh mi mj bi translated">在<a class="ae kx" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>处，一个HTTP GET请求通过英雄服务<code class="fe mp mq mr ms b">heroes list endpoint: <em class="kw">/heroes</em>.</code>的路由到达Zuul</li><li id="8e6f" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv nn mh mi mj bi translated">Zull将GET请求转发给一个可用的英雄服务<code class="fe mp mq mr ms b"> instances (in this case, to the second one) based on its round robin load-leveling algorithm .</code></li><li id="6f81" class="mb mc iq ka b kb mk kf ml kj mm kn mn kr mo kv nn mh mi mj bi translated">heroes-service '实例从共享的MongoDB数据库中检索请求的数据。因为所有服务实例都共享持久层，所以每个服务都可以检索由任何其他实例写入的最新信息。</li></ol><h1 id="1cac" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="08f6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本文中，您了解了持久层如何对微服务应用程序的架构做出贡献，以及如何使用MongoDB Atlas实现基于云的持久层。您看到了如何通过向系统添加新实例来扩展服务。您看到了如何使用网飞·尤里卡和网飞·祖尔为微服务发现、动态路由和负载平衡提供开箱即用的解决方案。将整个系统放在一起，您看到了服务的多个实例如何通过持久层轻松共享信息，而不需要复杂的路由或数据操作功能。您还看到了如何将新版本的服务添加到正在运行的应用程序中，以提供新功能的无缝升级路径。</p><p id="77b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步<a class="ae kx" href="https://medium.com/@maciejtreder/protecting-javascript-microservices-on-node-js-with-json-web-tokens-and-twilio-authy-90d8ed780f5e" rel="noopener">使用JSON Web令牌和Twilio Authy </a>保护Node.js上的JavaScript微服务。</p><h1 id="ca81" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">额外资源</h1><p id="2ae9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated"><a class="ae kx" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" rel="noopener ugc nofollow" target="_blank">架构风格和基于网络的软件架构的设计</a>，罗伊·托马斯·菲尔丁，2000——菲尔丁的博士论文描述了表述性状态转移(第五章)和其他架构风格。</p><p id="c5b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">微服务</a>——尽管有缺陷，维基百科的文章是一个很好的起点，可以找到更多关于微服务架构和实现的信息。</p><p id="1d09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://nodejs.org/en/docs/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> —为应用服务器提供参考文档。</p><p id="2eed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://docs.mongodb.com/manual/" rel="noopener ugc nofollow" target="_blank">MongoDB 4.0手册</a> —涵盖了用JavaScript和其他编程语言实现MongoDB。</p><p id="4229" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/spring-cloud/spring-cloud-netflix" rel="noopener ugc nofollow" target="_blank"> Spring Cloud网飞项目</a>“…通过自动配置和绑定到Spring环境和其他Spring编程模型习惯用法，为Spring Boot应用程序提供网飞操作系统集成。”</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="33c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">我是Maciej Treder，通过</em><a class="ae kx" href="mailto:contact@maciejtreder.com" rel="noopener ugc nofollow" target="_blank"><em class="kw">【contact@maciejtreder.com】</em></a><em class="kw"/><a class="ae kx" href="https://www.maciejtreder.com/" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://www.maciejtreder.com</em></a><em class="kw">或@ maciejtreder on</em><a class="ae kx" href="http://github.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="kw">GitHub</em></a><em class="kw"/><a class="ae kx" href="https://twitter.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="kw">Twitter</em></a><em class="kw">和</em><a class="ae kx" href="https://www.linkedin.com/in/maciej-treder/" rel="noopener ugc nofollow" target="_blank"><em class="kw">LinkedIn</em></a><em class="kw">。</em></p><p id="f6da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本帖原载于Twilio博客</em><a class="ae kx" href="https://www.twilio.com/blog/scale-node-js-javascript-microservices-shared-mongodb-atlas" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw">。</em></p></div></div>    
</body>
</html>