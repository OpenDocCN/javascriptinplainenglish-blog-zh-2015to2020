<html>
<head>
<title>A Cautionary Tale on Using JavaScript’s fill() Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript的fill()方法的警示</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-cautionary-tale-on-using-javascripts-fill-method-e0939e2e16f4?source=collection_archive---------12-----------------------#2020-06-20">https://javascript.plainenglish.io/a-cautionary-tale-on-using-javascripts-fill-method-e0939e2e16f4?source=collection_archive---------12-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d5d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为ES6特性的一部分，<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" rel="noopener ugc nofollow" target="_blank"> Array.prototype.fill() </a>方法允许我们在数组中添加、替换或生成新元素。</p><p id="9780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，在数组中填充相同的元素时，这是普通for循环的一个聪明的替代方法。</p><p id="3261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您想要创建一个包含三个相同元素的数组，而不是创建一个空数组并通过For循环将每个新元素推入数组，那么这个一行程序就可以完成这个任务:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="d680" class="kv kw iq kr b gy kx ky l kz la">const threeFives = Array(3).fill(5)<br/>threeFives<br/>// [5, 5, 5]</span></pre><p id="ab7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们尝试在这个经典的螺旋矩阵算法挑战中实现<code class="fe lb lc ld kr b">fill()</code>方法。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="8e6b" class="kv kw iq kr b gy kx ky l kz la">/* Direction:<br/>Write a function that accepts an integer N, and returns a NxN spiral matrix. */</span><span id="ea76" class="kv kw iq kr b gy le ky l kz la">// Examples: </span><span id="8673" class="kv kw iq kr b gy le ky l kz la">matrix(2)<br/>// [[1, 2]<br/>// [4, 3]]</span><span id="91ad" class="kv kw iq kr b gy le ky l kz la">matrix(3)<br/>// [[1, 2, 3],<br/>//  [8, 9, 4],<br/>//  [7, 6, 5]]</span><span id="a67d" class="kv kw iq kr b gy le ky l kz la">matrix(4)<br/>// [[1,   2,  3, 4],<br/>//  [12, 13, 14, 5],<br/>//  [11, 16, 15, 6],<br/>//  [10,  9,  8, 7]]</span></pre><p id="c009" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没有尝试过这个挑战，我鼓励你在进一步阅读之前先尝试一下。</p><p id="4f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现的大多数解决方案都是从填充一个由空子数组组成的空数组开始的，就像这样:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="de51" class="kv kw iq kr b gy kx ky l kz la">function matrix(n) {<br/>    const results = []<br/>    for (let i = 0; i &lt; n; i++) {<br/>        results.push([])<br/>    }</span><span id="d42c" class="kv kw iq kr b gy le ky l kz la">    let counter = 1<br/>    let startColumn = 0<br/>    let endColumn = n - 1<br/>    let startRow = 0<br/>    let endRow = n - 1<br/>    while (startColumn &lt;= endColumn &amp;&amp; startRow &lt;= endRow){<br/>        // top row<br/>        for (let i = startColumn; i &lt;= endColumn; i++) {<br/>            results[startRow][i] = counter<br/>            counter++<br/>        }<br/>        startRow++<br/>        // right column<br/>        for (let i = startRow; i &lt;= endRow; i++) {<br/>            results[i][endColumn] = counter<br/>            counter++<br/>        }<br/>        endColumn--<br/>        // bottom row<br/>        for (let i = endColumn; i &gt;= startColumn; i--) {<br/>            results[endRow][i] = counter<br/>            counter++<br/>        }<br/>        endRow--<br/>        // start column<br/>        for (let i = endRow; i &gt;= startRow; i--) {<br/>            results[i][startColumn] = counter<br/>            counter++<br/>        }<br/>        startColumn++<br/>    }<br/>    return results<br/>}</span></pre><p id="cb56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，我们可以使用<code class="fe lb lc ld kr b">fill()</code>来代替前三行中的for循环。因此，与其说:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="8f27" class="kv kw iq kr b gy kx ky l kz la">const results = []<br/>    for (let i = 0; i &lt; n; i++) {<br/>        results.push([])<br/>    }</span></pre><p id="2435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以这样使用<code class="fe lb lc ld kr b">fill()</code>:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="9209" class="kv kw iq kr b gy kx ky l kz la">const results = Array(n).fill([])</span></pre><p id="552c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，当您在控制台中记录<code class="fe lb lc ld kr b">results</code>时，您可以看到它们产生了相同的输出。</p><p id="f5f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酷，所以如果我们在解决方案的其余部分保持相同的逻辑，我们会看到相同的结果，对不对？</p><p id="5e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不对。</p><p id="7b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>，如果<code class="fe lb lc ld kr b">fill()</code>方法的第一个参数是一个对象，“数组中的每个槽都将引用那个对象。”</p><figure class="km kn ko kp gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lf"><img src="../Images/0c9380ee04209a116c615b4762681652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HI76kHHGSxqZIzJy.png"/></div></div></figure><p id="ac30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是使用<code class="fe lb lc ld kr b">fill()</code>可能会弄乱你制作精美的矩阵函数的地方。</p><p id="a7d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如相同的MDN文档所示，如果您传入一个对象并改变一个对象中的项目，数组中的所有后续对象都将填充相同的项目。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="edaf" class="kv kw iq kr b gy kx ky l kz la">let arr = Array(3).fill({}) // [{}, {}, {}]<br/>arr[0].hi = "hi"            // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]</span></pre><p id="c4e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，在矩阵函数中，我们通过<code class="fe lb lc ld kr b">fill()</code>创建的所有子数组都将改变，即使我们只想改变一个子数组。</p><p id="aba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我控制台记录了主矩阵产品中每个迭代的结果。正如你在下面看到的，所有用<code class="fe lb lc ld kr b">fill([])</code>创建的子数组保持镜像第一个子数组:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="26bc" class="kv kw iq kr b gy kx ky l kz la">using for loop:  [ [ 1 ], [] ]<br/>using fill([]):  [ [ 1 ], [ 1 ] ]<br/>=====<br/>using for loop:  [ [ 1, 2 ], [] ]<br/>using fill([]):  [ [ 1, 2 ], [ 1, 2 ] ]<br/>=====<br/>using for loop:  [ [ 1, 2 ], [ &lt;1 empty item&gt;, 3 ] ]<br/>using fill([]):  [ [ 1, 3 ], [ 1, 3 ] ]<br/>=====<br/>using for loop:  [ [ 1, 2 ], [ 4, 3 ] ]<br/>using fill([]):  [ [ 4, 3 ], [ 4, 3 ] ]<br/>=====</span></pre><p id="6d24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是否意味着我们不应该使用<code class="fe lb lc ld kr b">fill()</code>来创建一个空的子数组？</p><p id="79f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我发现的一个解决方案，它似乎可以成功地生成数组占位符，而且没有副作用:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="04f6" class="kv kw iq kr b gy kx ky l kz la">const results = Array(n).fill().map(()=&gt;Array(n).fill());</span></pre><p id="4d12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不是用数组填充数组，数组是对象类型，而是简单地用空值填充。在JavaScript中，空值是<code class="fe lb lc ld kr b">undefined</code>，它不是一个对象，因此允许我们在每次迭代中重新分配新项，而不会影响其他子数组。</p><p id="39d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过比较生成数组和子数组的所有三种用法，可以看出它们之间的区别:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="0b0f" class="kv kw iq kr b gy kx ky l kz la">using for loop:  [ [ 1 ], [] ]<br/>using fill([]):  [ [ 1 ], [ 1 ] ]<br/>using fill().map():  [ [ 1, undefined ], [ undefined, undefined ] ]<br/>=====<br/>using for loop:  [ [ 1, 2 ], [] ]<br/>using fill([]):  [ [ 1, 2 ], [ 1, 2 ] ]<br/>using fill().map():  [ [ 1, 2 ], [ undefined, undefined ] ]<br/>=====<br/>using for loop:  [ [ 1, 2 ], [ &lt;1 empty item&gt;, 3 ] ]<br/>using fill([]):  [ [ 1, 3 ], [ 1, 3 ] ]<br/>using fill().map():  [ [ 1, 2 ], [ undefined, 3 ] ]<br/>=====<br/>using for loop:  [ [ 1, 2 ], [ 4, 3 ] ]<br/>using fill([]):  [ [ 4, 3 ], [ 4, 3 ] ]<br/>using fill().map():  [ [ 1, 2 ], [ 4, 3 ] ]<br/>=====</span></pre><p id="ad0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一次，当您尝试使用<code class="fe lb lc ld kr b">fill()</code>方法时，一定要检查您正在传递的值的类型。这是我从<em class="ln">第二次尝试几乎</em>破解螺旋矩阵代码挑战中学到的惨痛教训。</p><figure class="km kn ko kp gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lo"><img src="../Images/17633ae20afe171d8baf818cdc37ea31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8t_q6DiirRy7n1KW"/></div></div></figure></div></div>    
</body>
</html>