<html>
<head>
<title>Using the URLSearchParams Object in JavaScript — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用URLSearchParams对象—第2部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-urlsearchparams-object-in-javascript-part-2-b63006f605df?source=collection_archive---------7-----------------------#2020-01-07">https://javascript.plainenglish.io/using-the-urlsearchparams-object-in-javascript-part-2-b63006f605df?source=collection_archive---------7-----------------------#2020-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/620cdbfc040fcf57eff012e6e6c87ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6TNU7pejBDSQLiFu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rami_alzayat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rami Al-zayat</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="737f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不得不从头开始编写代码来解析和修改查询字符串，那么处理查询字符串可能会很痛苦。幸运的是，大多数最新的浏览器都有URLSearchParams对象，可以让我们轻松地处理查询字符串。有了它，解析和操作查询字符串就变得容易了。我们不再需要第三方库或从头开始编写代码来处理查询字符串。在本文中，我们继续本指南的第1部分。</p><p id="9b67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe lb lc ld le b">URLSearchParams</code>构造函数创建一个URLSearchParams对象。<code class="fe lb lc ld le b">URLSearchParams</code>构造函数接受一个可选参数，这是一个包含查询字符串的<code class="fe lb lc ld le b">USVString </code>参数。<code class="fe lb lc ld le b">USVString</code>对象对应于Unicode标量值的所有可能序列的集合。在我们的代码中，我们可以像对待常规字符串一样对待它们。它可以是一系列的<code class="fe lb lc ld le b">USVString</code>或包含<code class="fe lb lc ld le b">USVString</code>的记录。在我们的代码中，我们不必关心<code class="fe lb lc ld le b">USVString</code> s。实际上，它们被视为字符串。我们可以像下面的代码一样构造一个<code class="fe lb lc ld le b">URLSearchParams</code>对象:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5499" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>console.log(params.get('key1'));<br/>console.log(params.get('key2'));</span></pre><p id="54d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建<code class="fe lb lc ld le b">URLSearchParams</code>对象还有其他方法，包括传入其他类型的对象。要查看详细信息，请参阅本指南的第1部分。</p><h1 id="fb7b" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">更多方法</h1><p id="aeee" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">每个<code class="fe lb lc ld le b">URLSearchParams</code>实例都有多种方法来获取键和值，并通过添加、更改和删除键或值来操作它们。使用这些方法，我们可以轻松地构造查询字符串，而不必直接进行字符串操作。如果我们想在操作后得到完整的查询字符串，我们可以用<code class="fe lb lc ld le b">toString()</code>方法得到它。</p><h2 id="4709" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">得到</h2><p id="8318" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated"><code class="fe lb lc ld le b">URLSearchParams</code>对象的<code class="fe lb lc ld le b">get</code>方法让我们通过给定的键获得查询字符串的值。它有一个参数，即带有键名的字符串。如果找到搜索参数，则返回值的<code class="fe lb lc ld le b">USVString</code>，否则返回<code class="fe lb lc ld le b">null</code>。例如，如果我们有下面的查询字符串和<code class="fe lb lc ld le b">URLSearchParams</code>对象，如下面的代码所示:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="67eb" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>console.log(params.get('key1'));</span></pre><p id="5131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从上面的<code class="fe lb lc ld le b">console.log</code>语句中得到1。如果我们有多个具有相同键的键-值对，如下例所示:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3b07" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key1', 2);<br/>params.append('key1', 3);<br/>console.log(params.get('key1'));</span></pre><p id="ba68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到第一个值，它是从<code class="fe lb lc ld le b">get</code>方法返回的值。如果我们想获得与给定键相关的所有值，我们可以使用<code class="fe lb lc ld le b">getAll</code>方法。即使我们不使用<code class="fe lb lc ld le b">append </code>方法向查询字符串添加更多的键值对，情况也是一样的:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c3a9" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key1=2&amp;key1=3&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key1=2&amp;key1=3&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>console.log(params.get('key1'));</span></pre><p id="68ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们仍然从上面的<code class="fe lb lc ld le b">console.log</code>输出中得到1。</p><p id="a318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图用一个不存在的键获取一个值，那么我们得到的是返回的<code class="fe lb lc ld le b">null</code>，如下例所示:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a9c2" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>console.log(params.get('abc'));</span></pre><p id="f2eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从上面的<code class="fe lb lc ld le b">console.log</code>语句中得到<code class="fe lb lc ld le b">null</code>，因为我们没有带有关键字<code class="fe lb lc ld le b">'abc'</code>的搜索参数。</p><h2 id="14a3" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">getAll</h2><p id="ffee" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">使用<code class="fe lb lc ld le b">getAll</code>方法，我们可以获得所有带有相关键名的值。它接受一个参数，该参数是一个带有键名的字符串，并返回带有与键名相关联的所有值的<code class="fe lb lc ld le b">USVString</code>数组。例如，如果我们有以下代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6b53" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key1', 2);<br/>params.append('key1', 3);<br/>console.log(params.getAll('key1'));</span></pre><p id="6667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从上面的<code class="fe lb lc ld le b">console.log</code>语句得到<code class="fe lb lc ld le b">[“1”, “2”, “3”]</code>。</p><h2 id="0a5c" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">有</h2><p id="6d60" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">如果具有给定键的值存在，<code class="fe lb lc ld le b">has</code>方法返回一个布尔值<code class="fe lb lc ld le b">true</code>。它有一个参数，这是一个字符串，带有我们要查找的键名。例如，我们可以在下面的代码中使用<code class="fe lb lc ld le b">has</code>方法:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="cf1f" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key1', 2);<br/>params.append('key1', 3);<br/>console.log(params.has('key1'));<br/>console.log(params.has('abc'));</span></pre><p id="cdda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们运行上面的代码时，我们得到第一个<code class="fe lb lc ld le b">console.log</code>语句将输出<code class="fe lb lc ld le b">true</code>，而第二个语句将输出<code class="fe lb lc ld le b">false</code>。这是我们所期望的，因为我们将<code class="fe lb lc ld le b">‘key1’</code>作为一个或多个搜索参数的关键字，但是我们没有任何将<code class="fe lb lc ld le b">'abc'</code>作为关键字的搜索参数。</p><h2 id="2191" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">键</h2><p id="8aac" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">keys</code>方法获得一个迭代器，让我们遍历查询字符串中的所有搜索参数键。钥匙都是<code class="fe lb lc ld le b">USVString </code>的物件。它不带参数，返回一个迭代器，让我们遍历搜索参数键。例如，我们可以写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9497" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);</span><span id="cf3b" class="ln lo iq le b gy ng lq l lr ls">for (const key of params.keys()) {<br/>  console.log(key);<br/>}</span></pre><p id="7b1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们从上面的<code class="fe lb lc ld le b">console.log</code>语句中得出以下内容:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3174" class="ln lo iq le b gy lp lq l lr ls">key1<br/>key2</span></pre><h2 id="ba37" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">设置</h2><p id="8feb" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated"><code class="fe lb lc ld le b">URLSeacrchParam</code>实例的<code class="fe lb lc ld le b">set</code>方法让我们用给定的搜索参数键设置值。它需要两个参数。第一个是带有搜索参数键的字符串，第二个是要设置为带有给定键的值的值。如果有几个值具有相同的键，那么它们将被删除。如果带有给定键的搜索参数不存在，那么这个方法将创建它。</p><p id="7cb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以像下面的代码一样使用它:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0f90" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key1', 2);<br/>params.append('key1', 3);<br/>params.set('key1', 5);<br/>console.log(params.getAll('key1'));<br/>console.log(params.toString());</span></pre><p id="7b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，将从上面的第一个<code class="fe lb lc ld le b">console.log</code>语句中获得数组<code class="fe lb lc ld le b">[“5”]</code>。如我们所料，<code class="fe lb lc ld le b">key1</code>的所有其他值都被删除了。第二个<code class="fe lb lc ld le b">console.log</code>语句将得到<code class="fe lb lc ld le b">key1=5&amp;key2=2</code>，它与我们从<code class="fe lb lc ld le b">getAll</code>方法中得到的相匹配。我们还可以使用它来创建新的搜索参数键值对，就像我们对以下代码所做的那样:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="86ae" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key1', 2);<br/>params.append('key1', 3);<br/>params.set('abc', 1);<br/>console.log(params.getAll('abc'));<br/>console.log(params.toString());</span></pre><p id="0f77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们运行上面的代码之后，我们从第一个<code class="fe lb lc ld le b">console.log</code>语句中返回<code class="fe lb lc ld le b">[“1”]</code>，这意味着带有关键字<code class="fe lb lc ld le b">'abc'</code>和值1的搜索参数被创建，就像我们期望的那样。当我们使用<code class="fe lb lc ld le b">toString()</code>方法时得到的查询字符串是<code class="fe lb lc ld le b">key1=1&amp;key2=2&amp;key1=2&amp;key1=3&amp;abc=1</code>，这与我们从<code class="fe lb lc ld le b">getAll()</code>方法中得到的一致。</p><h2 id="336f" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">分类</h2><p id="be9d" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们可以用<code class="fe lb lc ld le b">sort()</code>方法按键对<code class="fe lb lc ld le b">URLSearchParams</code>对象的键值对进行排序。排序顺序由键的Unicode码位决定。具有相同键的键值对之间的相对顺序将被保留。这个方法不接受任何参数并返回<code class="fe lb lc ld le b">undefined</code>。例如，我们可以在下面的代码中使用它:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="010b" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key1', 2);<br/>params.append('key1', 3);<br/>params.set('abc', 1);<br/>params.sort();<br/>console.log(params.toString());</span></pre><p id="e535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，我们会得到:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="53ce" class="ln lo iq le b gy lp lq l lr ls">abc=1&amp;key1=1&amp;key1=2&amp;key1=3&amp;key2=2</span></pre><p id="79d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<code class="fe lb lc ld le b">console.log</code>语句的输出来看，这是我们所期望的，因为<code class="fe lb lc ld le b">'abc'</code>比<code class="fe lb lc ld le b">'key1'</code>具有更低的码位，而<code class="fe lb lc ld le b">‘key1'</code>比<code class="fe lb lc ld le b">key2'</code>具有更低的码位值。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/86c4b015b01f283c968053aa59c03694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C5N5TM3RGMKaKYn6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@philipestrada?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Philip Estrada</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="7d7a" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">toString</h2><p id="17b7" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">正如我们在前面的例子中看到的，<code class="fe lb lc ld le b">toString()</code>方法返回查询字符串，我们可以把它放在URL中。在完成对<code class="fe lb lc ld le b">URLSearchParams</code>对象的操作后，返回的查询字符串将包含结果。注意，返回的查询字符串前面不会有问号，不像从<code class="fe lb lc ld le b">window.location.searh</code>返回的那样。例如，如果我们有:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="80b9" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key3', 3);<br/>params.append('key4', 4);<br/>params.set('key5', 5);<br/>console.log(params.toString());</span></pre><p id="bb6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们回来了:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c443" class="ln lo iq le b gy lp lq l lr ls">'key1=1&amp;key2=2&amp;key3=3&amp;key4=4&amp;key5=5'</span></pre><p id="473f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正是我们所期望的。我们有从URL对象解析的所有搜索参数，以及我们用<code class="fe lb lc ld le b">URLSearchParams</code>对象的<code class="fe lb lc ld le b">append()</code>方法添加的内容，还有我们用<code class="fe lb lc ld le b">set()</code>方法添加的内容。</p><h2 id="d8a0" class="ln lo iq bd lu mv mw dn ly mx my dp mc ko mz na mg ks nb nc mk kw nd ne mo nf bi translated">价值观念</h2><p id="0403" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated"><code class="fe lb lc ld le b">values</code>方法返回一个迭代器，让我们遍历包含在<code class="fe lb lc ld le b">URLSearchParams</code>对象中的所有值。迭代器可以由<code class="fe lb lc ld le b">for...of</code>循环遍历，并由spread操作符操作。这不需要争论。例如，如果我们有以下代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9496" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>params.append('key3', 3);<br/>params.append('key4', 4);<br/>params.set('key5', 5);<br/>for (const value of params.values()) {<br/>  console.log(value);<br/>}</span></pre><p id="06c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从循环中的<code class="fe lb lc ld le b">console.log</code>语句得到以下输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="fc42" class="ln lo iq le b gy lp lq l lr ls">1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="1543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们在搜索参数中设置的值。</p><h1 id="20d1" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用URLSearchParams对象时捕获</h1><p id="e10e" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated"><code class="fe lb lc ld le b">URLSearchParams</code>构造函数不能解析完整的URL。大概是这样的:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ed62" class="ln lo iq le b gy lp lq l lr ls">const params = new URLSearchParams('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);</span><span id="ebbb" class="ln lo iq le b gy ng lq l lr ls">for (const [key, value] of params.entries()) {<br/>  console.log(key, value);<br/>}</span></pre><p id="0227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不会起作用。当我们运行上面的代码时，我们从<code class="fe lb lc ld le b">console.log</code>语句中得到以下输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="74cc" class="ln lo iq le b gy lp lq l lr ls"><a class="ae kc" href="https://example.com?key1" rel="noopener ugc nofollow" target="_blank">https://example.com?key1</a> 1<br/>key2 2</span></pre><p id="a896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，第一个等号前的整个URL被解析为第一个搜索参数的键，这是错误的。这意味着我们必须使用URL对象的search属性来获取查询字符串并传递它，就像我们在下面的示例中所做的那样:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ffca" class="ln lo iq le b gy lp lq l lr ls">const url = new URL('<a class="ae kc" href="https://example.com?key1=1&amp;key2=2'" rel="noopener ugc nofollow" target="_blank">https://example.com?key1=1&amp;key2=2'</a>);<br/>const params = new URLSearchParams(url.search);<br/>for (const [key, value] of params.entries()) {<br/>  console.log(key, value);<br/>}</span></pre><p id="b0f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，我们会从<code class="fe lb lc ld le b">console.log</code>语句中得到以下输出:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="419d" class="ln lo iq le b gy lp lq l lr ls">key1 1<br/>key2 2</span></pre><p id="3153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的输出是我们想要的，因为这些是实际的搜索参数键值对。</p><p id="9122" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数最新的浏览器都有<code class="fe lb lc ld le b">URLSearchParams </code>对象，可以让我们轻松处理查询字符串。现在，处理查询字符串不再是一件痛苦的事情，因为我们不必从头开始编写代码来解析和修改它。有了<code class="fe lb lc ld le b">URLSearchParams</code>对象，解析和操作查询字符串就变得容易了。我们不再需要第三方库或从头开始编写代码来处理查询字符串。唯一的问题是，我们必须向构造函数传入一个查询字符串，或者像映射和数组这样的序列，将键值对作为一个数组，key作为第一个元素，value作为第二个元素。关于如何构造<code class="fe lb lc ld le b">URLSearchParams</code>对象的更多细节，请参见第1部分。</p></div></div>    
</body>
</html>