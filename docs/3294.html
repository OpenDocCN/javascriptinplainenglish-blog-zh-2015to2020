<html>
<head>
<title>ES2020 and null: Optional Chaining and Null Coalescing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2020和null:可选链接和Null合并</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/null-and-es2020-optional-chaining-and-null-coalescing-e62e31fb0240?source=collection_archive---------6-----------------------#2020-09-16">https://javascript.plainenglish.io/null-and-es2020-optional-chaining-and-null-coalescing-e62e31fb0240?source=collection_archive---------6-----------------------#2020-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/8c3271cb9725593f67316799e78840a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*lnrA7-KL8mTZFPOtwjW_yQ.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Plenty of Question Marks</figcaption></figure><p id="2187" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当Javascript开发人员想到ECMA时，他们会提到2015年的变化，这些变化改善了语法，并为语言添加了新功能。然而，ECMA仍然更新语言！今年早些时候，他们发布了ES11，其中有两个我最喜欢的工具:可选链接和空合并！</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="b3b5" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">简史<em class="ly">null</em>T11】</strong></h1><p id="2990" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated"><em class="me"> null </em>是一种非常有趣的数据类型。它是一个<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">原语</a>类型，以及字符串、数字、布尔、符号和未定义。(边注:从ES11开始，BigInt现在是另一个原语类型了！)原始类型是不可变的，而对象(包括数组)是可以变异的。</p><p id="40c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，<em class="me"> null </em>是奇数的原始输出。当您在任何数据类型上使用<code class="fe mg mh mi mj b">typeof</code>时，您都会得到一个合理的预期响应:<code class="fe mg mh mi mj b">typeof 3</code>是一个<code class="fe mg mh mi mj b">Number</code> , <code class="fe mg mh mi mj b">typeof {foo: "bar"}</code>是一个<code class="fe mg mh mi mj b">Object</code>，等等。由于Javascript的开发方式，当<code class="fe mg mh mi mj b">typeof</code>应用于null<em class="me">时，它被认为是一个<code class="fe mg mh mi mj b">Object</code>。查看阿克塞尔·劳施迈尔博士撰写的这篇精彩的<a class="ae mf" href="https://2ality.com/2013/10/typeof-null.html" rel="noopener ugc nofollow" target="_blank">文章</a>，了解更多细节！</em></p><p id="0a7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="me"> null </em>是一个假值，大致等于<em class="me"> undefined ( </em> <code class="fe mg mh mi mj b">undefined == null // TRUE</code>)，最重要的是<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">表示故意缺少任何对象值</a>。当一个值未被定义时，它将总是接收<em class="me">未定义</em>的值。当Javascript开发人员声明一个变量但希望它为空时，他们会将值设置为<em class="me"> null </em>。<em class="me"> null </em>从不被Javascript赋值，只被开发者赋值；如果它没有任何有意义的数据，给出一个空值是一个有用的工具。得到一个空值意味着你的变量被声明并且确实存在，自动通知你不需要调整变量声明，提升，或者范围问题:这个值是可用的，只是没有任何信息。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mk"><img src="../Images/753e009e3cd076483ed7b66f079c7f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oj6GC0qfmtQLP-0TECOPmA.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Visual Demonstration</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="80f4" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">可选链接</h1><p id="2129" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">你遇到过这种情况吗？！</p><pre class="ml mm mn mo gt mt mj mu mv aw mw bi"><span id="5183" class="mx lb in mj b gy my mz l na nb">const friendData = props.user.friends.map(callback)</span><span id="9d06" class="mx lb in mj b gy nc mz l na nb">Uncaught TypeError: cannot read property 'friends' of undefined</span></pre><p id="8636" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的应用程序需要访问一些数据，您依赖一系列方法或属性来评估您真正想要的数据。可选链接是来拯救你的！</p><p id="e401" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可选链接允许您保留嵌套链，而不必添加一大堆条件。如果该属性不能被访问，剩余的方法或属性不求值，返回值是<em class="me">未定义的</em>。您所要做的就是在可能为空的值后面添加一个<code class="fe mg mh mi mj b">?</code>, JS会完成剩下的工作</p><pre class="ml mm mn mo gt mt mj mu mv aw mw bi"><span id="dda6" class="mx lb in mj b gy my mz l na nb">const friendData = props.user?.friends.map(callback)</span><span id="3bd9" class="mx lb in mj b gy nc mz l na nb">console.log(friendData)<br/>// undefined</span></pre><p id="9fe2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，这可能会产生误导；我的值声明了，我不希望它被<em class="me">未定义。这就是Nullish合并的用武之地！</em></p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="d999" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">无效合并</h1><p id="295a" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">Nullish合并将检查一个值是否是nullish(也就是说，或者是<em class="me"> null </em>或者是<em class="me"> undefined </em>)，并允许进行一些其他的评估。使用上面的例子，如果方法链变得<em class="me">未定义</em>，新的nullish合并操作符<code class="fe mg mh mi mj b">??</code>将改变值。</p><pre class="ml mm mn mo gt mt mj mu mv aw mw bi"><span id="63f7" class="mx lb in mj b gy my mz l na nb">const friendData = props.user?.friends.map(callback) ?? []</span><span id="42b8" class="mx lb in mj b gy nc mz l na nb">console.log(friendData)<br/>// []</span></pre><p id="61b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我可以让这个链计算一个数组，或者空值，这取决于后续数据的需要。这个新操作符也适用于条件句！</p><pre class="ml mm mn mo gt mt mj mu mv aw mw bi"><span id="38d0" class="mx lb in mj b gy my mz l na nb">const value = previousVariable ?? false</span></pre><p id="7be5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果左侧的值为假值，如<code class="fe mg mh mi mj b">"", false, 0</code>，则不会触发nullish合并运算符，但前提是该值为<em class="me"> null </em>或<em class="me"> undefined </em>。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="fbb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">始终关注ECMAScript的新特性；ES6不是JavaScript的最终形式！我希望这些新的ES11特性对你有所帮助！</p></div></div>    
</body>
</html>