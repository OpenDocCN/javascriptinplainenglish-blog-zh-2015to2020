<html>
<head>
<title>Better JavaScript — No Globals or with</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的JavaScript——没有全局变量或有</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/better-javascript-no-globals-or-with-be8f82ff4d2?source=collection_archive---------17-----------------------#2020-10-06">https://javascript.plainenglish.io/better-javascript-no-globals-or-with-be8f82ff4d2?source=collection_archive---------17-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/64b48da1bbaa24e27379237d0fbcab71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ew81W7aeiSxn1EjT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mzoe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marco Zoppi</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9122" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进JavaScript代码的方法。</p><h1 id="802d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最小化全局对象的用户</h1><p id="de79" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">全局对象违背了模块化原则。</p><p id="c962" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的变量在任何地方都是可用的。</p><p id="a3d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何东西都可以改变它们。</p><p id="a684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们与他们合作时遇到的一个问题。</p><p id="5c59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很难追踪它们的价值，因为它们可以被任何东西改变。</p><p id="166f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用全局变量时，所有的组件都耦合在一起。</p><p id="bc1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们有大的应用程序时，这肯定是不可接受的。</p><p id="9fc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们拥有模块之前，全局名称空间是JavaScript应用程序的独立部分进行交互的唯一方式。</p><p id="26cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该使用模块来分离各个部分，让我们使用我们想要的部分。</p><p id="70ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该小心不要意外地创建全局变量。</p><p id="a546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在顶层创建一个带有<code class="fe me mf mg mh b">var</code>的变量，我们就可以做到这一点。</p><p id="6d3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7994" class="mq lc iq mh b gy mr ms l mt mu">var x = 1;</span></pre><p id="8c17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该在顶层创建函数声明。</p><p id="190d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4227" class="mq lc iq mh b gy mr ms l mt mu">function foo() {}</span></pre><p id="dbf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该通过给没有定义的东西赋值而意外地创建全局变量。</p><p id="bc40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以不要写这样的话:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eb25" class="mq lc iq mh b gy mr ms l mt mu">foo = 1;</span></pre><p id="5ba2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b789" class="mq lc iq mh b gy mr ms l mt mu">this.foo = 1;</span></pre><p id="6ae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最高层。</p><p id="231d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些语句都更新全局对象。</p><p id="2342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以防止最后两项用struct模式创建全局变量。</p><p id="30ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然可以使用JavaScript标准库中的全局对象。</p><p id="654b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用像<code class="fe me mf mg mh b">Array</code>、<code class="fe me mf mg mh b">Number</code>、<code class="fe me mf mg mh b">JSON</code>等这样的对象。</p><p id="1c6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们绝对不应该创造新的。</p><p id="5bb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想让应用程序的其他部分可以访问代码，我们应该使用模块。</p><p id="9e72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浏览器支持开箱即用的模块，我们可以使用模块捆绑器将它们构建到一个应用程序中。</p><h1 id="fe63" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总是声明局部变量</h1><p id="c6f7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该总是声明局部变量。</p><p id="a744" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以使用<code class="fe me mf mg mh b">let</code>和<code class="fe me mf mg mh b">const</code>关键字。</p><p id="c40b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都是块范围的，所以变量留在块内。</p><p id="6714" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="37cc" class="mq lc iq mh b gy mr ms l mt mu">function swap(arr, i, j) {<br/>  temp = arr[i];<br/>  arr[i] = arr[j];<br/>  arr[j] = temp;<br/>}</span></pre><p id="5652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9c8e" class="mq lc iq mh b gy mr ms l mt mu">function swap(arr, i, j) {<br/>  const temp = arr[i];<br/>  arr[i] = arr[j];<br/>  arr[j] = temp;<br/>}</span></pre><p id="5bc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在变量名前添加了<code class="fe me mf mg mh b">const</code>,这样我们就不会声明一个全局变量。</p><p id="c58d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建全局变量绝对是一种不好的风格。</p><p id="88b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">意外地创造它们更糟糕。</p><p id="5f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用linter来自动检查这类错误。</p><p id="b0b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是像ESLint这样的linters会检查的事情之一。</p><h1 id="1271" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免with语句</h1><p id="f63c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在代码中使用<code class="fe me mf mg mh b">with</code>语句。</p><p id="af33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它没有提供很多便利，但是它确实提供了很多不可靠性和低效率。</p><p id="9c09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">低效来自于不能通过检查代码来确定范围。</p><p id="afd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，优化是不可能的。</p><p id="b783" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">范围的不确定性也意味着处理内部的东西是令人困惑的。</p><p id="7df1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有这样的东西:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="704c" class="mq lc iq mh b gy mr ms l mt mu">function foo(x, y) {<br/>  with(Math) {<br/>    return min(round(x), sqrt(y)); <br/>  }<br/>}</span></pre><p id="f276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们不知道<code class="fe me mf mg mh b">x</code>和<code class="fe me mf mg mh b">y</code>是来自参数还是来自<code class="fe me mf mg mh b">Math</code>物体。</p><p id="6abf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该使用它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/5bae9a6c185c66c142ddf500d013d7d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0o7sV7vuDPB2laL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ling_gigi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gigi</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3364" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4c0a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该总是避免创建全局变量，避免使用<code class="fe me mf mg mh b">with</code>语句。</p><p id="5947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>