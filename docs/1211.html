<html>
<head>
<title>JavaScript new features in ES2019(ES10)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2019(ES10)中的JavaScript新功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-es2019-es10-in-a-nutshell-cae6f7524519?source=collection_archive---------1-----------------------#2020-02-13">https://javascript.plainenglish.io/javascript-es2019-es10-in-a-nutshell-cae6f7524519?source=collection_archive---------1-----------------------#2020-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5afb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简短、有用的JavaScript课程——让它变得简单。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a92258aa41470d9bebf40f21338058a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6U7XOPa_p7nuS4AmxNtNlw.jpeg"/></div></div></figure><p id="d953" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ECMAScript规范的2019版有许多新功能。其中，我将总结那些对我来说最有用的。</p><p id="e721" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，您可以在<strong class="kt ir">节点运行这些示例，js ≥12 </strong>。要在Ubuntu-Debian-Mint上安装Node.js 12，您可以执行以下操作:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="71b6" class="ls lt iq lo b gy lu lv l lw lx">$sudo apt update<br/>$sudo apt -y upgrade<br/>$sudo apt update<br/>$sudo apt -y install curl dirmngr apt-transport-https lsb-release  ca-certificates<br/>$curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -<br/>$sudo apt -y install nodejs</span></pre><p id="55f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，在<strong class="kt ir"> Chrome Version ≥72、</strong>中，您可以在开发者控制台中尝试这些功能(Alt +j)。</p><h1 id="719b" class="ly lt iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">array . prototype . flat &amp; &amp; array . prototype . flat map</h1><p id="0819" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated"><strong class="kt ir"> flat() </strong>方法创建一个新的数组，所有子数组元素递归连接到该数组中，直到指定的深度。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="d7fd" class="ls lt iq lo b gy lu lv l lw lx">let array1 = ['a','b', [1, 2, 3]];<br/>let array2 = array1.flat();<br/>//['a', 'b', 1, 2, 3]</span></pre><p id="0191" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还应该注意，该方法排除了数组中的间隙或空元素:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="3cbb" class="ls lt iq lo b gy lu lv l lw lx">let array1 = ['a', 'b', , , , 'c'];<br/>let array2 = array1.flat();<br/>// ['a','b','c']</span></pre><p id="5d9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">flatMap()方法的效果与使用Map()方法后跟flat()方法的效果相同，默认深度为1</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="9fb5" class="ls lt iq lo b gy lu lv l lw lx">let array1 = [1, 2, 3, 4];</span><span id="18b0" class="ls lt iq lo b gy mu lv l lw lx">array1.flatMap(x =&gt; [x + 1]);<br/>// [2, 3, 4, 5]</span></pre><h1 id="52a6" class="ly lt iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">对象. fromEntries()</h1><p id="a76d" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">它创建一个对象或将键值对转换成一个对象。它只接受<a class="ae mv" href="https://alligator.io/js/iterables/" rel="noopener ugc nofollow" target="_blank">项</a>。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="1102" class="ls lt iq lo b gy lu lv l lw lx">const obj = { a: 1, b: 2, c: 3};</span><span id="7e2d" class="ls lt iq lo b gy mu lv l lw lx">const entries = Object.entries(obj);<br/>// entries<br/>(3) [Array(2), Array(2), Array(2)]<br/>0: (2) ["a", 1]<br/>1: (2) ["b", 2]<br/>2: (2) ["c", 3]</span><span id="c9d4" class="ls lt iq lo b gy mu lv l lw lx">const obj2 = Object.fromEntries(entries)<br/>// {a: 1, b: 2, c: 3}</span></pre><h1 id="8ad5" class="ly lt iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">string . trim start()&amp; string . trimend()</h1><p id="249d" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">trims start()/trimEnd()方法删除字符串开头/结尾的空白。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="bca7" class="ls lt iq lo b gy lu lv l lw lx">let result = '      hello!'.trimStart();<br/>// "hello!"</span><span id="d409" class="ls lt iq lo b gy mu lv l lw lx">let cadena = 'hello      '.trimEnd()<br/>// "hello!"</span></pre><h1 id="488e" class="ly lt iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">可选锁扣</h1><p id="6836" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">它允许我们使用try /catch，而无需在catch块中提供错误参数。</p><p id="4a97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mw">无可选锁扣:</em></p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="faca" class="ls lt iq lo b gy lu lv l lw lx">try {<br/>    // do something<br/>} catch (e) {<br/>    // we have error parameter to handle it<br/>}</span></pre><p id="5f84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mw">带可选锁扣:</em></p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="9905" class="ls lt iq lo b gy lu lv l lw lx">try {<br/>    // do something<br/>} catch {<br/>    // no binding or parameter to handle it<br/>}</span></pre><p id="6432" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然在大多数情况下不建议这样做，但是当您知道您不打算使用异常对象时，这样做是有意义的。</p><h1 id="1be4" class="ly lt iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">函数“toString”修订版</h1><p id="1fcf" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">现在，toString方法必须返回从第一个标记开始到最后一个标记结束的源文本片段，并匹配适当的语法。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="3bde" class="ls lt iq lo b gy lu lv l lw lx">function /* kk*/ foo() { /* cc */ }</span><span id="83bd" class="ls lt iq lo b gy mu lv l lw lx">// before:<br/>foo.toString();<br/>// "function foo() {}"</span><span id="6593" class="ls lt iq lo b gy mu lv l lw lx">// Now:<br/>foo.toString();<br/>//"function /* kk*/ foo() { /* cc */ }"</span></pre><h1 id="7320" class="ly lt iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">数组。排序稳定性</h1><p id="3ddf" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">以前，V8对超过10个元素的数组使用不稳定的快速排序。V8(Chrome ≥70)采用稳定的TimSort算法。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="105e" class="ls lt iq lo b gy lu lv l lw lx">const array1 = [<br/> { name: "a",   age: 14 },<br/> { name: "b", age: 14 },<br/> { name: "c",  age: 13 },<br/> { name: "d",   age: 13 },<br/> { name: "e",   age: 13 },<br/> { name: "f",    age: 13 },<br/> { name: "g",   age: 13 },<br/> { name: "h",  age: 13 },<br/> { name: "i",   age: 12 },<br/> { name: "j",   age: 12 },<br/> { name: "k",    age: 12 }<br/>]</span><span id="8beb" class="ls lt iq lo b gy mu lv l lw lx"><strong class="lo ir">const array2 = array1.sort( (a,b) =&gt; b.age - a.age)</strong></span></pre><p id="ce29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数组按名称的字母顺序预先排序。为了按年龄排序，我们传递了一个比较年龄的自定义回调。这是您所期望的结果:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="ec0f" class="ls lt iq lo b gy lu lv l lw lx"><strong class="lo ir">0: {name: "a", age: 14}<br/>1: {name: "b", age: 14}</strong><br/>2: {name: "c", age: 13}<br/>3: {name: "d", age: 13}<br/>4: {name: "e", age: 13}<br/>5: {name: "f", age: 13}<br/>6: {name: "g", age: 13}<br/>7: {name: "h", age: 13}<br/>8: {name: "i", age: 12}<br/>9: {name: "j", age: 12}<br/>10: {name: "k", age: 12}</span></pre><p id="6ad2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数组是按年龄排序的，但是在每个年龄<strong class="kt ir">内，它们仍然按名称</strong>的字母顺序排序。</p><p id="b0b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以前，JavaScript规范不要求Array.sort的排序稳定性，而是将其留给实现。正因为如此，您也可以得到这样的结果，其中“b”出现在“a”之前:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="bda0" class="ls lt iq lo b gy lu lv l lw lx"><strong class="lo ir">0: {name: "b", age: 14}<br/>1: {name: "a", age: 14}</strong><br/>2: {name: "c", age: 13}<br/>3: {name: "d", age: 13}<br/>4: {name: "e", age: 13}<br/>5: {name: "f", age: 13}<br/>6: {name: "g", age: 13}<br/>7: {name: "h", age: 13}<br/>8: {name: "i", age: 12}<br/>9: {name: "j", age: 12}<br/>10: {name: "k", age: 12}</span></pre><h1 id="a0c5" class="ly lt iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">符号.描述</h1><p id="b74e" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi translated">符号是唯一标识符的内置数据类型。现在添加了一个新的属性Symbol.prototype.description，以便从Symbol中获取描述。</p><p id="9657" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以前</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="274d" class="ls lt iq lo b gy lu lv l lw lx">const symbol1 = Symbol('my symbol');<br/>console.log(symbol1.toString());//Symbol(my symbol)</span></pre><p id="17e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="0c6b" class="ls lt iq lo b gy lu lv l lw lx">const symbol1 = Symbol('my symbol'); <br/>console.log(symbol1) <br/>console.log(String(symbol1) === `Symbol(${'my symbol'})`);<br/>console.log(symbol1.description);</span><span id="ef8e" class="ls lt iq lo b gy mu lv l lw lx">//Symbol(my symbol)<br/>//true<br/>//my symbol</span></pre><p id="ee44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更多在<a class="ae mv" href="https://medium.com/@kesk/new-javascript-features-in-es2020-c2d76acf9c5a" rel="noopener"><strong class="kt ir">JavaScript 2020中的新特性</strong> </a></p><h2 id="1904" class="ls lt iq bd lz mx my dn md mz na dp mh la nb nc mj le nd ne ml li nf ng mn nh bi translated">非常感谢你阅读我！保重！</h2></div></div>    
</body>
</html>