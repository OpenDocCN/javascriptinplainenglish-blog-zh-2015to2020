<html>
<head>
<title>Best Features of ES2018 — Object Spread vs Object.assign</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2018的最佳功能—对象扩散与对象分配</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-features-of-es2018-object-spread-vs-object-assign-14e1ce68f327?source=collection_archive---------3-----------------------#2020-09-29">https://javascript.plainenglish.io/best-features-of-es2018-object-spread-vs-object-assign-14e1ce68f327?source=collection_archive---------3-----------------------#2020-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/93f5ea57da0cf98d5601694819aad53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oaEQB--E2Sr2XvI_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bedeviere?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bimata Prathama</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="230e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2018的最佳特性。</p><h1 id="49ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">克隆具有属性的对象原型</h1><p id="6a66" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用属性克隆对象的原型。</p><p id="0de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以将<code class="fe me mf mg mh b">__proto__</code>属性设置为原始对象的原型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ae92" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="9332" class="mq lc iq mh b gy mv ms l mt mu">const clone = {<br/>  __proto__: Object.getPrototypeOf(obj),<br/>  ...obj<br/>};</span></pre><p id="ae53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设置了原型，并扩展了其他属性以获得更全面的克隆。</p><p id="f466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2b7c" class="mq lc iq mh b gy mr ms l mt mu">const clone = Object.assign(<br/>  Object.create(Object.getPrototypeOf(obj)), obj);</span></pre><h1 id="6fc3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">合并两个对象</h1><p id="69b9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象扩展操作符对于将多个对象合并成一个对象也很方便。</p><p id="6981" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7ad5" class="mq lc iq mh b gy mr ms l mt mu">const merged = {<br/>  ...obj1,<br/>  ...obj2<br/>};</span></pre><p id="0370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3699" class="mq lc iq mh b gy mr ms l mt mu">const merged = Object.assign({}, obj1, obj2);</span></pre><p id="cf8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">合并对象有助于将选项与默认选项合并:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d750" class="mq lc iq mh b gy mr ms l mt mu">const data = {<br/>  ...DEFAULTS,<br/>  ...options<br/>};</span></pre><h1 id="81a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">散布物体与<code class="fe me mf mg mh b">Object.assign()</code></h1><p id="a846" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">传播算子和<code class="fe me mf mg mh b">Object.assign</code>非常相似。</p><p id="a329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同之处在于spread定义新属性，而<code class="fe me mf mg mh b">Object.assign</code>设置它们。</p><p id="0ec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7454" class="mq lc iq mh b gy mr ms l mt mu">Object.assign(target, obj1, obj2);</span></pre><p id="58de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用<code class="fe me mf mg mh b">obj1</code>和<code class="fe me mf mg mh b">obj2</code>的属性就地修改<code class="fe me mf mg mh b">target</code>。</p><p id="ca97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想用所有3个对象的属性创建一个新的合并对象，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac5b" class="mq lc iq mh b gy mr ms l mt mu">const merged = Object.assign({}, target, obj1, obj2);</span></pre><p id="0470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它从<code class="fe me mf mg mh b">target</code>、<code class="fe me mf mg mh b">obj1</code>和<code class="fe me mf mg mh b">obj2</code>返回一个新的对象。</p><p id="cead" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">扩展运算符与第二种使用<code class="fe me mf mg mh b">Object.assign</code>的方式相同。</p><p id="ddba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Spread和<code class="fe me mf mg mh b">Object.assign</code>都通过<code class="fe me mf mg mh b">get</code>操作读取数值。</p><p id="38eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8c73" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  get a() {<br/>    return 1<br/>  }<br/>}</span><span id="6245" class="mq lc iq mh b gy mv ms l mt mu">const clone = Object.assign({}, obj);</span></pre><p id="344c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">clone</code>中克隆<code class="fe me mf mg mh b">a</code> getter。</p><p id="5227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="70f8" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  get a() {<br/>    return 1<br/>  }<br/>}</span><span id="c361" class="mq lc iq mh b gy mv ms l mt mu">const clone = {<br/>  ...obj<br/>};</span></pre><p id="070f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到同样的结果。</p><p id="3bb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">扩展操作符在目标对象中定义新的属性。</p><p id="788c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe me mf mg mh b">Object.assign</code>使用普通的设置操作来创建它们。</p><p id="3321" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们向<code class="fe me mf mg mh b">Object.prototype</code>添加一个setter，创建对象，并在其上运行<code class="fe me mf mg mh b">Object.assign</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6330" class="mq lc iq mh b gy mr ms l mt mu">Object.defineProperty(Object.prototype, 'foo', {<br/>  set(value) {<br/>    console.log('set', value);<br/>  },<br/>});</span><span id="f9f6" class="mq lc iq mh b gy mv ms l mt mu">const obj = {<br/>  foo: 1<br/>};</span><span id="66e2" class="mq lc iq mh b gy mv ms l mt mu">const clone = <!-- -->Object.assign({}, obj);</span></pre><p id="ecb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以从控制台日志中看到setter正在运行。</p><p id="3413" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6695" class="mq lc iq mh b gy mr ms l mt mu">Object.defineProperty(Object.prototype, 'foo', {<br/>  set(value) {<br/>    console.log('set', value);<br/>  },<br/>});<br/>const obj = {<br/>  foo: 1<br/>};</span><span id="d63f" class="mq lc iq mh b gy mv ms l mt mu">const clone = {<br/>  ...obj<br/>}</span></pre><p id="fb0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么setter没有运行。</p><p id="0127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">Object.assign</code>，我们可以通过继承的只读属性来阻止它创建非继承的属性。</p><p id="2e75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="707f" class="mq lc iq mh b gy mr ms l mt mu">Object.defineProperty(Object.prototype, 'foo', {<br/>    writable: false,<br/>    value: 1,<br/>});</span><span id="3e90" class="mq lc iq mh b gy mv ms l mt mu">const obj = {<br/>  foo: 1<br/>};</span><span id="320a" class="mq lc iq mh b gy mv ms l mt mu">const clone = Object.assign({}, obj);</span></pre><p id="9f23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到“未捕获的类型错误:无法分配给对象“# <object>”的只读属性“foo”。</object></p><p id="bcab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4a96" class="mq lc iq mh b gy mr ms l mt mu">Object.defineProperty(Object.prototype, 'foo', {<br/>  writable: false,<br/>  value: 1,<br/>});</span><span id="1ea7" class="mq lc iq mh b gy mv ms l mt mu">const obj = {<br/>  foo: 1<br/>};<br/>const clone = {<br/>  ...obj<br/>};</span></pre><p id="22ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们没有得到任何错误，所以资产评级成功。</p><p id="3390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为spread运算符定义属性，而不是设置属性。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1c786e15e66982bc9dc56c3d6c2023a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zhQYHmg7Tg3RdDGk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joe Green</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f98a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4241" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.assign</code>做着相似的事情，却有着我们无法忽视的小差异。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>