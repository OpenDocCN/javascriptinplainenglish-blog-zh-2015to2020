<html>
<head>
<title>A Practical Intro to the Vue 3 Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue 3组合API的实用介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-practical-intro-to-the-vue-3-composition-api-628b6ff15b2f?source=collection_archive---------6-----------------------#2020-12-29">https://javascript.plainenglish.io/a-practical-intro-to-the-vue-3-composition-api-628b6ff15b2f?source=collection_archive---------6-----------------------#2020-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/e073e3a3927e81b51c058e568030dfc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z8gy4NQ4XL_D9bE-ervH4Q.png"/></div></div></figure><div class=""/><p id="d9bd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Composition API是在Vue.js中的组件之间共享应用程序逻辑的一种很好的方式。您不仅可以将重复的代码片段组织到单独的文件中，还可以使它们易于重用。</p><p id="a73d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Composition API允许您在共享的代码片段中保持变量的活性，这与以前版本的Vue中构建的实现相比是一个巨大的改进，即使对于企业规模的应用程序也是如此。根据官方文档，部署复合API是必要的，因为在大型应用程序中，组件之间的高效代码共享是一个问题。</p><p id="879e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管过去有突出公共部分的解决方案，如mixin、renderless compontent或HOC，但这些都不能提供与组合API一样高的灵活性。这个新特性的最大优点是，我们可以同时提取以前必须在给定组件的数据、计算和方法部分中实现的部分(使用选项API)。让我们举一个简单的例子来说明如何在现实世界中使用复合API。</p><p id="6721" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，使用Vue.js(版本3)创建一个项目。为了提高速度，我将使用vue cli来实现这一目的。一旦项目完成，删除示例组件，我们将不再需要它。阐明我们将组织代码的项目结构。我将我的组件放在<em class="kt"> src </em>下的<em class="kt">组件</em>文件夹中，同时我创建了一个<em class="kt">服务</em>文件夹，在其中我打包了实现业务逻辑的可重用但“非组件”的代码。一个文件包含一个服务。如果我必须给出一个常见服务的例子，例如，有实现各种排序和过滤或http调用的服务。</p><p id="2c82" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通常不希望把它们写成组件，它们只能被适当地参数化，但是我们希望在总体上看到给定的逻辑，作为代码中的一个模块。作为实现解决方案的组合API完全符合这一思想。</p><p id="7794" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组合API为组件代码引入了一个新的部分，称为<em class="kt"> setup </em>。这是一个可以有两个参数的函数，上下文和道具。在设置中，我们可以使用之前已知的选项API实现我们在数据、计算和方法部分中编写的部分。这里我们可以定义组件的内部状态和功能，这里我们也可以使用我称为服务的公共代码片段。</p><p id="7754" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的许多项目中，我需要可以按列升序或降序排序的表格。我们将创建两个使用相同director服务的表。这是一个很好的真实例子，说明了为什么组合API作为一种思想是有效的。</p><p id="1688" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，在一个企业规模的项目中，我们必须将所有的表格逻辑外包给一个通用的表格组件，然后该组件使用排序服务，但是我们现在不会这样做，因为本文旨在介绍组合API，它足以从表格中提取服务代码。</p><p id="c60a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的应用程序的聚合组件叫做HomePage，它只显示这两个表。这两个表也很简单，一个列出了<strong class="jx iz">用户</strong>，另一个列出了<strong class="jx iz">产品</strong>。Composition API允许我将排序操作创建为一个单独的服务，如果需要，我可以在其中处理反应值，然后我可以在使用该服务的组件中使用这些值。</p><p id="9486" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我将把排序方向存储在我的服务自己的反应变量中。我在我的两个表组件中的数据下面的按钮文本中打印这个订单值。我将在必要时以清晰可见的方式仅在分类服务中更改分类顺序，组件将立即被通知这一更改，证明存在反应性。</p><h1 id="e1d5" class="ku kv iy bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">最终结果</h1><figure class="lt lu lv lw gt ip gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/584a08b87ff50b4c99d6a37e172b7697.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*MLNo-apiGLuR8sbd6cw9dQ.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">Result: 2 different tables use the same service to sort data</figcaption></figure><p id="b40b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">主页</strong>组件包含这两个表格(以及几行css代码以在后台突出显示表格):</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="ac48" class="ku kv iy bd kw kx mk kz la lb ml ld le lf mm lh li lj mn ll lm ln mo lp lq lr bi translated">ProductTable和UserTable组件</h1><p id="1159" class="pw-post-body-paragraph jv jw iy jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated"><strong class="jx iz"> ProductTable </strong>组件显示了一个包含3列的简单表格和一个用于排序的按钮。为了简单起见，它从25 的<strong class="jx iz">行定义数据行。</strong></p><p id="146c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">第33行:</strong>使用订单服务获取其返回值，即orderState和orderItems。OrderState是订单服务的内部状态，包含方向值(“asc”或“desc”)，OrderItems是排序函数本身。正如你所看到的，整个排序逻辑是从组件使用中分离出来的。想象一下，如果在一个组件中包含10个或更多服务，这个解决方案会多么有用。</p><p id="01c1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">第35行:</strong>在组件“加载时”对服务进行排序(参见vue 3生命周期方法)。</p><p id="50c5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">第37行:</strong>返回一个包含状态(component own - reactive -state)、orderItems(排序函数)和orderState(order service own state带方向值)的对象。<strong class="jx iz">这是一个重要的时刻，因为组合API需要这种返回才能正常工作。</strong>在你带着那些东西返回后，组件的模板可以使用orderItems和orderState.direction，正如你在14 的<strong class="jx iz">行看到的。</strong></p><p id="4cd1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第8行:状态可以直接在模板中使用。</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="e40e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">用户表</strong>组件与之前分析的产品表几乎相同。唯一不同的是25 的<strong class="jx iz">线上的数据行。该组件可以像ProductTable组件一样受益于排序服务。</strong></p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="e50e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">排序服务没什么特别的，只是一个超级简单的排序功能。它可以根据内容的name属性对给定的数据数组进行排序。我不验证输入值，因为从组合API示例的角度来看，这无关紧要。重要的部分是服务(或函数或任何您称之为它的东西)内部的反应状态以及特性结束时的返回值。</p><p id="7d6b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">记住:你必须从服务中返回所有的东西(函数、变量等),以使它在组件级可用。</strong></p><p id="4c3e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Composition API中很酷的一点是，一个特性的整个逻辑连接可以提取到一个单独的部分，因为如果你愿意，你可以在一个代码块中“模拟”Vue.js的数据、方法和计算特性。有了这个想法，我可以以同样的方式在任何组件中使用我的分离排序特性。</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><h1 id="bc53" class="ku kv iy bd kw kx mk kz la lb ml ld le lf mm lh li lj mn ll lm ln mo lp lq lr bi translated">结论</h1><p id="3e18" class="pw-post-body-paragraph jv jw iy jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">我知道，我知道，这是个超级简单的例子。本文的唯一目的是将您的注意力吸引到组合API的最大好处上。如果你和我一样，用Vue.js做企业软件，下次试着替换常用的Options API，你不会失望的。你对这个话题有什么看法？请在评论中分享你的想法和经验。万事如意！</p></div></div>    
</body>
</html>