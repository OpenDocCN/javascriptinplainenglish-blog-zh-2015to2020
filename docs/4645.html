<html>
<head>
<title>How Lazy Loading Impacts Angular App Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">惰性加载如何影响Angular应用性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-lazy-loading-impacts-angular-app-performance-9c1ee0cb11ea?source=collection_archive---------1-----------------------#2020-12-28">https://javascript.plainenglish.io/how-lazy-loading-impacts-angular-app-performance-9c1ee0cb11ea?source=collection_archive---------1-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/46d7892f145d0861849b782bbab09f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQe4r0YQO571SRNHx940Dw.png"/></div></div></figure><h1 id="28c7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">角形部件有什么问题？</strong></h1><p id="640b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir">组件</strong>在角度应用中充当<strong class="ky ir">页面</strong>。一般来说，我们在创建<strong class="ky ir">角度</strong>应用时会做什么？。我们将根据项目需求创建许多组件。比方说，如果您正在创建一个Angular应用程序，它需要十个页面(只有十个页面)。然后，我们将创建十个组件，并将应用程序部署到云服务器。假设整个dist <strong class="ky ir">文件夹的大小</strong>大约为<strong class="ky ir">2–3mb</strong>。当您加载特定的应用程序时，浏览器将在第一个请求中<strong class="ky ir">加载所有的</strong>十个组件。加载的组件将缓存在浏览器内存中。而且上页速度非常快。它给了用户更好的用户体验。这是棱角分明的特征。是的，Angular将在<strong class="ky ir">单个请求</strong>中加载所有组件。这就是为什么与以前的技术相比，它呈现页面的速度非常快。每次只从服务器中提取数据。</p><p id="db00" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您的应用程序非常小，那么在一个请求中加载所有组件就太好了。为什么？因为它减少了渲染时间和带宽，不像旧技术。但是如果你有更多的组件。比方说，如果你有100个或100个以上的组件。Angular将再次尝试在一个请求中加载所有的<strong class="ky ir"> 100+ </strong>组件。并且加载所有组件将花费更多的时间。如果应用程序需要更多的时间来加载，用户会感到沮丧，并会离开应用程序。如果一个应用程序花费太多的时间来加载，我们将失去使用基础。</p><h1 id="2fa9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">什么是懒装？</strong></h1><p id="dd77" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们如何避免这个问题？。简单来说，只加载需要的组件，而不是加载所有的组件。这个概念将减少加载时间。</p><p id="66dd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">只加载需要的组件，并在需要时加载其他组件，而不是在一个请求中加载所有组件。没错，这就是所谓的懒加载。</strong></p><p id="ee63" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">将组件放在模块</strong>下可以实现惰性加载。您可以拆分组件，并将其放在不同的模块下。默认情况下加载根页面。模块只有在被请求时才会被加载。比方说，如果您有10个模块，那么在第一个请求中只加载根页面。其余模块只有在被请求时才会被加载。它减少了装载时间。</p><h1 id="a9bd" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">什么时候用懒人加载？</strong></h1><p id="c8ce" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当你设计一个大角度的应用程序时，必须实现延迟加载。一个大的应用程序意味着它在dist文件夹中产生更多的MB或者有更多的组件。在我看来，如果你的应用程序超过2 MB以上，那么你可以使用惰性加载的概念。为什么因为，如果拿今天的网速来说，加载2MB是非常容易的。但是，您必须考虑应用程序将用于哪个领域。如果您的用户的互联网连接速度很慢，那么您必须相应地优化大小和实现延迟加载。</p><p id="a4a3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">初学者必须意识到这个概念。我将分享我的故事。当我刚接触Angular时，我不知道惰性加载的概念。完成了几个项目，但没有实现/不知道惰性加载(大约25页的应用程序)。我没有感觉到应用程序变慢，用户也没有报告任何关于应用程序加载时间的问题。为什么？因为我们有很好的网络连接。</p><p id="3b0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">过了一段时间，我进入了一个大的应用(ERP)。我们完成了所有的基本工作，如设计数据库和创建一个用户界面原型。最初，我们创建了100个组件。那么它就超过了200多个组件。仅创建UI级别的组件。当时，我面临一个大问题。由于内存问题(更多组件)，未生成dist。我遇到了一个堆内存错误。然后我们增加了内存，生成了dist，没有实现延迟加载。</p><p id="c403" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后我们开始开发应用程序。即使在本地开发环境中，当我们在应用程序中进行简单的更改时，也需要更多的加载时间。当时只有我意识到我们做错了。我决定解决这个问题。然后谷歌了一下，发现了懒加载的概念。</p><p id="7af4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这对我们来说是双重工作。将所有的组件转移到一个单独的模块会耗费大量的时间，因为我们已经开始开发了。这是一个大错误。所以在做角度应用的时候，你必须意识到惰性加载。</p><p id="2fd0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">如何实现懒加载？</strong></p><ol class=""><li id="4673" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">首先，创建一个模块。</li><li id="1cd1" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">在模块下创建组件。</li><li id="cb08" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">为模块下的组件创建工艺路线。</li><li id="b22c" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">将新创建的路由包括到主路由(app.routing.ts)</li></ol><p id="e0d5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">以上四个步骤将帮助您在Angular应用程序中实现延迟加载。</p><p id="5d59" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">假设我们要创建一个计费应用程序。计费应用程序有四个组件。</p><ol class=""><li id="c1f4" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">类别列表</li><li id="da6e" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">产品列表</li><li id="b6bf" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">新法案</li><li id="3b56" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">账单列表</li></ol><p id="3116" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我要把以上四个组件放到两个模块里。</p><ol class=""><li id="df99" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">主数据模块(类别列表、产品列表)</li><li id="d89d" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">账单数据模块(新账单、账单列表)</li></ol><p id="6845" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">项目结构</strong></p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/fa9df043c7458e67ca4c369056039cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*0onTuwj4okGReP1Bms-l6w.png"/></div></figure><p id="ca50" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> 1。创建新模块</strong></p><p id="a66d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用下面的命令创建一个新模块。在这里，我们将创建两个模块。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0642" class="mx jz iq mt b gy my mz l na nb">ng g module master-data<br/>ng g module bill-data</span></pre><p id="179d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> 2。在模块</strong>下创建组件</p><p id="476c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要创建一个组件，我们可以使用相同的命令。但是在命令名之前添加模块名。</p><p id="311a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为主数据模块创建组件。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2ffa" class="mx jz iq mt b gy my mz l na nb">ng g c master-data/category-list<br/>ng g c master-data/product-list</span></pre><p id="23fc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为账单数据模块创建组件。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="98fd" class="mx jz iq mt b gy my mz l na nb">ng g c bill-data/bill-list<br/>ng g c bill-data/new-bill</span></pre><p id="d81d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> 3。为组件创建路由</strong></p><p id="3c92" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要创建路由，我们需要在模块文件夹下创建一个<strong class="ky ir"> routing.ts </strong>文件。</p><p id="bac0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于主数据模块，在主数据文件夹下创建一个名为<strong class="ky ir">master-data . routing . ts</strong>file的新文件。并粘贴下面的代码。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0ec3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在包括到<strong class="ky ir"> master-data.module.ts </strong>文件的路径。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c7b8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对账单数据模块也重复相同的步骤。</p><p id="dc77" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> 4。将模块包括到主路由</strong></p><p id="25c3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在导入并在<strong class="ky ir"> app.routing.ts </strong>文件中包含新创建的模块路由。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bf6d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我创建了一个home组件，并将其作为默认的根页面。当加载应用程序时，它只加载home组件。如果我们导航到产品列表，那么只有账单数据模块将被加载。如果您没有导航到产品或类别页面，则主数据模块无法加载。只会加载所需的页面模块。</p><p id="507f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用<strong class="ky ir">home.component.html</strong>文件中的以下代码导航到不同的路线。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9fc1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">样本输出</strong></p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/d1a5a254a19b30b6a59ef745b71b7dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyohUjfPVdYaWLGzbz3BSA.png"/></div></div></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/868e9da4ad9c133b63d8c5ad1f20dad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UM7POD26_cQPbj_J_P66Uw.png"/></div></div></figure><p id="809e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我在演示中使用了引导CSS框架。</p><p id="cec1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">仅此而已。希望你喜欢这个教程。</p><p id="b594" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">获取完整源代码</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6d33" class="mx jz iq mt b gy my mz l na nb"><a class="ae ng" href="https://github.com/bharathirajatut/angular-examples/tree/master/lazy-loading-example/src" rel="noopener ugc nofollow" target="_blank">https://github.com/bharathirajatut/angular-examples/tree/master/lazy-loading-example/src</a></span></pre></div></div>    
</body>
</html>