<html>
<head>
<title>TypeScript 4.0 finally delivers what I’ve been waiting for</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.0最终交付了我一直在等待的东西</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-4-0-i-want-a-list-of-generic-params-with-good-labels-c6087d2df935?source=collection_archive---------0-----------------------#2020-08-07">https://javascript.plainenglish.io/typescript-4-0-i-want-a-list-of-generic-params-with-good-labels-c6087d2df935?source=collection_archive---------0-----------------------#2020-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5129" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">标签良好的通用参数列表！</h2></div><p id="e4d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">昨天，微软公布了TypeScript 4.0 的<a class="ae lb" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-rc" rel="noopener ugc nofollow" target="_blank">发布候选。随之而来的是</a><a class="ae lb" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-rc/#labeled-tuple-elements" rel="noopener ugc nofollow" target="_blank">标记的元组元素</a>，这就是这篇文章标题的答案。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/2301923928df03516303f64a569b3168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G00zmJivkNGN1L6fDo9vnQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Arguments with useful labels and arguments with useless labels</figcaption></figure><h1 id="9be3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">具有未知参数的通用接口</h1><p id="6953" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这里有一个人为的例子。<code class="fe mp mq mr ms b">IQuery</code>。它的意思是描述查询事物的函数的形状。它总是返回一个承诺，并使用一个<a class="ae lb" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>来描述承诺发出的内容(<code class="fe mp mq mr ms b">TReturn</code>)。该接口也足够灵活，可以不带任何参数<em class="mt">或未知数量的参数</em>(<code class="fe mp mq mr ms b">UParams extends any[] = []</code>)。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="ad38" class="my lt iq ms b gy mz na l nb nc">interface IQuery&lt;TReturn, UParams extends any[] = []&gt; {<br/>  (...args: UParams): Promise&lt;TReturn&gt;<br/>}</span></pre><h2 id="f5fa" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">示例函数:findSongAlbum()</h2><p id="1b1b" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">利用这个接口，我们将编写一个函数，通过标题和艺术家来查找歌曲专辑。它返回一个发出单个类型为<code class="fe mp mq mr ms b">Album</code>的对象的承诺。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="d85b" class="my lt iq ms b gy mz na l nb nc">type Album = {<br/>  title: string<br/>}</span></pre><p id="9696" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有TypeScript，该函数可能如下所示:</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="68dd" class="my lt iq ms b gy mz na l nb nc">const findSongAlbum = (title, artist) =&gt; {<br/>  // data fetching code...<br/>  <br/>  const albumName = '1989';</span><span id="5cdb" class="my lt iq ms b gy no na l nb nc">  return Promise.resolve({<br/>     title: albumName<br/>  });<br/>}</span></pre><p id="ccd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用TypeScript，并利用<code class="fe mp mq mr ms b">IQuery</code>接口，您可以将<code class="fe mp mq mr ms b">Album</code>类型作为第一个泛型参数传入，以确保promise发出的形状总是与<code class="fe mp mq mr ms b">Album</code>类型相匹配。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="ed32" class="my lt iq ms b gy mz na l nb nc">const findSongAlbum: IQuery&lt;Album&gt; = (title, artist) =&gt; {<br/>  // data fetching code...<br/>  <br/>  const albumName = '1989';</span><span id="982e" class="my lt iq ms b gy no na l nb nc">  return Promise.resolve({<br/>     title: albumName <br/>  });<br/>}</span></pre><h2 id="2dc5" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">在TypeScript 4.0之前</h2><p id="1a9e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">您还需要定义参数以及它们的类型。在这种情况下，<code class="fe mp mq mr ms b">title</code>和<code class="fe mp mq mr ms b">artist</code>都是字符串。您定义了一个新类型<code class="fe mp mq mr ms b">Params</code>，并将其作为第二个类型传递给<code class="fe mp mq mr ms b">IQuery</code>。</p><p id="ce81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，<strong class="kh ir">在TypeScript 4.0 </strong>之前，<code class="fe mp mq mr ms b">Params</code>将被定义为一个类型列表。列表中的每一项都按照与参数列表相同的顺序定义类型。这种类型被称为<a class="ae lb" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">元组</a>类型。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="0fe9" class="my lt iq ms b gy mz na l nb nc">type Params = [string, string]</span><span id="8db8" class="my lt iq ms b gy no na l nb nc">const findSongAlbum: IQuery&lt;Album, Params&gt; = (title, artist) =&gt; {<br/>  // data fetching code...<br/>  <br/>  const albumName = '1989';</span><span id="3998" class="my lt iq ms b gy no na l nb nc">  return Promise.resolve({<br/>     title: albumName<br/>  });<br/>}</span></pre><p id="d713" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在上面的<code class="fe mp mq mr ms b">Params</code>类型中看到，第一个条目类型是<code class="fe mp mq mr ms b">string</code>，使得第一个参数“title”成为了一个<code class="fe mp mq mr ms b">string</code>。第二个，当然，遵循同样的模式，是<code class="fe mp mq mr ms b">string</code>使第二个参数“artist”也是一个<code class="fe mp mq mr ms b">string</code>。这将为参数列表提供适当的类型安全。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi np"><img src="../Images/36429846d48cd0bed4f513798cfd8809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZZTq2-il42ITd06l-GZjyg.gif"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">findSongAlbum() showing useless argument labels</figcaption></figure><p id="d9dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，以这种方式使用元组类型并不能在使用函数时给出有用的类型安全标签<em class="mt">。相反，它只是将参数列为<code class="fe mp mq mr ms b">args_0: string, args_1: string</code>。除了知道第一个参数是一个<code class="fe mp mq mr ms b">string</code>之外，“arg_0”并没有告诉我第一个参数应该是我正在搜索的歌曲的“标题”。</em></p><h2 id="f879" class="my lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">在TypeScript 4.0之后</h2><p id="ef05" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">使用TypeScript 4候选版本，我们可以获得<strong class="kh ir">标记的元组元素</strong>，我们可以使用它们来获得参数列表中的有用标签。</p><p id="91b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mp mq mr ms b">Params</code>类型中的每一项现在都有一个标签，当你使用<code class="fe mp mq mr ms b">findSongAlbum</code>函数时，它会很好地显示在你的IDE中。</p><pre class="ld le lf lg gt mu ms mv mw aw mx bi"><span id="e52e" class="my lt iq ms b gy mz na l nb nc">type Params = [title: string, artist: string]</span><span id="3f4e" class="my lt iq ms b gy no na l nb nc">const findSongAlbum: IQuery&lt;Album, Params&gt; = (title, artist) =&gt; {<br/>  // data fetching code...<br/>  <br/>  const albumName = '1989';</span><span id="703f" class="my lt iq ms b gy no na l nb nc">  return Promise.resolve({<br/>     title: albumName<br/>  });<br/>}</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi np"><img src="../Images/edc4a310f3ecccb88fe7b899c345e3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8DQ2mM364SRO6OV2nPHLnQ.gif"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">findSongAlbum() showing valuable argument labels</figcaption></figure><p id="16ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，代替<code class="fe mp mq mr ms b">arg_0: string</code>，我们在智能感知中得到<code class="fe mp mq mr ms b">title: string</code>，它告诉我们<strong class="kh ir"> <em class="mt">需要传入什么</em> </strong>字符串。</p><p id="fcb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢你阅读❤</p></div></div>    
</body>
</html>