<html>
<head>
<title>The Bridge Pattern — Design Patterns meet the Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">桥接模式——设计模式与前端相遇</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-bridge-pattern-design-patterns-meet-the-frontend-c2f09a009ab?source=collection_archive---------1-----------------------#2019-12-04">https://javascript.plainenglish.io/the-bridge-pattern-design-patterns-meet-the-frontend-c2f09a009ab?source=collection_archive---------1-----------------------#2019-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a6f570be7add1e2b49b39eca68245ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vgn2g61EtoiqyZEShQJFxA.jpeg"/></div></div></figure><p id="4076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">桥梁设计模式是我最难以理解的设计模式之一。🤯<em class="kw">注意:本文假设了一些面向对象编程中接口的基础知识</em></p><p id="6d4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将解释这种模式是什么，如何使用它，并举例说明它目前在前端空间中的使用情况(psst Angular🚀).</p><p id="fad8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将讨论几件事情:</p><ul class=""><li id="639d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">这是什么？🤔</li><li id="5391" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我们来分解一下😱</li><li id="9ccf" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">但是为什么呢？😐</li><li id="31d0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在哪里可以找到它的作用？🚀</li><li id="cce1" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">我还能在哪里使用它？🎉</li></ul><h1 id="732e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">这是什么？🤔</h1><p id="191b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">桥接模式可以被认为是继承复合论点的一部分。它本质上在抽象和实现之间“架起了一座桥梁”。这些术语可能会引起一些混乱，所以让我们来澄清一下。</p><ul class=""><li id="4854" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">实现——这是一个描述一组特定行为的接口，可以被我们代码库中的任何对象使用。它可以有多个符合接口中定义的契约的具体实现。</li><li id="aec3" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">抽象——这个对象将提供一个利用底层实现的API。它充当实现之上的一层，如果需要，可以通过继承进一步细化。</li></ul><p id="7e18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，我很惊讶。🤯我知道，读起来可能有点吓人。</p><p id="94bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们快速看一下UML图(我知道，唉，但是它确实有帮助):</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/54cd7396980253eec6317518b20b24dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*e6qd7OKKjp51TLV3.png"/></div></figure><p id="11d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们从图中看到的，模式允许我们分离两个接口，这两个接口可以定义一个对象的细节，在这种情况下是对象的形状类型和形状的颜色。</p><p id="5d29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以创建多种颜色，或者多种形状，而不用担心一种会影响另一种，因此增加了代码库中的松散耦合！🔥</p><h1 id="bd96" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们来分解一下😱</h1><p id="f1ea" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">记住上面的例子，抽象是我们的形状类，而我们的实现是颜色类。</p><p id="9df8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抽象包含了通过类的属性对实现的引用(因此是继承之上的组合)，在我们的例子中，Shape有一个颜色属性。任何实现颜色协定的类都可以由任何形状属性使用。</p><p id="4e02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抽象的消费者不需要担心底层的实现，而模式本身也增加了抽象和实现之间的松散耦合。</p><p id="ca82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你像我一样，看代码可以帮助你理清思路。让我们就这么做吧！</p><p id="9a8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这些例子，我们将使用TypeScript</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a45c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">厉害！我们可以创建任意多的<code class="fe mv mw mx my b">Colors</code>，或者任意多的<code class="fe mv mw mx my b">Shapes</code>，而不会影响任何一个。🚀🚀🚀</p><p id="fbe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保持事物的简单和分离增加了我们代码的可维护性和可测试性，从而产生更好的代码！我们现在也可以很容易地扩展新的形状和颜色！</p><h1 id="0e76" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">但是为什么呢？😐</h1><p id="5917" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">让我们来看看为什么我们会使用这种模式的一些原因:</p><ul class=""><li id="b916" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">桥接模式将抽象和实现解耦，因此允许两者独立地不同。</li><li id="1f37" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">它将抽象和实现保留在自己的继承层次中，允许它们在不影响对方的情况下增长。</li><li id="d18e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">抽象不需要知道具体的实现，因此它可以在运行时设置或交换，而不会破坏抽象。</li></ul><p id="3e20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了，但是我能在哪里使用它？🤔</p><h1 id="2172" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">在哪里可以找到它的作用？🚀</h1><p id="ab4b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">好吧，桥的图案太棒了。它可以增加我们的松耦合，但是，我们<em class="kw">究竟在哪里</em>使用它呢？它在野外的什么地方被使用？</p><p id="5436" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular用它！<em class="kw">(非常感谢</em> <a class="ae mz" href="https://twitter.com/wescopeland_" rel="noopener ugc nofollow" target="_blank"> <em class="kw">韦斯·科普兰</em> </a> <em class="kw">给我指出了这一点。)</em></p><p id="1ae2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们在自己的<a class="ae mz" href="https://angular.io/api/forms" rel="noopener ugc nofollow" target="_blank">表单</a> API中使用它来弥合任何<a class="ae mz" href="https://angular.io/api/forms/NgControl" rel="noopener ugc nofollow" target="_blank"> NgControl </a>和任何<a class="ae mz" href="https://angular.io/api/forms/ControlValueAccessor" rel="noopener ugc nofollow" target="_blank"> ControlValueAccessor </a>之间的差距。</p><p id="b78f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">ControlValueAccessor</code>是一个具有方法的接口，任何实现它的类都必须实现这些方法。Angular提供了自己的<code class="fe mv mw mx my b">ControlValueAccessor</code>实现的具体实现，但是任何开发者都可以实现这个接口，任何<code class="fe mv mw mx my b">NgControl</code>都可以使用它！</p><p id="6bec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，框架内的抽象完全可以接受Angular框架外的实现！🔥🔥</p><p id="1a62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，开发人员可以创建自己的<code class="fe mv mw mx my b">NgControl</code>，Angular提供的任何具体实现都可以使用它！💥💥</p><p id="b180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这可以帮助您理解桥模式背后的力量，但是如果您仍然需要自己的用例，请继续阅读！</p><h1 id="581d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我还能在哪里使用它？🚀</h1><p id="9ce5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">嗯，我发现在前端世界中，一个完美的例子是数据访问层。</p><p id="4b5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以拥有以下内容:</p><ul class=""><li id="fc92" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">定义实体服务的抽象，实体服务将处理与系统中的实体相关的逻辑。</li><li id="a4b4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">一个定义API接口的实现，允许你与任何潜在的后端系统或API进行交互。</li></ul><p id="eef0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速看一下这一过程:</p><p id="3ce8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将从我们的实现(API接口)开始:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1061" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们将定义我们的抽象(实体服务):</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7556" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们已经建立了我们的抽象和实现。让我们把它们派上用场吧！</p><p id="715d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我们创建一个用户服务来提炼我们的抽象。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3538" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个精炼的抽象，让我们继续创建一个具体的实现</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cd1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在让我们使用我们的具体实现和我们的精炼抽象:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2099" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">厉害！我们的<code class="fe mv mw mx my b">UserService</code>不需要知道<code class="fe mv mw mx my b">IApiService</code>实现的细节，它仍然可以按预期执行。</p><p id="e168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果以后需求改变，突然我们不能再使用<code class="fe mv mw mx my b">CustomApiService</code>了，会发生什么？😱</p><p id="a310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不用怕，桥型在这里！😍</p><p id="f75a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单地创建一个新的具体实现，并将其提供给<code class="fe mv mw mx my b">UserService</code>:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3d16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是不是很牛逼！🚀🚀🚀</p><p id="b447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你多学了一点(<em class="kw">？</em>)关于本文中的桥接模式，它的一个潜在用例，以及如何在Angular中使用它。</p><p id="782a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如有任何问题，欢迎在下方提问或在Twitter上联系我:<a class="ae mz" href="https://twitter.com/FerryColum" rel="noopener ugc nofollow" target="_blank"> @FerryColum </a>。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="e567" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原发布于2019年12月4日</em><a class="ae mz" href="https://dev.to/coly010/the-bridge-pattern-design-patterns-meet-the-frontend-46fc" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://dev . to</em></a><em class="kw">。</em></p></div></div>    
</body>
</html>