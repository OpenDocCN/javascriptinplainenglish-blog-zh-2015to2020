<html>
<head>
<title>Should I Upgrade to React 17?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我应该升级到React 17吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/should-i-upgrade-to-react-17-92aac7e7eb0d?source=collection_archive---------0-----------------------#2020-08-13">https://javascript.plainenglish.io/should-i-upgrade-to-react-17-92aac7e7eb0d?source=collection_archive---------0-----------------------#2020-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3aff" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">你现在可以做些什么来准备你的应用程序</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e6d47cf32498a6476202fe2af251aabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OC3wtMDL372h3j9E3G9nfg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Original Photo by <a class="ae ks" href="https://unsplash.com/@only1simonharmer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Simon Harmer</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4ab0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React最新、最闪亮的版本即将推出！React刚刚发布了版本17的候选版本，并有一个博客描述了它的新特性。你可以在这里阅读全部内容<a class="ae ks" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html" rel="noopener ugc nofollow" target="_blank">。你可能有的疑问是:<em class="lp">我该不该升级到17版本？还是坚持16版，我们都知道，都喜欢？</em></a></p><p id="d41b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">简答:</strong>对，升级！</p><p id="7527" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">长回答:</strong> React 17将是React的新标准和基础。你可以认为它类似于Windows 10新的功能将建立在它的基础上，而不需要更新你的整个系统，因为17以后的所有版本都将完全向后兼容17(但不是16)。这意味着您可以升级到17，然后根据需要将部分应用程序更新到更高的版本。但是在大多数情况下，你可以高枕无忧，不用担心在很长一段时间内破坏改变。</p><p id="b251" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">拥有大型应用程序的团队可能会犹豫是否做出更改，但是您等待的时间越长，更新就越困难。更不用说，你会错过很多即将推出的很酷的功能。</p><p id="d77c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了使过渡更容易，我建议创建一个新的React-17升级史诗，根据<a class="ae ks" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html" rel="noopener ugc nofollow" target="_blank"> React博客</a>中概述的变化在您的待办事项中创建一些故事，并告诉您的团队在接下来的几个月中解决它们。我不会在博客中重复所有内容，因为它已经写得非常好了，但我会回顾一些潜在的重大影响:</p><p id="a378" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">- <a class="ae ks" href="#461d" rel="noopener ugc nofollow">不安全的方法</a><br/>-<a class="ae ks" href="#5d97" rel="noopener ugc nofollow">on scroll</a><br/>-<a class="ae ks" href="#793a" rel="noopener ugc nofollow">forward ref和memo </a> <br/> - <a class="ae ks" href="#df8b" rel="noopener ugc nofollow">事件监听器</a> <br/> - <a class="ae ks" href="#a0cf" rel="noopener ugc nofollow">并发模式</a></p><h1 id="461d" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">不安全的方法</h1><p id="7fc2" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">对于那些使用基于类的组件的人来说:这些生命周期方法正准备被弃用:<code class="fe mn mo mp mq b"><em class="lp">componentWillRecieveProps</em></code>、<code class="fe mn mo mp mq b"><em class="lp">componentWillMount</em></code>和<code class="fe mn mo mp mq b"><em class="lp">componentWillUpdate</em></code>。您仍然可以在17中使用它们，但是您必须添加<code class="fe mn mo mp mq b"><em class="lp">UNSAFE_</em></code>前缀。</p><p id="cbcf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">创建简单的故事:</strong>确定所有使用这些方法的位置，并进行简单的全部替换，以添加<code class="fe mn mo mp mq b"><em class="lp">UNSAFE_</em></code>前缀。</p><p id="be82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">创建更好的故事:</strong>不要在你创建的任何新组件上使用这些方法；建议使用替代功能(即<code class="fe mn mo mp mq b"><em class="lp">getDerivedStateFromProps</em></code> <em class="lp"> </em>代替<code class="fe mn mo mp mq b"><em class="lp">componentWillRecieveProps</em></code>)。或者更好的是，您可以开始使用功能组件，这些组件可以复制您可能需要的所有功能。对于这两种方法，您都可以找到大量的指南来帮助您进行改进。</p><p id="e5db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是不要担心，你不必一下子改变你的整个应用程序；我建议使用新的生命周期方法，或者对您创建的任何<em class="lp"> *new* </em>组件使用Functional React，以将未来影响降至最低。然后，您可以逐步对现有组件进行更改。(别忘了:你可以在你的应用中混合使用基于类的组件和功能组件)</p><h1 id="5d97" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">OnScroll</h1><p id="3e17" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我已经知道这对我的团队来说是一个巨大的变化。目前，如果你在一个元素上定义了一个<code class="fe mn mo mp mq b"><em class="lp">onScroll</em></code> <em class="lp"> </em>回调函数，它会在子元素滚动时执行。这是无意的，会造成很多混乱，所以React 17修复了这一点。然而，在很多情况下，您可能(无意中)期望回调在向下滚动一两级元素时执行，并且可能认为该功能是理所当然的。</p><p id="d43d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">要创建的故事:</strong>识别应用程序中的所有<code class="fe mn mo mp mq b"><em class="lp">onScroll</em></code> <em class="lp"> </em>回调，并确保您实际上没有跟踪子元素的变化。</p><h1 id="793a" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">转发参考和备忘录</h1><p id="c453" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这个非常简单:如果这些函数返回undefined，React将抛出一个错误。你只需要确保在使用这些函数时，你实际上是在返回* 某个东西，而不是意外地让它们返回未定义的东西。</p><p id="c8d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">要创建的故事:</strong>确定<code class="fe mn mo mp mq b">memo</code>和<code class="fe mn mo mp mq b">forwardRef</code>的所有用法，并确保它们返回某个东西(或<code class="fe mn mo mp mq b"><em class="lp">null</em></code> <em class="lp"> </em>，如果需要的话)而不是<code class="fe mn mo mp mq b">undefined</code>。</p><h1 id="df8b" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">事件监听器</h1><p id="3e9a" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">为了完全理解这一点，我必须阅读一篇关于冒泡和捕获的解释。当JavaScript事件发生时，它从文档向下到达目标，然后返回到文档。在向上传播(冒泡)阶段，任何监视该事件的元素都将执行任何已定义的代码。</p><p id="85ae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通常在JavaScript中，如果您在一个元素上调用<code class="fe mn mo mp mq b"><em class="lp">event.stopPropagation()</em></code>，它会停止将该事件向上传播到上面的任何元素，这些元素可能正在等待执行基于该事件的动作。如果在普通元素(如按钮或div)上调用，您可能希望事件在到达文档级之前停止。但是在React 16中，所有事件处理程序都附加到文档级。因为事件从那里开始，<code class="fe mn mo mp mq b"><em class="lp">stopPropagation</em></code>只停止向上传播到文档之上的任何地方，这不是您所期望的。</p><p id="5d79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在React 17中，事件处理程序将被附加到根元素(你附加你的应用程序的最顶层的根div)，所以<code class="fe mn mo mp mq b"><em class="lp">stopPropagation</em></code> <em class="lp"> </em>将在到达文档级之前正确地停止事件。<em class="lp">(补充说明:这实际上会让您在同一个应用程序中运行多个版本的React，因为事件并不都在文档级别绑定，太酷了！)</em></p><p id="29a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使这与16的工作方式相同，您需要告诉您的定制事件侦听器使用捕获阶段，这意味着它们在事件的初始向下传播时执行回调(它将总是在文档级执行，因为它从那里开始)。这是通过在自定义<code class="fe mn mo mp mq b"><em class="lp">addEventListener</em></code> <em class="lp"> </em>函数中添加第三个参数<code class="fe mn mo mp mq b"><em class="lp">{ capture: true }</em></code> <em class="lp"> </em>来实现的</p><p id="24d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">要创建的故事:</strong>确定<em class="lp">停止传播</em>与应用程序中<em class="lp">*手动* </em>创建的<code class="fe mn mo mp mq b"><em class="lp">document.addEventListener(…)</em></code> <em class="lp"> </em>回调交互的所有情况，并查看将事件处理程序附加到根的新方法是否会破坏预期的功能；如果是这样，使用捕获阶段。</p><h1 id="a0cf" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">并发模式</h1><p id="979e" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">React 17会有一个实验特性叫做<a class="ae ks" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">并发模式</a>。以前，重新呈现一个组件是<em class="lp"> *not* </em>可中断的，这意味着如果在呈现时发生了一个事件，浏览器将不得不等待(并且可能会降低相当多的速度，就像在文本框中键入内容导致状态更新和页面重新呈现的情况)。</p><p id="97bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在并发模式下，重新渲染发生在内存中，并且是可中断的，所以如果在重新渲染的过程中发生了新的事件，它会被放弃并重新开始。这解决了许多浏览器变慢的情况。</p><p id="b30e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种模式仍然不被完全支持，但它最终会允许一些新功能，如<a class="ae ks" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">悬念</a>，它让你在显示组件之前等待组件中的所有数据加载，防止部分呈现，并使加载指示器变得轻而易举。</p><p id="cfb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">故事打造:</strong>熟读<a class="ae ks" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">并发模式</a>和<a class="ae ks" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">悬疑</a>；如果你雄心勃勃，创建一个概念应用程序，并尝试它们。<em class="lp">注意:您必须明确选择使用并发模式，因为默认情况下它是禁用的</em></p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="c4df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你对React 17的最初想法是什么？下面评论！就我个人而言，我认为它建立的基础和它将启用的新功能(如悬念)令人难以置信地兴奋；我等不及要试用它们了！</p></div></div>    
</body>
</html>