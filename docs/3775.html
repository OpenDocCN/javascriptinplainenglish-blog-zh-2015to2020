<html>
<head>
<title>The Monad Interface</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单子界面</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-monad-interface-2045e5810851?source=collection_archive---------5-----------------------#2020-10-24">https://javascript.plainenglish.io/the-monad-interface-2045e5810851?source=collection_archive---------5-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8881" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">莫纳德简单地解释道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/13b4533a8778efd441d993206059b44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k5jnuDhLn4e--8Dn"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lazycreekimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Dziedzic</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b49d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近在JS世界里，单子风靡一时。如果任何严肃的JS开发者没有听说过<em class="ls">单子，我会感到惊讶。</em>但以防万一，我喜欢把单子描述成一个奇特的盒子。这是一个特殊的盒子。你不能(嗯，你<em class="ls">不应该</em>能够)看到盒子里面到底是什么，但是你<em class="ls">可以</em>知道这个盒子保存了某种类型的值，并且公开了三个主要的操作符，我们可以用它们来修改或者取出盒子的内容。这些操作就是我所说的<em class="ls"> Monad接口。</em></p><p id="dc6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，所以<em class="ls"> Monad </em>不完全是一个接口。但是在JS中我们可以把它想成一个。作为快速复习，在强类型语言(如C系列)中，<em class="ls">接口</em>是类对象<em class="ls">的定义。</em>如果你曾经使用过TypeScript，你会知道一个接口描述了某个东西的预期<em class="ls">形状</em>——比如一个对象，或者一个函数的参数和返回值。一个接口归结起来就是一个<em class="ls">契约</em>由任何实现该接口的东西来维护，但是它没有给出实现的细节。将事物看作接口是有用的，因为接口是抽象的。抽象是计算机科学中最有用的概念之一。说什么东西是<em class="ls">抽象</em>就是表达它离机器码有多远。我们离机器代码越远越好，因为人类大脑理解语言的抽象；只有机器被制造来读取机器码。关于接口最好的部分是它是一个无成本的抽象。例如，如果您用TypeScript编写一个，它最终甚至不会生成代码，它只会在编译时检查接口的契约是否得到维护。在bare JS中，接口只是在作者的头脑中。因此，我们只能通过自己确保所有预期的方法和字段都被正确实现来维护接口的契约——没有编译时检查来帮助您。但这没关系，因为JS的动态类型特性带来了一些其他非常好的好处，我现在不一定要讨论这些。</p><p id="1567" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以事不宜迟，下面是<em class="ls"> Monad </em>坚持的接口(用TS接口符号表示):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/710df7ebf29c155fd687eb09db351842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6d54nOUVBw7NSDf0khq7g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The Monad Interface in TS notation.</figcaption></figure><p id="8192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其实没那么复杂。我将逐一介绍这三个函数，让它们变得清晰明了。</p><p id="bce4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我们从<code class="fe lu lv lw lx b">map</code>开始。<code class="fe lu lv lw lx b">map</code>是<em class="ls">单子</em>界面中最容易掌握的功能。我们一直在JS中使用它。它说，‘给定一个单子<code class="fe lu lv lw lx b">M a</code>和一个函数<code class="fe lu lv lw lx b">a -&gt; b</code>，将该函数应用于单子的内容<code class="fe lu lv lw lx b">M a</code>产生一个单子<code class="fe lu lv lw lx b">M b</code>。您可以在野外看到本地JS的<em class="ls">数组</em>类型的地图。在<em class="ls">数组</em>中，<code class="fe lu lv lw lx b">map</code>只需将提供的函数应用于数组中的每个元素，生成一个新的数组:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/3d93839fb2819afb28f792291695ff14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNwj-g79a0hKxDstO6rBzA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An example of the map function as used by Array.</figcaption></figure><p id="6587" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我只使用函数<code class="fe lu lv lw lx b">sq</code>的标识符来调用map的方式——这是一种声明式的编码方式。你在一个地方定义事物，在其他地方用名字称呼它们。简单地用名字来称呼它们实际上让事情变得不那么复杂，因为它会将您编写的代码弄乱。此外，您可能想在多个地方拨打<code class="fe lu lv lw lx b">sq</code>。为什么每次调用<code class="fe lu lv lw lx b">sq</code>都要写出匿名函数<code class="fe lu lv lw lx b">x =&gt; x * x</code>？也看看阅读有多好？这几乎是简单的英语，“将函数<code class="fe lu lv lw lx b">sq</code>应用于<code class="fe lu lv lw lx b">a1</code>的内容，并将其分配给一个新的数组<code class="fe lu lv lw lx b">a2</code>。</p><p id="d477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在为<code class="fe lu lv lw lx b">unwrap</code>。<code class="fe lu lv lw lx b">unwrap</code>是<em class="ls"> Monad </em>界面中最没有意义的界面。您可能知道它是<code class="fe lu lv lw lx b">flat</code>、<code class="fe lu lv lw lx b">flatten</code>、<code class="fe lu lv lw lx b">join</code>、<code class="fe lu lv lw lx b">emit</code>等，但它的意思是“把盒子里的东西拿出来”。虽然拥有它可能看起来很傻，但它实际上是一个非常重要的功能。如果你不能从盒子里拿出里面的东西，单子就没什么用了。也就是说，您通常不应该调用<code class="fe lu lv lw lx b">unwrap</code>，相反，您应该选择一个考虑到您的Monad的每个变体的函数。</p><p id="ae9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑这个片段，定义一个最小的选项(一个处理可空值的单子)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/4fc49cde8c197b84b318e8c7341c90a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXngAejR7kJ1Cu0RsvyiBw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The Option Monad with an example of correct unwrapping.</figcaption></figure><p id="8756" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码创建了一个基础，它定义了一个简单的容器，该容器有两个变体(<em class="ls"> Some </em>和<em class="ls"> None </em>)，称为<em class="ls"> Option </em>。它还不是一个完全成熟的单子，因为我们还没有在它上面定义<code class="fe lu lv lw lx b">map</code>、<code class="fe lu lv lw lx b">chain</code>或<code class="fe lu lv lw lx b">unwrap</code>。注意选项namespace-object上的<code class="fe lu lv lw lx b">or</code>的定义。它在内部调用<code class="fe lu lv lw lx b">unwrap</code>，而不是直接调用。它检查每个变量，如果不是Option的变量，就抛出一个错误。这优于<code class="fe lu lv lw lx b">unwrap</code>，因为展开一个<em class="ls"> None </em>值将简单地返回一个<em class="ls"> None </em>。大多数单子都有一个特定的函数来安全地展开它们，考虑空值或未定义的值并适当地响应，更重要的是，<em class="ls">可预测的。</em></p><p id="5e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用上面定义的<code class="fe lu lv lw lx b">map</code>和<code class="fe lu lv lw lx b">unwrap</code>操作符来充实<em class="ls">选项</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/b423aac25ddd97cc7de1b1e29260b086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U23U7wCAoSg5sJC2jRAQwQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Map and Unwrap implemented for the option variants Some and None.</figcaption></figure><p id="4660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一些真正的功能。让我们快速讨论一下这意味着什么:</p><ul class=""><li id="4d62" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">选装件有两种<em class="ls">变型——部分</em>和<em class="ls">无</em>。</li><li id="48d4" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">你要么有一些东西，要么什么都没有。</li><li id="5168" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">当你有一些东西，你可以像平常一样映射和打开它。</li><li id="4eac" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">当你没有任何东西的时候，你可以试着映射或打开，但你仍然没有，所以这就是为什么我们不断返回它。</li></ul><p id="cd52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以对盒子里的东西进行操作。如果我们仅仅在<code class="fe lu lv lw lx b">map</code>处停止，我们就会有所谓的<em class="ls">函子</em>。函子是一个奇特的盒子，可以<code class="fe lu lv lw lx b">map</code>。很容易把函子误认为完全成熟的单子，但它们是不同的。必须遵守数学恒等式法则，才能正确地将a构造定义为单子，包括<code class="fe lu lv lw lx b">unwrap</code>和<code class="fe lu lv lw lx b">chain</code>方法。我们不会深入讨论所有这些，但是我们将定义<code class="fe lu lv lw lx b">chain</code>，当它和<code class="fe lu lv lw lx b">unwrap</code>一起被正确定义时，几乎可以使函子成为单子。现在我们来定义一下<code class="fe lu lv lw lx b">chain</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/d10e1a5d43dc2f7eda56c6c032d5ea16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXmfCsQlX9MpjpQVv-wICg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Chain of the Monad Interface implemented on Some and None.</figcaption></figure><p id="15e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">明白我为什么把链子留到最后了吧？它是通过在一个类型上定义<code class="fe lu lv lw lx b">map</code>和<code class="fe lu lv lw lx b">unwrap</code>免费给我们的。<code class="fe lu lv lw lx b">chain</code>实际上是将提升值的函数链接在一起，通过展开丢弃外部的单子。这是一种数学对称，允许我们应用单子构造操作，而不会出现盒中盒中盒的情况。这些是FP想要避免的复杂类型。</p><p id="bad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以玩一下<code class="fe lu lv lw lx b">chain</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/203357bc4bbd55f8ce66abb6845d9e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvYG6eqUAdCz8HkGDjPrCg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A simple use case for chain of the Monad Interface.</figcaption></figure><p id="81f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们没有<code class="fe lu lv lw lx b">chain</code>，我们仍然可以像这样映射函数。这种方法的问题是，我们最终会得到一个<code class="fe lu lv lw lx b">Option(Option(A))</code>，而不仅仅是一个<code class="fe lu lv lw lx b">Option(A)</code>。用盒子里的盒子工作要复杂得多。让我们看看会发生什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/6d9419fc6829b80233d5970fab4905e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBDWZhhQJnIGr-KBZybJEg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Mapping an Option-returning function into an Option.</figcaption></figure><p id="58fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看我们现在如何考虑我们的嵌套值是什么，然后随着我们的进行添加越来越多的展开？这就是为什么<code class="fe lu lv lw lx b">chain</code>如此重要——它使得一系列相当冗长的操作变得非常简单易懂。一个人一次只能处理这么多信息，所以为什么不通过让信息更有表现力来让自己的生活变得更好呢？这很有意义。想象一下，尝试使用prop之类的方法处理一些检索到的JSON，将结果提升到一个新的单子中——如果我们不使用chain来打开每个结果，每个嵌套的值都会创建一个新的单子包装器。这将导致展开等于您需要下降的嵌套级别—不理想。故事的寓意:使用<code class="fe lu lv lw lx b">chain</code>安全地操作你的价值，同时丢弃多余的容器。</p><p id="5966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们知道了如何基于这个接口定义简单的单子。这支笔可以让你破解选项单子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你喜欢函数式编程的冒险。直到下一次，FP对乡亲们！</p></div></div>    
</body>
</html>