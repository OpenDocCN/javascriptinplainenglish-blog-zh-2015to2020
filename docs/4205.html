<html>
<head>
<title>Angular Resolver for Prefetching Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于预取数据的角度解析器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-resolver-for-prefetching-data-angular-guards-resolve-40fda257d666?source=collection_archive---------0-----------------------#2020-11-24">https://javascript.plainenglish.io/angular-resolver-for-prefetching-data-angular-guards-resolve-40fda257d666?source=collection_archive---------0-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="734c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用角度解析器预取数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/b000c884b1d650e29ee4c932ccb43d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*XPQoqucjRoq5ct0xCYP_Ng.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Guard Types in Angular, Angular Resolve Guard</figcaption></figure><h1 id="067e" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">什么是角旋变器？</h1><p id="154d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当用户从一条路线重定向到另一条路线时，使用角度解析器来预取一些数据。新的可用页面将已经具有需要在页面中呈现的数据。</p><p id="476a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在某些场景中，我们可能需要为要显示的组件预加载数据，以便在初始呈现时组件本身包含数据，而不是先显示空组件，然后查询API来提取数据。</p><h1 id="69a2" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">为什么我们在角路由中使用旋变器？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e46db0bbf419c56e5cf243e31106c0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*nLP9mRCr8HkpLfn3LWFq-Q.png"/></div></figure><p id="a8d6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">使用角度解析器的常见用例场景是，正在加载的路由正在寻找一些异步数据。异步数据需要显示在组件中。</p><p id="75e8" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">当我们对要呈现的组件的异步数据有一些需求时，有两种方法。</p><ol class=""><li id="013b" class="ml mm iq ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated"><strong class="ll ir">在组件加载后加载数据</strong>:在第一种方法中，我们最初可以不使用任何数据来呈现组件，一旦组件被加载，我们可以调用Ajax来提取组件数据。然后组件被重新呈现以显示Ajax调用中的可用数据。这类似于最初呈现一个空白模板，然后向该模板添加数据。组件最初呈现后，数据可能会在短暂延迟后可用。</li><li id="db55" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><strong class="ll ir">在组件加载之前加载数据</strong>:另一种方法是在呈现组件之前准备好数据。如果需要从异步调用中提取数据，组件将在第一次呈现组件之前首先等待数据可用。这样，我们就不会渲染空模板了。在组件的初始渲染之前，路由器首先等待数据可用。</li></ol><h1 id="4256" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">如何创建角度解析器服务</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/25ec5803bc4f400727e4c3c35e131ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*B-SMgwbL1iWBcwmhrjPpdw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">How to create Angular Resolve Service</figcaption></figure><p id="d12b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了实现解析器服务，我们需要:</p><ol class=""><li id="a43f" class="ml mm iq ll b lm mf lp mg ls mn lw mo ma mp me mq mr ms mt bi translated">我们需要从“<strong class="ll ir"> @angular/router </strong>”导入解析接口</li><li id="005f" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">创建一个实现这个<strong class="ll ir">“解析”接口</strong>的服务类</li><li id="3be5" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated"><strong class="ll ir">覆盖“resolve()”函数</strong>来指定我们需要等待的HTTP请求。这个函数可能返回一个承诺或可观察的</li><li id="9696" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">将该服务类添加到<strong class="ll ir">“根”模块</strong>。</li><li id="0166" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">将“<strong class="ll ir"> ActivatedRouteSnapshot </strong>”注入到被加载的组件中，以使用“resolve”函数中指定的AJAX请求中的可用数据</li></ol><h1 id="b055" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">实现解析服务</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6c5d3aeeb2a1cd369df9fb91f30780ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*yGLpqV-s9n6lpnw8BXmI1A.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Implementing Resolver Service in Angular</figcaption></figure><p id="f4ee" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们创建一个"<strong class="ll ir"> DataService </strong>"来提取"<strong class="ll ir">employeelistcomponent</strong>"的数据。该服务将从一个简单的API调用中获取公司的员工列表。下面是实现…</p><p id="3119" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们从实现服务开始，该服务将在组件加载到屏幕之前解析需要对组件可用的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk"><a class="ae nd" href="https://gist.github.com/Mayankgupta688/67fca46dbbfc47c9289c45dd6be41f1f" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/67fca46dbbfc47c9289c45dd6be41f1f</a></figcaption></figure><p id="c106" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在上面的代码中，我们创建了一个“data service”<strong class="ll ir">来实现“Resolve”接口</strong>。因为我们正在实现接口，所以我们需要<strong class="ll ir">定义一个“解析”函数</strong>，它可以<strong class="ll ir">从该函数返回一个承诺/可观察或对象数据</strong>。现在，我们可以使用这个服务在组件加载到应用程序页面之前预取数据。</p><h1 id="3115" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">在角度模块中实施路线</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/2bd74a94dd489c2d6a6e1fca7ec76d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*2dHWY_-5QFE5vETrZxu8Aw.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Adding routs to Angular Module</figcaption></figure><p id="dbd9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">一旦我们创建了服务，我们需要配置我们的路由来指定需要为每个组件预取的数据。让我们看看，我们如何修改路线…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk"><a class="ae nd" href="https://gist.github.com/Mayankgupta688/64c5f3e7f7ff49cbbd6fa97f2234bc01" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/64c5f3e7f7ff49cbbd6fa97f2234bc01</a></figcaption></figure><p id="ff36" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">上面的代码定义了应用程序的路由。当我们为应用程序定义路由时，我们提供一个键“resolve ”,它包含一个用于提取数据的对象。“Resolve”键被分配给一个以“employee”为键、以“DataService”为值的对象。</p><p id="2656" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll ir">“data service”的“resolve”函数被调用</strong>，在加载组件之前，首先<strong class="ll ir">解析返回的承诺/可观察值</strong>。从API中提取的数据被分配给对象“<strong class="ll ir">雇员</strong>”。可以使用下面的代码在组件内部提取数据。</p><h1 id="9bb1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">订阅解析的数据</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk"><a class="ae nd" href="https://gist.github.com/Mayankgupta688/66b3059fb0352b2f29088315a368c2f5" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/66b3059fb0352b2f29088315a368c2f5</a></figcaption></figure><p id="5019" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了在应用程序中获得解析后的数据，我们需要将“<strong class="ll ir"> ActivatedRoute </strong>”注入到构造函数中。因为“数据服务”解析函数正在返回可观察值。我们可以<strong class="ll ir">订阅“这个。_routes.data" </strong>，这将解析并向我们返回上述指定路线的“解析”键中指定的所有数据。</p><p id="5be9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">上述代码将从“DataService”类中指定的API返回雇员列表。一旦数据被订阅，雇员列表将在“雇员”键中可用。</p><p id="5110" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">工作代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nc l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk"><a class="ae nd" href="https://codesandbox.io/s/angular-resolve-routing-qoh9h?file=/src/app/app.module.ts" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/angular-resolve-routing-qoh9h?file=/src/app/app.module.ts</a></figcaption></figure></div></div>    
</body>
</html>