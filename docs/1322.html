<html>
<head>
<title>Advanced Vuejs Component Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Vuejs组件模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/advanced-vuejs-component-patterns-3ab1e1f0ed07?source=collection_archive---------3-----------------------#2020-03-01">https://javascript.plainenglish.io/advanced-vuejs-component-patterns-3ab1e1f0ed07?source=collection_archive---------3-----------------------#2020-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5502" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可扩展Vuejs应用程序的5种模式</h2></div><p id="e5b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组件模式是定义组件的职责和行为的方法和最佳实践。遵循这些模式将提高应用程序的可维护性、性能和可伸缩性。</p><p id="286a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一部分中，我们将介绍在实现新组件时添加到工具箱中的5种模式。</p><ul class=""><li id="4511" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">功能组件</li><li id="cfcb" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">动态组件</li><li id="7a4f" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">异步组件</li><li id="e4e5" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">无渲染组件</li><li id="2f26" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">高阶组件</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/46f09d2f43b3cefe243a98fb72a8b63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nzo269Yz0NnuEr8n"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Photo by <a class="ae mf" href="https://unsplash.com/@fran_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fran .</a> on <a class="ae mf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="935c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">功能组件</h1><p id="38c9" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">与您的设想不同，这些组件并没有做太多的事情。它们由渲染函数组成，没有状态(无状态)，没有生命周期挂钩，甚至没有Vue实例，因此它们便宜而快速。</p><h2 id="a463" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">何时使用它们</h2><p id="2843" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">当您想要提升应用程序的性能时，它们是一个不错的选择。功能组件往往尺寸更小，因此增加了可测试性和可重用性。</p><p id="2db4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们通常用于编写表示性的(<em class="nk">哑的</em>)组件，比如按钮、图像、链接和头像。</p><h2 id="32e8" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">如何实现它们</h2><p id="6795" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">通过向组件添加<code class="fe nx ny nz oa b">functional</code>属性，可以很容易地实现功能组件，这可以通过使用模板或渲染函数来完成。</p><h2 id="c3a4" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">模板</h2><p id="c13e" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">类似于常规的vue组件，我们可以使用带有<code class="fe nx ny nz oa b">functional</code>属性的<code class="fe nx ny nz oa b">template</code>标签。</p><p id="5c2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于是无状态的，API是不同的，例如，你必须使用<code class="fe nx ny nz oa b">{{props.msg}}</code>而不是<code class="fe nx ny nz oa b">{{msg}}</code>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="7001" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">渲染功能</h2><p id="0701" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">当使用渲染函数时，你需要做的就是定义<code class="fe nx ny nz oa b">true</code>的函数属性如下</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7ce9" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">动态组件</h1><p id="1109" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">动态组件允许你利用<code class="fe nx ny nz oa b">&lt;component :is="attribute"&gt;</code>基于<code class="fe nx ny nz oa b">attribute</code>安装和卸载组件</p><p id="c220" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着你不再有几个<code class="fe nx ny nz oa b">v-if</code>和一个杂乱的模板，而是获得了开箱即用的相同功能。此外，您还可以在交换组件时保持您的状态。</p><h2 id="7244" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">何时使用它们</h2><p id="858b" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">到目前为止，选项卡是最流行的用例，因为对于每个选项卡，您都希望根据所选的选项卡交换几个组件。</p><p id="16f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网站构建者通常非常依赖这种模式，因为最终客户(用户)是决定在运行时呈现哪些组件的人。</p><h2 id="e958" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">如何实施它们</h2><p id="9f52" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">实现动态组件非常简单。使用内置的<code class="fe nx ny nz oa b">&lt;component :is=”componentName”&gt;</code>，它允许我们基于<code class="fe nx ny nz oa b">componentName</code>的评估动态地呈现一个组件。</p><p id="1035" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果我们想在不同组件之间切换时保持状态，那么我们可以使用<code class="fe nx ny nz oa b">&lt;keep-alive&gt;</code>来保持这个组件状态不消失。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b9d9" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">异步组件</h1><p id="1f2d" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">异步组件是异步加载的组件。它们通过减小初始包的大小来优化加载时间，从而有助于提高应用程序的性能。</p><p id="8d9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您的应用程序增长，您将认识到您不必立即将所有组件交付给您的用户，因为有些用户可能不使用某些组件。</p><p id="cdc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用Webpack和ES6，您可以轻松优化向客户交付哪些组件。</p><h2 id="5469" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">何时使用它们</h2><p id="7fcb" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">异步组件通常用于路由/页面组件，从而推迟这些组件的加载，直到客户请求它们。</p><p id="e0c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在更大的组件中，涉及复杂的状态操作来切换一些组件(<em class="nk">思考表单向导</em>)延迟这些组件的加载也有助于减少初始包的大小。</p><h2 id="cef2" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">如何实施它们</h2><p id="cac3" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">您所需要做的就是返回一个与您的组件一起解析的<code class="fe nx ny nz oa b">promise</code>。使用Webpack和ES6，我们可以只在安装了<code class="fe nx ny nz oa b">my-async-component</code>的用户时才加载它。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="0a4d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">高阶组件</h1><p id="98a2" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">高阶组件是将一个组件作为参数，并在添加一些功能后返回另一个组件的组件。</p><p id="6039" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在几个组件之间共享逻辑，HOC允许您减少代码重复。</p><p id="4871" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这种模式不像react社区中那样常见，因为存在作用域槽和混合。可以编写高阶元件，如<a class="ae mf" href="https://github.com/ktsn/vuex-connect" rel="noopener ugc nofollow" target="_blank"> vuex-connect </a>。</p><h2 id="60b4" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">何时使用它们</h2><p id="ff10" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">我个人还没有使用过它们，但是我可以看到回退加载组件是HOC有用的一个用例。</p><h2 id="2420" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">如何实现它们</h2><p id="078e" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">以下是由<a class="od oe ep" href="https://medium.com/u/507e445516c?source=post_page-----3ab1e1f0ed07--------------------------------" rel="noopener" target="_blank">Bogna“bog nix”knychaa</a>撰写的关于HOC的深度指南</p><div class="of og gp gr oh oi"><a href="https://medium.com/bethink-pl/higher-order-components-in-vue-js-a79951ac9176" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">Vue.js中的高阶组件</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">如React文档中所述，高阶组件是一个函数，它将组件和…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow lz oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://github.com/jackmellis/vue-hoc/blob/master/packages/vue-hoc/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">jackmellis/vue-hoc</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">受https://github.com/vuejs/vue/issues/6201姐妹项目的启发，创建更高阶的Vue组件:vue-compose…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow lz oi"/></div></div></a></div></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c20d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">无渲染组件</h1><p id="76b1" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">这些组件本身不呈现任何内容。它们的存在是为了封装特定的功能并允许消费者提供不同的模板。</p><p id="fcca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无渲染组件通过向上提供数据/接口，严重依赖于作用域插槽。</p><h2 id="c311" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">何时使用它们</h2><p id="9ce7" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">假设我们想要实现一个可切换的按钮，但同时我们不想把它限制在一个模板上。这使得切换组件成为无渲染的良好候选。在这个意义上，我们将公开状态，并使用作用域槽向上公开方法。</p><h2 id="986e" class="nl mo iq bd mp nm nn dn mt no np dp mx ko nq nr mz ks ns nt nb kw nu nv nd nw bi translated">如何实施它们</h2><p id="2913" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">首先，我们向消费组件公开状态<code class="fe nx ny nz oa b">on</code>和一些方法，如<code class="fe nx ny nz oa b">setOff</code>和<code class="fe nx ny nz oa b">setOn</code>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="eaf9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍后，我们用模板填充该槽，并在无渲染组件中重用预定义的状态和方法</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="f3da" class="mn mo iq bd mp mq oy ms mt mu oz mw mx jw pa jx mz jz pb ka nb kc pc kd nd ne bi translated">摘要</h1><p id="983f" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">我们已经介绍了一些流行的组件模式、它们的用法和实现。关于组件模式的推理将帮助您更好地设计您的应用程序，从而从长远来看节省您的时间。</p><p id="4f20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些模式并不相互排斥，您经常可以将多个模式混合在一起，这样您就可以拥有一个异步功能组件或一个无渲染的动态组件。</p><p id="21ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是我问自己的一些有帮助的问题，以决定使用哪种组件模式</p><ul class=""><li id="13ac" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">这个组件是有状态的吗？它需要有状态吗？</li><li id="cc38" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">您认为这个组件的“逻辑”有可能被重用吗？</li><li id="2805" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">您需要在初始加载时加载该组件吗？</li><li id="92b9" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">我的模板上有多个<code class="fe nx ny nz oa b">v-if</code>吗？</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="cdaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读，我错过了你使用的一些模式吗？请在评论中告诉我。如果您想阅读更多关于组件模式的内容，这是一个很好的起点。</p><div class="of og gp gr oh oi"><a href="https://learn-vuejs.github.io/vue-patterns/patterns/#component-declaration" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">组件声明| Vue模式</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">SFC(clicked - 0)引用:基本上，vue组件遵循单向数据流，即props down()和events up…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">learn-vuejs.github.io</p></div></div></div></a></div></div></div>    
</body>
</html>