<html>
<head>
<title>Basic Built-in React Hooks- useState and useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本的内置反应挂钩——使用状态和使用效果</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basic-built-in-react-hooks-usestate-and-useeffect-6011271ed0af?source=collection_archive---------10-----------------------#2020-04-06">https://javascript.plainenglish.io/basic-built-in-react-hooks-usestate-and-useeffect-6011271ed0af?source=collection_archive---------10-----------------------#2020-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8b53c621a0c284ff321de32972203bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3wUseTKqzg9zXCPH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@chandramaharzan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chandra Maharzan</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e18e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="859d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看一些基本的内置React挂钩，包括<code class="fe lb lc ld le b">useState</code>和<code class="fe lb lc ld le b">useEffect</code>。</p><h1 id="0e2b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">useState</code></h1><p id="b8b4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">useState</code>钩子让我们管理功能组件的内部状态。它接受一个初始值作为参数，并返回一个具有当前状态的数组和一个更新它的函数。</p><p id="ec48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当组件最初呈现时，它返回初始状态。</p><p id="591d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果新值是使用以前的状态计算出来的，我们可以传入一个函数来更新这个值。</p><p id="0927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来更新基于先前值的值:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6fc5" class="mq lg iq le b gy mr ms l mt mu">function App() {<br/>  const [count, setCount] = React.useState(0);<br/>  return (<br/>    &lt;&gt;<br/>      Count: {count}<br/>      &lt;button onClick={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;<br/>        Decrement<br/>      &lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;<br/>        Increment<br/>      &lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="6dc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8cbc" class="mq lg iq le b gy mr ms l mt mu">setCount(prevCount =&gt; prevCount - 1)}</span></pre><p id="b52a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b240" class="mq lg iq le b gy mr ms l mt mu">setCount(prevCount =&gt; prevCount + 1)}</span></pre><p id="8bba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数通过传入将先前的计数作为参数并返回新计数的函数来分别递减和递增<code class="fe lb lc ld le b">count</code>。</p><p id="b8c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们可以向状态更新函数传递新值，就像我们在:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a291" class="mq lg iq le b gy mr ms l mt mu">setCount(0)</span></pre><p id="aa08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">useState</code>不会自动合并更新对象。我们可以用spread语法复制这种行为:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4e65" class="mq lg iq le b gy mr ms l mt mu">function App() {<br/>  const [nums, setNums] = React.useState({});<br/>  return (<br/>    &lt;&gt;<br/>      &lt;p&gt;{Object.keys(nums).join(",")}&lt;/p&gt;<br/>      &lt;button<br/>        onClick={() =&gt;<br/>          setNums(oldNums =&gt; {<br/>            const randomObj = { [Math.random()]: Math.random() };<br/>            return { ...oldNums, ...randomObj };<br/>          })<br/>        }<br/>      &gt;<br/>        Click Me<br/>      &lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="5e34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6e51" class="mq lg iq le b gy mr ms l mt mu">setNums(oldNums =&gt; {<br/>            const randomObj = { [Math.random()]: Math.random() };<br/>            return { ...oldNums, ...randomObj };<br/>          })</span></pre><p id="3648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用一个随机数作为键和值来创建一个<code class="fe lb lc ld le b">randomObj</code>对象，我们将它合并到另一个具有旧值的对象中，然后返回它。</p><p id="3a56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们显示它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c400" class="mq lg iq le b gy mr ms l mt mu">Object.keys(nums).join(",")</span></pre><p id="529d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过得到钥匙并把它们连接在一起。</p><h2 id="8ada" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">惰性初始状态</h2><p id="d6a6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们想延迟初始状态的设置，我们可以向<code class="fe lb lc ld le b">useState</code>传递一个函数。</p><p id="3cd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们传入一个函数，它会在初始渲染后被忽略。</p><p id="5a8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果初始状态是通过一些昂贵的操作计算出来的，这是很有用的。</p><p id="3dcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="44d6" class="mq lg iq le b gy mr ms l mt mu">function App() {<br/>  const [count, setCount] = React.useState(() =&gt; 0);<br/>  return (<br/>    &lt;&gt;<br/>      Count: {count}<br/>      &lt;button onClick={() =&gt; setCount(() =&gt; 0)}&gt;Reset&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;<br/>        Decrement<br/>      &lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;<br/>        Increment<br/>      &lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="2b0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="05ac" class="mq lg iq le b gy mr ms l mt mu">React.useState(() =&gt; 0)</span></pre><p id="edde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数只返回0。</p><p id="907f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会看到和以前一样的结果。</p><h2 id="741b" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">退出状态更新</h2><p id="4fad" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们用与当前值相同的值更新一个状态钩子。React将跳过更新状态，而不渲染子对象或激发效果。</p><p id="c2c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React使用<code class="fe lb lc ld le b">Object.is()</code>来比较当前状态和新状态，除了<code class="fe lb lc ld le b">+0</code>和<code class="fe lb lc ld le b">-0</code>被视为不相等而<code class="fe lb lc ld le b">NaN</code>等于自身之外，它与<code class="fe lb lc ld le b">===</code>操作符很接近。</p><p id="a310" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在退出之前，React可能仍然会渲染，但是如果它发现新旧值相同，它不会更深入到树中。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/ef2b1c471ebe5cfd8373aafbbf2a6142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C62yODbuFJlwHmja"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@_louisreed?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Louis Reed</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d50c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">useEffect</code></h1><p id="81b0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">useEffect</code>钩子来做各种不允许在函数组件主体内部进行的操作，这是渲染阶段之外的事情。</p><p id="89b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以用它来做任何突变、订阅、设置定时器和其他副作用。</p><p id="ce59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行代码需要回调。</p><p id="36d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在内部返回一个函数，以便在每次渲染后以及组件卸载时运行任何清理代码。</p><p id="27f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在延迟事件期间，传入<code class="fe lb lc ld le b">useEffect</code>的回调在布局和绘制之后触发。</p><p id="b7a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得它适合于运行不应该阻止浏览器更新屏幕的操作。</p><p id="ec18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">必须同步运行的代码可以放到<code class="fe lb lc ld le b">useLayoutEffect</code>钩子的回调中，这是<code class="fe lb lc ld le b">useEffect</code>的同步版本。</p><p id="7e3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它肯定会在任何新的渲染之前启动。React将总是在开始新的更新之前刷新以前的渲染效果。</p><h2 id="7ef9" class="mq lg iq bd lh mv mw dn ll mx my dp lp ko mz na lt ks nb nc lx kw nd ne mb nf bi translated">有条件地触发一个效果</h2><p id="db0a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以向<code class="fe lb lc ld le b">useEffect</code>传递第二个参数，该参数带有一个值数组，要求在值发生变化时运行一个效果。</p><p id="64f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用它在初始渲染时从API获取数据，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e19b" class="mq lg iq le b gy mr ms l mt mu">function App() {<br/>  const [joke, setJoke] = React.useState({});<br/>  useEffect(() =&gt; {<br/>    (async () =&gt; {<br/>      const response = await fetch("<a class="ae kc" href="https://api.icndb.com/jokes/random" rel="noopener ugc nofollow" target="_blank">https://api.icndb.com/jokes/random</a>");<br/>      const res = await response.json();<br/>      console.log(res);<br/>      setJoke(res);<br/>    })();<br/>  }, []);<br/>  return (<br/>    &lt;&gt;<br/>      &lt;p&gt;{joke.value &amp;&amp; joke.value.joke}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="ce03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将空数组作为第二个参数传递会阻止它在后续渲染中加载。</p><p id="af02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以向数组传递一个值，观察数组中的值的变化，然后运行回调函数:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="bf77" class="mq lg iq le b gy mr ms l mt mu">function App() {<br/>  const [joke, setJoke] = React.useState({});<br/>  const [id, setId] = React.useState(1);<br/>  useEffect(() =&gt; {<br/>    (async () =&gt; {<br/>      const response = await fetch(`<a class="ae kc" href="https://api.icndb.com/jokes/${id}`" rel="noopener ugc nofollow" target="_blank">https://api.icndb.com/jokes/${id}`</a>);<br/>      const res = await response.json();<br/>      console.log(res);<br/>      setJoke(res);<br/>    })();<br/>  }, [id]);<br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; setId(Math.ceil(Math.random() * 100))}&gt;<br/>        Random Joke<br/>      &lt;/button&gt;<br/>      &lt;p&gt;{joke.value &amp;&amp; joke.value.joke}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="df20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，当我们单击随机笑话按钮时，<code class="fe lb lc ld le b">setId</code>被调用，调用的新数字在1到100之间。然后<code class="fe lb lc ld le b">id</code>改变，触发<code class="fe lb lc ld le b">useEffect</code>回调运行。</p><p id="6400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用新值设置<code class="fe lb lc ld le b">joke</code>，然后新的<code class="fe lb lc ld le b">joke</code>显示在屏幕上。</p><h1 id="56e2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="44fb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">useState</code>和<code class="fe lb lc ld le b">useEffect</code>是最基本的内置React钩子。</p><p id="f868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">useState</code>让我们通过传入一个返回初始状态的函数或者直接传入初始状态来更新状态。</p><p id="0931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个具有当前状态的数组和一个更新状态的函数。返回的状态更新函数接受一个值或一个以以前的值作为参数的函数，如果新值依赖于以前的值，则返回新值。</p><p id="33dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">useEffect</code>让我们运行任何副作用、突变或渲染阶段之外的任何东西。</p><p id="f2c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个回调，其中要运行的代码作为第一个参数，并接受一个数组，其中包含在回调运行之前要监视的更改的值。</p><p id="0af1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果传入一个空数组，那么回调只在初始渲染时运行。</p><p id="bc22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【JavaScript用简单的英语写的一句话:我们总是乐于帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>