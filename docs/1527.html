<html>
<head>
<title>Authentication and Express Middleware with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL的认证和快速中间件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/authentication-and-express-middleware-with-graphql-35d9f6b50f2c?source=collection_archive---------5-----------------------#2020-03-27">https://javascript.plainenglish.io/authentication-and-express-middleware-with-graphql-35d9f6b50f2c?source=collection_archive---------5-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b6de47d993435c922274b22eb9632d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zT4VUYMk-N8UQMth"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lensinkmitchel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mitch Lensink</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8335" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用Express创建一个简单的GraphQL服务器。为此，我们需要<code class="fe lb lc ld le b">express-graphql</code>和<code class="fe lb lc ld le b">graphql</code>包。</p><p id="f3d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何在Express GraphQL中使用中间件。</p><h1 id="7fb3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">快速中间件</h1><p id="0bf0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们使用<code class="fe lb lc ld le b">express-graphql</code>用Express构建我们的GraphQL服务器，我们可以像往常一样使用Express中间件。</p><p id="c3e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在任何解析器中，<code class="fe lb lc ld le b">request</code>对象都可以作为第二个参数。</p><p id="9719" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想在解析器中获得请求的主机名，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f994" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const graphqlHTTP = require('express-graphql');<br/>const { buildSchema } = require('graphql');</span><span id="5ca4" class="mq lg iq le b gy mv ms l mt mu">const schema = buildSchema(`<br/>  type Query {<br/>    hostname: String<br/>  }<br/>`);</span><span id="400a" class="mq lg iq le b gy mv ms l mt mu">const loggingMiddleware = (req, res, next) =&gt; {<br/>  console.log(req.hostname);<br/>  next();<br/>}</span><span id="846d" class="mq lg iq le b gy mv ms l mt mu">const root = {<br/>  hostname(args, request) {    <br/>    return request.hostname;<br/>  }<br/>};</span><span id="3bf8" class="mq lg iq le b gy mv ms l mt mu">const app = express();<br/>app.use(loggingMiddleware);<br/>app.use('/graphql', graphqlHTTP({<br/>  schema: schema,<br/>  rootValue: root,<br/>  graphiql: true,<br/>}));<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="d6eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们像往常一样创建了模式来获取应用程序的主机名。</p><p id="3698" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加了我们的<code class="fe lb lc ld le b">loggingMiddleware</code>来记录主机名。它调用<code class="fe lb lc ld le b">next</code>，所以我们可以使用我们的<code class="fe lb lc ld le b">graphqlHTTP</code>中间件。</p><p id="9ed9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的<code class="fe lb lc ld le b">root</code>解析器中，我们添加了一个<code class="fe lb lc ld le b">hostname</code>方法，它将<code class="fe lb lc ld le b">request</code>参数作为第二个实参，这个实参有Express request对象。</p><p id="b890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们可以从<code class="fe lb lc ld le b">request</code>返回<code class="fe lb lc ld le b">hostname</code>属性的地方，这样我们就可以在响应中返回它。</p><p id="a783" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以像使用REST APIs一样继续使用中间件来处理身份验证。</p><p id="2fc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Express的常用认证选项包括Passport、<code class="fe lb lc ld le b">express-jwt</code>和<code class="fe lb lc ld le b">express-session</code>。</p><h1 id="6384" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">证明</h1><p id="aea6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以在Express GraphQL服务器中使用<code class="fe lb lc ld le b">jsonwebtoken </code>,如下所示，通过JSON web token添加身份验证。</p><p id="ed43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们首先通过运行以下命令来安装<code class="fe lb lc ld le b">jsonwebtoken</code>:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ca2c" class="mq lg iq le b gy mr ms l mt mu">npm i <!-- -->jsonwebtoken</span></pre><p id="143d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将它包含在我们的应用程序中，然后添加到我们的Express GraphQL服务器，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e400" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const graphqlHTTP = require('express-graphql');<br/>const { buildSchema } = require('graphql');<br/>const jwt = require('jsonwebtoken');<br/>const unless = require('express-unless');</span><span id="7fbd" class="mq lg iq le b gy mv ms l mt mu">const schema = buildSchema(`<br/>  type Query {<br/>    hostname: String<br/>  }<br/>`);</span><span id="7fdb" class="mq lg iq le b gy mv ms l mt mu">const root = {<br/>  hostname(args, request) {<br/>    return request.hostname;<br/>  }<br/>};</span><span id="8303" class="mq lg iq le b gy mv ms l mt mu">const verifyToken = (req, res, next) =&gt; {  <br/>  jwt.verify(req.headers.authorization, 'secret', (err, decoded) =&gt; {<br/>    if (err){      <br/>      return res.send(401);<br/>    }<br/>    next();<br/>  });<br/>}<br/>verifyToken.unless = unless;</span><span id="3eed" class="mq lg iq le b gy mv ms l mt mu">const app = express();<br/>app.post('/auth', (req, res) =&gt; {<br/>  const token = jwt.sign({ foo: 'bar' }, 'secret');<br/>  res.send(token);<br/>})</span><span id="7c03" class="mq lg iq le b gy mv ms l mt mu">app.use(verifyToken.unless({ path: ['/auth'] }));<br/>app.use('/graphql', graphqlHTTP({<br/>  schema: schema,<br/>  rootValue: root,<br/>  graphiql: true,<br/>}));<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="5737" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用<code class="fe lb lc ld le b">verifyToken</code>中间件来验证由<code class="fe lb lc ld le b">auth</code>路由发出的令牌。</p><p id="27d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">verifyToken</code>中，我们调用<code class="fe lb lc ld le b">jwt.verify</code>来验证我们传递到<code class="fe lb lc ld le b">Authorization</code>头中的令牌。如果我们得到一个错误，那么我们发送一个401响应。</p><p id="cd4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们调用<code class="fe lb lc ld le b">next</code>继续下一个中间件我们的路线。</p><p id="507b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">auth</code>路由中，我们通过调用<code class="fe lb lc ld le b">jwt.sign</code>来发布我们的认证令牌，第一个参数是我们想要的任何内容，第二个参数是令牌的秘密。</p><p id="92cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们通过使用<code class="fe lb lc ld le b">express-unless</code>中间件将<code class="fe lb lc ld le b">verifyToken</code>中间件从<code class="fe lb lc ld le b">auth</code>路线中排除。</p><p id="c6b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过将<code class="fe lb lc ld le b">unless</code>分配给<code class="fe lb lc ld le b">verifyToken.unless</code>做到了这一点。</p><p id="ac62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们想要通过<code class="fe lb lc ld le b">/graphql</code>路由向GraphQL服务器发出请求时，我们必须将我们的auth令牌传递给<code class="fe lb lc ld le b">Authorization</code>头。</p><p id="a17d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使我们的GraphQL请求更加安全。然而，如果我们要在现实世界中使用JSON web令牌，我们应该有一个加密的秘密。</p><h1 id="2025" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="454b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用Express中间件进行日志记录、身份验证或任何我们需要它们做的事情。</p><p id="082b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了包含中间件，我们像往常一样调用<code class="fe lb lc ld le b">app.use</code>方法。</p><p id="394a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用带有<code class="fe lb lc ld le b">express-unless</code>包的中间件来排除路由。</p><p id="cfc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了通过JSON web令牌添加身份验证，我们可以使用<code class="fe lb lc ld le b">jsonwebtoken</code>包为我们的Express GraphQL服务器添加令牌发布和验证功能。</p></div></div>    
</body>
</html>