<html>
<head>
<title>Modding Web apps with ASTs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ASTs修改Web应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/modding-web-apps-with-asts-5a7ac7d1f65d?source=collection_archive---------5-----------------------#2019-12-06">https://javascript.plainenglish.io/modding-web-apps-with-asts-5a7ac7d1f65d?source=collection_archive---------5-----------------------#2019-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="9925" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">动机</h1><p id="bdb5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我正在做一个前端项目，这个项目有很多贡献者，编码风格被放错了地方。这意味着不同的开发人员编写不同的模式。随着项目的增长，不同的JavaScript文件暴露了不同的类和模块(不使用模块导出:(只是为了清楚起见)很难识别哪个文件依赖于另一个文件。这意味着调试和修复代码气味具有挑战性。更不用说循环依赖地狱了。就像用枪一样，我需要一个瞄准镜来更好地瞄准虫子。</p><p id="3d6f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><a class="ae lo" href="https://github.com/divyamamgai/skope/tree/master/article#developing-better-code-using-asts" rel="noopener ugc nofollow" target="_blank"> <em class="lp">这里的</em> </a> <em class="lp">是这篇文章的降价版。</em></p><h1 id="b94f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">开发范围计算器</h1><p id="88bd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将使用抽象语法树(或简称AST)来获取关于我们的代码的信息，我们可以很容易地分析这些信息。我不会在这里详细讨论AST，因为<a class="ae lo" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">这篇</a>文章已经很好地介绍了它，所以请仔细阅读。很好地总结一下，然后继续前进，不要太深入-</p><blockquote class="lq lr ls"><p id="09d5" class="kl km lp kn b ko lj kq kr ks lk ku kv lt ll ky kz lu lm lc ld lv ln lg lh li ij bi translated"><em class="iq">AST仅包含与分析源文本相关的信息，并跳过解析文本时使用的任何其他额外内容。</em></p></blockquote><p id="268c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了给我们的JavaScript文件构建这样一个AST，我们将使用<a class="ae lo" href="https://github.com/acornjs/acorn" rel="noopener ugc nofollow" target="_blank"> acorn </a>(它是一个JavaScript解析器)和<a class="ae lo" href="https://github.com/acornjs/acorn/tree/master/acorn-walk" rel="noopener ugc nofollow" target="_blank"> acorn-walk </a>(一个语法树，通过acorn，walker生成)。让我们举一个(写得很差的)JavaScript (ES5)代码的例子。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="ddd9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在我们开始开发一个检测声明的逻辑之前，让我们列出我们所期望的结果声明。</p><ol class=""><li id="ac4f" class="md me iq kn b ko lj ks lk kw mf la mg le mh li mi mj mk ml bi translated">变量<code class="fe mm mn mo mp b">a</code>和函数<code class="fe mm mn mo mp b">f()</code>在全局范围内声明。</li><li id="0bea" class="md me iq kn b ko mq ks mr kw ms la mt le mu li mi mj mk ml bi translated">根据定义，变量<code class="fe mm mn mo mp b">d</code>是一个全局变量，因为我们省略了<code class="fe mm mn mo mp b">var</code>关键字。</li><li id="f7ed" class="md me iq kn b ko mq ks mr kw ms la mt le mu li mi mj mk ml bi translated"><code class="fe mm mn mo mp b">window</code>对象的函数属性<code class="fe mm mn mo mp b">e()</code>在浏览器中本来就是一个全局标识符。</li></ol><p id="0e5f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，对于我们的代码片段，我们期望声明为<code class="fe mm mn mo mp b">a</code>、<code class="fe mm mn mo mp b">f</code>、<code class="fe mm mn mo mp b">d</code>和<code class="fe mm mn mo mp b">e</code>(对于这个例子，我们保持简单，不要分离函数和变量)，它们被暴露给其他可能使用或包含的代码片段。</p><p id="0aa6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要使用acorn生成AST，首先我们需要从文件中读取JavaScript代码。解析器返回一个由<a class="ae lo" href="https://github.com/estree/estree" rel="noopener ugc nofollow" target="_blank"> ESTree spec </a>指定的AST对象，这是一个类型为<code class="fe mm mn mo mp b">Program</code>的节点，其主体包含根据代码片段定义的连续类型节点。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="eae8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了可视化生成的树，我写了一个<a class="ae lo" href="https://gist.github.com/divyamamgai/396a4424cd1b04ac415bc4ec72b087e4" rel="noopener ugc nofollow" target="_blank">脚本</a>，它创建了树的一个<a class="ae lo" href="https://raw.githubusercontent.com/divyamamgai/skope/master/article/images/fileGraph.svg?sanitize=true" rel="noopener ugc nofollow" target="_blank"> SVG </a>文件(不包括一些节点)，附在下面。我建议通过控制台日志记录或调试节点来获得更多信息，目前，这只是一个简单的例子，只显示了节点的<code class="fe mm mn mo mp b">type</code>。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/79bdc9849188ae8ff13cfe74056ffac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HeHBRrJmIQ98n4VAmqY7A.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Visualization of the sample code in form of AST</figcaption></figure><p id="bca6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，我们可以使用Acorn AST walker以多种方式遍历生成的树，如这里的<a class="ae lo" href="https://github.com/acornjs/acorn/tree/master/acorn-walk#interface" rel="noopener ugc nofollow" target="_blank">所述</a>，在继续前进之前，请花时间阅读这些方法。我们将使用<code class="fe mm mn mo mp b">ancestor</code>遍历器，它对一棵树进行<code class="fe mm mn mo mp b">simple</code>遍历，构建一个祖先节点数组(包括当前节点),并将结果数组作为第二个参数传递给回调函数。</p><p id="d3e7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您可以将回调与每个节点类型相关联。只要遍历器到达一个特定的节点，它就用<code class="fe mm mn mo mp b">node</code>和它的<code class="fe mm mn mo mp b">ancestors</code>作为参数为该节点触发回调。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="9212" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">获取JavaScript中标识符的范围</h2><p id="44dc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在JavaScript中，标识符的作用范围是功能性的(考虑到ES5的语法，并将复杂性保持在最低限度)。因此，如果我们想得到任何标识符节点的作用域，我们只需要冒泡到它的祖先节点，直到我们到达一个函数节点(<code class="fe mm mn mo mp b"><a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#functionexpression" rel="noopener ugc nofollow" target="_blank">FunctionExpression</a></code>或<code class="fe mm mn mo mp b"><a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#functiondeclaration" rel="noopener ugc nofollow" target="_blank">FunctionDeclaration</a></code>),如果我们这样做了，这将使它成为本地的或函数作用域。否则，如果我们到达<code class="fe mm mn mo mp b"><a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#programs" rel="noopener ugc nofollow" target="_blank">Program</a></code>节点，那么它就是全球范围的。让我们创建一个简单的存根，它接受一个标识符的祖先节点数组，并将该标识符的范围返回为- <code class="fe mm mn mo mp b">Program|FunctionExpression|FunctionDeclaration</code>节点。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h2 id="bfda" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">全球范围内的直接声明</h2><p id="6621" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要知道变量或函数声明是否直接在全局范围内完成，使用我们的图作为基础，很明显我们需要检测声明节点的直接父节点是否是<code class="fe mm mn mo mp b">Program</code>节点。为了做到这一点，我们将使用<code class="fe mm mn mo mp b"><a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#variabledeclarator" rel="noopener ugc nofollow" target="_blank">VariableDeclarator</a></code>和<code class="fe mm mn mo mp b">FunctionDeclaration</code>回调(因为它将给我们的标识符命名为<code class="fe mm mn mo mp b">node.id.name</code>)与祖先walker。我们将使用<code class="fe mm mn mo mp b">getScope</code>存根获取节点的范围，并将范围节点类型与<code class="fe mm mn mo mp b">Program</code>进行比较，如果是，我们将其推送到<code class="fe mm mn mo mp b">globalDeclarations</code>列表。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="873e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当我们执行上面的代码(用我们的<code class="fe mm mn mo mp b"><a class="ae lo" href="https://gist.github.com/divyamamgai/93c1b55e7c38faa6f28e10df555da862" rel="noopener ugc nofollow" target="_blank">sample.js</a></code>)时，我们期望输出是<code class="fe mm mn mo mp b">a</code>和<code class="fe mm mn mo mp b">f</code>。</p><h2 id="a4fc" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">全局范围内的间接声明</h2><p id="57b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">标识符可以在全局范围内间接声明，甚至可以从功能块中声明。我们将专注于两种可以实现的方法-</p><ol class=""><li id="57d4" class="md me iq kn b ko lj ks lk kw mf la mg le mh li mi mj mk ml bi translated">在<code class="fe mm mn mo mp b">window</code>对象中创建标识符的属性。</li><li id="a3b1" class="md me iq kn b ko mq ks mr kw ms la mt le mu li mi mj mk ml bi translated">在声明(或分配)标识符时省略<code class="fe mm mn mo mp b">var</code>关键字。</li></ol><p id="4ab2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了检测上述两种情况，我们将使用<code class="fe mm mn mo mp b"><a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#assignmentexpression" rel="noopener ugc nofollow" target="_blank">AssignmentExpression</a></code>节点，因为在这两种情况下都执行赋值。<code class="fe mm mn mo mp b">AssignmentExpression</code>节点有两个子节点- <code class="fe mm mn mo mp b">left</code>和<code class="fe mm mn mo mp b">right</code>。</p><h2 id="2d02" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">案例1</h2><p id="b530" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于案例#1，我们必须检查<code class="fe mm mn mo mp b">AssignmentExpression</code>的<code class="fe mm mn mo mp b">left</code>节点是否是<code class="fe mm mn mo mp b">window</code>对象的<code class="fe mm mn mo mp b"><a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#memberexpression" rel="noopener ugc nofollow" target="_blank">MemberExpression</a></code>。一个<code class="fe mm mn mo mp b">MemberExpression</code>访问一个对象的成员或属性(例如<code class="fe mm mn mo mp b">window.location</code>)。因此，在<code class="fe mm mn mo mp b">AssignmentExpression</code>的上下文中，我们正在访问<code class="fe mm mn mo mp b">window</code>对象的指定键，并为其赋值。</p><p id="d8b3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在我们继续之前，让我们编写一个简单的实用程序<code class="fe mm mn mo mp b">getName()</code>来从<code class="fe mm mn mo mp b">MemberExpression</code>节点获取一个可读的名称。在一个<code class="fe mm mn mo mp b">MemberExpression</code>节点中，我们有两个属性- <code class="fe mm mn mo mp b">object</code>和<code class="fe mm mn mo mp b">property</code>。<code class="fe mm mn mo mp b">object</code>将是一个<code class="fe mm mn mo mp b"><a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#identifier" rel="noopener ugc nofollow" target="_blank">Identifier</a></code>，而<code class="fe mm mn mo mp b">property</code>将是<code class="fe mm mn mo mp b">Identifier|MemberExpression</code>，因此我们将需要递归调用该实用程序，直到我们到达一个<code class="fe mm mn mo mp b">Identifier</code>节点，其名称可以使用<code class="fe mm mn mo mp b">name</code>属性来检索。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="56e0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们必须使用祖先步行者的<code class="fe mm mn mo mp b">AssignmentExpression</code>回调。调用我们的实用程序<code class="fe mm mn mo mp b">getName(node.left)</code>来获取名称，检查左侧节点的类型是否为<code class="fe mm mn mo mp b">MemberExpression</code>，名称的格式是否为- <code class="fe mm mn mo mp b">window.identifier</code>。如果是，那么<code class="fe mm mn mo mp b">identifier</code>就是一个全局变量。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="38f4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当我们执行上面的代码(用我们的<code class="fe mm mn mo mp b"><a class="ae lo" href="https://gist.github.com/divyamamgai/93c1b55e7c38faa6f28e10df555da862" rel="noopener ugc nofollow" target="_blank">sample.js</a></code>)时，我们期望输出是<code class="fe mm mn mo mp b">e</code>。</p><h2 id="deb7" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">案例2</h2><p id="82aa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于第二种情况，情况会有点复杂。检测关键字<code class="fe mm mn mo mp b">var</code>是否被省略的一个简单方法如下。</p><ol class=""><li id="64a6" class="md me iq kn b ko lj ks lk kw mf la mg le mh li mi mj mk ml bi translated">捕获给定代码片段中的所有声明。</li><li id="e8f2" class="md me iq kn b ko mq ks mr kw ms la mt le mu li mi mj mk ml bi translated">捕获给定代码片段中对非函数参数标识符的所有赋值。</li><li id="991a" class="md me iq kn b ko mq ks mr kw ms la mt le mu li mi mj mk ml bi translated">过滤掉所有具有相应声明的捕获的标识符分配。</li></ol><p id="9eae" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在前面的章节中，我们已经看到了如何捕获声明。让我们看看如何捕捉标识符的赋值，特别是非函数参数的。我们所说的“非功能参数”是什么意思？本质上，我们可以在不使用<code class="fe mm mn mo mp b">var</code>关键字的情况下为函数参数重新赋值。对于这些参数，没有对应的声明，因此我们必须事先排除它们。</p><p id="3774" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了检测是否正在对一个函数参数赋值，我们可以利用我们的<code class="fe mm mn mo mp b">getScope(node)</code>实用程序来获取正在赋值的函数的范围。为了保持复杂性最小，让我们考虑在嵌套函数中没有对父函数的参数进行赋值(为了检测这一点，我们可以转换我们的<code class="fe mm mn mo mp b">getScope(node)</code>实用程序来返回一个作用域数组，然后我们可以迭代所有嵌套的作用域来识别这样的函数参数)。我们只需要检查这个标识符是否属于<a class="ae lo" href="https://github.com/estree/estree/blob/master/es5.md#functions" rel="noopener ugc nofollow" target="_blank">函数</a>的<code class="fe mm mn mo mp b">params</code>数组。如果任务是在全局(或<code class="fe mm mn mo mp b">Program</code>)范围内完成的，我们可以直接将它包含在我们的任务列表中。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5957" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当我们执行上面的代码(用我们的<code class="fe mm mn mo mp b"><a class="ae lo" href="https://gist.github.com/divyamamgai/93c1b55e7c38faa6f28e10df555da862" rel="noopener ugc nofollow" target="_blank">sample.js</a></code>)时，我们期望输出是<code class="fe mm mn mo mp b">d</code>。</p><h2 id="ad64" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">拼凑起来</h2><p id="6a0d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将前几节中提到的所有内容放在一起，我们可以得到在给定的JavaScript代码片段中做出的所有全局声明(做了一些假设)。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9059" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当我们执行上面的代码(用我们的<code class="fe mm mn mo mp b"><a class="ae lo" href="https://gist.github.com/divyamamgai/93c1b55e7c38faa6f28e10df555da862" rel="noopener ugc nofollow" target="_blank">sample.js</a></code>)时，我们期望输出是<code class="fe mm mn mo mp b">a</code>、<code class="fe mm mn mo mp b">d</code>、<code class="fe mm mn mo mp b">e</code>和<code class="fe mm mn mo mp b">f</code>。</p><h2 id="e74f" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">我们解决方案的局限性</h2><p id="6181" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你是一个敏锐的观察者，并且一直在自己进行实验，你可能已经注意到我们当前的解决方案有一些明显的局限性。以下是其中的一些限制。</p><ol class=""><li id="1199" class="md me iq kn b ko lj ks lk kw mf la mg le mh li mi mj mk ml bi translated">未使用的函数中的声明也在考虑之列。</li><li id="cb40" class="md me iq kn b ko mq ks mr kw ms la mt le mu li mi mj mk ml bi translated">不考虑对<code class="fe mm mn mo mp b">window</code>对象的引用。</li><li id="490e" class="md me iq kn b ko mq ks mr kw ms la mt le mu li mi mj mk ml bi translated">父函数的函数参数不排除在赋值之外。</li></ol><p id="f1ab" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这些限制是可以解决的，但是对于AST的介绍以及可以用它做什么来说，解决方案会变得更加复杂。</p><h1 id="71d5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用范围信息</h1><p id="016a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用我们刚刚创建的方便的小插件，我们可以生成许多关于代码的有用见解和信息。</p><h2 id="4255" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">检测和消除循环依赖</h2><p id="65c5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">循环依赖对你的代码库没有好处。在这种情况下，两个模块相互依赖，因此你不能确定哪个模块应该先加载。使用Tarjan的强连通分量算法，您可以检测依赖图中的循环，然后努力消除它们。</p><h2 id="d53b" class="ng jo iq bd jp nh ni dn jt nj nk dp jx kw nl nm kb la nn no kf le np nq kj nr bi translated">模块的包含顺序</h2><p id="057e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的实用程序生成的模块依赖图上使用拓扑排序，我们可以得到理想情况下应该包含的模块的顺序。唯一的警告是拓扑排序只对有向非循环图有效，你需要从你的代码库中删除所有的循环依赖来获得这些信息。</p><h1 id="0279" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">抽象语法树的力量</h1><p id="0f65" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用ASTs可以实现很多目标。他们可以帮助你执行关键的代码分析，比如计算出你的代码库的圈复杂度T2，让它在T4的控制之下。ASTs的另一个有趣的用途是<a class="ae lo" href="https://www.toptal.com/javascript/write-code-to-rewrite-your-code" rel="noopener ugc nofollow" target="_blank">代码修改</a>，有了它，你基本上可以重新编写你的代码，以符合更新的<a class="ae lo" href="https://github.com/reactjs/react-codemod" rel="noopener ugc nofollow" target="_blank">框架</a>或特定语言的标准，而不需要任何开发人员的努力。您已经看到了本文中概述的一种用法，它有助于弄清楚前导入和导出时代的遗留JavaScript之间的依赖关系。在你的开发中，这项技术总有一个空间来简化这个过程，你只需要把它弄清楚。</p></div></div>    
</body>
</html>