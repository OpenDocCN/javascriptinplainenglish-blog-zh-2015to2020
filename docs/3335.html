<html>
<head>
<title>Which equals operator should I use in JavaScript comparisons? (== vs ===)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我应该在JavaScript比较中使用哪个等号运算符？(== vs ===)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/which-equals-operator-should-i-use-in-javascript-comparisons-vs-c3bc44960518?source=collection_archive---------5-----------------------#2020-09-20">https://javascript.plainenglish.io/which-equals-operator-should-i-use-in-javascript-comparisons-vs-c3bc44960518?source=collection_archive---------5-----------------------#2020-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="407c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在JavaScript == vs ===中比较东西，应该用哪个？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/856a06b703b3957c56337476061315f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDizzGT-6aXLjDefwW7mLA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@unitasphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Charles “Duck” Unitas</a> on <a class="ae kv" href="https://unsplash.com/s/photos/equals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6f17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe ls lt lu lv b">===</code>不等于<code class="fe ls lt lu lv b">==</code>那么它等于什么？？？</p><p id="3af9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">啊？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">huh? — Giphy</a></figcaption></figure><h2 id="7921" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">我们来分解一下</h2><p id="2b05" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，让我们定义两个运算符:</p><ul class=""><li id="dc30" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><code class="fe ls lt lu lv b">===</code>被称为严格的等式算子</li><li id="b0a4" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><code class="fe ls lt lu lv b">==</code>是抽象的等式运算符</li></ul><p id="cfb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们的行为是一样的，因为它们都返回一个布尔值，告诉我们两个表达式是否相等。</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="ef70" class="ly lz iq lv b gy no np l nq nr">A === B // returns true or false<br/>Y == Z  // also returns true or false</span></pre><p id="ee3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不同之处在于严格相等运算符(===)不进行类型转换(也称为类型强制)。</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="04a9" class="ly lz iq lv b gy no np l nq nr">1 == "1" // returns true</span><span id="6ca8" class="ly lz iq lv b gy ns np l nq nr">1 === "1" // returns false as the type is not equal</span></pre><p id="4f67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，要使两个表达式相等，它们必须都是等效值和相同的类型。</p><p id="ee0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nt">注意:同样适用于不等式检查，</em> <code class="fe ls lt lu lv b"><em class="nt">!=</em></code> <em class="nt">有严格的等式对应</em> <code class="fe ls lt lu lv b"><em class="nt">!==</em></code> <em class="nt">。</em></p><h2 id="41e0" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">让我们看一些例子</h2><p id="9c03" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这在现实中意味着什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/c7d274dea896fbc41a306271dedcb3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQE-5MNbSKp8a5rp5hMyTQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Examples of equality operator results, feel free to try them out in your browser console!</figcaption></figure><p id="7116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前四个例子看起来并没有太大的不同。在每一种情况下，我们都在比较相同类型的变量。</p><p id="098b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这满足了严格相等运算符(===)的条件，其中两个值相等且属于同一类型。</p><p id="70ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们开始比较不同类型的变量时，就变得有趣了。让我们以这个例子为例，比较0(一个数字)和false(一个布尔值):</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="77d7" class="ly lz iq lv b gy no np l nq nr">0 == false   // This will return true<br/>0 === false  // This will return false </span></pre><p id="b8c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<strong class="ky ir">抽象等式操作符(==) </strong>可以将两个变量转换成相同的类型，然后检查它们的相等性。</p><p id="f913" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为0等同于false，所以当转换为布尔值时，等式的两边是相等的。</p><p id="f9d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们的<strong class="ky ir">严格相等运算符(===) </strong>不进行类型转换，并确定Number不等于Boolean，因此等式的两边不相等。</p><p id="88f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不仅适用于布尔值，正如你在表格中看到的，<code class="fe ls lt lu lv b">100</code>(一个数字)和<code class="fe ls lt lu lv b">"100"</code>(一个字符串)被<strong class="ky ir">抽象相等运算符(==) </strong>归类为相等，而不是被<strong class="ky ir">严格相等运算符(===) </strong>归类为相等。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h2 id="ad11" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">那么我应该在代码中使用哪一个呢？？</h2><p id="7d39" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我看来，以及许多其他更有经验的人看来，最好还是使用<strong class="ky ir">严格的等式运算符(===)。</strong></p><p id="f1ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是如何工作的非常清楚，不需要你记住很多疯狂的边缘案例。</p><p id="f19a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象的等式操作符(==) 并不总是如你所愿，除非你完全理解所有可能的结果，并且有一些非常古怪的结果。</p><p id="95f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">引用《JavaScript:精彩部分》作者道格拉斯·克洛克福特的话:</p><blockquote class="oc od oe"><p id="04c6" class="kw kx nt ky b kz la jr lb lc ld ju le of lg lh li og lk ll lm oh lo lp lq lr ij bi translated">JavaScript有两组相等运算符:<code class="fe ls lt lu lv b">===</code>和<code class="fe ls lt lu lv b">!==</code>，以及它们邪恶的双胞胎<code class="fe ls lt lu lv b">==</code>和<code class="fe ls lt lu lv b">!=</code>。好的以你期望的方式工作。如果两个操作数类型相同，值相同，那么<code class="fe ls lt lu lv b">===</code>产生<code class="fe ls lt lu lv b">true</code>，而<code class="fe ls lt lu lv b">!==</code>产生<code class="fe ls lt lu lv b">false</code>。当操作数属于同一类型时，邪恶的双胞胎会做正确的事情，但是如果它们属于不同类型，他们会试图强制值。他们这样做的规则是复杂的，不可记忆的。</p></blockquote><p id="90f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果您发现自己处于对变量的类型相等性没有信心的情况下，那么它可以帮助您显式地首先强制/转换类型。</p><p id="7cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您正在检查两个数字是否相等，但其中一个可能是字符串或数字类型，请强制自己对其值进行编号:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="3a9d" class="ly lz iq lv b gy no np l nq nr">const someValue = VariableA === Number(VariableB)</span></pre><h2 id="4c78" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">参考资料:</h2><ul class=""><li id="aa6c" class="mw mx iq ky b kz mr lc ms lf oi lj oj ln ok lr nb nc nd ne bi translated">道格拉斯·克洛克福特的《JavaScript:精彩部分》</li><li id="c8bc" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kv" href="https://dorey.github.io/JavaScript-Equality-Table/" rel="noopener ugc nofollow" target="_blank"> JavaScript等式表</a>由<a class="ae kv" href="https://github.com/dorey" rel="noopener ugc nofollow" target="_blank"> dorey </a></li><li id="e08a" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kv" href="https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>一如既往…</li></ul><h2 id="c958" class="ly lz iq bd ma mb mc dn md me mf dp mg lf mh mi mj lj mk ml mm ln mn mo mp mq bi translated">其他文章:</h2><div class="ol om gp gr on oo"><a href="https://medium.com/javascript-in-plain-english/how-to-remove-an-element-from-an-array-in-javascript-54612785295e" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">如何在JavaScript中从数组中移除元素</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在JavaScript中从数组中快速移除元素的两种方法</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div><div class="ol om gp gr on oo"><a href="https://medium.com/@kitson.broadhurst/quickly-set-up-a-theme-in-material-ui-and-access-it-in-your-components-ba0565304887" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">在Material-UI中快速设置一个主题，并在组件中访问它</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">向您的React应用程序添加可定制的材质用户界面主题</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc kp oo"/></div></div></a></div></div></div>    
</body>
</html>