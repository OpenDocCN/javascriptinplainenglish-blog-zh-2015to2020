<html>
<head>
<title>Releasing PuxiJS 1.0.0-RC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发布PuxiJS 1.0.0-RC</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/releasing-puxijs-1-0-1210c88eb845?source=collection_archive---------4-----------------------#2020-03-23">https://javascript.plainenglish.io/releasing-puxijs-1-0-1210c88eb845?source=collection_archive---------4-----------------------#2020-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d176" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解官方PixiJS GUI库及其各种开源小部件和布局！—<a class="ae kl" href="https://pixijs.io/pixi-ui" rel="noopener ugc nofollow" target="_blank">https://pixijs.io/pixi-ui</a></p><p id="903d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PixiJS是一个快速、轻量级的网络2D渲染引擎。它是创建丰富的、交互式的、快速的内容的首选解决方案，而无需一头扎进WebGL API。然而，很长一段时间以来，它一直缺乏一个全面的GUI小部件解决方案，为您处理<em class="km">呈现</em>和<em class="km">交互</em>并公开一个基于事件的API。</p><p id="dc6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nicholai Mortenson建立了一个名为pixi-ui的库，它得到了PixiJS的官方支持。它的大部分用途是将它分支到现有的项目中，并将其转换成MVVM组件。然而，它从未发布到npm，并最终退出维护。这就是为什么我接手了这个项目，并把它重新命名为PuxiJS。我选择将其命名为Puxi是因为:I)这不会是一个插件，而是几个组件的monorepo，我认为它应该有自己的品牌名称，ii)这个词包含“UX/UI ”,同时明显与Pixi相似。</p><p id="2e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会在npm上发布PuxiJS，这样你也可以看看！：</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="47b5" class="kw kx iq ks b gy ky kz l la lb">npm install puxi.js</span></pre><p id="312a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PuxiJS的基本构件是“小部件”。小部件是一种UI控件，它可以:</p><ul class=""><li id="e621" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">给定一些约束条件，计算最佳宽度和高度。</li><li id="d173" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">布局并将其自身呈现在屏幕上的矩形内。</li><li id="6010" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">用填充在其内容后面显示背景。</li></ul><p id="0446" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lq lr ls ks b">PUXI.Widget</code>类提供了一个高级API来帮助您配置这些特性。</p><h1 id="8232" class="lt kx iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">场景图和舞台</h1><p id="bfbd" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">在PuxiJS应用程序中，有两个场景图——小部件图和显示对象图。一个<code class="fe lq lr ls ks b">PUXI.Stage</code>是小部件图的根元素，它可以作为子元素添加到PixiJS应用程序中的任何一个<code class="fe lq lr ls ks b">PIXI.Container</code>中。</p><p id="357c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">小部件层次结构中的任何全局阶段都存储在阶段中。这允许您创建多个GUI阶段，当您需要切换页面或显示新内容时，可以“交换”这些阶段。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="4e2b" class="kw kx iq ks b gy ky kz l la lb">/* Basic setup of a PuxiJS application*/</span><span id="45d4" class="kw kx iq ks b gy mv kz l la lb">// Create your PixiJS application.<br/>const app = new PIXI.Application({ /* ... */ });</span><span id="7613" class="kw kx iq ks b gy mv kz l la lb">// Create a stage that covers the whole canvas!<br/>const stage = new PUXI.Stage(app.view.width, app.view.height);</span><span id="f243" class="kw kx iq ks b gy mv kz l la lb">// Place a button widget on the top-left corner!<br/>stage.addChild(<br/>  new PUXI.Button({ text: "Hello World!" })<br/>    .setBackground(0x00FFFF)<br/>    .setPadding(8)<br/>)<br/></span><span id="91e1" class="kw kx iq ks b gy mv kz l la lb">// This is a bit confusing! app.stage is the PixiJS stage while<br/>// stage is the PuxiJS stage.</span><span id="fddd" class="kw kx iq ks b gy mv kz l la lb">app.stage.addChild(stage);</span></pre><p id="bdbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在内部，显示对象图不会在阶段结束。每个小部件都有多个<code class="fe lq lr ls ks b">PIXI.Container</code>对象。</p><ul class=""><li id="74c5" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe lq lr ls ks b">contentContainer</code>:这个容器包含了呈现小部件内容所需的所有显示对象，包括子对象。</li><li id="6360" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe lq lr ls ks b">insetContainer</code>:这是容纳任何填充内容的容器。</li></ul><p id="2925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个子部件被添加到父部件时，它的<code class="fe lq lr ls ks b">insetContainer</code>会被添加到父部件的<code class="fe lq lr ls ks b">contentContainer</code>中。</p><blockquote class="mw mx my"><p id="c673" class="jn jo km jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated">舞台不是一个小部件，它是一个<code class="fe lq lr ls ks b">PIXI.Container</code>；但是，它的子对象必须是小部件。然而，它共享了小部件的许多特征，如布局和背景。</p></blockquote><h1 id="4ec9" class="lt kx iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">布局</h1><p id="8979" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">PuxiJS最强大的特点是它的布局系统。布局系统很大程度上是受Android的<code class="fe lq lr ls ks b">ViewGroups</code>集合的启发。</p><h2 id="e347" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">布局经理</h2><p id="ea96" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">布局管理器负责定位和调整小部件的子部件。一个<code class="fe lq lr ls ks b">PUXI.WidgetGroup</code>可以附加你想要的布局管理器。配置一个特定子节点的布局，您可以使用<code class="fe lq lr ls ks b">Widget#setLayoutOptions</code>指定布局选项。每种布局类型都有自己的布局选项类。</p><blockquote class="mw mx my"><p id="eeec" class="jn jo km jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated">您可以通过创建自己的布局管理器来自定义小部件组的子部件的布局方式。或者，您可以使用PuxiJS提供的布局之一— <code class="fe lq lr ls ks b">FastLayout</code>、<code class="fe lq lr ls ks b">AnchorLayout</code>和<code class="fe lq lr ls ks b">BorderLayout</code>。随着PuxiJS的增长，更多的布局将被添加到这个列表中！</p></blockquote><h2 id="7fb9" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">布局选项</h2><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="2e12" class="kw kx iq ks b gy ky kz l la lb">const widget = new PUXI.Text("Widget").setBackground(0xfefefe);</span><span id="6fd4" class="kw kx iq ks b gy mv kz l la lb">widget.setLayoutOptions(new PUXI.LayoutOptions({<br/>  width: PUXI.LayoutOptions.WRAP_CONTENT, // natural width<br/>  height: PUXI.LayoutOptions.FILL_PARENT // height = stage's height<br/>});</span><span id="eb9b" class="kw kx iq ks b gy mv kz l la lb">const widget2 = new PUXI.Text("Widget2").setBackground(0xffeeaa);</span><span id="4373" class="kw kx iq ks b gy mv kz l la lb">widget2.setLayoutOptions(new PUXI.LayoutOptions({<br/>  width: .5, // 50% width<br/>  height: 42 // 42px height<br/>}); </span><span id="4bdb" class="kw kx iq ks b gy mv kz l la lb">stage.addChild(widget, widget2);</span></pre><p id="a196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基类<code class="fe lq lr ls ks b">PUXI.LayoutOptions</code>允许您指定小部件的宽度和高度。宽度/高度可以设置为:</p><ul class=""><li id="92cc" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe lq lr ls ks b">WRAP_CONTENT</code>:使用宽度的自然宽度/高度。</li><li id="c34b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe lq lr ls ks b">FILL_PARENT</code>:填充母体的宽度/高度。</li><li id="9f7d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">固定值，例如96:宽度/高度可以设置为固定的像素值。这将强制小部件以该宽度/高度呈现自己。</li><li id="0b60" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">百分比值，例如. 5:如果在布局选项中传递的值小于1，则它被解释为父项的宽度/高度的百分比。</li></ul><h2 id="ebec" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">舞台和快速布局</h2><p id="dd88" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">舞台采用快速布局。您还可以在任何小部件组上使用快速布局。</p><p id="0a5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速布局允许您指定小部件的<em class="km"> (x，y) </em>位置和您想要的宽度/高度。</p><figure class="kn ko kp kq gt nn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="ac33" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">AnchorLayout示例</h2><p id="8b4c" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">Anchor layout允许您将每个子部件的边缘锚定到相对于父部件的insets(或其<code class="fe lq lr ls ks b">contentContainer</code>的边缘)的特定偏移量。这些偏移也可以是父对象宽度或高度的“百分比”。要强制小部件填充锚定区域，请将其宽度/高度设置为零。</p><p id="fdbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子使用anchor-layout在画布的左边和右边放置了两个按钮。左按钮的宽度填充其锚定区域，而右按钮的高度填充其锚定区域。</p><figure class="kn ko kp kq gt nn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="a646" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">测量和布局通道</h2><p id="d4fd" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">PuxiJS的优势在于<em class="km">自适应</em>。它应该适用于移动屏幕、平板电脑和台式机。测量和布局通道是这种能力的基础。</p><p id="f394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测量过程中，一个小部件在一组约束条件下计算它的最佳宽度和高度。如果小部件附有布局管理器，布局管理器将测量子部件。</p><p id="0061" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在布局过程中，布局管理器根据测量的宽度和高度定位子部件。使用在每个子节点上设置的布局选项来配置该过程。</p><h1 id="efac" class="lt kx iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">高级小部件</h1><h2 id="755a" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">ScrollWidget</h2><p id="bb8b" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">scroll小部件显示其部分内容，并允许用户滚动查看其内容的不同部分。它自动创建滚动条，处理拖动、鼠标滚动和放松滚动。</p><figure class="kn ko kp kq gt nn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/e1deffa95f57b010038797e9d16da19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFWpVZbfzgbGUHtuk6taPw.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk">PuxiJS Example Expo</figcaption></figure><h2 id="8d75" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">滑块</h2><p id="a02d" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">滑块允许用户通过拖动滑块的手柄来设置最小值和最大值之间的值。</p><h2 id="e1b3" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">文本输入</h2><p id="aa9c" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">文本输入允许用户键入文本。当文本溢出时，它还具有滚动功能。</p><h1 id="7d9e" class="lt kx iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">小部件的其他功能</h1><h2 id="8712" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">背景</h2><p id="1636" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">您可以将小部件的背景设置为任何颜色或像素显示对象。例如，如果要使用圆角矩形:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="aad8" class="kw kx iq ks b gy ky kz l la lb">widget.setBackground(<br/>  new PIXI.Graphics()<br/>    .beginFill(0xff)<br/>    .drawRoundedRect(0, 0, 32, 32, /* radius: */ 8)<br/>    .endFill()<br/>);</span></pre><h2 id="0b75" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">填料</h2><p id="e87a" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">您可以在小部件的内容周围添加填充。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="b503" class="kw kx iq ks b gy ky kz l la lb">widget.setPadding(/* horizontal: */ 8, /* vertical: */ 12);</span></pre><h2 id="c71d" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">立面图(实验)</h2><p id="2c8c" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">在一个小部件上使用一个仰角将会在它的背景上添加一个投影。</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="c722" class="kw kx iq ks b gy ky kz l la lb">widget.setElevation(4);// adds a drop-shadow with distance=4</span></pre><figure class="kn ko kp kq gt nn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/c34ce853bd2c6d1876ee5ee62827961a.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*M1V8esjkoFMqwxr0RWDYTg.png"/></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk">Button with a drop-shadow &amp; rounded rect background!</figcaption></figure><h1 id="fdec" class="lt kx iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">进一步的工作</h1><h2 id="178b" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">动态文本</h2><p id="1c7b" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">pixi-ui的原作者创造了一个叫“动态文本”的东西。这种类型的文本将在纹理中缓存文本的每个字母，并使用它进行绘制。PuxiJS将在1.0.0之后发布该特性。</p><h2 id="e8f0" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">更多布局和小部件</h2><p id="d7ce" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">更高级的布局仍然需要推出——列表布局、网格布局和一些基于约束的布局。小部件也是如此——幻灯片小部件、图标和图像按钮、下拉菜单等。</p><h2 id="dd66" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">造型支架</h2><p id="4586" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">在未来，我想支持一个特性，你可以使用类似react native的<code class="fe lq lr ls ks b">StyleSheet</code>来设计你的组件。</p><h2 id="365d" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">响应背景</h2><p id="89d6" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">现在，小部件的背景只是一个静态的显示对象。如果背景能够响应像悬停、点击、拖动和聚焦这样的事件，那不是很好吗？</p><h2 id="c6ad" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">反应式数据模型</h2><p id="2dc8" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">如果你是一名前端开发人员，在为WebGL应用程序开发GUI时，你会错过React的范例。我将致力于弥补PixiJS中的差距！</p><h2 id="29ed" class="kw kx iq bd lu nc nd dn ly ne nf dp mc jy ng nh mg kc ni nj mk kg nk nl mo nm bi translated">智能缓存</h2><p id="a1d5" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">小部件大多是静态的。它们很容易被缓存，只有在发生变化时才被渲染。</p><h1 id="770b" class="lt kx iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">贡献</h1><p id="2c21" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">PuxiJS是开源的，将感谢贡献:<a class="ae kl" href="https://github.com/pixijs/pixi-ui" rel="noopener ugc nofollow" target="_blank">https://github.com/pixijs/pixi-ui</a>。我们还有很多事情要处理。</p><p id="f5e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个项目是一个monorepo，构建系统类似于PixiJS，用Typescript编写。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="1000" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿，伙计们，我是Shu Kant Pal——pix ijs的核心维护者和Silcos内核的创建者。喜欢我的内容？，跟我来这里:</p><div class="oj ok gp gr ol om"><a href="https://twitter.com/ShukantP" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">舒坎特·库马尔·帕尔</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">Shukant Kumar Pal (@ShukantP)的最新推文。PixiJS项目成员，pixi-UI/PuxiJS的维护者。自我…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">twitter.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa nv om"/></div></div></a></div></div></div>    
</body>
</html>