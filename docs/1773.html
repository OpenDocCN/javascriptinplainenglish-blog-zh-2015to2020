<html>
<head>
<title>Stop Pretending You Don't Need To Learn Dynamic Programming!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">别再假装不需要学习动态编程了！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-dynamic-programming-in-javascript-e80fbdb29b7a?source=collection_archive---------1-----------------------#2020-04-21">https://javascript.plainenglish.io/learn-dynamic-programming-in-javascript-e80fbdb29b7a?source=collection_archive---------1-----------------------#2020-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/383325b5d9bf689fd5626ea2f2d13c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*48dheex1ta8s12Ya"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="62b8" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">不要担心；这并不像听起来那么难！</h2></div><p id="fa19" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">啊，动态编程。程序员讨厌他。撇开所有的笑话不谈，许多编码员——无论是自学的还是其他的——从来没有学习过这种算法方法。</p><p id="2f69" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我知道，这听起来有点吓人。但是，我记得我第一次听到这个词时的反应。</p><p id="4d53" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"><em class="lr"/></strong><em class="lr"/>我第一个想到的是一个疯狂的wiz的形象——kid编写一些可以实时修改自己的疯狂算法。</p><p id="9308" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是这个术语不能准确地描述这种方法。你还会看到它被记忆化，记忆化更准确，但没有前者那么容易记住。</p><p id="9a8a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们开始吧。</p><h1 id="19c8" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">教科书定义(来自维基百科)</h1><p id="c837" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jh">动态编程</strong> </a>既是一种<a class="ae jd" href="https://en.wikipedia.org/wiki/Mathematical_optimization" rel="noopener ugc nofollow" target="_blank">数学优化</a>方法，也是一种计算机编程方法。这项技术是由理查德·贝尔曼在20世纪50年代开发的，已经在从航空航天工程到经济学的众多领域得到了应用。</p><h1 id="52cd" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">现在用简单的英语</h1><p id="43bc" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">通过将计算结果存储在内存中，并在需要时重用它们以节省时间，算法方法被用来优化一个简单的解决方案(通常是递归的)。</p><h1 id="54db" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">但是怎么做呢？</h1><p id="0f68" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">不是所有的问题都可以用动态编程来解决，但是所有的问题都有相同的条件。</p><ul class=""><li id="90f7" class="mp mq jg kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">这个问题是递归的，因此可以分解成子问题</li><li id="dd70" class="mp mq jg kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">子问题通常会在某一点上重叠。</li></ul><h1 id="ada8" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">在某一点上重叠？</h1><p id="53ca" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当我说两个子问题重叠时，程序将不得不解决同一个问题至少不止一次。</p><p id="7c2b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">动态规划的基础是每个子问题只计算一次，并保存结果以备以后需要再次计算时使用。</p><p id="c5f5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着不用重复计算同一个子问题——通常是数千次——我们只需做一次，将它存储在内存中，并在需要时重用它。</p><h1 id="7017" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">通过实例学习</h1><p id="b706" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">好吧，你可能理解这个理论，但是我们如何实现它呢？首先，让我们分解一个著名的例子来理解它是如何工作的以及为什么工作。</p><h2 id="877c" class="nd lt jg bd lu ne nf dn ly ng nh dp mc le ni nj me li nk nl mg lm nm nn mi no bi translated">斐波那契数列</h2><p id="781c" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">黄金比例，这个数列是由著名的意大利数学家列奥纳多·斐波那契发现的。</p><p id="7f98" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺序是这样的。</p><blockquote class="np"><p id="9601" class="nq nr jg bd ns nt nu nv nw nx ny lq dk">0 — 1 — 1 — 2 — 3 — 5 — 8 — 13</p></blockquote><p id="9226" class="pw-post-body-paragraph kv kw jg kx b ky nz kh la lb oa kk ld le ob lg lh li oc lk ll lm od lo lp lq ij bi translated">你能找到模式吗？每个数字都是通过将序列中的前两个数字相加来计算的。比如给定<strong class="kx jh"> fib(0) = 0 </strong>，<strong class="kx jh"> fib(1) = 1 </strong>，那么我们可以从<strong class="kx jh"> fib(2) </strong>开始，发现下面的公式求解。</p><blockquote class="np"><p id="77ae" class="nq nr jg bd ns nt nu nv nw nx ny lq dk translated">光纤(n) =光纤(n-1) +光纤(n-2)</p></blockquote><p id="601e" class="pw-post-body-paragraph kv kw jg kx b ky nz kh la lb oa kk ld le ob lg lh li oc lk ll lm od lo lp lq ij bi translated">在事先不知道的情况下，如何找到前两个值？</p><h1 id="7531" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated"><strong class="ak">天真的方法(递归)</strong></h1><p id="fbbe" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你了解递归，它可以非常优雅和直接地解决这个问题。像这样</p><figure class="oe of og oh gt is"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="8fc5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归将问题分解成更小的子问题，直到达到一个基本情况(当n = 0时)，然后重新构造解决方案。</p><p id="2d97" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过查看，我们可以理解，要找到序列中的第10个数字，我们需要找到它之前的两个值。</p><p id="a981" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我是一个视觉学习者，所以我会把它画出来。之后就好理解多了。相信我！</p><h1 id="0e41" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">递归分解</h1><figure class="oe of og oh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/3c93c60fc7c283cc01e7891efc5d24f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-gJWPwk6qIpq6gR65NmzA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Graphics by yours indeed.</figcaption></figure><p id="7e3a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到，通过递归地分解问题，我们向下到了基础案例<strong class="kx jh"> 1 </strong>或<strong class="kx jh"> 0 </strong></p><p id="d46f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们到达案例，调用栈将通过添加我们沿着树向下进行的每个调用来负责重建解决方案。</p><h1 id="a8c2" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">仔细看看</h1><p id="7130" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们还可以非常清楚地看到计算重叠的地方。在这种情况下，<strong class="kx jh"> fib(2) </strong>计算<strong class="kx jh">两次</strong>，而<strong class="kx jh"> fib(1) </strong>计算<strong class="kx jh">三次</strong>。对于序列中的小数字来说，这几乎不是问题，但是随着n的增加，每次计算都要重复更多次。</p><p id="aa0d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那需要多少努力？</p><p id="589f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们必须进行八次计算才能找到序列中的第四个数字。</p><p id="ce70" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这转化为<strong class="kx jh"> 2^n </strong>，因为我们的算法每次分裂都会产生两个子问题。</p><p id="9ddb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">八个<strong class="kx jh">操作</strong>现在看起来可能没问题，但是寻找<strong class="kx jh"> fib(15) </strong>呢？</p><p id="fbd0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2 ⁵= <strong class="kx jh"> 32768 </strong>操作！</p><p id="57c6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个指数函数，它会随着值的增加而急剧增长。</p><figure class="oe of og oh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/4c5c955951954d8a1038778a70f5f53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcoiuEhoDnGkk6HHWdB2pQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Google 2^x to get this graph</figcaption></figure><p id="9322" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望你现在能理解随着T21的增加，这个算法的伸缩性有多差。</p><p id="0945" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使最快的计算机也难以计算fib(100)</p><p id="b189" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果我们只计算每个值一次呢？这个问题变成了一个线性问题。为了找到fib(100 ),我们只需要100次运算，因为我们添加了O(n)空间以避免重复计算。</p><p id="b01c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嘣！这就是你的动态编程！</p><h1 id="1140" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">来实现它</h1><p id="284b" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一旦你知道需要做什么，这个问题就简单了。</p><p id="6529" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要采用线性方法——一个循环来实现这一点。然后我们必须建立从树叶到根(N)的解决方案。</p><h1 id="cae4" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">自下而上的方法</h1><p id="8317" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">与其递归地分解问题，我们可以从基础案例开始，然后把它建立起来。</p><figure class="oe of og oh gt is"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2902" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们初始化一个数组来存储我们的值。我们已经知道了<strong class="kx jh"> fib(0)和fib(1) </strong>的值，所以我们将其初始化为<strong class="kx jh"> [0，1]。</strong></p><p id="5e93" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们从2开始循环，一直到到达<strong class="kx jh"> n. </strong></p><p id="a5f4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了计算当前值，我们使用从序列中导出的公式。因为i = 2，所以结果[2] =结果[1] +结果[0]。</p><p id="7493" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们前进时，如果我们只需要数组中前两个值，而不是像以前那样计算重叠的值。</p><h1 id="5ba0" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">奖金</h1><p id="d935" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你没有注意到，由于我们的公式只需要最后两个数字，我们可以跟踪它们，而不是从0到<strong class="kx jh"> n </strong>的整个序列。</p><p id="867b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只需将它们存储在两个变量中，并随着循环的进行进行更新。</p><figure class="oe of og oh gt is"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="0e82" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就速度而言，我们的解决方案仍然是O(n)，但是我们能够将内存使用减少到O(1)，(常数)，因为我们总是只使用两个变量。</p><h1 id="ad0e" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="311a" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这并不难，对吧？</p><p id="2663" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们认识到问题可以动态解决，那就轻而易举了。</p><p id="27ed" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">困难的部分是首先识别模式。</p><p id="0193" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么你应该总是尝试用简单的方法解决问题——在这个例子中是递归的——并从那里开始。</p><blockquote class="om on oo"><p id="4f85" class="kv kw lr kx b ky kz kh la lb lc kk ld op lf lg lh oq lj lk ll or ln lo lp lq ij bi translated">这些问题都可以在面试问题中问到，所以知道如何解决总是加分的。</p></blockquote><h2 id="8d08" class="nd lt jg bd lu ne nf dn ly ng nh dp mc le ni nj me li nk nl mg lm nm nn mi no bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="cb54" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们已经推出了三种新的出版物！请关注我们的最新出版物:<a class="ae jd" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kx jh"> AI in Plain English </strong> </a>，<a class="ae jd" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kx jh">UX in Plain English</strong></a>，<a class="ae jd" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kx jh">Python in Plain English</strong></a><strong class="kx jh"/>——谢谢，继续学习！</p><p id="df77" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也一直有兴趣帮助推广高质量的内容。因此，如果你有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jd" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx jh">submissions @ plain English . io</strong></a><strong class="kx jh"/>，并附上你的Medium用户名，我们会将你添加为作者。此外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>