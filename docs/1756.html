<html>
<head>
<title>Nullish Coalescing Operator Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了零化合并运算符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nullish-coalescing-operator-explained-8b1e0dc6c24c?source=collection_archive---------6-----------------------#2020-04-19">https://javascript.plainenglish.io/nullish-coalescing-operator-explained-8b1e0dc6c24c?source=collection_archive---------6-----------------------#2020-04-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b6b94ed37627837bc7e1778ee7af7bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRz4IDa0QqkrwPt2hPhXdA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://www.pexels.com/@myburgh?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Myburgh Roux</a> from <a class="ae jz" href="https://www.pexels.com/photo/codes-computer-monitor-programming-1102797/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="d3af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Nullish合并运算符是javascript中的一个新运算符，实际上是ES2020规范。它是一个短路操作符，很像<code class="fe ky kz la lb b">&amp;&amp;</code>和<code class="fe ky kz la lb b">||</code>操作符。</p><h1 id="931a" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">这是什么？</h1><p id="a2a4" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">Nullish合并运算符(<code class="fe ky kz la lb b">??</code>)是一个逻辑运算符，当LHS操作数为<code class="fe ky kz la lb b">nullish</code>(空或未定义)时，返回其RHS操作数，否则返回其LHS操作数。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="639d" class="mn ld in lb b gy mo mp l mq mr">const name = <em class="ms">null</em> ?? ‘John Doe’<br/><em class="ms">// output: John Doe</em></span></pre><h1 id="78c8" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我们为什么需要它？</h1><p id="be66" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在零化合并运算符之前，逻辑OR ( <code class="fe ky kz la lb b">||</code>)运算符用于检查零化值。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="f911" class="mn ld in lb b gy mo mp l mq mr">const name = <em class="ms">null</em> || 'John Doe'</span><span id="ac24" class="mn ld in lb b gy mt mp l mq mr"><em class="ms">// output: John Doe</em></span></pre><p id="52dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但问题是<code class="fe ky kz la lb b">||</code>检查为<code class="fe ky kz la lb b">truthy</code>还是<code class="fe ky kz la lb b">falsy</code>值。也就是说，当LHS操作数为<code class="fe ky kz la lb b">falsy</code> (null，undefined，false，0，''，NaN)时，它返回RHS操作数，否则，它返回LHS操作数。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="ad88" class="mn ld in lb b gy mo mp l mq mr">const name = '' || 'John Doe'</span><span id="c2f6" class="mn ld in lb b gy mt mp l mq mr"><em class="ms">// output: John Doe</em></span><span id="f95f" class="mn ld in lb b gy mt mp l mq mr">const name = '' ?? 'John Doe'</span><span id="431c" class="mn ld in lb b gy mt mp l mq mr"><em class="ms">// output: ''</em></span></pre><p id="db94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了更好地理解这个问题，请考虑下面的代码示例。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="c21b" class="mn ld in lb b gy mo mp l mq mr">function joinArray(<em class="ms">array</em>, <em class="ms">delimiter</em>) {</span><span id="70df" class="mn ld in lb b gy mt mp l mq mr">  delimiter = delimiter || ',';</span><span id="b9e2" class="mn ld in lb b gy mt mp l mq mr">  return arr.join(delimiter);</span><span id="09f7" class="mn ld in lb b gy mt mp l mq mr">}</span></pre><p id="93de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本例中，<code class="fe ky kz la lb b">delimiter</code>参数是可选的。如果没有为分隔符参数传递值，则<code class="fe ky kz la lb b">,</code>将是默认值。但是这段代码有一个bug。如果我们想要在没有任何分隔符的情况下加入数组，也就是使用<code class="fe ky kz la lb b">''</code>作为参数，会发生什么？</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="bd3f" class="mn ld in lb b gy mo mp l mq mr">let joined = joinArray(['Find', 'the', 'bug'], '');</span><span id="04dd" class="mn ld in lb b gy mt mp l mq mr"><em class="ms">// expected output: Findthebug</em></span><span id="41cf" class="mn ld in lb b gy mt mp l mq mr"><em class="ms">// actual output: Find,the,bug</em></span></pre><p id="d335" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，预期的输出是‘findtebug’，但实际的输出是Find，the，bug’。这是因为<code class="fe ky kz la lb b">||</code>操作符只检查操作数是<code class="fe ky kz la lb b">truthy</code>还是<code class="fe ky kz la lb b">falsy</code>，空字符串(<code class="fe ky kz la lb b">''</code>)的计算结果为假。因此，返回RHS操作数，在本例中为逗号(<code class="fe ky kz la lb b">,</code>)。</p><p id="0dfd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过用<code class="fe ky kz la lb b">??</code>替换<code class="fe ky kz la lb b">||</code>来轻松修复这个bug。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="6a25" class="mn ld in lb b gy mo mp l mq mr">function joinArray(<em class="ms">array</em>, <em class="ms">delimiter</em>) {</span><span id="f4aa" class="mn ld in lb b gy mt mp l mq mr">  delimiter = delimiter ?? ',';</span><span id="5495" class="mn ld in lb b gy mt mp l mq mr">  return arr.join(delimiter);</span><span id="5648" class="mn ld in lb b gy mt mp l mq mr">}</span></pre><p id="0bab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们得到了正确的结果。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="7170" class="mn ld in lb b gy mo mp l mq mr">let joined = joinArray(['Find', 'the', 'bug'], '');</span><span id="6e37" class="mn ld in lb b gy mt mp l mq mr"><em class="ms">// output: Findthebug</em></span></pre><h1 id="1750" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">关于用AND或or运算符链接的注释</h1><p id="6df1" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">不能用<code class="fe ky kz la lb b">??</code>直接链接AND ( <code class="fe ky kz la lb b">&amp;&amp;</code>)和OR ( <code class="fe ky kz la lb b">||</code>)运算符。将这两者结合起来会引发语法错误。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="16e4" class="mn ld in lb b gy mo mp l mq mr">const name = <em class="ms">null</em> || <em class="ms">undefined</em> ?? 'John Doe'</span><span id="2574" class="mn ld in lb b gy mt mp l mq mr"><em class="ms">//Uncaught SyntaxError: Unexpected token '??</em></span></pre><p id="c8ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您需要组合它们，那么您必须用括号将其中一个操作符组括起来。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="56eb" class="mn ld in lb b gy mo mp l mq mr">const name = (<em class="ms">null</em> || <em class="ms">undefined</em>) ?? 'John Doe'</span></pre><p id="71f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将消除歧义，任何阅读代码的人都可以立即理解它做什么。编码快乐！</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="65b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ms">原载于</em><a class="ae jz" href="https://jinoantony.com/blog/nullish-coalescing-operator-explained" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://jinoantony.com</em></a><em class="ms">。</em></p><h2 id="fb0b" class="mn ld in bd le nb nc dn li nd ne dp lm kl nf ng lq kp nh ni lu kt nj nk ly nl bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="f8d9" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae jz" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kc io">AI in Plain English</strong></a><a class="ae jz" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kc io">UX in Plain English</strong></a><a class="ae jz" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kc io">Python in Plain English</strong></a><strong class="kc io"/>——谢谢，继续学习！</p><p id="01ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jz" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">submissions @ plain English . io</strong></a><strong class="kc io"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>