# 关于虚拟世界死亡的报道被大大夸大了

> 原文：<https://javascript.plainenglish.io/reports-of-the-virtual-doms-death-are-greatly-exaggerated-2206d00beead?source=collection_archive---------1----------------------->

## …揭穿其他现代 Web 开发神话

![](img/d6b02a4178b96d1489f2db5d54269e7c.png)

我最近读了几篇文章，这些文章提出了一些相当离谱的主张，其依据只不过是一些会议讨论的轶事。一部分是一年中的时间。随着我们从一年走向下一年，这是一个展望未来的好时机。我甚至不认为所有的情绪都是错误的，只是缺乏证据和理由。我们也许有一天会到达那里，但那一天不是今天。

因此，让我们深入探讨一下过去一年中流传的几个问题。

# 误解 1: Web 组件取代了框架/库

Web 组件是一系列技术，通过使用 HTML 元素，使 HTML、CSS 和 JavaScript 以可重用的方式模块化。这些技术为 DOM 添加了以前没有的特性，以帮助实现这个目标，包括模板、CSS 封装、元素生命周期挂钩(包括属性监视)和子元素槽。从表面上看，这些是 UI 框架实现的许多相同的特性，最终你会得到组件。所以它们一定是等价的，对吗？

不，一点也不。一个是一组解决一般问题的原生工具，另一个是一组自以为是的特性，以提高应用程序的生产效率。现在这种困惑是可以理解的。有时，我甚至不确定那些参与撰写提案的人是否清楚界限在哪里。一些提议看起来像是下一个框架的规范。但在 6 年里，我一直在关注这一点，供应商之间的共识率很明显，这里的功能集越基本，就越有可能向前发展。对于他们应该扮演什么角色仍有许多争论。像支持原生内置(扩展现有元素的能力)没有完全支持。仅这一点就表明，一些政党并不认为这些适合设计系统。

那么它们有什么用呢？微前端或插件包装似乎是可行的。您还可以发明自己的可访问性、本地化和表单处理功能，并设计自己的元素。有一点很清楚，它们与 React 组件不同。它们模块化，但与变更传播或高效呈现没有关系。它们的界限更重，代表了通过它们自己的生命周期的封装隔离。足以让每一个都拥有自己的 UI 库。有些确实如此。事实上，几乎所有产生 Web 组件的库都是这种性质的库。你不能避免学习一个框架/库。我的意思是你可以使用普通的 DOM APIs，但是你现在也可以不使用 Web 组件。不要上当。你要么使用他们与你已经熟悉的库，如角元素，或 Svelte 或 Vue 导出自定义元素，或者你正在学习一个新的库，如聚合物，模板，异端或 LitElement。

什么都没有改变。使用它们并不是突然支持开放网络。事实上，最自由的方法可能是像 [SkateJS](https://github.com/skatejs/skatejs) 这样的东西，它并不试图附带一个框架，而是让你使用任何现有的框架。该库的存在只是为了使 API 表面均匀化，并允许您以自己想要的方式工作。但是你猜怎么着？您仍在使用框架/库。

# 神话 2:消失的框架

我喜欢这个。这必须是自虚拟 DOM 以来网络前端最好的营销短语，并帮助苗条像风暴一样到来。这完全是夸张。总有一个运行时。它可以很小，但必须是能引发变化的东西。所有的库都是普通的 JS、HTML 和 CSS。这里真正的英雄是树摇动，静态分析导入语句以消除死代码的过程。基本上，从不导入的代码不需要包含在最终的包中。使用编译，你所要做的就是寻找标识符，然后添加导入语句，树抖动会做得最好。不难想象这个过程。编译器遇到了像`#each`这样的助手，并决定包含列表映射代码。不要相信我在你编译的细长代码中寻找`import`语句。他们在那里。

现在，通过编译，我们可以减少捆绑运行时代码的数量，因为您可以硬编码模板，本质上是解开循环。但是一旦遇到常见的模式，实际上抽象的规模效率更高，在你知道之前，运行时间更短。现在，任何足够简单的库与树抖动相结合都可以产生相同的结果，尽管可能不那么巧妙。反应式库往往更小，但甚至有虚拟 DOM 库甚至可以产生等效或更小的包(见 [HyperApp](https://github.com/jorgebucaran/hyperapp) )。也许我们应该考虑专注于让有价值的东西消失。

# 神话 3:虚拟 DOM 是纯粹的开销

好吧，我不能否认这不是真的。然而，该语句的使用会产生误导。绝对一切不是香草 js 是纯粹的开销。我的意思也不仅仅是编译优化的代码。正如神话 2 中提到的，仍然有一个运行时。因此，无论您如何攻击它，都需要管理 DOM 的更新和更改。一般来说，所有现代的数据驱动 UI 库都以 3 种方式工作，每种方式都有自己的权衡。您可以为每种方法创建有效的版本。事实上，已经有一些库体现了每种方法的规模和性能特征，远远超出了流行库的能力(见[https://github.com/krausest/js-framework-benchmark](https://github.com/krausest/js-framework-benchmark))。

虚拟 DOM 和其他方法一样是一种完全可行的方法，并且仍然是图书馆中最流行的方法，甚至在生产 Web 组件的图书馆中也是如此。大多数基准测试都是由库在一个组件中完成所有工作。在真实的项目中，您可以模块化成多个组件。这也有一个开销，并没有被谈论的那么多。与其他方法相比，虚拟 DOM 通常在更多的组件上具有更好的伸缩性。所以我们对真实表现的看法可能会有偏差。

在我看来，您选择不使用虚拟 DOM 的原因不是性能或大小。您更喜欢开发人员经验的扩展——组合模式、可变性与不可变性、代码结构等...但是仅仅因为用技术方法做某事不容易，并不意味着它不可能。React Fiber 和 Hooks 表明虚拟 DOM 库可以表现得几乎像一个反应库。当然，KnockoutJS 在 2010 年拥有这些功能，但这并没有减少它的潜力。

> 我提到的三种方法是虚拟 DOM、DOM 协调和反应式。
> 
> 虚拟 DOM 库是基于使用生成一个虚拟树，然后不同于以前的迭代和修补 DOM 更新。它使用不变性和引用相等来简化优化。然而，不变性会导致大量的克隆和内存分配。示例:反应、Vue、地狱
> 
> DOM 协调库在创建 DOM 节点时存储绑定值。每次更新时，它们都与以前的值进行比较，并更新 DOM。它们类似于虚拟 DOM 库，除了它们在一个通道中工作，只有叶子不同。然而，基于可变性，它们需要在叶子处总是不同的，因此在深层嵌套结构中优化快捷方式的方法较少。示例:角形、聚合物、lit-html
> 
> 反应库在创建 DOM 节点时构造一个反应图。这样，每个绑定上下文都可以与一个事件订阅相关联，以便在数据更新时只运行相关的事件处理程序。这种方法是优化的，因为它需要最小的差异，但它具有最大的初始创建成本。例如:苗条、迷人、结实

# 误解 4: Web 组装对于 Web UI 来说更快

不变的是:永远不要低估 JavaScript。但在我看来更是如此:永远不要低估 DOM 的成本。DOM 贵得离谱。到目前为止，大多数人都知道操作 DOM 的代价，因为它会导致重流和重画。并且即使读取影响布局的属性也会导致过早回流。然而，即使窥视它上面的其他属性也会有巨大的成本。任何类型的树遍历几乎都和创建 DOM 节点一样昂贵。几乎你用 DOM 做的任何事情都有额外的成本。

不幸的是，对于其他技术来说，成本更难处理。Web 工作人员会拯救我们，但是他们不能访问 DOM，所以虽然他们有很多性能上的好处，但是他们对 Web UI 没有有意义的影响。WASM 也有类似的限制。当你在 WASM 时，WASM 比 JavaScript 快得多，但是你越是过渡到 JavaScript APIs，它就越慢。目前，这是它访问 DOM 的唯一方式。随着 Web 绑定的引入，这种情况最终会改变。这在过去几年里一直在工作，当规范最终落地时，我们可以看到一些大的收获。到今天为止，普通 js 不仅在 DOM 渲染上更快，而且一些高级数据驱动库比最快的低级 WASM 实现更高效(见[https://github.com/krausest/js-framework-benchmark](https://github.com/krausest/js-framework-benchmark))。更高级别的 WASM 实现可能会有更多的开销。所以，最新的 WASM UI 库远远不是性能最好的。

# 误解 5:调度意味着更好的性能

这不是一个新的，但它不断回来。React Concurrent Mode 只是制作大多数无意义动画演示的最新趋势。为什么我说大多没有意义？有意义的性能受到帧速率的限制。几乎所有的演示都使用`requestAnimationFrame`，因为不这样做就是做不必要的工作。所以通常唯一的解决方法就是想出荒谬的场景。然而这意味着我们只是在非常有限的情况下测试库——当它们受到最糟糕的约束时。这有一些优点。在资源有限的情况下，适度降级对低功耗设备至关重要。但是图书馆如何摆脱这种束缚呢？想办法少做工作。这不再是提高性能的练习，而是如何缩减工作以提供更好的用户体验。

这是一个非常崇高的目标，但它有一些有趣的副作用。检测和调度有开销。显然比 DOM 少。但是库中的渲染越重，就越需要这种干预。它变成了一种自我实现的预言。所有的库都可以使用像`requestAnimationFrame`这样的调度技术。因此，尽管我们同意阻塞主线程不利于交互性，但很难概括出性能和阻塞量之间的最佳平衡点。只有当我们超出硬件支持的极限时，我们才会注意到这一点，那么最优雅的降级方式是什么呢？我在我的办公室里用 [Sierpinski 三角形演示](https://github.com/ryansolid/solid-sierpinski-triangle-demo)测试了对不同调度算法的视觉反应，结果相当不一致。没有更好的选择了。而在切换带有悬念的标签页时，延迟加载状态的视觉效果是一致的。

目前常用的技术是基于截止日期和排队的概念。`requestAnimationFrame`和`requestIdleCallback`的一个不太为人所知的特性是，调用你提供的回调函数时会带有一些信息，这些信息可以让你决定你需要工作多少时间。通过使用它来根据可用时间管理你的工作，你可以更聪明地安排时间。不幸的是，正如我所说的，这里没有灵丹妙药。有时候越快越好。

我希望这次探索能够揭示 2019 年前端的一些常见神话。不只是一个唱反调的人，因为我知道很多这些来自一个展望未来的地方。虽然我认为这些技术具有很大的潜力，但我警告说，不要急于求成，因为这种热情尤其是在没有具体现实基础的情况下，可能会导致毫无根据的猜测，从而形成势头。在 2014 年，同样的原因导致一些人认为虚拟 DOM 比实际 DOM 更快。

![](img/769a24705e19d944d536e9fd3ab47ba2.png)

是..没有那么多。