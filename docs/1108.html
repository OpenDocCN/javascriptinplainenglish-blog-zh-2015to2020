<html>
<head>
<title>What Is JavaScript IIFE?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是JavaScript IIFE？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-javascript-iife-f755f899ba0c?source=collection_archive---------5-----------------------#2020-01-30">https://javascript.plainenglish.io/what-is-javascript-iife-f755f899ba0c?source=collection_archive---------5-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="208d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">立即调用的函数表达式(IIFE)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/16f2cebb1472111d64ec534fdd2b7ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yt7ncfS_QY7oJZ41"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@fabrizioverrecchia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fabrizio Verrecchia</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="35f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">IFE代表立即调用的函数表达式。它是一个JavaScript函数，一旦定义好就运行。它没有名字，也不存储在变量中。</p><p id="d676" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些通常出现在整个代码库都包装在IFFE中的库中。这可以防止库中的变量与库外的变量发生冲突。这些通常用于避免在全局范围内声明变量和创建闭包。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/4c7afacb6a1130fa8b25d3a46e315cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*xA_unY40ppuuFrwAjA_Wug.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A normal function</figcaption></figure><p id="b76e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个普通函数的例子。我们声明一个函数，然后调用这个函数。传递这些值，它返回这些值的乘积。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/30c734cfd4665ebcbaf27cbbd3ddf6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*Y7nWNhPnslvUTr5olcC9VQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The same function as in IIFE</figcaption></figure><p id="a84b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与生活中的功能相同。在这里，我们删除函数名，将函数括在括号中，然后在末尾添加括号，其中包含我们要传递的值。</p><p id="2e71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结束括号实际上是调用函数的部分。注意，这个函数永远不能被再次调用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/243bcb7b9f819bdd67ce4ef3a9714c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*diBjTVIt4Fisw3D8850xOQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The same function as an arrow function</figcaption></figure><p id="ebf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的函数也可以写成箭头函数。表达式中的任何值都不能从闭包外部访问。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/fe4b43bf9742172ef243f840d24f1381.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*ZyVBafesUoK5K8Ey2duNMA.png"/></div></figure><p id="a237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里你可以看到在生命中，名字变量是<code class="fe md me mf mg b">John</code>，但是在生命之外，名字变量是<code class="fe md me mf mg b">Aiman</code>。</p><p id="9dfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了ES6，你可以使用使用块作用域的<code class="fe md me mf mg b">Let</code>和<code class="fe md me mf mg b">Const</code>变量来完成同样的事情。当这些在块中声明时，它们被认为是局部范围的，而不是全局范围的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/ebd6491059259801cf7d97d55511820f.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*oyngZJzUGjCAPygGiHomNg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A block with curly braces</figcaption></figure><p id="18d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以去掉函数，只用花括号创建一个块。首先，我们用<code class="fe md me mf mg b">var</code>来展示不同之处。这里<code class="fe md me mf mg b">var</code>被认为是全局范围的，甚至在块内。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/be50e96c1f046c9a5b8dd38de9345734.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*scE47gcf9lQ6Lepvyg0mSg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Change var to let</figcaption></figure><p id="23fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当我们将<code class="fe md me mf mg b">var</code>改为<code class="fe md me mf mg b">let</code>时，我们可以看到块内的name变量是局部范围的，不能从块外访问。</p></div></div>    
</body>
</html>