<html>
<head>
<title>How to Use React Router with Layouts: A New Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在布局中使用React路由器:一种新方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/new-approach-for-working-with-react-router-dom-82b7be0404b9?source=collection_archive---------1-----------------------#2020-03-13">https://javascript.plainenglish.io/new-approach-for-working-with-react-router-dom-82b7be0404b9?source=collection_archive---------1-----------------------#2020-03-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/6c70f33ef2c43b88ac31cec287c7c56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qqj09kL_nkE684AFt-PJEw.png"/></div></div></figure><div class=""/><div class=""><h2 id="1b9a" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">用数组在一个简单的React应用程序中制作路由器</h2></div><p id="e03d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">大家好，我是阿里·希尔扎德，前端开发者。</p><p id="1599" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">对于我的一个简单项目，我决定提高我的代码的可读性，让下一个为我的代码工作的人开心！:)</p><p id="4641" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">当我在谷歌上搜索如何绘制路线时，我完全被弄糊涂了，失去了我的主要目标，即提高可读性。我找到的所有教程都与react-router的官方文档非常相似。</p><p id="5d19" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">react-router的一个简单示例:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lj"><img src="../Images/53a3bd29ff300faf0baee608316907f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApB2bDXqrhJGgS1cUJNw1w.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Skip <em class="ls">&lt;Home/&gt; ,&lt;About/&gt;,&lt;Dashboard/&gt; </em>Component For Now</figcaption></figure><p id="7534" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上面的代码非常清晰，可读性很好。</p><p id="ba1c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">但是如果我想使用带有组件的布局呢？</p><p id="070c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">据我所知，我们使用布局有两种选择:<br/> 1。分别制作被版图包裹的各个组件<br/> 2。用布局组件<br/>包装所有你想使用的路线(我更喜欢第一种方式，我不太喜欢第二种方式)</p><p id="e9c1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz">选项一大概是这样的:</strong></p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lt"><img src="../Images/4dfc207a34c47918cab09e8dd9f90ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcmF-2__AgyjdP81UAZ9TQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">We Must do this for All Component that Wants to Use Layout</figcaption></figure><p id="02fe" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后像这样使用它们:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lt"><img src="../Images/af82239fbb6e15fe8e14fef1a53b7d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPzZ2YDdAtAvmKS59b5mwg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Skip &lt;AnotherComponent/&gt;, I Just Want To Show You How to Wrap And Use Them</figcaption></figure><p id="5212" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz">第二个是这样的:</strong></p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lt"><img src="../Images/0540b68e3842ff2f394ab2a486cb87ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aTEYcBfzLgJMlHctx6qPw.png"/></div></div></figure><p id="9a54" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">像这样使用它们:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lu"><img src="../Images/eac5bf3d9631d5d9bfdef727bc4ffe2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*St1xuAXAmYYsM-ykjtT_8g.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Description of Private Route Later</figcaption></figure><p id="8228" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在这两种方式中<em class="lv">、&lt; SomeLayout &gt; </em>是这样的:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lt"><img src="../Images/69db133fbe54050aedf8a79ea618c2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqBU3mLus4GQoyzf_0Vt6g.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Imagine We Created the Header, Sidebar and Footer earlier</figcaption></figure><p id="dfa2" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如您所见，该组件通过使用交换机和路由器组合了所有子组件并显示其中一个，但它没有良好的可读性。在我的项目中，每次我需要路由时，我应该使用这个意大利面条代码吗？<br/>(你可以在<a class="ae lw" href="https://stackoverflow.com/questions/42862028/react-router-v4-with-multiple-layouts" rel="noopener ugc nofollow" target="_blank">这个链接</a>上看到一些解决方案)</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="b7ca" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">和队友聊过之后，他们建议我把所有路线放在一个数组里，用地图功能做路线(更容易阅读和开发)。</p><p id="f94b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">因此，在上面的两个例子中，我们不使用<em class="lv"> App.js </em>，而是使用这个方法:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lt"><img src="../Images/7731d6b5638889a63dee6cd0c48fadb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIPzFSCoxXOXrjxQbM2FAA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Imagine We Have Teacher, Classes Component And Imported</figcaption></figure><p id="be9a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上图:<br/> <br/> 1。创建一个数组(routes)的对象，该对象具有一些与Route组件相关的属性。<br/>②<br/>。遍历routes数组，并将它们放入&lt; routeComponent/ &gt;(将<em class="lv"> routes </em>数组中的所有元素转换为react-router-dom中的routeComponent，并将其移动到&lt;<em class="lv">Route component/&gt;</em>)。<br/> <br/> 3。最后使用在第二步中生成的routeComponent(完整示例<a class="ae lw" href="https://codesandbox.io/s/react-router-with-map-no44i" rel="noopener ugc nofollow" target="_blank">这里是</a>，引用是<a class="ae lw" href="https://alligator.io/react/react-router-map-to-routes/" rel="noopener ugc nofollow" target="_blank">这里是</a>)。<br/> <br/>看起来不错但还是需要用布局单独包裹所有组件。:(</p><p id="cb1f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我认为如果我们对所有的路线使用一个对象会更好，这个对象包括所有的路线和它们的属性，像<em class="lv">路径</em>、<em class="lv">精确</em>、<em class="lv">布局</em>、<em class="lv">组件</em></p><p id="7fed" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">想象一下，如果我们能够将这个物体转换成一个真实的路由系统:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lt"><img src="../Images/3e00804ba4caa2e1c73842433107cdba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBnUDz2yD-KqZjTydl3D2g.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">exact Property is True By Default, Private Is props for Protect Route from Unauthorised User and Redirect Them To Login Page</figcaption></figure><p id="365b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我认为在一个简单的react项目中定义路由是最好的方法，但是如何做到这一点呢？</p><p id="0028" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们所知道的是，我们必须使用一个map来遍历数组，并返回一些具有某种属性的组件…</p><p id="7174" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们知道父布局必须在子路由中使用(这样，我们通过模块属性中的一个级别来定义子路由)。</p><p id="b062" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">例如，Admin.newProduct组件从其父组件继承adminLayout。</p><p id="8ff8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">另外，新产品的路径是这样的:</p><pre class="lk ll lm ln gt me mf mg mh aw mi bi"><span id="f600" class="mj mk iy mf b gy ml mm l mn mo">http://www.site.com/admin/new_product</span></pre><p id="c45c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">所以我们需要将父路径和子路径连接起来。</p><p id="2c2f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们只知道我们必须创建一些函数组件来返回路线数组</p><p id="f618" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后以这种方式使用这个组件:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mp"><img src="../Images/15b6078097852f38436544f97c50b0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmiR1cHzp9x87DxM342tAA.png"/></div></div></figure><p id="361e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">因此，我们必须创建一个功能组件，并将其命名为<em class="lv"> RouteCombiner </em>，并接收道具<em class="lv"> : </em></p><pre class="lk ll lm ln gt me mf mg mh aw mi bi"><span id="deed" class="mj mk iy mf b gy ml mm l mn mo">import React from 'react'<br/>import {} from 'react-router-dom' //Import Something Later from RRD</span><span id="4941" class="mj mk iy mf b gy mq mm l mn mo">export default function RouteCombiner(props) {<br/>  return <br/>  &lt;&gt;<br/>    //Do Something With Props<br/>  &lt;/&gt;<br/>}</span></pre><p id="fd1d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="lv"> RouteCombiner </em>组件接收<em class="lv"> PrivateRoute </em>组件(如果不了解私有路由，请阅读<a class="ae lw" href="https://medium.com/@thanhbinh.tran93/private-route-public-route-and-restricted-route-with-react-router-d50b27c15f5e" rel="noopener">此</a>页面)和routes对象作为道具。</p><p id="b708" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="lv">中的<strong class="kp iz">route combiner</strong></em>:</p><p id="8850" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们必须析构一些属性(如果你不知道什么是析构，请阅读<a class="ae lw" href="https://www.freecodecamp.org/news/how-to-use-destructuring-in-javascript-to-write-cleaner-more-powerful-code-9d1b38794050/" rel="noopener ugc nofollow" target="_blank">这个</a>，我们需要<em class="lv"> PrivateRoute一个</em>和<em class="lv"> routes </em>对象。然后，我们必须创建另一个包含所有生成的路由组件的对象，并最终返回由switch包装的组件(使用此组件时，可以在<em class="lv"> app.js </em>中使用Switch，而不是在这里)。</p><ol class=""><li id="e333" class="mr ms iy kp b kq kr kt ku kw mt la mu le mv li mw mx my mz bi translated">通过路线进行循环</li><li id="cec4" class="mr ms iy kp b kq na kt nb kw nc la nd le ne li mw mx my mz bi translated">使<em class="lv"> ComponentWithLayout </em>组件<em class="lv"> t </em>包含被布局包装的<em class="lv">组件</em>(如果布局不存在，我们可以使用默认值)</li><li id="e465" class="mr ms iy kp b kq na kt nb kw nc la nd le ne li mw mx my mz bi translated">检查路由是否有私有属性，如果有私有属性，返回我们作为道具发送的<em class="lv"> PrivateRoute </em>组件。如果私有属性不存在，返回从RRD导入的路由组件(react-router-dom)。</li><li id="99d9" class="mr ms iy kp b kq na kt nb kw nc la nd le ne li mw mx my mz bi translated">在这两种方式中，如果<em class="lv">模块</em>属性存在，则进行另一个循环并遍历模块数组。</li></ol></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="e396" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi">1:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nf"><img src="../Images/345ea7ed45544944747fa0f8b011aca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5v_P1qIBd47xhIC2oIRz-w.png"/></div></div></figure><p id="56d8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi">2:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ng"><img src="../Images/151a928f5ee9f9ce39de1466408df896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlCEWvyMIlJ1BEniJ0_iEQ.png"/></div></div></figure><p id="98da" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi">3:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nf"><img src="../Images/7680bb06878dd8e7871f96e5e8dd95bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNoZdeTbkgS-BhKb_23xdQ.png"/></div></div></figure><p id="1772" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">仅此而已。现在，我们可以轻松地对一个对象使用布局和路径，但是我们忘记了一些东西。模块呢(模块代表所有子路由)？</p><p id="96cc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果要返回儿童路线，<em class="lv"> RoutesMap有些变化。<br/> </em>我们只返回一个路由(或私有路由)组件。如果我们需要返回孩子，我们必须返回一个包含主路由及其孩子的数组。</p><p id="472a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">对于第四步:</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nh"><img src="../Images/ae0bf4470b6427901c8711363b080041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZR7EMJ_eKooX3gwWcwjlA.png"/></div></div></figure><p id="a6a6" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">结束了。:)</p><p id="1edb" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这听起来可能很难，但是想象一下你是一个必须使用这个代码作为路由系统的人。</p><p id="0bde" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">最后，这段代码只适用于不需要SSR(服务器端渲染)的简单项目。因为<em class="lv"> After.js </em>和<em class="lv"> Next.js </em>都有自己的路由方案……也许还有一些性能问题。</p><p id="9ec1" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">(完整示例在<a class="ae lw" href="https://codesandbox.io/s/route-combiner-suq4u" rel="noopener ugc nofollow" target="_blank">我的沙盒</a>上)</p><p id="bf6b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">请随意问我这篇文章的任何部分，如果有人能解决可能的问题并使代码变得更好，我会很高兴。</p><p id="fe59" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">编码快乐！😜</p><p id="0395" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><em class="lv">更多内容看</em> <a class="ae lw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="lv">说白了就是io </em> </strong> </a> <em class="lv">。报名参加我们的</em> <a class="ae lw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="lv">免费周报</em> </strong> </a> <em class="lv">。关注我们关于</em><a class="ae lw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="lv">Twitter</em></strong></a><em class="lv">和</em><a class="ae lw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kp iz"><em class="lv">LinkedIn</em></strong></a><em class="lv">。加入我们的</em> <a class="ae lw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> <em class="lv">社区</em> </strong> </a> <em class="lv">。</em></p></div></div>    
</body>
</html>