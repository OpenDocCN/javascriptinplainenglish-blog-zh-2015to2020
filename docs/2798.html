<html>
<head>
<title>Testing In React, Part 2: React Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的测试，第2部分:React测试库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-in-react-part-2-react-testing-library-f32432b93c6c?source=collection_archive---------1-----------------------#2020-07-25">https://javascript.plainenglish.io/testing-in-react-part-2-react-testing-library-f32432b93c6c?source=collection_archive---------1-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/bf40a55cdd50cd0482ac0dfb7fc1be59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fsLSCBaQzpsKf8X4AgH2MA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@ivoafr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ivo Rainha</a> on <a class="ae jd" href="https://unsplash.com/s/photos/library?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="dd05" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本文是React中测试系列的一部分:</p><p id="0e47" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-1-types-tools-244107abf0c6" rel="noopener">React中的测试，第1部分:类型&amp;工具</a></p><p id="90ab" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">React中的测试，第2部分:React测试库</strong></p><p id="1683" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-3-jest-jest-dom-7a8a03ae60b" rel="noopener">React的测试，第3部分:Jest &amp; Jest-Dom </a></p><p id="9369" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-4-enzyme-9b030ad616ae" rel="noopener">React中的测试，第4部分:酶</a></p><p id="5c1e" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/@bryn.bennett/testing-in-react-part-5-end-to-end-testing-with-cypress-bd2bf8d3385f" rel="noopener">React中的测试，第5部分:使用Cypress的端到端测试</a></p><p id="2cba" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-6-real-world-testing-with-react-testing-library-jest-enzyme-and-cypress-9c73436d95d8" rel="noopener">React中的测试，第6部分:React测试库、Jest、Enzyme和Cypress的真实测试</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="a473" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">React测试库的标题是，“测试功能，<em class="kp">而不是</em>实现”。这个概念背后的思想是，实现是不断迭代和改进的，因此作为测试UX的手段是不可靠的。</p><p id="5071" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">例如，假设您正在开发一个小的React组件，在早期，您为其编写测试。该组件处理一定量的逻辑，并向DOM呈现一些内容。随着应用程序的增长，这个组件也在增长，最终将它分解成多个组件是有意义的。就用户而言，什么都没有改变——呈现给DOM的内容还是一样的。换句话说，您只改变了<em class="kp">实现</em>，而没有改变<em class="kp">功能。</em></p><p id="9333" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">如果您的初始测试是为了测试实现而编写的，它们将会崩溃。但是通过测试功能——DOM节点而不是呈现的组件——您的测试继续通过(当然，除非您搞砸了重构)。</p><p id="7d76" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated"><strong class="kq jh">在我们开始</strong>之前，有一个小提示:Jest和React测试库经常一起使用，虽然我认为分别关注其中一个很有帮助，但是离开另一个来谈论其中一个几乎是不可能的。你可以认为Jest是在做实际的测试，而React Testing Library是在重新创建要测试的东西(无论是事件还是节点等等)。).这里提到的任何Jest功能将在我的下一篇文章中深入讨论。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="2d1a" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">测试功能</h1><blockquote class="kk kl km"><p id="015e" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个库提供的实用程序可以像用户一样方便地查询DOM。通过标签文本查找表单元素(就像用户一样)，从文本中查找链接和按钮(就像用户一样)。它还公开了一种推荐的方法，通过一个<code class="fe mn mo mp mq b">data-testid</code>来查找元素，作为文本内容和标签没有意义或不实用的元素的“出口”。</p></blockquote><p id="f50f" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">以上摘自官方文档，总结了这个库的核心。简单地说，反应测试库1。呈现React组件和2。搜索(或“查询”)一个DOM节点。查询之后，测试被踢回Jest(或Jest-Dom)，Jest可以实际测试被查询节点的属性(即，它存在于Dom中或具有指定的长度)。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="a4b2" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">在测试环境中渲染</h1><p id="dc1b" class="pw-post-body-paragraph kn ko jg kq b kr mr kt ku kv ms kx ky lm mt lb lc ln mu lf lg lo mv lj lk ll ij bi translated">从语法上来说，第一步很简单。要测试的组件被导入到一个测试文件中，然后使用<code class="fe mn mo mp mq b">render</code>函数进行渲染。真的很简单。真实世界的实现将把<code class="fe mn mo mp mq b">render</code>封装在一个Jest测试中，我们将在Jest中介绍这个测试。现在，想象一下这个:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="cf47" class="ne lq jg mq b gy nf ng l nh ni">import App from './App';</span><span id="82b8" class="ne lq jg mq b gy nj ng l nh ni">render(&lt;App /&gt;);</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="f0a9" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">API查询</h1><p id="0e5a" class="pw-post-body-paragraph kn ko jg kq b kr mr kt ku kv ms kx ky lm mt lb lc ln mu lf lg lo mv lj lk ll ij bi translated">第二步，在DOM中搜索一些东西，通过API查询来实现。最流行的两个查询是<code class="fe mn mo mp mq b">getByText</code>和<code class="fe mn mo mp mq b">getByRole</code>，但是还有更多。这些语句由变量(<code class="fe mn mo mp mq b">getBy</code>)和查询(<code class="fe mn mo mp mq b">Text</code>)组成。</p><h2 id="d5e0" class="ne lq jg bd lr nk nl dn lv nm nn dp lz lm no np md ln nq nr mh lo ns nt ml nu bi translated"><strong class="ak">可用变体:</strong></h2><ul class=""><li id="7d7a" class="nv nw jg kq b kr mr kv ms lm nx ln ny lo nz ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">getBy</code></li><li id="33a2" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">getAllBy</code></li><li id="16ba" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">queryBy</code></li><li id="bc53" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">queryAllBy</code></li><li id="14b0" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">findBy</code></li><li id="c98c" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">findAllBy</code></li></ul><h2 id="5d13" class="ne lq jg bd lr nk nl dn lv nm nn dp lz lm no np md ln nq nr mh lo ns nt ml nu bi translated"><strong class="ak">可用查询:</strong></h2><ul class=""><li id="4c0e" class="nv nw jg kq b kr mr kv ms lm nx ln ny lo nz ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByLabelText</code></li><li id="317e" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByPlaceholderText</code></li><li id="3a28" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByText</code></li><li id="6a0a" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByAltText</code></li><li id="cc31" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByTitle</code></li><li id="5521" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByDisplayValue</code></li><li id="dd6b" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByRole</code></li><li id="5778" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">ByTestId</code></li></ul><p id="105e" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">这些都是不言自明的，所以我不打算在这里一一介绍。不过，我会很快指出，由于<code class="fe mn mo mp mq b">get</code>、<code class="fe mn mo mp mq b">query</code>和<code class="fe mn mo mp mq b">find</code>看起来都是表示同一事物的词，它们确实有不同的用法。</p><p id="35c8" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated"><code class="fe mn mo mp mq b">get</code>将是您的首选，<code class="fe mn mo mp mq b">query</code>通常用于断言元素的缺失，<code class="fe mn mo mp mq b">find</code>可用于异步出现的元素。</p><p id="fe1a" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">此外，那些接受字符串作为参数的函数也可以接受正则表达式，这在查找部分匹配时很有用。您可以在<a class="ae jd" href="https://testing-library.com/docs/dom-testing-library/api-queries" rel="noopener ugc nofollow" target="_blank">官方文档</a>中阅读关于每个变体和问题的更多信息。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="d0fa" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">屏幕</h1><p id="2e70" class="pw-post-body-paragraph kn ko jg kq b kr mr kt ku kv ms kx ky lm mt lb lc ln mu lf lg lo mv lj lk ll ij bi translated">这些查询在库提供的一个<code class="fe mn mo mp mq b">screen</code>对象上被调用，这个对象类似于<code class="fe mn mo mp mq b">document.body</code>,但是适用于您的测试环境。事实上，<code class="fe mn mo mp mq b">screen</code>伴随着每个预先绑定到<code class="fe mn mo mp mq b">document.body</code>的查询。</p><p id="2785" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">此外，<code class="fe mn mo mp mq b">screen</code>有一个<code class="fe mn mo mp mq b">debug</code>功能，它会将指定的HTML打印到您的终端，让您看到实际呈现给用户的内容。API查询可以传递给<code class="fe mn mo mp mq b">debug</code>函数，如下图:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="717c" class="ne lq jg mq b gy nf ng l nh ni">screen.debug(screen.getByText('submit'))</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="6c15" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">事件</h1><p id="1d15" class="pw-post-body-paragraph kn ko jg kq b kr mr kt ku kv ms kx ky lm mt lb lc ln mu lf lg lo mv lj lk ll ij bi translated">由于React的核心是对事件做出反应，React测试库允许您测试事件的触发。您可以通过使用上面的功能来选择触发事件的节点(比如一个按钮)，然后使用<code class="fe mn mo mp mq b">fireEvent</code>来重新创建要测试的事件。<code class="fe mn mo mp mq b">fireEvent</code>提供了许多方便的方法，这样你就不必为像点击这样的基本操作创建新的自定义事件。</p><h2 id="eb64" class="ne lq jg bd lr nk nl dn lv nm nn dp lz lm no np md ln nq nr mh lo ns nt ml nu bi translated">便利方法:</h2><ul class=""><li id="837e" class="nv nw jg kq b kr mr kv ms lm nx ln ny lo nz ll oa ob oc od bi translated"><a class="ae jd" href="https://github.com/testing-library/dom-testing-library/blob/master/src/event-map.js" rel="noopener ugc nofollow" target="_blank">完整列表</a></li><li id="9b3c" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">click</code>、<code class="fe mn mo mp mq b">dblClick</code>、<code class="fe mn mo mp mq b">drag</code>、<code class="fe mn mo mp mq b">drop</code>、<code class="fe mn mo mp mq b">mouseEnter</code>、<code class="fe mn mo mp mq b">mouseLeave</code></li><li id="627e" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">copy</code>、<code class="fe mn mo mp mq b">cut</code>、<code class="fe mn mo mp mq b">paste</code></li><li id="7f61" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">focus</code>、<code class="fe mn mo mp mq b">blur</code>、<code class="fe mn mo mp mq b">focusIn</code>、<code class="fe mn mo mp mq b">focusOut</code></li><li id="c912" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">change</code>、<code class="fe mn mo mp mq b">input</code>、<code class="fe mn mo mp mq b">invalid</code>、<code class="fe mn mo mp mq b">submit</code>、<code class="fe mn mo mp mq b">reset</code></li><li id="37e8" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">keyDown</code>、<code class="fe mn mo mp mq b">keyPress</code>、<code class="fe mn mo mp mq b">keyUp</code></li><li id="565c" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">select</code></li><li id="cd81" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">scroll</code></li></ul><p id="7127" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">便利方法列表下的“完整列表”将提供便利事件的完整列表，以及包括默认<code class="fe mn mo mp mq b">eventProperties</code>在内的详细信息。</p><p id="d439" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated"><code class="fe mn mo mp mq b">fireEvent</code>函数的结构如下:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="f157" class="ne lq jg mq b gy nf ng l nh ni">fireEvent[eventName](node: HTMLElement, eventProperties: Object)</span></pre><p id="e23c" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">下面的例子(由官方文档提供)模拟了用户右击提交按钮(<code class="fe mn mo mp mq b">button: 0</code>是左键，<code class="fe mn mo mp mq b">button: 2</code>是右键)</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="440f" class="ne lq jg mq b gy nf ng l nh ni">const rightClick = { button: 2 } </span><span id="b171" class="ne lq jg mq b gy nj ng l nh ni">fireEvent.click(getByText('Submit'), rightClick)</span></pre><p id="b935" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">最方便的可用的<code class="fe mn mo mp mq b">eventProperties</code>方法包括<code class="fe mn mo mp mq b">bubbling</code>和<code class="fe mn mo mp mq b">cancelable</code>，但是有些会有特定于它的属性，比如<code class="fe mn mo mp mq b">click</code>有一个<code class="fe mn mo mp mq b">button</code>属性。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="769f" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">异步ˌ非同步(asynchronous)</h1><p id="a69e" class="pw-post-body-paragraph kn ko jg kq b kr mr kt ku kv ms kx ky lm mt lb lc ln mu lf lg lo mv lj lk ll ij bi translated">最后，由于异步代码在任何给定时间都会极大地影响DOM上的内容，React测试库提供了测试DOM中异步发生的变化的功能。</p><h2 id="b775" class="ne lq jg bd lr nk nl dn lv nm nn dp lz lm no np md ln nq nr mh lo ns nt ml nu bi translated">异步实用程序</h2><ul class=""><li id="015c" class="nv nw jg kq b kr mr kv ms lm nx ln ny lo nz ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">waitFor</code></li><li id="080c" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><code class="fe mn mo mp mq b">waitForElementToBeRemoved</code></li></ul><p id="0c58" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">其他不赞成使用的实用程序仍然可用，所以您可能会在现有代码中看到其他实用程序(就像简单的<code class="fe mn mo mp mq b">wait</code>)，但这是当前应该使用的两个实用程序。</p><p id="4ffc" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">通常，这些函数用于等待某件事情发生以响应某个事件，简单地说明了JavaScript中的事情不一定是瞬间发生的。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="3e30" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">正如我前面说过的，React测试库与Jest一起使用，我们将在接下来讨论。一旦我们理解了这两者是如何工作的，我们就可以看到它们是如何组合成一个有效的测试套件的。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="6548" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">之前的</strong>:<a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-1-types-tools-244107abf0c6" rel="noopener">React中的测试，第1部分:类型&amp;工具</a></p><p id="07cc" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">下一个</strong>:<a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-3-jest-jest-dom-7a8a03ae60b" rel="noopener">React中的测试，第3部分:Jest &amp; Jest-Dom </a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="0d6a" class="ne lq jg bd lr nk nl dn lv nm nn dp lz lm no np md ln nq nr mh lo ns nt ml nu bi translated">资源</h2><ul class=""><li id="00f2" class="nv nw jg kq b kr mr kv ms lm nx ln ny lo nz ll oa ob oc od bi translated"><a class="ae jd" href="https://testing-library.com/docs/intro" rel="noopener ugc nofollow" target="_blank">正式文件</a></li><li id="ad3e" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><a class="ae jd" href="https://testing-library.com/docs/dom-testing-library/cheatsheet" rel="noopener ugc nofollow" target="_blank">反应测试库小抄</a></li><li id="e6ca" class="nv nw jg kq b kr oe kv of lm og ln oh lo oi ll oa ob oc od bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=JKOwJUM4_RM&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">什么是React测试库？</a></li></ul></div></div>    
</body>
</html>