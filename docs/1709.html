<html>
<head>
<title>Leveraging Type-Only imports and exports with TypeScript 3.8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用TypeScript 3.8的仅类型导入和导出</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/leveraging-type-only-imports-and-exports-with-typescript-3-8-5c1be8bd17fb?source=collection_archive---------1-----------------------#2020-04-16">https://javascript.plainenglish.io/leveraging-type-only-imports-and-exports-with-typescript-3-8-5c1be8bd17fb?source=collection_archive---------1-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2437" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个月前，我开始在Webpack上看到关于找不到出口的奇怪警告。</p><p id="311f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很困惑。显然，有什么地方出错了，因为出口确实在那里:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="fcc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不能注意到我用那种字体的地方出了什么问题:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="78ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能发现问题吗？</p><h1 id="0f08" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">根本原因…</h1><p id="f49e" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在没有任何线索的情况下，我挖了一会儿，无意中发现了下面这个问题:<a class="ae lv" href="https://github.com/webpack/webpack/issues/7378" rel="noopener ugc nofollow" target="_blank">https://github.com/webpack/webpack/issues/7378</a></p><p id="4783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有一种感觉，这与TypeScript &amp; transpilation有关，因为我正在导入/使用TypeScript类型，但不清楚…</p><p id="b722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后就咔嚓一声；<a class="ae lv" href="https://github.com/webpack/webpack/issues/7378#issuecomment-392264102" rel="noopener ugc nofollow" target="_blank">托拜厄斯·科珀斯立刻看到了</a>我没能理解的东西。我感到“惭愧”,因为我刚刚<a class="ae lv" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL/ref=sr_1_4?dchild=1&amp;keywords=typescript+3&amp;qid=1587049779&amp;sr=8-4" rel="noopener ugc nofollow" target="_blank">出版了一本关于打字稿</a> :D的书</p><p id="a63e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事情是，一旦类型脚本代码被编译，接口/类型就消失了。它们已经不存在了；它们不存在于<em class="lw">发出的</em>文件中。</p><p id="be18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我之前没有考虑太多的是，虽然类型被删除，但导入/导出不一定被删除。原因是存在歧义，编译器并不总是确切知道导出的东西是类型还是值。</p><p id="a0f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，Webpack在处理生成的JavaScript代码时看到的是一个并不存在的导入。</p><p id="d51b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Webpack是宽松的，所以它只发出一个警告，但问题确实存在，我无法控制在这种情况下TypeScript会生成什么。</p><h1 id="9473" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">TypeScript 3.8拯救世界</h1><p id="668c" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">当时我没有太多时间来进一步研究这个问题，所以我让它休息了一段时间(它没有阻塞)，但是后来，一旦TypeScript 3.8发布，我注意到发行说明中有一些真正有趣的东西:<a class="ae lv" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-8/#type-only-imports-exports" rel="noopener ugc nofollow" target="_blank">仅类型的导入和导出</a>。</p><p id="a797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这直接提醒了我的进口问题…</p><p id="c569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript的这一新特性增加了将元素仅作为类型导入的可能性，这正好适用于导入的类型仅用作类型而从不作为值的情况。这正是我所需要的；多亏了这一点，我终于可以准确地告诉编译器我想做什么。</p><p id="fc10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要解决这个问题，我只需更换它</p><pre class="kl km kn ko gt lx ly lz ma aw mb bi"><span id="3536" class="mc kt iq ly b gy md me l mf mg">import { MyCustomExpressRequest } from "../../../shared";</span></pre><p id="e4fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过以下方式:</p><pre class="kl km kn ko gt lx ly lz ma aw mb bi"><span id="f62c" class="mc kt iq ly b gy md me l mf mg">import <strong class="ly ir">type</strong> { DidowiExpressRequest } from "../../../shared";</span></pre><p id="848c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">精彩！</p><p id="4964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这在实践中改变了什么呢？</p><p id="8bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，正如<a class="ae lv" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-8/#type-only-imports-exports" rel="noopener ugc nofollow" target="_blank"> TS发布说明</a>所解释的，通过使用“导入类型”来导入元素，它告诉编译器该元素只是被导入来用作类型注释/声明。由于这一点，编译器知道它可以删除发出的代码中的导入。</p><p id="66ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成这一项更改后，Webpack立刻变得更开心了:不再有奇怪的导入了！</p><p id="7dd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，您还可以使用“导出类型”来表示某些导出将只用作类型注释/声明。</p><p id="25f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，可以通过“importsNotUsedAsValues”标志进一步配置行为。</p><h1 id="560e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="ef1e" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">TypeScript仅类型的导入/导出是该语言的一个有用的补充，允许我们对TypeScript为我们做的事情进行更细粒度的控制，从而允许我们处理一些像这样令人讨厌的“边缘情况”。</p><p id="8e0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，给你一个警告:不要做得太过火；-)</p><p id="8dbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你想学习大量关于TypeScript、Angular、React、Vue和其他酷主题的其他酷东西，那么不要犹豫，去<a class="ae lv" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae lv" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p><p id="c1f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p></div></div>    
</body>
</html>