<html>
<head>
<title>Node.js Tips — Testing Redirects, Sessions, and Auth Middlewares</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—测试重定向、会话和授权中间件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-testing-redirects-sessions-and-auth-middlewares-40d498f2b264?source=collection_archive---------3-----------------------#2020-07-27">https://javascript.plainenglish.io/node-js-tips-testing-redirects-sessions-and-auth-middlewares-40d498f2b264?source=collection_archive---------3-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6448b24150d7c805fc94064a4bd9b183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kP84Qc3I2hMlwGdL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@marcsm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc Sendra Martorell</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="719e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="1080" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express中输入每条路线之前，使用中间件检查授权</h1><p id="744a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在路由中添加一个中间件，在输入路由之前检查是否有正确的凭证。</p><p id="a41c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5296" class="mn lc iq mj b gy mo mp l mq mr">const protectedMiddlewares = [authChecker, fetchUser];<br/>const unprotectedMiddlewares = [trackVisistorCount];</span><span id="1cb8" class="mn lc iq mj b gy ms mp l mq mr">app.get("/", unprotectedMiddlewares, (req, res) =&gt; {<br/>  //...<br/>})</span><span id="8ced" class="mn lc iq mj b gy ms mp l mq mr">app.get("/dashboard", protectedMiddlewares, (req, res) =&gt; {<br/>  // ...<br/>})</span><span id="6407" class="mn lc iq mj b gy ms mp l mq mr">app.get("/auth", unprotectedMiddlewares, (req, res) =&gt; {<br/>  //...<br/>})</span><span id="5ea2" class="mn lc iq mj b gy ms mp l mq mr">app.put("/auth", unprotectedMiddlewares, (req, res) =&gt; {<br/>  //...<br/>})</span></pre><p id="c533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为受保护的<code class="fe mt mu mv mj b">dashboard</code>路线提供了一系列中间件。</p><p id="12e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一系列用于无保护路由的中间件。</p><p id="6acc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">中间件可能如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8830" class="mn lc iq mj b gy mo mp l mq mr">const authChecker = (req, res, next) =&gt; {<br/>  if (req.session.auth || req.path === '/auth') {<br/>    next();<br/>  } else {<br/>    res.redirect("/auth");<br/>  }<br/>}</span></pre><p id="aa7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有检查路由和会话路径的<code class="fe mt mu mv mj b">authChecker</code>中间件。</p><p id="50e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有一个会话集，那么我们调用下一个中间件，这最终会导致一个受保护的路由处理器。</p><p id="55e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们改走<code class="fe mt mu mv mj b">auth</code>路线。</p><h1 id="30f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试在节点中使用Mocha和Supertest重定向的请求</h1><p id="af6b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要测试重定向到另一个路由的请求，并在Mocha测试运行程序中运行Supertest，我们可以编写；</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="108d" class="mn lc iq mj b gy mo mp l mq mr">it('should log out the user', (done) =&gt; {<br/>  request(app)<br/>    .post('/login')<br/>    .type('form')<br/>    .field('user', 'username')<br/>    .field('password', 'password')<br/>    .end((err, res) =&gt; {<br/>      if (err) { return done(err); }<br/>      request(app)<br/>        .get('/')<br/>        .end((err, res) =&gt; {<br/>          if (err) { return done(err); }<br/>          res.text.should.include('profile');<br/>          done();<br/>        });<br/>    });<br/>});</span></pre><p id="234d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过检查第二个<code class="fe mt mu mv mj b">end</code>回调中的响应文本来测试一个<code class="fe mt mu mv mj b">login</code>路由的重定向。</p><p id="0790" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们用用户名和密码发出了一个POST请求。</p><p id="f89c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在重定向完成后调用回调。</p><p id="c150" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从响应中获取文本，看看它是否是<code class="fe mt mu mv mj b">profile</code>路线中的文本。</p><h1 id="e8f5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Express发送附加HTTP标头</h1><p id="bbdd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用response对象的<code class="fe mt mu mv mj b">setHeader</code>方法发送我们想要的任何响应头。</p><p id="82d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b718" class="mn lc iq mj b gy mo mp l mq mr">app.use((req, res, next) =&gt; {<br/>  res.setHeader("Access-Control-Allow-Origin", "*");<br/>  return next();<br/>});</span></pre><p id="d14e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">Access-Control-Allow-Origin</code>设置为<code class="fe mt mu mv mj b">*</code>以允许来自所有来源的请求。</p><h1 id="4d6f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express中使用会话</h1><p id="5152" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在Express应用程序中处理会话，我们可以使用表达式中间件。</p><p id="d10e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6cbe" class="mn lc iq mj b gy mo mp l mq mr">const express = require('express');<br/>const session = require('express-session');</span><span id="42c9" class="mn lc iq mj b gy ms mp l mq mr">const app = express();</span><span id="7d5f" class="mn lc iq mj b gy ms mp l mq mr">app.use(session({<br/>  resave: false,<br/>  saveUninitialized: false,<br/>  secret: 'secret'<br/>}));</span><span id="ad78" class="mn lc iq mj b gy ms mp l mq mr">app.get('/', (req, res) =&gt; {<br/>  if (req.session.views) {<br/>    ++req.session.views;<br/>  } else {<br/>    req.session.views = 1;<br/>  }<br/>  res.send(`${req.session.views} views`);<br/>});</span><span id="3786" class="mn lc iq mj b gy ms mp l mq mr">app.listen(3000);</span></pre><p id="b74e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用了带有几个选项的<code class="fe mt mu mv mj b">express-session</code>包。</p><p id="6dfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">session</code>是一个函数，它返回一个中间件来让我们处理会话。</p><p id="2c8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">resave</code>表示如果会话未被修改，我们不会保存会话，因为它是<code class="fe mt mu mv mj b">false</code>。</p><p id="3822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">saveUninitialized</code>意味着如果是<code class="fe mt mu mv mj b">false</code>，我们不会创建会话，直到有东西被存储。</p><p id="5289" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">secret</code>是签名会话的秘密。</p><p id="9d75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在<code class="fe mt mu mv mj b">req.session</code>属性中存储我们想要的任何数据。</p><p id="f716" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会持续到会话结束。</p><p id="f409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是在到达<code class="fe mt mu mv mj b">/</code>路线时不断增加<code class="fe mt mu mv mj b">views</code>计数。</p><p id="0c78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缺省值是内存存储，只有在没有多个实例的情况下才应该使用它。</p><p id="4f92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们需要使用持久会话。</p><h1 id="f673" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Socket.io获取连接的客户端用户名列表</h1><p id="f8e2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过使用<code class="fe mt mu mv mj b">clients</code>方法，我们可以获得连接到或未连接到名称空间的客户端列表。</p><p id="9d60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="79f8" class="mn lc iq mj b gy mo mp l mq mr">const clients = io.sockets.adapter.rooms[roomId]; <br/>for (const clientId of Object.keys(clients)) {<br/>  console.log(clientId); <br/>  const clientSocket = io.sockets.connected[clientId];<br/>}</span></pre><p id="6bb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到一个对象，用客户端id作为键，用<code class="fe mt mu mv mj b">io.socket.adapter.rooms</code>对象。</p><p id="b2f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">roomId</code>是我们所在房间的ID。</p><p id="259e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe mt mu mv mj b">io.socket.connected</code>对象为客户机获取套接字。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/3997a92b895ee0d42cf4a3703b278e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KQd-FgfGlm7ZNr3n"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jentheodore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jen Theodore</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3ab2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6898" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Socket.io得到客户端。</p><p id="7583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以编写自己的中间件来检查凭证，然后再继续路由。</p><p id="81aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">express-session允许我们在express应用程序中处理会话。</p><p id="6f51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过检查<code class="fe mt mu mv mj b">end</code>回调中的响应内容，用Supertest测试重定向。</p><h1 id="29ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="5f39" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>