<html>
<head>
<title>Internationalization in React Apps using react-intl</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用react-intl在React应用程序中实现国际化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/internationalization-in-react-apps-using-react-intl-1d72a6f14053?source=collection_archive---------0-----------------------#2020-01-28">https://javascript.plainenglish.io/internationalization-in-react-apps-using-react-intl-1d72a6f14053?source=collection_archive---------0-----------------------#2020-01-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cee16a1d3e99a5c9ff0de32e9dbc40e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjFWxpqYjJ6OtV5qEuH-Mg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(a): Internationalization ( credit: <a class="ae jz" href="https://wallpaperaccess.com/map" rel="noopener ugc nofollow" target="_blank">source</a> )</figcaption></figure><h1 id="b14a" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">剧情简介</strong>:</h1><p id="143b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在这篇博客中，我们将研究i18n可用的不同库，选择首选库的原因，库中可用的组件/api及其用法，最后构建单独的翻译库，使其模块化，以便可以跨不同的应用程序使用。</p><p id="f64f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">调查从寻找合适的国际化库开始，该库易于采用，具有强大的社区支持、受欢迎程度、文档和灵活性。我们并不生活在完美的世界中，所以也将列出一些关注点。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/4311389dc16d28e52f1157dc64999c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dsU_aGmy6U1bvF2QF2JsA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(b): goal: abstraction of translation from applications &amp; libraries</figcaption></figure><h1 id="acf9" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">必须有</strong>:</h1><ul class=""><li id="13a2" class="mg mh in la b lb lc lf lg lj mi ln mj lr mk lv ml mm mn mo bi translated">翻译文本应该从代码中提取。即把静态内容从代码库中移走。</li><li id="b75f" class="mg mh in la b lb mp lf mq lj mr ln ms lr mt lv ml mm mn mo bi translated">如果有一个独立的翻译库，开发者和翻译人员都可以参考，那就太好了。</li><li id="9a4a" class="mg mh in la b lb mp lf mq lj mr ln ms lr mt lv ml mm mn mo bi translated">每个应用程序和/或库负责根据地区提供完整的翻译解决方案。</li></ul><p id="d64e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这些必须具备的条件与我们选择的国际化库无关，但是我们决定使用react-intl，因为它支持日期和时间、货币、数字的翻译以及*synopsis中提到的基本要求。我们可以使用的其他有竞争力的翻译库有阿里巴巴的<a class="ae jz" href="https://www.i18next.com/" rel="noopener ugc nofollow" target="_blank"> i18next </a>、LinguiJS、<a class="ae jz" href="https://github.com/alibaba/react-intl-universal" rel="noopener ugc nofollow" target="_blank"> react-intl-universal </a>。</p><h1 id="a510" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">反应-国际:</h1><p id="ec09" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">简要概述一下，<code class="fe mu mv mw mx b">react-intl</code>提供了在react应用程序中实现i18n的声明式和命令式方法。声明性组件易于实现，并且是比命令性低级api更受欢迎的使用方式。然而，在某些情况下，我们只能使用命令式方法(api)进行翻译，因此只能使用替代选项。</p><p id="a208" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">要使用<code class="fe mu mv mw mx b">react-intl</code>，应用程序的根组件需要用<code class="fe mu mv mw mx b">&lt;IntlProvider/&gt;</code>包装，它设置整个应用程序所需的i18n上下文，所以我们需要在这里设置<code class="fe mu mv mw mx b">locale</code>和<code class="fe mu mv mw mx b">messages</code>道具。一旦默认完成，来自react-intl的声明性组件就可用，但是<em class="my">命令性的低级api不可用。然而，每当我们需要低级api时，我们需要用更高级的组件<code class="fe mu mv mw mx b">injectIntl</code>包装<em class="my">相应的</em>组件。这将允许我们通过<code class="fe mu mv mw mx b">intl</code> prop访问这些低级api。(<em class="my">提示</em>:此处注意道具名称<code class="fe mu mv mw mx b">intl</code>)。</em></p><blockquote class="mz na nb"><p id="5acc" class="ky kz my la b lb lw ld le lf lx lh li nc ly ll lm nd lz lp lq ne ma lt lu lv ig bi translated">测试提示:Inject-intl将包装器组件添加到我们定义的组件中，因此一级浅层呈现不会提供对我们组件的访问。</p></blockquote><p id="8dcb" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在我们有了一些了解，我们可以尝试在react应用程序中实现它。</p><h1 id="5d95" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">实施:</strong></h1><p id="a3fb" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">示例应用程序是使用<a class="ae jz" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> CRA </a>创建的，这里是它的<a class="ae jz" href="https://github.com/citta-lab/react-internationalization-exmple/tree/f60d084f2927840162cac3736c5520339bd44148/internationalized-app" rel="noopener ugc nofollow" target="_blank">提交</a>。随着我们的进展，我们将添加和移动翻译到它自己的库中，讨论模块化。让我们从安装<code class="fe mu mv mw mx b">react-intl</code>开始，</p><h2 id="ba95" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">1.<IntlProvider/>:</h2><p id="535c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">一旦我们使用<code class="fe mu mv mw mx b">yarn add react-intl</code>安装了<code class="fe mu mv mw mx b">react-intl</code>。应用程序根组件由i18n上下文提供程序包装，即<code class="fe mu mv mw mx b">&lt;IntlProvider&gt;</code>，我们将在其中添加浏览器检测到的区域设置和翻译的消息。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><blockquote class="mz na nb"><p id="4474" class="ky kz my la b lb lw ld le lf lx lh li nc ly ll lm nd lz lp lq ne ma lt lu lv ig bi translated">到目前为止，翻译文件托管在应用程序中，不同的翻译(英语和西班牙语)由它们的名称空间分开。</p></blockquote><p id="93b2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">为了更好地理解，下面引用了完整的英文翻译文件，并将在整个博客中引用。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="91e7" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">2.<formatted/>:</h2><p id="a134" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，应用程序中的其余组件必须进行修改，以适应<code class="fe mu mv mw mx b">react-intl</code>。如果我们向最终用户显示任何文本、日期、数字等，那么这些组件内容或消息需要用由<code class="fe mu mv mw mx b">react-intl</code>提供的各自的<code class="fe mu mv mw mx b">&lt;Formatted*&gt;</code>组件包装。下面是一个这样的改编的例子，完整的例子你可以检查<a class="ae jz" href="https://github.com/citta-lab/react-internationalization-exmple/tree/f917d6371dcbbb5b3c323c12bd5b8291b0c53495/internationalized-app" rel="noopener ugc nofollow" target="_blank">这个</a>提交。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="02c1" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们为用户添加一些帮助消息，在我们的例子中，我们希望用户知道每个卡片标题的意思，即在<code class="fe mu mv mw mx b">&lt;h3&gt;</code>标签中添加标题。格式化后的代码如下所示，</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ca3d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在的问题是我们如何根据从<code class="fe mu mv mw mx b">IntlProvider</code>传来的地区翻译<code class="fe mu mv mw mx b">titleMessage</code>？</p><h2 id="ad21" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">3.injectIntl():</h2><p id="8f8f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">为了解决这个问题，我们将注意力转移到react-intl提供的命令式api上(在这里阅读更多关于低级api的<a class="ae jz" href="https://github.com/formatjs/react-intl/blob/master/docs/API.md#date-formatting-apis" rel="noopener ugc nofollow" target="_blank"/>)。当我们用<code class="fe mu mv mw mx b">injectIntl</code>高阶组件包装<code class="fe mu mv mw mx b">Card</code>组件时，利用<code class="fe mu mv mw mx b">formatMessage</code>翻译通过props注入上下文的文本。</p><p id="e809" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">让我们更新卡组件以反映我们刚才提到的更改(为了完成实现检查<a class="ae jz" href="https://github.com/citta-lab/react-internationalization-exmple/tree/194b74f0e0ce050ace297edae2198d319d052c90" rel="noopener ugc nofollow" target="_blank">这个</a>提交)，</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4ab5" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">瞧，现在我们可以将鼠标悬停在卡片标题上来查看翻译后的信息。</p><p id="041b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">由于<strong class="la io"> <em class="my"> React 16.8 </em> </strong>我们可以利用钩子来编写功能组件，<code class="fe mu mv mw mx b">react-intl</code>包含了这个钩子实现，因为它是命令式api，并且不需要任何选项。这使得使用起来更加容易和简单，但是<em class="my">只能用在功能组件上</em>。</p><h2 id="bde2" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">4.使用说明:</h2><p id="8ebf" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在本节中，我们将使用<code class="fe mu mv mw mx b">useIntl</code>挂钩代替卡组件示例中的<code class="fe mu mv mw mx b">injectIntl</code> hoc。简而言之，我们不需要用injectIntl包装组件，因此<code class="fe mu mv mw mx b">intl</code>不能作为prop使用。然而翻译所需的<code class="fe mu mv mw mx b">intl</code>由<code class="fe mu mv mw mx b">useIntl()</code>提供。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="060e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这个例子的完整提交可以在<a class="ae jz" href="https://github.com/citta-lab/react-internationalization-exmple/tree/15c51205c78e699dc948061d302ec59f2ad8a92c" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这符合在react应用程序中使用<code class="fe mu mv mw mx b">react-intl</code>的基本思想。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/1cb81966d7f1d61daf16d6b62ea83c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buGFfDn0beHfPruuj2ucEw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">fig(c): summarizing the declarative &amp; imperative api’s</figcaption></figure><blockquote class="mz na nb"><p id="0fe2" class="ky kz my la b lb lw ld le lf lx lh li nc ly ll lm nd lz lp lq ne ma lt lu lv ig bi translated">每当我们必须翻译与<code class="fe mu mv mw mx b">html</code>标签和/或<code class="fe mu mv mw mx b">aria-label</code>属性一起使用的静态文本时，我们就使用命令式api。</p></blockquote><h1 id="e10e" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">翻译:</h1><p id="a728" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">到目前为止，我们一直使用翻译作为我们的 react应用程序的<em class="my">部分，也许我们可以从应用程序代码库中提取它们。通过这样做，我们可以独立于应用程序维护翻译，可以轻松地与翻译团队合作进行任何更新或新的语言添加，有助于防止重复等。</em></p><p id="0006" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这个想法是用所有的翻译创建基本的<code class="fe mu mv mw mx b">npm</code>包，并用不同的解决方案将它们分开。您可能会考虑不按应用程序拆分翻译，但我们希望提供完整的解决方案(以及翻译)，而不是让宿主应用程序为其提供翻译。</p><blockquote class="mz na nb"><p id="8f2d" class="ky kz my la b lb lw ld le lf lx lh li nc ly ll lm nd lz lp lq ne ma lt lu lv ig bi translated"><strong class="la io">示例</strong>:您的react应用程序可能会使用不同团队或公司创建的不同react库(第一个库用于处理由“a”团队创建的用户会话，第二个库由“b”团队创建，用于下订单)。然后，一种方法是让react应用程序为所有消费库提供翻译。</p></blockquote><p id="a001" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">重新构建的新翻译库如下所示，如果消费应用程序对从库中获取所有英语翻译感兴趣，他们可以通过访问<code class="fe mu mv mw mx b">/translation-lib/bylang/en.js</code>来实现</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4dd4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们的应用程序的<code class="fe mu mv mw mx b">index.js</code>被更改为使用来自<code class="fe mu mv mw mx b">translation-lib</code>的翻译。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7f2b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果你已经厌倦了这个，但是还想看看其他的国际化库，那就去看看维克多·舍甫琴科在i18next上的博客。</p><h1 id="8d3b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">区域设置:</h1><h2 id="b967" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">1.浏览器检测:</h2><p id="f513" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在我们示例应用程序中，我们已经手动设置了区域设置，并将其作为属性传递给了<code class="fe mu mv mw mx b">&lt;IntlProvider/&gt;</code>，但是在实际应用程序中，我们可能需要自动处理这一点。一种这样的方式是从浏览器进行检测，</p><pre class="mc md me mf gt nu mx nv nw aw nx bi"><span id="5ed6" class="nf kb in mx b gy ny nz l oa ob">var locale = (navigator.languages &amp;&amp; navigator.languages[0]) || navigator.language || navigator.userLanguage || 'en-US';</span></pre><p id="c8fb" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">请注意，如果我们未能检测到浏览器的区域设置，我们将退回到英语(即en-US)。如果我们在一个库(而不是一个应用程序)中实现它，那么我们会希望应用程序设置locale prop，并且消费库会遵守它。下面是示例应用程序中更新后的index.js示例。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="87bc" class="nf kb in bd kc ng nh dn kg ni nj dp kk lj nk nl ko ln nm nn ks lr no np kw nq bi translated">2.默认消息:</h2><p id="28cc" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们已经在<code class="fe mu mv mw mx b">&lt;Formatted*/&gt;</code>组件中使用了<code class="fe mu mv mw mx b">defaultMessage</code> prop，以在区域检测失败或id丢失的情况下提供回退消息。这是<code class="fe mu mv mw mx b">react-intl</code>团队推荐的方式。</p><blockquote class="mz na nb"><p id="dc4a" class="ky kz my la b lb lw ld le lf lx lh li nc ly ll lm nd lz lp lq ne ma lt lu lv ig bi translated">默认情况下在源中保留默认消息的主要原因是为了让UI可以回退到不依赖于网络请求的东西(这是人们加载区域数据的常见方式。)—埃里克·费拉约洛</p></blockquote><p id="dd47" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">然而，从代码中保留翻译信息有它自己的好处，同时维护/更新翻译，而不是膨胀代码库等。我能想到两种方法，我更喜欢后一种。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c036" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">通过这样做，我们将需要在所有组件中导入英语翻译文件，并用各自提取的英语翻译(基于id)替换静态文本。另一种方法是在用<code class="fe mu mv mw mx b">&lt;IntlProvider/&gt;</code>包装应用程序的根时立即处理这个问题。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="f6b0" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">缺点:</h1><ol class=""><li id="b2ab" class="mg mh in la b lb lc lf lg lj mi ln mj lr mk lv oc mm mn mo bi translated"><code class="fe mu mv mw mx b">react-intl</code>的解压缩大小几乎是1.1MB，而<code class="fe mu mv mw mx b">i18next</code>大约是481KB。</li><li id="864e" class="mg mh in la b lb mp lf mq lj mr ln ms lr mt lv oc mm mn mo bi translated">如果我们决定不在声明性组件中使用<code class="fe mu mv mw mx b">defaultMessage</code>，需要处理一种提供默认翻译的方法。</li><li id="6274" class="mg mh in la b lb mp lf mq lj mr ln ms lr mt lv oc mm mn mo bi translated"><code class="fe mu mv mw mx b">react-intl</code>不喜欢嵌套的json结构，所以翻译id必须是一级名称空间。举例:<code class="fe mu mv mw mx b">"card.welcome.title"</code> vs <code class="fe mu mv mw mx b">"card":{ "welcome": { "title": " " }}</code></li><li id="21a1" class="mg mh in la b lb mp lf mq lj mr ln ms lr mt lv oc mm mn mo bi translated"><code class="fe mu mv mw mx b">injectIntl</code>添加一个包装组件，因此在测试一个级别时，浅渲染将无法访问所需的组件。</li></ol><h1 id="ef25" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">最后:</strong></h1><p id="064d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们应该翻译每个用户可见的字符串。例如工具提示、警告消息、标题、文本等。简而言之，申请表上出现的任何东西都应该被翻译。</p><p id="6562" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">完成github 项目库。</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><p id="9a91" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我之前的三篇博客:</p><ol class=""><li id="179d" class="mg mh in la b lb lw lf lx lj ok ln ol lr om lv oc mm mn mo bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/react-onchange-with-input-field-button-854f0035b94a" rel="noopener">对输入字段的变化做出反应&amp;按钮</a></li><li id="e632" class="mg mh in la b lb mp lf mq lj mr ln ms lr mt lv oc mm mn mo bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/inner-workings-of-map-reduce-filter-f06ba87f2509" rel="noopener">Map的内部工作方式，减少JavaScript中的&amp;过滤器</a></li><li id="5d79" class="mg mh in la b lb mp lf mq lj mr ln ms lr mt lv oc mm mn mo bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/thinking-in-react-manage-user-interaction-in-react-apps-611074e004b8" rel="noopener">在React中思考:在React应用中管理用户交互</a></li></ol></div></div>    
</body>
</html>