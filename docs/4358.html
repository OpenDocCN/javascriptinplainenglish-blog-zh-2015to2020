<html>
<head>
<title>Create Editable HTML in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中创建可编辑的HTML</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/editable-html-in-react-6dd67dd7e302?source=collection_archive---------0-----------------------#2020-12-06">https://javascript.plainenglish.io/editable-html-in-react-6dd67dd7e302?source=collection_archive---------0-----------------------#2020-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/bee82a825ec5821d6e546769bbf8d830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icSV8kFVLCaPk9iwrhBenw.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@xpsteven?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steven Su</a> on <a class="ae ja" href="https://unsplash.com/s/photos/iran?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="d3a1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们正在为我们在<a class="ae ja" href="https://www.alida.com/alida-touchpoint" rel="noopener ugc nofollow" target="_blank">接触点</a>的构建器开发内联编辑器。作为内联编辑器的一部分，用户应该能够编辑组件的样式和文本。例如，改变一个按钮的颜色和文字，内嵌！</p><p id="bc0e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去的两个星期里，我一直在思考我们如何才能拥有一个可编辑的组件？🤔我总结了三个解决方案，我喜欢其中的一个，我想在这篇文章中与你分享。</p><h1 id="b3d9" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使内容在HTML中可编辑</h1><p id="71aa" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">有一个HTML属性可以传递给任何HTML标签，使其可编辑。如果你为几乎所有的HTML标签设置了<code class="fe mb mc md me b">contenteditable=true</code>，标签将会变成可编辑的！</p><p id="d0f0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里你可以看到一个例子:</p><figure class="mg mh mi mj gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mf"><img src="../Images/100bd0156b5ecdcfb2f21be336963a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bJfEeBbi94lDXeTEEF0Jug.gif"/></div></div></figure><p id="4d2a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里了解更多:<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Editable_content" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Guide/HTML/Editable _ content</a></p><h1 id="fa5f" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe mb mc md me b">contentEditable</code>道具在反应</h1><p id="1f6c" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我们看如何在React中使用它之前，我想说的是，当你在React中使用它时，你应该非常小心。当你添加<code class="fe mb mc md me b">contentEditable=true</code>到一个组件时，你会看到一个来自React的警告:<em class="mk">警告:一个组件是“内容可编辑的”并且包含React管理的“子组件”。现在，您有责任保证这些节点不会被意外修改或复制。这大概不是故意的。</em></p><p id="eb0d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个警告意味着从此React不再控制这些组件，并且可能会发生许多意想不到的错误。因此，确保我们正在做的事情没有任何副作用，不会给我们的应用程序的其余部分带来问题，这真的取决于我们。您可以在这个<a class="ae ja" href="https://stackoverflow.com/questions/49639144/why-does-react-warn-against-an-contenteditable-component-having-children-managed" rel="noopener ugc nofollow" target="_blank"> StackOverflow问题</a>中了解更多关于此警告的信息。</p><p id="635e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要关闭该警告(假设我们知道自己在做什么并能控制它)，我们可以将<code class="fe mb mc md me b">suppressContentEditableWarning=true</code>传递给我们的组件来关闭该警告。所以基本上像这样的组件在React中是可编辑的:</p><pre class="mg mh mi mj gt ml me mm mn aw mo bi"><span id="6134" class="mp kz jd me b gy mq mr l ms mt">const EditableDiv = () =&gt; {<br/>  return (<br/>    &lt;div contentEditable={true} suppressContentEditableWarning={true}&gt;Awesome Div!&lt;/div&gt;</span><span id="d8c4" class="mp kz jd me b gy mu mr l ms mt">  )</span><span id="30e7" class="mp kz jd me b gy mu mr l ms mt">}</span></pre><h1 id="99f7" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更通用的解决方案</h1><p id="8161" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我的理想世界中，我不想把道具添加到每个组件中，然后做所有的检查和逻辑来听变化，我想有一个更通用的解决方案，我可以在我们的应用程序中使用。<br/>以下是我的解决方案:</p><pre class="mg mh mi mj gt ml me mm mn aw mo bi"><span id="768a" class="mp kz jd me b gy mq mr l ms mt">const EditableElement = (props) =&gt; {<br/>  const { onChange } = props;<br/>  const element = useRef();<br/>  let elements = React.Children.toArray(props.children);<br/>  if (elements.length &gt; 1) {<br/>    throw Error("Can't have more than one child");<br/>  }<br/>  const onMouseUp = () =&gt; {<br/>    const value = element.current?.value || element.current?.innerText;<br/>    onChange(value);<br/>  };<br/>  useEffect(() =&gt; {<br/>    const value = element.current?.value || element.current?.innerText;<br/>    onChange(value);<br/>  }, []);<br/>  elements = React.cloneElement(elements[0], {<br/>    contentEditable: true,<br/>    suppressContentEditableWarning: true,<br/>    ref: element,<br/>    onKeyUp: onMouseUp<br/>  });<br/>  return elements;<br/>};</span></pre><p id="e069" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上我想做的就是把我的组件包装在这个组件里面，然后准备好！</p><p id="fc2e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们一起来复习一下代码。这个想法是我们传递一个<code class="fe mb mc md me b">ref</code>给我们的包装组件，用一个事件监听器让<code class="fe mb mc md me b">onKeyUp</code>监听任何键盘事件。有一个<code class="fe mb mc md me b">onChange</code>道具，我们可以传递给这个组件，它作为一个回调函数工作，所以每次有变化它都会被调用。</p><p id="eb64" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一些初始检查来确保我们没有接受一个以上的组件(也有一些方法来处理这种情况，但是对于我们的用例来说，一个组件就足够了)。(如果你不熟悉React顶级API，你可以在文档的<a class="ae ja" href="https://reactjs.org/docs/react-api.html" rel="noopener ugc nofollow" target="_blank">这一部分找到更多细节)。</a></p><p id="c707" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们使用了两个顶级API:</p><p id="c83b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">做出反应。children . to array(props . children):</strong>它将<code class="fe mb mc md me b">props.children</code>转换为一个数组。</p><p id="1443" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je"> React.cloneElement: </strong>你可以传递一些新的道具给React组件。如果你感兴趣，你可以<a class="ae ja" href="https://frontarm.com/james-k-nelson/passing-data-props-children/" rel="noopener ugc nofollow" target="_blank">阅读这篇文章了解更多信息</a>。</p><p id="f9b8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je"> <em class="mk">免责声明:</em> </strong> <em class="mk">使用React定制钩子、高阶组件和所有这些工具，还有许多其他方法来实现这个功能。</em></p><p id="15b6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在确保我们只包装了一个孩子之后，我们将一个<code class="fe mb mc md me b">ref</code>、<code class="fe mb mc md me b">onKeyUp</code>和<code class="fe mb mc md me b">contentEditable</code>传递给我们的组件，使其可编辑。</p><p id="ff2b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是如何使用该组件的示例:</p><pre class="mg mh mi mj gt ml me mm mn aw mo bi"><span id="5e03" class="mp kz jd me b gy mq mr l ms mt">export default function App() {<br/>  const initialValue = "value";<br/>  const [value, setValue] = useState(initialValue);<br/>  const handleChange = (value) =&gt; {<br/>    setValue(value);<br/>  };<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;EditableElement onChange={handleChange}&gt;<br/>        &lt;div style={{ outline: "none" }}&gt;<br/>          &lt;p&gt;{initialValue}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>      &lt;/EditableElement&gt;<br/>      &lt;label&gt;{value}&lt;/label&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="072f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">提醒您，当您在React中使用此组件或可编辑组件时，您应该小心，并确保不会给您的应用程序带来任何问题。例如，在我们的用例中，我们只将想要编辑其文本的组件包装在这个组件中。</p><p id="22f2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个完整的例子:</p><figure class="mg mh mi mj gt ip"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="501b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你喜欢这篇文章！我希望听到你的反馈，如果你有其他方法来实现这个功能，请在评论中分享！</p><p id="f97c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意安全！<br/> <a class="ae ja" href="https://www.linkedin.com/in/mostafa-darehzereshki/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc je"> <em class="mk">莫斯塔法</em> </strong> </a></p></div></div>    
</body>
</html>