<html>
<head>
<title>How to mercilessly refactor your JavaScript code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何无情地重构您的JavaScript代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/refactoring-code-in-javascript-707cf5f18bf6?source=collection_archive---------2-----------------------#2020-07-11">https://javascript.plainenglish.io/refactoring-code-in-javascript-707cf5f18bf6?source=collection_archive---------2-----------------------#2020-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6ba3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">几次，让你的JS更上一层楼</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/42e93e4a506e53cabd6d4dd71e1c95e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_2XY3hclQZ1-_rVa.jpg"/></div></div></figure><p id="2fe5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在本文中，我将回顾我多年来积累的一些实践，以编写良好且可维护的代码。</p><h1 id="cf4d" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">使用干的</h1><p id="e08d" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><strong class="kq io">不要重复自己</strong>是一个旨在减少代码重复的原则，用抽象代替代码以避免冗余。复制代码总是以混乱告终。如果你在某个地方修复了一个bug，你需要多次重新打补丁。拥有更少和非冗余的代码可以节省时间并提高可维护性。</p><p id="91ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个知识或逻辑在系统中必须有一个单一的、明确的表示。</p><p id="9aa8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，我得到了不同类型教程的材料，并为每种类型的教程复制了代码。现在想想如果我想要20种不同类型的教程会发生什么。我会写这个函数20次吗？不要！那么，现在该如何重构这段代码呢！？</p><p id="e3c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们没有考虑到代码的可伸缩性时，就会发生这种情况。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="863c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">答案很简单，只需在一个单独的函数中取出业务逻辑，然后通过传递type属性来调用该函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="22f6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">好处— </strong>让ES6数组函数的代码更具可读性。<strong class="kq io">仅仅4行代码。一个简单的重构可以大大减少你的代码库。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="f6d3" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated"><strong class="ak">使用功能绑定</strong></h1><p id="42c6" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">现实世界中的一些对象具有相同的功能，例如printName函数对于一个公司、一个人或任何其他事物都是相同的。因此，我们可以使用<code class="fe mk ml mm mn b">bind()</code>并使用这个函数绑定我们的对象，而不是创建附加到一个对象的单独方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5a39" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在使用了<code class="fe mk ml mm mn b">bind()</code>之后，我们只是创建printName()函数并用不同的对象多次调用它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="db31" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated"><strong class="ak">避免开关语句</strong></h1><p id="fca0" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们使用Switch语句来避免使用大型if-else语句。然而，Switch语句很难调试，也不是很简洁，而且我觉得它们的语法非常混乱。当添加更多案例时，我们必须手动添加它们，并放置Break语句。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3f27" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我们可以使用<code class="fe mk ml mm mn b">Object Literal.</code>来重构我们的代码，我们都知道JavaScript中的对象，并且语法非常易于维护和扩展。这次我们不需要手动创建案例。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="166e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如你所见，我们减少了多少代码行。而且现在超级简洁易读。我们也可以在这里使用枚举、接口或映射。</p><h1 id="1a5a" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated"><strong class="ak">使用Guard子句避免深度嵌套</strong></h1><p id="c345" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">这是我多次犯下的罪行之一。我曾经有深度嵌套的if-else语句和不必要的日志记录语句。有时候，我们不需要记录所有的事情，这是我从惨痛的教训中学到的。</p><p id="0a2a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">深度嵌套的<strong class="kq io">T2条件使得几乎不可能说出什么代码将运行，或者<strong class="kq io">何时</strong>。在这个例子中，我创建了一个深度为- <strong class="kq io"> 4的嵌套if-else。</strong></strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4bc5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你需要几分钟来阅读代码，了解函数的流程。编写这段代码的更好方式是，如果反向条件失败，并且没有继续执行流程，则使用防护来抛出错误，从而反向执行代码。例如，我们可以设置一个检查，如果用户没有登录，我们应该停止执行并从函数返回。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="7806" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">开闭原理</h1><p id="fdeb" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">开闭原则意味着类应该对扩展开放，但对修改关闭。</p><p id="a4bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果有人想扩展我的模块的行为，他们不应该觉得有必要修改现有的代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="bd1a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个例子中，如果我想清洗一辆新型汽车，我不能这样做，因为我没有权限在我想使用它的对象上使用它。如果我想洗一辆新型汽车，那么我必须改变这个文件的代码，因此，这将违反开闭原则。</p><p id="591c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在考虑下面的例子，我们可以添加一个新的函数<code class="fe mk ml mm mn b">addCar()</code>来扩展这个函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="a8f9" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">用什么隐藏</h1><p id="283e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated"><strong class="kq io">单一责任原则规定<em class="mh">职能部门应该做一件事情，并且只做一件事情。</em>T12】</strong></p><p id="7114" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">做多件事的函数很难调试和测试。</p><p id="61f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">每个人都知道软件开发中的单一责任原则。但是当编写代码时，我们有时会忘记遵循它，最终会编写出一个非模块化的、混乱的代码。</p><p id="b4e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们不应该把所有的代码都写在一个函数中，而是应该记住把它分成不同的模块。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="1dc3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">希望，你学到了一些东西，这将有助于你写高质量的代码，并会减少你的代码库。尽管如此，重构的目的并不是用更少的代码行来编写代码，而是让代码具有可读性、可维护性和可伸缩性。</p></div></div>    
</body>
</html>