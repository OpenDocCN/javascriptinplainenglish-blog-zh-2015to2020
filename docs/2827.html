<html>
<head>
<title>Decoding Data Structures with Dogs: Singly Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用狗解码数据结构:单链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/decoding-data-structures-with-dogs-singly-linked-lists-9f6def049c4a?source=collection_archive---------10-----------------------#2020-07-27">https://javascript.plainenglish.io/decoding-data-structures-with-dogs-singly-linked-lists-9f6def049c4a?source=collection_archive---------10-----------------------#2020-07-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2a95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">学习JS的所有细节可能会让人不知所措，尤其是当一个人开始处理数据结构时。在这个系列中，我将尝试分解一些基础知识，从单链表开始，用狗的图片来减轻我们的痛苦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/92fe448fcf664d43135ed95f3ccf932d.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*3VztCeQqppft6WWzMX5KXQ.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">In an array, elements are indexed based on their position.</figcaption></figure><p id="64b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为程序员新手，我们学习使用的第一个数据结构是数组。概括地说，数组是一个项的列表，这些项根据它们在数组中的位置被赋予一个索引或一个数值。想象一个像楼梯一样的阵列，每个台阶上都有一个可爱的木偶。每一步都有一个值，我们可以通过计算他们所处的步骤来找到他们。第一只小狗在底部，还不是一个台阶，所以我们给它的值或索引为0，下一只小狗在第一个台阶上，所以它的索引为1。</p><p id="35b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链表</strong>有点不同。不是每个pup(或节点，而不是元素)都有一个索引，而是每个节点都指向下一个节点。把它想象成一列火车，每节车厢与下一节车厢相连，下一节车厢又与下一节车厢相连，以此类推。在数组中，我们可以说“给我第六个pup”，但是在链表中，我们必须从火车的开头开始，从第一节车厢到第二节车厢，等等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ku"><img src="../Images/d27651eee00c74e2f78483dbe60f8011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iuBvBXeST5XFo4HYxrEnw.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">In a linked list, each node is connected to the next, like a train!</figcaption></figure><p id="07e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链表中的每个节点都有一个值，以及一个指向另一个节点的指针，否则如果它在列表的末尾就指向null。</p><p id="053e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链表有3个属性:</p><ul class=""><li id="7a81" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated"><em class="li">头- </em>名单的开始</li><li id="3cb4" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated"><em class="li">尾- </em>列表结束</li><li id="3b4c" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated"><em class="li">长度</em> -头部和尾部之间的长度</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lo"><img src="../Images/099e84cdafea91ec46da108c8bc222e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2N4PsUfbfk1QduGm-oVARw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">We can’t pet one pup without petting all the pups!</figcaption></figure><p id="1d23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么为什么要使用链表而不是数组呢？数组元素似乎比列表节点更容易访问，对吗？因为数组是索引的，所以插入和删除在内存方面会非常昂贵。<strong class="jm io"> </strong>数组支持直接访问，这意味着所有的元素都存储在一个连续的内存块中，这使得我们可以很容易地获取我们想要的任何随机元素，但会占用更多的内存。如果我们想向数组中添加一个元素，数组中的所有其他元素都必须被重新索引，根据数组周围的内存大小，整个数组可能都必须在内存中重新定位。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lp"><img src="../Images/422d8f4c771f8d2fa3e3e9eb7c0e2849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygHfN-1ZUsW0DwQmvMWfEQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">All elements in an array are stored in a continuous block of memory.</figcaption></figure><p id="6dbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链表支持顺序访问，这意味着节点可以存储在内存中的任何地方，但是没有索引，只有指向下一个节点的指针。这意味着在链表中添加和删除节点的速度要比数组快得多，并且分配给链表其余部分的内存不需要重新定位，只要内存中有空间，就可以创建新的节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lq"><img src="../Images/7db9b63c22a0cf76995d5e9dd2084ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mx-gPQtyiKuKPXdHEx7yg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Nodes can be stored anywhere in memory, and are connected together by pointers.</figcaption></figure></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="23c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">单链表</strong> <strong class="jm io">的设置和设计相当简单。</strong>我们将使用Javascript类来演示这一点，所以如果你不熟悉JS类，请查看这里的文档<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"/>。链表最重要的部分是节点的构造方式:每个节点都需要某种类型的数据，以及指向下一个节点的指针。我们将从创建一个节点类开始，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="06a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">data属性包含我们希望列表存储的任何内容，next属性是我们将用来访问列表中下一个节点的内容。我们最初将next设置为null，因为我们还不知道下一个节点是什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="01c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将链表中的第一个节点称为head，因此我们创建了<code class="fe mb mc md me b">head</code>变量来表示第一个节点。然后，我们能够通过使用下一个指针来创建后续节点，以指示它们是下一个链接。列表中的最后一个<code class="fe mb mc md me b">next</code>指针仍然是<code class="fe mb mc md me b">null</code>。</p><p id="7bea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们设置链表的下一步是创建一个linked list类，这样我们就可以稍微清理一下，这样我们就不必在每次想要向链表添加新节点时都添加<code class="fe mb mc md me b">next</code>指针。让我们从定义类和添加构造函数开始。记住，单链表总是接受几个东西:头部、尾部和长度。所以我们可以添加这些作为我们的属性。我们将头部和尾部都设置为<code class="fe mb mc md me b">null</code>来开始，因为我们还没有传入任何东西，并且还将长度设置为0。现在我们的构造函数完成了，我们可以传入一堆方法，实际上开始利用我们的单链表！</p><p id="2370" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的<code class="fe mb mc md me b">push</code>函数需要完成以下工作:</p><ul class=""><li id="a5df" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">接受一个值作为参数</li><li id="ec29" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated">用所述值创建一个新节点</li><li id="2dab" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated">如果还没有head属性，则将该值指定为head和tail，</li><li id="a834" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated">否则，将当前尾部的下一个属性设置为新节点</li><li id="a753" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated">将新节点设置为新尾部</li><li id="171e" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated">将长度增加1</li><li id="661e" class="kz la in jm b jn lj jr lk jv ll jz lm kd ln kh le lf lg lh bi translated">归还名单</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c356" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先将我们的<code class="fe mb mc md me b">new Node</code>赋给一个变量，在这种情况下我称之为<code class="fe mb mc md me b">newNode.</code>，然后我们检查是否没有头部，如果没有，那么将头部和尾部都赋给<code class="fe mb mc md me b">newNode.</code>，否则，如果有头部，那么将尾部赋给<code class="fe mb mc md me b">newNode.</code>，然后我们增加长度，并返回列表。</p><p id="37f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当我们向我们的push方法发送一个值时，我们得到了相同的结果，并且不必跟踪我们有多少个<code class="fe mb mc md me b">next</code>指针。此SinglyLinkedList类创建以下数据结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mf"><img src="../Images/fff5d2a70e9a0e31f33aa63e11bfa4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58ZiZ9xCT4GvIDpyX3r7zA.png"/></div></div></figure><p id="1da6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为开发人员，数据结构可能会让我们难以理解，但是分解它们(用狗)至少会有一点帮助！</p><h2 id="0f10" class="mg mh in bd mi mj mk dn ml mm mn dp mo jv mp mq mr jz ms mt mu kd mv mw mx my bi translated">简单英语的JavaScript</h2><p id="0430" class="pw-post-body-paragraph jk jl in jm b jn mz jp jq jr na jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ly" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jm io">！</strong></p></div></div>    
</body>
</html>