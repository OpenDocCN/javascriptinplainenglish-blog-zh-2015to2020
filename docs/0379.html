<html>
<head>
<title>Algorithms 101: best time to buy and sell stock in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:用JavaScript买卖股票的最佳时机</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-best-time-to-buy-and-sell-stock-in-javascript-7a2249b29495?source=collection_archive---------1-----------------------#2019-09-30">https://javascript.plainenglish.io/algorithms-101-best-time-to-buy-and-sell-stock-in-javascript-7a2249b29495?source=collection_archive---------1-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b934" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉LeetCode，第8集，数组操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ce14681c409bd28713a3c59cde501c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tz18n1AReRLLMtUbr0jR0A.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@chrisliverani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Chris Liverani</a> on <a class="ae kv" href="https://unsplash.com/s/photos/stock-trading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="58f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在阅读LeetCode“简单”类别中的顶级面试问题时，我发现了这个问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/9493b49bd2c9590a473c61c9e56f0d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OdOfyfAvCtRrTdiSzv0gw.png"/></div></div></figure><p id="2994" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的第一个方法是这样的。对于数组中的每个数字——我们称之为<em class="lt">买入</em>——找到右边最大的元素——我们称之为<em class="lt">卖出。I </em> f卖出低于买入，让我们从买入中减去卖出，称结果为<em class="lt">盈利</em>。</p><p id="189b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，我们将有另一个名为<em class="lt"> maxProfit </em>的变量，它从零开始。在每个循环结束时，如果利润大于<em class="lt">最大利润</em>，那么我们将设置<em class="lt">最大利润</em>等于利润。如果这让你感到困惑，我会把它分成以下几个步骤。</p><h1 id="be0f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">第一步。迭代，同时跟踪索引</h1><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="d551" class="mr lv iq mn b gy ms mt l mu mv">var maxProfit = function(prices) {<br/>   let profit<br/>   let maxProfit = 0<br/>   <br/>   prices.forEach(function(buy, index) {<br/>       // more code here<br/>   })  <br/>    return maxProfit    <br/>};</span></pre><h1 id="1b1b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">第二步。在右边创建一个新的元素子数组</h1><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="1b32" class="mr lv iq mn b gy ms mt l mu mv">let rest = prices.slice(index + 1)<br/>//it's index + 1 because we want all elements to the right ...</span></pre><h1 id="124d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">第三步。找出子数组中最大的数字</h1><p id="d1e6" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">但是…如果我们在看数组的最后一个元素，那么<code class="fe nb nc nd mn b">rest = []</code>。为了说明这种边缘情况，让我们首先检查一下<em class="lt"> rest </em>是否不为空。我们将使用javaScript的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max" rel="noopener ugc nofollow" target="_blank"> Math.max() </a>来查找最大值。我们会在出售时保存价值。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="e8e2" class="mr lv iq mn b gy ms mt l mu mv">if(rest){<br/>    let sell = Math.max(...rest)<br/>}</span></pre><h1 id="c032" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">步骤四。计算利润</strong></h1><p id="8930" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">如果卖出大于买入(按照挑战规则的要求)，我们可以这样计算利润:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="619a" class="mr lv iq mn b gy ms mt l mu mv">if (sell &gt; buy){<br/> profit = sell — buy<br/> }</span></pre><h1 id="4e9b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">第五步。检查利润是否大于最大利润</h1><p id="db0c" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">对于每一笔购买，我们都在计算利润。我们从零开始获取最大利润。现在，在我们的循环中，我们需要比较两者，并且总是将较大的值分配给<em class="lt"> maxProfit </em>:</p><p id="c945" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd mn b">profit &gt; maxProfit ? maxProfit = profit : null</code></p><p id="19f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在循环结束时，我们返回<em class="lt"> maxProfit </em>:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="6226" class="mr lv iq mn b gy ms mt l mu mv">var maxProfit = function(prices) {<br/>   let profit<br/>   let maxProfit = 0<br/>   <br/>   prices.forEach(function(buy, index) {<br/>       let rest = prices.slice(index + 1)       <br/>       if (rest){<br/>         let sell = Math.max(...rest)      <br/>           sell &gt; buy ? profit = sell - buy : null<br/>            profit &gt; maxProfit ? maxProfit = profit : null    <br/>     }     <br/>   })  <br/>    return maxProfit    <br/>};</span></pre><p id="3468" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有用！但是它的表现如何呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">can you say SLoooooooooooowwwwwwww ….?</figcaption></figure><p id="6e3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们是倒数5%的人！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/f4fa93d48dead0b833b547d3caff2c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JL6dS7brRs0JAw6IFoU4hw.png"/></div></div></figure><p id="3f0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么？因为我们有嵌套循环——for循环中的if循环，更不用说每个嵌套循环的两个三元运算了。</p><h1 id="893a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">我们需要不同的方法！</h1><p id="6216" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我们的第一个方法是将数组分成两个数组，一个嵌套在另一个中。这次，我们只迭代一次。我们仍然会为maxProfit设置一个初始值。我们还将为min 设置一个初始值(最小值，即最低价格)。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="a258" class="mr lv iq mn b gy ms mt l mu mv">var maxProfit = function(prices) {<br/>    let maxProfit = 0;<br/>    let min = prices[0];<br/>    for(let i = 1; i &lt; prices.length; i++) {<br/>    // more code here<br/>    }<br/>}</span></pre><p id="08e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们迭代时，我们将把我们最近的<em class="lt"> min </em>值与下一个元素进行比较，并将这两个值中较小的一个设置为<em class="lt"> min </em>的新值。我们使用javaScript的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min" rel="noopener ugc nofollow" target="_blank"> Math.min() </a>。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="742c" class="mr lv iq mn b gy ms mt l mu mv">const prices = [7,1,5,3,6,4]<br/>min = Math.min(prices[i], min);<br/>        //i = 1, min = Math.min(1,7) =&gt; 1</span></pre><h1 id="5c70" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">跟踪利润</h1><p id="a5a0" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在同一个循环中，我们还更新最大利润，我们将它定义为<em class="lt"> maxProfit </em>的前一个值，或者当前价格减去<em class="lt"> min </em>。</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="5ee4" class="mr lv iq mn b gy ms mt l mu mv">maxProfit = Math.max(maxProfit, prices[i] - min);</span></pre><p id="57c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面看看这些值在每次循环后是如何更新的:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="4fff" class="mr lv iq mn b gy ms mt l mu mv">const prices = [7,1,5,3,6,4]</span><span id="edc1" class="mr lv iq mn b gy nh mt l mu mv">for(let i = 1; i &lt; prices.length; i++) {</span><span id="0bc8" class="mr lv iq mn b gy nh mt l mu mv">        min = Math.min(prices[i], min);<br/>        //i = 1, lowestPrice = Math.min(1,7) =&gt; 1<br/>        //i = 2, lowestPrice = Math.min(5,1) =&gt; 1<br/>        //i = 3, lowestPrice = Math.min(3,1) =&gt; 1<br/>        //i = 4, lowestPrice = Math.min(6,1) =&gt; 1<br/>        //i = 5, lowestPrice = Math.min(4,1) =&gt; 1</span><span id="b175" class="mr lv iq mn b gy nh mt l mu mv">        maxProfit = Math.max(maxProfit, prices[i] - min);<br/>        //i = 1, Math.max(0, 1 - 1) =&gt; 0<br/>        //i = 2, Math.max(0, 5 - 1) =&gt; 4<br/>        //i = 3, Math.max(4, 3 - 1) =&gt; 4<br/>        //i = 4, Math.max(4, 6 - 1) =&gt; 5<br/>        //i = 5, Math.max(5, 4 - 1) =&gt; 5<br/>    }</span></pre><p id="435b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在一起:</p><pre class="kg kh ki kj gt mm mn mo mp aw mq bi"><span id="8747" class="mr lv iq mn b gy ms mt l mu mv">const maxProfit = function(prices) {<br/>    let maxProfit = 0;<br/>    let lowestPrice  = prices[0];<br/>    for(let i = 1; i &lt; prices.length; i++) {<br/>        min = Math.min(prices[i], min);<br/>        maxProfit = Math.max(maxProfit, prices[i] - min);<br/>    }<br/>    return maxProfit;<br/>};</span></pre><p id="6ab3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有用！这次我们只使用了一个循环，外加Math.max()和Math.min():</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/66883dc25a7aa751c7c4023bd2ba1346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jofGRsLrFVN7ZPaxgZfyTw.png"/></div></div></figure><p id="7e02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@joanrigdon/algorithms-101-jewels-and-stones-in-ruby-and-javascript-c22fce37ad2b" rel="noopener"> <em class="lt">接下来:算法101，#9:红宝石和JS中的宝石</em> </a></p><p id="b31b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/algorithms-101-best-time-to-buy-and-sell-stock-in-javascript-7a2249b29495" rel="noopener"> <em class="lt">以防你错过:算法101，# 7:JavaScript中的入室抢劫犯</em> </a></p><p id="2171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">版权所有琼·印第安纳·琳斯2019</p></div></div>    
</body>
</html>