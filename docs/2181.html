<html>
<head>
<title>Read File Line by Line as Data Stream | Deno By Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将文件作为数据流逐行读取</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/read-file-line-by-line-as-data-stream-deno-by-example-18fb340c9e1c?source=collection_archive---------6-----------------------#2020-05-27">https://javascript.plainenglish.io/read-file-line-by-line-as-data-stream-deno-by-example-18fb340c9e1c?source=collection_archive---------6-----------------------#2020-05-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1fba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Deno</code>提供多个API读取文件。您可以使用<code class="fe ki kj kk kl b">Deno.readAll</code>和<code class="fe ki kj kk kl b">Deno.readTextFile</code>读取整个文件。然而，逐行阅读在<code class="fe ki kj kk kl b">std</code>库中仍然不可用。在本教程中，我将解释如何逐行(流)读取整个文件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7efdf03bc47a594185ba60a27761a5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L2RkHW8ALvGhjj7L.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Google</figcaption></figure><p id="6342" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在进入实际代码之前，让我们先通过例子了解一下标准库。</p><p id="bd92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Deno提供了<code class="fe ki kj kk kl b">Deno.open</code> API来打开文件。这是异步API。意思，你需要<code class="fe ki kj kk kl b">await</code>。作为回报，你会得到包含<code class="fe ki kj kk kl b">rid</code>的<code class="fe ki kj kk kl b">File</code>。</p><h2 id="40f3" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">样本:打开文件<a class="ae lv" href="https://deepakshrma.github.io/deno-by-example/advance_readline/#sample-open-file" rel="noopener ugc nofollow" target="_blank"> # </a></h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="a94c" class="lc ld in kl b gy ma mb l mc md">// examples/06_readfile_chunk.ts<br/>async function main(name?: string) {<br/>  if (name) {<br/>    const file = await Deno.open(name);<br/>    console.log(file);<br/>  }<br/>}<br/>const [fileName] = Deno.args;<br/>main(fileName);</span></pre><h2 id="6316" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">[运行]</h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="edc9" class="lc ld in kl b gy ma mb l mc md">$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json</span><span id="467d" class="lc ld in kl b gy me mb l mc md">## Output:<br/># File { rid: 3 }</span></pre><p id="a9c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以看到<code class="fe ki kj kk kl b">rid</code>作为回报。让我们使用这个<code class="fe ki kj kk kl b">rid</code>来获取数据块。读取块需要API <code class="fe ki kj kk kl b">Deno.read</code></p><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="d65d" class="lc ld in kl b gy ma mb l mc md">// examples/06_readfile_chunk.ts<br/>async function main(name?: string) {<br/>  if (name) {<br/>    const file = await Deno.open(name);<br/>    const decoder = new TextDecoder();<br/>    let buf = new Uint8Array(100);<br/>    const numOfByteRead = await Deno.read(file?.rid, buf);<br/>    console.log(numOfByteRead);<br/>    console.log(decoder.decode(buf));<br/>  }<br/>}<br/>const [fileName] = Deno.args;<br/>main(fileName);</span></pre><h2 id="98d3" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated"><strong class="ak">【运行】</strong></h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="90fa" class="lc ld in kl b gy ma mb l mc md">$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json</span><span id="4e0b" class="lc ld in kl b gy me mb l mc md"># Output<br/># 100<br/>{<br/>   "id": 1,<br/>   "version": "1.0.1",<br/>   "contributors": [<br/>     "deepak",<br/>     "gary"<br/>   ],<br/>   "actor": {</span></pre><p id="22d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，正如您所看到的，每次您调用<code class="fe ki kj kk kl b">Deno.read</code>时，它都会返回已经读取的字节数。如果<code class="fe ki kj kk kl b">numOfByteRead</code>是<code class="fe ki kj kk kl b">null</code> ie。是文件<strong class="jm io">【EOF】</strong>的结尾。</p><p id="e5b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">new Uint8Array(100);</code>调用read时将填充Uint8Array。缓冲区大小可以是任何值。读取器将读取字节，直到达到缓冲区大小。</p><p id="71e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您注意到，读取的文件不是一个完整的文件。您需要增加缓冲区大小来读取所有文件。</p><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="2973" class="lc ld in kl b gy ma mb l mc md">// examples/06_readfile_chunk.ts<br/>async function main(name?: string) {<br/>  if (name) {<br/>    const file = await Deno.open(name);<br/>    const decoder = new TextDecoder();<br/>    let buf = new Uint8Array(1000); // 353<br/>    const numOfByteRead = await Deno.read(file?.rid, buf);<br/>    console.log(numOfByteRead);<br/>    console.log(decoder.decode(buf));<br/>  }<br/>}<br/>const [fileName] = Deno.args;<br/>main(fileName);</span></pre><h2 id="0d97" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">[运行]</h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="db31" class="lc ld in kl b gy ma mb l mc md">$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json</span><span id="c71f" class="lc ld in kl b gy me mb l mc md"># Output<br/># 353<br/>## JSON here..</span></pre><p id="ed6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我将缓冲区大小增加到了1000，超过了353。这样我就可以读取整个JSON文件。</p><p id="4226" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">【注意】:</strong>你应该避免大的缓冲区大小。读取大文件会产生内存问题。同时也很难预测实际的规模。</p><p id="1209" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了逐块读取整个文件，我们可以在<code class="fe ki kj kk kl b">then</code> able API上使用递归。</p><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="b123" class="lc ld in kl b gy ma mb l mc md">// examples/06_readfile_chunk.ts<br/>async function main(name?: string) {<br/>  if (name) {<br/>    const file = await Deno.open(name);<br/>    const decoder = new TextDecoder();<br/>    let buf = new Uint8Array(100);<br/>    let chunk = new Uint8Array(0);<br/>    Deno.read(file?.rid, buf).then(function readByte(numOfByteRead) {<br/>      if (numOfByteRead) {<br/>        chunk = _append(chunk, buf, numOfByteRead);<br/>        Deno.read(file?.rid, buf).then(readByte);<br/>      } else {<br/>        console.log(decoder.decode(chunk));<br/>      }<br/>    });<br/>  }<br/>}<br/>const [fileName] = Deno.args;<br/>main(fileName);</span></pre><h2 id="3cdd" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">[运行]</h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="d790" class="lc ld in kl b gy ma mb l mc md">$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json</span><span id="4d61" class="lc ld in kl b gy me mb l mc md"># Output<br/>{<br/>  "id": 1,<br/>  "version": "1.0.1",<br/>  "contributors": [<br/>    "deepak",<br/>    "gary"<br/>  ],<br/>  "actor": {<br/>    "name": "Tom Cruise",<br/>    "age": 56,<br/>    "Born At": "Syracuse, NY",<br/>    "Birthdate": "July 3 1962",<br/>    "movies": [<br/>      "Top Gun",<br/>      "Mission: Impossible",<br/>      "Oblivion"<br/>    ],<br/>    "photo": "<a class="ae lv" href="https://jsonformatter.org/img/tom-cruise.jpg" rel="noopener ugc nofollow" target="_blank">https://jsonformatter.org/img/tom-cruise.jpg</a>"<br/>  }<br/>}</span></pre><h2 id="e75b" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">[故障]</h2><p id="32ae" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">在这段代码中，当我调用<code class="fe ki kj kk kl b">Deno.read(file?.rid, buf).then</code>时。它将触发一个命名函数<code class="fe ki kj kk kl b">function readByte(numOfByteRead)</code>。这将在每次内部检查<code class="fe ki kj kk kl b">numOfByteRead</code>。您可以通过<code class="fe ki kj kk kl b">decoder.decode</code>追加解码后返回的文本。我追加为Uint8Array。对于命名的Uint8Array数组，我在<code class="fe ki kj kk kl b">StackOverflow</code>上找到了一个很好的例子。</p><p id="00f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">[_追加】</strong></p><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="7259" class="lc ld in kl b gy ma mb l mc md">function _append(a: Uint8Array, b: Uint8Array, numOfByteRead:number) {<br/>  var c = new Uint8Array(a.length + numOfByteRead);<br/>  c.set(a, 0);<br/>  c.set(b.slice(0, numOfByteRead), a.length);<br/>  return c;<br/>}</span></pre><p id="2797" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">【注意】:</strong>如果没有通过<code class="fe ki kj kk kl b">numOfByteRead</code>，可能会对上次读取的值进行垃圾处理。</p><p id="6a3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尼斯（法国城市名）🙂，一切看起来都很好。然而，我们仍然没有逐行阅读。为此，我们将使用异步迭代器。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mk"><img src="../Images/a35b0998e29330c4f2235376e8451aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DKk0FVYVE5aSi88g7UqpzA.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">from: deadcoderising.com</figcaption></figure><h2 id="c62e" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">异步迭代器的基本示例<a class="ae lv" href="https://deepakshrma.github.io/deno-by-example/advance_readline/#basic-sample-for-async-iterator" rel="noopener ugc nofollow" target="_blank"> # </a></h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="bc3c" class="lc ld in kl b gy ma mb l mc md">let range = {<br/>  from: 1,<br/>  to: 5,<br/>  [Symbol.asyncIterator]() {<br/>    return {<br/>      current: this.from,<br/>      last: this.to,<br/>      async next() {<br/>        const value = await new Promise&lt;number&gt;((resolve) =&gt;<br/>          setTimeout(() =&gt; {<br/>            resolve(this.current++);<br/>          }, 1000)<br/>        );<br/>        if (value &lt;= this.last) {<br/>          return { done: false, value };<br/>        } else {<br/>          return { done: true };<br/>        }<br/>      },<br/>    };<br/>  },<br/>};<br/>(async () =&gt; {<br/>  for await (let value of range) {<br/>    console.log(value); // 1,2,3,4,5<br/>  }<br/>})();</span></pre><p id="3866" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">【输出】:</strong> `1，2，3，4，5 '</p><p id="c29e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像<code class="fe ki kj kk kl b">Symbol.iterator</code>一样，我们可以使用<code class="fe ki kj kk kl b">Symbol.asyncIterator</code>来创建一个异步迭代器。因为typescript支持现成的异步迭代器。我们可以使用这个API。要了解更多，你可以阅读<a class="ae lv" href="https://javascript.info/async-iterators-generators" rel="noopener ugc nofollow" target="_blank">异步迭代器生成器</a>。</p><p id="e895" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了逐行读取，我创建了两个实用方法<code class="fe ki kj kk kl b">_readTillDone</code>和<code class="fe ki kj kk kl b">readLine</code>。</p><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="40ac" class="lc ld in kl b gy ma mb l mc md">const _readTillDone = async (<br/>  rid: number,<br/>  text: string = ""<br/>): Promise&lt;[string, string, boolean]&gt; =&gt; {<br/>  let buf = new Uint8Array(100);<br/>  let indexOfLine = text.indexOf("\n");<br/>  if (indexOfLine === -1) {<br/>    const num = await Deno.read(rid, buf);<br/>    if (num) {<br/>      text = text + decoder.decode(buf.slice(0, num));<br/>      return _readTillDone(rid, text);<br/>    } else {<br/>      return [text, "", true];<br/>    }<br/>  } else {<br/>    return [text.slice(0, indexOfLine), text.slice(indexOfLine + 1), false];<br/>  }<br/>};</span><span id="31b4" class="lc ld in kl b gy me mb l mc md">const readLine = async (fileName: string) =&gt; {<br/>  const file = await Deno.open(fileName);<br/>  let text = "";<br/>  let done = false;<br/>  return {<br/>    [Symbol.asyncIterator]() {<br/>      return {<br/>        async next() {<br/>          const [t, rest, d] = await _readTillDone(file?.rid, text);<br/>          if (done) {<br/>            return { done: true, value: t };<br/>          } else {<br/>            text = rest;<br/>            done = d;<br/>            return { done: false, value: t };<br/>          }<br/>        },<br/>      };<br/>    },<br/>  };<br/>};</span></pre><h2 id="78fd" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">[故障]</h2><p id="39c5" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated"><code class="fe ki kj kk kl b">readLine</code>很简单。在每次异步迭代器调用时，它将调用<code class="fe ki kj kk kl b">_readTillDone</code>并返回该行。但是，_readTillDone有点复杂。我使用<code class="fe ki kj kk kl b">file.rid</code>来跟踪文件的读取。</p><p id="cb64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当我用<code class="fe ki kj kk kl b">file?.rid, text</code>打<code class="fe ki kj kk kl b">_readTillDone</code>的时候。它试图用<code class="fe ki kj kk kl b">newLine</code>分割文本。我找不到纽林。它试图读取更多的行，直到结束。<code class="fe ki kj kk kl b">_readTillDone</code>返回三个参数<code class="fe ki kj kk kl b">[t, rest, d]</code>。这里<code class="fe ki kj kk kl b">t</code>，逐行读取的文本，<code class="fe ki kj kk kl b">rest</code>作为缓冲文本，<code class="fe ki kj kk kl b">d</code>作为完成返回。</p><p id="784d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ml">让我们完成教程。一旦我们有了这些实用程序，实现就非常简单了。</em> </strong></p><h2 id="2afa" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">示例-最终代码<a class="ae lv" href="https://deepakshrma.github.io/deno-by-example/advance_readline/#example-final-code" rel="noopener ugc nofollow" target="_blank"> # </a></h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="6319" class="lc ld in kl b gy ma mb l mc md">// examples/06_readfile_chunk.ts<br/>import { readLine } from "<a class="ae lv" href="https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/examples/file_reader.ts" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/deepakshrma/deno-by-example/master/examples/file_reader.ts</a>";</span><span id="4a86" class="lc ld in kl b gy me mb l mc md">async function main(name?: string) {<br/>  if (name) {<br/>    // Example 6<br/>    const reader = await readLine(name);<br/>    for await (let value of reader) {<br/>      console.log(value);<br/>    }<br/>  }<br/>}<br/>const [fileName] = Deno.args;<br/>main(fileName);</span></pre><h2 id="0ef9" class="lc ld in bd le lf lg dn lh li lj dp lk jv ll lm ln jz lo lp lq kd lr ls lt lu bi translated">[运行]</h2><pre class="kn ko kp kq gt lw kl lx ly aw lz bi"><span id="e429" class="lc ld in kl b gy ma mb l mc md">$ deno  run --allow-read  examples/06_readfile_chunk.ts examples/tom.json</span><span id="3b24" class="lc ld in kl b gy me mb l mc md"># Output<br/>{<br/>  "id": 1,<br/>  "version": "1.0.1",<br/>  "contributors": [<br/>    "deepak",<br/>    "gary"<br/>  ],<br/>  "actor": {<br/>    "name": "Tom Cruise",<br/>    "age": 56,<br/>    "Born At": "Syracuse, NY",<br/>    "Birthdate": "July 3 1962",<br/>    "movies": [<br/>      "Top Gun",<br/>      "Mission: Impossible",<br/>      "Oblivion"<br/>    ],<br/>    "photo": "<a class="ae lv" href="https://jsonformatter.org/img/tom-cruise.jpg" rel="noopener ugc nofollow" target="_blank">https://jsonformatter.org/img/tom-cruise.jpg</a>"<br/>  }<br/>}</span></pre><p id="b3ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TaDa！👏👏现在，您可以逐行读取整个文件。</p><p id="db5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你喜欢这个教程。请在评论中告诉我你的反馈。请支持(🙏🙏)通过订阅和鼓掌。</p><p id="d24f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有工作实例都可以在我的Github中找到:<a class="ae lv" href="https://github.com/deepakshrma/deno-by-example/tree/master/examples" rel="noopener ugc nofollow" target="_blank">https://Github . com/deepakshrma/deno-by-example/tree/master/examples</a></p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="c848" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ml">原载于</em><a class="ae lv" href="https://deepakshrma.github.io/deno-by-example/advance_readline" rel="noopener ugc nofollow" target="_blank"><em class="ml">https://deepakshrma . github . io</em></a><em class="ml">。</em></p><h1 id="2578" class="mt ld in bd le mu mv mw lh mx my mz lk na nb nc ln nd ne nf lq ng nh ni lt nj bi translated">用简单英语写的便条</h1><p id="aafe" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae lv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae lv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">订阅我们的YouTube频道</strong> </a> <strong class="jm io">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>