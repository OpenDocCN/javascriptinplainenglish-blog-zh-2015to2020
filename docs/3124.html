<html>
<head>
<title>RxJS: Filter repetitive Values out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS:过滤掉重复值</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-filter-repetitive-values-out-a0afcf42264b?source=collection_archive---------8-----------------------#2020-08-31">https://javascript.plainenglish.io/rxjs-filter-repetitive-values-out-a0afcf42264b?source=collection_archive---------8-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b1bd7b895eb02dfb9f9876f013a1061f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22agcLXz6tCmqxeuvuUazg.jpeg"/></div></div></figure><p id="bf73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RxJS有一堆很酷的运营商。即使你已经可以用<code class="fe kw kx ky kz b">map</code>和<code class="fe kw kx ky kz b">filter</code>做很多事情，了解你工具箱里所有的工具会让你有空闲时间，写出更清晰、更简洁的代码。</p><p id="7b09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在处理一个发出可能重复值的可观察对象，但只对新的值感兴趣，您可以构建一个带有<code class="fe kw kx ky kz b">temp</code>变量、<code class="fe kw kx ky kz b">map</code>和<code class="fe kw kx ky kz b">filter</code>的东西，以便跳过与您之前收到的值相同的值。您也可以使用<code class="fe kw kx ky kz b">distinctUntilChanged</code>运算符。</p><p id="1268" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b"><em class="la">distinctUntilChanged</em></code> <em class="la">仅在当前值不同于上一次</em>时发出</p><p id="8a85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着可观察到以下情况:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="941f" class="lj lk iq kz b gy ll lm l ln lo">from([1, 1, 2, 1, 2, 3, 3]).pipe(distinctUntilChanged());</span></pre><p id="7fc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">订阅时会发出<code class="fe kw kx ky kz b">1, 2, 1, 2, 3</code>。</p><p id="1f79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于对象，类似的例子就没那么好了:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="b375" class="lj lk iq kz b gy ll lm l ln lo">from([<br/>  { value: 1 }, <br/>  { value: 1 },<br/>  { value: 2 },<br/>]).pipe(distinctUntilChanged());</span></pre><p id="d6b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使第一个和第二个对象是相同的，这个对象也会发出所有三个对象。这是因为<code class="fe kw kx ky kz b">distinctUntilChanged</code>使用了精确的比较运算符<code class="fe kw kx ky kz b">===</code>，所以只有当对象具有相同的引用时才会匹配它们。在我们的例子中情况并非如此。</p><p id="f20f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这并不意味着在比较简单值时只能使用运算符。对于需要比较对象的情况，有两种选择。</p><p id="53c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先你可以先定义自己的<code class="fe kw kx ky kz b">compare</code>函数。假设原始的可观察对象发出一个用户列表，如果这个值与前一个值具有相同的姓和名，那么您可以决定跳过这个值。为此，您可以将比较函数作为参数传递给<code class="fe kw kx ky kz b">distinctUntilChanged</code>操作符。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="6b17" class="lj lk iq kz b gy ll lm l ln lo">const areUsersEqual = (<br/>  user1,<br/>  user2,<br/>): boolean =&gt; user1.lastname === user2.lastname &amp;&amp;<br/>             user1.firstname === user2.firstname;</span><span id="bec9" class="lj lk iq kz b gy lp lm l ln lo">from([<br/>  { firstname: 'Tom', lastname: 'Johnson' }, <br/>  { firstname: 'Tom', lastname: 'Johnson' },<br/>  { firstname: 'Martin', lastname: 'Johnson' },<br/>]).pipe(distinctUntilChanged(areUsersEqual));</span></pre><p id="c5b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将按预期工作，并且仅发射<code class="fe kw kx ky kz b">Tom Johnson</code>一次。</p><p id="54af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于像我们前面的例子这样简单的情况，它可能看起来有很多代码:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="479f" class="lj lk iq kz b gy ll lm l ln lo">from([<br/>  { value: 1 }, <br/>  { value: 1 },<br/>  { value: 2 },<br/>]).pipe(distinctUntilChanged());<br/></span></pre><p id="c8e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您只能从一个属性的值中区分两个元素，有一个更简洁的解决方案:<code class="fe kw kx ky kz b">distinctUntilKeyChanged</code>。您可以将想要用来比较发出值的属性作为参数传递给运算符。如果两个连续发射的对象具有相同的属性值，则只发射第一个对象。</p><p id="89c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户有<code class="fe kw kx ky kz b">id</code>，我们可以与他们一起使用:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="6a29" class="lj lk iq kz b gy ll lm l ln lo">from([<br/>  { id: '1', firstname: 'Tom', lastname: 'Johnson' }, <br/>  { id: '1', firstname: 'Tom', lastname: 'Johnson' },<br/>  { id: '2', firstname: 'Martin', lastname: 'Johnson' },<br/>]).pipe(<!-- -->distinctUntilKeyChanged<!-- -->('id'));</span></pre><p id="a99b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里再次说明，<code class="fe kw kx ky kz b">Tom Johnson</code>只发出一次。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="c439" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RxJS操作符通常很容易掌握，可以节省几行代码。但是它们太多了，有时候很难找到你要找的那一个。听说过<code class="fe kw kx ky kz b">distinctUntilChanged</code>和<code class="fe kw kx ky kz b">distinctUntilKeyChanged</code>并且知道无论你比较的值是什么形式，你都可以使用它们，下次你遇到类似的问题时，你会想到它。</p></div></div>    
</body>
</html>