<html>
<head>
<title>JavaScript: 6 practices to be aware of</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:需要注意的6种实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-4-weird-things-to-be-aware-of-18b8528b8ef7?source=collection_archive---------2-----------------------#2020-01-22">https://javascript.plainenglish.io/javascript-4-weird-things-to-be-aware-of-18b8528b8ef7?source=collection_archive---------2-----------------------#2020-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0d4e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JS可能很棘手——为了不弄乱您的代码，需要注意以下几点</h2></div><p id="51c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，我们都知道JavaScript很奇怪。但是我们大多数人，包括我，都喜欢它。即使它的概念很奇怪。为了让我们都能继续热爱JavaScript &amp;将来不再为愚蠢的事情烦恼，我写了这篇文章来澄清其中的一些问题。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/bdb0e147db39534f3224e7c4488ce3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Y6YIUTDqNQ4Kpl15h2YBgA.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Oh no… it’s retarded!</figcaption></figure><h1 id="5d31" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">1).你知道在JavaScript中可以用字符串计算吗？</h1><p id="15e9" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">起初，这对你来说并不奇怪，不是吗？</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="46b7" class="mp lo iq ml b gy mq mr l ms mt"> 11 + 1      // 12<br/>'11' + 1;    <em class="mu">// 111<br/> </em>11 – 1;     <em class="mu">// 10</em></span></pre><p id="59a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是魔法来了:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="f664" class="mp lo iq ml b gy mq mr l ms mt"> '11' — 1    // 10</span></pre><p id="9b7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，JavaScript自动将字符串转换成数字，所以您可以将这里的1转换成字符串。这将导致同样的结果。<br/>证明就是，如果你有两个包含字母的字符串，想把它们相减，JavaScript只会输出NaN，即“不是数字”。</p><p id="1df6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">精髓:始终确保你使用正确的数据类型</strong></p><h1 id="5523" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">2).阻止事件循环</h1><p id="51f8" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">让我们从一个简单的问题开始。哪个名称将通过console.log打印出来？</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="d382" class="mp lo iq ml b gy mq mr l ms mt">let name = ‘Max’<br/>setTimeout(function() {<br/>  name = ‘Tom’</span><span id="b0a9" class="mp lo iq ml b gy mv mr l ms mt">}, 1000)</span><span id="6724" class="mp lo iq ml b gy mv mr l ms mt">console.log(name)</span></pre><p id="7b3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正确。<strong class="kh ir">最大值</strong>将被打印。setTimeout不会阻止整个JavaScript的执行，因为JavaScript识别函数console.log，即使它在代码中的setTimeout之后。<br/>该函数将首先被执行，然后JS将运行那个setTimeout。</p><p id="95a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个更复杂的例子:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="c903" class="mp lo iq ml b gy mq mr l ms mt">let start = Date.now()</span><span id="5c9d" class="mp lo iq ml b gy mv mr l ms mt">let doWork = () =&gt; {</span><span id="16f2" class="mp lo iq ml b gy mv mr l ms mt">console.log(‘doWork started’)</span><span id="7593" class="mp lo iq ml b gy mv mr l ms mt">for (let i = 0; i &lt; 999999999; i++) {}<br/>  console.log(‘doWork done after’, Date.now() — start)<br/>}</span><span id="19ab" class="mp lo iq ml b gy mv mr l ms mt">let clickme = () =&gt; {<br/>  alert(‘clicked after’, Date.now() — start)<br/>}</span><span id="350e" class="mp lo iq ml b gy mv mr l ms mt">doWork()</span><span id="abcb" class="mp lo iq ml b gy mv mr l ms mt">setTimeout(function() {<br/>  console.log(‘setTimeout done after’, Date.now() — start)<br/>}, 1000)</span><span id="d6b0" class="mp lo iq ml b gy mv mr l ms mt">doWork()</span></pre><p id="53bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请确保在您的浏览器中运行此程序。以下是结果，时代可能不同</p><blockquote class="mw mx my"><p id="1d1c" class="kf kg mu kh b ki kj jr kk kl km ju kn mz kp kq kr na kt ku kv nb kx ky kz la ij bi translated">道工作开始<br/>道工作在854之后完成<br/>道工作开始<br/>道工作在1429之后完成<br/>设置超时在1858之后完成</p></blockquote><p id="7f2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到的是，再次设置超时将被延迟。但是您是否也注意到了代码中的“clickme”函数？创建一个简单的HTML按钮，当你点击它时执行，你会看到简单的<strong class="kh ir">警告</strong>也会被延迟，只要doWork函数被执行。<strong class="kh ir"> <br/> </strong>再次，setTimeout将被延迟。但是这一次不仅从doWork函数，而且从clickme函数。我们从中学到了什么？永远记住JS中的事件循环是如何工作的。这可以防止HTTP请求的许多问题，例如&amp;确保永远不要阻塞事件循环，当用户应该能够执行一个功能时，就像在我们的例子中，通过一个按钮。想象一下，点击按钮应该会打开一个下拉菜单。这种延迟会杀死你的UX。</p><h1 id="820d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">3).奇怪的范围规则</h1><p id="89fd" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在JavaScript中，我们必须限定范围。全局和局部范围。只有两个，但它们会导致很多混乱。</p><p id="45e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在函数内部定义一个变量时，它只在局部范围内可用。这是我们大多数人的想法。但是在JavaScript中并不总是这样。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="15f6" class="mp lo iq ml b gy mq mr l ms mt">function hello() {<br/>  message = ‘Hello!’<br/>}</span><span id="72de" class="mp lo iq ml b gy mv mr l ms mt">console.log(message) // message is not defined</span><span id="60b7" class="mp lo iq ml b gy mv mr l ms mt">hello()</span></pre><p id="6235" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是一旦函数被执行，这个变量是全局可用的。即使函数在定义之前就在代码中被调用，这也是可行的。<br/>(称为提升，但对箭头功能不起作用，详见:<a class="ae nc" href="https://medium.com/javascript-in-plain-english/arrow-functions-vs-regular-functions-in-javascript-f98687f23a6d" rel="noopener">箭头与常规功能</a>)</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="ed30" class="mp lo iq ml b gy mq mr l ms mt">hello()</span><span id="6ba4" class="mp lo iq ml b gy mv mr l ms mt">console.log(message) <em class="mu">// Hello</em></span><span id="c070" class="mp lo iq ml b gy mv mr l ms mt">function hello() {<br/>  message = ‘Hello!’<br/>}</span></pre><h1 id="6c8a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">4).0.1 + 0.2等于0.3？是的，但实际上不是。</h1><p id="455e" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">而且说实话，这不仅仅是JavaScript的问题。例如，如果您在Python中执行相同的操作，将会得到相同的结果。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="e11e" class="mp lo iq ml b gy mq mr l ms mt">0.1 + 0.2   // 0.30000000000000004</span></pre><p id="1afd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mu">但用JS计算不完全准确的不仅仅是这里:</em></p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="4793" class="mp lo iq ml b gy mq mr l ms mt">2.3 * 100   // 229.99999999999997</span></pre><h1 id="c35f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">5).在JavaScript中清理数组？有几种方法，但只有两种合适的方法</h1><p id="6dc6" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在这一节中，我参考了一个有趣的性能研究，从5种不同的方法来清空JS中的数组。<br/><a class="ae nc" href="http://jsben.ch/hyj65" rel="noopener ugc nofollow" target="_blank">http://jsben.ch/hyj65</a></p><p id="1ed1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这个实验可以看出，这是最快的方法:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="a2cd" class="mp lo iq ml b gy mq mr l ms mt">var arr1 = [“a”, “b”, “c”, “d”, “e”, “f”];<br/>var arr2 = arr1;   <em class="mu"><br/></em>arr1 = [];</span></pre><p id="0492" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以理论上你只需要重新初始化数组就可以清空了？<strong class="kh ir">是</strong>。<br/>但这永远是最好的方式吗？<strong class="kh ir">否</strong>。<br/>因为这里发生的事情:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="6316" class="mp lo iq ml b gy mq mr l ms mt">var arr1 = [“a”, “b”, “c”, “d”, “e”, “f”];<br/>var arr2 = arr1; <em class="mu">// Reference arr1 by another variable<br/></em>arr1 = [];<br/>console.log(arr2); // [“a”, “b”, “c”, “d”, “e”, “f”]</span></pre><p id="4b9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们看到的，实际的数组是空的，但是<em class="mu"> arr2 </em>仍然包含它的完整内容。<br/>但是根据我们的实验，还有第二种方法，几乎一样快:只需将数组的<strong class="kh ir">长度</strong>设置为0。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="7ba2" class="mp lo iq ml b gy mq mr l ms mt">var arr1 = [“a”, “b”, “c”, “d”, “e”, “f”];<br/>var arr2 = arr1;<em class="mu"><br/></em>arr1.length = 0;<br/>console.log(arr2); // [ ]</span></pre><h1 id="1750" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">6).传递参数时危险的不准确性</h1><p id="b0ab" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">让我们创建一个简单的函数来添加两个值:</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="47cf" class="mp lo iq ml b gy mq mr l ms mt">function add(a, b) {<br/>  return a + b;<br/>}</span><span id="96d4" class="mp lo iq ml b gy mv mr l ms mt">add(2, 2); <em class="mu">// 4</em></span><span id="f437" class="mp lo iq ml b gy mv mr l ms mt"><em class="mu">// one param missing — won’t work<br/></em>add(2); <em class="mu">// NaN</em></span><span id="2c2f" class="mp lo iq ml b gy mv mr l ms mt"><em class="mu">// one param too much — doesn’t care<br/></em>add(2, 2, 10); <em class="mu">// 4</em></span></pre><p id="0187" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从逻辑上讲，如果我们正好传递两个参数，一切都会正常。但是，如果我们超过一个，或者少过一个，会发生什么呢？不同的东西。</p><p id="b9e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们移交的<strong class="kh ir">太少</strong>，就会导致错误。如果我们把太多的交给<strong class="kh ir">，所有那些太多的都被忽略了。然而，JavaScript在这两种情况下都没有给出确切的警告。</strong></p><h2 id="6267" class="mp lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni lz ks nj nk mb kw nl nm md nn bi translated">变通办法</h2><p id="0060" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">首先，您可以为您的参数使用默认值，如果没有为参数传递任何其他内容，就会应用默认值。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="a16b" class="mp lo iq ml b gy mq mr l ms mt">function add(a, b = 2) {<br/>   return a + b;<br/>}</span><span id="0b2a" class="mp lo iq ml b gy mv mr l ms mt">add(2);     // 4<br/>add(2, 3);  // 5</span></pre><p id="f37c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种选择是将参数放入一个数组，其中包含传递给函数的所有内容。是的，正如你所看到的，你不需要在函数本身中定义，它所期望的参数。</p><pre class="lc ld le lf gt mk ml mm mn aw mo bi"><span id="7b1e" class="mp lo iq ml b gy mq mr l ms mt">function paramArray() {<br/>   return Array.from(arguments);<br/>}</span><span id="4816" class="mp lo iq ml b gy mv mr l ms mt">paramArray(2, 2, 2);   <em class="mu">// [2, 2, 2]</em></span></pre><h2 id="dba6" class="mp lo iq bd lp nd ne dn lt nf ng dp lx ko nh ni lz ks nj nk mb kw nl nm md nn bi translated">目前为止就这些了</h2><p id="fdb6" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这篇文章一直在扩展，所以我们最终有了JavaScript中错误的最终列表。因此，请随时留下您的反馈&amp;在评论中添加任何内容:)</p><h1 id="9dcd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">感谢您的阅读！</h1><p id="0138" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">嗨！非常感谢你阅读我的博客，我叫路易斯，是一名来自德国的18岁学生。我热爱web开发，包括后端和前端。我最喜欢的技术是React、Vue、React Native和node . js。<br/>请关注我，了解更多相关内容，并随时查看我的IG @ Louis . jsx&amp;@ codingcultureshop<br/>祝您愉快&amp;随时给我留下您的反馈:)</p></div></div>    
</body>
</html>