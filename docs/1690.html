<html>
<head>
<title>What the heck is an Event Queue?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是事件队列？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/decoupling-patterns-event-queue-b3c0fa2ce5c1?source=collection_archive---------10-----------------------#2020-04-14">https://javascript.plainenglish.io/decoupling-patterns-event-queue-b3c0fa2ce5c1?source=collection_archive---------10-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b7ae18f0b0ff88e96beac50819c76640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MXOCmM69DCnYWI0W"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@evonneteoh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Evonne Yuwen Teoh</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="6d4b" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">用于系统设计的强大设计模式</h2></div><p id="e5d7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">你可以在这里</em> <a class="ae jd" href="https://github.com/pacosw1/EventQueue" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jh"> <em class="lr">下载完整代码</em></strong></a><strong class="kx jh"><em class="lr"/></strong><em class="lr">到</em> <strong class="kx jh"> <em class="lr"> </em> </strong> <em class="lr">跟着来。</em></p><p id="c055" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天我们将谈论一个在系统设计中使用的非常令人兴奋的模式。无论是金融后端服务、实时应用程序还是视频游戏，这种模式都使系统易于维护和扩展。</p><p id="7ab4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是本系列的第一个解耦模式，所以让我们从解释什么是解耦以及为什么要使用它开始。</p><h1 id="e4ad" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">简而言之，脱钩</h1><p id="0634" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在我们特定的上下文中，解耦意味着<strong class="kx jh">将我们系统中的组件</strong>分开，这样它们就不会直接依赖于彼此<strong class="kx jh"/>或者相互<strong class="kx jh">交互。</strong></p><h1 id="d5e3" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">目的</h1><p id="3643" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当我们构建需要扩展的复杂系统时，我们很少会单独工作。这意味着不同的人需要同时阅读和修改项目的不同部分。</p><p id="f190" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果事情做得不对，这会导致很多挫折。</p><p id="2e31" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，假设我们正在建立一个社交网络。团队中的每个人都被分配到不同的组件。一个负责网络，另一个可能负责聊天功能，还有一个负责feed和图片上传。</p><p id="b381" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">乍一看，人们可能会认为网络组件(从客户端发送和接收数据)必须与聊天组件有直接的联系，因为它们需要彼此才能工作。关于上传位也可以这么说。</p><p id="8f42" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这可能是真的，但网络和聊天执行完全不同的功能，彼此并不完全相关。但同时，聊天需要网络组件正在接收和处理的数据。</p><h1 id="1278" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">避免意大利面条代码</h1><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/505b0a29b0af1c662a458510166a3cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qyfGy-RqIa1MB4aYRvaeg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">all graphics created by me</figcaption></figure><p id="1b16" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们实现了简单的方法，我们会让聊天依赖于网络组件，反之亦然。</p><p id="f30a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">网络组件中的任何改变都可能影响聊天功能，聊天者可能需要侵入网络者的代码，以使其代码再次工作。这是事情变得非常混乱的地方。聊天的人不应该需要修改不特定于他的领域的代码。或者至少是最少的数量。</p><p id="0510" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为这两个组件是耦合的，所以双方都需要跟踪这两个领域中发生的事情，当系统随着时间变得更加复杂时，这就变得非常棘手。</p><h1 id="c0b5" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">救援事件队列</h1><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/48f5f43065392a98699ec1c3414dbcf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqkJp3oD8zy1OlsGE-Yy3A.png"/></div></div></figure><p id="4921" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事件队列就像一个中心站，一个中间人，所有的“包”都到达这里，并被分发到相应的目的地。这种模式使用基于事件的系统来解耦所有的通信。</p><p id="a1f5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象一下，你正在看youtube，你真的很喜欢X的频道，希望在他们上传新视频时得到通知。每当X上传一个新的视频，你，现在是订阅者，将会收到一封电子邮件(事件)。</p><p id="4522" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事件队列以同样的方式工作。组件向队列发送一个事件，队列处理所有这些消息，并将其分发到订阅该事件的任何组件。</p><h1 id="6afc" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">事件队列的构造块</h1><h2 id="9f8a" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">事件</h2><p id="150e" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">事件是一种结构，它定义了发送和接收的数据是什么(它的类型)，并跟踪谁在监听它。</p><h2 id="91ee" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">发报机</h2><p id="64b8" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">发送者就像YouTuber，他将消息发送到事件队列，这就是他所需要担心的。不错！</p><h2 id="233e" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">听众</h2><p id="52b4" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">侦听器将首先需要订阅一个事件。那么每当来自所述事件的新消息到达时，事件队列将通知他。</p><h2 id="61f7" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">处理函数</h2><p id="f58d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一旦接收到数据，处理程序是由每个用户执行的功能。所有订户都接收到该特定事件的相同数据，但是每个订户都可以将该数据用于不同的目的。</p><h2 id="d9a1" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">事件队列</h2><p id="cfb8" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">事件队列将接收来自发送方的事件消息，并将它们广播给相应的订阅方。</p><h1 id="749b" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">实现事件队列</h1><p id="f538" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在我们更熟悉它是如何工作的，让我们用JavaScript来实现它</p><p id="edba" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从实现eventQueue类开始</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f588" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们可以看到一些东西。</p><h2 id="4df0" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">长队</h2><ul class=""><li id="1477" class="nj nk jg kx b ky mk lb ml le nl li nm lm nn lq no np nq nr bi translated">该队列将用于接收和广播事件消息</li></ul><h2 id="ecb8" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">消息监听器</h2><ul class=""><li id="6b94" class="nj nk jg kx b ky mk lb ml le nl li nm lm nn lq no np nq nr bi translated">监听Message类型事件的所有组件的列表</li></ul><h2 id="eef8" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">运转</h2><ul class=""><li id="3946" class="nj nk jg kx b ky mk lb ml le nl li nm lm nn lq no np nq nr bi translated">我们的EventQueue的状态，我们可以通过使它= false来停止循环；</li></ul><h2 id="1f1b" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">开始()</h2><ul class=""><li id="e431" class="nj nk jg kx b ky mk lb ml le nl li nm lm nn lq no np nq nr bi translated">开始运行循环</li></ul><h2 id="59bb" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">runLoop()</h2><ul class=""><li id="0789" class="nj nk jg kx b ky mk lb ml le nl li nm lm nn lq no np nq nr bi translated">它卸载队列中的下一个事件，并将其消息广播给所有注册的侦听器。(订户)</li><li id="4ea2" class="nj nk jg kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated">这是最重要的部分之一。事件循环异步等待发送到其队列的消息。</li><li id="db1b" class="nj nk jg kx b ky ns lb nt le nu li nv lm nw lq no np nq nr bi translated">我们需要使它成为异步函数的原因是因为JavaScript是单线程的，所以如果我们不这样做，循环将阻塞我们代码中的所有其他内容，我们将无法接收任何输入，甚至无法停止循环。</li></ul><h2 id="b378" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">创建事件</h2><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="63e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以创建许多不同类型的事件，如“客户端连接”、“客户端断开”、“客户端加入组”、“客户端离开组”等…</p><p id="d005" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要创建一个事件，我们需要存储的只是侦听器和实际发送的消息(有效负载)。</p><p id="d8f9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个事件都有一个广播方法，因此eventQ可以将消息广播给它的所有侦听器。</p><p id="b2db" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:在这种情况下，每个侦听器都必须实现一个名为HandleMessage的方法，但是您可以选择方法的名称。</p><p id="bdb9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该方法可以对信息做任何它想做的事情。</p><h2 id="1ae4" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">注册事件</h2><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4931" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在EventQueue类中，我们需要添加一个方法来注册一个组件，这样它就可以监听我们的消息事件。</p><p id="1f9d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要为每个独特的事件添加一个侦听器数组，并创建一个注册函数来为该事件添加组件。</p><p id="572c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本例中，我们在创建事件队列类<strong class="kx jh"> </strong>时已经创建了<strong class="kx jh"> messageListeners[] </strong>，因此我们可以添加<strong class="kx jh"> register方法。</strong>每当触发这种类型的事件时，所有注册的组件都会得到通知。</p><h1 id="f736" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">将这一切结合在一起</h1><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="5722" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated"><strong class="ak">怎么回事？</strong></h1><p id="ccb6" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><strong class="kx jh"> <em class="lr">组件A和B </em> </strong>将只监听和处理它们收到的消息，因此它们不需要访问eventQueue实例</p><p id="91bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="lr">组件C </em> </strong>将发送消息，因此它需要访问eventQueue的方法。</p><p id="03a8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们注册<strong class="kx jh">组件A和B </strong>来接收消息类型的事件</p><p id="7b99" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从<strong class="kx jh">组件C </strong>发送<strong class="kx jh">两个消息</strong>，它们被广播给注册的组件。(A &amp; B)</p><p id="8401" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还可以修改组件A和B，以便能够像组件C那样发送消息事件，或者您能想到任何其他类型的事件。</p><blockquote class="nx ny nz"><p id="b09a" class="kv kw lr kx b ky kz kh la lb lc kk ld oa lf lg lh ob lj lk ll oc ln lo lp lq ij bi translated">请注意，这段代码将创建一个无限循环，因为我们希望在应用程序运行的同时运行eventQ。您可以在main.js文件的末尾添加eventQ.running = false，但是由于我们正在停止循环，因此只会记录第一条消息。</p></blockquote><p id="67eb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出将如下所示。</p><p id="3b6e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">发送了两个消息事件，由于这个事件类型有两个侦听器，它被打印两次，每个侦听器打印一次，</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/74083bf5f24aa1d78f58e55199f0a74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndY5d_1SJWa7wfJnWGWDyQ.png"/></div></div></figure><h1 id="2213" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="4b8d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">事件队列是一个非常强大的解耦设计模式。它使系统的内部通信更加有效，并提供了一种及时安排行动的方法。</p><p id="7b95" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着只要系统中有事件发生，就可以接收消息。这对于需要在发生重要事情时通知用户的系统来说非常有用，比如实时应用程序和多人视频游戏。</p><p id="c91a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在JavaScript中，我们使用异步来“并发”运行它，但是在像GO这样的多线程语言中，我们可以更有效地做到这一点</p><p id="a5c2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天到此为止。</p><p id="0ac9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！</p><h2 id="2627" class="mv lt jg bd lu mw mx dn ly my mz dp mc le na nb me li nc nd mg lm ne nf mi ng bi translated">用简单英语写的JavaScript的注释</h2><p id="15dd" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到<a class="ae jd" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank"><strong class="kx jh">submissions@javascriptinplainenglish.com</strong></a>给我们，我们会把你添加为作者。</p><p id="7d2b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还推出了三种新出版物！通过以下方式表达对我们新出版物的热爱:<a class="ae jd" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kx jh"/></a><a class="ae jd" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kx jh">【UX】</strong></a><a class="ae jd" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kx jh">【Python】</strong></a><strong class="kx jh"/>——谢谢您，继续学习！</p></div></div>    
</body>
</html>