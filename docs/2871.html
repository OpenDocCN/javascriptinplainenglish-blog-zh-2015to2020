<html>
<head>
<title>Creating a dynamic RESTful API using Express and Sequelize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express和Sequelize创建动态RESTful API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/heavy-lifting-creating-a-dynamic-restful-api-using-express-and-sequelize-6d18f9a4bcfb?source=collection_archive---------1-----------------------#2020-07-31">https://javascript.plainenglish.io/heavy-lifting-creating-a-dynamic-restful-api-using-express-and-sequelize-6d18f9a4bcfb?source=collection_archive---------1-----------------------#2020-07-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e959" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是API，RESTful意味着什么，以及如何使用Node.js实现这些</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c499320836fc52c53193e0c25608aab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTT6zV0fmgNI7TwJ0LXNAA.jpeg"/></div></div></figure><h1 id="b69d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="69cf" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在本文中，我们将讨论什么是API，RESTful意味着什么，以及如何使用Node.js实现这些。我们将使用的Node.js包将是用于API端点的Express和用于查询数据库的Sequelize。</p><p id="ac66" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">学习如何创建一个应用编程接口是一个微妙的过程。开发人员只是想快速构建端点，这样他们就可以快速为网页做好消费准备。然而，学习如何使事情RESTful将使您的API更加一致、可预测和可伸缩。</p><p id="93cb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">本文假设您知道如何创建一个Express服务器并使用Sequelize连接到一个数据库。</p><p id="3419" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果您只想进入代码，完整的代码示例是可用的。</p><div class="mh mi gp gr mj mk"><a href="https://github.com/andrewgbliss/tutorial-sequelize-router" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">andrewgbliss/教程-sequelize-路由器</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">通过在GitHub上创建一个帐户，为andrewgbliss/tutorial-sequelize-router开发做出贡献。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my km mk"/></div></div></a></div><h1 id="e58c" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">术语</h1><p id="2ee2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">让我们定义一下构建RESTful API的含义。</p><p id="49f5" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">创建一个API ( <strong class="li io"> A </strong>应用程序<strong class="li io"> P </strong>编程<strong class="li io"> I </strong>接口)是我们如何设置逻辑动作以在应用程序中执行某些功能。例如，我们可以设置一个名为“创建客户”的函数，它将为我们提供一个界面，所以我们不需要理解它将如何实际创建客户，我们需要知道的只是如何调用该函数。然后由程序员来实现对API的要求。</p><p id="34ed" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">创建RESTful(<strong class="li io">RE</strong>presentation<strong class="li io">S</strong>state<strong class="li io">T</strong>transfer)API意味着我们将遵循如何通过使用HTTP方法在逻辑上设置端点的模式。例如，当您在浏览器中键入要转到的网页时，它将调用HTTP GET方法来检索要显示的网页。我们将在后面讨论创建RESTful API所需要知道的所有方法。</p><h1 id="3bbb" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">入门指南</h1><p id="3f69" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在我们开始之前，让我们计划一下构建我们的API需要什么。例如，假设我们有一个反应应用程序，它有一个客户页面。在此页面上，用户可以创建、显示所有客户、更新和删除客户。然后，反应应用程序将对我们的Express服务器进行API调用，反过来，API将对我们的数据库执行操作。我们还需要用版本号作为API端点的前缀(如果您需要构建更多的API但需要维护旧版本，这很有用)。</p><h1 id="9160" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">RESTful端点</h1><h2 id="c087" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">GET/API/v1/客户</h2><p id="2aca" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这将返回我们数据库中的一系列客户。</p><h2 id="7d12" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">GET/API/v1/customers/id:</h2><p id="b055" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这会返回一个<em class="nl"> :id </em>参数指定的客户。</p><h2 id="3c96" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">POST/API/v1/客户</h2><p id="dac4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这将在我们的数据库中创建一个客户。</p><h2 id="bf69" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">PUT/API/v1/customers/id:</h2><p id="e2c0" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这会更新<em class="nl"> :id </em>参数指定的客户。</p><h2 id="f92d" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">DELETE/API/v1/customers/id:</h2><p id="7235" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">这将删除由:<em class="nl"> id </em>参数指定的客户。</p><div class="mh mi gp gr mj mk"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">HTTP请求方法</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">HTTP定义了一组请求方法来指示对给定资源要执行的操作。虽然…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">developer.mozilla.org</p></div></div><div class="mt l"><div class="nm l mv mw mx mt my km mk"/></div></div></a></div><p id="dd0f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">上面的链接介绍了每个HTTP方法是什么以及它的意图是什么。让我们快速浏览一下我们将使用的HTTP方法。</p><p id="249f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io"> GET: </strong>这个HTTP方法将返回位于服务器上的资源。</p><p id="4c51" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io"> POST: </strong>这个HTTP方法将创建一个资源。</p><p id="5b9c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这个HTTP方法将更新一个资源。</p><p id="79a7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">删除:</strong>这个HTTP方法将删除一个资源。</p><p id="f00c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">遵循HTTP方法及其目的，意味着我们可以开始构建一个可预测的RESTful API。然而，我们不希望每次创建新的数据库资源时都编写全新的路由器。让我们写一些代码来帮我们完成所有繁重的工作。</p><h1 id="fe3e" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">快速路由器</h1><p id="509c" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">创建一个Express路由器是直接的和非个人化的，所以我们希望保持这种灵活性，但同时我们不希望一遍又一遍地编写相同类型的路由器。</p><p id="d095" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，让我们来看一个路由器，我们可以为我们的客户编写这个RESTful API。</p><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="3088" class="mz kp in no b gy ns nt l nu nv">import express, { Request, Response } from 'express';<br/>import db from '../../db';<br/>const model = db.Customers;<br/>const router = express.Router();</span><span id="aa91" class="mz kp in no b gy nw nt l nu nv">const getCustomers = async (req: Request, res: Response) =&gt; {<br/>  const results = await model.findAll();<br/>  res.json(results);<br/>};</span><span id="3f1c" class="mz kp in no b gy nw nt l nu nv">const getCustomer = async (req: Request, res: Response) =&gt; {<br/>  const results = await model.findByPk(req.params.id);<br/>  res.json(results);<br/>};</span><span id="b815" class="mz kp in no b gy nw nt l nu nv">const createCustomer = async (req: Request, res: Response) =&gt; {<br/>  const results = await model.create(req.body);<br/>  res.json(results);<br/>};</span><span id="3ad8" class="mz kp in no b gy nw nt l nu nv">const updateCustomer = async (req: Request, res: Response) =&gt; {<br/>  const results = await model.update(req.body, {<br/>    where: {<br/>      id: req.params.id,<br/>    },<br/>  });<br/>  res.json(results);<br/>};</span><span id="586c" class="mz kp in no b gy nw nt l nu nv">const deleteCustomer = async (req: Request, res: Response) =&gt; {<br/>  const results = await model.destroy({<br/>    where: {<br/>      id: req.params.id,<br/>    },<br/>  });<br/>  res.json(results);<br/>};</span><span id="cddd" class="mz kp in no b gy nw nt l nu nv">router.get('/', getCustomers);<br/>router.get(`/:id`, getCustomer);<br/>router.post('/', createCustomer);<br/>router.put(`/:id`, updateCustomer);<br/>router.delete(`/:id`, deleteCustomer);</span><span id="8f4b" class="mz kp in no b gy nw nt l nu nv">export default router;</span></pre><p id="6525" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这种方法没有错，如果您需要做额外的事情，比如发送电子邮件或进行其他api调用，您可以拥有充分的灵活性。但是，您可以从这个示例中看到，它几乎是一个样板路由器，您可以复制并粘贴到另一个路由器中，只需将customer的名称更改为其他资源的名称。</p><p id="4720" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，让我们制作一个中间件，它可以为我们完成所有这些繁重的工作。</p><p id="66b0" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">首先，让我们创建一些助手中间件来帮助处理async /await函数，并以JSON格式返回我们的调用。</p><h2 id="645e" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">助手中间件</h2><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="d728" class="mz kp in no b gy ns nt l nu nv">const asyncEndpoint = (endpoint) =&gt; {<br/>  return async (req: Request, res: Response, next: NextFunction) =&gt;<br/>  {<br/>    try {<br/>      await endpoint(req, res, next);<br/>    } catch (e) {<br/>      next(e);<br/>    }<br/>  };<br/>};</span></pre><p id="e7bb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这将使一个路由能够被包装在一个async / await函数中，如果发生任何错误，我们可以捕捉它并将其发送到下一个Express函数。</p><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="d797" class="mz kp in no b gy ns nt l nu nv">const toJson = (req: Request, res: Response) =&gt; {<br/>  res.status(200).json(req.results);<br/>};</span></pre><p id="9085" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这将被放置在每个路由的末尾，如果路由成功，它将返回JSON形式的响应。</p><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="60ac" class="mz kp in no b gy ns nt l nu nv">import asyncEndpoint from './asyncEndpoint';</span><span id="6bce" class="mz kp in no b gy nw nt l nu nv">export const validateSchema = (...schemas) =&gt; {<br/>  return asyncEndpoint(async (req, res, next) =&gt; {<br/>    for (let schemaItem of schemas) {<br/>      const { schema, path } = schemaItem;<br/>      let validation = schema.validate(req[path], {<br/>        abortEarly: false,<br/>      });<br/>      if (validation.error) {<br/>        let messages = validation.error.details.map((i) =&gt; i.message);<br/>        let errMessage = `Validation errors: ${messages.join(', ')}`;<br/>        throw {<br/>          status: 400,<br/>          message: errMessage,<br/>        };<br/>      }<br/>    }<br/>    next();<br/>  });<br/>};</span></pre><p id="aa54" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这将是我们的验证中间件，将使用hapi / joi包。</p><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="a6b6" class="mz kp in no b gy ns nt l nu nv">export const withSequelize = (<br/>  req: Request,<br/>  res: Response,<br/>  next: NextFunction<br/>) =&gt; {<br/>  const db = req.app.get('db');<br/>  const { Sequelize } = db;<br/>  const {<br/>    page = 0,<br/>    limit = 100,<br/>    order = '',<br/>    attributes = ['id'],<br/>    include,<br/>  }: any = req.query;<br/>  let options: SequelizeOptions = {<br/>    offset: page === 0 ? 0 : parseInt(page) * parseInt(limit),<br/>    limit: parseInt(limit),<br/>  };<br/>  let conditions = {};</span><span id="2866" class="mz kp in no b gy nw nt l nu nv">  if (order &amp;&amp; isString(order)) {<br/>    const [column, direction = 'ASC'] = order.split(',');<br/>    options.order = [[Sequelize.col(column), direction]];<br/>  } else if (order &amp;&amp; isArray(order)) {<br/>    options.order = order.map((orderGroup = '') =&gt; {<br/>      const [column, direction = 'ASC'] = orderGroup.split(',');<br/>      return [Sequelize.col(column), direction];<br/>    });<br/>  }</span><span id="a3ce" class="mz kp in no b gy nw nt l nu nv">  if (attributes &amp;&amp; isString(attributes)) {<br/>    options.attributes = attributes.split(',');<br/>  } else if (attributes &amp;&amp; isArray(attributes)) {<br/>    options.attributes = attributes;<br/>  }</span><span id="ae8e" class="mz kp in no b gy nw nt l nu nv">  if (attributes &amp;&amp; isString(attributes)) {<br/>    options.attributes = attributes.split(',');<br/>  } else if (attributes &amp;&amp; isArray(attributes)) {<br/>    options.attributes = attributes;<br/>  }</span><span id="32ce" class="mz kp in no b gy nw nt l nu nv">  if (include &amp;&amp; isArray(include)) {<br/>    options.include = include.map((includeModel) =&gt; {<br/>      const { model, as, attributes, ...rest }: any = qs.parse(<br/>        includeModel,<br/>        ';',<br/>        '='<br/>      );<br/>      const include: Include = {<br/>        model: db[model],<br/>      };<br/>      if (as) {<br/>        include.as = as;<br/>      }<br/>      if (attributes) {<br/>        include.attributes = attributes.split(',');<br/>      }<br/>      const otherColumns = omit(rest, [<br/>        'page',<br/>        'limit',<br/>        'order',<br/>        'attributes',<br/>        'include',<br/>      ]);<br/>      if (otherColumns) {<br/>        include.where = otherColumns;<br/>      }<br/>      return include;<br/>    });<br/>  }</span><span id="6ad4" class="mz kp in no b gy nw nt l nu nv">  const otherColumns = omit(req.query, [<br/>    'page',<br/>    'limit',<br/>    'order',<br/>    'attributes',<br/>    'include',<br/>  ]);</span><span id="349f" class="mz kp in no b gy nw nt l nu nv">  if (otherColumns) {<br/>    conditions = {<br/>      where: otherColumns,<br/>    };<br/>  }</span><span id="8798" class="mz kp in no b gy nw nt l nu nv">  req.sequelize = {<br/>    options,<br/>    conditions,<br/>  };<br/>  return next();<br/>};</span></pre><p id="5275" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果有任何你应该放入你的军火库的中间件，它将是这个。您可以设置任何读取路径，使其具有分页、条件，并只选择您需要的属性，而不是整个资源。</p><p id="552b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在我上面链接的Github repo中有一些Typescript接口可以查看。这篇文章已经太长了。</p><h2 id="c42b" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">创建资源</h2><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="affe" class="mz kp in no b gy ns nt l nu nv">export const create = (props) =&gt; {<br/>  const route = async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>    const db = req.app.get('db');<br/>    const model = db[props.model];<br/>    if (!model) {<br/>      throw {<br/>        status: 404,<br/>        message: 'Model not found',<br/>      };<br/>    }<br/>    const results = await model.create(req.body);<br/>    req.results = results;<br/>    next();<br/>  };<br/>  return [asyncEndpoint(route), toJson];<br/>};</span></pre><p id="98fa" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这个中间件将接受一个带有模型名称的属性对象。然后，它将从我们的db(数据库)对象中查找模型。如果你没有正确设置模型，它会抛出一个错误。否则，它将执行与普通路由器中的路由相同的操作。</p><h2 id="bf54" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">阅读资源</h2><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="8a96" class="mz kp in no b gy ns nt l nu nv">export const read = (props) =&gt; {<br/>  const route = async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>    const db = req.app.get('db');<br/>    const model = db[props.model];<br/>    if (!model) {<br/>      throw {<br/>        status: 404,<br/>        message: 'Model not found',<br/>      };<br/>    }<br/>    let results = await model.findAll({<br/>      ...req.sequelize.conditions,<br/>      ...req.sequelize.options,<br/>    });<br/>    req.results = results;<br/>    next();<br/>  };<br/>  return [withSequelize, asyncEndpoint(route), toJson];<br/>};</span></pre><p id="d8ef" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这与create函数具有相同的功能，只是因为我们从数据库中读取数据，所以我们可以使用带有Sequelize 中间件的<em class="nl">来帮助控制分页和条件。</em></p><p id="34ff" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">例如，如果我们运行这个API调用:</p><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="f0ec" class="mz kp in no b gy ns nt l nu nv"><a class="ae nx" href="http://localhost:3000/api/v1/customers?attributes=id,first_name&amp;first_name=John" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/v1/customers?attributes=id,first_name&amp;first_name=John</a></span></pre><p id="0e9c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">API将只返回名字为John的客户。</p><h2 id="3250" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">通过Id查找一个资源</h2><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="02e4" class="mz kp in no b gy ns nt l nu nv">export const findByPk = (props) =&gt; {<br/>  const { id } = props;<br/>  const route = async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>    const db = req.app.get('db');<br/>    const model = db[props.model];<br/>    if (!model) {<br/>      throw {<br/>        status: 404,<br/>        message: 'Model not found',<br/>      };<br/>    }<br/>    const results = await model.findByPk(req.params[id], {<br/>      ...req.sequelize.conditions,<br/>      ...req.sequelize.options,<br/>    });<br/>    req.results = results;<br/>    next();<br/>  };<br/>  return [withSequelize, asyncEndpoint(route), toJson];<br/>};</span></pre><p id="c1e2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这类似于read中间件，除了它只会找到一条记录并返回一个对象，而不是一个对象数组。</p><h2 id="62ed" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">更新资源</h2><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="1370" class="mz kp in no b gy ns nt l nu nv">export const update = (props) =&gt; {<br/>  const { key, path, fields } = props;<br/>  const route = async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>    const db = req.app.get('db');<br/>    const model = db[props.model];<br/>    if (!model) {<br/>      throw {<br/>        status: 404,<br/>        message: 'Model not found',<br/>      };<br/>    }<br/>    const results = await model.update(req.body, {<br/>      where: {<br/>        [key]: get(req, path),<br/>      },<br/>      fields,<br/>    });<br/>    req.results = results;<br/>    next();<br/>  };<br/>  return [asyncEndpoint(route), toJson];<br/>};</span></pre><p id="88cb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您可以开始看到，我们正在从上面的普通路由器构建相同功能的通用版本。您可以在您的路由器中使用其中任何一种或其中一种。如果你不需要做什么特别的事情，这些中间件会大大加快你构建一个API的时间。</p><h2 id="d074" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">删除资源</h2><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="d49f" class="mz kp in no b gy ns nt l nu nv">export const destroy = (props) =&gt; {<br/>  const { key, path } = props;<br/>  const route = async (req: Request, res: Response, next: NextFunction) =&gt; {<br/>    const db = req.app.get('db');<br/>    const model = db[props.model];<br/>    if (!model) {<br/>      throw {<br/>        status: 404,<br/>        message: 'Model not found',<br/>      };<br/>    }<br/>    const results = await model.destroy({<br/>      where: {<br/>        [key]: get(req, path),<br/>      },<br/>    });<br/>    req.results = results;<br/>    next();<br/>  };<br/>  return [asyncEndpoint(route), toJson];<br/>};</span></pre><p id="1c77" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在我们有了一些中间件，可以为我们构建RESTful API路由，让我们以创建一个序列路由器来结束，它可以接受所有这些中间件并为我们构建一个动态API。</p><h2 id="ab7b" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">顺序路由器</h2><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="c977" class="mz kp in no b gy ns nt l nu nv">import express from 'express';<br/>import { validateSchema } from './validateSchema';<br/>import { create, read, findByPk, update, destroy } from './sequelize';</span><span id="aeb4" class="mz kp in no b gy nw nt l nu nv">const sequelizeRouter = (props) =&gt; {<br/>  const { model, key = 'id', schemas } = props;<br/>  const router = express.Router();<br/>  <br/>  router.get('/', read({ model }));<br/>  router.get(`/:${model}Id`, findByPk({ model, id: `${model}Id` }));<br/>  router.post('/', validateSchema(schemas.create), create({ model }));<br/>  router.put(<br/>    `/:${model}Id`,<br/>    validateSchema(schemas.update),<br/>    update({<br/>      model,<br/>      key,<br/>      path: `params.${model}Id`,<br/>    })<br/>  );<br/>  router.delete(<br/>    `/:${model}Id`,<br/>    destroy({<br/>      model,<br/>      key,<br/>      path: `params.${model}Id`,<br/>    })<br/>  );<br/>  return router;<br/>};</span><span id="39c3" class="mz kp in no b gy nw nt l nu nv">export default sequelizeRouter;</span></pre><p id="ec15" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在我们有了这个最终的中间件，我们可以像这样重写我们的普通客户路由器:</p><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="e4c6" class="mz kp in no b gy ns nt l nu nv">import joi from '@hapi/joi';<br/>import sequelizeRouter from '../../../../../middleware/sequelizeRouter';</span><span id="c7a1" class="mz kp in no b gy nw nt l nu nv">const createSchema = {<br/>  path: 'body',<br/>  schema: joi.object().keys({<br/>    first_name: joi.string().required(),<br/>    last_name: joi.string().required(),<br/>  }),<br/>};</span><span id="2c1e" class="mz kp in no b gy nw nt l nu nv">const updateSchema = {<br/>  path: 'body',<br/>  schema: joi.object().keys({<br/>    first_name: joi.string().required(),<br/>    last_name: joi.string().required(),<br/>  }),<br/>};</span><span id="6a92" class="mz kp in no b gy nw nt l nu nv">const router = sequelizeRouter({<br/>  model: 'Customers',<br/>  schemas: { create: createSchema, update: updateSchema },<br/>});</span><span id="b7d0" class="mz kp in no b gy nw nt l nu nv">export default router;</span></pre><p id="92c4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您现在可以看到，我们可以通过中间件完成所有繁重的工作，现在我们唯一需要关心的是允许创建和更新的模式，以及模型的名称。如果您不关心模式验证，那么您只需要:</p><pre class="kd ke kf kg gt nn no np nq aw nr bi"><span id="1837" class="mz kp in no b gy ns nt l nu nv">const router = sequelizeRouter({<br/>  model: 'Customers',<br/>});</span></pre><p id="768f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，通过传递模型名，我们可以用几行代码构建一个完整的RESTful API。</p><p id="45fa" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果你确实需要做一些更健壮或更灵活的事情，你可以很容易地脱离这些功能，做你自己的事情。然而，通过保持API的可预测性、一致性和可伸缩性，您可以在此基础上构建更多，例如添加缓存和事件处理。</p><h2 id="999b" class="mz kp in bd kq na nb dn ku nc nd dp ky lp ne nf la lt ng nh lc lx ni nj le nk bi translated">结论</h2><p id="a39f" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">当你一次又一次地使用相同的模式时，编写完成所有繁重工作的代码是有益的。创建动态中间件来为您生成代码使得跨API实现新特性变得如此容易。我们创建了每个中间件来处理HTTP方法，并为我们构建了一个Express路由器。</p><p id="b05e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">让我知道你对这种方法的看法。你一直喜欢手工编码普通路由器吗？你遇到过不同的举重方法吗？</p></div></div>    
</body>
</html>