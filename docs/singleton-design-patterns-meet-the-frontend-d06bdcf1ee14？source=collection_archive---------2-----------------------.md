# 用 Angular 在 JavaScript 中创建单例

> 原文：<https://javascript.plainenglish.io/singleton-design-patterns-meet-the-frontend-d06bdcf1ee14?source=collection_archive---------2----------------------->

## 设计模式符合前端

![](img/1ad663c82cb4777459b0eebf4286324e.png)

作为一名棱角分明的开发者，我每天都在处理单个的`Injectables`形状。然而，当我坐下来写关于单身族的文章时，我又看了一眼。

*注意:本文中的代码示例将使用*[*TypeScript(3.7)*](http://www.typescriptlang.org/)*，最后两个示例将使用 Java。*

让我们把它分成几个问题:

*   🤔什么构成了独生子女？
*   ❓:为什么它们用在有棱角的地方？
*   😍我们从单身族身上得到了什么优势？
*   📣为什么会有关于它们是否是反模式的争论？

在这篇文章中，我将试图阐明其中的一些问题。

# 🤔什么构成了独生子女？

我们将从单体的定义开始:

> *类的实例化对单个实例的限制。*

换句话说，任何时候我们实例化一个类，我们都只能得到该类的第一个实例。这些单件可以实现接口，作为参数传递给方法，并且可以是多态的 T21。

然而，每次我们使用该类时，它将是我们第一次创建的同一个对象。下面的代码示例可能更能说明这种情况:

就是这样！创建单例就是这么简单！🔥🔥🔥

但是这到底是什么意思呢？这将如何影响我们的程序设计，我们在其中找到了价值？

好吧，单例可以用来存储共享状态。你可以在你的应用中实例化你的 Singleton，改变其中的一些数据，它会在你的应用中得到反映。

如果你不仔细考虑，⚠️这样做可能会有危险！

让我们修改上面的示例来说明这一点:

上述示例的结果是:

```
Hi, my name is John 
Hi, my name is John
```

🤔🤔但是我们不是把`myService.user`设置成了一个`Colum`的名字吗？

是的，但那是在我们将`differentService.user`命名为`John`之前。

通过这样做，由于`UserService`只能有一个实例，我们实际上将*单个* `user`对象的名称从`Colum`改为`John`。

这种能够共享状态的想法有时非常有用，例如，如果您想要跟踪当前登录的用户。

单例可以延迟加载，这可能会提高应用程序的启动性能，但是，在多线程语言中，延迟加载单例的实现可能会导致跨多线程的多个实例化问题，如果没有声明跨线程同步，则会破坏模式。

# ❓:那么，它们为什么用在有棱角的地方呢？

Angular 的[依赖注入](https://angular.io/guide/dependency-injection)依赖`Injectables`。依赖注入本身也是一种设计模式，但是它在这里是相关的，因为在这个上下文中，它使用了单例模式。

Angular 应用程序通常包含多个模块(`NgModules`)，但至少有一个根模块，其中包含应用程序所需的列表。然后将它们注入到需要它们的类中。

让我们来看一个寻找一个`LogService`注入其中的角形组件。

首先，我们组件的`constructor`接受了一个`LogService`类型的参数。
其次，在没有创建这个类的实例的情况下，我们在我们的`ngOnInit()`方法中使用它。这是因为 Angular 将实例化这个类，将它保存在内存中，并将其传递给任何需要它的类。

通过这样做，Angular 也利用了 Singleton 模式，因为它只实例化一个模块的提供者一次，并将对这个实例的引用传递给依赖它的任何类。

# 😍我们从单身族身上得到了什么优势？

如前所述，我们可以通过使用 Singleton 模式与应用程序中的不同区域共享状态，在 Angular 中，由于依赖注入系统，这变得更加简单。

有些用例涉及对数据存储的单一访问、跟踪购物车中的活动商品、单一真实来源等。

⚠️ *请注意，单身族并不打算取代你正在使用的任何国家管理系统。*

然而，它还允许我们创建逻辑服务，这是一类可以在多种情况下重用以提供相同逻辑的方法，可以只实例化一次，有助于提高代码的可重用性和可维护性，而不会对内存使用或应用程序的性能产生很大影响。

这些用例是调用 API 端点的数据服务，这些服务将基于传递给它们的方法的参数做出并返回决策。

# 📣为什么会有关于它们是否是反模式的争论？

有一种观点认为，通过积极地违反依赖倒置(DI)原则，单例在代码中促进了糟糕的设计。在构造函数中接受接口作为参数的类，可以简单地接受一个常量/最终实例化对象作为参数。

这种争论通常来自使用强类型语言的开发人员，或者当他们完全控制他们的 DI 系统时。请参见下面的 Java 示例，以了解更多信息:

正如我们从上面所看到的，开发人员完全控制着应用程序的结构，可以自己决定他们想要使用的接口的实现，可以在应用程序启动时初始化它们，并将它们传递给相关的类。

如果这里要使用 Singleton 模式，那么只能使用数据服务的一种可能的实现。请参见下面代码中的变化:

虽然上面的代码可能更小，但它确实打破了依赖倒置原则，并在依赖单例的类和单例本身之间创建了更紧密的耦合。

# 然而❗❗❗

值得注意的是，Angular 通过使用[注入令牌](https://angular.io/guide/dependency-injection-in-action#supply-a-custom-provider-with-inject)解决了这个问题，这是一个稍微高级一点的话题。它允许您在 NgModule 级别提供具体的实现，而不是将您的组件和服务耦合到您的 Singletons。
🚀🚀🚀

希望你多学了一点(*？*)关于本文中的单件，它们的一些用例以及它们在 Angular 中的实现。

如有任何问题，欢迎在下方提问或在 Twitter 上联系我: [@FerryColum](https://twitter.com/FerryColum) 。

*原发布于 2019 年 11 月 27 日*[*https://dev . to*](https://dev.to/coly010/singleton-design-patterns-meet-the-frontend-12m1)*。*