<html>
<head>
<title>Solving a Conceptual Interview Question in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript解决一个概念性面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solving-a-conceptual-interview-question-in-javascript-d904e8fd95ea?source=collection_archive---------3-----------------------#2020-06-17">https://javascript.plainenglish.io/solving-a-conceptual-interview-question-in-javascript-d904e8fd95ea?source=collection_archive---------3-----------------------#2020-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aaf74142200d23f47f44a6bc79f304c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qijuVdngMtsPx-96"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@by_syeoni?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Suhyeon Choi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ff37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，在一次模拟技术面试中，我被要求回答这个面试问题:</p><p id="5683" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">假设你正在为一家航空公司构建一个靠背娱乐系统。你的任务是实现一个功能，允许用户观看电影对，其总运行时间将等于他们飞行的确切长度。</em></p><p id="2506" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">编写一个函数，该函数采用一个整数</em> <strong class="kc io"> <em class="ky"> flightLength(以分钟为单位)</em> </strong> <em class="ky">和一个整数数组</em> <strong class="kc io"> <em class="ky"> movieLengths(以分钟为单位)</em> </strong> <em class="ky">并返回一个布尔值，该值指示在</em><strong class="kc io"><em class="ky">movie lengths</em></strong><em class="ky">中是否有两个数字的和等于</em><strong class="kc io"><em class="ky">flight length</em></strong></p><p id="c46c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">用户不能两次观看同一部电影，只有在飞行期间可以观看完整的两部电影时，该函数才应返回true。</em></p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="d42a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像大多数编码挑战一样，这里有多种方法来解决问题。首先，我们将实现一个强力解决方案，以便理解问题并让我们的代码工作。</p><p id="f2c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">稍后，我们将探讨重构代码以优化运行时时的一些关键概念。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h2 id="9f14" class="lg lh in bd li lj lk dn ll lm ln dp lo kl lp lq lr kp ls lt lu kt lv lw lx ly bi translated"><strong class="ak">天真的方法</strong></h2><p id="cc50" class="pw-post-body-paragraph ka kb in kc b kd lz kf kg kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx ig bi translated">首先，让我们硬编码一个<code class="fe me mf mg mh b">flightLength</code>和几个不同的<code class="fe me mf mg mh b">movieLengths</code>数组。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/b9c81c51c1ab88d2d6994e32dc1dbc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*izgB3R8ncAzQ610PfgCF8A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Example inputs</figcaption></figure><p id="786d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设<code class="fe me mf mg mh b">flightLength</code>为160分钟，<code class="fe me mf mg mh b">movieLengths1</code>不包含两个合起来等于160分钟的运行时。这里，我们应该返回false。</p><p id="5390" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe me mf mg mh b">movieLengths2</code>返回true，因为运行时间为110分钟和50分钟的电影总计为160分钟。</p><p id="0baf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe me mf mg mh b">movieLengths3</code>也返回true，因为有两个<em class="ky">独立的</em>电影，运行时间为80分钟。它们合起来等于160分钟。</p><p id="1b9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们天真的方法可能是这样的:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f064d6f243552b7d5359800eabd66a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*QI50QyJyWEeSLzH1R8s5-w.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A naïve approach using a nested loop</figcaption></figure><p id="e3f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们使用一个循环来迭代<code class="fe me mf mg mh b">movieLengths</code>数组，并选择我们的第一部电影。然后，我们进入一个嵌套循环来选择我们的第二部电影。如果<code class="fe me mf mg mh b">flightLength</code>等于<code class="fe me mf mg mh b">firstMovieLength</code>和<code class="fe me mf mg mh b">secondMovieLength</code>之和，函数将返回true。否则，我们将停留在嵌套循环中，重置<code class="fe me mf mg mh b">secondMovieLength</code>的值，并在每次迭代中比较它和<code class="fe me mf mg mh b">firstMovieLength</code>到<code class="fe me mf mg mh b">flightLength</code>的和，直到没有第二部电影可供选择。</p><p id="c5bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们到达了数组的末尾，却没有找到一个与我们的<code class="fe me mf mg mh b">firstMovieLength</code>组合在一起等于<code class="fe me mf mg mh b">flightLength</code>的<code class="fe me mf mg mh b">secondMovieLength</code>，我们将跳出我们的嵌套循环，回到我们的原始循环中，在那里我们将设置数组中的下一部电影等于<code class="fe me mf mg mh b">firstMovieLength</code>。然后，重复该过程。如果没有任何两个电影长度可以组合等于<code class="fe me mf mg mh b">flightLength</code>，我们的函数返回假。</p><p id="82c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这个解决方案可行，但远非理想。嵌套循环导致运行时间为<em class="ky"> O </em> (n)。这意味着随着我们的<code class="fe me mf mg mh b">movieLengths</code>数组大小的增加，我们的算法将需要成倍增加的时间来运行。只要有可能，就应该避免使用它们，而且通常可以重构为更有效的解决方案。</p><p id="515f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">花一分钟时间停下来，想想我们如何在这里重构代码。怎样才能避免内循环？内循环到底在做什么？</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/1d2224a76f8df732c3114567304b6ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*AwtCKtl5R5nyMb24p9NqZA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The inner loop</figcaption></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="08e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分步朗读:对于外循环中选作<code class="fe me mf mg mh b">firstMovieLength</code>的电影之后的每一部电影，如果<code class="fe me mf mg mh b">flightLength</code>等于<code class="fe me mf mg mh b">firstMovieLength</code>和<code class="fe me mf mg mh b">secondMovieLength</code>之和，则返回true。</p><p id="9e20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与其将<code class="fe me mf mg mh b">flightLength</code>与每一对可能的电影之和进行比较，不如我们移动一些数学运算，首先找出我们的函数返回true所需的第二部电影的长度？</p><p id="a401" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以在定义了<code class="fe me mf mg mh b">firstMovieLength</code>的值之后，在外部循环中这样做:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e7ac4a016efb936534017149cf00fe18.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*sh0_ufVU3fxcabhoQq1Jxw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Set target equal to the difference between flightLength and firstMovieLength</figcaption></figure><p id="5b73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">啊哈！所以现在我们有了第二部电影的目标长度，而不是使用内部循环来比较<code class="fe me mf mg mh b">flightLength</code>和每对电影的总和，我们可以在原始数组中搜索我们的目标长度！对吗？！嗯…没那么快。</p><p id="1c3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">诚然，我们<em class="ky">可以</em>实现这样的解决方案，从而避免在我们的代码中显式写出内部循环，但是在数组上执行搜索需要<em class="ky"> O </em> (n)，因此我们代码的运行时间最终将是相同的，<em class="ky"> O </em> (n)。这是因为我们将设置<code class="fe me mf mg mh b">firstMovieLength</code> <em class="ky"> O </em> (n)次，然后在数组中搜索<code class="fe me mf mg mh b">secondMovieLength</code> <em class="ky"> O </em> (n)。</p><p id="b6c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该死。如果有一种数据结构能让我们在恒定的时间内进行搜索就好了</p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="1ef0" class="lg lh in bd li lj lk dn ll lm ln dp lo kl lp lq lr kp ls lt lu kt lv lw lx ly bi translated"><strong class="ak">使用一个物体</strong></h2><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/64782cb2cdda5b44efe571272b861e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*OhsVAEZdadQF50PgBbnzfw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Create an object to hold movieLengths values as keys</figcaption></figure><p id="bb68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以从<code class="fe me mf mg mh b">movieLengths</code>数组中创建一个对象，以便在常量时间内查找我们的目标值。我们迭代每个电影长度，如果电影长度在我们的<code class="fe me mf mg mh b">movieLengthsObj</code>中还不存在，我们为该电影长度创建一个键，并将其值设置为1。如果它确实存在，我们就把它的值加1。这是很重要的，这样我们就可以跟踪具有相同运行时间的不同电影，例如我们在<code class="fe me mf mg mh b">movieLengths3</code>中设置的虚拟数据。</p><h2 id="6f71" class="lg lh in bd li lj lk dn ll lm ln dp lo kl lp lq lr kp ls lt lu kt lv lw lx ly bi translated"><strong class="ak">现在为剩下的代码</strong></h2><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/a7b1ac12c6fdee5dd091e69f9c2e9e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Up0NwtsTVw3XJZ-RnrU62w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Looking up target value in movieLengthsObj</figcaption></figure><p id="28f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在设置了<code class="fe me mf mg mh b">firstMovieLength</code>并为我们的第二个电影长度计算了一个目标值之后，我们搜索<code class="fe me mf mg mh b">movieLengthsObj</code>来查看目标电影长度是否作为一个键存在。如果是的话，如果目标值不等于我们的<code class="fe me mf mg mh b">firstMovieLength</code>或者对应于我们的目标电影长度的键值大于1，我们将返回true。这使得我们可以避免对同一部电影进行两次计数，并考虑共享相同运行时间的不同电影。</p><p id="39b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可能看起来比我们的第一个解决方案多了很多代码，你可能会想如果我们仍然有两个循环会有什么好处。虽然这是真的，但重要的是循环不是嵌套的。这意味着在计算我们的Big O运行时，我们将它们加在一起，而不是相乘。<em class="ky">O</em>(n)+<em class="ky">O</em>(n)=<em class="ky">O</em>(2n)，由于大O只是一个近似值我们可以把系数去掉，称之为<em class="ky"> O </em> (n)。厉害！</p><p id="3272" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在使用一个对象查找我们的目标值后，我们从第一个解决方案中的<em class="ky"> O </em> (n)到<em class="ky"> O </em> (n)。完成了吗？不完全是。</p><h2 id="a8a6" class="lg lh in bd li lj lk dn ll lm ln dp lo kl lp lq lr kp ls lt lu kt lv lw lx ly bi translated">让我们把它清理得更干净些</h2><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/ef9abfa06ad043ba091bbdcaf4583c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*3wRBHWGjG1Mbg9eRrnxUIw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Final solution</figcaption></figure><p id="63d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们不是从一开始就用所有的<code class="fe me mf mg mh b">movieLengths</code>值填充我们的对象，而是在检查我们的目标值是否存在于<code class="fe me mf mg mh b">movieLengthsObj</code>中之后，只给我们的对象<em class="ky">添加一个电影长度。在这种情况下，我们不需要担心增加键值，因为我们只能向后比较在之前的循环迭代中已经设置为<code class="fe me mf mg mh b">firstMovieLength</code>的电影。不可能对同一部电影进行两次求和，共享相同运行时间的独立电影可以放心地加在一起。</em></p><p id="88ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为奖励，使用这种方法我们还优化了最佳情况下的空间效率<code class="fe me mf mg mh b">movieLengthsObj</code>。</p><p id="9a17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这与我们最初的嵌套循环解决方案相比如何？</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="5605" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读，如果您有不同的方法来解决这个问题，请在评论中告诉我。很想听听你的想法！</p></div></div>    
</body>
</html>