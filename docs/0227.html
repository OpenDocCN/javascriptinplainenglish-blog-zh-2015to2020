<html>
<head>
<title>Harnessing the power of Mixins in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用混音的力量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/harnessing-the-power-of-mixins-in-angular-f2faa432add2?source=collection_archive---------0-----------------------#2019-08-29">https://javascript.plainenglish.io/harnessing-the-power-of-mixins-in-angular-f2faa432add2?source=collection_archive---------0-----------------------#2019-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/67b18253ab08ad974adfc17aea2b4bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*Ei-NUxcFKtzN3GLkvZiGuw.png"/></div></div></figure><p id="3053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么是mixin？根据版本<a class="ae kt" href="https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#support-for-mix-in-classes" rel="noopener ugc nofollow" target="_blank"> 2.2 </a>，TypeScript现在支持mixin的概念——这个函数可以接受一个类，用一些功能扩展它，然后返回新的类，允许其他类从中扩展——允许类混合和共享功能！</p><h1 id="fc40" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">它是如何工作的？</h1><p id="09bb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这个概念相当简单——如果我们熟悉继承、高阶类/函数及其语法，我们就可以直接进入它们。下面是TypeScript文档本身的示例:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7ba1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们看到的，我们在这里使用一个函数来创建另一个类的丰富版本，它既可以用来实例化新对象，也可以用来扩展其他类。在某种意义上，这现在允许多重继承—如果我们的一些类只需要共享功能(<em class="md"> abstract </em> class)，那么我们可以将它写在一个函数内，这样它就可以与其他类混合，以便进一步组合。</p><h1 id="4c75" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">这个怎么用？</h1><p id="8359" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">假设一个普通的Angular应用程序有不同的页面，其中一些页面有表单。一切都很好，然后有一天我们决定，从现在开始，如果用户触摸一个表单，但试图离开页面而不保存它，应该显示一个窗口，要求用户确认他们是否真的想离开页面(一个非常标准的功能)。</p><p id="7023" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，首先想到的是一个<code class="fe me mf mg mh b">Guard</code>。因为我们的应用程序设计得很时尚，<em class="md">大部分</em>(但<strong class="jx io">不是</strong>全部！)包含表单的组件有一个通用的<code class="fe me mf mg mh b">form</code>字段，它是<code class="fe me mf mg mh b">AbstractFormControl</code>的一个实例。当然，从那时起我们可以检查<code class="fe me mf mg mh b">form</code>属性的<code class="fe me mf mg mh b">touched</code>字段，如果有必要显示提示的话。守卫可以是这样的:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="6d56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，这在纸面上看起来不错，但实际上，正如上面简要提到的，并不是每个页面都是这样的——有些页面有多个表单，有些页面的子组件中有表单，有些页面两者都有。当然，我们希望防护装置以相同的方式为每个组件工作，我们也希望非常精确和一致。所以这里有一个想法:从现在开始，每个应该有这个保护的组件都应该实现一个叫做<code class="fe me mf mg mh b">isFormTouched</code>的特殊方法，这个方法将返回一个<code class="fe me mf mg mh b">boolean</code>来告诉这个保护是否必须显示提示。下面是一个更复杂的组件的例子，它的表单<em class="md">不在它自身</em>中，而是在它的子组件中，以及它如何实现这个方法:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="8898" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，这很好，但是对于大多数组件(比如90%)来说,<code class="fe me mf mg mh b">isFormTouched</code>方法可以归结为:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5445" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们可以将这个方法复制并粘贴到我们需要它的每个组件中，但是这个操作本身就有问题，对吗？我们不想要这个解决方案的一个原因是，有一天，它可能还需要检查表单是否已经被提交(在同一个类上使用一个<code class="fe me mf mg mh b">isSubmitted</code>属性)。那将需要我们重写<strong class="jx io">许多</strong>代码。如果我们遗漏了一个实例，可能要过很久才会有人发现这样一个小错误。因此，自然地，我们想要一个解决方案，让我们只写一次特定的方法<em class="md"/>，但是仍然在我们所有需要它的组件之间共享它。很自然地，我们想到了继承——但是这里有三个基本的缺点:</p><ol class=""><li id="b9bd" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">惯用的:继承意味着表示一种<em class="md">是-一种</em>关系(如“马是一种动物”)，而不是共享功能。依赖注入或对象组合被用于此。</li><li id="2187" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">范例:这个类应该代表什么？在一些面向对象的语言中有一个叫做<code class="fe me mf mg mh b">trait</code>的概念，它允许这样的事情，但是在JS中我们没有这样的特性，所以我们的类应该代表一些东西，而不仅仅是包含一个简单的方法。</li><li id="0299" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">实用:如果将来我们需要从另一个基类扩展我们的组件怎么办？在那种情况下，我们会束手无策。</li></ol><h1 id="6346" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">混血儿来拯救</h1><p id="d610" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">看看这个函数:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="49f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，这个函数接受一个简单的类(也可以是一个角度组件)并返回另一个组件，该组件从它扩展而来，并在其上实现了<code class="fe me mf mg mh b">isFormTouched</code>方法。我们可以做这个简单的事情:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="07f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是这个函数如何解决上述三个问题:</p><ol class=""><li id="66bd" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">因为它被命名为<code class="fe me mf mg mh b">WithFormTouchedCheck</code>，所以它现在代表了一个类(它可以作为一个参数获得——或者没有它，请注意<code class="fe me mf mg mh b">Base: Constructor&lt;T&gt; = (class {} as any)</code>行，这基本上意味着如果没有给定类，将会扩展一个空的类),该类被增强了一些额外的特性。</li><li id="36f5" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">这个函数本身并不是一个类，它只代表了一个添加到现有函数中的功能——假设它实现了某个接口——这就是为什么它被声明为抽象的原因。</li><li id="4c09" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">因为它接受另一个类作为参数，所以现在它也允许我们从其他类扩展我们的组件。事实上，只要我们保持这种形式，我们就可以想上多少课就上多少课！</li></ol><h1 id="64d5" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">混合东西</h1><p id="867f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我相信你们很多人都听说过关于<a class="ae kt" href="https://gist.github.com/ThomasBurleson/df0d9554b5d30d365cd8737a36d69fe3" rel="noopener ugc nofollow" target="_blank">僵尸订阅</a>的可怕故事，以及我们如何通过使用<code class="fe me mf mg mh b">takeUntil</code>操作符来避免它们。当然，我们还需要为此创建一个特定的<code class="fe me mf mg mh b">Subject</code>，并在我们的<code class="fe me mf mg mh b">ngOnDestroy</code>方法中发送一个<code class="fe me mf mg mh b">next</code>通知。事实上，代码如下:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="0f5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的许多组件内部可能都有订阅，并且所有的组件都应该实现相同的功能，所以将其转换为mixin是有意义的:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="55a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，使用我们以前的mixin的组件可能也需要这个新的，但是将它们组合起来是极其容易的:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="70e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">小心</strong>:我们在mixin中实现了<code class="fe me mf mg mh b">ngOnDestroy</code>方法:如果你要在一个类中使用它，这个类本身也会实现<code class="fe me mf mg mh b">ngOnDestroy</code>方法，一定要在里面调用<code class="fe me mf mg mh b">super.ngOnDestroy()</code>！</p><h1 id="1fb3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">骗局</h1><p id="0865" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当然，编程中的每一种方法都可能有一些缺点。在我们的例子中，大多数错误都与一些特定于Typescript编译器的问题或者角度构建问题有关。这里我呈现其中的两个，可能是最让人沮丧的。</p><p id="72d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.<code class="fe me mf mg mh b">Decorators are not valid here</code>问题:</p><p id="5880" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们尝试在mixin中使用这样的装饰器:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5b79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将得到一个显示<code class="fe me mf mg mh b">Decorators are not valid here</code>的错误。这实际上是Typescript编译器的一个问题。以下是一种解决方法:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Somehow Typescript is only okay when we put decorators on a named class</figcaption></figure><p id="0c70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.角度输入问题:</p><p id="d55e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们在一个mixin类中包含一个decorator，例如，在类上定义一个<code class="fe me mf mg mh b">Input</code>属性，那么当我们<code class="fe me mf mg mh b">ng serve</code>我们的应用程序时，它将按预期工作，但是在产品构建期间将抛出一个错误。这与这个<a class="ae kt" href="https://github.com/angular/angular/issues/25249" rel="noopener ugc nofollow" target="_blank">问题</a>有关。这个问题的解决方法有点混乱:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2768" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这当然需要在子组件上做更多的工作，Angular自己的风格指南不允许在decorators中使用<code class="fe me mf mg mh b">inputs</code>数组，但这仍然是一种变通方法。我个人并不介意，直到Angular团队给我们提供了解决方案。</p><h1 id="5de0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="8d08" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Typescript mixins是一种很好的方式，可以在不中断任何流程的情况下，通过共享功能来增强我们的Angular应用程序。虽然这项技术仍然有一些小的缺点，但我个人认为它的好处远远大于它们。</p><p id="f5bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="md">关注我关于</em> <a class="ae kt" href="https://medium.com/@Armandotrue" rel="noopener"> <em class="md">中型</em> </a> <em class="md">和</em><a class="ae kt" href="https://twitter.com/Armandotrue" rel="noopener ugc nofollow" target="_blank"><em class="md">Twitter</em></a><em class="md">了解更多关于Angular、Rxjs、React和Javascript的一般信息</em>。</p></div></div>    
</body>
</html>