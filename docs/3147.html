<html>
<head>
<title>How to handle comparison corner cases?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理比较角案例？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-comparison-corner-cases-c96ae9a17d4a?source=collection_archive---------3-----------------------#2020-09-03">https://javascript.plainenglish.io/how-to-handle-comparison-corner-cases-c96ae9a17d4a?source=collection_archive---------3-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="a083" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">JavaScript算法可以“不可预测”！</h2><div class=""/><div class=""><h2 id="f872" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">抓住所有这些案例，开始编写一流的代码！</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/27fb5ab25fa6c9f7da8edb56bc992a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNArmsLDeouV0GoryF4IlA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@goshua13?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joshua Aragon</a> on <a class="ae le" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="lf lg lh"><p id="4d87" class="li lj lk ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">任何足够先进的技术都和魔法没什么区别</p><p id="5389" class="li lj lk ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><em class="iq">——</em>亚瑟·C·克拉克(第三克拉克定律)</p></blockquote><p id="d8e2" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">在我们开始熟悉JavaScript边角案例之前，我想区分一下<strong class="ll ja">边角案例</strong>和<strong class="ll ja">边缘案例</strong>。</p><p id="e00e" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">我们可以说<strong class="ll ja">边缘情况是一个只有在最小或最大参数</strong>下才会发生的问题。预测它可能是一项重要的任务，因为这些情况可能会被忽视或低估。例如，处于全功率的PC可能会过热，其性能可能会略有下降。</p><p id="0866" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">我也很乐意介绍一个<strong class="ll ja">边界案例</strong>(也是一个有疑问的主题)。如果其中一个参数超出最小或最大限值，就会发生这种情况。</p><p id="1f3d" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated"><strong class="ll ja">边角案例</strong>呢？我不会给出任何定义，因为在你看了下面的例子后，你就可以自己做了。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="d889" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">你不会相信的！</h1><p id="194c" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">如果我问你，某物的强制性能等于它自身的否定吗，你会怎么回答？你可能会说这是一个无意义的问题，但是:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="aa2b" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">你可能认为JS是一种疯狂的语言，对于JS这样的流行语言来说，这种情况不应该发生。这个例子很傻，因为在真实的例子中，你永远不会把价值和它本身的否定相比较。但是这是一个很好的例子，可以帮助你澄清和采用正确的心智模式！</p><p id="5e46" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated"><strong class="ll ja">你永远也不会遇到将数组与负数组进行比较的情况。你永远不会用这种方式设计代码。这是你不想管理代码库的一个很好的例子。</strong></p><p id="675c" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">在下一个例子中，我将详细解释发生了什么，这样你就可以清楚地了解算法在做什么:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ccbf" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">首先，我将参考<a class="ae le" href="http://documentation" rel="noopener ugc nofollow" target="_blank">文档</a>。在第6行，我们比较了原始值和非原始值。在这种情况下，规则11适用。<strong class="ll ja">这个算法的结果是一个空字符串。</strong></p><p id="ecb9" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">下一步，我们将一个空字符串与假字符串进行比较。根据算法，适用规则№9。下一步(第8行)是应用规则№5。第五步，比较两个数。由于我们正在使用相等比较，<strong class="ll ja">我们将调用严格相等比较算法</strong>。</p><p id="8927" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">最后一步是从严格的相等比较中返回一个<em class="lk"> true </em>。第二个例子更实际一点，因为我们使用了not equals(双重相等否定)- <strong class="ll ja">检查是否不强制相等</strong>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6e45" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">当我们比较两个非原始类型时，这意味着我们将执行一个身份比较。这同样适用于使用严格相等比较的情况。</p><h1 id="66d5" class="mp mq iq bd mr ms no mu mv mw np my mz kf nq kg nb ki nr kj nd kl ns km nf ng bi translated">不要惹布尔人</h1><p id="d12c" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">让我们来谈谈布尔及其与抽象等式的联系。这是你经常做的事情。我们应该看看可能发生的极端情况:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="23fe" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated"><strong class="ll ja">直截了当有时会产生不必要的问题。</strong>在第二个if子句中，我们比较了array和boolean。你可能认为这个操作的结果是布尔<em class="lk">真</em>，但事实并非如此。<em class="lk"> </em> <strong class="ll ja">同样的效果会与严格的相等。</strong></p><p id="2e99" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">一个数组和一个布尔值的比较将贯穿于许多关键情况。在我们看例子之前，我给你一个提示:<strong class="ll ja">永远不要在boolean ( <em class="lk"> true </em>和<em class="lk"> false </em> ) </strong>中使用double equals。我们来分析一下算法是如何工作的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d211" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">第一个if子句不言自明，所以我不会浪费时间解释。和前面的例子一样，<strong class="ll ja">我参考了</strong> <a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ja">的文档</strong> </a>。比较数组和布尔是要调用<a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" rel="noopener ugc nofollow" target="_blank"><em class="lk">to primitive()</em></a>抽象运算(规则№11)因为比较的值之一是非原语类型。</p><p id="059c" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">接下来的三步很简单。首先，我们将一个布尔值转换成一个数字(rule№9:<a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-tonumber" rel="noopener ugc nofollow" target="_blank"><em class="lk">to number(true)</em></a>)，下一步字符串变成数字(rule№5:<a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-tonumber" rel="noopener ugc nofollow" target="_blank"><em class="lk">to number(" "</em></a>)，最后一步是执行严格的相等比较。第三条与前一条相同。</p><p id="1175" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">强制的缺点之一是抽象操作<em class="lk"> ToNumber() </em>。我不确定将一个空字符串转换成数字是否应该返回<em class="lk"> 0 </em>。最好返回<em class="lk"> NaN </em>，因为<em class="lk"> NaN </em>代表一个无效数字。</p><p id="5d20" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">结论:<strong class="ll ja">无谓的输入总会产生无谓的输出。我们不必一直都很明确。隐式有时比显式更好。</strong></p><p id="f7c3" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">当您检查数组中的值是否存在时，您可以做的最好的事情是更明确地检查<code class="fe nt nu nv nw b">.length</code>的存在，以确保它是一个字符串或数组:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8d00" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">深查更靠谱。如你所见，一个空数组将返回<em class="lk">真</em>(在布尔强制之后)。同样的事情也适用于对象- <strong class="ll ja">总是做深度检查</strong>。当我们确定类型是字符串或数组时，我们将使用<code class="fe nt nu nv nw b">typeof</code>操作符(或<code class="fe nt nu nv nw b">Array.isArray()</code>方法)。</p><h1 id="de34" class="mp mq iq bd mr ms no mu mv mw np my mz kf nq kg nb ki nr kj nd kl ns km nf ng bi translated">澄清</h1><p id="b57d" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">有一些指导方针你必须遵循，以避免陷入困境。到处使用双等号可能是一把双刃剑。请记住，当被比较值的任一侧为<em class="lk"> 0 </em>时，使用双等号，空字符串或只有空格的字符串是一种不好的做法。</p><p id="d794" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">要记住的下一件大事是避免对非原始类型使用双等号。<strong class="ll ja">唯一可以用的时候就是身份对比。</strong>我不能说这是100%安全的，因为它离死角足够近，不值得这么做。</p><p id="e039" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated"><a class="ae le" href="https://www.w3schools.com/js/js_es6.asp" rel="noopener ugc nofollow" target="_blank"> ECMAScript 6 </a>引入了新的实用工具<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank"> <em class="lk"> Object.is() </em> </a>。有了这个方法，我们终于可以在没有副作用风险的情况下进行身份比对了。最后，我们可以说，使用双等号只对基元类型安全，对非基元类型不安全。</p><p id="34f4" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">最后但并非最不重要的是避免对布尔值使用双等号(<em class="lk">真</em>和<em class="lk">假</em>)。允许隐式布尔强制要好得多(调用<em class="lk"> ToBoolean() </em>抽象操作)。如果您不能启用隐式强制，并且您被限制对布尔值使用双重等于(<em class="lk"> true </em>和<em class="lk"> false </em>)，那么<strong class="ll ja">使用三重等于</strong>。</p><p id="6623" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">结论:<strong class="ll ja">通过重构我们的代码库，可以避免大部分的死角。</strong></p></div></div>    
</body>
</html>