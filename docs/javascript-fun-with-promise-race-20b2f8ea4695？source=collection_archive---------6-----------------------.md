# JavaScript Fun with Promise.race()

> 原文：<https://javascript.plainenglish.io/javascript-fun-with-promise-race-20b2f8ea4695?source=collection_archive---------6----------------------->

## 愿最快的承诺获胜

![](img/cc958ac1f007cfdc942b2ef3b4fa0380.png)

Source: [Unsplash](https://unsplash.com/photos/1IW4HQuauSU)

**首先:**对于这篇文章，你应该明白承诺的目的是什么，以及它们是如何运作的。

众所周知，承诺需要时间来兑现。

理想情况下，在一定时间后，他们成功完成，然后他们被**解决**。在什么条件下它们应该被解析，我们可以使用 **resolve()** 函数来告诉每个承诺在什么条件下它应该被解析。

# 那么，什么是 Promise.race()函数呢？

顾名思义，其实就是赛跑。Promise.race()将我们在代码中定义的承诺数组作为参数，它本身就是一个承诺。

就 Promise.race()完成而言，它会给我们最快的承诺(无论是解决的还是拒绝的)的输出(resolve 函数的参数)。不多不少——只是最快承诺的输出。

我们不局限于一定数量的承诺，可以在数组中传递给 Promise.race()。

整个过程在浏览器和 Node.js 中都有效。

# 一个例子

下面的代码中定义了两个承诺。

它们所做的只是在超时完成后进行解析。上限承诺*定时器 1* 当然会被更快地解析，因为解析函数已经在 2 秒后被调用。如你所见，第二个承诺需要 4 秒钟。

作为 Promise.race()的参数，我们只需传递由两个函数组成的数组，每个函数都包含一个 Promise。

因为 Promise.race()本身返回一个承诺，所以一旦承诺完成，我们就可以继续使用*和*。

Promise.race() basic example

**两秒钟后，结果将是** : *，因为第一个承诺最快完成&，我们只需将在 resolve 函数中传递的数据变量作为**数据。***

# 这如何实际应用？

我个人可以想到 3 种不同的场景。

## 1.标杆管理

当然，每当我们处理承诺时，优化它们以提高性能是很有趣的。特别是对于网络或数据库请求，承诺通常是标准，这时我们可以使用 Promise.race()来测试两种不同的方法，并找出哪种方法更快。

## 2.同时执行

尽可能快地向用户提供数据总是符合我们的利益的。

例如，可以想象同时向几个服务器发送请求，只要其中一个服务器完成了工作，我们就会感到满意。那么 Promise.race()最适合同时执行承诺，并在第一个成功后立即完成。

## 3.设定时间限制

是的，还可以通过使用 reject()函数来限制承诺的执行时间，例如超时。

然而，我们可以对网络请求的承诺和时间限制的承诺做同样的事情，这将在 3 秒后解决。如果定时器承诺在 3 秒钟后比网络请求更早完成，则网络请求被中止。

这里有一个简单的例子: