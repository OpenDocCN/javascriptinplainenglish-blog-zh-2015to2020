<html>
<head>
<title>Guide to the Express Request Object — Queries and Cookies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速请求对象指南—查询和Cookies</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/guide-to-the-express-request-object-queries-and-cookies-c2224592ca7f?source=collection_archive---------4-----------------------#2020-02-25">https://javascript.plainenglish.io/guide-to-the-express-request-object-queries-and-cookies-c2224592ca7f?source=collection_archive---------4-----------------------#2020-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0757b4caf2cbebd4872fc8679c9c6115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mO3WBJwqJOVL_xlS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@laddhanikh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">nikhil laddha</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e9bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">request对象让我们在中间件和路由处理程序中获得来自客户端的请求信息。</p><p id="ce24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将详细研究Express的请求对象的属性，包括查询字符串、URL参数和签名的cookies。</p><h1 id="54ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">请求对象</h1><p id="3972" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们在上面的路由处理程序中的<code class="fe me mf mg mh b">req</code>参数是<code class="fe me mf mg mh b">req</code>对象。</p><p id="6000" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一些属性，我们可以使用这些属性来获取客户端发出的请求的相关数据。下面列出了比较重要的几个。</p><h2 id="dbac" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求.原始Url</h2><p id="d44f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">originalUrl</code>属性有原始的请求URL。</p><p id="9806" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="dab5" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="c6b7" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.originalUrl);<br/>})</span><span id="d06b" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="c8cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们得到带有查询字符串<code class="fe me mf mg mh b">/?foo=bar</code>的请求时，我们得到<code class="fe me mf mg mh b">/?foo=bar</code>。</p><h2 id="a59d" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求参数</h2><p id="4549" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">params</code>属性有来自URL的请求参数。</p><p id="6708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="e282" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express')<br/>const app = express()</span><span id="808c" class="mi lc iq mh b gy ng nd l ne nf">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="7ed5" class="mi lc iq mh b gy ng nd l ne nf">app.get('/:name/:age', (req, res) =&gt; {<br/>  res.json(req.params)<br/>})</span><span id="fe84" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="01ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们将<code class="fe me mf mg mh b">/john/1</code>作为URL的参数部分传入时，我们得到:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="9cbb" class="mi lc iq mh b gy nc nd l ne nf">{<br/>    "name": "john",<br/>    "age": "1"<br/>}</span></pre><p id="5d14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为上面路线的回应。</p><h2 id="17c4" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">req.path</h2><p id="fad7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">属性包含请求URL的路径部分。</p><p id="3f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="f14d" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="ca09" class="mi lc iq mh b gy ng nd l ne nf">app.get('/:name/:age', (req, res) =&gt; {<br/>  res.send(req.path);<br/>})</span><span id="0b4d" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="e422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并向<code class="fe me mf mg mh b">/foo/1</code>发出请求，然后我们在响应中得到同样的东西。</p><h2 id="3135" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求协议</h2><p id="533f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">protocol</code>属性获得协议字符串。</p><p id="a457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="b4bc" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="42c1" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.protocol);<br/>})</span><span id="f0df" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="f852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们通过HTTP发出请求时，我们返回<code class="fe me mf mg mh b">http</code>。</p><h2 id="4e23" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">req.query</h2><p id="826b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">query</code>属性从解析成对象的请求URL中获取查询字符串。</p><p id="1685" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="0e08" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express')<br/>const app = express()</span><span id="262c" class="mi lc iq mh b gy ng nd l ne nf">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="345e" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.json(req.query)<br/>})</span><span id="aa40" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="a2d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们将<code class="fe me mf mg mh b">?name=john&amp;age=1</code>附加到主机名的末尾时，我们得到:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="aa0d" class="mi lc iq mh b gy nc nd l ne nf">{<br/>    "name": "john",<br/>    "age": "1"<br/>}</span></pre><p id="d48e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从回应来看。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/bccd747d6d8daab68cd252ed72fafa21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*swGhEQB34mJuO35D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@annademy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anna Demianenko</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="5f68" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求路由</h2><p id="56c1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">route</code>属性得到当前匹配的路线。</p><p id="cb22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="5df1" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="d796" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  console.log(req.route);<br/>  res.json(req.route);<br/>})</span><span id="aecf" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="d707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从<code class="fe me mf mg mh b">console.log</code>中得到类似下面的东西:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="f099" class="mi lc iq mh b gy nc nd l ne nf">Route {<br/>  path: '/',<br/>  stack:<br/>   [ Layer {<br/>       handle: [Function],<br/>       name: '&lt;anonymous&gt;',<br/>       params: undefined,<br/>       path: undefined,<br/>       keys: [],<br/>       regexp: /^\/?$/i,<br/>       method: 'get' } ],<br/>  methods: { get: true } }</span></pre><h2 id="5bd4" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求安全</h2><p id="e49d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个布尔属性，指示请求是否通过HTTPS发出。</p><p id="a5c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="bbe0" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="39b5" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {  <br/>  res.json(req.secure);<br/>})</span><span id="3133" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="b6e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果请求是通过HTTP发出的，那么我们得到<code class="fe me mf mg mh b">false</code>。</p><h2 id="1162" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">req.signedCookies</h2><p id="cb38" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">signedCookies</code>对象有一个cookie，它的值是从散列值中解密出来的。</p><p id="d2e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="f945" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const cookieParser = require('cookie-parser');<br/>const app = express();<br/>app.use(cookieParser('secret'));</span><span id="30d3" class="mi lc iq mh b gy ng nd l ne nf">app.get('/cookie', (req, res, next) =&gt; {<br/>  res.cookie('name', 'foo', { signed: true })<br/>  res.send();<br/>})</span><span id="f23d" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.signedCookies.name);<br/>})</span><span id="a696" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="1807" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用了<code class="fe me mf mg mh b">/cookie</code>路径将cookie从我们的应用程序发送到客户端。然后，我们可以从客户端获取值，然后向<code class="fe me mf mg mh b">/</code>路由发出请求，请求的标题是<code class="fe me mf mg mh b">Cookie</code>，关键字是<code class="fe me mf mg mh b">name</code>，值是来自<code class="fe me mf mg mh b">/cookie</code>路由的签名值。</p><p id="adc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，它看起来像这样:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="f433" class="mi lc iq mh b gy nc nd l ne nf">name=s%3Afoo.dzukRpPHVT1u4g9h6l0nV6mk9KRNKEGuTpW1LkzWLbQ</span></pre><p id="9ea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在签名的cookie被解码后，我们从<code class="fe me mf mg mh b">/</code>路径返回<code class="fe me mf mg mh b">foo</code>。</p><h2 id="076f" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">req.stale</h2><p id="ddb0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">stale</code>是<code class="fe me mf mg mh b">fresh</code>的反义词。更多详情见<code class="fe me mf mg mh b"><a class="ae kc" href="https://expressjs.com/en/4x/api.html#req.fresh" rel="noopener ugc nofollow" target="_blank">req.fresh</a></code>。</p><h2 id="077a" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求子域名</h2><p id="acd0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在带有<code class="fe me mf mg mh b">subdomains</code>属性的请求的域名中获得一个子域数组。</p><p id="d4d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="55dd" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="d000" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.subdomains);<br/>})</span><span id="3086" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="9d58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们向<code class="fe me mf mg mh b">/</code>路由发出请求时，我们会得到类似这样的结果:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="d7df" class="mi lc iq mh b gy nc nd l ne nf">["beautifulanxiousflatassembler--five-nine"]</span></pre><h2 id="2134" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">req.xhr</h2><p id="4178" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">true</code>为<code class="fe me mf mg mh b">X-Requested-With</code>的布尔属性请求头字段为<code class="fe me mf mg mh b">XMLHttpRequest</code>。</p><p id="eca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="01c3" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="fe34" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.xhr);<br/>})</span><span id="a0ee" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="8578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们在<code class="fe me mf mg mh b">X-Requested-With</code>报头设置为<code class="fe me mf mg mh b">XMLHttpRequest</code>的情况下向<code class="fe me mf mg mh b">/</code>路由发出请求时，我们返回<code class="fe me mf mg mh b">true</code>。</p><h1 id="51ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3d8e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">请求对象中有许多属性可以获取许多东西。</p><p id="c1b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用Cookie解析器中间件获得签名的Cookie。查询字符串和URL参数可以通过<code class="fe me mf mg mh b">query</code>、<code class="fe me mf mg mh b">params</code>、<code class="fe me mf mg mh b">route</code>属性以各种形式访问。</p><p id="3b5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以用<code class="fe me mf mg mh b">subdomains</code>属性获取子域的一部分。</p></div></div>    
</body>
</html>