<html>
<head>
<title>Simplest Angular State Management with Observable Service Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有可观察服务模式的最简单角度状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-state-management-with-observable-service-pattern-27b18538f4c3?source=collection_archive---------3-----------------------#2020-12-13">https://javascript.plainenglish.io/angular-state-management-with-observable-service-pattern-27b18538f4c3?source=collection_archive---------3-----------------------#2020-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ad6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用可观测数据服务的简单而有效的解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5cfecd7c64ec269eb6515ce65d8fd005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fniE4N2T6M7wzl6l"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="57d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Angular状态管理是任何Angular App的核心，但没有放之四海而皆准的解决方案。虽然Ngrx是最流行的角度状态管理框架，但它过多的样板代码使它对许多中小型应用程序来说是多余的。</p><p id="125b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文讨论了一个简单而有效的角度状态管理模式，它使用了可观察的数据服务。</p><p id="2ee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想要实现的是通过使用类似于R <a class="ae kv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> edux </a>模式的概念获得以下主要好处。</p><ul class=""><li id="9110" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">单一来源的真相</strong></li><li id="6890" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">单向数据流</strong></li><li id="5f96" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">组件级不可变状态</strong></li></ul><p id="db5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个演示<a class="ae kv" href="https://github.com/sunnyy02/HeroesWithSimpleStateObservable" rel="noopener ugc nofollow" target="_blank"> Hero应用</a>可以作为如何用这种模式实现Angular应用的例子。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="8ec5" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">概观</h2><p id="6c49" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">下图说明了模式的数据流，它类似于Redux流。通过应用程序的数据流顺序如下:</p><ul class=""><li id="bfa4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当用户执行动作时，事件/动作被发送到商店服务</li><li id="5521" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果需要，存储服务调用API服务(副作用)</li><li id="14d6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">API调用返回后，存储服务更新状态</li><li id="85ea" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">新状态通过可观察的steam发布</li><li id="9948" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">订阅该状态的组件重新呈现UI</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/93d8869e8c0f85aac50687ccaaad5c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CY9e_m16m4ryjkQe1b3wyg.png"/></div></div></figure><h2 id="aaf7" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">商店服务</h2><p id="01b4" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在Redux的世界里，商店保存着全局的应用程序状态树，状态描述了应用程序在特定时间点的状况。</p><p id="56d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个示例应用程序中，我们使用<code class="fe nm nn no np b">HeroStore</code>作为一个可观察的商店服务，作为一个商店在整个应用程序中提供数据。并且它可以被注入到任何需要状态的组件中。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="7305" class="mn mo iq np b gy nu nv l nw nx">@Injectable()<br/>export class HeroStore extends Store&lt;HeroState&gt; </span></pre><p id="8487" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">HeroStore </code>服务从抽象的<code class="fe nm nn no np b">Store</code>类扩展而来。Store类的核心是Rxjs行为主体。它被用作私有的可观察实例来保存状态，并向订阅者发出任何更改。</p><p id="b0b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，暴露的是只读的observable <code class="fe nm nn no np b">state$</code>而不是BehaviorSubject，以加强从存储服务到组件的单向数据流。一个<code class="fe nm nn no np b">setState </code>方法被提供为受保护的，更新状态的唯一方式是来自<code class="fe nm nn no np b">HeroStore </code>服务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/0175c53564e10bbe33c8ebeee4250733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4745Un0DVt9cPQm1gyRcRw.png"/></div></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="e155" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">状态切片</h2><p id="155b" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">hero state类表示UI所需的状态数据的类型定义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/298b86542a63292317dffc3ec1df452b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0E3ft3Gb2TauXLX98NfkQ.png"/></div></div></figure><p id="8d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在演示应用程序中，每个单独的组件都需要一个状态片段，即仪表板组件需要<code class="fe nm nn no np b">heroes</code>数据来显示前5个英雄。我们用只读的可观察的存储服务公开状态数据片。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/d943c96d3f9a7131e3c4bb4e899c008a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DaAqImmqTmJLh3HwANqMcQ.png"/></div></div></figure><p id="6e90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过Rxjs映射操作符，它在组件中被公开为可观察的，并通过异步管道绑定到UI。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/1ef4656970f05395ea09fc9bf7d6b373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIlHcU8a7RZoRDkualAO9Q.png"/></div></div></figure><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="5d88" class="mn mo iq np b gy nu nv l nw nx">&lt;a *ngFor="let hero of heroes$ | async"&gt;&lt;h4&gt;{{hero.name}}&lt;/h4&gt;&lt;/a&gt;</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="fb09" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">行动方法</h2><p id="b6dd" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在<code class="fe nm nn no np b">HeroStore </code>服务中，CRUD操作方法被公开来更新状态。下面的<code class="fe nm nn no np b">add</code>方法就是一个例子。</p><p id="789e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">add </code>动作方法触发一个API服务调用来添加新的<code class="fe nm nn no np b">hero </code>对象并更新全局状态。请注意，spread操作符用于在更新状态之前创建状态的副本，以确保不变性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/257312b7d21fb2f67a4c641725cf55f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9BUd3PSHCW_IAbrs6HI8g.png"/></div></div></figure><p id="28ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新后的状态将从存储服务中发布，状态数据切片的所有订阅者都将得到通知，UI也将更新。订户不知道哪一方导致了状态改变，他们只是被通知了状态改变。这使得组件与应用程序的其他部分解耦。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="c237" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">副作用</h2><p id="cf79" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">当进行外部API调用并且状态因此而改变时，会产生副作用。在Ngrx中，Ngrx效果库作为一个中间件来监听动作，触发副作用，并将动作返回到reducer中。</p><p id="a103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个模式中，我想避免Ngrx效应的复杂性，所以动作方法触发API服务调用(副作用), Rxjs观察对象被链接起来处理这些副作用的结果。</p><p id="83a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API服务被分离到一个<code class="fe nm nn no np b">HeroApiService </code>类中，以隔离与副作用相关的代码，从而实现可维护性，API服务的唯一消费者是<code class="fe nm nn no np b">HeroStore </code>服务。换句话说，不允许组件直接调用API服务，每个请求都必须通过store服务发送。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/dc1cf534ef8a9bde66e2084a772a9301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_HL7e6ZCQrq7kscDp6opQ.png"/></div></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="596c" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">几个音符</h2><p id="7aa2" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在这种模式下，大多数组件变得简单而被动。首先，它从状态片段中获取输入，状态片段是来自商店服务的链接/映射的可观察对象，并通过异步管道绑定到HTML。然后，它通过调用商店服务动作方法来处理用户交互。</p><p id="65a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您的应用程序增长时，您可能会发现状态的复杂性不断增加。然后，可能是时候将您的商店服务按照全局或特性模块划分成不同的服务了，您也可以使用Rxjs操作符，如<code class="fe nm nn no np b">combinelatest </code>或<code class="fe nm nn no np b">mergeAll </code>来映射/分割UI要使用的状态。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="1f10" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">结论</h2><p id="d312" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这种可观察的存储服务是一种易于实现的模式，并且保留了那些复杂得多的状态管理框架的大部分优点。另一个好处是，商店服务有助于避免“事件汤”，当使用太多的个人角度服务，到处订阅observables时。</p><p id="66fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编程快乐！</p><p id="fa07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oe">如果您还不是Medium、</em> <a class="ae kv" href="https://sunnysun-5694.medium.com/membership" rel="noopener"> <strong class="ky ir"> <em class="oe">的付费会员，您可以通过访问此链接</em> </strong> </a> <em class="oe">进行注册。你可以无限制地阅读媒体上的所有报道。我会收你一部分会员费作为介绍费。</em></p></div></div>    
</body>
</html>