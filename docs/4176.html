<html>
<head>
<title>How Does Inheritance Work In React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的继承是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/inheritance-in-react-1e301ef3a618?source=collection_archive---------7-----------------------#2020-11-22">https://javascript.plainenglish.io/inheritance-in-react-1e301ef3a618?source=collection_archive---------7-----------------------#2020-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/130485653fd08bf05c27c56c314f8a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVPUvwMMRAxyK_k5bdALEg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@estherrj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Esther Jiao</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="fb72" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有继承，现代代码在很大程度上是站不住脚的，这“<a class="ae jd" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#:~:text=Inheritance%20allows%20programmers%20to%20create,via%20public%20classes%20and%20interfaces." rel="noopener ugc nofollow" target="_blank">允许程序员创建基于现有类</a>的类”。它是面向对象编程的基石。尽管React在许多方面利用了传统面向对象的实践，但JSX及其整体结构与传统的合成有所不同。例如，我们不会通过调用传统的构造函数来创建一个类的新实例:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="52a2" class="lk ll jg lg b gy lm ln l lo lp">new Component();</span></pre><p id="2655" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而是创建类的JSX表示，作为React组件:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3b4f" class="lk ll jg lg b gy lm ln l lo lp">&lt;Component /&gt;</span></pre></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="e67e" class="lx ll jg bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">问题是</h1><p id="cfb0" class="pw-post-body-paragraph kd ke jg kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">那些通过继承解决的问题仍然存在于React应用中，但由于我们编写React代码的方式不同，变得更加棘手。例如，我最近正在构建一个容器，它可以呈现几种不同图表中的任何一种。这些图表之间有许多共同的属性，但也有一些重要的差异。</p><p id="0727" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来像是继承的经典案例，对吧？我们创建了一个<code class="fe mz na nb lg b">Chart</code>类，其中的<code class="fe mz na nb lg b">ChartA</code>、<code class="fe mz na nb lg b">ChartB</code>和<code class="fe mz na nb lg b">ChartC</code>都可以继承。</p><p id="f4d7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">沿着这条路走下去之后，才知道<em class="nc">就是不行</em>。从我们调用函数、处理道具和渲染JSX的方式，所有这些都是我们代码中众所周知的难题。你会接近，但不完全是<em class="nc">那里</em>——至少，不会以任何方式在反应中感到自然。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/d72118d1ab2e525be72242714d82c6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47xgNhw8AMdPkfmXqHvWkw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@karlahrnndz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Karla Hernandez</a> on <a class="ae jd" href="https://unsplash.com/s/photos/problem?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cd8b" class="lx ll jg bd ly lz ne mb mc md nf mf mg mh ng mj mk ml nh mn mo mp ni mr ms mt bi translated">解决方案</h1><p id="88ee" class="pw-post-body-paragraph kd ke jg kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">React文档建议单独使用合成来代替继承。</p><blockquote class="nj"><p id="66ef" class="nk nl jg bd nm nn no np nq nr ns la dk translated">React有一个强大的组合模型，我们建议使用组合而不是继承来重用组件之间的代码。</p></blockquote><p id="0841" class="pw-post-body-paragraph kd ke jg kf b kg nt ki kj kk nu km kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">这些文档特别强调了“专门化”——当一个组件是通用组件的“特例”时。这感觉就像我们上面看到的图表问题。尽管共享的图表属性只会作为<code class="fe mz na nb lg b">ChartA</code>、<code class="fe mz na nb lg b">ChartB</code>或<code class="fe mz na nb lg b">ChartC</code>的一部分呈现，而不仅仅是<code class="fe mz na nb lg b">Chart</code>，这三个图表在某种程度上是<code class="fe mz na nb lg b">Chart</code>的“特例”。</p><h2 id="9542" class="lk ll jg bd ly ny nz dn mc oa ob dp mg ko oc od mk ks oe of mo kw og oh ms oi bi translated">不要做什么</h2><p id="d598" class="pw-post-body-paragraph kd ke jg kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我的第一反应是构建一个父组件，或者甚至是容器，将所有共享属性传递给专用图表。这很自然地感觉像是继承的表现——本质上是通过<code class="fe mz na nb lg b">props</code>继承类属性。然而，在这条道路上出现了几个问题。</p><p id="7afa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，事实是共享属性比唯一属性多得多，一些唯一属性嵌套在共享属性中。这使得凌乱的物体蔓延和大，笨拙的道具。</p><p id="0fa9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二，存在范围的问题——主要是，感觉它们应该在<code class="fe mz na nb lg b">Charts</code>中被一般性地定义，但是依赖于在子元素中定义的那些独特的属性，因此必须限定在最里面的子元素的范围内。</p><p id="1449" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三，有一层逻辑确实是完全通用的，但由于组成和结构，最终在<code class="fe mz na nb lg b">ChartA</code>、<code class="fe mz na nb lg b">ChartB</code>和<code class="fe mz na nb lg b">ChartC</code>中被重复。这违反了D.R.Y，一个明确的危险信号，表明我们在做错事。</p><h2 id="03ca" class="lk ll jg bd ly ny nz dn mc oa ob dp mg ko oc od mk ks oe of mo kw og oh ms oi bi translated">正确的东西</h2><p id="53f5" class="pw-post-body-paragraph kd ke jg kf b kg mu ki kj kk mv km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">那么，我们做什么呢？我们把上面的拿过来，然后翻转过来。React文档建议构建您的组件，以便“一个更‘特定’的组件呈现一个更‘一般’的组件，并用props对其进行配置”。</p><p id="80eb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这感觉是违反直觉的，就像通用是从“特殊”继承的一样。<code class="fe mz na nb lg b">ChartA</code>、<code class="fe mz na nb lg b">ChartB</code>和<code class="fe mz na nb lg b">ChartC</code>都呈现一个共享的<code class="fe mz na nb lg b">Chart</code>组件。但是(没有人感到惊讶)，React的团队对这种结构完全正确，这种组合可以满足任何继承和专门化的需要。</p><p id="de3a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继承的核心是共享属性和实现的概念——换句话说，一个类的属性在子类中被“重用”。在React中，我们还创建组件，这些组件的属性和实现可以在整个代码库中重用和共享。我们把这些可重用的组件放在哪里呢？在其他容器或组件的内部，这些容器或组件通常为重用组件提供关于其行为方式的上下文。例如，一个按钮从一个<code class="fe mz na nb lg b">Login</code>容器中接收它的<code class="fe mz na nb lg b">label</code>和<code class="fe mz na nb lg b">onClick</code>。</p><p id="f86d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的图表示例中，<code class="fe mz na nb lg b">ChartA</code>、<code class="fe mz na nb lg b">ChartB</code>和<code class="fe mz na nb lg b">ChartC</code>都共享<code class="fe mz na nb lg b">Chart</code>的属性，即它们“继承”(共享属性)的组件/类，方法是将<code class="fe mz na nb lg b">Chart</code>作为子组件，并将唯一的(子类)属性作为<code class="fe mz na nb lg b">props</code>传入。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="4cb8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在React <a class="ae jd" href="https://reactjs.org/docs/composition-vs-inheritance.html" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多关于组合与继承的内容。</p></div></div>    
</body>
</html>