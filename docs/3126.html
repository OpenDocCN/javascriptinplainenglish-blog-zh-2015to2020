<html>
<head>
<title>How to Test the Availability of Your API Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试API服务器的可用性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-test-the-availability-of-your-api-server-46e5e6a8a677?source=collection_archive---------10-----------------------#2020-08-31">https://javascript.plainenglish.io/how-to-test-the-availability-of-your-api-server-46e5e6a8a677?source=collection_archive---------10-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/00817d4618637bf32180ede3ea6d2993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Scpk-mrAJhT8WVX9j440cQ.png"/></div></div></figure><p id="55a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您是否已经开发或正在创建将在生产或云环境中使用的API服务器？在我的<a class="ae kw" href="https://www.youtube.com/playlist?list=PLISqeoHsXJYAIfu4-mgNY0tloWz2uut1t" rel="noopener ugc nofollow" target="_blank"> Node JS性能优化</a>系列的第4部分中，我将向您展示如何测试您的API服务器的可用性，以便您可以了解它在执行繁重任务时每秒可以处理多少请求。</p><p id="97c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个非常重要的措施，尤其是对于生产环境，因为您最不希望的事情就是由于API服务器达到峰值并且没有足够频繁地释放资源而导致传入请求排队。</p><p id="dd5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kx">注意:</em> </strong> <em class="kx">虽然我将在本文中引用</em><a class="ae kw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"><em class="kx">NodeJS</em></a><em class="kx">，但是提到的大部分理论和原则可以适用于任何平台和环境。</em></p><h1 id="6fe4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用哪种基准测试工具</h1><p id="4c76" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我将在测试中使用的工具叫做<a class="ae kw" href="https://github.com/mcollina/autocannon" rel="noopener ugc nofollow" target="_blank">auto canon</a>。完全用<a class="ae kw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>写的，和<a class="ae kw" href="https://httpd.apache.org/docs/2.4/programs/ab.html" rel="noopener ugc nofollow" target="_blank">阿帕奇基准</a>、<a class="ae kw" href="https://artillery.io" rel="noopener ugc nofollow" target="_blank">火炮</a>、<a class="ae kw" href="https://k6.io" rel="noopener ugc nofollow" target="_blank"> K6 </a>、<a class="ae kw" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank"> Wrk </a>等非常相似。这是一个好消息，因为您不必被迫使用AutoCannon来阅读本文。如果您的基准测试工具可以针对HTTP请求执行负载测试，并且可以确定每秒的平均请求数，那么您就可以开始了。</p><p id="30db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，如果您希望使用AutoCannon，可以像在全球范围内安装NPM模块一样简单:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5308" class="mk kz iq mg b gy ml mm l mn mo">npm i -g autocannon</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/32cc484311284730983fe50299d7a7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycDizxmQsd9xV0fXkfcm8g.png"/></div></div></figure><h1 id="52c0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何测试API服务器的可用性</h1><p id="a2ce" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">首先，如果您希望在本地环境中运行这些示例，可以参考在线的<a class="ae kw" href="https://github.com/bleedingcode/nodejs-performance-optimizations" rel="noopener ugc nofollow" target="_blank">源代码回购</a>。您所需要的只是安装NodeJS。</p><p id="1b4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的代码片段让您几乎达到了99%的目标，只是设置了package.json，将NODE_ENV设置为Production，将PORT设置为6000(如果您有困难，请参考提供的源代码报告和嵌入式视频中的示例代码)。将以下内容添加到一个<strong class="ka ir"> <em class="kx"> app.js </em> </strong>文件中。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6565" class="mk kz iq mg b gy ml mm l mn mo">’use strict’</span><span id="3c0a" class="mk kz iq mg b gy mq mm l mn mo">require(‘dotenv’).config()</span><span id="96f2" class="mk kz iq mg b gy mq mm l mn mo">const Express = require(‘express’)</span><span id="ac0e" class="mk kz iq mg b gy mq mm l mn mo">const App = Express()</span><span id="989a" class="mk kz iq mg b gy mq mm l mn mo">const HTTP = require(‘http’)</span><span id="e9ee" class="mk kz iq mg b gy mq mm l mn mo">const BCrypt = require(‘bcryptjs’)</span><span id="17f9" class="mk kz iq mg b gy mq mm l mn mo">// Router Setup</span><span id="1207" class="mk kz iq mg b gy mq mm l mn mo">App.get(‘/pulse’, (req, res) =&gt; {</span><span id="bf99" class="mk kz iq mg b gy mq mm l mn mo">   res.send(‘’)</span><span id="a94b" class="mk kz iq mg b gy mq mm l mn mo">})</span><span id="10bf" class="mk kz iq mg b gy mq mm l mn mo">App.get(‘/stress’, async (req, res) =&gt; {</span><span id="526a" class="mk kz iq mg b gy mq mm l mn mo">   const hash = await BCrypt.hash(‘this is a long password’, 8)</span><span id="da54" class="mk kz iq mg b gy mq mm l mn mo">   res.send(hash)</span><span id="7770" class="mk kz iq mg b gy mq mm l mn mo">})</span><span id="515a" class="mk kz iq mg b gy mq mm l mn mo">// Server Setup</span><span id="ca0e" class="mk kz iq mg b gy mq mm l mn mo">const port = process.env.PORT</span><span id="b2c8" class="mk kz iq mg b gy mq mm l mn mo">const server = HTTP.createServer(App)</span><span id="9fe9" class="mk kz iq mg b gy mq mm l mn mo">server.listen(port, () =&gt; {</span><span id="4dcb" class="mk kz iq mg b gy mq mm l mn mo">   console.log(‘NodeJS Performance Optimizations listening on: ‘,    <br/>   port)</span><span id="a727" class="mk kz iq mg b gy mq mm l mn mo">})</span></pre><p id="8acd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个非常简单的Express服务器，它公开了两条路由:</p><ul class=""><li id="f068" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">/脉冲</li><li id="9bde" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">/压力</li></ul><p id="8e9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kx"> /pulse </em> </strong>端点表示一个非常轻量级的API，它不包含业务逻辑，并返回一个空字符串作为响应。在处理此端点时，应该没有任何延迟的理由。</p><p id="da9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，<strong class="ka ir"> <em class="kx"> /stress </em> </strong>端点使用<a class="ae kw" href="https://github.com/dcodeIO/bcrypt.js" rel="noopener ugc nofollow" target="_blank"> BcryptJS </a>对密码进行加盐和哈希运算。这是一个相当繁重的过程，因为它完全是用JavaScript编写的，所以会严重阻塞事件循环。</p><p id="d867" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的第一个测试，我们将使用AutoCannon对<strong class="ka ir"> <em class="kx"> /pulse </em> </strong>端点运行负载测试，以查看API服务器在空闲运行时每秒可以处理多少请求。流程如下:</p><p id="ec33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.启动Express服务器</p><ul class=""><li id="55d2" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">node app</code></li></ul><p id="ff2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.运行自动扫描测试</p><ul class=""><li id="14ce" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">autocannon http://127.0.0.1:6000/pulse</code></li><li id="f810" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">这是一个简单的负载测试，运行10个并发连接10秒钟</li></ul><p id="21fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在测试运行之后，您应该会收到一个包含平均每秒请求数的报告。根据机器的速度，它应该在15 000到25 000个请求之间变化:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6428c3b08a88e706267f4dbaa6d1290c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/0*7Dc1hQ_ytd846Sc0"/></div></figure><p id="836a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了基线测量，让我们看看当API服务器执行繁重任务时会发生什么:</p><p id="1df1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.确保Express服务器正在运行</p><ul class=""><li id="0985" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">node app</code></li></ul><p id="05b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.打开2个终端窗口进行测试</p><p id="16e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.在窗口1中，对着<strong class="ka ir"><em class="kx">/应力</em> </strong>端点运行自动扫描，持续时间为<strong class="ka ir"> 30 </strong>秒</p><ul class=""><li id="27ae" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">autocannon -d 30 <a class="ae kw" href="http://127.0.0.1:6000/stress" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:6000/stress</a></code></li></ul><p id="6cf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.在窗口2中，当<strong class="ka ir"><em class="kx">/应力</em> </strong>测试运行时，对<strong class="ka ir"><em class="kx">/脉冲</em> </strong>端点运行自动扫描，与之前相同</p><ul class=""><li id="6c4e" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">autocannon <a class="ae kw" href="http://127.0.0.1:6000/pulse" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:6000/pulse</a></code></li><li id="28d4" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">确保<strong class="ka ir"><em class="kx">/脉冲</em> </strong>测试运行完成，同时<strong class="ka ir"><em class="kx">/应力</em> </strong>测试正在运行</li></ul><p id="c92a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个测试运行之后，您应该会看到<strong class="ka ir"> <em class="kx"> /pulse </em> </strong>测试的每秒请求数显著下降。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/061efa740e02a69dbc9d05f4cfcd88e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*o8Z9pwXunBYry5AvuU8gNg.png"/></div></figure><p id="75ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以想象，这是一个可怕的结果…一个需要尽快处理的结果。</p><h1 id="4935" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">这在现实世界中意味着什么</h1><p id="1a2e" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">虽然这个例子在现实世界中没有太多意义，但是它为您应该在您的环境中运行的测试类型提供了一个模板。您需要确定您的API服务器何时运行在峰值，然后对属于您的服务器的轻量级API进行负载测试。您需要确定它们是否可以在没有太多延迟的情况下得到处理，或者它们是否因为您的代码可能没有很好地管理事件循环而被阻塞。</p><h1 id="bdbe" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我如何解决这个问题？</h1><p id="fb03" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">好吧，我有好消息:正如开始提到的，我正忙于一个关于“<a class="ae kw" href="https://www.youtube.com/playlist?list=PLISqeoHsXJYAIfu4-mgNY0tloWz2uut1t" rel="noopener ugc nofollow" target="_blank"> Node JS性能优化</a>”的系列。已经使用了我已经发布的内容和即将发布的内容中的例子，我设法将每秒对<strong class="ka ir"><em class="kx">/脉冲</em> </strong>测试的请求从<strong class="ka ir"> 117 </strong>增加到超过<strong class="ka ir"> 4 000 </strong>。</p><p id="b530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你要做的是<a class="ae kw" href="https://youtube.com/bleedingcode?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅</a>我的<a class="ae kw" href="https://youtube.com/bleedingcode" rel="noopener ugc nofollow" target="_blank">流血代码</a> YouTube频道，因为我会先在那里发布所有内容，而且几乎每周都会发布。这个系列已经有6个视频，其中一个重要的是“<a class="ae kw" href="http://bleedingcode.com/managing-the-event-loop-phases/" rel="noopener ugc nofollow" target="_blank">管理事件循环阶段</a>”。</p><p id="2bad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章证明是有价值的。敬请期待更多精彩😎</p><p id="b0f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干杯</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="844b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">原载于2020年8月31日</em><a class="ae kw" href="http://bleedingcode.com/how-to-test-availability-of-your-api-server/" rel="noopener ugc nofollow" target="_blank"><em class="kx">http://bleedingcode.com</em></a>T22。</p></div></div>    
</body>
</html>