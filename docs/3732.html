<html>
<head>
<title>Best of Modern JavaScript — Child Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华—子类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-child-classes-316aa9e59358?source=collection_archive---------12-----------------------#2020-10-20">https://javascript.plainenglish.io/best-of-modern-javascript-child-classes-316aa9e59358?source=collection_archive---------12-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b4f0fcb992a20a953d9fd95d9bf2bc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bdOvAMs7WNRZlPsg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@caleb_woods?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Caleb Woods</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7bb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用JavaScript定义类。</p><h1 id="166c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">计算方法名称</h1><p id="c18a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以添加带有计算属性名的方法。</p><p id="403d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="222d" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  ['foo' + 'Bar']() {}<br/>}</span></pre><p id="1398" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将返回字符串或符号的表达式传递到方括号中，以创建具有给定标识符的方法。</p><p id="fb51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以通过书写来传递一个符号:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d13c" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  [Symbol.iterator]() {<br/>    //...<br/>  }<br/>}</span></pre><h1 id="af16" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生成器方法</h1><p id="126c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以向类中添加生成器方法。</p><p id="0e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8292" class="mn lc iq mj b gy mo mp l mq mr">class Iterable {<br/>  constructor(arr) {<br/>    this.arr = arr;<br/>  }</span><span id="ebb8" class="mn lc iq mj b gy ms mp l mq mr">  *[Symbol.iterator]() {<br/>    for (const a of this.arr) {<br/>      yield a;<br/>    }<br/>  }<br/>}</span></pre><p id="8ec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">constructor</code>创建一个<code class="fe mt mu mv mj b">Iterable</code>类，用<code class="fe mt mu mv mj b">Symbol.iterator</code>方法创建一个方法。</p><p id="8191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得我们的<code class="fe mt mu mv mj b">Iterable</code>实例是可迭代的。</p><p id="1ede" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该方法是由<code class="fe mt mu mv mj b">*</code>符号表示的生成器。</p><p id="b496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mt mu mv mj b">yield</code>来返回和暂停每个项目。</p><p id="b07b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下代码将它与for-of循环一起使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="db03" class="mn lc iq mj b gy mo mp l mq mr">class Iterable {<br/>  constructor(arr) {<br/>    this.arr = arr;<br/>  }</span><span id="6998" class="mn lc iq mj b gy ms mp l mq mr">*[Symbol.iterator]() {<br/>    for (const a of this.arr) {<br/>      yield a;<br/>    }<br/>  }<br/>}</span><span id="d2fe" class="mn lc iq mj b gy ms mp l mq mr">for (const x of new Iterable(['foo', 'bar', 'baz'])) {<br/>  console.log(x);<br/>}</span></pre><p id="9b96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们记录了传入数组的每个条目。</p><h1 id="94ed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">子类</h1><p id="0604" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以从基类创建子类。</p><p id="765b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关键字<code class="fe mt mu mv mj b">extends</code>让我们创建子类。</p><p id="9b38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="812f" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  toString() {<br/>    return `(${this.name})`;<br/>  }<br/>}</span><span id="4393" class="mn lc iq mj b gy ms mp l mq mr">class Employee extends Person {<br/>  constructor(name, title) {<br/>    super(name);<br/>    this.title = title;<br/>  }<br/>  toString() {<br/>    return `(${super.toString()}, ${this.title})`;<br/>  }<br/>}</span></pre><p id="7736" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用关键字<code class="fe mt mu mv mj b">extends</code>创建了<code class="fe mt mu mv mj b">Employee</code>类，从而创建了<code class="fe mt mu mv mj b">Person</code>的子类。</p><p id="e9ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">Employee</code>的<code class="fe mt mu mv mj b">constructor</code>中，我们调用<code class="fe mt mu mv mj b">super</code>从那里调用<code class="fe mt mu mv mj b">Person</code>构造函数。</p><p id="1bbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们访问子类中的<code class="fe mt mu mv mj b">this</code>之前，这是必需的。</p><p id="77c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">title</code>参数的值设置<code class="fe mt mu mv mj b">this.title</code>属性。</p><p id="de3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">toString</code>方法中，我们调用<code class="fe mt mu mv mj b">super.toString</code>来调用<code class="fe mt mu mv mj b">Person</code>实例的<code class="fe mt mu mv mj b">toString</code>。</p><p id="d586" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们创建一个<code class="fe mt mu mv mj b">Employee</code>的实例，我们可以检查创建它的类。</p><p id="681e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5ab8" class="mn lc iq mj b gy mo mp l mq mr">const emp = new Employee('jane', 'waitress');<br/>console.log(emp instanceof Person);<br/>console.log(emp instanceof Employee);</span></pre><p id="ac14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们都回来了，正如我们所料。</p><p id="fdc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">Person</code>是基类<code class="fe mt mu mv mj b">Employee</code>是子类。</p><h1 id="e27c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">子类的原型是超类</h1><p id="4040" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类语法只是创建构造函数的一种方便的方法，所以它坚持原型继承模型。</p><p id="16f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子类的原型是超类。</p><p id="628c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f0e5" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  toString() {<br/>    return `(${this.name})`;<br/>  }<br/>}</span><span id="f4a5" class="mn lc iq mj b gy ms mp l mq mr">class Employee extends Person {<br/>  constructor(name, title) {<br/>    super(name);<br/>    this.title = title;<br/>  }<br/>  toString() {<br/>    return `(${super.toString()}, ${this.title})`;<br/>  }<br/>}</span></pre><p id="da5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fae5" class="mn lc iq mj b gy mo mp l mq mr">console.log(Object.getPrototypeOf(Employee) === Person)</span></pre><p id="ea7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">日志<code class="fe mt mu mv mj b">true</code>。</p><p id="6fc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子类从基类继承静态属性。</p><p id="c0ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f66a" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  static baz() {<br/>    return 'baz';<br/>  }<br/>}</span><span id="9621" class="mn lc iq mj b gy ms mp l mq mr">class Bar extends Foo {}</span></pre><p id="1a19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5792" class="mn lc iq mj b gy mo mp l mq mr">Bar.baz()</span></pre><p id="2d27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以在子类中调用静态方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="183a" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  static baz() {<br/>    return 'baz';<br/>  }<br/>}</span><span id="c18f" class="mn lc iq mj b gy ms mp l mq mr">class Bar extends Foo {<br/>  static baz() {<br/>    return `child ${super.baz()}`;<br/>  }<br/>}</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/f09e657a7ca54ac97c3f32484be80046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QdMKuUBA3-c-Xe8j"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@robbie36?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Robert Collins</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="758d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9923" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以添加计算方法名、静态成员，并从子类中获取父类成员。</p><p id="9529" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>