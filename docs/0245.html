<html>
<head>
<title>Graphs: Breadth First Search vs. Depth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图表:广度优先搜索与深度优先搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/graphs-breadth-first-search-vs-depth-first-search-d9908c560642?source=collection_archive---------0-----------------------#2019-09-05">https://javascript.plainenglish.io/graphs-breadth-first-search-vs-depth-first-search-d9908c560642?source=collection_archive---------0-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4f33fa11ec2c30d050f545423141f75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwtXA4A_ntUSEGHKtLaMZA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@armand_khoury?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Armand Khoury</a> on <a class="ae jd" href="https://unsplash.com/s/photos/graph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplas</a></figcaption></figure><div class=""/><div class=""><h2 id="00d4" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">虽然数组和哈希完全能够处理我们的许多数据需求，但随着所需信息变得越来越复杂，它们开始出现问题。</h2></div><p id="a52f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数组对于查找数据非常有用，但是添加或删除数据的成本很高。散列很容易添加或删除，但搜索起来代价很高。两者都可以显示简单的关系，但是随着这些关系以及与之相关的数据变得更加复杂，阅读和遍历变得更加困难。</p><p id="6d61" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数组和散列可以用来创建数据结构，而不是Ruby提供给我们的类，比如链表、树和图。在这篇博文中，我们将关注图表。我们将介绍如何在Ruby中恰当地表示一个图，以及两种最常见的图搜索算法:广度优先搜索和深度优先搜索。</p><h1 id="75a8" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">图表示</h1><p id="04a6" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">简单来说，计算机科学中的一个图就是一组相连的项目的集合。我们称这些项目为<strong class="kx jh">节点</strong>或<strong class="kx jh">顶点</strong>，它们由<strong class="kx jh">边</strong>连接。例如，在脸书上，两个用户各自用一个顶点来表示，他们的友谊状态用一条边来表示。这种连接允许像“你可能认识的人”这样的功能，以及与其他用户查看共同的朋友。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/fccf4a21f195a76a020f13e752223a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*OUTBv5AokjAofnzrJtwQww.gif"/></div></figure><p id="dcff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在左边的图中，顶点是:<strong class="kx jh"> A、B、C、D、E和f。</strong></p><p id="df29" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">边是你看到的所有连接顶点的线:<strong class="kx jh"> A-B，A-C，A-D，B-C，B-E，D-E，D-f。</strong></p><p id="1276" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这样的可视化表示中很容易看到这一点，但是我们如何以编程方式表示这个图呢？顶点可以存储在一个数组中:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3612" class="my ls jg mu b gy mz na l nb nc">vertices = ['A', 'B', 'C', 'D', 'E']</span></pre><p id="2efc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前这是可行的，但是当我们开始遍历图形时，我们会看到我们实际上想要将数据与每个节点相关联，因此散列数组(其中每个散列代表一个节点)确实是更好的选择。</p><p id="8f57" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">边也可以存储在数组中，但这一次，我们将使用数组的数组:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="88f9" class="my ls jg mu b gy mz na l nb nc">edges = [<br/>    ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'E'],<br/>    ['D', 'E'], ['D', 'F']<br/>]</span></pre><p id="d11c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了！我们现在知道如何用程序来表示我们的图表。我们可以很容易地返回一个节点的所有子节点，找出哪些节点是这个图上的顶点，等等。但我们在这里能做的肯定有限。随着这个图的缩放，当节点不相邻时，像查找两个节点之间的最短路径，以及查找是否有路径这样的事情变得更加复杂。</p><p id="585e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">进入广度优先搜索和深度优先搜索，这是遍历图的两个最流行的算法。维基百科给出了计算机科学中图形遍历的如下定义:</p><blockquote class="nd ne nf"><p id="616a" class="kv kw ng kx b ky kz kh la lb lc kk ld nh lf lg lh ni lj lk ll nj ln lo lp lq ij bi translated">在计算机科学中，<strong class="kx jh">图遍历</strong>(也称为<strong class="kx jh">图</strong>搜索)是指访问(检查和/或更新)一个<strong class="kx jh">图</strong>中每个顶点的过程。这种遍历按照顶点被访问的顺序进行分类。</p></blockquote><p id="dc85" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每一个都代表了一种不同的方法来遍历或访问一个图的每个顶点。</p><h1 id="5226" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">横向优先搜索</h1><p id="bf39" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">BFS指的是一种遍历图的方法，即先访问一个节点的所有子节点，然后再访问该子节点的子节点。你可以用层次来思考。如果根节点是第1层，则访问第2层的所有节点，然后是第3层的所有节点，第4层的所有节点，依此类推。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a41e3964ad5414a012513c9c962da11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*KcqFYE5IFkQLg_SbyOSkDg.png"/></div></figure><p id="d60f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上图中，给定根节点1，我们将从标记为1的节点开始。节点1将被视为“已访问”，然后我们将访问节点1的每个子节点，即节点2和节点5。既然我们已经访问了节点1的所有子节点，节点1将被视为“已浏览”，节点2和5将被视为“已访问”。然后，我们将访问节点2的未访问的子节点，这里是节点3。现在浏览节点2，并访问节点3。</p><p id="702f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将返回节点5，并访问节点5的子节点，而不是转到节点3的子节点。同样，我们在继续之前访问每个“级别”，这里2和5是同一级别。因此，我们访问节点4，并将节点5标记为已浏览。</p><p id="d627" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们回到节点3去访问它的未被访问的子节点，但是它没有子节点，所以我们把它标记为explored并回到节点4。我们找到节点4的唯一子节点节点6，将其标记为已访问，并将节点4标记为已浏览。然后，我们看到节点6没有子节点，并且没有其他未访问的顶点需要浏览，因此我们将节点6标记为已浏览，我们的算法完成。</p><p id="d411" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一开始觉得很困惑，没关系。当顶点被标记为explored时，尝试重新创建图形，您将看到我们在这里移动的模式。</p><h1 id="66b4" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">深度优先搜索</h1><p id="c766" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">BFS是一层一层地走下去的，而DFS则是沿着一个孩子的路走下去，从根到尾，然后再回到另一个孩子的路上。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a41e3964ad5414a012513c9c962da11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*KcqFYE5IFkQLg_SbyOSkDg.png"/></div></figure><p id="995c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用与上面相同的图，给定根节点1，我们将再次从标记为1的节点开始，并访问节点1的每个子节点，节点2和节点5。我们不是访问节点2的未访问子节点，然后再访问节点5的未访问子节点，而是访问节点2的未访问子节点，并继续探索该路径，直到到达终点，然后返回节点5。</p><p id="0e40" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从节点2访问节点3，并将节点2标记为已浏览。从节点3开始，我们访问节点4并将节点3标记为已浏览，从节点4开始，我们访问节点6并将节点4标记为已浏览。我们现在看到我们从节点6无处可去，所以我们将它标记为已浏览，并返回到节点5。因为节点5的子节点已经被访问过，我们将节点5标记为已浏览，我们的算法完成。</p><h1 id="0b48" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">差别</h1><p id="7243" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">您可以看到，改变遍历方法会导致在算法的不同点浏览节点。这是一个简单的图表，因此差异很小，但下面是使用每种算法标记浏览的顶点的顺序:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f2cf" class="my ls jg mu b gy mz na l nb nc">BFS: 1, 2, 5, 3, 4, 6</span><span id="2a09" class="my ls jg mu b gy nl na l nb nc">DFS: 1, 2, 3, 4, 6, 5</span></pre><p id="6c0f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，节点5从第三个被探索的顶点到最后一个。随着图形变得越来越大、越来越复杂，这些差异就变得越来越大。下周，我们将使用Ruby实际编写BFS和DFS算法的代码。</p></div></div>    
</body>
</html>