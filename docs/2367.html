<html>
<head>
<title>What Concurrent Mode on React Can Do For You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上的并发模式能为您做些什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-the-concurrent-mode-on-react-can-do-for-you-c9ac7e46c436?source=collection_archive---------5-----------------------#2020-06-17">https://javascript.plainenglish.io/what-the-concurrent-mode-on-react-can-do-for-you-c9ac7e46c436?source=collection_archive---------5-----------------------#2020-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6553a53c866e8ee2ecfb5c7e1af9c468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlORROdUiyr1Bs0NhhBwZQ.png"/></div></div></figure><p id="b5ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">看来React又来了。他们新的并发模式范例将在今年发布。</strong></p><p id="31ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还记得2019年2月，我们都在忙着学钩子吗？是的，非常喜欢。终于有了一个很好的借口来摆脱类组件及其令人困惑的命名生命周期方法，简化代码并增强可读性，这让人感到耳目一新。这次的流行语是并发。因此，我收集了所有的官方文档和一些例子，并坐下来弄清楚这对基于React的项目意味着什么。</p><h1 id="97b2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="ed0d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">并发模式引入了一组工具，帮助我们重新思考获取数据和代码的方式。</p><p id="99b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它也将让产品团队有机会加入到精心安排获取数据的乐趣中。</p><h1 id="11dc" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么选择并发模式</h1><p id="ecdb" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我发现的最好的例子是过滤列表。想象一下，一长串条目要花很长时间才能呈现出来。现在假设我们有一个过滤列表的文本输入字段。每次我们改变输入，React都会重新渲染组件，触发列表的重绘。如果列表<em class="lw">足够昂贵</em>，输入域很快就会变得滞后和无响应，因为UI库一次只呈现一件事:输入域的重新呈现必须等待列表完成。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/da5043d4236c297f000717a35cec4562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/1*UxQfAB3HHdG30CZcrEVKFA.gif"/></div></figure><p id="2e90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们已经解决了几个问题:</p><ol class=""><li id="1fe7" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">我们可以限制输入的<strong class="jx io"> onChange </strong>处理程序，仅在一定数量的更改后重新呈现列表，这将为我们的文本输入释放执行时间，</li><li id="55c5" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">或者我们可以去抖，这意味着只有当用户完成输入时列表才会改变。</li></ol><p id="702c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两种解决方案看起来都有点不太好，我们所做的只是隐藏了一个延迟，这是由于在输入的意外行为背后有一个性能较差的浏览器。此外，在更快的应用程序和机器上，延迟不明显，当用户键入一个键时，输入不会触发重新呈现。</p><h1 id="b056" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是并发模式</h1><p id="b94a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">进入并发模式。这一新功能的目的是保持对用户交互的反应，避免滞后，这归结为增强最终用户的体验。</p><p id="650b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了并发，组件呈现过程就变成了<em class="lw">可中断</em> : React可以选择哪个更新最重要，中断其余的，然后一旦完成就回来完成它的工作；就像厨师会优先处理等待的订单一样。</p><h1 id="6f98" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">焦虑</h1><p id="5096" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">React还引入了悬念，它采用了<a class="ae mq" href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html" rel="noopener ugc nofollow" target="_blank"> React 16.6 </a>中提供的<strong class="jx io">悬念</strong>组件，并引入了一个新的变化:该组件可以告诉React何时准备好进行渲染。当它存在时，React将使它脱离挂起模式，并在页面上呈现它。</p><p id="14d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那又怎样？首先想到的是，我们必须重新思考如何编排数据获取。“加载状态”不再属于组件，而是属于呈现它的父组件。</p><p id="cd79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并发模式API还有一些技巧。官方文档非常清晰和完整，充满了有用的例子，但我将引用突出的例子。</p><h1 id="4b21" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">悬念界限</h1><p id="432d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">一个<strong class="jx io">悬念</strong>组件使用一个<strong class="jx io">回退</strong>道具来告诉React当其子组件被挂起时要呈现什么，这可以是文本或JSX:你可能想用一个微调器或其他视觉提示来替换被挂起的组件。我们如何在视图上组织<strong class="jx io">暂停</strong>组件将影响加载状态如何传递给用户，以及组件脱离暂停状态时出现的顺序。注意<strong class="jx io">悬念</strong>组件也可以嵌套。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/9dc3454edc07aaecb115da860a458317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3wYY1BDL8Mq8Tqpc8sJ3A.png"/></div></div></figure><p id="1586" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，一篇博客文章将被挂起，直到标题和正文准备好被呈现。一旦可见，<strong class="jx io">评论</strong>将暂停并显示其回退。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/20f77f343192c16c7728b7898cc7faf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*ffU4mszjRgI8nMaT0UxckQ.gif"/></div></figure><h1 id="71ba" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">获得正确的顺序</h1><p id="92c5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当组件在同一层级时，<strong class="jx io">暂停列表</strong>会告诉它们出现的顺序。例如，您可能希望博文正文出现在评论之前，因此我们将暂停的组件包装在一个<strong class="jx io">suspend elist</strong>中，这将确保各个部分按顺序出现。</p><p id="b52e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，我们将设置主体在标题到达之前到达。当然，这不是我们想要的呈现方式，所以我们可以将它们设置在一个<strong class="jx io">suspend elist</strong>中。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/c127da834850d2f6f8f7b3463b96e071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kW0GtKLULTepHC1dnJKUw.png"/></div></div></figure><p id="bbb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着数据的加载，组件将依次退出暂停状态。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/ef16e82c8782798820396d33ab389049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/1*DXIsw0gsZKgTEApTr_0Ugg.gif"/></div></figure><h2 id="933b" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">转换到挂起状态</h2><p id="b709" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">并发模式API的另一个优点是钩子<strong class="jx io"> useTransition </strong>，它允许我们转换到一个处于挂起状态的组件。假设你点击一个按钮来查看一个<em class="lw">昂贵的</em>组件。向按钮添加一个微调器和一个禁用的属性可能会有用几毫秒，而不会触发视图变化，然后转换到挂起的组件，从而在调用者和挂起的组件之间划分等待时间。如果组件提前脱离挂起状态，它可以在流中呈现，而不需要回退。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/27e01d3696330fd65f2fd84befa47998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*sJJNZ5T7oFZ7Xh3FlA6C5Q.gif"/></div></figure><p id="3654" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个非常有用的解决方案，可以避免视图中充满悬浮组件和加载指示器。事实上，React文档预测<strong class="jx io"> useTransition </strong>将会非常普遍；人们基本上可以在所有触发组件挂起的UI元素中使用它(参见<a class="ae mq" href="https://reactjs.org/docs/concurrent-mode-patterns.html#baking-transitions-into-the-design-system" rel="noopener ugc nofollow" target="_blank">这里的</a>)。</p><h1 id="1e3e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">渲染时获取数据</h1><p id="f74e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这可能是并发模式最有趣的附加功能。我们都习惯于以两种方式之一获取数据:</p><ol class=""><li id="d7f4" class="mc md in jx b jy jz kc kd kg me kk mf ko mg ks mh mi mj mk bi translated">在<strong class="jx io"> componentDidMount </strong>或<strong class="jx io"> useEffect </strong>中，呈现视图的加载状态，然后获取数据，或者</li><li id="e31c" class="mc md in jx b jy ml kc mm kg mn kk mo ko mp ks mh mi mj mk bi translated">在父组件中，这意味着一旦数据准备好就要呈现组件。</li></ol><p id="2b00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">悬念允许你在渲染时<strong class="jx io">获取数据。假设我们从你的API加载一篇博客文章，你有一个主体和一个评论组件。有了悬念，您可以在组件开始呈现时开始获取数据，暂停任何等待数据到达的内容。</strong></p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/9ad0bae222776ee730607e29ba78f74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeEGCVr2jG_0ZR-tvk3j_A.png"/></div></div></figure><p id="41d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您在示例中看到的，当第一次加载<strong class="jx io"> Post </strong>组件时，数据获取开始。随着正文和评论开始出现，他们各自的观点从悬念中走出来，并在帖子中呈现出来。</p><p id="3622" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这反过来又打开了新的可能性，例如急切加载(参见关于这一点的<a class="ae mq" href="https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early" rel="noopener ugc nofollow" target="_blank"> React文档</a>)，我们可以尝试<em class="lw">猜测</em>用户的下一个动作将是什么，并相应地开始获取。直接从<a class="ae mq" href="https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html#fetch-in-event-handlers" rel="noopener ugc nofollow" target="_blank"> React docs </a>中:我们可以假设，如果在路由器链接上发生了<strong class="jx io"> mousedown </strong>或<strong class="jx io"> mouseover </strong>事件，比如<strong class="jx io">&lt;Link to = "/posts/5 "/&gt;</strong>，用户很可能会点击它，因此这将是开始为id = 5 的帖子获取数据的好时机。</p><h2 id="04c8" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated"><strong class="ak">总之</strong></h2><p id="2a73" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这太令人兴奋了。如你所知，Hooks心中有开发者。并发模式，或者至少是我们目前所知道的，似乎是产品团队对数据加载编排进行更深入分析的好机会:转换、加载器的编排，以及哪些数据与准系统呈现相关。</p><p id="8658" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还必须重新思考组件如何使用数据，组件状态的哪些部分对呈现最重要，以及哪些部分可以等待react的人们称之为高优先级和低优先级状态。</p><p id="9a1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个想法是关于<a class="ae mq" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank">错误边界</a>:如果你还没有实现它们，你应该实现它们。悬念使用它们来提醒在渲染和数据获取阶段遇到的任何错误。</p><blockquote class="ni"><p id="4137" class="nj nk in bd nl nm nn no np nq nr ks dk translated">各位，API调用中不再有try {} catch {}块。</p></blockquote></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="aa86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">最初发表于</em><a class="ae mq" href="https://www.zartis.com/untethering-webapps-with-observables-rxjs/" rel="noopener ugc nofollow" target="_blank">T5【https://www.zartis.com】</a><em class="lw">。</em></p><p id="1808" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">作者</em>:</p><div class="nz oa gp gr ob oc"><a href="https://www.linkedin.com/in/antonioreher/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">Antonio Reher -技术主管- Zartis | LinkedIn</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">查看世界上最大的职业社区LinkedIn上的Antonio Reher的个人资料。安东尼奥有6份工作列在…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">www.linkedin.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq jt oc"/></div></div></a></div></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h2 id="0e62" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">简单英语的JavaScript</h2><p id="09e2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mq" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">订阅我们的YouTube频道</strong> </a> <strong class="jx io">获取更多类似内容！</strong></p></div></div>    
</body>
</html>