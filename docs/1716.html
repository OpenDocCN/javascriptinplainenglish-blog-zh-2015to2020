<html>
<head>
<title>Understanding Recursion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的递归</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-recursion-in-javascript-72a0cebb76e1?source=collection_archive---------8-----------------------#2020-04-16">https://javascript.plainenglish.io/understanding-recursion-in-javascript-72a0cebb76e1?source=collection_archive---------8-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f4b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过实例演示递归</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/60919c90f229657e4d5c8976ca7dd526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNmVMK1oEulT8IGYgFxQIA.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/easy-way-to-understand-recursion-in-javascript"><div class="gh gi kr"><img src="../Images/c19cb3069af1beba3c93258d9fcfe139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-PVzecNs3s4ZbJsdsgIsGA.png"/></div></a></figure><p id="9efa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你在上图中看到的是一个Mandelbrot集合。可以说是最著名的分形。分形是一组无限复杂的几何形状，它们有一个特殊的特征。在不同的放大倍数下，它们看起来是一样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/54009cd84dcc688601781fa39536f88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*IeIxtJCWxuSDF7Xv_0BMuA.gif"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Mandelbrot set on different magnification levels taken from <a class="ae lt" href="https://en.wikipedia.org/wiki/Fractal" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="d415" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">那么分形和递归有什么共同点呢？他们以自我相似的方式不断重复自己。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="f564" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">什么是句子中的递归？</h1><blockquote class="mt"><p id="db06" class="mu mv iq bd mw mx my mz na nb nc ln dk translated">递归发生在函数调用自身的时候。</p></blockquote><p id="c3d8" class="pw-post-body-paragraph ks kt iq ku b kv nd jr kx ky ne ju la lb nf ld le lf ng lh li lj nh ll lm ln ij bi translated">这就是全部了。你可能也听过史蒂芬·霍金的名言:</p><blockquote class="mt"><p id="6d0a" class="mu mv iq bd mw mx my mz na nb nc ln dk translated">要理解递归，首先必须理解递归。</p></blockquote><p id="d6a5" class="pw-post-body-paragraph ks kt iq ku b kv nd jr kx ky ne ju la lb nf ld le lf ng lh li lj nh ll lm ln ij bi translated">虽然这的确是一个关于递归的聪明玩笑，但是我们可以通过使用它来真正理解它。那么如何转化为实践呢？让我们看一些实际的例子。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="afd7" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">递归的例子</h1><p id="93f7" class="pw-post-body-paragraph ks kt iq ku b kv ni jr kx ky nj ju la lb nk ld le lf nl lh li lj nm ll lm ln ij bi translated">首先，我们如何知道什么时候使用循环，什么时候使用递归函数？虽然循环的序列有一个确定的结尾，但递归没有顺序结尾。简单地说，如果你不知道你需要循环的次数，你将需要使用递归。这就是为什么停止条件如此重要。否则，您将最终创建一个无限循环。</p><p id="2acd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">递归的一些用例是什么？想象一下级联菜单，你可以无限期地拥有子菜单。另一个常见的用例是生成文件树。我们还可以在这里生成层次结构、网络或图形。</p><p id="aaf5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了便于理解，让我们从最基本的场景开始，从一个给定的数字开始倒数。</p><h2 id="4621" class="nn mc iq bd md no np dn mh nq nr dp ml lb ns nt mn lf nu nv mp lj nw nx mr ny bi translated">倒数计秒</h2><p id="8e78" class="pw-post-body-paragraph ks kt iq ku b kv ni jr kx ky nj ju la lb nk ld le lf nl lh li lj nm ll lm ln ij bi translated">想象一下，我们必须将100的数字打印到控制台上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0c59cfc7a64acdab14a42c3348649cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*CV86neBktl0B4BxPIkjD7w.png"/></div></figure><p id="bc21" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以用一个简单的循环来做这件事，但是既然我们在讨论递归，我们就这样做。让我们检查以下功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="46a1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个函数一直调用自己，直到传递的数字达到0。您刚刚创建了您的第一个递归函数！如果我们没有if语句会发生什么？该函数将无限地调用自己，直到发生以下情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/d672c35551d6dffcd73a25bf1ec539f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smdrhPqR9VS8_yHHyz1lzw.png"/></div></div></figure><p id="0d7a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它达到了浏览器的最大堆栈大小，这阻止了它永远运行。否则，我们会很快耗尽内存。所以我们在定义递归函数的退出条件时必须非常仔细。现在让我们来看一个稍微复杂一点但实用的例子。</p><h2 id="281a" class="nn mc iq bd md no np dn mh nq nr dp ml lb ns nt mn lf nu nv mp lj nw nx mr ny bi translated">生成文件树对象</h2><p id="7e22" class="pw-post-body-paragraph ks kt iq ku b kv ni jr kx ky nj ju la lb nk ld le lf nl lh li lj nm ll lm ln ij bi translated">假设您正在构建一个应用程序，您希望从一个真实的目录结构中生成一个文件树对象。如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/9559b447ec2ce22695514859c866f156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8auXpPiSm4xxlfkisyc9GA.png"/></div></div></figure><p id="239e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">每个目录都应该是一个对象，包含所有的内容。如果我们命中一个文件，我们可以将它的大小存储为值。</p><p id="fbc6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先在根目录下创建一个名为<code class="fe oe of og oh b">recursion.js</code>的新文件。我们需要首先导入<code class="fe oe of og oh b">fs</code>模块。让我们从心里的目的开始，看看我们想要什么。我们希望有一个函数返回一个文件树对象。这就是我们将要写入JSON文件的内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7bf3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所以我们需要实现<code class="fe oe of og oh b">getTree</code>函数。它接受我们想要遍历的文件夹。先加一些检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="077d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先，我们需要确保我们正在处理的文件或文件夹是存在的。否则，继续下去就没有意义了。然后我们想要填充最后返回的变量<code class="fe oe of og oh b">fileTree</code>。我们可以从两条路线中的一条开始:</p><ul class=""><li id="7a6e" class="oi oj iq ku b kv kw ky kz lb ok lf ol lj om ln on oo op oq bi translated">我们正在处理一个目录</li><li id="8e66" class="oi oj iq ku b kv or ky os lb ot lf ou lj ov ln on oo op oq bi translated">我们正在处理一份文件</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cae4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们正在处理一个文件，我们可以将大小分配给一个新的节点，以传递的参数命名。否则，我们在一个目录中。这意味着我们需要递归地调用这个函数，因为我们无法知道有多少个子文件夹。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d643" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这给我们留下了上面的实现。对于目录中的每个文件，我们希望检查它是否是一个子文件夹。然后我们可以用新的路径调用函数。当我们点击第8行时，我们跳转到一个新的文件夹并执行相同的步骤。如果该文件夹有另一个子文件夹，我们也这样做。诸如此类。由于函数最后返回一个<code class="fe oe of og oh b">fileTree</code>对象，我们可以将其值赋回<code class="fe oe of og oh b">fileTree[file]</code>。</p><p id="cce9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在最后，我们用完了子文件夹，这是我们的退出条件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/6c1f6ceb6e19822b6660c52e2d215b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3VNVP5ZuUQQHKybheBQbnA.gif"/></div></div></figure><p id="0388" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">继续用<code class="fe oe of og oh b">node recursion.js</code>运行这个文件。应该在您的根文件夹中生成一个<code class="fe oe of og oh b">tree.json</code>文件，包含文件夹结构的对象表示。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="f1ed" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">摘要</h1><p id="6627" class="pw-post-body-paragraph ks kt iq ku b kv ni jr kx ky nj ju la lb nk ld le lf nl lh li lj nm ll lm ln ij bi translated">也就是说，您现在应该已经掌握了递归的艺术。感谢您花时间阅读这篇文章。我想用一个受欢迎的漫画来结束我的演讲，作者是<a class="ae lt" href="https://www.safelyendangered.com/" rel="noopener ugc nofollow" target="_blank">安全濒危的</a>，它很好地说明了当递归中出现问题时会发生什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/de2bbdcb0905a39f5e11794f35a6e6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iY9X36DfMzxRzq3hspKkug.gif"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi ox"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="http://webtips.dev/"><div class="gh gi kr"><img src="../Images/b0d8e0a0c2689a59aa62a677429b83b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*_QOx8lB1bc1rVmMjWQ3Yfw.png"/></div></a></figure><h2 id="663f" class="nn mc iq bd md no np dn mh nq nr dp ml lb ns nt mn lf nu nv mp lj nw nx mr ny bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="cf1d" class="pw-post-body-paragraph ks kt iq ku b kv ni jr kx ky nj ju la lb nk ld le lf nl lh li lj nm ll lm ln ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:<a class="ae lt" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ku ir"/></a><a class="ae lt" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ku ir">UX</strong></a><a class="ae lt" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ku ir">Python</strong></a><strong class="ku ir"/>——谢谢，继续学习！</p><p id="e76f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae lt" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">submissions @ plain English . io</strong></a><strong class="ku ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>