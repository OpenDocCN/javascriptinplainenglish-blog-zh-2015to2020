<html>
<head>
<title>Object-Oriented JavaScript — Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——原型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-prototypes-de97f43a3594?source=collection_archive---------16-----------------------#2020-11-15">https://javascript.plainenglish.io/object-oriented-javascript-prototypes-de97f43a3594?source=collection_archive---------16-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8a1f0e87c8a0714351ff5d63e15ea46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ur1M-wE7znOXdLDY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="36dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究对象原型。</p><h1 id="b142" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型</h1><p id="9146" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每个物体都有原型。</p><p id="98bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象继承自称为原型的对象。</p><h1 id="4a21" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型属性</h1><p id="385f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">原型位于构造函数的<code class="fe me mf mg mh b">prototpe</code>属性中。</p><p id="572b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数具有<code class="fe me mf mg mh b">prototype</code>属性，该属性具有通过构造函数实例返回的方法。</p><p id="76a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有一个函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a69c" class="mq lc iq mh b gy mr ms l mt mu">function foo(a, b) {<br/>  return a + b;<br/>}</span></pre><p id="f70c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过书写得到它的原型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="730b" class="mq lc iq mh b gy mr ms l mt mu">console.log(foo.prototype)</span></pre><p id="c15d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有<code class="fe me mf mg mh b">constructor</code>属性，这是函数本身。</p><p id="c70e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要我们不另外指定，这个属性总是可用的。</p><h1 id="f565" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加原型方法和属性</h1><p id="9b57" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以向原型添加属性和方法，然后它们将被构造函数的所有实例共享。</p><p id="8a2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1f42" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>  this.whoAreYou = function() {<br/>    return `I am ${this.name}`;<br/>  };<br/>}</span></pre><p id="285b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有了<code class="fe me mf mg mh b">name</code>和<code class="fe me mf mg mh b">whoAreYou</code>实例属性。</p><p id="1255" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为每个实例创建不同的属性副本。</p><p id="288a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以在不同的实例之间共享<code class="fe me mf mg mh b">whoAreYou</code>，因为它是相同的方法。</p><p id="32a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过将它放在<code class="fe me mf mg mh b">prototype</code>属性中来实现:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="acf4" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="276a" class="mq lc iq mh b gy mv ms l mt mu">Person.prototype.whoAreYou = function() {<br/>  return `I am ${this.name}`;<br/>};</span></pre><p id="ac42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">this.name</code>在不同的实例之间应该是唯一的，所以应该在构造函数中。</p><p id="8d45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe me mf mg mh b">whoAreYou</code>是可以共享的，所以我们把它添加为<code class="fe me mf mg mh b">prototype</code>的一个属性。</p><h1 id="e812" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用原型的方法和属性</h1><p id="408e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过实例化构造函数的实例来使用原型的方法和属性。</p><p id="77ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f45e" class="mq lc iq mh b gy mr ms l mt mu">const jane = new Person('jane');</span></pre><p id="86a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来调用<code class="fe me mf mg mh b">whoAreYou</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8881" class="mq lc iq mh b gy mr ms l mt mu">console.log(jane.whoAreYou())</span></pre><p id="1eea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3c42" class="mq lc iq mh b gy mr ms l mt mu">'I am jane'</span></pre><h1 id="bee3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自有属性与原型属性</h1><p id="03be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">自有属性是在对象本身中定义的属性，而不是继承的属性。</p><p id="f9e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原型属性是从另一个对象继承的属性。</p><p id="f31d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">Person</code>构造函数中，我们有<code class="fe me mf mg mh b">prototype.whoAreYou</code>方法，这意味着它继承自<code class="fe me mf mg mh b">Person</code>构造函数的原型。</p><p id="de68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们获取一个属性或调用一个方法时，JavaScript引擎会查看原型链中对象的所有属性来获取属性。</p><p id="9ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能仅仅通过查看调用来区分。</p><p id="73c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">jane.name</code>看起来像<code class="fe me mf mg mh b">jane.whoAreYou()</code>，但是第一个是自己的属性，第二个是原型属性。</p><p id="9b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">constructor</code>属性进行检查。</p><p id="51e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="302f" class="mq lc iq mh b gy mr ms l mt mu">console.log(jane.constructor.prototype);</span></pre><p id="abc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在记录的对象中看到了<code class="fe me mf mg mh b">whoAreYou</code>方法。</p><h1 id="9de7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用自己的属性覆盖原型的属性</h1><p id="0027" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用自己的属性覆盖原型的属性。</p><p id="8e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e53" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="6531" class="mq lc iq mh b gy mv ms l mt mu">Person.prototype.name = 'no name';</span></pre><p id="6147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果我们创建一个<code class="fe me mf mg mh b">Person</code>实例:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fff5" class="mq lc iq mh b gy mr ms l mt mu">const jane = new Person('jane');</span></pre><p id="1af7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到的<code class="fe me mf mg mh b">jane</code>是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="05b5" class="mq lc iq mh b gy mr ms l mt mu">{name: "jane"}</span></pre><p id="eda2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">hasOwnProperty</code>方法确定一个属性是否是自己的属性。</p><p id="cf14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3f86" class="mq lc iq mh b gy mr ms l mt mu">console.log(jane.hasOwnProperty('name'));</span></pre><p id="bbb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe me mf mg mh b">true</code>。</p><p id="25ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">delete</code>操作符删除一个属性。</p><p id="afa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="07be" class="mq lc iq mh b gy mr ms l mt mu">delete jane.name</span></pre><p id="4934" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">移除它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ac768c00a71c6c4db0578d3de665c9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yHOwzDUqfAJsXVOM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ayoungh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anthony Young</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a575" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3eda" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象的原型是对象继承的对象。</p><p id="bed2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以覆盖它的属性。</p><p id="890e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>