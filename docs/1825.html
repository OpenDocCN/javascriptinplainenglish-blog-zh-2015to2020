<html>
<head>
<title>Basic JavaScript Interview Exercises — Numbers and Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本JavaScript面试练习—数字和元素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basic-javascript-interview-exercises-numbers-and-elements-4cba6ed1d935?source=collection_archive---------11-----------------------#2020-04-26">https://javascript.plainenglish.io/basic-javascript-interview-exercises-numbers-and-elements-4cba6ed1d935?source=collection_archive---------11-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f4355a956cdc01bbc483f49a64eba735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7uVkdZjfXpXsC8st"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nhillier?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Hillier</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="522d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="5420" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看一些每个人都应该知道的快速热身问题。</p><h1 id="bdc1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">写一个计算n的斐波那契数的函数。</strong></h1><p id="565f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过JavaScript的循环和析构语法来实现。</p><p id="3668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如下创建<code class="fe me mf mg mh b">fib</code>函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5611" class="mq lc iq mh b gy mr ms l mt mu">const fib = (n) =&gt; {<br/>  let i = 1,<br/>    a = 1,<br/>    b = 1;<br/>  while (i &lt; n) {<br/>    [a, b] = [b, a + b];<br/>    i++;<br/>  }<br/>  return a;<br/>}</span></pre><p id="cdd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe me mf mg mh b">b</code>设置为<code class="fe me mf mg mh b">a</code>，将<code class="fe me mf mg mh b">b</code>设置为<code class="fe me mf mg mh b">a + b</code>，以便在我们增加<code class="fe me mf mg mh b">i</code>时用新的斐波那契值更新数字。</p><p id="7cfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们完成循环时，我们返回<code class="fe me mf mg mh b">a</code>。</p><h1 id="6295" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">写一个函数，接受一个字符串并返回一个字符串字符频率的映射。</strong></h1><p id="a543" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用一个JavaScript <code class="fe me mf mg mh b">Map</code>来做这件事。</p><p id="7431" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过将字符串拆分成一个字符数组来计算字符串中字符的频率，然后按如下方式计算字符的频率:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="07e2" class="mq lc iq mh b gy mr ms l mt mu">const count = str =&gt; {<br/>  const chars = str.split('');<br/>  const frequencies = new Map();<br/>  for (let c of chars) {<br/>    const freq = frequencies.get(c) || 0;<br/>    frequencies.set(c, freq + 1);<br/>  }<br/>  return frequencies;<br/>}</span></pre><p id="cbf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在代码中，我们使用了<code class="fe me mf mg mh b">Map</code>的<code class="fe me mf mg mh b">get</code>方法来获取频率，我们将它加1，然后设置它。</p><p id="51fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们完成了循环，我们就返回<code class="fe me mf mg mh b">Map</code>。</p><h1 id="5df8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">写一个函数，接受一个数字并检查它是否是一个质数。</h1><p id="5663" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过检查一个数是2还是奇数来判断它是否是质数。如果是奇数，那么我们尝试将数字除以给定数字除以2的底数。</p><p id="2d28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下函数来检查质数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="31a2" class="mq lc iq mh b gy mr ms l mt mu">const isPrime = (num) =&gt; {<br/>  if (num % 2 === 0 &amp;&amp; num !== 2) {<br/>    return false;<br/>  }<br/>  for (let i = 3; i &lt;= Math.ceil(num / 2); i++) {    <br/>    if (num % i === 0) {<br/>      return false;<br/>    }<br/>  }<br/>  return true<br/>}</span></pre><p id="e2af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查它是否是偶数，而不是2。如果是，我们返回<code class="fe me mf mg mh b">false</code>。</p><p id="c30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们运行循环来检查一个数是否能被3整除，直到<code class="fe me mf mg mh b">num</code>除以2的上限。</p><p id="23f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它能被其中任何一个整除，那么我们返回<code class="fe me mf mg mh b">false</code>。</p><p id="f7c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们返回<code class="fe me mf mg mh b">true</code>。</p><h1 id="6c89" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">编写一个函数，接受一个DOM元素和一个字符串，并打印包含该字符串的类名的任何直接子元素。</strong></h1><p id="ef40" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用element对象的<code class="fe me mf mg mh b">getElementsByClassName</code>方法来获取具有给定class属性的子元素。</p><p id="8ad3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6a63" class="mq lc iq mh b gy mr ms l mt mu">const getChildrenWithClass = (el, className) =&gt; {<br/> const children = el.getElementsByClassName(className);<br/>  for (let c of children) {<br/>   console.log(c);<br/>  }<br/>}</span></pre><p id="f627" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码调用<code class="fe me mf mg mh b">el</code>元素对象上的<code class="fe me mf mg mh b">getElementsByClassName</code>并打印出具有给定类名的子元素。</p><p id="8978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">querySelectorAll</code>方法来做同样的事情。</p><p id="edd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e63f" class="mq lc iq mh b gy mr ms l mt mu">const getChildrenWithClass = (el, className) =&gt; {<br/>  const children = el.querySelectorAll(`.${className}`);<br/>  for (let c of children) {<br/>    console.log(c);<br/>  }<br/>}</span></pre><p id="25fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别是我们用模板字符串<code class="fe me mf mg mh b">`.${className}`</code>调用了<code class="fe me mf mg mh b">querySelectAll</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8aac432f6bc672aa4ae72658a4cec17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NOcO_OH3K53Wtd8-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sinjin_thomas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sinjin Thomas</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d6bc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">编写一个函数，接受一个DOM元素和一个字符串，如果它的任何父节点包含带有该字符串的类，则打印该函数。当没有父元素时，它应该停止。</strong></h1><p id="9d1e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以递归地使用<code class="fe me mf mg mh b">parentNode</code>属性，直到到达根元素或者找到我们想要的带有<code class="fe me mf mg mh b">className</code>的元素。</p><p id="b1df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们创建一个<code class="fe me mf mg mh b">getParentWithClassName</code>如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cab5" class="mq lc iq mh b gy mr ms l mt mu">const getParentWithClassName = (el, className) =&gt; {<br/>  let currentEl = el.parentNode;<br/>  while (currentEl) {<br/>    if (currentEl.className === className) {<br/>      return currentEl;<br/>    }<br/>    currentEl = currentEl.parentNode;<br/>  }<br/>  return undefined;<br/>}</span></pre><p id="c563" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe me mf mg mh b">currentEl</code>设置为<code class="fe me mf mg mh b">el</code>的<code class="fe me mf mg mh b">parentNode</code>。</p><p id="bc79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用一个<code class="fe me mf mg mh b">while</code>循环来搜索带有给定<code class="fe me mf mg mh b">className</code>的<code class="fe me mf mg mh b">parentNode</code>，直到找到一个带有给定名称的。</p><p id="d84c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们找到一个给定的<code class="fe me mf mg mh b">className</code>，我们返回这个元素。</p><p id="2ad3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们通过将<code class="fe me mf mg mh b">currrentel</code>设置为<code class="fe me mf mg mh b">currentEl.parentNode</code>来继续。</p><p id="552f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们循环到根节点，仍然没有找到具有给定<code class="fe me mf mg mh b">className</code>的元素，我们返回<code class="fe me mf mg mh b">undefined</code>。</p><h1 id="66b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ed55" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">parentNode</code>属性来查找子节点的父节点。</p><p id="90fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得带有给定CSS选择器的子节点，我们可以调用任何DOM导航方法来查找带有给定选择器的元素。</p><p id="5a51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一个字典，我们可以使用<code class="fe me mf mg mh b">Map</code>构造函数。</p><p id="d382" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像处理斐波那契数列一样，使用析构语法轻松地重新分配多个事物。</p><h2 id="9894" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="5e17" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="c79b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>