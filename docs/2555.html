<html>
<head>
<title>Mastering dates in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中掌握日期</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mastering-dates-in-javascript-93974ebd06f6?source=collection_archive---------2-----------------------#2020-07-05">https://javascript.plainenglish.io/mastering-dates-in-javascript-93974ebd06f6?source=collection_archive---------2-----------------------#2020-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4022" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何不因日期对象的不足而沮丧</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/527312b4b6ae5d0c7b3b9403de34f3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcqLNTjx-y_euyfDdyoQ1w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jessbaileydesigns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jess Bailey</a> on <a class="ae kv" href="/s/photos/day-and-time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="be29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript语言最不令人满意的方面之一是日期对象的管理，尤其是考虑到没有经验的程序员不太习惯处理日期。</p><p id="1035" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为什么这么说？在我看来，最根本的缺失是有效的方法:</p><ol class=""><li id="27df" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">格式化日期</li><li id="2462" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">将表示日期的字符串转换为date对象</li><li id="516b" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">执行<em class="ls">日期运算，</em>例如计算两个日期之间的距离或添加小时、天、月等。，到给定的日期</li></ol><p id="cf3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的几节中，我将展示如何用不必要的复杂解决方案来弥补JavaScript中的这些缺点，以及相反，一组奇妙的库如何让您直接获得相同的结果。</p><h1 id="9300" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">JavaScript中的日期是什么</h1><p id="6b3c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">JavaScript Date是一个内置对象，内部包含从1970年1月1日开始的毫秒数，而外部则显示为格式优美的字符串，具体取决于环境。例如，语句:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="00e6" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">let d = new Date;</strong></span></pre><p id="8cfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个包含当前日期和时间的Date对象。当我写这篇文章时，2020年6月21日下午2点27分，相应的<em class="ls">日期</em>包含一个类似1592828905046的整数。我们可以用<code class="fe no np nq nf b"><em class="ls">.valueOf</em></code>显示这个内部值:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ab95" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">new Date().valueOf()</strong> is equal to <strong class="nf ir">1592828905046</strong></span></pre><p id="1e34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相同的值(在相同的瞬间)可以通过以下方式获得:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="9c30" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">Date.now()</strong></span></pre><p id="1e0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们用<em class="ls"> console.log() </em>或<em class="ls"> document.write() </em>检查一个日期对象，我们会得到一个人类可读的字符串:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="6173" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">Mon Jun 22 2020 14:26:59 GMT+0200 (Central Europe daylight saving time)</strong>  [Chrome, Firefox]</span><span id="a7fa" class="nj mi iq nf b gy nr nl l nm nn">or</span><span id="7b9a" class="nj mi iq nf b gy nr nl l nm nn"><strong class="nf ir">Mon Jun 22 2020 14:26:59 GMT+0200 (CEST)</strong>   [Safari]</span></pre><h1 id="603d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">用date对象方法设置日期格式</h1><p id="5b27" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">过去30年里发明的大多数编程语言都提供了适当的功能来按照你需要的方式<strong class="ky ir"> <em class="ls">格式化</em> </strong>一个日期，例如在网页上显示。<strong class="ky ir"> JavaScript没有</strong>。</p><p id="3e3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设我们有一个<em class="ls">日期</em>对象<strong class="ky ir"> <em class="ls">日期</em> </strong>，我们需要以如下方式将它显示为文本:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="d281" class="nj mi iq nf b gy nk nl l nm nn">1) <strong class="nf ir">June 22nd, 2020</strong></span><span id="a61f" class="nj mi iq nf b gy nr nl l nm nn">2) <strong class="nf ir">22/06/2020</strong></span><span id="77a1" class="nj mi iq nf b gy nr nl l nm nn">3) <strong class="nf ir">22.06.20 13.00</strong></span><span id="6286" class="nj mi iq nf b gy nr nl l nm nn">4) <strong class="nf ir">Tue,</strong> <strong class="nf ir">Jun 22, 1.00 pm</strong></span></pre><p id="813f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅使用ES5 JavaScript(既不使用任何库，也不使用<strong class="ky ir"> <em class="ls"> Intl </em> </strong>对象，参见下一节)，情况很糟糕:</p><ol class=""><li id="e39c" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><strong class="ky ir"><em class="ls">“2020年6月22日”——</em></strong>不可行:没有办法自己从JavaScript中获取完整的月份名称(没有<strong class="ky ir"> Intl </strong>)。</li><li id="ce27" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir">“22/06/2020”——</strong>我能找到的最短的解决方案是:</li></ol><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="d6c9" class="nj mi iq nf b gy nk nl l nm nn">let d = mydate.toISOString(); // returns 2020–06–20T13:00:00.000Z<br/>d = d.substr(0,10).split('-').reverse().join('/');</span></pre><p id="9a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir">“22 . 06 . 20 13.00”——</strong>一个(恐怖的)解决方案是:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="6e33" class="nj mi iq nf b gy nk nl l nm nn">let d = mydate.toISOString();  <br/>d = d.substr(8,2)+’.’+d.substr(5,2)+’.’+d.substr(2,2)+' '+d.substr(11,5).replace(':','.') ;</span></pre><p id="2182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.<strong class="ky ir"> " <em class="ls">，</em></strong><em class="ls"/><strong class="ky ir"><em class="ls">6月22日下午1点"</em></strong>——太复杂而不值得引用:我们可以从我们得到的东西上切下各种碎片。<em class="ls"> toString() </em>或<em class="ls"> toLocaleString() </em>或<em class="ls">。toUTCString() </em>并将它们重新组合在一起。</p><h1 id="c73e" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">用整数格式化日期。DateTimeFormat对象</h1><p id="d759" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">意识到这些缺点并寻找日期、数字等的区域表示问题的更广泛的答案。，ECMA International在2015年推出了一个特定的国际化API，其中包括这些问题的解决方案，以及许多其他功能。</p><p id="e6da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">不幸的是</strong>，找到的解决方案远不是一个简单的解决方案。首先，ECMA International没有选择用强大的新方法来扩充Date对象(这是一个愚蠢的想法吗？)，但他们发明了一种新的<strong class="ky ir"> <em class="ls"> Intl。</em>datetime format</strong>对象，从而生成一个<strong class="ky ir"> <em class="ls">。格式化</em>可用于格式化日期的</strong>方法。其结果容易受到批评。</p><p id="1bd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我的意思。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="43a9" class="nj mi iq nf b gy nk nl l nm nn">1) <strong class="nf ir">June 22nd, 2020</strong></span></pre><p id="0e2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们仍然不能直接得到我们想要的，因为。DateTimeFormat 没有提供生成序数后缀的选项。我们能得到的最佳近似值是这样的:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2ba6" class="nj mi iq nf b gy nk nl l nm nn">new Intl.DateTimeFormat(‘en-US’,{ year: ‘numeric’, month: ‘long’, day: ‘numeric’ }).format(mydate)</span></pre><p id="ad47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就给出了2020年6月22日。至少可以说，这不是一个非常紧凑的解决方案。</p><p id="8af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，<em class="ls"> Intl API </em> <strong class="ky ir">提供了一种在<em class="ls"> Intl中产生序数后缀的方法。PluralRules </em>对象，但是没有办法在<em class="ls"> Intl中获得相同的效果。DateTimeFormat.format </em>方法。</strong></p><p id="81a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个例子可以用类似的方式<strong class="ky ir">精确地</strong>解决:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="552e" class="nj mi iq nf b gy nk nl l nm nn">2) <strong class="nf ir">22/06/2020</strong></span><span id="76a8" class="nj mi iq nf b gy nr nl l nm nn">new Intl.DateTimeFormat('it-IT',{ day: '2-digit', month: '2-digit', year: 'numeric' }).format(mydate)</span></pre><p id="8499" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于第三种情况，没有简洁的解决方案，因为我们需要一个非标准分隔符，并且我们需要删除日期后的逗号:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b61f" class="nj mi iq nf b gy nk nl l nm nn">3) <strong class="nf ir">22.06.20 13.00</strong></span><span id="4a34" class="nj mi iq nf b gy nr nl l nm nn">let d = new Intl.DateTimeFormat('en-GB',{ day: '2-digit', month: '2-digit', year: '2-digit', hour:'2-digit', minute:'2-digit', hour12:true }).format(mydate);</span><span id="de69" class="nj mi iq nf b gy nr nl l nm nn">d = d.replace(/\//g,'.').replace(/:/,'.').replace(',','')</span></pre><p id="34cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第四个例子可以用Intl正确地实现。日期时间格式:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="862f" class="nj mi iq nf b gy nk nl l nm nn">4) <strong class="nf ir">Mon,</strong> <strong class="nf ir">Jun 22, 1.00 pm</strong></span><span id="55dd" class="nj mi iq nf b gy nr nl l nm nn">new Intl.DateTimeFormat('en-US',{ weekday:'short', month: 'short', day: 'numeric', hour: 'numeric', minute:'2-digit', hour12:true }).format(mydate)</span></pre><p id="e190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，看着上面的表情，你不感到绝望吗？是不是显得没必要的啰嗦？</p><h1 id="6e76" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">解析日期</h1><p id="8743" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">让我们继续程序员处理的第二个最常见的日期操作:解析表示日期的字符串，以获得相应的日期对象。</p><p id="efa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">的确，日期“类”有一个“.parse”方法应该做到这一点:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c4a2" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">Date.parse(‘2012–07–06’)</strong> gives <strong class="nf ir">1341532800000</strong></span><span id="7b1e" class="nj mi iq nf b gy nr nl l nm nn">and</span><span id="5c7e" class="nj mi iq nf b gy nr nl l nm nn"><strong class="nf ir">Date.parse(‘July 6, 2012’)</strong> gives <strong class="nf ir">1341525600000</strong></span></pre><p id="a0de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">等等，等等</em> </strong>！但是这些日期不是一样的吗？我们得到不同的数字，怎么回事？让我们把它们格式化回来:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="eddb" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">new Date(Date.parse(‘2012-07-06’)) : Fri Jul 06 2012 02:00:00 GMT:+0200</strong></span><span id="fbc3" class="nj mi iq nf b gy nr nl l nm nn"><strong class="nf ir">new Date(Date.parse(‘Jul 6, 2012’)) : Fri Jul 06 2012 00:00:00 GMT:+0200</strong></span></pre><p id="9875" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看出区别了吗？前者的<strong class="ky ir"> <em class="ls">小时</em> </strong>是下午2点，后者的<strong class="ky ir"> <em class="ls">午夜</em> </strong>。JavaScript引擎解释两个日期，这两个日期对一个人来说是相等的，就好像它们是不同的一样:第一个日期被解释为GMT时区的午夜，然后转换为我的时区(CEST)，也就是凌晨2:00。第二个日期被解释为我的时区的午夜。</p><p id="3180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在Chrome、Firefox和Safari上测试过它们:它们都同意这种解释，这意味着它们可能遵循了ECMA的官方定义。<br/> <strong class="ky ir"> <em class="ls">那不是废话</em> </strong>吗？</p><p id="31fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更糟糕的是，各种JavaScript引擎在如何解释字符串的问题上并不总是意见一致。例如:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="0e04" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">           Date.parse(‘2012-07-06 14:20:34’)</strong> <br/>                        <em class="ls">gives</em> </span><span id="53b1" class="nj mi iq nf b gy nr nl l nm nn">          <strong class="nf ir">1341584434000</strong> <em class="ls">in Chrome and Firefox</em><br/>                    <strong class="nf ir">NaN</strong> <em class="ls">in Safari</em></span></pre><p id="eb6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Safari是一个纯粹主义者，只识别日期和时间之间带有“T”分隔符的日期时间，例如<strong class="ky ir">2012–07–06t 14:20:34。</strong></p><p id="7647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，<strong class="ky ir"> <em class="ls"> Date.parse </em> </strong>方法只能解释非常少的字符串类型:<strong class="ky ir"> <em class="ls"> ISO </em> </strong>格式(我们的第一个例子)、<strong class="ky ir"> <em class="ls">长日期</em> </strong>(第二个例子)和<strong class="ky ir"> <em class="ls">短日期</em> </strong>(例如07/06/2020)。没有办法通知。关于日期的组成部分如何放置在字符串中的解析函数。</p><h1 id="5970" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">日期算法</h1><p id="f12f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在处理日期时，一个常见的需要是计算两个日期之间的时间间隔或者计算什么日期是<strong class="ky ir"><em class="ls"/></strong>小时、<strong class="ky ir"> <em class="ls"> </em> </strong>天、月等。<strong class="ky ir"> <em class="ls">后</em> </strong>或<strong class="ky ir"> <em class="ls">前</em> </strong>给定日期。</p><p id="17de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于原生JavaScript来说，这很简单，对与日期相对应的数值进行算术运算，即表示自1970年1月1日以来的<strong class="ky ir"><em class="ls"/></strong>毫秒数的整数。</p><p id="c11c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，</p><ol class=""><li id="4423" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">计算日期2和日期1之间的差异<strong class="ky ir"> <em class="ls">小时</em> </strong>:</li></ol><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="487c" class="nj mi iq nf b gy nk nl l nm nn">Math.round( ( date2.valueOf() — date1.valueOf() ) / (60*60*1000) );</span></pre><p id="a097" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.计算两周后的日期:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="24cc" class="nj mi iq nf b gy nk nl l nm nn">new Date(Date.now() + 2*7*24*3600*1000);</span></pre><p id="aa7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.以天数计算我的年龄:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2cf6" class="nj mi iq nf b gy nk nl l nm nn">Math.floor((Date.now()-Date.parse(‘1956–07–13’)) / (24*3600*1000));</span></pre><p id="833b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这并不困难，但是值得注意的是缺乏任何直接的和用户友好的方法来做同样的事情。</p><p id="fa14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出现的问题通常会更复杂:</p><p id="dc5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.找到下一个星期一</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ebab" class="nj mi iq nf b gy nk nl l nm nn">let now = Date.now(); <br/>let today = now — now%(24*3600*1000);   // round to current day <br/>let weekDay = new Date(today).getDay(); // Sunday=0, Monday=1 etc. <br/>let nextMonday = new Date( today + (1 + (7-weekDay)%7)*24*3600*1000 );</span></pre><h1 id="8c9c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">图书馆尽职尽责</h1><p id="fe39" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">幸运的是，有一些JavaScript库可以解决JavaScript对日期操作支持不足所带来的所有问题。而且我要说，任何一个像样的JavaScript程序员都必须使用其中的一个，而不是依赖于原生的JavaScript <strong class="ky ir"> <em class="ls"> Date </em> </strong>和<strong class="ky ir"> <em class="ls"> Intl </em> </strong>对象。</p><p id="e2b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将展示我们如何使用以下库之一出色地解决上面列出的所有示例:</p><ul class=""><li id="0892" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ns lz ma mb bi translated"><a class="ae kv" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> moment.js </strong> </a>，最知名最全的库，支持多种浏览器。它包括对国际化的全面支持。</li><li id="a1f1" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ns lz ma mb bi translated"><a class="ae kv" href="https://day.js.org/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> day.js </strong> </a>，moment.js的快速轻量替代方案(所有国际化支持都保存在单独的文件中)</li><li id="0e38" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ns lz ma mb bi translated"><a class="ae kv" href="https://moment.github.io/luxon/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> luxon </strong> </a> <strong class="ky ir">，</strong>最新的库，由moment.js相同的组织支持，使用了不同的方法，与moment.js相比有优点和缺点(参见<a class="ae kv" href="https://moment.github.io/luxon/docs/manual/why.html" rel="noopener ugc nofollow" target="_blank">Luxon为什么存在？</a>)</li></ul><h1 id="9319" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">用moment.js和朋友格式化日期</h1><p id="4ebc" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">下面是我们给出的四个格式化示例的工作原理。</p><p id="30ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">moment . js<em class="ls">和</em> day.js </strong></p><p id="5e25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假如<strong class="ky ir"> <em class="ls"> mydate </em> </strong>是用<strong class="ky ir"><em class="ls">【mydate】</em></strong><em class="ls"/>或<em class="ls"/><strong class="ky ir"><em class="ls">dayjs(mydate)</em></strong>获得的包装对象，我们的格式化问题就很容易解决了:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="7493" class="nj mi iq nf b gy nk nl l nm nn">1) <strong class="nf ir">June 22nd, 2020             mydate.format('MMMM Do, YYYY')</strong></span><span id="4508" class="nj mi iq nf b gy nr nl l nm nn">2) <strong class="nf ir">22/06/2020                  mydate.format('DD/MM/YYYY')</strong></span><span id="cf5b" class="nj mi iq nf b gy nr nl l nm nn">3) <strong class="nf ir">22.06.20 13.00              mydate.format('DD.MM.YY HH.mm')</strong></span><span id="b7df" class="nj mi iq nf b gy nr nl l nm nn">4) <strong class="nf ir">Tue,</strong> <strong class="nf ir">Jun 22, 1.00 pm        mydate.format('ddd, MMM D, h.mm a')</strong></span></pre><p id="6a48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，不是吗？格式选项的完整列表可在<a class="ae kv" href="https://momentjs.com/docs/#/displaying/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kv" href="https://day.js.org/docs/en/display/format" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="c6d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">卢克森</strong></p><p id="3157" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦用创建了日期时间对象</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4645" class="nj mi iq nf b gy nk nl l nm nn">let mydate = luxon.DateTime.fromISO('2020-06-22')</span></pre><p id="ebb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的四个例子可以(几乎)这样解决:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="e6fc" class="nj mi iq nf b gy nk nl l nm nn">1) <strong class="nf ir">June 22nd, 2020             mydate.toFormat('MMMM d, y')<br/>                               </strong>Note: no support for the n-th suffix</span><span id="bd83" class="nj mi iq nf b gy nr nl l nm nn">2) <strong class="nf ir">22/06/2020                  mydate.toFormat('dd/MM/y')</strong></span><span id="d975" class="nj mi iq nf b gy nr nl l nm nn">3) <strong class="nf ir">22.06.20 13.00              mydate.toFormat('dd.MM.yy HH.mm')</strong></span><span id="d80c" class="nj mi iq nf b gy nr nl l nm nn">4) <strong class="nf ir">Tue,</strong> <strong class="nf ir">Jun 22, 1.00 pm        mydate.toFormat('EEE, MMM d, h.mm a')<br/>                               </strong>Note: AM/PM is always uppercase</span></pre><p id="37fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Luxon中可用的格式选项不多的原因是它依赖于<strong class="ky ir"> <em class="ls"> Intl </em> </strong>对象，并且继承了它们的所有优点和缺点。的完整规格。<em class="ls"> toFormat </em>选项可用<a class="ae kv" href="https://moment.github.io/luxon/docs/manual/formatting.html#toformat" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="0eb4" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">解析与moment.js和朋友的约会</h1><p id="d340" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated"><strong class="ky ir"> Moment.js和dayjs </strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8eba" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">moment('2012–07–06')<br/>moment('2012–07–06', 'YYYY-MM-DD')<br/>moment('Jul 6, 2020', 'MMM D, YYYY')</strong></span><span id="59a4" class="nj mi iq nf b gy nr nl l nm nn"><strong class="nf ir">dayjs('2012–07–06')<br/>dayjs('2012–07–06', 'YYYY-MM-DD')<br/>dayjs('Jul 6, 2020', 'MMM D, YYYY')</strong></span><span id="a90b" class="nj mi iq nf b gy nr nl l nm nn">all give</span><span id="036b" class="nj mi iq nf b gy nr nl l nm nn"><strong class="nf ir">Fri Jul 06 2012 00:00:00 GMT+0200</strong></span></pre><p id="fb7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这正是我们可以从<em class="ls">解析</em>函数中期望得到的东西。此处<a class="ae kv" href="https://momentjs.com/docs/#/parsing/" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae kv" href="https://day.js.org/docs/en/parse/string-format" rel="noopener ugc nofollow" target="_blank">此处</a>提供完整规格。</p><p id="5e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，moment.js和day.js都将缺少的时间部分解释为当前时区的午夜。如果想用UTC解析或显示日期时间，可以用<code class="fe no np nq nf b">moment.utc()</code>和<code class="fe no np nq nf b">dayjs.utc()</code>代替<code class="fe no np nq nf b">moment()</code>和<code class="fe no np nq nf b">dayjs()</code>。</p><p id="09b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">卢克森</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8ef1" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">luxon.DateTime.fromISO('2012-07-06')<br/>luxon.DateTime.fromFormat('2012-07-06','y-MM-dd');<br/>luxon.DateTime.fromFormat('Jul 6, 2012','MMM d, y')</strong></span><span id="29b9" class="nj mi iq nf b gy nr nl l nm nn">all give</span><span id="8a49" class="nj mi iq nf b gy nr nl l nm nn"><strong class="nf ir">2012-07-06T00:00:00.000+02:00</strong></span></pre><p id="90c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与moment.js和day.js一样，当没有给出附加选项时，日期被解释为当前时区的午夜。Luxon解析的完整规范可从<a class="ae kv" href="https://moment.github.io/luxon/docs/manual/parsing.html" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="1c6c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">与moment.js和朋友的约会算法</h1><p id="94fc" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">下面是我们给出的四个计算日期的例子。</p><p id="ab97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Moment.js和day.js </strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="726a" class="nj mi iq nf b gy nk nl l nm nn">1. compute the difference in hours between date2 and date1:                                        -&gt; <strong class="nf ir">moment(date2).diff(date1,’hours’)<br/></strong>-&gt; <strong class="nf ir">dayjs(date2).diff(date1,’hours’)</strong></span><span id="66e9" class="nj mi iq nf b gy nr nl l nm nn">2. compute the Date that is two weeks in the future since now:<br/>-&gt; <strong class="nf ir">moment().add(2,'weeks')<br/></strong>-&gt; <strong class="nf ir">dayjs().add(2,'weeks')</strong></span><span id="59ca" class="nj mi iq nf b gy nr nl l nm nn">3. compute my age in days:<br/>-&gt; <strong class="nf ir">moment().diff('1956-07-13','days')<br/></strong>-&gt; <strong class="nf ir">dayjs().diff('1956-07-13','days')</strong></span><span id="4950" class="nj mi iq nf b gy nr nl l nm nn">4. find the next Monday<br/>-&gt; <strong class="nf ir">moment().startOf('isoWeek').add(1, 'week')<br/></strong>-&gt; <strong class="nf ir">dayjs().startOf('isoWeek').add(1, 'week')</strong></span></pre><p id="6131" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个需要一些解释:<em class="ls">。startOf('isoWeek') </em>获取给定周期的开始日期；在我们的示例中，我们需要符合ISO 8601标准的本周开始，即星期一。</p><p id="e418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">全套操作方法在<a class="ae kv" href="https://momentjs.com/docs/#/manipulating/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kv" href="https://day.js.org/docs/en/manipulate/manipulate" rel="noopener ugc nofollow" target="_blank">这里</a>解释</p><p id="bbb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">卢克森</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5266" class="nj mi iq nf b gy nk nl l nm nn">1. compute the difference in hours between date2 and date1:                                        -&gt; <strong class="nf ir">date2.diff(date1).as('hours')</strong></span><span id="0671" class="nj mi iq nf b gy nr nl l nm nn">2. compute the Date that is two weeks in the future since now:<br/>-&gt; <strong class="nf ir">luxon.DateTime.local().plus({weeks: 2})</strong></span><span id="66cf" class="nj mi iq nf b gy nr nl l nm nn">3. compute my age in days:<br/>-&gt; <strong class="nf ir">luxon.DateTime.local().diff( luxon.DateTime.fromISO('1956-07-13') ).as('days')</strong></span><span id="d927" class="nj mi iq nf b gy nr nl l nm nn">4. find the next Monday<br/>-&gt; <strong class="nf ir">luxon.DateTime.local().set({weekday: 1}).plus({weeks: 1})</strong></span></pre><p id="7ec4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整规格可在<a class="ae kv" href="https://moment.github.io/luxon/docs/manual/math.html" rel="noopener ugc nofollow" target="_blank">此处</a>获得。</p><h1 id="f252" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="0603" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">不清楚为什么ECMA从2011年起就没有着手JavaScript日期对象规范，尽管它的功能缺陷是显而易见的。幸运的是，一些第三方库可以让我们避免很多麻烦。</p><p id="fa1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能现在最好的选择是<em class="ls"> day.js </em>，因为它比<em class="ls"> moment.js </em>更轻，比<em class="ls"> luxon </em>更紧凑。与<em class="ls"> moment.js相比，</em>还有一个额外的优势，那就是它的<strong class="ky ir"> dayjs </strong> wrapper对象是<strong class="ky ir">不可变的</strong>，也就是说，不能通过应用<em class="ls">之类的方法无意中改变它。增加</em>或<em class="ls">。减去</em>。</p></div></div>    
</body>
</html>