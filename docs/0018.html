<html>
<head>
<title>Reflect API 👌 Simple words about the complex theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反映API👌关于复杂理论的简单话语</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reflect-api-simple-words-about-the-complex-theory-ec70c56cd558?source=collection_archive---------0-----------------------#2018-08-06">https://javascript.plainenglish.io/reflect-api-simple-words-about-the-complex-theory-ec70c56cd558?source=collection_archive---------0-----------------------#2018-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">反射API </strong> </a>揭露隐藏在普通JavaScript习惯用法背后的抽象操作。它的主要用途是提供合理的方法来转发代理陷阱上调用的操作。</p><p id="8b70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Reflect </strong>是一组用于处理对象的有用方法，其中一半重写了对象中已经存在的<em class="kj">。</em></p><p id="8906" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这样做是为了改善语义和排序</strong>，因为Object是基类，但是它也包含了很多不应该在其中的方法。同样，如果你用一个空的原型创建一个对象，那么你将会失去反射方法。</p><p id="8998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与大多数全局对象不同，<strong class="jm io"> Reflect </strong>不是一个构造函数。不能将它与new运算符一起使用，也不能将Reflect对象作为函数调用。反射的所有属性和方法都是静态的。</p></div><div class="ab cl kk kl hr km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ig ih ii ij ik"><p id="4c87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">e.g .我们可以创建一个对象，其中的字段<strong class="jm io">将在访问它们时自动创建:</strong></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="kw kx l"/></div></figure><ul class=""><li id="c09b" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><strong class="jm io"> Reflect.has() </strong>方法的工作原理类似于&gt; <strong class="jm io"> <em class="kj">中的&lt; </em> </strong>运算符作为函数</li></ul><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="2073" class="lm ln in li b gy lo lp l lq lr">// <strong class="li io">Reflect.has()</strong></span><span id="ff36" class="lm ln in li b gy ls lp l lq lr">const <strong class="li io">MyObject </strong>= {<br/>  "<strong class="li io">property_1</strong>": 42<br/>};</span><span id="1c1e" class="lm ln in li b gy ls lp l lq lr">console.log( <strong class="li io">Reflect.has(MyObject</strong>, "<strong class="li io">property_1</strong>"<strong class="li io">) </strong>);<br/>// output: <strong class="li io">true</strong></span><span id="25c8" class="lm ln in li b gy ls lp l lq lr">console.log( <strong class="li io">Reflect.has(MyObject</strong>, "<strong class="li io">property_2</strong>"<strong class="li io">) </strong>);<br/>// output: <strong class="li io">false</strong></span></pre><ul class=""><li id="0f40" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><strong class="jm io"> Reflect.set() </strong>方法的工作原理类似于<em class="kj">设置一个对象的属性。</em></li></ul><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="b40e" class="lm ln in li b gy lo lp l lq lr">// <strong class="li io">Reflect.set()</strong></span><span id="d6bf" class="lm ln in li b gy ls lp l lq lr">const <strong class="li io">SmthObject = {}</strong>;<br/><strong class="li io">Reflect.set( SmthObject</strong>, '<strong class="li io">property</strong>', <strong class="li io">42 )</strong>;</span><span id="d04d" class="lm ln in li b gy ls lp l lq lr">console.log( <strong class="li io">SmthObject.property </strong>);<br/>// <em class="kj">output: 42</em></span><span id="1246" class="lm ln in li b gy ls lp l lq lr">const <strong class="li io">SmthArray </strong>= ['duck', 'duck', 'duck'];<br/><strong class="li io">Reflect.set( SmthArray</strong>, <strong class="li io">2</strong>, '<strong class="li io">goose</strong>' );</span><span id="0ddc" class="lm ln in li b gy ls lp l lq lr">console.log( <strong class="li io">SmthArray[2]</strong> );<br/>// <em class="kj">output: "goose"</em></span></pre><ul class=""><li id="66a5" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><strong class="jm io"> Reflect.get() </strong>方法的工作原理类似于从一个对象获取一个属性(target[propertyKey]) <strong class="jm io">作为一个函数。</strong></li></ul><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="026d" class="lm ln in li b gy lo lp l lq lr">const <strong class="li io">SmthObject </strong>= {<br/>  x: 1,<br/>  y: 2<br/>};</span><span id="7929" class="lm ln in li b gy ls lp l lq lr">console.log( <strong class="li io">Reflect.get(SmthObject, 'x')</strong> );<br/>// <em class="kj">output: 1</em></span><span id="7a1e" class="lm ln in li b gy ls lp l lq lr">const <strong class="li io">SmthArray </strong>= ['zero', 'one'];</span><span id="4b97" class="lm ln in li b gy ls lp l lq lr">console.log( <strong class="li io">Reflect.get(SmthArray, 1) </strong>);</span></pre></div><div class="ab cl kk kl hr km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ig ih ii ij ik"><h1 id="d5bd" class="lt ln in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">那么为什么有必要使用反射❓呢</h1><ul class=""><li id="a24e" class="ky kz in jm b jn mq jr mr jv ms jz mt kd mu kh ld le lf lg bi translated"><strong class="jm io">反射AP </strong> I更便于错误处理。例如，每个人都知道指令:</li></ul><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="85b6" class="lm ln in li b gy lo lp l lq lr"><strong class="li io">Object.defineProperty ( </strong>obj, name, desc<strong class="li io"> )</strong></span></pre><p id="120c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果失败，将会抛出异常。</p><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="659b" class="lm ln in li b gy lo lp l lq lr"><strong class="li io">try {</strong><br/>   <strong class="li io">Object.defineProperty(</strong> obj, name, desc <strong class="li io">)</strong>;<br/>   // property defined successfully<br/><strong class="li io">} catch (e) {</strong><br/>   // possible failure and might accidentally catch the wrong exception<br/><strong class="li io">}</strong></span></pre><p id="9783" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Reflect总是返回布尔值。</p><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="87df" class="lm ln in li b gy lo lp l lq lr">if ( <strong class="li io">Reflect.defineProperty( SmtObj</strong>, name, desc ) ) {<br/>   // success<br/>} else {<br/>   // to do smth<br/>}</span></pre><ul class=""><li id="2ea8" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><strong class="jm io">某些条件更短</strong>😉</li></ul><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="5242" class="lm ln in li b gy lo lp l lq lr"><strong class="li io">Function.prototype.apply.call(</strong> func, obj, args <strong class="li io">)</strong> </span><span id="566f" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Reflect.apply.call(</strong> func, obj, args <strong class="li io">)</strong></span></pre><ul class=""><li id="104a" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><strong class="jm io">行为差异</strong>💪</li></ul><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="305a" class="lm ln in li b gy lo lp l lq lr"><strong class="li io">Object.getPrototypeOf( </strong>1 <strong class="li io">)</strong>; // undefined</span><span id="9459" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Reflect.getPrototypeOf( </strong>1 <strong class="li io">)</strong>; // TypeError - more logical </span></pre><ul class=""><li id="3a71" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated"><strong class="jm io">使用空原型</strong>🥛</li></ul><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="e90a" class="lm ln in li b gy lo lp l lq lr">const <strong class="li io">SmtObj</strong> = Object.create(null);<br/><strong class="li io">SmtObj</strong>.bar = "value of eproperty";</span><span id="e034" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">SmtObj</strong>.<strong class="li io">hasOwnProperty </strong>=== <strong class="li io"><em class="kj">undefined</em></strong>; // true</span><span id="c0ff" class="lm ln in li b gy ls lp l lq lr">// SO YOU MUST TO WRITE THIS:</span><span id="764a" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Object.prototype.hasOwnProperty.call(</strong> <strong class="li io">SmtObj</strong>, 'bar' <strong class="li io">)</strong>; // true</span></pre><blockquote class="mv mw mx"><p id="7be2" class="jk jl kj jm b jn jo jp jq jr js jt ju my jw jx jy mz ka kb kc na ke kf kg kh ig bi translated">我们没有<strong class="jm io">反射</strong>的方法，例如<strong class="jm io"> hasOwnProperty() </strong></p></blockquote><p id="ba93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们可以用老🗝️的方法，参照<em class="kj">基类的原型，或者参照</em> <strong class="jm io"> <em class="kj">反映API </em> : </strong></p><pre class="kr ks kt ku gt lh li lj lk aw ll bi"><span id="b37d" class="lm ln in li b gy lo lp l lq lr"><strong class="li io">Reflect.ownKeys(</strong> SmtObj <strong class="li io">)</strong>.<strong class="li io">includes(</strong>'bar'<strong class="li io">)</strong></span></pre><blockquote class="nb"><p id="b288" class="nc nd in bd ne nf ng nh ni nj nk kh dk">👏👏👏</p><p id="671a" class="nc nd in bd ne nf nl nm nn no np kh dk translated">一般来说，Reflect API看起来像是重构的结果。</p><p id="1b21" class="nc nd in bd ne nf nl nm nn no np kh dk translated">它包含以前在基类Object、Function、<strong class="ak">等</strong>中保护的反射函数。</p><p id="e51d" class="nc nd in bd ne nf nl nm nn no np kh dk translated">如上所示，行为和错误处理发生了变化。</p></blockquote><figure class="nq nr ns nt nu kv gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/9d9154a4566ec3f663b7350d8b0fac28.png" data-original-src="https://miro.medium.com/v2/1*5m-Ty6IjvNBHM0vRBEiVDw.gif"/></div></figure></div><div class="ab cl kk kl hr km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ig ih ii ij ik"><ul class=""><li id="86a5" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">MDN Web文档</li></ul><div class="ny nz gp gr oa ob"><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/proxy" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">代理人</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">使用代理API代理web请求。有两种不同的方法可以做到这一点:</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">developer.mozilla.org</p></div></div><div class="ok l"><div class="ol l om on oo ok op nw ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">显示</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">Reflect是一个内置对象，为可拦截的JavaScript操作提供方法。方法与…相同</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">developer.mozilla.org</p></div></div><div class="ok l"><div class="oq l om on oo ok op nw ob"/></div></div></a></div><ul class=""><li id="0b92" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">Habr</li></ul><div class="ny nz gp gr oa ob"><a href="https://habr.com/company/tuturu/blog/334546/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">про反映API</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk">Всем привет! Недавно услышал, как одни молодые фронтендеры пытались объяснить другим молодым фронтендерам, что такое…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">habr.com</p></div></div><div class="ok l"><div class="or l om on oo ok op nw ob"/></div></div></a></div></div></div>    
</body>
</html>