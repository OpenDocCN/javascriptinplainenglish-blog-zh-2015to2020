# 对疲劳反应开发者有用的定制钩子

> 原文：<https://javascript.plainenglish.io/useful-custom-hooks-for-tired-react-devs-f2f602dc754f?source=collection_archive---------1----------------------->

![](img/c2c8d3623c306a15557a58e6ad8407a8.png)

Photo by [Anne Nygård](https://unsplash.com/@polarmermaid?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

编写反应应用程序可能会得到同样的结果。我们经常发现自己一遍又一遍地重复定义相同组件行为的相同模式，人们会开始怀疑我们如何才能使这些模式越来越枯燥。

反应钩棒极了。通过滥用 JavaScript 闭包的力量，并加上一些警告，可以在函数中保存状态。这有多酷？

*(在我被 C 开发者喊下来之前，他们会告诉我函数中的* `*static*` *变量实际上是有状态的，我知道。)*

钩子不仅允许有状态行为，而且它们还是*被动的*。您可以使用钩子对组件的支柱、存储状态、对可变值的存储引用等的变化做出反应。这只是使用默认情况下附带的钩子。挂钩也是*可组合的*。这意味着我可以编写自己的钩子，使用其他钩子。通过将这些结合起来，可以有效地将状态、行为或反应性注入任何功能组件。

在本文中，我将介绍几个例子，包括 reactor 和 React Native devs，它们证明了这种可组合性，并创建了一些整洁、超级方便、易于测试的功能，可以在任何项目中使用。

# 通用挂钩

这些钩子可用于 reactor 和 React Native 项目，因为它们都是 JS 专用的，并且使用了两者中可用的特性。

## 使用安装

通常情况下，我们可能会遇到这样的情况:副作用的后果是卸载一个期望进行状态更新的组件。例如，让我们想象以下取自我的一个旧代码库的例子:

现在，这个组件有几个我们不会涉及的问题，但是我们应该*真的*处理`props.onClick`拒绝的情况。

无论如何，就我们的目的而言，这没问题。但是如果`props.onClick`让应用程序导航到一个新的页面会发生什么呢？该按钮将卸载，因此，调用`setLoading(false)`。一般来说，**不应该更新未安装组件的状态**，因为这会导致内存泄漏**。**

当我们到达`setLoading(false)`时，我们需要知道组件是否仍然被安装，因为如果在此期间组件已经被卸载，我们需要跳过它。

让我们写一个钩子给我们参考:

现在，我们可以在前面的例子中使用它:

这个钩子帮助我避免了一些微妙的错误。快速前进-

## useWebSocket

如果您正在构建一个包含任何类型的实时通信(聊天、游戏等)的应用程序，那么您很可能最终会使用网络套接字。它们为您提供与另一台主机的全双工(双向)通信，这与采用请求-响应模型的 HTTP 相反。

在 React 组件中处理 WebSocket 的状态可能有点痛苦，并且您必须始终记住在卸载时关闭 WebSocket，等等。简而言之，如果你在应用程序的很多地方使用 WebSockets，这会导致很多重复。

让我们来看看钩子:

这个钩子返回一个 ref，它将活动的 WebSocket 存储在它的`current`属性中，并在使用它的组件卸载时自动关闭它，例如

这个钩子有很多灵活的基于 WebSocket 的应用用例，特别是 here chat，我们可以在聊天关闭时安全地关闭 WebSocket，只有在聊天打开时才打开它。

酷吧？假设我们得到了一个实际的`ws`实例的`ref`，那么使用通常的 WebSocket API，很容易添加我们可能想要的任何额外行为。

## 使用负载

这个钩子可以节省一点时间。想象一下这个场景——你有一个带有`n`按钮的组件，所有这些按钮都在按压/点击/点击等操作时启动一些异步操作。跟踪它们的加载状态有点麻烦——你不希望必须维护一个对象或加载布尔值的数组，因为这很容易导致错误——尤其是如果按钮的数量在组件的生命周期中会发生变化！看起来是这样的:

现在你有了一个关于动作加载状态的视图，被封装到一个钩子中——不再有`useState`弄乱你的组件，你可以这样做:

因为包装器确保返回您的`async`函数返回的承诺，所以您可以使用承诺(`await`、承诺链接等做所有您想做的事情。).

# 反应自然

这里有一个钩子，我们可以在 React 本地应用程序中使用它，让我们的生活变得更加轻松。

## 使用状态条

> 编辑:[来自`react-navigation`文档的这个教程](https://reactnavigation.org/docs/status-bar/#tabs-and-drawer)提供了这个钩子的一个更加声明性的版本，以达到同样的效果。

在使用 React 导航编写 React 原生应用时，我们经常会遇到一个特殊的问题。简而言之，设备的状态栏通过渲染一个`StatusBar`组件来控制。但是，如果我们有一个多屏幕的应用程序，一次呈现多个屏幕，而不是延迟加载，这种方法可能会失败。这是因为渲染这个`StatusBar`更新了引擎下的配置，但是只反映了上次渲染时的状态。这意味着，如果你的应用程序有屏幕 A 和 B，即使你有一个可见的，如果 B 在 A 之后呈现，状态栏将有来自屏幕 B 的配置，这对于屏幕 A 是错误的。

幸运的是，React Native 的`StatusBar`模块也导出了设置这个配置的强制方法。那么，如果我们可以编写一个钩子，在屏幕聚焦时进行这些命令性的调用，这样我们就总是有正确的配置，会怎么样呢？这是我为一个项目写的一个钩子，它就是这样做的:

Only drawback here is it’s not super future-proof for API changes.

现在我们只需调用`useStatusBar`就可以在每个屏幕上设置配置，当屏幕成为焦点时，它总是正确的。这种基于钩子的替代方法有助于使你的标记在每个屏幕上都清晰地呈现出`StatusBar`。

## 更进一步—使用外观 AwareStatusBar

如果我们有一个应用程序，使用手机的配色方案+偏好，可以在幕后改变，支持黑暗和光明模式，会怎么样？我们可以更进一步:

A little more complicated, but super powerful!

现在，如果用户在你的应用程序设置中改变了他们的颜色偏好，或者，例如，太阳下山，你手机的配色方案发生了变化，这个`StatusBar`将会意识到这一点，并与应用程序的其余部分相匹配。这里显然我们没有考虑`StatusBar` API 中的其他方法，这将是一个受欢迎的改进。

# 包扎

如前所述，React 应用程序可能会变得千篇一律。我们经常发现自己为许多组件维护相同的行为，而钩子是重用行为并使维护和迭代速度快如闪电的好方法。

感谢阅读！

💙