<html>
<head>
<title>React Technical Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回应技术面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-v16-technical-interview-questions-1d9b85e6167d?source=collection_archive---------2-----------------------#2020-03-16">https://javascript.plainenglish.io/react-v16-technical-interview-questions-1d9b85e6167d?source=collection_archive---------2-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/855c478dfd34506d5624211862486a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yic1G-V3tQBtG1DJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ryanmoreno?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ryan Moreno</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8776" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.什么是纯组件</h1><ul class=""><li id="f6e3" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">除了为您处理<code class="fe lt lu lv lw b">shouldComponentUpdate</code>方法之外，<code class="fe lt lu lv lw b">PureComponent</code>与<code class="fe lt lu lv lw b">Component</code>完全相同</li><li id="14a0" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">当道具或状态改变时，<code class="fe lt lu lv lw b">PureComponent</code>会对道具和状态做一个浅显的比较</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="9f25" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">2.反应状态是什么</h1><ul class=""><li id="0ea1" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">组件的状态是一个对象，它包含一些在组件的生命周期中可能会改变的信息</li><li id="7a3c" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">状态用于组件内部的内部通信</li><li id="b8d4" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">状态类似于道具，但它是</li></ul><p id="9645" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">状态vs道具</strong></p><ol class=""><li id="f753" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo ni lq lr ls bi translated">私人的</li><li id="dc60" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">完全由组件控制(即，除了拥有和设置它的组件之外，任何组件都不能访问它</li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="c282" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">3.React中的道具是什么</h1><ul class=""><li id="904f" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">道具是组件的输入</li><li id="fceb" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">属性是从父组件传递到子组件的数据</li></ul><p id="5ba9" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">React中道具的用途</strong></p><ol class=""><li id="cc45" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo ni lq lr ls bi translated">将自定义数据传递给组件</li><li id="1dd9" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">触发状态变化</li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="3ae7" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">4.状态和道具有什么区别</h1><p id="6ba5" class="pw-post-body-paragraph mo mp iq ld b le lf mr ms lg lh mu mv li nj mx my lk nk na nb lm nl nd ne lo ij bi translated"><strong class="ld ir">道具</strong></p><ul class=""><li id="d92d" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated">类似于函数参数，属性被传递给组件</li></ul><p id="39fe" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">状态</strong></p><ul class=""><li id="7419" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated">状态在组件中的管理类似于在函数中声明的变量</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="2843" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">5.为什么我们不应该直接更新状态</h1><ul class=""><li id="8bd8" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如果您尝试直接更新状态，那么它将不会重新呈现组件</li><li id="816e" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">相反，<code class="fe lt lu lv lw b">setState()</code>安排更新组件的状态对象</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="91e8" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">6.如何在JSX回调中绑定方法或事件处理程序</h1><h2 id="7615" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated"><strong class="ak"> &gt; 1在构造函数中绑定</strong></h2><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="ab67" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">&gt; 2公共类字段语法</h2><ul class=""><li id="8fad" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如果您不喜欢使用<code class="fe lt lu lv lw b">bind</code>方法，那么可以使用<code class="fe lt lu lv lw b">public class fields</code>语法来正确绑定回调</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="5625" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">回调中超过3个箭头函数</h2><ul class=""><li id="1b00" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">你可以在回调中直接使用<code class="fe lt lu lv lw b">arrow functions</code></li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="29c8" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">重要*</h2><ul class=""><li id="83f9" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如果回调作为prop传递给子组件，这些组件可能会进行额外的重新呈现</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="e93a" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">7.React中的合成事件是什么</h1><ul class=""><li id="8b89" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><code class="fe lt lu lv lw b">SyntheticEvent</code>是围绕浏览器本地事件的跨浏览器包装器</li><li id="5797" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">类似于<code class="fe lt lu lv lw b">stopPropagation()</code>和<code class="fe lt lu lv lw b">preventDefault()</code>，除了事件在所有浏览器中的工作方式相同</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="9fb0" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">8.什么是“关键”道具，在元素数组中使用它们有什么好处</h1><ul class=""><li id="80c4" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><code class="fe lt lu lv lw b">key</code>是一个特殊的字符串属性，在创建元素数组时应该包含它</li><li id="22e4" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">关键字有助于识别哪些项目发生了更改、被添加或被删除</li></ul><h2 id="7ac6" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated"><strong class="ak">重要* </strong></h2><ul class=""><li id="77f7" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如果项目的顺序可能会改变，不建议使用索引键</li><li id="7f41" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">这可能会对性能产生负面影响，并可能导致组件状态出现问题</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="1528" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">9.如何创建参考文献</h1><h2 id="a3ba" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated"><strong class="ak">有两种方法</strong></h2><h2 id="6abf" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">&gt;第一种方法</h2><ul class=""><li id="0bb5" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">可以使用<code class="fe lt lu lv lw b">React.createRef()</code>方法创建引用，并通过<code class="fe lt lu lv lw b">ref attribute</code>将其附加到React元素</li><li id="7484" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">为了在整个组件中使用<code class="fe lt lu lv lw b">refs</code>，只需将<code class="fe lt lu lv lw b">ref</code>分配给构造函数中的实例属性</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="7c2d" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">&gt;第二种方法</h2><ul class=""><li id="2c4f" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">使用引用回调(不管React版本如何)</li></ul><p id="4d9e" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">例如，</strong></p><ul class=""><li id="743f" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated">搜索栏组件的输入元素访问如下:</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="4a82" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">10.什么是前锋参考</h1><ul class=""><li id="d134" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">引用转发是一个特性，它允许某个组件接收一个引用，并将其进一步传递给一个子组件</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="b8f3" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">11.什么是受控组件</h1><ul class=""><li id="e2d3" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">在后续用户输入时控制表单中的输入元素的组件</li></ul><p id="fe3c" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">例如，</strong></p><ul class=""><li id="19fb" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated">要用大写字母写所有的名字，我们可以使用handleChange</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="4f25" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">12.什么是不受控组件</h1><ul class=""><li id="46f9" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">不受控制的组件是那些在内部存储它们自己的状态的组件，当你需要的时候，你可以使用一个<strong class="ld ir"> ref </strong>来查询DOM以找到它的当前值</li><li id="7c42" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">换句话说，不受控制的组件就像传统的HTML</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="080a" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">13.React中的提升状态是什么</h1><ul class=""><li id="6752" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">当几个组件需要共享相同的变化数据时，建议将共享状态延续到它们最近的共同祖先</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="b38e" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">14.什么是高阶组件</h1><ul class=""><li id="fc74" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">HOC是一个接受一个组件并返回一个新组件的函数</li><li id="b021" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">基本上，这是一种源自React的组合性质的模式</li></ul><h2 id="9ff3" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">特殊福利</h2><ol class=""><li id="2c9d" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo ni lq lr ls bi translated">代码重用</li><li id="ab6f" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">渲染劫持</li><li id="911e" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">状态抽象和操作</li><li id="d31e" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">道具操作</li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="c246" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">15.什么是语境</h1><ul class=""><li id="2de6" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性(即Redux、Flux……)</li></ul><p id="3766" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">例如，</strong></p><ul class=""><li id="cb3b" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated">许多组件需要在应用程序中访问经过身份验证的用户、本地首选项、UI主题</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="8351" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">16.什么是儿童道具</h1><ul class=""><li id="fa08" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Children是一个道具<code class="fe lt lu lv lw b">this.prop.children</code>，它允许你将组件作为数据传递给其他组件</li><li id="fe6a" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">放在组件开始和结束标签之间的组件树将作为<code class="fe lt lu lv lw b">children</code>属性传递给该组件</li></ul><p id="7a2b" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">React API中可用于此道具的方法数量</strong></p><ol class=""><li id="23dd" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo ni lq lr ls bi translated">React.children.map</li><li id="2b84" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">做出反应。Children.forEach</li><li id="70de" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">做出反应。儿童.计数</li><li id="843e" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">做出反应。仅限儿童</li><li id="2181" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo ni lq lr ls bi translated">做出反应。儿童. toArray</li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="ac26" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">17.使用带props参数的超级构造函数的目的是什么</h1><ul class=""><li id="ba77" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">在调用<code class="fe lt lu lv lw b">super()</code>方法之前，子类构造函数不能引用<code class="fe lt lu lv lw b">this</code></li><li id="afb6" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">将props参数传递给<code class="fe lt lu lv lw b">super()</code>调用的主要原因是为了访问子构造函数中的<code class="fe lt lu lv lw b">this.props</code></li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="8009" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">18.什么是和解</h1><ul class=""><li id="793f" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">当组件的属性或状态改变时，React通过比较来决定是否需要实际的DOM更新</li><li id="e43b" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">当它们不相等时，React将更新DOM</li><li id="b5d1" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">这个过程被称为<strong class="ld ir">对帐</strong></li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="6d26" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">19.如何用动态键名设置状态</h1><ul class=""><li id="7db9" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">使用计算的属性名</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="fe24" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">20.为什么片段使用在容器上</h1><ul class=""><li id="9b22" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">稍微快一点</li><li id="10ac" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">一些css机制，如Flexbox和CSS Grid，有特殊的父子关系，在中间添加div会很难保持理想的布局</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="a2ee" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">21.React v16中的错误界限是什么</h1><ul class=""><li id="4e61" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">错误边界是捕捉子组件树中任何位置的JavaScript错误，记录这些错误，并显示一个后备UI而不是崩溃的组件树的组件</li><li id="1917" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">如果一个类组件定义了一个名为<code class="fe lt lu lv lw b">componentDidCatch(error, info)</code>或<code class="fe lt lu lv lw b">static getDerivedStateFromError()</code>的新的生命周期方法，它就会变成一个错误边界</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="4e80" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">22.` getDerivedStateFromprops()`生命周期方法的目的是什么</h1><ul class=""><li id="62f4" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">新的静态<code class="fe lt lu lv lw b">getDerivedStateFromProps()</code>生命周期方法在组件实例化之后和重新呈现之前被调用</li><li id="6d44" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">它可以返回一个对象来更新状态，或者返回null来表示新的props不需要任何状态更新</li><li id="05ad" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated"><code class="fe lt lu lv lw b">componentDidUpdate()</code>涵盖了<code class="fe lt lu lv lw b">componentWillReceiveProps()</code>的所有用例</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="fd4a" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">23.` getSnapshotBeforeUpdate()`生命周期方法的目的是什么</h1><ul class=""><li id="ad41" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><code class="fe lt lu lv lw b">getSnapshotBeforeUpdate()</code>在DOM更新之前调用生命周期方法</li><li id="f1a0" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">这个生命周期方法和<code class="fe lt lu lv lw b">componentDidUpdate()</code>一起涵盖了<code class="fe lt lu lv lw b">componentWillUpdate()</code>的所有用例</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="22aa" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">24.为什么需要将函数传递给setState()</h1><ul class=""><li id="a320" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">这背后的原因是<code class="fe lt lu lv lw b">setState()</code>是一个异步操作</li><li id="16b1" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">出于性能原因，React批处理状态更改，因此在调用<code class="fe lt lu lv lw b">setState()</code>后，状态可能不会立即更改</li><li id="2250" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">这意味着在调用<code class="fe lt lu lv lw b">setState()</code>时不应该依赖当前状态，因为你不能确定状态将会是什么</li><li id="ad99" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">解决方案是将一个函数传递给<code class="fe lt lu lv lw b">setState()</code>，并将之前的状态作为参数</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="c02c" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">25.React中的严格模式是什么</h1><ul class=""><li id="d801" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><code class="fe lt lu lv lw b">React.StrictMode</code>是突出应用程序中潜在问题的有用组件</li><li id="0a20" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">它为其子代激活附加检查和警告(仅适用于开发模式)</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="86a4" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">重要* </strong></p><ul class=""><li id="ffe1" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated">在本例中，严格模式检查仅适用于<code class="fe lt lu lv lw b">&lt;ComponentOne&gt;</code>和<code class="fe lt lu lv lw b">&lt;ComponentTwo&gt;</code>组件</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="de2f" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">26.什么是反应混合</h1><ul class=""><li id="36ea" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Mixins是一种将组件完全分离以获得共同功能的方法</li><li id="7a44" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">不应使用混频器，可以用高阶元件(HOC)代替</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="7e9e" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">27.为什么“isMount()”是反模式，正确的解决方案是什么</h1><ul class=""><li id="a4e1" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><code class="fe lt lu lv lw b">isMount()</code>的主要用例是避免在组件被卸载后调用<code class="fe lt lu lv lw b">setState()</code>,因为它会发出警告</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="dbe7" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated"><strong class="ld ir">解决方案</strong></p><ul class=""><li id="1ca9" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated">理想情况下，任何回调都应该在卸载之前在<code class="fe lt lu lv lw b">componentWillUnmount()</code>中取消</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="dc6a" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">28.为什么组件名要以大写字母开头</h1><ul class=""><li id="120d" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">组件的名称必须以大写字母开头</li><li id="e7ca" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">否则，React将抛出一个错误，作为无法识别的标签，因为只有HTML元素和SVG标签可以以小写字母开头</li><li id="7b1c" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">您可以定义以小写字母开头的组件类</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><ul class=""><li id="bdf1" class="lb lc iq ld b le mq lg mt li nf lk ng lm nh lo lp lq lr ls bi translated"><strong class="ld ir">但是，</strong>导入的时候应该有大写字母</li></ul><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="a20b" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">29.React v16支持自定义DOM属性吗？</h1><ul class=""><li id="305b" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">反应v16 == &gt;否之前</li><li id="a570" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">反应后v16 == &gt;是</li><li id="d2ad" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">这对于提供特定于浏览器的非标准属性、尝试新的DOM APIs以及与第三方库集成非常有用</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="fdf7" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">30.你能在不调用setState的情况下强制组件重新呈现吗</h1><ul class=""><li id="6ff1" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">默认情况下，当组件的状态或属性改变时，组件将重新呈现</li><li id="2c28" class="lb lc iq ld b le lx lg ly li lz lk ma lm mb lo lp lq lr ls bi translated">如果你的<code class="fe lt lu lv lw b">render()</code>方法依赖于其他数据，你可以通过调用<code class="fe lt lu lv lw b">forceUpdate()</code>告诉React组件需要重新渲染</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="ee45" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">31.在React使用ES6类中,“super()”和“super(props)”有什么区别</h1><ul class=""><li id="d403" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">当你想访问<code class="fe lt lu lv lw b">constructor()</code>中的<code class="fe lt lu lv lw b">this.props</code>时，你应该将道具传递给<code class="fe lt lu lv lw b">super()</code>方法</li></ul><h2 id="337c" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated"><strong class="ak">超级(道具)</strong></h2><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="1169" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">超级()</h2><figure class="ny nz oa ob gt jr"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="e566" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">*重要*</h2><ul class=""><li id="8a50" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">在<code class="fe lt lu lv lw b">constructor()</code>之外，两者将为<code class="fe lt lu lv lw b">this.props</code>显示相同的值</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="8efe" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">32.如何访问属性引号中的属性</h1><ul class=""><li id="b2cb" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">React不支持属性值内的变量插值</li></ul><pre class="ny nz oa ob gt oe lw of og aw oh bi"><span id="08b9" class="nm ke iq lw b gy oi oj l ok ol">// NOT WORK<br/>&lt;img src='images/{this.props.image}'&gt;</span></pre><h2 id="fe1f" class="nm ke iq bd kf nn no dn kj np nq dp kn li nr ns kr lk nt nu kv lm nv nw kz nx bi translated">解决办法</h2><ol class=""><li id="daf0" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo ni lq lr ls bi translated">花括号内的JS表达式</li></ol><pre class="ny nz oa ob gt oe lw of og aw oh bi"><span id="49d8" class="nm ke iq lw b gy oi oj l ok ol">&lt;img src={'images/' + this.props.image}&gt;</span></pre><p id="3359" class="pw-post-body-paragraph mo mp iq ld b le mq mr ms lg mt mu mv li mw mx my lk mz na nb lm nc nd ne lo ij bi translated">2.模板字符串</p><pre class="ny nz oa ob gt oe lw of og aw oh bi"><span id="05dc" class="nm ke iq lw b gy oi oj l ok ol">&lt;img src={`images/${this.props.image}`}&gt;</span></pre></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="3a13" class="kd ke iq bd kf kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la bi translated">33.什么是用形状反应原型数组</h1><ul class=""><li id="b2d7" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如果你想将一个对象数组传递给一个具有特定形状的组件，那么使用<code class="fe lt lu lv lw b">React.PropTypes.shape()</code>作为<code class="fe lt lu lv lw b">React.PropTypes.arrayOf()</code>的参数</li></ul></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><blockquote class="om"><p id="85da" class="on oo iq bd op oq or os ot ou ov lo dk translated">感谢您的阅读，并希望您在事业上取得成功</p></blockquote><figure class="ox oy oz pa pb jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/6d23722524894cd36df0b714175dc200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*62SvUKh6csJkys1_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">bruce mars</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>