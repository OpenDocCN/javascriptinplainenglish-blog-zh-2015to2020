<html>
<head>
<title>React useRef can be used for more than you think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React useRef可以用的比你想象的多</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-useref-can-be-used-for-more-than-you-think-d4cfe7d90797?source=collection_archive---------1-----------------------#2020-11-10">https://javascript.plainenglish.io/react-useref-can-be-used-for-more-than-you-think-d4cfe7d90797?source=collection_archive---------1-----------------------#2020-11-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f1126c881068da048074f408327c0471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RXvb2xbfJzIhL1L6"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@tata186?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tatiana Rodriguez</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d478" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能已经使用了<em class="ky"> useRef </em>钩子来访问DOM节点。</p><p id="9311" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在<strong class="kc io"> <em class="ky"> ref </em> </strong>上搜索文章，这是你能找到的最常见的例子</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="8cbc" class="li lj in le b gy lk ll l lm ln">import React, { Component, createRef } from "react";                                               class CustomTextInput extends Component {                             </span><span id="7453" class="li lj in le b gy lo ll l lm ln"> textInput = createRef();                                                     </span><span id="b3f3" class="li lj in le b gy lo ll l lm ln"> focusTextInput = () =&gt; this.textInput.current.focus();                                                 </span><span id="d7fe" class="li lj in le b gy lo ll l lm ln"> render() {                          <br/>  return (                    <br/>    &lt;&gt;                                 <br/>   &lt;input type="text" ref={this.textInput} /&gt;                               &lt;button onClick={this.focusTextInput}&gt;Focus the text input&lt;/button&gt;                             &lt;/&gt;                         <br/>  );                 <br/>        }                    <br/>}</span></pre><p id="2b3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子展示了如果你有一个类组件，你将如何使用refs。</p><p id="d4a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您正在使用功能组件，这是您将采取的方法来实现同样的事情，</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="7a9c" class="li lj in le b gy lk ll l lm ln">function TextInputWithFocusButton() {<br/>  const inputEl = useRef(null);<br/>  const onButtonClick = () =&gt; {<br/>    // `current` points to the mounted text input element<br/>    inputEl.current.focus();<br/>  };<br/>  return (<br/>    &lt;&gt;<br/>      &lt;input ref={inputEl} type="text" /&gt;<br/>      &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="e30e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">useRef 钩子的另一个常见用法是当你想获取表单中的输入时，就像这样，</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="01f3" class="li lj in le b gy lk ll l lm ln">function Nameform {<br/>  <br/>    <br/>  const inputEl = useRef(null);  <br/><br/>  const handleSubmit=(event)=&gt; {<br/>    alert('A name was submitted: ' + inputEl.current.value);             </span><span id="9e52" class="li lj in le b gy lo ll l lm ln">    event.preventDefault();<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;form onSubmit={handleSubmit}&gt;<br/>        &lt;label&gt;<br/>          Name:<br/>          &lt;input type="text" ref={inputEl} /&gt;        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span></pre><blockquote class="lp lq lr"><p id="74ec" class="ka kb ky kc b kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw kx ig bi translated">但是，refs的相同属性不仅可以用于存储DOM引用。</p></blockquote><p id="7205" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将提供两个代码示例，演示如何使用<em class="ky">引用</em>，这可能有助于更好地理解<em class="ky">引用</em>。</p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><h2 id="fdd4" class="li lj in bd mc md me dn mf mg mh dp mi kl mj mk ml kp mm mn mo kt mp mq mr ms bi translated">示例1</h2><p id="5972" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">想象一下这样一个场景，当安装了一个特定的组件时，我们需要以特定的时间间隔向控制台记录一些东西。让我先在一个类组件中这样做，</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="8d81" class="li lj in le b gy lk ll l lm ln"><strong class="le io">class</strong> App <strong class="le io">extends</strong> React.Component{</span><span id="6949" class="li lj in le b gy lo ll l lm ln"><strong class="le io">constructor</strong>(props){</span><span id="d3b3" class="li lj in le b gy lo ll l lm ln">super();</span><span id="3029" class="li lj in le b gy lo ll l lm ln">this.interval=null;</span><span id="4ebd" class="li lj in le b gy lo ll l lm ln">this.state=true;</span><span id="eedd" class="li lj in le b gy lo ll l lm ln">}</span><span id="78d7" class="li lj in le b gy lo ll l lm ln">componentDidMount(){</span><span id="df6f" class="li lj in le b gy lo ll l lm ln">this.interval=setInterval(()<strong class="le io">=&gt;</strong>{</span><span id="b5b8" class="li lj in le b gy lo ll l lm ln">console.log("This is a log");</span><span id="2378" class="li lj in le b gy lo ll l lm ln">},2000)</span><span id="f06d" class="li lj in le b gy lo ll l lm ln">}</span><span id="3c24" class="li lj in le b gy lo ll l lm ln">handleCancel=()<strong class="le io">=&gt;</strong>{</span><span id="f0d2" class="li lj in le b gy lo ll l lm ln">clearInterval(this.interval);</span><span id="e7a0" class="li lj in le b gy lo ll l lm ln">}</span><span id="9a56" class="li lj in le b gy lo ll l lm ln">handleToggle=()<strong class="le io">=&gt;</strong>{</span><span id="5588" class="li lj in le b gy lo ll l lm ln">this.setState(()<strong class="le io">=&gt;</strong>{</span><span id="9a20" class="li lj in le b gy lo ll l lm ln">return !this.state</span><span id="3506" class="li lj in le b gy lo ll l lm ln">});</span><span id="e272" class="li lj in le b gy lo ll l lm ln">}</span><span id="0b20" class="li lj in le b gy lo ll l lm ln">render() {</span><span id="2ef1" class="li lj in le b gy lo ll l lm ln">console.log("App rendered");</span><span id="dfb4" class="li lj in le b gy lo ll l lm ln">return &lt;&gt;</span><span id="47cb" class="li lj in le b gy lo ll l lm ln">&lt;h1&gt;Hello&lt;/h1&gt;</span><span id="ecb2" class="li lj in le b gy lo ll l lm ln">&lt;button onClick={this.handleCancel}&gt;Cancel Timer&lt;/button&gt;</span><span id="b581" class="li lj in le b gy lo ll l lm ln">&lt;button onClick={this.handleToggle}&gt;Toggle State&lt;/button&gt;</span><span id="819e" class="li lj in le b gy lo ll l lm ln">&lt;/&gt;;</span><span id="74aa" class="li lj in le b gy lo ll l lm ln">}</span><span id="1b38" class="li lj in le b gy lo ll l lm ln">}</span></pre><p id="3c7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将计时器存储在一个<strong class="kc io"> <em class="ky">实例变量</em> </strong>中。我们也可以在状态中存储计时器，但这会导致额外的渲染。我们不想那样。</p><p id="6a94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们想在一个功能组件中这样做，你将如何存储定时器？在功能组件中，我们没有实例变量。</p><blockquote class="my"><p id="4e78" class="mz na in bd nb nc nd ne nf ng nh kx dk translated">useRef来救援</p></blockquote><pre class="ni nj nk nl nm ld le lf lg aw lh bi"><span id="e275" class="li lj in le b gy lk ll l lm ln"><strong class="le io">function</strong> App() {</span><span id="e163" class="li lj in le b gy lo ll l lm ln">console.log("App rendered");</span><span id="301b" class="li lj in le b gy lo ll l lm ln"><strong class="le io">const</strong> [state, toggle] = useState(true);</span><span id="8029" class="li lj in le b gy lo ll l lm ln"><strong class="le io">const</strong> intervalRef = useRef();</span><span id="50ac" class="li lj in le b gy lo ll l lm ln">useEffect(() <strong class="le io">=&gt;</strong> {</span><span id="c070" class="li lj in le b gy lo ll l lm ln"><strong class="le io"> const</strong> id = setInterval(() <strong class="le io">=&gt;</strong> {</span><span id="ec48" class="li lj in le b gy lo ll l lm ln">   console.log("This is a log")</span><span id="7c04" class="li lj in le b gy lo ll l lm ln">  },2000);</span><span id="0dff" class="li lj in le b gy lo ll l lm ln"> intervalRef.current = id;</span><span id="e9bd" class="li lj in le b gy lo ll l lm ln"> return () <strong class="le io">=&gt;</strong> {</span><span id="775c" class="li lj in le b gy lo ll l lm ln">  clearInterval(intervalRef.current);</span><span id="bdc1" class="li lj in le b gy lo ll l lm ln"> };</span><span id="87cd" class="li lj in le b gy lo ll l lm ln">},[]);</span><span id="02ae" class="li lj in le b gy lo ll l lm ln">function handleClick(){</span><span id="337d" class="li lj in le b gy lo ll l lm ln"> clearInterval(intervalRef.current);</span><span id="8c88" class="li lj in le b gy lo ll l lm ln">}</span><span id="a5ce" class="li lj in le b gy lo ll l lm ln">return (</span><span id="b5f5" class="li lj in le b gy lo ll l lm ln"> &lt;div&gt;</span><span id="82c2" class="li lj in le b gy lo ll l lm ln"> &lt;button onClick={handleClick}&gt;Cancel Timer&lt;/button&gt;</span><span id="1105" class="li lj in le b gy lo ll l lm ln"> &lt;button onClick={()<strong class="le io">=&gt;</strong>{ toggle(!state)}}&gt;Toggle&lt;/button&gt;</span><span id="b8aa" class="li lj in le b gy lo ll l lm ln"> &lt;/div&gt;<br/>)</span></pre><p id="9f71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，<em class="ky"> intervalRef </em>的行为就像一个实例变量。</p><p id="4d04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在想为什么我们不得不使用一个引用而不仅仅是一个局部变量，记住没有函数组件的<em class="ky">实例</em>，所以在下一次重新渲染时，先前与函数相关的数据会丢失。</p><p id="a854" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管如此，我还是要说，你做这样的事可能不会受到惩罚，</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="2560" class="li lj in le b gy lk ll l lm ln">let interval=null;<br/>function App(){</span><span id="2f6a" class="li lj in le b gy lo ll l lm ln">  // ...<br/> <br/> function handleClick(){</span><span id="576b" class="li lj in le b gy lo ll l lm ln">   clearInterval(interval);</span><span id="e655" class="li lj in le b gy lo ll l lm ln"> }</span><span id="c805" class="li lj in le b gy lo ll l lm ln">}</span></pre><p id="6c22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，将计时器引用存储在功能组件外部声明的变量中。</p><p id="2b84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，这显然不是一个好的解决方案，不推荐使用。因为，首先，如果你不止一次的渲染同一个组件，这将会中断。</p><p id="e3bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nn no np le b"><em class="ky">useRef</em></code> <em class="ky">返回一个可变ref对象，其</em> <code class="fe nn no np le b"><em class="ky">.current</em></code> <em class="ky">属性初始化为传递的参数(</em> <code class="fe nn no np le b"><em class="ky">initialValue</em></code> <em class="ky">)。返回的对象将在组件的整个生命周期内保持不变—</em><strong class="kc io"><em class="ky">React Docs</em></strong><em class="ky">。</em></p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><h2 id="a1d3" class="li lj in bd mc md me dn mf mg mh dp mi kl mj mk ml kp mm mn mo kt mp mq mr ms bi translated">示例2</h2><p id="f4c8" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">考虑这样一个场景，除了第一次(初始)渲染，你需要在每次渲染后对组件执行一些副作用。</p><p id="f2d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个类组件中，这就像使用<strong class="kc io"> componentDidUpdate </strong>生命周期方法一样简单，因为在组件挂载时不会调用它。</p><p id="08b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，在一个功能组件中，我们有一个useEffect来应用副作用，做一些类似于，</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="9ab6" class="li lj in le b gy lk ll l lm ln"><br/>  useEffect(() =&gt; {<br/>   // do something<br/>  })</span></pre><p id="1bb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将在每次渲染时执行，不会起作用(因为效果将在初始渲染后执行)。</p><p id="3b6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，<em class="ky"> useRef </em>再一次出手相救！</p><p id="00e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以这样做，</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="ccfb" class="li lj in le b gy lk ll l lm ln">const hasMounted= useRef(false)</span><span id="1786" class="li lj in le b gy lo ll l lm ln">useEffect(() =&gt; {<br/>    if (hasMounted.current) {<br/>      // do something<br/>    } else hasMounted.current = true<br/>  }</span></pre><p id="a496" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么会这样？我想我在前面的例子中已经提到过:)</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/38df599f1bbb35e346581a27e292b5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*BLe6tbTjTYH2mPmEtc-jMg.gif"/></div></figure><p id="889f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>