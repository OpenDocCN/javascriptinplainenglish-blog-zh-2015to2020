<html>
<head>
<title>How to RxJS — The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何应对——基础知识</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-rxjs-the-basics-d5a5905497e0?source=collection_archive---------6-----------------------#2020-03-10">https://javascript.plainenglish.io/how-to-rxjs-the-basics-d5a5905497e0?source=collection_archive---------6-----------------------#2020-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a134" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">RxJS构建的基本概念是什么？</h2></div><p id="0c3c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将学习观察者模式、函数式编程的基础知识，然后学习RxJS的基础知识。</p><h1 id="21a0" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">Rx的基础</h1><p id="50c9" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">反应式扩展基于几个基础，即它所基于的基本概念。在我们深入探讨之前，我想强调其中的一些。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/f1a8763be12063caddd593d734f03cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*w7xq72JdMch0lkmj5VXkHQ.jpeg"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Image by <a class="ae mh" href="https://pixabay.com/users/PIX1861-468748/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=668100" rel="noopener ugc nofollow" target="_blank">Csaba Nagy</a> from <a class="ae mh" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=668100" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h1 id="0792" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">观察者模式</h1><p id="34f3" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">观察者模式是一种设计模式，Rx“简单地”实现它。因为这种模式是Rx的主要基石之一，所以我想稍微谈一下。</p><p id="184f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">幸运的是，我们可以在维基百科上找到这个模式的很好的定义。</p><blockquote class="mi"><p id="a5d7" class="mj mk in bd ml mm mn mo mp mq mr kx dk translated">观察者模式是一种软件设计模式，在这种模式中，一个名为subject的对象维护一个名为observer的依赖者列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。</p></blockquote><p id="7bf5" class="pw-post-body-paragraph kc kd in ke b kf ms jo kh ki mt jr kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">所以基本上我们有想要观察的东西。我们希望在<em class="mx">发生变化时得到通知。</em>假设我们有一个按钮，我们想监听它的点击事件。解决方案很简单，你可能会说，“只需监听点击事件，并对其进行回调”。当然，这很容易，但是如果在我们的系统中，我们将这个点击与某个更高层次的事件联系起来呢？以一个登录表单为例，该表单上有一个submit按钮，它将尝试使用给定的信息对用户进行身份验证。之后，您将把用户导航到其他页面，这样他/她就可以使用您出色的应用程序。然而，在这个应用程序中，我们需要获得用户对象，它包含了用户的基本信息。在本例中，您可以看到，一个基本的点击事件现在对应于一个更高级别的“登录事件”。您的应用程序中会有几个部分对这个事件感兴趣，比如您的路线上的警卫，或者显示用户信息的组件，或者可能希望在用户向服务器发出授权用户的每个请求时发送一些userID或一些令牌的服务。</p><p id="4ad6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这仍然很容易，因为您可以创建一个服务，它可以存储用户对象，也可以将它提供给应用程序中其他感兴趣的组件。</p><p id="cb55" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在这个令牌部分再深入一点。令牌通常会及时过期。当然，通常情况下，你有方法获得一个新的令牌，但是让我们先把它放在一边。当这个令牌变得无用时，您应该通知应用程序的不同部分，使用这个令牌的用户现在没有通过身份验证。因此，您需要注销用户。这就是观察者模式派上用场的地方。你可以创建一个主题，其他组件可能会感兴趣。该主题将包含当前活动的用户对象，在登录时，您可以简单地<strong class="ke io">发出</strong>已登录的用户对象。你的应用程序的其他部分可以并且可能会让<strong class="ke io">订阅</strong>这个主题。这些<strong class="ke io">观察者</strong>会在这种变化发生时得到通知，他们可以按照自己认为合适的方式采取行动。</p><h1 id="6af9" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">函数式编程</h1><p id="b6c7" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">我想讲的另一个重要部分是函数式编程。我不想深入这个话题，因为我们可以为这个话题写一系列不同的文章。我只是喜欢浏览基础知识，让读者更深入地发现它。</p><p id="f8cb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，看看这个范例的定义，我们也可以查看维基百科。</p><blockquote class="mi"><p id="8680" class="mj mk in bd ml mm mn mo mp mq mr kx dk translated">函数式编程是一种编程范式——一种构建计算机程序的结构和元素的风格——将计算视为数学函数的评估，并避免改变状态和可变数据。它是一种声明式编程范式，因为编程是用表达式或声明而不是语句来完成的。</p></blockquote><p id="8008" class="pw-post-body-paragraph kc kd in ke b kf ms jo kh ki mt jr kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">所以基本上我们写我们的函数，就像你们在高中看到的数学函数一样。例如:`<em class="mx"> f(g(x))` </em>这个表达式说明我们做‘g’，然后对‘g’的结果我们运行‘f’。所以<strong class="ke io">我们在陈述我们做什么</strong>而不是我们将如何去做。命令可能是这样的:</p><ul class=""><li id="92d5" class="my mz in ke b kf kg ki kj kl na kp nb kt nc kx nd ne nf ng bi translated">取x，并计算其值的平方</li><li id="de27" class="my mz in ke b kf nh ki ni kl nj kp nk kt nl kx nd ne nf ng bi translated">给定x的平方，求反</li></ul><p id="0198" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以<strong class="ke io">我们在陈述我们是如何进行</strong>计算的。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/4ca92f9684fdde0e77aeb96d83253f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ldyJQVJl2HD7TKCik5Q2dw.jpeg"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Photo by <a class="ae mh" href="https://www.pexels.com/@lastly?utm_content=attributionCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Tyler Lastovich</a> from <a class="ae mh" href="https://www.pexels.com/photo/underwater-photography-of-clear-water-590178/?utm_content=attributionCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="ea0d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如定义所述，这种范式有两个基石。其中之一是<em class="mx">避免改变状态。</em>我们可以通过所谓的<em class="mx">纯函数</em>来实现这一点。纯函数是一个不会产生任何副作用的函数，并且只依赖于给它的参数，而不依赖于其他全局对象。简单地说，一个纯函数将:</p><ul class=""><li id="9335" class="my mz in ke b kf kg ki kj kl na kp nb kt nc kx nd ne nf ng bi translated">如果给定相同的参数，总是返回相同的结果</li><li id="ba17" class="my mz in ke b kf nh ki ni kl nj kp nk kt nl kx nd ne nf ng bi translated">不会引起任何可观察到的副作用，只是通过调用它</li></ul><p id="cfa3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个是<em class="mx">避免可变数据</em>，这很简单，只是意味着你不能在对象创建后改变它的状态。相反，您需要用新值创建另一个对象。我们称这类对象为不可变对象。</p><p id="359c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数式编程中还经常使用许多其他的技术，比如高阶函数、闭包等等。但是正如我所说的，本文的目的并不是要涵盖这些主题。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6712e3f2c8a172563b74fc07cc9e7b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*QyaJfLoqvop61tsXqinKaQ.png"/></div></figure><h1 id="5856" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">RxJS</h1><p id="4ebd" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">好了，现在我们完成了基本的，让我们继续。首先，引用RxJS的概述:</p><blockquote class="nu nv nw"><p id="35c5" class="kc kd mx ke b kf kg jo kh ki kj jr kk nx km kn ko ny kq kr ks nz ku kv kw kx ig bi translated">RxJS是一个库，用于通过使用可观察序列来编写异步和基于事件的程序。它提供了一个核心类型，即可观察类型、附属类型(观察者、调度器、主题)和受Array#extras(映射、过滤、减少、每等)启发的操作符，以允许将异步事件作为集合进行处理。</p></blockquote><p id="fd99" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以基本上，在Rx中，你是用异步数据流编程的。您可以将每个用户交互想象成一系列事件。您可以处理该流发出的每个项目，在本例中就是事件本身。如果我们更进一步，我们还会注意到，甚至应用程序本身也可以被视为异步数据流。该数据流将发出不同的应用程序状态。这是Redux的主要概念，也可以是另一个主题。</p><p id="6c10" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们看看上面的定义，我们可以用一个简单的矩阵来说明Rx与承诺和数组处理的关系:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="823d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们来过一遍RxJS的核心概念。正如定义中提到的，整个库的基础是<em class="mx"> `Observable` </em>。可观察类是Rx中的异步数据流类型，它只能用于订阅更改。通过这种观察，<strong class="ke io">用户</strong>将被通知新的数据、新的变化，并可以对其采取行动。你可以把这些可观察的东西想象成只读的装配线，你只能<em class="mx">观察</em>新的物品，但是你不能直接把新的物品推进这条装配线。</p><p id="82af" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，你不会直接与观察者互动，你会用一个主语来代替，但由于这是Rx和可观察模式的核心元素，你应该知道它们到底是什么。观察器允许您将数据推送到观察器，从而通知订阅者关于一个变化，一个新项目。如果你用关键字<em class="mx"> `new` </em>创建一个可观察对象，你可以看看它是如何工作的。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="a57e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Rx的下一个核心类型是<strong class="ke io">主体</strong>。简单来说，你可以把主体看成既是可观察对象，又是观察者。其实在RxJS源码内部，也可以看到主体直接实现了这两个接口。所以，你可以把主题想象成读写流水线，在那里你可以放入新的项目，也可以<em class="mx">观察</em>新的项目，变化。</p><h1 id="bc8c" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">大理石</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/93702857c66e6b964866cb454af717f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*SqtoW3FAdI-oEfRXlS1ang.jpeg"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Image by <a class="ae mh" href="https://pixabay.com/users/Couleur-1195798/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1659398" rel="noopener ugc nofollow" target="_blank">Couleur</a> from <a class="ae mh" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1659398" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="6db6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为作为一个刚开始学习Rx的开发人员，主要的工作是阅读关于操作符的文档，所以让我们看看如何阅读RxJS文档的重要部分marbles。</p><blockquote class="nu nv nw"><p id="7345" class="kc kd mx ke b kf kg jo kh ki kj jr kk nx km kn ko ny kq kr ks nz ku kv kw kx ig bi translated">为了解释操作符是如何工作的，文本描述通常是不够的。许多操作符与时间有关，例如，它们可能以不同方式延迟、采样、节流或去抖值发射。图表通常是更好的工具。大理石图是运算符如何工作的可视化表示，包括输入可观察值、运算符及其参数以及输出可观察值。</p></blockquote><p id="7155" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解释弹球图，让我从RxJS的文档中加入弹球图的定义和例子。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/ac445741abbc80d213f22182aedad21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*nAdYI6Bp8sPUdfZSXqu1eQ.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Image from <a class="ae mh" href="https://rxjs-dev.firebaseapp.com/guide/operators" rel="noopener ugc nofollow" target="_blank">RxJS’ documentation</a></figcaption></figure><p id="bf94" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个算子处理一个或一组可观测量，并产生一个输出可观测量。在图的顶部，你可以看到输入的可观测值，这条线代表从可观测值开始到结束的时间。一个可观察的完成由一条与时间线成对角线的线来表示。小圆圈(弹珠)是被观察物发出的单个项目。</p><p id="741d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输入和输出观察值之间的方框代表操作符本身，其中的文本显示了该操作符完成的转换的性质。</p><p id="f53e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">时间线上的“X”表示可观察对象发出的错误。此后将不再提供更多的价值。</p><h1 id="4271" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">可观察到的和承诺的区别</h1><p id="8e7c" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">既然我们说承诺和观察都是处理异步任务，您可能想知道它们之间有什么区别。所以让我们快速浏览一遍。我把它们总结成一个表格，你很容易掌握。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="3c68" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">总结一下</h1><p id="4ea4" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">如你所见，Rx和RxJS的核心只是实现了一些基本的想法。实现本身要复杂得多，但是核心概念非常简单。你需要掌握这些来完全理解RxJS。</p></div></div>    
</body>
</html>