<html>
<head>
<title>More Rxjs Transformation Operators — mergeScan and Pluck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多Rxjs变换运算符—合并扫描和选取</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/more-rxjs-transformation-operators-mergescan-and-pluck-2f09510abef?source=collection_archive---------6-----------------------#2020-02-12">https://javascript.plainenglish.io/more-rxjs-transformation-operators-mergescan-and-pluck-2f09510abef?source=collection_archive---------6-----------------------#2020-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/726b1f1ecdd41f839ac9c101f23fbf52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1dGRDHDqqIx7oTBa"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@xoutcastx?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Taylor</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dd2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="1fde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看一些转换操作符，如<code class="fe lb lc ld le b">mergeScan</code>、<code class="fe lb lc ld le b">pairwise</code>、<code class="fe lb lc ld le b">partition</code>和<code class="fe lb lc ld le b">pluck</code>操作符。</p><h1 id="b863" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">合并扫描</h1><p id="5ce3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">mergeScan</code>运算符对源可观测值应用累加器函数，累加器函数本身返回一个可观测值，返回的每个中间可观测值被合并到输出可观测值中。</p><p id="960a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最多需要3个参数。第一个是对每个源值调用的累加器函数。</p><p id="b786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是<code class="fe lb lc ld le b">seed</code>参数，取初始累加值。</p><p id="7892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数是可选参数，它采用了要同时订阅的最大数量的<code class="fe lb lc ld le b">concurrent</code>输入观察值。</p><p id="806d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3a69" class="mq lg iq le b gy mr ms l mt mu">import { of, interval } from "rxjs";<br/>import { mapTo, mergeScan } from "rxjs/operators";</span><span id="7feb" class="mq lg iq le b gy mv ms l mt mu">const interval$ = interval(5000);<br/>const one$ = interval$.pipe(mapTo(1));<br/>const seed = 0;<br/>const count$ = one$.pipe(mergeScan((acc, one) =&gt; of(acc + one), seed));<br/>count$.subscribe(x =&gt; console.log(x));</span></pre><p id="801e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有<code class="fe lb lc ld le b">interval$</code>可观察值，它通过<code class="fe lb lc ld le b">mapTo</code>操作符映射到值1。然后我们将<code class="fe lb lc ld le b">seed</code>初始值设为0。</p><p id="aaf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过<code class="fe lb lc ld le b">mergeScan</code>操作符将<code class="fe lb lc ld le b">interval$</code>可观测值的发出值发送给累加器函数，当<code class="fe lb lc ld le b">interval$</code>的值发出时，累加器函数一直加1。然后，当我们订阅<code class="fe lb lc ld le b">count$</code>时，我们从<code class="fe lb lc ld le b">$count</code>获取发出的号码。</p><h1 id="9ebb" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">成对地</h1><p id="25b4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">pairwise</code>将来自可观测源的成对连续发射组合在一起，然后将它们作为数组2值发射。</p><p id="10f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要争论。</p><p id="60ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以在下面的示例中使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="5e45" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { pairwise } from "rxjs/operators";</span><span id="03c5" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3, 4, 5, 6);<br/>const pair$ = of$.pipe(pairwise());<br/>pair$.subscribe(x =&gt; console.log(x));</span></pre><p id="43c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将把从<code class="fe lb lc ld le b">of$</code>可观察值发出的值分组成对，然后用<code class="fe lb lc ld le b">pairwise()</code>操作符发出这些值。然后我们从<code class="fe lb lc ld le b">console.log</code>得到以下输出:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="be48" class="mq lg iq le b gy mr ms l mt mu">[1, 2]<br/>[2, 3]<br/>[3, 4]<br/>[4, 5]<br/>[5, 6]</span></pre><h1 id="29c3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">划分</h1><p id="3aff" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">partition</code>操作符将源可观察对象分成两部分，其中一部分的值满足谓词，另一部分的值不满足谓词。</p><p id="0d20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多需要两个参数。第一个是<code class="fe lb lc ld le b">predicate</code>，这是一个评估源可观测值发出的每个值的函数。然后如果函数返回<code class="fe lb lc ld le b">true</code>，那么在第一个返回上发出的值在发出的数组中可观察到。否则，它会在第二个可观察到的数组中发出。</p><p id="0bdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是<code class="fe lb lc ld le b">thisArg</code>，它让我们在谓词函数中设置<code class="fe lb lc ld le b">this</code>的值。</p><p id="ac30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8aa1" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { partition } from "rxjs/operators";</span><span id="f0ef" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);<br/>const parts = of$.pipe(partition(x =&gt; x % 2 === 0));<br/>const [even, odd] = parts;<br/>odd.subscribe(x =&gt; console.log(`odd numbers: ${x}`));<br/>even.subscribe(x =&gt; console.log(`even numbers: ${x}`));</span></pre><p id="9efe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用一些数字观察到了<code class="fe lb lc ld le b">of$</code>。然后我们<code class="fe lb lc ld le b">pipe</code>将它放入<code class="fe lb lc ld le b">partition</code>操作符中，该操作符采用一个谓词函数来检查从<code class="fe lb lc ld le b">of$</code>可观察对象发出的数字是否为偶数。</p><p id="7567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">parts</code>将被设置为从<code class="fe lb lc ld le b">partition</code>操作器返回的2个可观测量。<code class="fe lb lc ld le b">even</code>可观察对象发射<code class="fe lb lc ld le b">even</code>号，而<code class="fe lb lc ld le b">odd</code>可观察对象发射奇数号。</p><p id="44b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们从<code class="fe lb lc ld le b">odd</code>可观察值中获得以下输出:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1828" class="mq lg iq le b gy mr ms l mt mu">odd numbers: 1<br/>odd numbers: 3<br/>odd numbers: 5<br/>odd numbers: 7<br/>odd numbers: 9</span></pre><p id="87df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们从<code class="fe lb lc ld le b">even</code>可观察值中得到以下输出:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b13a" class="mq lg iq le b gy mr ms l mt mu">even numbers: 2<br/>even numbers: 4<br/>even numbers: 6<br/>even numbers: 8<br/>even numbers: 10</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/22779d2eced90f8b4000a09655e50eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XfhREVAc4Hfl0dm-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thomasborowski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Thomas Borowski</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="847b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">勇气</h1><p id="9c7e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">pluck</code>操作符将每个从源可观察对象发出的值映射到其指定的嵌套属性。</p><p id="f73d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个参数，即<code class="fe lb lc ld le b">properties</code>对象，这是从每个源值中提取的嵌套属性。</p><p id="6768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="afb2" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { pluck } from "rxjs/operators";</span><span id="e04b" class="mq lg iq le b gy mv ms l mt mu">const people = [<br/>  { name: { firstName: "Mary" }, age: 10, gender: "female" },<br/>  { name: { firstName: "Joe" }, age: 11, gender: "male" },<br/>  { name: { firstName: "Amy" }, age: 10, gender: "female" }<br/>];<br/>const people$ = of(...people);<br/>const plucked = people$.pipe(pluck("name", "firstName"));<br/>plucked.subscribe(x =&gt; console.log(x));</span></pre><p id="ea49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有一个<code class="fe lb lc ld le b">people</code>数组，其中每个条目都有一个<code class="fe lb lc ld le b">name</code>对象。我们用<code class="fe lb lc ld le b">of</code>操作符发出值，然后用<code class="fe lb lc ld le b">pipe</code>发出值，并使用<code class="fe lb lc ld le b">pluck</code>获得嵌套属性<code class="fe lb lc ld le b">firstName</code>，它在<code class="fe lb lc ld le b">name</code>内部。</p><p id="d829" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4bd1" class="mq lg iq le b gy mr ms l mt mu">Mary<br/>Joe<br/>Amy</span></pre><p id="75bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为最后一行的输出。</p><p id="b143" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">mergeScan</code>对源可观察值应用累加器函数，累加器函数本身返回一个可观察值。然后将返回的每个中间可观测值合并到输出可观测值中，一起发出。</p><p id="5ed1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">pairwise</code>将来自可观测源的成对连续发射组合在一起，然后将它们作为数组2值发射。</p><p id="2f09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">partition</code>操作符将源可观察对象分成两部分，其中一部分的值满足谓词函数返回的条件，另一部分的值不满足。</p><p id="30e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">pluck</code>操作符将每个从源可观察对象发出的值映射到指定嵌套属性的值。</p></div></div>    
</body>
</html>