<html>
<head>
<title>Build File Upload/Download Functionality with Image Preview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立带有图像预览的文件上传/下载功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implement-file-upload-and-download-functionality-using-mern-stack-with-image-preview-685bb989f4e8?source=collection_archive---------1-----------------------#2020-10-09">https://javascript.plainenglish.io/implement-file-upload-and-download-functionality-using-mern-stack-with-image-preview-685bb989f4e8?source=collection_archive---------1-----------------------#2020-10-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8f2c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">并学习如何添加拖放功能来上传任何类型文件</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/6df9640932a648ee3c8a9ac2757361b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/1*RnvuuipR3YKvvGqBX88L3Q.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">File Upload</figcaption></figure><h1 id="c0fc" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="23d3" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在本文中，我们将创建一个文件上传和下载功能，并使用MERN堆栈预览图像。</p><p id="e43a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">通过创建此应用程序，您将了解到</p><ul class=""><li id="94d7" class="mh mi in li b lj mc lm md lp mj lt mk lx ml mb mm mn mo mp bi translated">如何使用拖放上传文件</li><li id="169c" class="mh mi in li b lj mq lm mr lp ms lt mt lx mu mb mm mn mo mp bi translated">如何上传和下载任何类型的文件</li><li id="14ff" class="mh mi in li b lj mq lm mr lp ms lt mt lx mu mb mm mn mo mp bi translated">如何在上传时限制文件的类型</li><li id="fc7f" class="mh mi in li b lj mq lm mr lp ms lt mt lx mu mb mm mn mo mp bi translated">如何在上传时限制文件的大小</li><li id="2966" class="mh mi in li b lj mq lm mr lp ms lt mt lx mu mb mm mn mo mp bi translated">如何在选择图像后显示预览</li><li id="1891" class="mh mi in li b lj mq lm mr lp ms lt mt lx mu mb mm mn mo mp bi translated">如何使用MongoDB存储和获取文件的细节</li></ul><p id="7382" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">还有更多。</p><blockquote class="mv mw mx"><p id="805c" class="lg lh my li b lj mc jo ll lm md jr lo mz me lr ls na mf lv lw nb mg lz ma mb ig bi translated"><em class="in">我们不是将文件以base64编码的形式存储在MongoDB数据库中，而是将文件存储在服务器上，并且只存储文件在数据库中的路径，以保持数据库较小，并根据需要轻松访问和移动文件。</em></p></blockquote><p id="3063" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们使用一个非常流行的<a class="ae nc" href="https://www.npmjs.com/package/react-dropzone" rel="noopener ugc nofollow" target="_blank"> react-dropzone </a> npm库来实现拖放功能。</p><p id="de3f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">对于实际的文件上传，我们使用的是非常流行的npm库。</p><p id="2e1f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们将使用React Hooks来构建这个应用程序，所以如果您不熟悉它，请查看我以前的文章<a class="ae nc" href="https://levelup.gitconnected.com/an-introduction-to-react-hooks-50281fd961fe?source=friends_link&amp;sk=89baff89ec8bc637e7c13b7554904e54" rel="noopener ugc nofollow" target="_blank">这里</a>是关于Hooks的介绍。</p><p id="19ff" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们将使用<code class="fe nd ne nf ng b">MongoDB</code>数据库，所以请确保您按照我之前的文章<a class="ae nc" href="https://levelup.gitconnected.com/how-to-install-mongodb-database-on-local-environment-19a8a76f1b92?source=friends_link&amp;sk=416b443bad1f86b292e4b72602cf5c9b" rel="noopener ugc nofollow" target="_blank">在这里</a>安装它</p><h1 id="be90" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">初始设置</h1><p id="fa22" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">使用<code class="fe nd ne nf ng b">create-react-app</code>创建一个新项目</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="de6d" class="nl kp in ng b gy nm nn l no np">create-react-app react-upload-download-files</span></pre><p id="a54b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">项目创建完成后，删除<code class="fe nd ne nf ng b">src</code>文件夹中的所有文件，在<code class="fe nd ne nf ng b">src</code>文件夹中创建<code class="fe nd ne nf ng b">index.js</code>和<code class="fe nd ne nf ng b">styles.scss</code>文件。同样，在<code class="fe nd ne nf ng b">src</code>文件夹中创建<code class="fe nd ne nf ng b">components</code>、<code class="fe nd ne nf ng b">router</code>和<code class="fe nd ne nf ng b">utils</code>文件夹。</p><p id="8a82" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">安装必要的依赖项:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="3fc8" class="nl kp in ng b gy nm nn l no np">yarn add axios@0.20.0 bootstrap@4.5.2 downloadjs@1.4.7 node-sass@4.14.1 react-bootstrap@1.3.0 react-dropzone@11.2.0 react-router-dom@5.2.0</span></pre><p id="6e85" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">打开<code class="fe nd ne nf ng b">styles.scss</code>，将<a class="ae nc" href="https://github.com/myogeshchavan97/react-upload-download-files/blob/master/src/styles.scss" rel="noopener ugc nofollow" target="_blank">这里</a>的内容加入其中。</p><h1 id="65bd" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">创建初始页面</h1><p id="a5df" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">components</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">Header.js</code>的新文件，内容如下:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="285d" class="nl kp in ng b gy nm nn l no np">import React from 'react';<br/>import { NavLink } from 'react-router-dom';</span><span id="2718" class="nl kp in ng b gy nq nn l no np">const Header = () =&gt; {<br/>  return (<br/>    &lt;div className="header"&gt;<br/>      &lt;h1&gt;File Upload And Download&lt;/h1&gt;<br/>      &lt;nav&gt;<br/>        &lt;NavLink activeClassName="active" to="/" exact={true}&gt;<br/>          Home<br/>        &lt;/NavLink&gt;<br/>        &lt;NavLink activeClassName="active" to="/list"&gt;<br/>          Files List<br/>        &lt;/NavLink&gt;<br/>      &lt;/nav&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="5646" class="nl kp in ng b gy nq nn l no np">export default Header;</span></pre><p id="5d0a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">components</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">App.js</code>的新文件，内容如下:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="b548" class="nl kp in ng b gy nm nn l no np">import React, { useState, useRef } from 'react';<br/>import { Form, Row, Col, Button } from 'react-bootstrap';</span><span id="a859" class="nl kp in ng b gy nq nn l no np">const App = (props) =&gt; {<br/>  const [file, setFile] = useState(null); // state for storing actual image<br/>  const [previewSrc, setPreviewSrc] = useState(''); // state for storing previewImage<br/>  const [state, setState] = useState({<br/>    title: '',<br/>    description: ''<br/>  });<br/>  const [errorMsg, setErrorMsg] = useState('');<br/>  const [isPreviewAvailable, setIsPreviewAvailable] = useState(false); // state to show preview only for images<br/>  const dropRef = useRef(); // React ref for managing the hover state of droppable area</span><span id="0e83" class="nl kp in ng b gy nq nn l no np">  const handleInputChange = (event) =&gt; {<br/>    setState({<br/>      ...state,<br/>      [event.target.name]: event.target.value<br/>    });<br/>  };</span><span id="c59b" class="nl kp in ng b gy nq nn l no np">  const handleOnSubmit = async (event) =&gt; {<br/>    event.preventDefault();<br/>  };</span><span id="6cb8" class="nl kp in ng b gy nq nn l no np">  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;Form className="search-form" onSubmit={handleOnSubmit}&gt;<br/>        {errorMsg &amp;&amp; &lt;p className="errorMsg"&gt;{errorMsg}&lt;/p&gt;}<br/>        &lt;Row&gt;<br/>          &lt;Col&gt;<br/>            &lt;Form.Group controlId="title"&gt;<br/>              &lt;Form.Control<br/>                type="text"<br/>                name="title"<br/>                value={state.title || ''}<br/>                placeholder="Enter title"<br/>                onChange={handleInputChange}<br/>              /&gt;<br/>            &lt;/Form.Group&gt;<br/>          &lt;/Col&gt;<br/>        &lt;/Row&gt;<br/>        &lt;Row&gt;<br/>          &lt;Col&gt;<br/>            &lt;Form.Group controlId="description"&gt;<br/>              &lt;Form.Control<br/>                type="text"<br/>                name="description"<br/>                value={state.description || ''}<br/>                placeholder="Enter description"<br/>                onChange={handleInputChange}<br/>              /&gt;<br/>            &lt;/Form.Group&gt;<br/>          &lt;/Col&gt;<br/>        &lt;/Row&gt;<br/>        &lt;Button variant="primary" type="submit"&gt;<br/>          Submit<br/>        &lt;/Button&gt;<br/>      &lt;/Form&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="20d7" class="nl kp in ng b gy nq nn l no np">export default App;</span></pre><p id="d38b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这个文件中，我们现在呈现一个表单来添加<code class="fe nd ne nf ng b">title</code>和<code class="fe nd ne nf ng b">description</code>。我们将在本文后面添加添加文件的选项。</p><p id="3ed7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">对于每个输入字段，我们添加了一个<code class="fe nd ne nf ng b">handleInputChange</code>处理程序来更新每个输入字段的状态。我们为每个输入字段添加了一个<code class="fe nd ne nf ng b">name</code>属性，它与状态变量的名称完全匹配，因此我们能够使用ES6速记语法来更新状态。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="ca00" class="nl kp in ng b gy nm nn l no np">const handleInputChange = (event) =&gt; {<br/>  setState({<br/>    ...state,<br/>    [event.target.name]: event.target.value<br/>  });<br/>};</span></pre><p id="a8e8" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在钩子的情况下，状态不会自动合并，所以我们首先扩展状态的所有属性，然后更新相应的输入字段。</p><p id="73ff" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">router</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">AppRouter.js</code>的新文件，内容如下:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="23c3" class="nl kp in ng b gy nm nn l no np">import React from 'react';<br/>import { BrowserRouter, Switch, Route } from 'react-router-dom';<br/>import App from '../components/App';<br/>import Header from '../components/Header';</span><span id="d203" class="nl kp in ng b gy nq nn l no np">const AppRouter = () =&gt; (<br/>  &lt;BrowserRouter&gt;<br/>    &lt;div className="container"&gt;<br/>      &lt;Header /&gt;<br/>      &lt;div className="main-content"&gt;<br/>        &lt;Switch&gt;<br/>          &lt;Route component={App} path="/" exact={true} /&gt;<br/>        &lt;/Switch&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/BrowserRouter&gt;<br/>);</span><span id="615a" class="nl kp in ng b gy nq nn l no np">export default AppRouter;</span></pre><p id="74e7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，打开<code class="fe nd ne nf ng b">src/index.js</code>文件，在里面添加以下内容:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="6f6a" class="nl kp in ng b gy nm nn l no np">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import AppRouter from './router/AppRouter';<br/>import 'bootstrap/dist/css/bootstrap.min.css';<br/>import './styles.scss';</span><span id="7992" class="nl kp in ng b gy nq nn l no np">ReactDOM.render(&lt;AppRouter /&gt;, document.getElementById('root'));</span></pre><p id="9ef6" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，从终端执行<code class="fe nd ne nf ng b">yarn start</code>命令启动应用程序。</p><p id="a863" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您将看到以下屏幕:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/df053963f189d7469f7726230c4611bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_twR-GVyp9RYxs1O.png"/></div></div></figure><h1 id="c698" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">添加文件上传功能</h1><p id="5221" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在，让我们添加从UI上传文件的选项。</p><p id="2f0b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">打开<code class="fe nd ne nf ng b">src/App.js</code>文件，在提交按钮之前和结束<code class="fe nd ne nf ng b">Row</code>标签之后，添加以下代码</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="7d32" class="nl kp in ng b gy nm nn l no np">&lt;div className="upload-section"&gt;<br/>  &lt;Dropzone onDrop={onDrop}&gt;<br/>    {({ getRootProps, getInputProps }) =&gt; (<br/>      &lt;div {...getRootProps({ className: 'drop-zone' })} ref={dropRef}&gt;<br/>        &lt;input {...getInputProps()} /&gt;<br/>        &lt;p&gt;Drag and drop a file OR click here to select a file&lt;/p&gt;<br/>        {file &amp;&amp; (<br/>          &lt;div&gt;<br/>            &lt;strong&gt;Selected file:&lt;/strong&gt; {file.name}<br/>          &lt;/div&gt;<br/>        )}<br/>      &lt;/div&gt;<br/>    )}<br/>  &lt;/Dropzone&gt;<br/>  {previewSrc ? (<br/>    isPreviewAvailable ? (<br/>      &lt;div className="image-preview"&gt;<br/>        &lt;img className="preview-image" src={previewSrc} alt="Preview" /&gt;<br/>      &lt;/div&gt;<br/>    ) : (<br/>      &lt;div className="preview-message"&gt;<br/>        &lt;p&gt;No preview available for this file&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  ) : (<br/>    &lt;div className="preview-message"&gt;<br/>      &lt;p&gt;Image preview will be shown here after selection&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  )}<br/>&lt;/div&gt;</span></pre><p id="8fbc" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里，我们使用带有React render props模式的<code class="fe nd ne nf ng b">DropZone</code>组件，我们需要在拖放区显示的文本被添加到<code class="fe nd ne nf ng b">DropZone</code>组件内的输入字段之后。</p><p id="fa02" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">App.js</code>文件的顶部添加<code class="fe nd ne nf ng b">DropZone</code>和<code class="fe nd ne nf ng b">axios</code>的导入。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="48be" class="nl kp in ng b gy nm nn l no np">import Dropzone from 'react-dropzone';<br/>import axios from 'axios';</span></pre><p id="4b99" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">handleInputChange</code>处理程序后增加<code class="fe nd ne nf ng b">OnDrop</code>功能。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="ce54" class="nl kp in ng b gy nm nn l no np">const onDrop = (files) =&gt; {<br/>  const [uploadedFile] = files;<br/>  setFile(uploadedFile);</span><span id="20da" class="nl kp in ng b gy nq nn l no np">  const fileReader = new FileReader();<br/>  fileReader.onload = () =&gt; {<br/>    setPreviewSrc(fileReader.result);<br/>  };<br/>  fileReader.readAsDataURL(uploadedFile);<br/>  setIsPreviewAvailable(uploadedFile.name.match(/\.(jpeg|jpg|png)$/));<br/>};</span></pre><p id="7bd5" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这里，<code class="fe nd ne nf ng b">onDrop</code>函数接收一个包含被删除或选中文件的文件数组。</p><p id="c0fa" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们一次只上传一个文件，所以上传的文件将是可用的文件[0]，所以我们使用数组析构语法来获取该文件值。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="3962" class="nl kp in ng b gy nm nn l no np">const [uploadedFile] = files;</span></pre><p id="5017" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">为了显示图像的预览，我们使用JavaScript <code class="fe nd ne nf ng b">FileReader</code> API。</p><p id="252f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">为了将文件转换成<code class="fe nd ne nf ng b">dataURL</code>，我们调用了<code class="fe nd ne nf ng b">fileReader.readAsDataURL</code>方法。</p><p id="2dd2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">一旦文件被成功读取为<code class="fe nd ne nf ng b">dataURL</code>，就会调用<code class="fe nd ne nf ng b">fileReader</code>的onload函数。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="2431" class="nl kp in ng b gy nm nn l no np">fileReader.onload = () =&gt; {<br/>  setPreviewSrc(fileReader.result);<br/>};</span></pre><p id="73c9" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">读取操作的结果将在<code class="fe nd ne nf ng b">fileReader</code>的<code class="fe nd ne nf ng b">result</code>属性中可用，我们将该属性赋给<code class="fe nd ne nf ng b">previewSrc</code>状态变量。</p><p id="eee6" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们只显示图像的预览，所以我们检查上传文件的格式是否正确(只有jpg、jpeg和png图像),并更新<code class="fe nd ne nf ng b">previewAvailable</code>变量的状态。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="76b5" class="nl kp in ng b gy nm nn l no np">setIsPreviewAvailable(uploadedFile.name.match(/\.(jpeg|jpg|png)$/));</span></pre><p id="a7e3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，通过运行<code class="fe nd ne nf ng b">yarn start</code>命令重启应用程序并验证功能。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/eecf496af6fa41c14c3533e2d484813c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*PktuHTlaNPzascE8.gif"/></div></figure><p id="4386" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里，我们通过浏览添加了一个文件。您甚至可以通过拖放来添加文件，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/126c2117891ddd13112cf3d07200166c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*Pi-LugSfGUkURHiT.gif"/></div></figure><p id="f025" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果您选择了一个文件，而不是一个图像，我们将不会显示消息<code class="fe nd ne nf ng b">No preview available for this file</code>所指示的预览。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/48645a2a5142e6535d80cbfd2dd4232a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*NzGxqR1kDAKD40EU.gif"/></div></figure><h1 id="cc4f" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">添加下降指示</h1><p id="b369" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">如果您看到了拖放功能，我们没有显示任何文件被放入拖放区的迹象，所以让我们添加它。</p><p id="b2c4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们已经在<code class="fe nd ne nf ng b">App.js</code>文件中用类<code class="fe nd ne nf ng b">drop-zone</code>向div添加了一个<code class="fe nd ne nf ng b">ref</code>。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="e288" class="nl kp in ng b gy nm nn l no np">&lt;div {...getRootProps({ className: 'drop-zone' })} ref={dropRef}&gt;</span></pre><p id="1238" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">并且使用<code class="fe nd ne nf ng b">useRef</code>钩子在顶部创建了<code class="fe nd ne nf ng b">dropRef</code>变量。</p><p id="d2c7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">将<code class="fe nd ne nf ng b">onDragEnter</code>和<code class="fe nd ne nf ng b">onDragLeave</code>支柱添加到<code class="fe nd ne nf ng b">Dropzone</code>组件上。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="7925" class="nl kp in ng b gy nm nn l no np">&lt;Dropzone<br/>  onDrop={onDrop}<br/>  onDragEnter={() =&gt; updateBorder('over')}<br/>  onDragLeave={() =&gt; updateBorder('leave')}<br/>&gt;</span></pre><p id="9920" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当文件在拖放区上方时会触发<code class="fe nd ne nf ng b">onDragEnter</code>功能，当文件从拖放区移开时会触发<code class="fe nd ne nf ng b">onDragLeave</code>功能。</p><p id="593e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">handleOnSubmit</code>处理程序之前的<code class="fe nd ne nf ng b">App</code>组件内创建一个新的<code class="fe nd ne nf ng b">updateBorder</code>函数。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="26a7" class="nl kp in ng b gy nm nn l no np">const updateBorder = (dragState) =&gt; {<br/>  if (dragState === 'over') {<br/>    dropRef.current.style.border = '2px solid #000';<br/>  } else if (dragState === 'leave') {<br/>    dropRef.current.style.border = '2px dashed #e9ebeb';<br/>  }<br/>};</span></pre><p id="c3cc" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因为我们已经用类<code class="fe nd ne nf ng b">drop-zone</code>添加了对div的<code class="fe nd ne nf ng b">dropRef</code>引用，它将指向那个div，我们可以使用它的<code class="fe nd ne nf ng b">current</code>属性通过<code class="fe nd ne nf ng b">dropRef.current.style.border</code>更新拖放区域的边界。</p><p id="8780" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">另外，在<code class="fe nd ne nf ng b">onDrop</code>函数中，在函数的末尾添加下面一行。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="de74" class="nl kp in ng b gy nm nn l no np">dropRef.current.style.border = '2px dashed #e9ebeb';</span></pre><p id="2182" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，当我们将文件放到拖放区域时，边框将恢复到正常状态。</p><p id="5ad7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，如果您检查应用程序，您将会看到改变边框的拖放效果。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/8bccc27007527f22ccadc622760c3574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2yTWKNengQjg8ZoG.gif"/></div></div></figure><h1 id="8f40" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">调用API进行文件上传</h1><p id="8e8e" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">src/utils</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">constants.js</code>的新文件，内容如下</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="31d6" class="nl kp in ng b gy nm nn l no np">export const API_URL = 'http://localhost:3030';</span></pre><p id="3156" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们将很快在<code class="fe nd ne nf ng b">3030</code>港启动我们的快递服务器，所以我们在这里提到了。</p><p id="82c8" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，让我们在<code class="fe nd ne nf ng b">App.js</code>的<code class="fe nd ne nf ng b">handleOnSubmit</code>处理程序中编写代码来调用后端API。</p><p id="1a37" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">用以下代码替换<code class="fe nd ne nf ng b">handleOnSubmit</code>处理程序</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="eb1b" class="nl kp in ng b gy nm nn l no np">const handleOnSubmit = async (event) =&gt; {<br/>  event.preventDefault();</span><span id="1e08" class="nl kp in ng b gy nq nn l no np">  try {<br/>    const { title, description } = state;<br/>    if (title.trim() !== '' &amp;&amp; description.trim() !== '') {<br/>      if (file) {<br/>        const formData = new FormData();<br/>        formData.append('file', file);<br/>        formData.append('title', title);<br/>        formData.append('description', description);</span><span id="7b8a" class="nl kp in ng b gy nq nn l no np">        setErrorMsg('');<br/>        await axios.post(`${API_URL}/upload`, formData, {<br/>          headers: {<br/>            'Content-Type': 'multipart/form-data'<br/>          }<br/>        });<br/>      } else {<br/>        setErrorMsg('Please select a file to add.');<br/>      }<br/>    } else {<br/>      setErrorMsg('Please enter all the field values.');<br/>    }<br/>  } catch (error) {<br/>    error.response &amp;&amp; setErrorMsg(error.response.data);<br/>  }<br/>};</span></pre><p id="55d4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">另外，导入文件顶部的<code class="fe nd ne nf ng b">API_URL</code>。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="0777" class="nl kp in ng b gy nm nn l no np">import { API_URL } from '../utils/constants';</span></pre><p id="fe3a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">handleOnSubmit</code>处理程序中，我们首先检查用户是否输入了所有的字段值并选择了文件，我们对<code class="fe nd ne nf ng b">/upload</code> API进行API调用，这将在下一节中编写。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="9ad5" class="nl kp in ng b gy nm nn l no np">await axios.post(`${API_URL}/upload`, formData, {<br/>  headers: {<br/>    'Content-Type': 'multipart/form-data'<br/>  }<br/>});</span></pre><p id="10c4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们用<code class="fe nd ne nf ng b">formData</code>对象发出一个<code class="fe nd ne nf ng b">POST</code>请求，并将<code class="fe nd ne nf ng b">title</code>、<code class="fe nd ne nf ng b">description</code>和实际文件发送给API。</p><p id="5cf8" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">注意，提及多部分/形式数据的内容类型是非常重要的，否则文件将不会被发送到服务器。</p><h1 id="8db8" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">为文件上传添加服务器端代码</h1><p id="d343" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在，让我们添加上传文件的服务器端功能。</p><p id="44db" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">react-upload-download-files</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">server</code>的文件夹，并从<code class="fe nd ne nf ng b">server</code>文件夹中执行以下命令</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="6d65" class="nl kp in ng b gy nm nn l no np">yarn init -y</span></pre><p id="00c0" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这将在<code class="fe nd ne nf ng b">server</code>文件夹中创建一个<code class="fe nd ne nf ng b">package.json</code>文件。</p><p id="9b11" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">从终端的<code class="fe nd ne nf ng b">server</code>文件夹中执行以下命令，安装所需的依赖项</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="362e" class="nl kp in ng b gy nm nn l no np">yarn add cors@2.8.5 express@4.17.1 mongoose@5.10.7 multer@1.4.2 nodemon@2.0.4</span></pre><p id="f63a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">server</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">.gitignore</code>的新文件，并在其中添加下面一行，这样<code class="fe nd ne nf ng b">node_modules</code>文件夹就不会被添加到您的Git存储库中。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="7def" class="nl kp in ng b gy nm nn l no np">node_modules</span></pre><p id="4ad2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在在<code class="fe nd ne nf ng b">server</code>文件夹中创建<code class="fe nd ne nf ng b">db</code>、<code class="fe nd ne nf ng b">files</code>、<code class="fe nd ne nf ng b">model</code>、<code class="fe nd ne nf ng b">routes</code>文件夹。同样，在<code class="fe nd ne nf ng b">server</code>文件夹中创建<code class="fe nd ne nf ng b">index.js</code>。</p><p id="98f0" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">server/db</code>文件夹中，创建一个新文件<code class="fe nd ne nf ng b">db.js</code>，内容如下</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="a78d" class="nl kp in ng b gy nm nn l no np">const mongoose = require('mongoose');</span><span id="e17d" class="nl kp in ng b gy nq nn l no np">mongoose.connect('mongodb://127.0.0.1:27017/file_upload', {<br/>  useNewUrlParser: true,<br/>  useUnifiedTopology: true,<br/>  useCreateIndex: true<br/>});</span></pre><p id="78c3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在此提供您的<code class="fe nd ne nf ng b">MongoDB</code>数据库连接详情。<code class="fe nd ne nf ng b">file_upload</code>是我们将使用的数据库的名称。</p><p id="e681" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">model</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">file.js</code>的新文件，内容如下</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="b97d" class="nl kp in ng b gy nm nn l no np">const mongoose = require('mongoose');</span><span id="f970" class="nl kp in ng b gy nq nn l no np">const fileSchema = mongoose.Schema(<br/>  {<br/>    title: {<br/>      type: String,<br/>      required: true,<br/>      trim: true<br/>    },<br/>    description: {<br/>      type: String,<br/>      required: true,<br/>      trim: true<br/>    },<br/>    file_path: {<br/>      type: String,<br/>      required: true<br/>    },<br/>    file_mimetype: {<br/>      type: String,<br/>      required: true<br/>    }<br/>  },<br/>  {<br/>    timestamps: true<br/>  }<br/>);</span><span id="eb56" class="nl kp in ng b gy nq nn l no np">const File = mongoose.model('File', fileSchema);</span><span id="f76f" class="nl kp in ng b gy nq nn l no np">module.exports = File;</span></pre><p id="b8fb" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里，我们定义了集合的模式，因为我们使用了一个非常流行的<a class="ae nc" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>库来处理MongoDB。我们将在集合中存储<code class="fe nd ne nf ng b">title</code>、<code class="fe nd ne nf ng b">description</code>、<code class="fe nd ne nf ng b">file_path</code>和<code class="fe nd ne nf ng b">file_mimetype</code>，所以我们在这个文件中描述了每个的类型。</p><p id="99b9" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">注意，尽管我们已经将模型名称定义为<code class="fe nd ne nf ng b">File</code>，MongoDB还是创建了集合的复数版本。因此集合名称将为<code class="fe nd ne nf ng b">files</code>。</p><p id="548f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，在<code class="fe nd ne nf ng b">routes</code>文件夹中创建一个名为<code class="fe nd ne nf ng b">file.js</code>的新文件，内容如下</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="5c5c" class="nl kp in ng b gy nm nn l no np">const path = require('path');<br/>const express = require('express');<br/>const multer = require('multer');<br/>const File = require('../model/file');<br/>const Router = express.Router();</span><span id="a619" class="nl kp in ng b gy nq nn l no np">const upload = multer({<br/>  storage: multer.diskStorage({<br/>    destination(req, file, cb) {<br/>      cb(null, './files');<br/>    },<br/>    filename(req, file, cb) {<br/>      cb(null, `${new Date().getTime()}_${file.originalname}`);<br/>    }<br/>  }),<br/>  limits: {<br/>    fileSize: 1000000 // max file size 1MB = 1000000 bytes<br/>  },<br/>  fileFilter(req, file, cb) {<br/>    if (!file.originalname.match(/\.(jpeg|jpg|png|pdf|doc|docx|xlsx|xls)$/)) {<br/>      return cb(<br/>        new Error(<br/>          'only upload files with jpg, jpeg, png, pdf, doc, docx, xslx, xls format.'<br/>        )<br/>      );<br/>    }<br/>    cb(undefined, true); // continue with upload<br/>  }<br/>});</span><span id="556b" class="nl kp in ng b gy nq nn l no np">Router.post(<br/>  '/upload',<br/>  upload.single('file'),<br/>  async (req, res) =&gt; {<br/>    try {<br/>      const { title, description } = req.body;<br/>      const { path, mimetype } = req.file;<br/>      const file = new File({<br/>        title,<br/>        description,<br/>        file_path: path,<br/>        file_mimetype: mimetype<br/>      });<br/>      await file.save();<br/>      res.send('file uploaded successfully.');<br/>    } catch (error) {<br/>      res.status(400).send('Error while uploading file. Try again later.');<br/>    }<br/>  },<br/>  (error, req, res, next) =&gt; {<br/>    if (error) {<br/>      res.status(500).send(error.message);<br/>    }<br/>  }<br/>);</span><span id="4c1c" class="nl kp in ng b gy nq nn l no np">Router.get('/getAllFiles', async (req, res) =&gt; {<br/>  try {<br/>    const files = await File.find({});<br/>    const sortedByCreationDate = files.sort(<br/>      (a, b) =&gt; b.createdAt - a.createdAt<br/>    );<br/>    res.send(sortedByCreationDate);<br/>  } catch (error) {<br/>    res.status(400).send('Error while getting list of files. Try again later.');<br/>  }<br/>});</span><span id="5a1a" class="nl kp in ng b gy nq nn l no np">Router.get('/download/:id', async (req, res) =&gt; {<br/>  try {<br/>    const file = await File.findById(req.params.id);<br/>    res.set({<br/>      'Content-Type': file.file_mimetype<br/>    });<br/>    res.sendFile(path.join(__dirname, '..', file.file_path));<br/>  } catch (error) {<br/>    res.status(400).send('Error while downloading file. Try again later.');<br/>  }<br/>});</span><span id="a18a" class="nl kp in ng b gy nq nn l no np">module.exports = Router;</span></pre><p id="620a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这个文件中，我们使用<code class="fe nd ne nf ng b">multer</code>库来处理文件上传。我们正在创建一个<code class="fe nd ne nf ng b">multer</code>配置，存储在名为<code class="fe nd ne nf ng b">upload</code>的变量中。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="85e8" class="nl kp in ng b gy nm nn l no np">const upload = multer({<br/>  storage: multer.diskStorage({<br/>    destination(req, file, cb) {<br/>      cb(null, './files');<br/>    },<br/>    filename(req, file, cb) {<br/>      cb(null, `${new Date().getTime()}_${file.originalname}`);<br/>    }<br/>  }),<br/>  limits: {<br/>    fileSize: 1000000 // max file size 1MB = 1000000 bytes<br/>  },<br/>  fileFilter(req, file, cb) {<br/>    if (!file.originalname.match(/\.(jpeg|jpg|png|pdf|doc|docx|xlsx|xls)$/)) {<br/>      return cb(<br/>        new Error(<br/>          'only upload files with jpg, jpeg, png, pdf, doc, docx, xslx, xls format.'<br/>        )<br/>      );<br/>    }<br/>    cb(undefined, true); // continue with upload<br/>  }<br/>});</span></pre><p id="27f9" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><code class="fe nd ne nf ng b">multer</code>函数以一个对象作为参数，该对象有许多属性，其中一些属性是<code class="fe nd ne nf ng b">storage</code>、<code class="fe nd ne nf ng b">limits</code>和<code class="fe nd ne nf ng b">fileFilter</code>函数。</p><p id="671f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><code class="fe nd ne nf ng b">multer.diskStorage</code>函数接受一个带有<code class="fe nd ne nf ng b">destination</code>和<code class="fe nd ne nf ng b">filename</code>函数的对象。</p><p id="e7cc" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里我们使用ES6函数简写语法，所以</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="6b0f" class="nl kp in ng b gy nm nn l no np">destination(req, file, cb) {</span></pre><p id="f6a2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">与相同</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="630b" class="nl kp in ng b gy nm nn l no np">destination: function(req, file, cb) {</span></pre><p id="4371" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><code class="fe nd ne nf ng b">destination</code>和<code class="fe nd ne nf ng b">filename</code>功能接收三个输入参数，即<code class="fe nd ne nf ng b">req(request)</code>、<code class="fe nd ne nf ng b">file(actual uploaded file object)</code>和<code class="fe nd ne nf ng b">cb(callback function)</code>。</p><p id="0a1f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">对于回调函数(cb)参数，</p><ul class=""><li id="b04f" class="mh mi in li b lj mc lm md lp mj lt mk lx ml mb mm mn mo mp bi translated">如果有错误，它将作为第一个参数传递</li><li id="2c9c" class="mh mi in li b lj mq lm mr lp ms lt mt lx mu mb mm mn mo mp bi translated">如果没有错误，那么第一个参数将为空或未定义，第二个参数将包含要传递给回调函数的数据。</li></ul><p id="fecf" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">destination</code>函数中，我们传递将要存储上传文件的文件夹的路径。在我们的例子中，它将是<code class="fe nd ne nf ng b">server</code>文件夹中的一个<code class="fe nd ne nf ng b">files</code>文件夹。</p><p id="9986" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">filename</code>函数中，我们为每个上传的文件提供我们想要的名字。在我们的情况下，它将是<code class="fe nd ne nf ng b">current_timestamp_name_of_the_file</code>。</p><p id="b652" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">对于<code class="fe nd ne nf ng b">limits</code>属性，我们指定了上传文件允许的最大文件大小。在我们的例子中，我们提供了1MB作为最大文件限制。</p><p id="ad6e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然后在<code class="fe nd ne nf ng b">fileFilter</code>函数中，我们可以决定接受或者拒绝上传的文件。</p><p id="241b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果文件扩展名与任一<code class="fe nd ne nf ng b">jpeg|jpg|png|pdf|doc|docx|xlsx|xls</code>匹配，那么我们允许通过调用回调函数<code class="fe nd ne nf ng b">cb(undefined, true)</code>来上传文件，否则我们将抛出一个错误。</p><p id="a339" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果我们在<code class="fe nd ne nf ng b">fileFilter</code>函数内部调用<code class="fe nd ne nf ng b">cb(undefined, false)</code>，那么文件将总是被拒绝，不会被上传。</p><p id="8ea2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，让我们来看看<code class="fe nd ne nf ng b">/upload</code>路线</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="0191" class="nl kp in ng b gy nm nn l no np">Router.post(<br/>  '/upload',<br/>  upload.single('file'),<br/>  async (req, res) =&gt; {<br/>    try {<br/>      const { title, description } = req.body;<br/>      const { path, mimetype } = req.file;<br/>      const file = new File({<br/>        title,<br/>        description,<br/>        file_path: path,<br/>        file_mimetype: mimetype<br/>      });<br/>      await file.save();<br/>      res.send('file uploaded successfully.');<br/>    } catch (error) {<br/>      res.status(400).send('Error while uploading file. Try again later.');<br/>    }<br/>  },<br/>  (error, req, res, next) =&gt; {<br/>    if (error) {<br/>      res.status(500).send(error.message);<br/>    }<br/>  }<br/>);</span></pre><p id="afd1" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里，我们将<code class="fe nd ne nf ng b">upload.single</code>函数作为第二个参数传递给<code class="fe nd ne nf ng b">/upload</code>路由，这样它将作为一个中间件，在执行函数体之前首先被执行。</p><p id="4013" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">注意，<code class="fe nd ne nf ng b">upload.single</code>的<code class="fe nd ne nf ng b">file</code>参数必须与在前端上传文件时使用的名称相匹配。</p><p id="d3f2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">还记得我们之前用于从<code class="fe nd ne nf ng b">App.js</code>文件进行API调用的代码吗？</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="91d1" class="nl kp in ng b gy nm nn l no np">const formData = new FormData();<br/>formData.append('file', file);</span></pre><p id="5952" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们将文件添加到名为<code class="fe nd ne nf ng b">file</code>的属性内的<code class="fe nd ne nf ng b">formData</code>中。这必须与<code class="fe nd ne nf ng b">upload.single</code>参数名匹配，否则文件上传将无法进行。</p><p id="c62e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在函数内部，我们将获得<code class="fe nd ne nf ng b">req.body</code>中的<code class="fe nd ne nf ng b">title</code>和<code class="fe nd ne nf ng b">description</code>以及<code class="fe nd ne nf ng b">req.file</code>对象中的实际文件，因为我们已经使用了<code class="fe nd ne nf ng b">multer</code>库。</p><p id="5943" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然后我们将这些值传递给我们创建的<code class="fe nd ne nf ng b">File</code>模型的对象。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="a6bc" class="nl kp in ng b gy nm nn l no np">const file = new File({<br/>  title,<br/>  description,<br/>  file_path: path,<br/>  file_mimetype: mimetype<br/>});</span></pre><p id="0853" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在对象上调用<code class="fe nd ne nf ng b">save</code>方法实际上会将数据保存在MongoDB数据库中。</p><p id="8600" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果文件类型与<code class="fe nd ne nf ng b">jpeg|jpg|png|pdf|doc|docx|xlsx|xls</code>不匹配或者文件大小大于我们提到的大小(1MB ),那么将执行下面的代码</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="5656" class="nl kp in ng b gy nm nn l no np">(error, req, res, next) =&gt; {<br/>  if (error) {<br/>    res.status(500).send(error.message);<br/>  }<br/>};</span></pre><p id="8529" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们将错误消息发送回客户端(我们的React应用程序)。</p><p id="8a42" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，打开<code class="fe nd ne nf ng b">server/index.js</code>文件，在里面添加以下内容。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="3258" class="nl kp in ng b gy nm nn l no np">const express = require('express');<br/>const cors = require('cors');<br/>const fileRoute = require('./routes/file');<br/>require('./db/db');</span><span id="8d08" class="nl kp in ng b gy nq nn l no np">const app = express();</span><span id="bbd9" class="nl kp in ng b gy nq nn l no np">app.use(cors());<br/>app.use(fileRoute);</span><span id="88e8" class="nl kp in ng b gy nq nn l no np">app.listen(3030, () =&gt; {<br/>  console.log('server started on port 3030');<br/>});</span></pre><p id="362d" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这个文件中，我们使用<code class="fe nd ne nf ng b">Express</code>服务器在端口<code class="fe nd ne nf ng b">3030</code>上启动Node.js应用程序。</p><p id="2f7e" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们还将<code class="fe nd ne nf ng b">cors</code> npm包用作中间件，因此当我们从运行在端口<code class="fe nd ne nf ng b">3000</code>上的React应用程序向运行在端口<code class="fe nd ne nf ng b">3030</code>上的Node.js应用程序发出API调用时，我们不会收到<code class="fe nd ne nf ng b">CORS</code>错误。</p><p id="99a2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，让我们运行应用程序，检查上传功能。</p><p id="f6c5" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">打开<code class="fe nd ne nf ng b">server/package.json</code>文件，在<code class="fe nd ne nf ng b">scripts</code>属性中添加<code class="fe nd ne nf ng b">start</code>脚本。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="b51a" class="nl kp in ng b gy nm nn l no np">"scripts": {<br/>  "start": "nodemon index.js"<br/>}</span></pre><p id="2949" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，打开另一个保持React终端运行的终端，从<code class="fe nd ne nf ng b">server</code>文件夹中执行下面的命令</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="b978" class="nl kp in ng b gy nm nn l no np">yarn start</span></pre><p id="8015" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这将启动我们的Node.js express服务器，这样我们就可以对它进行API调用。</p><p id="9c58" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">还可以通过从终端运行以下命令来启动MongoDB数据库服务器(如果您已经遵循了前面提到的<a class="ae nc" href="https://levelup.gitconnected.com/how-to-install-mongodb-database-on-local-environment-19a8a76f1b92?source=friends_link&amp;sk=416b443bad1f86b292e4b72602cf5c9b" rel="noopener ugc nofollow" target="_blank">这篇文章</a></p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="abf4" class="nl kp in ng b gy nm nn l no np">./mongod --dbpath=&lt;path_to_mongodb-data_folder&gt;</span></pre><p id="60aa" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所以现在您将打开三个终端:一个用于React应用程序，一个用于Node.js服务器，另一个用于MongoDB服务器。</p><p id="270c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在让我们来验证上传功能。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/55eeeabf189f9fc725c9729f227dc736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*MFtXr00ZHEnG3m6h.gif"/></div></figure><p id="67d3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如您所见，当我们上传一个文件时，它被添加到files文件夹中，并且条目也在MongoDB数据库中。所以文件上传成功。</p><p id="1fb4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">但是我们没有在UI上显示任何文件已经成功上传的迹象。让我们现在做那件事。</p><p id="0433" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">components</code>文件夹中创建一个新文件<code class="fe nd ne nf ng b">FilesList.js</code>，内容如下</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="9046" class="nl kp in ng b gy nm nn l no np">import React, { useState, useEffect } from 'react';<br/>import download from 'downloadjs';<br/>import axios from 'axios';<br/>import { API_URL } from '../utils/constants';</span><span id="81ac" class="nl kp in ng b gy nq nn l no np">const FilesList = () =&gt; {<br/>  const [filesList, setFilesList] = useState([]);<br/>  const [errorMsg, setErrorMsg] = useState('');</span><span id="1c53" class="nl kp in ng b gy nq nn l no np">  useEffect(() =&gt; {<br/>    const getFilesList = async () =&gt; {<br/>      try {<br/>        const { data } = await axios.get(`${API_URL}/getAllFiles`);<br/>        setErrorMsg('');<br/>        setFilesList(data);<br/>      } catch (error) {<br/>        error.response &amp;&amp; setErrorMsg(error.response.data);<br/>      }<br/>    };</span><span id="4c38" class="nl kp in ng b gy nq nn l no np">    getFilesList();<br/>  }, []);</span><span id="2496" class="nl kp in ng b gy nq nn l no np">  const downloadFile = async (id, path, mimetype) =&gt; {<br/>    try {<br/>      const result = await axios.get(`${API_URL}/download/${id}`, {<br/>        responseType: 'blob'<br/>      });<br/>      const split = path.split('/');<br/>      const filename = split[split.length - 1];<br/>      setErrorMsg('');<br/>      return download(result.data, filename, mimetype);<br/>    } catch (error) {<br/>      if (error.response &amp;&amp; error.response.status === 400) {<br/>        setErrorMsg('Error while downloading file. Try again later');<br/>      }<br/>    }<br/>  };</span><span id="a14b" class="nl kp in ng b gy nq nn l no np">  return (<br/>    &lt;div className="files-container"&gt;<br/>      {errorMsg &amp;&amp; &lt;p className="errorMsg"&gt;{errorMsg}&lt;/p&gt;}<br/>      &lt;table className="files-table"&gt;<br/>        &lt;thead&gt;<br/>          &lt;tr&gt;<br/>            &lt;th&gt;Title&lt;/th&gt;<br/>            &lt;th&gt;Description&lt;/th&gt;<br/>            &lt;th&gt;Download File&lt;/th&gt;<br/>          &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;<br/>          {filesList.length &gt; 0 ? (<br/>            filesList.map(<br/>              ({ _id, title, description, file_path, file_mimetype }) =&gt; (<br/>                &lt;tr key={_id}&gt;<br/>                  &lt;td className="file-title"&gt;{title}&lt;/td&gt;<br/>                  &lt;td className="file-description"&gt;{description}&lt;/td&gt;<br/>                  &lt;td&gt;<br/>                    &lt;a<br/>                      href="#/"<br/>                      onClick={() =&gt;<br/>                        downloadFile(_id, file_path, file_mimetype)<br/>                      }<br/>                    &gt;<br/>                      Download<br/>                    &lt;/a&gt;<br/>                  &lt;/td&gt;<br/>                &lt;/tr&gt;<br/>              )<br/>            )<br/>          ) : (<br/>            &lt;tr&gt;<br/>              &lt;td colSpan={3} style={{ fontWeight: '300' }}&gt;<br/>                No files found. Please add some.<br/>              &lt;/td&gt;<br/>            &lt;/tr&gt;<br/>          )}<br/>        &lt;/tbody&gt;<br/>      &lt;/table&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="86c7" class="nl kp in ng b gy nq nn l no np">export default FilesList;</span></pre><p id="9627" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这个文件中，最初在<code class="fe nd ne nf ng b">useEffect</code>钩子内部，我们对<code class="fe nd ne nf ng b">/getAllFiles</code> API进行API调用。</p><p id="b190" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">来自<code class="fe nd ne nf ng b">routes/file.js</code>的<code class="fe nd ne nf ng b">/getAllFiles</code> API如下所示:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="9efb" class="nl kp in ng b gy nm nn l no np">Router.get('/getAllFiles', async (req, res) =&gt; {<br/>  try {<br/>    const files = await File.find({});<br/>    const sortedByCreationDate = files.sort(<br/>      (a, b) =&gt; b.createdAt - a.createdAt<br/>    );<br/>    res.send(sortedByCreationDate);<br/>  } catch (error) {<br/>    res.status(400).send('Error while getting list of files. Try again later.');<br/>  }<br/>});</span></pre><p id="c197" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在这里，我们调用<code class="fe nd ne nf ng b">File</code>模型上的<code class="fe nd ne nf ng b">mongoose</code>库的<code class="fe nd ne nf ng b">.find</code>方法来获取添加到数据库中的所有文件的列表，然后我们按照<code class="fe nd ne nf ng b">createdAt</code>日期以降序对它们进行排序，因此我们将在列表中首先获取最近添加的文件。</p><p id="efb3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然后我们将API的结果分配给状态中的<code class="fe nd ne nf ng b">filesList</code>数组</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="10e1" class="nl kp in ng b gy nm nn l no np">const { data } = await axios.get(`${API_URL}/getAllFiles`);<br/>setErrorMsg('');<br/>setFilesList(data);</span></pre><p id="4aa2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然后，我们使用数组映射方法遍历数组，并在UI上以表格格式显示它们。</p><p id="a316" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">我们还在表格中添加了一个下载链接。当我们点击<code class="fe nd ne nf ng b">download</code>链接时，我们正在调用<code class="fe nd ne nf ng b">downloadFile</code>函数</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="4052" class="nl kp in ng b gy nm nn l no np">const downloadFile = async (id, path, mimetype) =&gt; {<br/>  try {<br/>    const result = await axios.get(`${API_URL}/download/${id}`, {<br/>      responseType: 'blob'<br/>    });<br/>    const split = path.split('/');<br/>    const filename = split[split.length - 1];<br/>    setErrorMsg('');<br/>    return download(result.data, filename, mimetype);<br/>  } catch (error) {<br/>    if (error.response &amp;&amp; error.response.status === 400) {<br/>      setErrorMsg('Error while downloading file. Try again later');<br/>    }<br/>  }<br/>};</span></pre><p id="4a13" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">在<code class="fe nd ne nf ng b">downloadFile</code>函数中，我们调用了<code class="fe nd ne nf ng b">/download/:id</code> API。注意，我们将<code class="fe nd ne nf ng b">responseType</code>设置为<code class="fe nd ne nf ng b">blob</code>。这一点非常重要，否则您将无法获得正确格式的文件。</p><p id="e18f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">来自<code class="fe nd ne nf ng b">routes/file.js</code>文件的<code class="fe nd ne nf ng b">/download</code> API如下所示:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="9265" class="nl kp in ng b gy nm nn l no np">Router.get('/download/:id', async (req, res) =&gt; {<br/>  try {<br/>    const file = await File.findById(req.params.id);<br/>    res.set({<br/>      'Content-Type': file.file_mimetype<br/>    });<br/>    res.sendFile(path.join(__dirname, '..', file.file_path));<br/>  } catch (error) {<br/>    res.status(400).send('Error while downloading file. Try again later.');<br/>  }<br/>});</span></pre><p id="d6a8" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里，首先，我们用提供的<code class="fe nd ne nf ng b">id</code>检查是否存在任何这样的文件。如果它存在，那么我们首先通过设置文件的<code class="fe nd ne nf ng b">content-type</code>来发送回存储在<code class="fe nd ne nf ng b">files</code>文件夹中的文件。</p><p id="8578" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">设置<code class="fe nd ne nf ng b">content-type</code>对于获得正确格式的文件非常重要，因为我们不仅上传图像，还上传doc、xls和pdf文件。因此，为了正确发送回文件内容，需要使用<code class="fe nd ne nf ng b">content-type</code>。</p><p id="2927" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">一旦我们从<code class="fe nd ne nf ng b">downloadFile</code>函数中的<code class="fe nd ne nf ng b">/download</code> API得到响应，我们就调用由<a class="ae nc" href="https://www.npmjs.com/package/downloadjs" rel="noopener ugc nofollow" target="_blank"> downloadjs </a> npm库提供的<code class="fe nd ne nf ng b">download</code>函数。</p><p id="403b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><code class="fe nd ne nf ng b">downloadjs</code>是一个非常受欢迎的库，可以下载任何类型的文件。你只需要提供文件内容，它的内容类型和文件名，你希望文件下载时，它将触发浏览器的下载功能。</p><p id="c822" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，打开<code class="fe nd ne nf ng b">router/AppRouter.js</code>文件，为<code class="fe nd ne nf ng b">FilesList</code>组件添加一条路径。</p><p id="98ff" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您的<code class="fe nd ne nf ng b">AppRouter.js</code>文件现在看起来像这样:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="6abc" class="nl kp in ng b gy nm nn l no np">import React from 'react';<br/>import { BrowserRouter, Switch, Route } from 'react-router-dom';<br/>import App from '../components/App';<br/>import Header from '../components/Header';<br/>import FilesList from '../components/FilesList';</span><span id="d5c3" class="nl kp in ng b gy nq nn l no np">const AppRouter = () =&gt; (<br/>  &lt;BrowserRouter&gt;<br/>    &lt;div className="container"&gt;<br/>      &lt;Header /&gt;<br/>      &lt;div className="main-content"&gt;<br/>        &lt;Switch&gt;<br/>          &lt;Route component={App} path="/" exact={true} /&gt;<br/>          &lt;Route component={FilesList} path="/list" /&gt;<br/>        &lt;/Switch&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/BrowserRouter&gt;<br/>);</span><span id="5c35" class="nl kp in ng b gy nq nn l no np">export default AppRouter;</span></pre><p id="5e5c" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，打开<code class="fe nd ne nf ng b">src/App.js</code>，在调用<code class="fe nd ne nf ng b">/upload</code> API后，在<code class="fe nd ne nf ng b">handleOnSubmit</code>处理程序中添加一条语句，将用户重定向到<code class="fe nd ne nf ng b">FilesList</code>组件</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="0a0e" class="nl kp in ng b gy nm nn l no np">await axios.post(`${API_URL}/upload`, formData, {<br/>  headers: {<br/>    'Content-Type': 'multipart/form-data'<br/>  }<br/>});<br/>props.history.push('/list'); // add this line</span></pre><p id="355b" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所以现在，一旦文件被上传，我们将被重定向到<code class="fe nd ne nf ng b">FilesList</code>组件，在那里我们将看到上传的文件列表。</p><p id="b850" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如果上传文件时出现错误，您将在UI上看到错误消息，并且您不会被重定向到列表页面。</p><p id="3f81" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">假设您已经在两个单独的终端中执行了<code class="fe nd ne nf ng b">yarn start</code>命令，用于启动React和Node.js应用程序，并在另一个终端中运行MongoDB服务器。现在，让我们验证应用程序的功能。</p><h1 id="bd2d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">上传图像文件演示</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/292332b440c27987e15c0e462c7acd94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*3QSdJccWvm0r-_CA.gif"/></div></figure><h1 id="ac3e" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">上传PDF文件演示</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/9d2b3ef1436fe7428f48b28bf789da07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*Kb-JwVJbIUSbOZCg.gif"/></div></figure><h1 id="b723" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">上传Excel文件演示</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/41ad3decbc28cfad6815b2a71f911528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*xvYTGfVBIK6sm-eD.gif"/></div></figure><h1 id="ff9a" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">上传文档文件演示</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/71e1b2dd61dd5b1fcc69c886f720a5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/0*gmD1MGCsfnZIibdw.gif"/></div></figure><h1 id="94f1" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">上传不支持的文件演示</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/263706b94d3240c78e1a1893e20ae5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BJz8Fl05qbb5M--d.gif"/></div></div></figure><p id="5031" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">如您所见，我们能够成功上传和下载我们支持的格式列表中的任何类型的文件。</p><h1 id="c14b" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">消除对CORS的需求</h1><p id="58c0" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">如前所述，为了在从React应用程序向Node.js应用程序调用API时避免出现CORS错误，我们在服务器端使用了<code class="fe nd ne nf ng b">cors</code>库，如下所示:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="a822" class="nl kp in ng b gy nm nn l no np">app.use(cors());</span></pre><p id="c3bd" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">尝试从文件中删除这一行，您将看到从React到Node.js的API调用失败。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/189507694d8ab6f2d4585e806ff821e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GXn2ITLn1DcnqLir.png"/></div></div></figure><p id="a96f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">为了防止这个错误，我们使用了cors中间件。但正因为如此，世界上的任何人都可以从他们的应用程序直接访问我们的API，出于安全原因，这并不好。</p><p id="f96a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，为了消除对cors的需要，我们将在同一个端口上运行Node.js和React应用程序，这也将消除运行两个独立命令的需要。</p><p id="7a8a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所以首先从<code class="fe nd ne nf ng b">server/index.js</code>文件中删除<code class="fe nd ne nf ng b">cors</code>的使用，同时删除<code class="fe nd ne nf ng b">cors</code>的<code class="fe nd ne nf ng b">require</code>语句。</p><p id="de32" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">然后在<code class="fe nd ne nf ng b">app.use(fileRoute)</code>语句前添加以下代码。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="ad79" class="nl kp in ng b gy nm nn l no np">app.use(express.static(path.join(__dirname, '..', 'build')));</span></pre><p id="5038" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">这里，我们告诉express静态地提供构建文件夹的内容。</p><p id="6951" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当我们为React应用程序运行<code class="fe nd ne nf ng b">yarn build</code>命令时，将会创建构建文件夹。</p><p id="cf67" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">要详细了解这实际上是如何工作的，请点击这里查看我以前的文章<a class="ae nc" href="https://levelup.gitconnected.com/how-to-render-react-app-using-express-server-in-node-js-a428ec4dfe2b?source=friends_link&amp;sk=3f152ac7908f540b209f07f683b494cd" rel="noopener ugc nofollow" target="_blank"/></p><p id="a8a3" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">并在文件顶部导入<code class="fe nd ne nf ng b">path</code> Node.js包。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="e8cd" class="nl kp in ng b gy nm nn l no np">const path = require('path');</span></pre><p id="205f" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您的<code class="fe nd ne nf ng b">server/index.js</code>文件现在看起来像这样:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="50ee" class="nl kp in ng b gy nm nn l no np">const express = require('express');<br/>const path = require('path');<br/>const fileRoute = require('./routes/file');<br/>require('./db/db');</span><span id="d0e0" class="nl kp in ng b gy nq nn l no np">const app = express();</span><span id="a54e" class="nl kp in ng b gy nq nn l no np">app.use(express.static(path.join(__dirname, '..', 'build')));<br/>app.use(fileRoute);</span><span id="b2ba" class="nl kp in ng b gy nq nn l no np">app.listen(3030, () =&gt; {<br/>  console.log('server started on port 3030');<br/>});</span></pre><p id="a818" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，打开主<code class="fe nd ne nf ng b">package.json</code>文件，在<code class="fe nd ne nf ng b">scripts</code>部分添加<code class="fe nd ne nf ng b">start-app</code>脚本。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="6dd6" class="nl kp in ng b gy nm nn l no np">"scripts": {<br/>    "start": "react-scripts start",<br/>    "build": "react-scripts build",<br/>    "test": "react-scripts test",<br/>    "eject": "react-scripts eject",<br/>    "start-app": "yarn build &amp;&amp; (cd server &amp;&amp; yarn start)"<br/>  },</span></pre><p id="d5c8" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，假设您已经启动了MongoDB服务器，您只需要从终端运行<code class="fe nd ne nf ng b">yarn run start-app</code>命令。</p><p id="7d64" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">该命令将创建一个包含所有React应用程序的<code class="fe nd ne nf ng b">build</code>文件夹，然后在端口<code class="fe nd ne nf ng b">3030</code>上启动Node.js服务器。</p><p id="6777" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所以现在，我们可以在同一个<code class="fe nd ne nf ng b">3030</code>端口上访问React和Node.js应用程序。因此不需要运行两个单独的命令，您可以在<a class="ae nc" href="http://localhost:3030/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3030/ </a>访问应用程序</p><p id="6af7" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">但是有一个问题，如果你刷新<code class="fe nd ne nf ng b">/list</code>页面，你会得到一个404错误。这是因为我们正在使用Express服务器启动应用程序，所以当我们到达<code class="fe nd ne nf ng b">/list</code>路线时，它会去服务器检查该路线。</p><p id="50d2" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">但是服务器不包含这样一条路线，但是我们的反应应用程序有这条路线，所以为了解决这个问题，我们需要添加一些代码。</p><p id="1498" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">打开<code class="fe nd ne nf ng b">server/index.js</code>文件，在<code class="fe nd ne nf ng b">app.listen</code>调用前，添加如下代码。</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="4e22" class="nl kp in ng b gy nm nn l no np">app.get('*', (req, res) =&gt; {<br/>  res.sendFile(path.join(__dirname, '..', 'build', 'index.html'));<br/>});</span></pre><p id="b45a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">当我们遇到服务器端不存在的任何路由时，上面的代码将把<code class="fe nd ne nf ng b">build/index.html</code>文件发送回我们的反应应用程序。</p><p id="5839" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">因此，由于服务器端不存在<code class="fe nd ne nf ng b">/list</code>路由，当我们将用户重定向到<code class="fe nd ne nf ng b">index.html</code>文件时，out React应用程序将处理该路由。</p><p id="ab29" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">所以确保在所有服务器端路由之后添加上述代码行，因为<code class="fe nd ne nf ng b">app.get</code>中的<code class="fe nd ne nf ng b">*</code>将匹配任何路由。</p><p id="963a" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您的最终<code class="fe nd ne nf ng b">server/index.js</code>文件现在将如下所示:</p><pre class="kd ke kf kg gt nh ng ni nj aw nk bi"><span id="8a35" class="nl kp in ng b gy nm nn l no np">const express = require('express');<br/>const path = require('path');<br/>const fileRoute = require('./routes/file');<br/>require('./db/db');</span><span id="a6de" class="nl kp in ng b gy nq nn l no np">const app = express();</span><span id="8be5" class="nl kp in ng b gy nq nn l no np">app.use(express.static(path.join(__dirname, '..', 'build')));<br/>app.use(fileRoute);</span><span id="cc68" class="nl kp in ng b gy nq nn l no np">app.get('*', (req, res) =&gt; {<br/>  res.sendFile(path.join(__dirname, '..', 'build', 'index.html'));<br/>});</span><span id="c205" class="nl kp in ng b gy nq nn l no np">app.listen(3030, () =&gt; {<br/>  console.log('server started on port 3030');<br/>});</span></pre><p id="41d4" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">现在，通过运行<code class="fe nd ne nf ng b">yarn run start-app</code>命令重启你的应用程序，现在刷新<code class="fe nd ne nf ng b">/list</code>路线不会给你404错误。</p><h1 id="faac" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">结论</h1><p id="ac25" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们现在已经完成了使用MERN堆栈创建完整的文件上传和下载功能。</p><p id="cc18" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated">您可以在<a class="ae nc" href="https://github.com/myogeshchavan97/react-upload-download-files" rel="noopener ugc nofollow" target="_blank">这个信息库</a>中找到这个应用程序的完整源代码。</p><p id="2162" class="pw-post-body-paragraph lg lh in li b lj mc jo ll lm md jr lo lp me lr ls lt mf lv lw lx mg lz ma mb ig bi translated"><strong class="li io">不要忘记订阅我的每周时事通讯，在这里直接在您的收件箱</strong> <a class="ae nc" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io">中找到惊人的技巧、窍门和文章。</strong> </a></p></div></div>    
</body>
</html>