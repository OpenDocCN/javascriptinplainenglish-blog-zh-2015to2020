<html>
<head>
<title>Asynchronous JavaScript to learn before JavaScript Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript框架之前学习异步JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-javascript-to-learn-before-javascript-frameworks-9b63972290c2?source=collection_archive---------1-----------------------#2020-06-05">https://javascript.plainenglish.io/asynchronous-javascript-to-learn-before-javascript-frameworks-9b63972290c2?source=collection_archive---------1-----------------------#2020-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b62075e2024de187cc773557356aff4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNJxBO3aLOJ4zI6BVOhH2A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Source: <a class="ae jz" href="https://myfreecourses.com/wp-content/uploads/2018/09/1705248_a6d3-1280x720.jpg" rel="noopener ugc nofollow" target="_blank">https://myfreecourses.com/wp-content/uploads/2018/09/1705248_a6d3-1280x720.jpg</a></figcaption></figure><p id="ebf4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一系列文章中，我们旨在涵盖以下主题:</p><ol class=""><li id="b30e" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/things-to-learn-before-learning-a-javascript-framework-b7baec310247" rel="noopener">ES6的重要特性</a></li><li id="a040" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/object-and-array-methods-to-learn-before-javascript-frameworks-59728dcea306" rel="noopener">对象和数组方法</a></li><li id="7020" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">异步JavaScript和获取API(本文)</li><li id="2ce5" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/how-to-use-npm-and-import-export-modules-in-javascript-31a7f66a2064" rel="noopener">JavaScript中的NPM和导入/导出模块</a></li></ol><p id="588e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在前两篇文章中，我们已经讨论了前两个主题，所以在本文中，我们将讨论<strong class="kc io">异步JavaScript和Fetch API。</strong></p><p id="80c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，不浪费任何时间，让我们从这个话题开始:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="lq lr l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Source: <a class="ae jz" href="https://giphy.com/g" rel="noopener ugc nofollow" target="_blank">https://giphy.com</a></figcaption></figure><p id="3c68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在跳到异步JavaScript的细节之前，我们先来说说JavaScript中<strong class="kc io">同步代码</strong>的执行。我们将考虑一个简单的例子来理解这一点:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="0700" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您所注意到的，它遵循一个连续的顺序，也就是说，所有的任务都是按照它们被编码的顺序执行的。在内部，JavaScript引擎在<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank"> <em class="lt">调用栈</em> </a>的帮助下执行这些任务。</p><p id="6c56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看调用堆栈如何帮助执行我们的代码:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/48f03c8852706ac9ada2719fdd0a2697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCJEEK7IUK2lJwkl87oZiw.jpeg"/></div></div></figure><p id="1a6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您所注意到的，当前正在执行的任务被添加到<code class="fe lv lw lx ly b">Call Stack</code>中，并在完成执行后从其中弹出。</p><p id="1661" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您对同步代码的执行和调用堆栈有了一个概念，让我们从异步javascript开始吧。</p><h2 id="0e72" class="lz ma in bd mb mc md dn me mf mg dp mh kl mi mj mk kp ml mm mn kt mo mp mq mr bi translated">什么是异步JavaScript，为什么我需要它？</h2><p id="0050" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">JavaScript是一种单线程的T21语言，也就是说它只有一个T1，这意味着它一次只能执行一个任务。因此，如果我们试图以同步的方式执行缓慢(或耗时)的操作，那么它们会导致阻塞主线程。</p><p id="0e52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们借助一个例子来理解我们所说的<code class="fe lv lw lx ly b">Blocking</code>是什么意思:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="7d94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述示例中调用堆栈的不同状态如下:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/c47919f248240c2962af94152ce787c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*00_RZrWufzeICW0dVHRlXw.png"/></div></figure><p id="5119" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，正如你所注意到的，它遵循我们已经学习过的相同的顺序，但是，这一次<code class="fe lv lw lx ly b">getImages</code>和<code class="fe lv lw lx ly b">applyFilters</code>是需要大量时间执行的缓慢操作，由于它们，主线程被阻塞，这意味着，<strong class="kc io">页面冻结，我们不能在输入中输入任何内容，也不能触发任何事件。</strong></p><p id="a088" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注:</strong></p><ol class=""><li id="f8df" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">当程序处于阻塞状态时，链接、事件监听器或函数都不起作用。</li><li id="7d15" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">您可以通过在浏览器的开发人员控制台窗口中运行任何无限或繁重的操作来轻松复制阻塞行为。这种操作的一个例子是:</li></ol><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="e66e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是运行此代码的结果:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/0275a600c45a3dd8d030435f785ee6f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Db2Td1kO-gIgBH-0t9R-Lg.gif"/></div></div></figure><p id="b25b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你所注意到的，页面被冻结了，没有一个事件在起作用，所以，我们可以清楚地说这不是一个理想的情况，所以为了克服它，为了避免我们所有人编写阻塞代码，JavaScript提出了<strong class="kc io">异步的概念。</strong></p><p id="f430" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据维基百科:</p><blockquote class="mz na nb"><p id="2830" class="ka kb lt kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated"><strong class="kc io">异步</strong>，在计算机编程中，是指独立于主程序流程的事件的发生以及处理这类事件的方式。</p></blockquote><p id="8031" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JavaScript的例子中，由于它是单线程语言，<strong class="kc io">异步</strong>意味着一次只执行一个任务，但是告诉环境在稍后的某个时间点执行特定的任务。</p><p id="2e5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的，但是我们如何用JavaScript写一个函数，在某个时间点之后被调用，或者如何写一个异步代码？</p><p id="e44a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对此最简单的回答是使用<strong class="kc io">异步回调</strong>。</p><h2 id="ff35" class="lz ma in bd mb mc md dn me mf mg dp mh kl mi mj mk kp ml mm mn kt mo mp mq mr bi translated"><strong class="ak">异步</strong>回调</h2><p id="2215" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">顾名思义，异步<strong class="kc io"> </strong>回调是在另一个函数完成执行时调用的函数。它使我们的代码非阻塞，并为我们的代码提供异步行为。</p><p id="dc85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浏览器为我们提供了一个名为<code class="fe lv lw lx ly b">setTimeout()</code>的函数，它接受两个参数，第一个是回调函数，第二个是回调函数应该执行的最小持续时间。让我们借助一个简单的例子来看看它是如何工作的:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="193e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，回调函数在程序执行一秒钟后被调用。</p><p id="2dc9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，上面的例子本质上是异步的，但是它是如何在调用栈或JavaScript引擎中工作的呢？</p><p id="5aae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们借助一段视频来了解一下:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="nf lr l"/></div></figure><p id="da17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您所注意到的，除了<strong class="kc io">调用堆栈，</strong>现在我们还有一列用于<strong class="kc io">Web API</strong>和一行用于<strong class="kc io">回调队列</strong>。</p><p id="5b39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，为了理解执行，让我们来分解一下这些东西是如何工作的:</p><ol class=""><li id="555d" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">任何异步任务(就像本例中的回调函数)都会和它的定时器(如果有的话)一起被添加到Web APIs列中。</li><li id="368e" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">一旦计时器结束，回调函数将被添加到回调队列中。</li><li id="e2e1" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">现在，<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">事件循环的</a>任务是遍历堆栈和队列，如果堆栈为空，它将队列中的第一个任务推送到堆栈上，从而有效地运行该任务。</li></ol><p id="0c9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了更好地理解它，我们来看另一个例子，这次我们将持续时间设置为0:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="6fa6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一次没有立即调用回调，因为事件循环等待堆栈为空，以将任务推送到队列中。让我们借助一个小视频来了解一下执行情况:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="nf lr l"/></div></figure><p id="5c27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>从上面的例子我们可以得知，setTimeout()函数中提到的持续时间是回调函数被调用或执行的最小 <strong class="kc io">持续时间</strong><strong class="kc io">。</strong></p><p id="76cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想了解更多关于事件循环、web APIs和其他相关术语的信息，那么<a class="ae jz" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">这段</strong> </a>视频非常值得一看。另外，<a class="ae jz" href="http://latentflip.com/loupe/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">这里的</strong> </a>是我用来展示JavaScript引擎工作的网站链接。</p><h2 id="db89" class="lz ma in bd mb mc md dn me mf mg dp mh kl mi mj mk kp ml mm mn kt mo mp mq mr bi translated">顺序执行多个异步操作</h2><p id="9b21" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">假设我们现在必须顺序执行多个异步操作，因为这些操作都是异步的，所以我们必须使用异步回调来避免阻塞线程。那么，让我们看看如何实现这一目标:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/df75ec4a011a5105cfeb6a925dd367db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*Nt33J1sdIPhgxw7Wp2dhFA.png"/></div></figure><p id="9dc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以清楚地看到，现在我们的代码很难理解和维护，而且不可伸缩。这种情况被称为<code class="fe lv lw lx ly b">Callback hell</code>或<code class="fe lv lw lx ly b">Pyramid of Doom</code>。</p><p id="e635" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于回调的可读性更差，复杂性更高，因此引入了承诺的概念。让我们看看Promises是如何解决这个问题的。</p><h2 id="9cc9" class="lz ma in bd mb mc md dn me mf mg dp mh kl mi mj mk kp ml mm mn kt mo mp mq mr bi translated">承诺</h2><p id="db09" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">承诺是包装异步代码并在完成时发出通知的对象。它代表了一个可能还不可用但将来会有的值。它帮助我们以同步的方式编写异步代码。</p><p id="5405" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">允诺对象由允诺人和被允诺人组成。承诺状态可能有3个不同的值:</p><ul class=""><li id="82c7" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx nh le lf lg bi translated">待定(初始状态，既未解决也未拒绝)</li><li id="a9a1" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">已解决(表示操作成功)</li><li id="aa22" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">拒绝(意味着操作失败)</li></ul><p id="b45a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">PromiseValue由操作的结果组成，如果成功可能是数据，如果失败可能是错误。</p><p id="f107" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">承诺有三种执行方法，具体取决于承诺的状态:</p><ul class=""><li id="9814" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx nh le lf lg bi translated">。然后(如果承诺已解决，则执行)</li><li id="1e1f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">。catch(承诺被拒绝时执行)</li><li id="dc9c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">。最终(在承诺已解决或已拒绝时执行)</li></ul><p id="f8fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有这些方法都接受一个函数并返回另一个承诺。</p><p id="6be3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看返回承诺的异步代码的基本语法:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="a636" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们一行一行地理解上面的例子:</p><ol class=""><li id="c5bd" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">一些异步代码被执行，它返回一个承诺。</li><li id="0da0" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如果承诺的状态为<code class="fe lv lw lx ly b">resolved</code>，那么将执行<code class="fe lv lw lx ly b">.then()</code>函数中的代码。</li><li id="aac4" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">如果返回的承诺的状态为<code class="fe lv lw lx ly b">rejected</code>，那么<code class="fe lv lw lx ly b">.catch()</code>中的代码将被执行。</li></ol><p id="956c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>有时你有多个异步任务，你想按顺序执行，你也需要把上一步的结果传递给下一步，在这种情况下，你可以把<code class="fe lv lw lx ly b">.then()</code>方法链接起来，这样每个方法执行一个特定的任务，它的结果将在下一个任务的执行中有用。</p><p id="15fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来理解它在我们的图像示例中是如何工作的:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="0ea5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们可以注意到，这次我们的代码更具可读性和可伸缩性，因此与回调相比，承诺更易于使用，因为它们使我们的代码更具可读性，更易于维护。</p><p id="910b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>可以链接多个<code class="fe lv lw lx ly b">.then()</code>方法，但只允许使用一个<code class="fe lv lw lx ly b">.catch()</code>方法。因此，如果在执行任何一个<code class="fe lv lw lx ly b">.then()</code>方法时出现错误，那么<code class="fe lv lw lx ly b">.catch()</code>方法会捕获该错误并执行传递给它的函数。</p><p id="d81a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一张图片，可以帮助您直观地看到这一点:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/f11572cbfc729549f22a42ead2a13767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YMjYu7HaimryurzyAHs6Gw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Credits: <a class="nj nk ep" href="https://medium.com/u/78e5e4ccd675?source=post_page-----9b63972290c2--------------------------------" rel="noopener" target="_blank">Kevin Kim</a></figcaption></figure><p id="d61e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">记住这些知识，让我们写一些实际的代码来更好地理解它。我们将使用<code class="fe lv lw lx ly b"><strong class="kc io">fetch API</strong></code>向<a class="ae jz" href="https://jsonplaceholder.typicode.com/todos/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1</a>发出一个<code class="fe lv lw lx ly b">GET</code>请求。</p><h2 id="a50e" class="lz ma in bd mb mc md dn me mf mg dp mh kl mi mj mk kp ml mm mn kt mo mp mq mr bi translated">获取API</h2><p id="dbca" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">Fetch API提供了在<code class="fe lv lw lx ly b">window</code>对象上定义的<code class="fe lv lw lx ly b">fetch()</code>方法，用于执行请求。该方法返回一个承诺，您可以用它来检索请求的响应。</p><p id="c707" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在实践中看看:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="f5ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们一步一步解码:</p><ul class=""><li id="19b6" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx nh le lf lg bi translated">Fetch方法接收一个<code class="fe lv lw lx ly b">url</code>，从中读取/发送数据。</li><li id="a82f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">作为<code class="fe lv lw lx ly b">GET</code>请求的结果，它返回一个承诺。</li><li id="f01f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">如果承诺的状态为<code class="fe lv lw lx ly b">resolved</code>，那么执行第一个<code class="fe lv lw lx ly b">.then()</code>方法，将响应解析为JSON。</li><li id="9384" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">第一个<code class="fe lv lw lx ly b">.then()</code>方法执行后，返回的结果被传递到第二个<code class="fe lv lw lx ly b">.then()</code>方法，该方法将数据打印到控制台。</li><li id="1de2" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx nh le lf lg bi translated">如果承诺的状态为<code class="fe lv lw lx ly b">rejected</code>，那么将执行<code class="fe lv lw lx ly b">.catch()</code>方法，将<code class="fe lv lw lx ly b">error</code>打印到控制台。</li></ul><p id="93d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是如何使用<code class="fe lv lw lx ly b">Fetch</code>方法生成一个简单的<code class="fe lv lw lx ly b">GET</code>请求。现在，我们将看到另一个发出<code class="fe lv lw lx ly b">POST</code>请求的例子。我们将向<a class="ae jz" href="https://jsonplaceholder.typicode.com/posts'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts</a>发出帖子请求，以创建一个帖子:</p><figure class="lm ln lo lp gt jo"><div class="bz fp l di"><div class="ls lr l"/></div></figure><p id="01bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，除了URL，我们还传递了一个对象，该对象由发出<code class="fe lv lw lx ly b">POST</code>请求所需的方法、主体和头组成。该方法指定了API请求的类型，<code class="fe lv lw lx ly b">body</code>由我们正在创建的新post数据组成，<code class="fe lv lw lx ly b">headers</code>由<code class="fe lv lw lx ly b">Content-type</code>组成。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="6473" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文到此为止，我们将在下一篇文章中讨论本系列的最后一个主题。</p><p id="df54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和往常一样，为了结束这篇文章，我将留给你们一个简单的<code class="fe lv lw lx ly b">React Component</code>，它使用了上述概念:</p><figure class="lm ln lo lp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/3f3b44ec2b1c2705807aefceea0eb282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*260KXB1lxjP1nnKthv-COw.png"/></div></div></figure><p id="01e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，检查之前的部分(如果你没有):</p><div class="nt nu gp gr nv nw"><a href="https://medium.com/javascript-in-plain-english/things-to-learn-before-learning-a-javascript-framework-b7baec310247" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">学习JavaScript框架之前需要了解的事情(第1部分)</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">因此，在这一系列的文章中，我将尝试解释一些我认为真正…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok jt nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://medium.com/javascript-in-plain-english/object-and-array-methods-to-learn-before-javascript-frameworks-59728dcea306" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">JavaScript框架之前要学习的对象和数组方法(第2部分)</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">JavaScript中可以应用于对象和数组的不同类型的方法</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="ol l oh oi oj of ok jt nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://medium.com/javascript-in-plain-english/how-to-use-npm-and-import-export-modules-in-javascript-31a7f66a2064" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">如何在JavaScript中使用NPM(和导入/导出模块)(第4部分)</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">学习JavaScript框架之前要学习的NPM命令和导入/导出模块</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="om l oh oi oj of ok jt nw"/></div></div></a></div><p id="4fe2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想和我联系，请点击下面的链接:</p><p id="00bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.linkedin.com/in/rajat-verma-39458317b/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae jz" href="https://github.com/rajat2502" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae jz" href="https://twitter.com/rajatverma2502" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>