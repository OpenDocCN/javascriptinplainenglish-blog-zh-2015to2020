<html>
<head>
<title>List of JavaScript Antipatterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript反模式列表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/list-of-javascript-antipatterns-77b4e0274292?source=collection_archive---------6-----------------------#2020-04-30">https://javascript.plainenglish.io/list-of-javascript-antipatterns-77b4e0274292?source=collection_archive---------6-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/87aec8b09e7dd6dc78ab8a5f4e6f2735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sFTEKtdyYmjBCoPx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@cassidyjames?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cassidy James Blaede</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6048" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种在很多地方都被广泛使用的语言，包括web开发等等。</p><p id="294f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何其他语言一样，当我们用JavaScript编程时，很容易提交反模式。</p><p id="a685" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些我们应该避免的反模式。</p><h1 id="a52f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">污染全局名称空间</h1><p id="4af7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">污染全局名称空间是不好的，因为它会导致名称冲突，</p><p id="0205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有严格模式，也很容易意外声明全局变量。</p><p id="e79d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果没有严格模式，我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fcfd" class="mn lc iq mj b gy mo mp l mq mr">x = 1;</span></pre><p id="1640" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d397" class="mn lc iq mj b gy mo mp l mq mr">window.x = 1;</span></pre><p id="da14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">window</code>是浏览器JavaScript中的全局对象。</p><p id="a642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">全局变量在任何地方都是可访问的，因此我们可以在任何地方改变它们的值。</p><p id="0853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不好，因为我们不想因为意外的重新分配而遇到错误。</p><p id="1d86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">意外分配的一个例子是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4640" class="mn lc iq mj b gy mo mp l mq mr">function foo() {<br/>  return 1;<br/>}</span><span id="d98a" class="mn lc iq mj b gy mv mp l mq mr">function bar() {<br/>  for (i = 0; i &lt; 10; i++) {}<br/>}</span><span id="b2bb" class="mn lc iq mj b gy mv mp l mq mr">i = foo();<br/>bar();</span></pre><p id="c85b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在很多地方都给<code class="fe ms mt mu mj b">i</code>赋值。<code class="fe ms mt mu mj b">i</code>被混乱地分配到多个地方。</p><h1 id="b351" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">扩展对象原型</h1><p id="8fb8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该给<code class="fe ms mt mu mj b">Object.prototype</code>添加任何新的属性。</p><p id="d5d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它是全球性的。这将影响其他对象，因为几乎所有对象都扩展了<code class="fe ms mt mu mj b">Object.prototype</code>。</p><p id="d433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果每个人都这样做，人们很容易用自己的代码覆盖<code class="fe ms mt mu mj b">Object</code>的原型。</p><p id="4abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，如果我们想要控制对象的属性，我们应该使用<code class="fe ms mt mu mj b">Object.defineProperty</code>来定义带有属性描述符的属性。</p><h1 id="9508" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用多个var声明而不是一个</h1><p id="7b32" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">多个<code class="fe ms mt mu mj b">var</code>声明可读性较差，速度稍慢，所以不用编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0b16" class="mn lc iq mj b gy mo mp l mq mr">var a = 1;<br/>var b = 2;<br/>var c = 3;</span></pre><p id="b19c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a32e" class="mn lc iq mj b gy mo mp l mq mr">var a = 1,<br/>  b = 2,<br/>  c = 3;</span></pre><h1 id="eec0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用新数组()、新对象()、新字符串()和新数字()</h1><p id="f75e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">没有理由使用<code class="fe ms mt mu mj b">Array</code>构造函数。这令人困惑，因为单参数版本和多参数版本做不同的事情。</p><p id="7ee0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单参数版本接受一个数字，并返回一个长度由参数设置的数组。</p><p id="8643" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多参数版本将数组的内容作为参数。我们可以传入尽可能多的数据来填充新数组。</p><p id="9c5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f366" class="mn lc iq mj b gy mo mp l mq mr">const arr = new Array(5);</span></pre><p id="ff40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回一个有5个空槽的数组。</p><p id="049c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7efd" class="mn lc iq mj b gy mo mp l mq mr">const arr = new Array(1, 2, 3);</span></pre><p id="a2a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe ms mt mu mj b">[1, 2, 3]</code>。</p><p id="e55b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用数组文字来简化我们的工作:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="349f" class="mn lc iq mj b gy mo mp l mq mr">const arr = <!-- -->[1, 2, 3];</span></pre><p id="6d6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样更简单，也不那么混乱。</p><p id="62a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，<code class="fe ms mt mu mj b">new Object()</code>只是多余的文字。如果要添加属性，我们必须在不同的行上定义属性，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a3f4" class="mn lc iq mj b gy mo mp l mq mr">const obj = new Object();<br/>obj.a = 1;<br/>obj.b = 2;<br/>obj.c = 3;</span></pre><p id="5a75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">obj</code>的值就是<code class="fe ms mt mu mj b">{a: 1, b: 2, c: 3}</code>。</p><p id="b504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那只是额外的写作。相反，我们应该使用对象文字:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4d14" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}</span></pre><p id="f3e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打字更少，也很清晰。</p><p id="f301" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">new String()</code>和<code class="fe ms mt mu mj b">new Number()</code>的问题是它们给了我们类型<code class="fe ms mt mu mj b">'object'</code>。我们没有理由需要字符串和数字拥有类型<code class="fe ms mt mu mj b">'object'</code>。</p><p id="985c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想把它们转换回原始值，我们必须调用<code class="fe ms mt mu mj b">valueOf()</code>。</p><p id="c88b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用工厂函数<code class="fe ms mt mu mj b">String()</code>和<code class="fe ms mt mu mj b">Number()</code>将东西转换为字符串或数字。</p><p id="7cc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e7e9" class="mn lc iq mj b gy mo mp l mq mr">const str = new String(1);</span></pre><p id="92f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b6bc" class="mn lc iq mj b gy mo mp l mq mr">const str = String(1);</span></pre><p id="fecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9c1e" class="mn lc iq mj b gy mo mp l mq mr">const num = new Number('1');</span></pre><p id="4da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="db9f" class="mn lc iq mj b gy mo mp l mq mr">const num = Number('1');</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d4ef3903e5045fa1c8a1a11d3254347a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f28JIEpcYHOPkFP_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@berkaygumustekin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Berkay Gumustekin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="dda6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">依赖于像<code class="fe ms mt mu mj b">.map</code>和<code class="fe ms mt mu mj b">.filter</code>这样的迭代器函数的排序</h1><p id="4980" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该依赖<code class="fe ms mt mu mj b">forEach</code>、<code class="fe ms mt mu mj b">map</code>、<code class="fe ms mt mu mj b">filter</code>的迭代顺序。</p><p id="96f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe ms mt mu mj b">async</code>函数作为过滤器传递，迭代也不起作用。</p><p id="93fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要以特定的顺序迭代事物，那么我们应该在迭代之前按照我们想要的方式对它们进行排序。</p><p id="3a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，如果我们想使用条目的索引，我们可以将它传递给回调函数，这样我们就可以可靠地获得索引。</p><p id="6c09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来获取回调中的<code class="fe ms mt mu mj b">index</code>和原始数组，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="468f" class="mn lc iq mj b gy mo mp l mq mr">const nums = [1, 2, 3];<br/>nums.forEach((num, index, nums) =&gt; {<br/>  if (index === nums.length - 1) {<br/>    console.log('end');<br/>  }<br/>})</span></pre><p id="a18b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="917c" class="mn lc iq mj b gy mo mp l mq mr">const nums = [1, 2, 3];<br/>let count = 0;<br/>nums.forEach((num) =&gt; {<br/>  if (count === nums.length - 1) {<br/>    console.log('end');<br/>  }<br/>  count++<br/>})</span></pre><p id="967f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不仅第二个例子更复杂，而且也不太可靠，因为我们可能会不小心在其他地方改变<code class="fe ms mt mu mj b">count</code>。</p><p id="da8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，从回调参数访问索引和原始数组意味着没有机会在外部修改<code class="fe ms mt mu mj b">count</code>。</p><p id="d8d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也适用于<code class="fe ms mt mu mj b">map</code>和<code class="fe ms mt mu mj b">filter</code>。</p><h1 id="4e4d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4209" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该避免像全局变量这样的反模式，不必要的构造函数的使用，以及扩展<code class="fe ms mt mu mj b">Object</code>的原型。</p><p id="ce24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，因为我们可以从参数中访问数字，所以我们不应该创建变量来跟踪外部的索引。</p><h2 id="7f46" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="05c4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！</p><p id="20b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>