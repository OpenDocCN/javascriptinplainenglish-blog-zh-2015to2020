<html>
<head>
<title>Is mapStateToProps causing needless re-renders?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">mapStateToProps会导致不必要的重新渲染吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/is-mapstatetoprops-causing-needless-re-renders-6d14346b3cb8?source=collection_archive---------6-----------------------#2020-06-06">https://javascript.plainenglish.io/is-mapstatetoprops-causing-needless-re-renders-6d14346b3cb8?source=collection_archive---------6-----------------------#2020-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b4fbbae850a4b49e971c446b90b996c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hQKZ70wmQKEM2Jr1NZpYQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Pictured: simple redux flow between connected components 😫</figcaption></figure><p id="a7fd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您是一名React开发人员，从事的项目并不简单，那么您可能会使用Redux进行状态管理。简单地说，你连接的组件都在监听应用程序的全局状态<code class="fe la lb lc ld b">store</code>的任何更新，你的<code class="fe la lb lc ld b">mapStateToProps</code>函数获取这个状态的一部分，并将其作为道具返回给你连接的组件。</p><p id="767e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我最近在处理一个奇怪的bug，它涉及一个redux-connected组件:一个用户将鼠标悬停在我们饼图组件的一部分上，有时饼图中心的标签会恢复到默认标签…嗯。出于某种原因，我们的饼图被重新呈现，即使它的状态没有更新。双hmmm…</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi le"><img src="../Images/3cc661493f5a9b24d6e4069d5a72179a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*8FNqmQdm_bey9FJk7tmFSQ.gif"/></div></figure><p id="dc24" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种间歇性的错误很难重现，但一旦它与使用实时套接字更新的小部件共享商店，我注意到每次我们的商店收到实时更新时都会发生这种情况。</p><p id="f044" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">组件应该在每次存储收到更新时重新呈现吗——即使它对状态的特定部分不感兴趣？不，那不可能是对的。那么我们的<code class="fe la lb lc ld b">mapStateToProps</code>函数如何理解何时应该触发重新渲染呢？嗯，在引擎盖下，redux通过实现<code class="fe la lb lc ld b">shouldComponentUpdate</code>方法对从<code class="fe la lb lc ld b">mapStateToProps</code>返回的状态做了一个简单的比较。有意思。但还是不能解释为什么我们的派会变得怪异。</p><p id="aca3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是我们的饼状图代码的简化版本:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="677d" class="ln lo iq ld b gy lp lq l lr ls">import React from 'react';<br/>import { connect } from 'react-redux';<br/><br/>import PieChartWidget from './components/PieChartWidget';<br/><br/>const mergeProps = (stateProps, dispatchProps, ownProps) =&gt; {<br/>  return {...ownProps, ...dispatchProps, ...stateProps};<br/>};<br/><br/>const mapStateToProps = (state, ownProps) =&gt; {<br/>  const data = state.widgetData;<br/>  const apiArgs = { ...ownProps.apiArgs }; //OOPS!!!!</span><span id="bdcf" class="ln lo iq ld b gy lt lq l lr ls">  return {<br/>    data,<br/>    apiArgs<br/>  };<br/>};<br/><br/>const IssuesPieChart = ({<br/>  apiArgs,<br/>  data,<br/>}) =&gt; (<br/>  &lt;DataLoader<br/>    apiArgs={apiArgs}<br/>    {...others}<br/>  &gt;<br/>    &lt;PieChartWidget<br/>      data={data}<br/>    /&gt;<br/>  &lt;/Widget&gt;<br/>);<br/><br/>export default connect(mapStateToProps, mapWidgetDispatchToProps, mergeProps)(IssuesPieChart);</span></pre><p id="760b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">事实证明，我们在<code class="fe la lb lc ld b">mapStateToProps</code>函数中犯了一个诚实的错误，使用spread <code class="fe la lb lc ld b">...</code>操作符复制状态。哦。像<code class="fe la lb lc ld b">slice, concat, filter</code>或<code class="fe la lb lc ld b">...</code>这样的常见数组操作创建一个对对象或数组的新引用，当redux在内部比较新旧状态时，它将触发组件更新。</p><p id="ae9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里的快速解决方法是简单地像这样分配我们的状态:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="069a" class="ln lo iq ld b gy lp lq l lr ls">const mapStateToProps = (state, ownProps) =&gt; {<br/>  const data = state.widgetData;<br/>  const apiArgs = ownProps.apiArgs;</span><span id="983d" class="ln lo iq ld b gy lt lq l lr ls"> return {<br/>    data,<br/>    apiArgs<br/>  };<br/>};</span></pre><p id="6f3f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您的用例比较复杂，并且对您关心的状态树的一部分进行了一些过滤或选择，您可能想要检查内存化的选择器函数，以避免昂贵的比较和不必要的重新呈现:<a class="ae lu" href="https://redux.js.org/recipes/computing-derived-data#creating-a-memoized-selector" rel="noopener ugc nofollow" target="_blank">https://redux . js . org/recipes/computing-derived-data # creating-a-memo ized-selector</a></p><h2 id="21ae" class="ln lo iq bd lv lw lx dn ly lz ma dp mb kn mc md me kr mf mg mh kv mi mj mk ml bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="87c6" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae lu" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">订阅我们的YouTube频道</strong> </a> <strong class="ke ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>