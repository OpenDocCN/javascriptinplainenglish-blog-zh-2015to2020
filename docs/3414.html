<html>
<head>
<title>How to Slim Down Your Bundle Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何减少你的包裹尺寸</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/slimming-down-your-bundle-size-d59db04c95d9?source=collection_archive---------5-----------------------#2020-09-27">https://javascript.plainenglish.io/slimming-down-your-bundle-size-d59db04c95d9?source=collection_archive---------5-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0b3c602150a1e232a9a9d6fd06594c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ay-LHFzuA58drtN0"/></div></div></figure><p id="2f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使我们今天有更快的计算机和移动设备，我们作为开发人员也应该考虑我们作为一个整体来构建产品的受众。并不是每个人都可以使用相同类型的快速设备或使用最快的互联网。因此，我们需要更广泛地看待性能问题。可以通过许多不同的方式来追求性能，但是对于本文，我们将重点关注前端性能。我们更仔细地研究了这一方面，并对这一领域可能的改进提出了建议。</p><h1 id="763b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">前端性能</h1><p id="1b44" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">前端性能优化至关重要，因为<a class="ae lz" href="http://www.stevesouders.com/blog/2012/02/10/the-performance-golden-rule/" rel="noopener ugc nofollow" target="_blank">它约占用户响应时间</a>的80–90%。因此，当用户等待页面加载时，大约80–90%的时间是由于前端相关的代码和资产。<a class="ae lz" href="http://www.stevesouders.com/" rel="noopener ugc nofollow" target="_blank">下图</a>显示了LinkedIn要加载的前端/后端资产的比例。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/3b4dbcdd051ce850c5b62d6264e872d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*_H_rUgOMx7PTVyAg"/></div></figure><p id="79b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端加载时间的很大一部分花费在执行JavaScript文件和呈现页面上。但是提高前端性能的一个关键部分是减少应该通过网络下载的JavaScript包的大小。JavaScript包越小，用户访问页面的速度就越快。</p><p id="c365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://www.keycdn.com/support/the-growth-of-web-page-size" rel="noopener ugc nofollow" target="_blank">如果我们看看历史数据</a>，我们可以看到2010年JavaScript文件平均为2KB。但是随着JavaScript的发展，新的JavaScript库的引入，像<a class="ae lz" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>或<a class="ae lz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React、</a>和<a class="ae lz" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank">单页应用的概念</a>，平均JavaScript资产大小已经<a class="ae lz" href="https://www.keycdn.com/support/the-growth-of-web-page-size" rel="noopener ugc nofollow" target="_blank">增加到2016年的357 kb</a>。我们需要利用这些新技术找到更好的解决方案。但是我们也需要考虑一些可能的方法来提高它们的性能，比如减少整个JavaScript包的大小。但是在深入这个主题之前，我们需要熟悉JavaScript包。它们到底是什么？</p><h1 id="dead" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">JavaScript包</h1><p id="c4f4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您的前端应用程序需要一堆JavaScript文件来运行。这些文件可以是内部依赖的格式，就像您自己编写的JavaScript文件一样。它们也可以是您用来构建应用程序的外部依赖项和库，如<a class="ae lz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae lz" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>或<a class="ae lz" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>。因此，为了让您的页面第一次加载，应用程序需要能够访问这些JavaScript文件。那么我们如何揭露他们呢？</p><p id="a894" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去，公开JavaScript文件的方式要简单得多。大多数网页不需要很多JavaScript资源。由于我们无法获得标准的<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">所需的</a>依赖，我们不得不依赖于使用全局依赖。假设我们既需要jQuery，也需要保存所有应用程序JavaScript逻辑的<code class="fe mf mg mh mi b">main.js</code>和<code class="fe mf mg mh mi b">other.js</code>。我们能够公开这些依赖关系的方式如下所示:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="994b" class="mn kx iq mi b gy mo mp l mq mr">&lt;script src="/js/main.js"&gt;&lt;/script&gt;<br/>&lt;script src="/js/other.js"&gt;&lt;/script&gt;<br/>&lt;script src="//code.jquery.com/jquery-1.12.0.min.js"&gt;&lt;/script&gt;</span></pre><p id="bfb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个问题，这是一个简单的解决方案，但是在扩展应用程序时很快就失控了。例如，如果<code class="fe mf mg mh mi b">main.js</code>的变化依赖于<code class="fe mf mg mh mi b">other.js</code>中的代码，我们需要像这样重新排序我们的脚本标签:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="2571" class="mn kx iq mi b gy mo mp l mq mr">&lt;script src="/js/other.js"&gt;&lt;/script&gt;<br/>&lt;script src="/js/main.js"&gt;&lt;/script&gt;<br/>&lt;script src="//code.jquery.com/jquery-1.12.0.min.js"&gt;&lt;/script&gt;</span></pre><p id="13d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所见，大规模管理这样的代码结构会很快变得一团糟。但是过了一段时间，在应用程序中有了更好的解决方案。例如，如果您使用的是<a class="ae lz" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>，您可以依赖NodeJS自己的模块系统(基于<a class="ae lz" href="http://wiki.commonjs.org/wiki/Modules/1.1" rel="noopener ugc nofollow" target="_blank"> commonJS规范</a>)。这将允许您使用<a class="ae lz" href="https://nodejs.org/en/knowledge/getting-started/what-is-require/" rel="noopener ugc nofollow" target="_blank"> require函数</a>来获得所需的依赖项。因此，在节点环境中，我们上面的代码片段应该是这样的:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="dbf4" class="mn kx iq mi b gy mo mp l mq mr">&lt;script&gt;<br/>  var jQuery = require('jquery')<br/>  var main = require('./js/main')<br/>  var other = require('./js/other')<br/>&lt;/script&gt;</span></pre><p id="343e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您不仅仅需要几个JavaScript文件来运行您的应用程序。您的应用程序的JavaScript依赖项可能包括数百或数千个文件，很明显不可能像上面的代码片段那样列出它们。这有几个原因:</p><ul class=""><li id="ff5a" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">当应用程序的不同部分需要不同的依赖关系时，将JavaScript资产分离到不同的文件中确实需要大量的HTTP请求。这将不是高性能的，需要很多时间</li><li id="c56f" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">此外，NodeJS <code class="fe mf mg mh mi b">require</code>是同步的，但是我们希望它是异步的，并且如果资产还没有下载，就不要阻塞主线程</li></ul><p id="c3ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，最好的方法似乎是将所有的JavaScript代码放在一个JavaScript文件中，并处理其中的所有依赖关系。嗯，这是一个<a class="ae lz" href="https://blog.bitsrc.io/choosing-the-right-javascript-bundler-in-2020-f9b1eae0d12b" rel="noopener ugc nofollow" target="_blank"> JavaScript捆绑器</a>的基本工作。尽管不同的捆扎机对此可以有不同的策略。让我们进一步探讨一下，看看捆扎机是如何做到这一点的。然后，我们将看看是否有额外的改进可以实现更小的包大小，从而获得更高的性能。出于本文的目的，我们将使用<a class="ae lz" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>作为捆绑器，这是最著名的选项之一。</p><h1 id="d4be" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用Webpack构建示例包</h1><p id="9359" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们从建立一个简单的Webpack项目开始。我们将使用基本包来启动一个简单的web应用程序项目。<a class="ae lz" href="https://www.npmjs.com/package/react" rel="noopener ugc nofollow" target="_blank"> React </a>，<a class="ae lz" href="https://www.npmjs.com/package/react-dom" rel="noopener ugc nofollow" target="_blank"> ReactDOM </a>作为UI框架，<a class="ae lz" href="https://blog.logrocket.com/why-you-should-use-swc/" rel="noopener ugc nofollow" target="_blank"> SWC作为Babel </a>的更快替代方案用于传输，以及一系列Webpack工具和加载器。这就是我们的<code class="fe mf mg mh mi b"><a class="ae lz" href="https://docs.npmjs.com/files/package.json" rel="noopener ugc nofollow" target="_blank">package.json</a></code>的样子:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="5e29" class="mn kx iq mi b gy mo mp l mq mr">// package.json</span><span id="b737" class="mn kx iq mi b gy ng mp l mq mr">{<br/>  "name": "project",<br/>  "version": "1.0.0",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "build": "rm -rf ./dist &amp;&amp; webpack",<br/>    "start": "webpack-dev-server"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "MIT",<br/>  "devDependencies": {<br/>    "@swc/core": "^1.1.39",<br/>    "css-loader": "^3.4.0",<br/>    "html-loader": "^0.5.5",<br/>    "html-webpack-plugin": "^3.2.0",<br/>    "sass-loader": "^8.0.0",<br/>    "style-loader": "^1.1.1",<br/>    "swc-loader": "^0.1.9",<br/>    "webpack": "^4.41.4",<br/>    "webpack-cli": "^3.3.10",<br/>    "webpack-dev-server": "^3.10.1"<br/>  },<br/>  "dependencies": {<br/>    "react": "^16.12.0",<br/>    "react-dom": "^16.12.0",<br/>    "regenerator-runtime": "^0.13.5"<br/>  }<br/>}</span></pre><p id="5add" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要一个<code class="fe mf mg mh mi b"><a class="ae lz" href="https://webpack.js.org/configuration/" rel="noopener ugc nofollow" target="_blank">webpack.config.js</a></code>，它是我们的Webpack命令的配置入口点。该文件中有几个选项，但让我们澄清几个重要的选项:</p><ul class=""><li id="3961" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><code class="fe mf mg mh mi b"><a class="ae lz" href="https://webpack.js.org/configuration/mode/" rel="noopener ugc nofollow" target="_blank">mode</a></code> —这是Webpack的一个选项，它可以根据传递给它的选项来判断是否应该进行任何优化。我们稍后将进一步讨论这一点</li><li id="077c" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe mf mg mh mi b"><a class="ae lz" href="https://webpack.js.org/configuration/output/" rel="noopener ugc nofollow" target="_blank">output</a></code> —该选项告诉Webpack应该在根级别将组装的包加载或放置在哪里。它接受路径和文件名</li><li id="d243" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe mf mg mh mi b"><a class="ae lz" href="https://webpack.js.org/plugins/html-webpack-plugin/" rel="noopener ugc nofollow" target="_blank">HTMLWebpackPlugin</a></code> —此选项有助于我们更轻松地使用Webpack捆绑包提供HTML文件</li><li id="b72e" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe mf mg mh mi b"><a class="ae lz" href="https://webpack.js.org/concepts/loaders/" rel="noopener ugc nofollow" target="_blank">loaders</a></code> —这些加载器插件帮助您将大多数现代编码语言特性转换成所有浏览器都可以理解的代码</li></ul><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="06ae" class="mn kx iq mi b gy mo mp l mq mr">// global dependencies<br/>const path = require('path');<br/>const HTMLWebpackPlugin = require("html-webpack-plugin");</span><span id="22c3" class="mn kx iq mi b gy ng mp l mq mr">module.exports = {<br/>  mode: "production",<br/>  // DOC: <a class="ae lz" href="https://webpack.js.org/configuration/output/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/configuration/output/</a><br/>  output: {<br/>    path: path.resolve(__dirname, './dist'),<br/>    filename: 'index_bundle.js'<br/>  },<br/>  // DOC: <a class="ae lz" href="https://webpack.js.org/configuration/dev-server/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/configuration/dev-server/</a><br/>  devServer: {<br/>    contentBase: path.join(__dirname, 'dist'),<br/>    compress: true,<br/>    port: 9000<br/>  },<br/>  module: {<br/>    rules: [<br/>        {<br/>        test: /\.jsx?$/ ,<br/>        exclude: /(node_modules|bower_components)/,<br/>        use: {<br/>            // `.swcrc` in the root can be used to configure swc<br/>            loader: "swc-loader"<br/>        }<br/>      },<br/>      {<br/>        test: /\.html$/,<br/>        use: [<br/>          {<br/>            loader: "html-loader",<br/>            options: { minimize: true }<br/>          }<br/>        ]<br/>      },<br/>      {<br/>        test: /\.scss/i,<br/>        use: ["style-loader", "css-loader", "sass-loader"]<br/>      }<br/>    ]<br/>  },<br/>  plugins: [<br/>    // DOC: <a class="ae lz" href="https://webpack.js.org/plugins/html-webpack-plugin/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/plugins/html-webpack-plugin/</a><br/>    new HTMLWebpackPlugin({<br/>      filename: "./index.html",<br/>      template: path.join(__dirname, 'public/index.html')<br/>    })<br/>  ]<br/>};</span></pre><h1 id="6ea4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">测量和分析</h1><p id="e3ce" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在，是时候为我们的Webpack构建进行一些初始测量了。当Webpack进行编译时，我们需要对构建的模块、编译速度和生成的依赖图进行某种统计。Webpack已经<a class="ae lz" href="https://webpack.js.org/api/stats/" rel="noopener ugc nofollow" target="_blank">为我们提供了工具</a>来获取这些统计数据，方法是运行一个简单的CLI命令:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="93b1" class="mn kx iq mi b gy mo mp l mq mr">webpack-cli --profile --json &gt; compilation-stats.json</span></pre><p id="e16f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过传递<code class="fe mf mg mh mi b">--json &gt; compilation-stats.json</code>，我们告诉Webpack生成构建统计数据和依赖图，作为一个具有我们指定名称的JSON文件。通过传递<code class="fe mf mg mh mi b">--profile</code>标志，我们可以获得关于单个模块的更详细的构建统计信息。运行这个命令后，你会得到一个<code class="fe mf mg mh mi b">json</code>文件，其中包含了很多有用的信息。但是为了使事情变得简单，我们将使用一个推荐的工具来可视化所有这些构建统计数据。你所需要做的就是将<code class="fe mf mg mh mi b">compilation-stats.json</code>拖动到这个<a class="ae lz" href="http://webpack.github.io/analyse/" rel="noopener ugc nofollow" target="_blank">官方分析工具</a>中的指定区域。这样做之后，我们得到以下结果。</p><h1 id="1196" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">网络包分析</h1><p id="fc59" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们得到下表，其中包含有关Webpack的一般信息，以构建分析:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/55b5a6553af15bf183dcbb581d3ac04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7VqiV-tqKqSp71SwVsdeQ.png"/></div></div></figure><h1 id="9b3c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">依赖图</h1><p id="69ac" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果我们单击dependency部分，我们会得到一个类似的图表，其中显示了我们的应用程序中不同的依赖关系，每个依赖关系的详细信息，以及它们是如何相互连接的。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5b0c72fdc6f857d16f1986dc044cf6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e5IlAzbtYWkQDd3o"/></div></div></figure><p id="12a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这些构建统计数据非常有用，但是由于我们将只关注于精简和优化我们的包大小，我们将使用一个名为<a class="ae lz" href="https://github.com/webpack-contrib/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank">Webpack-bundle-analyzer</a>的专门web pack工具。此工具将允许您可视化Webpack输出文件的大小，并向您显示一个交互式的可缩放树状图。让我们为我们的项目设置它。第一件事是安装软件包:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="b17c" class="mn kx iq mi b gy mo mp l mq mr">npm install --save-dev webpack-bundle-analyzer</span></pre><p id="e3d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们需要做的是在<code class="fe mf mg mh mi b">webpack.config.js</code>文件中设置相关的配置:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="8da5" class="mn kx iq mi b gy mo mp l mq mr">const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;</span><span id="50f0" class="mn kx iq mi b gy ng mp l mq mr">module.exports = {<br/>  plugins: [<br/>    new BundleAnalyzerPlugin()<br/>  ]<br/>}</span></pre><p id="3990" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您所要做的就是在您的<code class="fe mf mg mh mi b">package.json</code>中挂接一个脚本来运行分析器:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="fbac" class="mn kx iq mi b gy mo mp l mq mr">"scripts": {<br/>  "bundle-report": "webpack-bundle-analyzer --port 4200 compilation-stats.json"<br/>}</span></pre><p id="5251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在运行<code class="fe mf mg mh mi b">npm run-script bundle-report</code>之后，我们得到了包中内容的可视化表示，并看到它们中的哪些占据了大部分大小。这是我们项目的情况:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c9504c18edf008877b8d1c4455618b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4k2Qwcl7aI7uwpqv"/></div></div></figure><p id="db94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如我们所见，React依赖项占据了包的大部分大小。让我们看看对此我们能做些什么，来帮助我们减少总的包大小。</p><h1 id="6eb6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">捆绑包优化#1:在生产模式下运行Webpack</h1><p id="7881" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这种优化包和减少总包大小的策略简单明了。Webpack有一个产品标志(<code class="fe mf mg mh mi b">-p</code>)，它很少进行开箱即用的优化。因此，如果我们用下面的命令运行我们的构建脚本，我们应该得到一些优化:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="73ac" class="mn kx iq mi b gy mo mp l mq mr">// via command-line<br/> webpack-cli -p</span><span id="9ff6" class="mn kx iq mi b gy ng mp l mq mr">// via package.json script<br/>"scripts": {<br/>  "build": "rm -rf ./dist &amp;&amp; webpack -p",<br/>},</span></pre><p id="6b83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行这个之后，我们可以看到我们的包大小将从<strong class="ka ir"> 970KB </strong>减少到<strong class="ka ir"> 128KB </strong>。但是Webpack是如何用这样一个简单的命令来管理这种剧烈的优化的呢？这主要有两个原因:</p><ul class=""><li id="cf69" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">在引擎盖下，React将使用一个名为<a class="ae lz" href="http://lisperator.net/uglifyjs/" rel="noopener ugc nofollow" target="_blank"> UglifyJS </a>的插件，该插件通过删除任何不必要的空白或未使用的代码来处理代码缩减和死代码消除。</li><li id="164d" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">它还将<code class="fe mf mg mh mi b">NODE_ENV</code>投入生产。这样，像React这样的包就不会包含调试代码</li></ul><p id="766f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是减少我们的包大小和减少用户加载时间的一个很好的步骤。让我们看看我们还能做什么。</p><h1 id="6af8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">捆绑包优化#2:安装轻量级替代库</h1><p id="8829" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React的包大小仍然有点大(在我们的项目中是124KB)，即使在我们之前进行了优化之后。在检查webpack-bundle-analyzer报告时，我们可以看到React占用了我们的包大小的很大一部分。因此，我们将考虑用一个名为<a class="ae lz" href="https://preactjs.com/" rel="noopener ugc nofollow" target="_blank"> preact </a>的React的更轻版本来替换它，只有3KB大小。</p><p id="a79b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们将这个包作为依赖项安装时，我们同时获得了React API的核心和DOM支持；作为一个额外的步骤，我们可以安装<a class="ae lz" href="https://github.com/preactjs/preact-compat" rel="noopener ugc nofollow" target="_blank"> preact-compat </a>作为2KB大小的react的兼容层。这样，在我们的项目中，我们可以直接使用preact来替代react。Preact比react更具性能，正如我们在下面不同库之间的性能比较中所看到的，这些库用于构建一个简单的“待办事项”MVC基准:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/9e13e92dc7cf53b908418d95f63773e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E2CRmcACtDeqrGVe"/></div></div></figure><p id="2340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在，我们将为我们的项目安装Preact，看看它如何影响我们的包大小。我们首先安装preact和preact-compat:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="4784" class="mn kx iq mi b gy mo mp l mq mr">npm install preact preact-compat</span></pre><p id="a47c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们只需要在<code class="fe mf mg mh mi b">wepack.config.js</code>中设置<code class="fe mf mg mh mi b">alias</code> config，让这个库与你所有的React代码兼容:</p><pre class="mb mc md me gt mj mi mk ml aw mm bi"><span id="ca46" class="mn kx iq mi b gy mo mp l mq mr">// webpack.config.js</span><span id="ba91" class="mn kx iq mi b gy ng mp l mq mr">resolve: {<br/>  alias: {<br/>    "react": "preact-compat",<br/>    "react-dom": "preact-compat"<br/>  }<br/>},</span></pre><p id="4b1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在设置并运行我们的<code class="fe mf mg mh mi b">npm run-script bundle-report</code>之后，我们得到了下面的包分析。在这个交互图中，我们可以看到，与之前的124KB相比，React相关的包大小现在缩小到了23KB左右。这对我们来说是一个很大的缩减:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa39bb49531d6fa2f4c991ec1d13e01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aGczIFzdPUsJYHAa"/></div></div></figure><p id="b06c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mf mg mh mi b">webpack-bundle-analyzer</code>可以让我们直观地看到应用程序中安装的包。如果一个包占用了很多空间，我们可以考虑用一个更轻的版本库来代替它(就像我们上面做的)。</p><h1 id="2d28" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="290a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">到目前为止，我们能够将我们的包的大小从970Kb减少到23KB，这是我们的包大小的42倍。此外，请记住，我们的项目结构和依赖项都很小，但是主动为更大更复杂的项目减少捆绑包的大小会更有益。</p><p id="7fd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一些潜在的后续步骤，您可以采取这些步骤来减少包的大小和加载时间，并提高性能。</p><ul class=""><li id="a21a" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">考虑重写大型库，因为您可能不需要它的所有功能。例如，许多开发人员使用<a class="ae lz" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> Moment.js </a>来解析和验证JavaScript中的日期，这是一个很大的问题，但并不是每个人都需要整个库来进行简单的日期解析。考虑编写简单的实用函数，而不是依赖大型库</li><li id="0f83" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">检查您是否仅使用库的一个功能模块，该模块可以单独导入，而无需导入整个库。这个用例的一个很好的例子是<a class="ae lz" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>，您可以单独导入它的任何库实用函数</li><li id="4f17" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">最后考虑<a class="ae lz" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank">代码拆分</a>。并不是每一个依赖项都需要在每次页面加载时加载，所以将它们单独捆绑在一起是有意义的。例如，外部NPM依赖项不会像我们的应用程序代码那样改变很多。因此，将它们分割成一个单独的包将允许浏览器在它们没有被改变时缓存它们，从而减少每次页面加载需要加载的包的数量</li></ul><blockquote class="nj nk nl"><p id="0aee" class="jy jz nm ka b kb kc kd ke kf kg kh ki nn kk kl km no ko kp kq np ks kt ku kv ij bi translated">帖子最初发表在<a class="ae lz" href="https://blog.logrocket.com/slimming-down-your-bundle-size/" rel="noopener ugc nofollow" target="_blank"> LogRocket博客</a></p></blockquote><h1 id="111f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">资源</h1><ul class=""><li id="b87b" class="ms mt iq ka b kb lu kf lv kj nq kn nr kr ns kv mx my mz na bi translated"><a class="ae lz" href="https://www.sciencefocus.com/future-technology/can-computers-keep-getting-faster/" rel="noopener ugc nofollow" target="_blank">https://www . science focus . com/future-technology/can-computers-keep-getting-fast/</a></li><li id="9af6" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://www.keycdn.com/support/the-growth-of-web-page-size" rel="noopener ugc nofollow" target="_blank">https://www.keycdn.com/support/the-growth-of-web-page-size</a></li><li id="a4d1" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://medium.com/better-programming/reducing-js-bundle-size-58dc39c10f9c" rel="noopener">https://medium . com/better-programming/reducing-js-bundle-size-58dc 39 c 10 f 9 c</a></li><li id="496a" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://www.contentful.com/blog/2017/10/10/put-your-webpack-on-a-diet-part-1/" rel="noopener ugc nofollow" target="_blank">https://www . content ful . com/blog/2017/10/10/put-your-web pack-on-a-diet-part-1/</a></li><li id="8bb3" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://medium.com/@rajaraodv/using-preact-instead-of-react-70f40f53107c" rel="noopener">https://medium . com/@ rajaraodv/using-preact-instead-of-react-70f 40 f 53107 c</a></li><li id="f8a5" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://medium.com/a-young-devoloper/analyzing-and-reducing-react-bundle-size-bb2d2577b22a" rel="noopener">https://medium . com/a-young-devo oper/analyzing-and-reducing-react-bundle-size-bb2d 2577 b22a</a></li><li id="4f82" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://codeengineered.com/blog/why-front-end-performance-important/" rel="noopener ugc nofollow" target="_blank">https://code engineered . com/blog/why-前端-性能-重要/ </a></li><li id="6ccb" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="http://www.stevesouders.com/blog/2012/02/10/the-performance-golden-rule/" rel="noopener ugc nofollow" target="_blank">http://www . stevesouders . com/blog/2012/02/10/the-performance-golden-rule/</a></li><li id="144f" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://www.keycdn.com/support/the-growth-of-web-page-size" rel="noopener ugc nofollow" target="_blank">https://www.keycdn.com/support/the-growth-of-web-page-size</a></li><li id="e595" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://medium.com/better-programming/reducing-js-bundle-size-58dc39c10f9c" rel="noopener">https://medium . com/better-programming/reducing-js-bundle-size-58dc 39 c 10 f 9 c</a></li><li id="e261" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://medium.com/@gimenete/how-javascript-bundlers-work-1fc0d0caf2da" rel="noopener">https://medium . com/@ gimenete/how-JavaScript-bundlers-work-1 fc 0d 0 caf 2 da</a></li><li id="9028" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae lz" href="https://blog.jakoblind.no/3-ways-to-reduce-webpack-bundle-size/" rel="noopener ugc nofollow" target="_blank">https://blog . jakoblind . no/3-ways-to-reduce-web pack-bundle-size/</a></li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="74fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">更多内容请看</em><a class="ae lz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nm">plain English . io</em></strong></a><em class="nm">。报名参加我们的</em> <a class="ae lz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nm">免费周报</em> </strong> </a> <em class="nm">。关注我们关于</em><a class="ae lz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nm">Twitter</em></strong></a><em class="nm">和</em><a class="ae lz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nm">LinkedIn</em></strong></a><em class="nm">。加入我们的</em> <a class="ae lz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nm">社区不和谐</em> </strong> </a> <em class="nm">。</em></p></div></div>    
</body>
</html>