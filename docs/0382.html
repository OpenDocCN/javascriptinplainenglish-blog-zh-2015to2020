<html>
<head>
<title>Using a Grocery List to Understand props and state in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用购物清单理解React中的道具和状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-a-grocery-list-to-understand-props-and-state-in-react-f86eefbcc132?source=collection_archive---------4-----------------------#2019-09-30">https://javascript.plainenglish.io/using-a-grocery-list-to-understand-props-and-state-in-react-f86eefbcc132?source=collection_archive---------4-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d60d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释动态React组件的可变和不可变属性之间的区别</h2></div><p id="b173" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个基于组件构建的前端JavaScript库。这些组件代表了用户界面的独立“单元”,可以非常容易地重用。与静态HTML元素不同，React组件可以被定义为内置动态行为。问题是，这是如何实现的？</p><p id="04e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个例子，让我们试着在React中制作一个简单的购物清单。我们希望在HTML网页上呈现两种食品的列表——黄瓜和甘蓝。当你点击该商品时，会有一条删除线穿过，告诉你该商品已被购买。下次单击该项目可以删除该行。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/8b3f109037f38e84daf4824fef8c7c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_Bhl5iZdthdIcyzTCPdWA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">An example of the simple grocery list we wish to create using React.</figcaption></figure><p id="0631" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是JSX购物清单用户界面的整个结构:</p><pre class="lc ld le lf gt lr ls lt lu aw lv bi"><span id="42f8" class="lw lx iq ls b gy ly lz l ma mb">&lt;GroceryList <em class="mc">items</em>={["Cucumber", "Kale"]} /&gt;</span></pre><p id="fbae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单吧？这就是React的强大之处——我们可以模块化用HTML编写的复杂用户界面，直到整个应用程序被浓缩成几个(或者在这种情况下，一个)通用组件。</p><p id="06a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面GroceryList组件中的属性<em class="mc"> items </em>是一个名为<em class="mc"> props </em>的对象的一部分，该对象保存了JSX组件的所有属性。在这种情况下，道具看起来就像{ items: ["Cucumber "，" Kale"] }。</p><p id="aa3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Props在GroceryList组件的定义中是可访问的，如<em class="mc"> this.props </em>(因为props是GroceryList实例的属性):</p><pre class="lc ld le lf gt lr ls lt lu aw lv bi"><span id="f110" class="lw lx iq ls b gy ly lz l ma mb">import React <em class="mc">from</em> "react";<br/>import ReactDOM <em class="mc">from</em> "react-dom";</span><span id="aa1d" class="lw lx iq ls b gy md lz l ma mb">class GroceryList extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;ul&gt;<br/>        {this.props.items.map((item, index) =&gt; (<br/>          &lt;GroceryListItem item={item} key={index} /&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="b8c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GroceryList在HTML中呈现为一个无序列表，每个列表元素由一个GroceryListItem提供。请注意，数组中的JSX元素是从。map()只是按顺序呈现。</p><p id="cd68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个GroceryListItem代表this.props.items中的一个项目，就是数组["Cucumber "，" Kale"]。每个GroceryListItem的props对象有两个属性(“Item”和“key”)。</p><p id="89df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只需要定义GroceryListItem组件，并赋予它动态删除线行为:</p><pre class="lc ld le lf gt lr ls lt lu aw lv bi"><span id="de76" class="lw lx iq ls b gy ly lz l ma mb">class GroceryListItem extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      bought: false<br/>    };<br/>  }</span><span id="702b" class="lw lx iq ls b gy md lz l ma mb">  handleClick() {<br/>    this.setState({<br/>      bought: !this.state.bought<br/>    });<br/>  }</span><span id="2734" class="lw lx iq ls b gy md lz l ma mb">  render() {<br/>    let style = {<br/>      textDecoration: this.state.bought ? "line-through" : "none",<br/>    };<br/>    return (<br/>      &lt;li style={style} onClick={this.handleClick.bind(this)}&gt;<br/>        {this.props.item}<br/>      &lt;/li&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="5088" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喔，等一下！构造函数中的<em class="mc"> this.state </em>是什么意思？</p><p id="3090" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态是另一个对象，它是React组件的内部属性。在上面的代码中，this.state包含属性<em class="mc">buyed</em>，它指示我们是否已经购买了那个特定的GroceryListItem。如render()方法所示，如果商品已经购买，我们调整样式，以便textDecoration属性设置为line-through。</p><p id="6c24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们购买/取消购买项目的方式是通过onclick事件处理程序。当我们单击与GroceryListItem相对应的HTML li元素时，state . buyed更改为与其当前值相反的值。之后，render()方法重新呈现页面，因为this.setState()已被调用。</p><p id="89f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但接下来就有问题了:难道不能直接把买来的属性加到道具里吗？换句话说，难道我们不能写下面的代码，然后编辑这个. props . buyed吗？</p><pre class="lc ld le lf gt lr ls lt lu aw lv bi"><span id="104b" class="lw lx iq ls b gy ly lz l ma mb">&lt;GroceryListItem item={item} key={index} bought=false /&gt;</span></pre><p id="d277" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答案是否定的，因为React库中的一个通用规则:<strong class="kh ir">道具是只读的</strong>。React的理念是props，或者从父组件传递到子组件的数据应该是不可变的。改变一个道具可能会有有害的副作用，因为它可能会被UI层次结构中更高层的组件所依赖和改变。</p><p id="f702" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这个例子，假设buy确实是this.props的一个属性，我们使用onclick事件处理程序修改了它。但是，如果我们向GroceryList添加一个方法，导致整个GroceryList被重新呈现，那么每个GroceryListItem的buy属性将变回false——即使我们没有通过重新单击每个GroceryListItem来显式取消购买它们。</p><p id="2716" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，状态是完全封装的。除了在其中定义它的组件之外，其他组件无法访问它，因此动态编辑它是安全的。因此，有状态的GroceryListItem防止删除线被GroceryList移除，因为GroceryList将无法访问GroceryListItem的状态。</p></div></div>    
</body>
</html>