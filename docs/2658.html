<html>
<head>
<title>Node.js Tips — Modules, Hashes, Favicons, Nested Routers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—模块、散列、图标、嵌套路由器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-modules-hashes-favicons-nested-routers-640d24922c90?source=collection_archive---------10-----------------------#2020-07-12">https://javascript.plainenglish.io/node-js-tips-modules-hashes-favicons-nested-routers-640d24922c90?source=collection_archive---------10-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0bc3d895114309a2849d1008e367794a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xnb4zUZgiOdib1O4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@orijit57?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Orijit Chatterjee</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f374" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="98c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生成随机SHA1哈希以用作Node.js中的ID</h1><p id="4f5d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了生成一个随机的SHA1散列，我们可以使用<code class="fe me mf mg mh b">crypto</code>模块。</p><p id="23fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b767" class="mq lc iq mh b gy mr ms l mt mu">const crypto = require('crypto');<br/>const currentDate = (new Date()).getTime().toString();<br/>const random = Math.random().toString();<br/>crypto.createHash('sha1').update(currentDate + random).digest('hex');</span></pre><p id="adb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">Date</code>实例的<code class="fe me mf mg mh b">getTime</code>方法来获取时间戳。</p><p id="48c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建一个随机数。</p><p id="9065" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们通过使用<code class="fe me mf mg mh b">crypto</code>模块的<code class="fe me mf mg mh b">createHash</code>和<code class="fe me mf mg mh b">update</code>方法来创建散列。</p><p id="030d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">digest</code>把它转换成十六进制。</p><h1 id="aa39" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express中设置自定义收藏夹图标</h1><p id="c13b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">serve-favicon</code>包来提供一个自定义的图标。</p><p id="3d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7448" class="mq lc iq mh b gy mr ms l mt mu">const favicon = require('serve-favicon');<br/>app.use(favicon(path.join(__dirname,'public','images','favicon.ico')));</span></pre><p id="0773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过运行以下命令来安装该软件包:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="730b" class="mq lc iq mh b gy mr ms l mt mu">npm i serve-favicon</span></pre><p id="e4f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过传递中间件的路径来使用捆绑的中间件。</p><h1 id="f9a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">打开默认浏览器并导航到节点应用程序中的特定URL</h1><p id="dcd6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">opn</code>包打开浏览器，转到一个特定的URL。</p><p id="332f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="55fd" class="mq lc iq mh b gy mr ms l mt mu">npm install opn</span></pre><p id="882d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6498" class="mq lc iq mh b gy mr ms l mt mu">const opn = require('opn');<br/>opn('http://example.com');</span></pre><p id="9f00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用默认浏览器打开URL。</p><p id="6ebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过编写以下内容来指定浏览器:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9cf9" class="mq lc iq mh b gy mr ms l mt mu">opn('http://example.com', { app: 'firefox' });</span></pre><p id="2212" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后URL将在Firefox中打开。</p><h1 id="9687" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带有嵌套路由器的Express.js</h1><p id="2306" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以嵌套路由器快递。</p><p id="e759" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1c04" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const app = express();</span><span id="5ab7" class="mq lc iq mh b gy mv ms l mt mu">const userRouter = express.Router();<br/>const itemRouter = express.Router({ mergeParams: true });</span><span id="e4fe" class="mq lc iq mh b gy mv ms l mt mu">userRouter.use('/:userId/items', itemRouter);</span><span id="4a64" class="mq lc iq mh b gy mv ms l mt mu">userRouter.route('/')<br/>  .get((req, res) <!-- -->=&gt; <!-- -->{<br/>    res.send('hello users');<br/>  });</span><span id="dad0" class="mq lc iq mh b gy mv ms l mt mu">userRouter.route('/:userId')<br/>  .get((req, res) <!-- -->=&gt; <!-- -->{<br/>    res.status(200)<br/>  });</span><span id="6274" class="mq lc iq mh b gy mv ms l mt mu">itemRouter.route('/')<br/>  .get((req, res) <!-- -->=&gt; <!-- -->{<br/>    res.send('hello');<br/>  });</span><span id="fe40" class="mq lc iq mh b gy mv ms l mt mu">itemRouter.route('/:itemId')<br/>  .get((req, res) =&gt; {<br/>    res.send(`${req.params.itemId} ${req.params.userId}`);<br/>  });</span><span id="1775" class="mq lc iq mh b gy mv ms l mt mu">app.use('/user', userRouter);</span><span id="7a0c" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="6ccf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是将路由器项目传递到我们希望的地方。</p><p id="4e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们想要从父路由器访问参数，所以<code class="fe me mf mg mh b">itemRouter</code>上需要<code class="fe me mf mg mh b">mergeParams</code>。</p><p id="023d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，我们只需通过编写以下代码将<code class="fe me mf mg mh b">itemRouter</code>嵌套在<code class="fe me mf mg mh b">userRouter</code>中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7cb0" class="mq lc iq mh b gy mr ms l mt mu">userRouter.use('/:userId/items', itemRouter);</span></pre><h1 id="5f7d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将二进制NodeJS缓冲区转换为JavaScript ArrayBuffer</h1><p id="97bb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过编写以下代码将节点缓冲区转换为JavaScript <code class="fe me mf mg mh b">ArrayBuffer</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac4b" class="mq lc iq mh b gy mr ms l mt mu">const toArrayBuffer = (buffer) =&gt; {<br/>  const arrayBuffer = new ArrayBuffer(buffer.length);<br/>  const view = new Uint8Array(arrayBuffer);<br/>  for (let i = 0; i &lt; buffer.length; i++) {<br/>    view[i] = buffer[i];<br/>  }<br/>  return arrayBuffer;<br/>}</span></pre><p id="99de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是将缓冲区的每个but放入<code class="fe me mf mg mh b">Uint8Array</code>。</p><p id="60b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过书写来转换另一种方式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0761" class="mq lc iq mh b gy mr ms l mt mu">const toBuffer = (arrayBuffer) =&gt; {<br/>  const buffer = Buffer.alloc(arrayBuffer.byteLength);<br/>  const view = new Uint8Array(arrayBuffer);<br/>  for (let i = 0; i &lt; buffer.length; i++) {<br/>    buffer[i] = view[i];<br/>  }<br/>  return buffer;<br/>}</span></pre><p id="6e10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">alloc</code>方法创建了<code class="fe me mf mg mh b">Buffer</code>。</p><p id="f9ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">arrayByffer</code>传递给<code class="fe me mf mg mh b">Uint8Array</code>构造函数，这样我们就可以遍历它。</p><p id="460b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将所有的位分配给<code class="fe me mf mg mh b">buffer</code>数组。</p><h1 id="a8a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在节点应用程序中写入文件时创建目录</h1><p id="d8d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">fs.mkdir</code>方法的<code class="fe me mf mg mh b">recursive</code>选项在创建文件之前创建一个目录。</p><p id="51f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6e9f" class="mq lc iq mh b gy mr ms l mt mu">fs.mkdir('/foo/bar/file', { recursive: true }, (err) =&gt; {<br/>  if (err) {<br/>    console.error(err);<br/>  }<br/>});</span></pre><p id="3780" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建路径为<code class="fe me mf mg mh b">/foo/bar/file</code>的文件，因为我们已经将<code class="fe me mf mg mh b">recursive</code>选项设置为<code class="fe me mf mg mh b">true</code>。</p><p id="3304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过编写以下内容来使用promise版本:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e6c4" class="mq lc iq mh b gy mr ms l mt mu">fs.promises.mkdir('/foo/bar/file', { recursive: true }).catch(console.error);</span></pre><h1 id="4fde" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">加载外部JS文件并访问本地变量</h1><p id="ddd2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们创建一个模块，我们可以从另一个文件加载外部JS文件。</p><p id="6590" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="0fdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">module.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7c05" class="mq lc iq mh b gy mr ms l mt mu">module.exports = {<br/>  foo(bar){<br/>    //...<br/>  }<br/>}</span></pre><p id="f0d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5f85" class="mq lc iq mh b gy mr ms l mt mu">const module = require('./module');<br/>module.foo('bar');</span></pre><p id="7ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">foo</code>函数放入<code class="fe me mf mg mh b">module.exports</code>中导出，用<code class="fe me mf mg mh b">require</code>导入。</p><p id="f166" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">module.foo('bar');</code>来称呼它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/192709ee81b15b5d13d7b81f2a45e76d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BTyVxMzDt9Le_lDC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lbmartin12?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Landon Martin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8f85" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3b87" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用加密模块生成一个带有时间戳和随机字符串的散列。</p><p id="5677" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用循环在节点缓冲区和数组缓冲区之间进行转换。</p><p id="df41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<code class="fe me mf mg mh b">serve-favicon</code>包让我们在我们的Express应用程序中提供图标。</p><p id="6c4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建模块来导出可以从其他函数运行的函数。</p><p id="35a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速路由器可以嵌套超过一层。</p><h2 id="d204" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="3572" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>