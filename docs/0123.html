<html>
<head>
<title>State Management with React Hooks — No Redux or Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩进行状态管理——没有冗余或上下文API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/state-management-with-react-hooks-no-redux-or-context-api-8b3035ceecf8?source=collection_archive---------0-----------------------#2019-04-08">https://javascript.plainenglish.io/state-management-with-react-hooks-no-redux-or-context-api-8b3035ceecf8?source=collection_archive---------0-----------------------#2019-04-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="42c5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">反应钩比你想象的更强大。</h2></div><p id="486c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我们将探索它并开发一个定制的钩子来管理全局状态——一个比Redux更容易使用的方法，并且比Context API更高效。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/8d1a47b956498f02200fc864a6821f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcDT-neKHP7E3quS9n30gw.png"/></div></div></figure><h1 id="e504" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">钩子的基础</h1><p id="f1d2" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">如果你已经熟悉React钩子，你可以跳过这一部分。</p><h2 id="c10d" class="mh ll in bd lm mi mj dn lq mk ml dp lu kl mm mn lw kp mo mp ly kt mq mr ma ms bi translated">使用状态()</h2><p id="1992" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">在钩子出现之前，功能组件没有状态。现在，有了<code class="fe mt mu mv mw b">useState()</code>，我们可以做到了。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3b89f31d10d81e6d205498f7880e4acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*SfXrcDkOMOZweX9mjXwBdg.png"/></div></figure><p id="6277" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它通过返回一个数组来工作。上述数组的第一项是一个变量，它提供了对状态值的访问。第二项是更新组件状态以反映DOM上新值的函数。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="a578" class="mh ll in bd lm mi mj dn lq mk ml dp lu kl mm mn lw kp mo mp ly kt mq mr ma ms bi translated">useEffect()</h2><p id="dd23" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">类组件使用生命周期方法管理副作用，比如<code class="fe mt mu mv mw b">componentDidMount()</code>。<code class="fe mt mu mv mw b">useEffect()</code>功能允许您在功能组件中执行副作用。</p><p id="c411" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，效果在每次完成渲染后运行。但是，您可以选择仅在某些值发生更改时触发它，将变量数组作为第二个可选参数传递。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ea00" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了得到与<code class="fe mt mu mv mw b">componentDidMount()</code>相同的结果，我们可以发送一个空数组。知道一个空集永远不变，效果只会运行一次。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="fb85" class="lk ll in bd lm ln nh lp lq lr ni lt lu jt nj ju lw jw nk jx ly jz nl ka ma mb bi translated">共享状态</h1><p id="e3fc" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">我们可以看到钩子状态的工作方式与类组件状态完全一样。组件的每个实例都有自己的状态。</p><p id="583d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决在组件之间共享状态的问题，我们将创建一个自定义钩子。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nm"><img src="../Images/46d9756c9cf34f8652e159acefb3124c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5QpNirqwE9DUCnFMSe-zQ.png"/></div></div></figure><p id="5a65" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个想法是创建一个监听器数组和一个状态对象。每当一个组件改变状态时，所有订阅的组件都会触发它们的<code class="fe mt mu mv mw b">setState()</code>函数并得到更新。</p><p id="f16e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过调用自定义钩子中的<code class="fe mt mu mv mw b">useState()</code>来实现。但是，我们没有返回<code class="fe mt mu mv mw b">setState()</code>函数，而是将它添加到一个侦听器数组中，并返回一个更新状态对象并运行所有侦听器函数的函数。</p><h2 id="c0d4" class="mh ll in bd lm mi mj dn lq mk ml dp lu kl mm mn lw kp mo mp ly kt mq mr ma ms bi translated">等等。这不是应该让我的生活更轻松吗？</h2><p id="8b1f" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">是的。我创建了一个封装了所有这些逻辑的NPM包。</p><div class="nn no gp gr np nq"><a href="https://www.npmjs.com/package/use-global-hook" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">使用全局钩子</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用不到1kb的钩子轻松管理react的状态。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">www.npmjs.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe li nq"/></div></div></a></div><p id="f067" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你不需要在每个项目上都重写这个定制钩子。如果您只想跳过这一步并使用最终的解决方案，您可以通过运行以下命令轻松地将其添加到您的项目中:</p><pre class="kz la lb lc gt of mw og oh aw oi bi"><span id="398f" class="mh ll in mw b gy oj ok l ol om">npm install -s use-global-hook</span></pre><p id="ffdf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以通过软件包文档中的示例来学习如何使用它。但是，从现在开始，我们将关注它是如何工作的。</p><h1 id="34c4" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">第一个版本</h1><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="e8ec" class="mh ll in bd lm mi mj dn lq mk ml dp lu kl mm mn lw kp mo mp ly kt mq mr ma ms bi translated">要在组件上使用它:</h2><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5e32" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个第一个版本已经在共享状态下工作。您可以在应用程序中添加任意数量的计数器组件，它们都将具有相同的全局状态。</p><h1 id="b57d" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">但是我们可以做得更好</h1><p id="577c" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">我不喜欢第一个版本:</p><ul class=""><li id="d910" class="on oo in ke b kf kg ki kj kl op kp oq kt or kx os ot ou ov bi translated">我想在卸载组件时从阵列中删除侦听器。</li><li id="0fec" class="on oo in ke b kf ow ki ox kl oy kp oz kt pa kx os ot ou ov bi translated">我想使它更通用，所以我们可以在其他项目中使用。</li><li id="58a8" class="on oo in ke b kf ow ki ox kl oy kp oz kt pa kx os ot ou ov bi translated">我想通过参数设置一个<code class="fe mt mu mv mw b">initialState</code>。</li><li id="495f" class="on oo in ke b kf ow ki ox kl oy kp oz kt pa kx os ot ou ov bi translated">我想使用更多面向函数的编程。</li></ul><h2 id="5ee9" class="mh ll in bd lm mi mj dn lq mk ml dp lu kl mm mn lw kp mo mp ly kt mq mr ma ms bi translated">在组件卸载之前调用函数</h2><p id="3936" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">我们了解到，用一个空数组调用<code class="fe mt mu mv mw b">useEffect(function,[])</code>，与<code class="fe mt mu mv mw b">componentDidMount()</code>有相同的用途。但是，如果第一个参数中使用的函数返回另一个函数，那么第二个函数将在组件被卸载之前被触发。跟<code class="fe mt mu mv mw b">componentWillUnmount()</code>一模一样。</p><p id="2450" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是从listeners数组中删除组件的最佳位置。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="f732" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">第二个版本</h1><p id="46f0" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">除了最后的修改，我们还将:</p><ul class=""><li id="9f53" class="on oo in ke b kf kg ki kj kl op kp oq kt or kx os ot ou ov bi translated">将React设置为参数，不再导入它。</li><li id="4304" class="on oo in ke b kf ow ki ox kl oy kp oz kt pa kx os ot ou ov bi translated">不是导出customHook，而是导出一个函数，根据<code class="fe mt mu mv mw b">initialState</code>参数返回一个新的customHook。</li><li id="47f9" class="on oo in ke b kf ow ki ox kl oy kp oz kt pa kx os ot ou ov bi translated">创建一个包含<code class="fe mt mu mv mw b">state</code>值和<code class="fe mt mu mv mw b">setState()</code>函数的<code class="fe mt mu mv mw b">store</code>对象。</li><li id="fc4f" class="on oo in ke b kf ow ki ox kl oy kp oz kt pa kx os ot ou ov bi translated">将箭头函数替换为<code class="fe mt mu mv mw b">setState()</code>和<code class="fe mt mu mv mw b">useCustom()</code>中的常规函数，这样我们就可以有一个上下文来将<code class="fe mt mu mv mw b">store</code>绑定到<code class="fe mt mu mv mw b">this</code>。</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ff0d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们现在有了一个更通用的钩子，所以我们必须在一个存储文件中设置它。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="dd3b" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">将动作与组件分离</h1><p id="190c" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">如果您曾经使用过复杂的状态管理库，您会知道直接从组件操纵全局状态并不是最好的主意。</p><p id="e3b9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最好的方法是通过创建操作状态的动作来分离业务逻辑。出于这个原因，我希望我们解决方案的最后一个版本没有给组件提供对<code class="fe mt mu mv mw b">setState()</code>函数的访问，而是提供一组动作。</p><p id="0b91" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，我们的<code class="fe mt mu mv mw b">useGlobalHook(React, initialState, actions)</code>函数将接收一个<code class="fe mt mu mv mw b">action</code>对象作为第三个参数。关于这一点，我想补充几点:</p><ul class=""><li id="022c" class="on oo in ke b kf kg ki kj kl op kp oq kt or kx os ot ou ov bi translated">动作将可以访问<code class="fe mt mu mv mw b">store</code>对象。因此，动作可以用<code class="fe mt mu mv mw b">store.state</code>读取状态，通过<code class="fe mt mu mv mw b">store.setState()</code>写入状态，甚至用<code class="fe mt mu mv mw b">state.actions</code>调用其他动作。</li><li id="e32f" class="on oo in ke b kf ow ki ox kl oy kp oz kt pa kx os ot ou ov bi translated">对于组织，操作对象可能包含其他操作的子对象。所以，你可能有一个<code class="fe mt mu mv mw b">actions.addToCounter(amount)</code>或一个子对象，所有的计数器动作都用<code class="fe mt mu mv mw b">actions.counter.add(amount)</code>调用。</li></ul><h1 id="a322" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">最终版本</h1><p id="fa36" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">以下文件是NPM包<code class="fe mt mu mv mw b">use-global-hook</code>中的实际文件。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="2de8" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">使用示例</h1><p id="a776" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">你再也不需要触摸<code class="fe mt mu mv mw b">useGlobalHook.js</code>了。您现在可以专注于您的应用程序了。这里有两个在现实生活中如何使用的例子。</p><h2 id="af46" class="mh ll in bd lm mi mj dn lq mk ml dp lu kl mm mn lw kp mo mp ly kt mq mr ma ms bi translated">几个计数器，一个值</h2><p id="abab" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">添加任意数量的计数器，它们将共享相同的全局值。每当一个计数器在全局值上加1时，所有计数器都会呈现。父组件不需要再次渲染。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="pb mz l"/></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk">Click in “Open in Editor” to view the code in a new tab</figcaption></figure><h2 id="c536" class="mh ll in bd lm mi mj dn lq mk ml dp lu kl mm mn lw kp mo mp ly kt mq mr ma ms bi translated">异步ajax请求</h2><p id="b346" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">通过用户名搜索GitHub库。用async/await异步处理ajax请求。每次搜索时更新请求计数器。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="pb mz l"/></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk">Click in “Open in Editor” to view the code in a new tab</figcaption></figure><h1 id="3088" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们做到了！</h1><p id="ac73" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">我们自己的带有React钩子的状态管理库！</p><h1 id="d861" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">更新—2019年9月</h1><p id="543b" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">在版本0.1.10中，我们向库中添加了一个重要的特性。现在我们可以在使用它之前映射全局状态的子集。这将避免每次全局状态改变时不必要的渲染。</p><p id="0acd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的例子中，我们在全局状态上有两个计数器:counterA和counterB。当您向counterA添加值时，counterB组件将不会重新呈现，反之亦然。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="pb mz l"/></div></figure><p id="0655" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尝试按钮添加10.000个抵靠组件。这将使更新counterB的值非常慢，但更新counterA将继续快速。</p><p id="a08a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="pg">更多内容尽在</em><a class="ae ph" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="pg">plain English . io</em></strong></a><strong class="ke io"><em class="pg"/></strong><em class="pg">和上</em><strong class="ke io"><em class="pg"/></strong><a class="ae ph" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ke io">我们的YouTube频道</strong> </a> <strong class="ke io">！</strong></p><div class="nn no gp gr np nq"><a href="https://newsletter.plainenglish.io/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">上周简明英语杂志</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">《上周简明英语》——科技世界的每周综述，包含我们认为你会…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">时事通讯. plainenglish.io</p></div></div><div class="nz l"><div class="pi l ob oc od nz oe li nq"/></div></div></a></div></div></div>    
</body>
</html>