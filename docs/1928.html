<html>
<head>
<title>JavaScript Interview Question: How to Implement a Promise?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript采访问题:如何实现承诺？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-interview-question-how-to-implement-a-promise-1a2ac69b9a0d?source=collection_archive---------1-----------------------#2020-05-05">https://javascript.plainenglish.io/javascript-interview-question-how-to-implement-a-promise-1a2ac69b9a0d?source=collection_archive---------1-----------------------#2020-05-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bd86" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一步一步写承诺函数。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5616eefb3f2f2f33edab695ccb72dffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*itr4Ob8DbH3Ih5qa"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@mmayyer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">marcos mayer</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="73a9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“承诺”是ES2015版JavaScript的核心功能。承诺是一个在未来某个时候可能会产生单个值的对象:解析的值或未解析的原因(例如，发生网络错误)。承诺可能处于3种可能状态之一:已履行(已解决)、已拒绝或待决。承诺用户可以附加回调来处理已实现的值或拒绝的原因。</p><p id="ce4e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的无极功能应该符合无极A+规范，如果您不熟悉，请先阅读本规范。</p><div class="lp lq gp gr lr ls"><a href="https://promisesaplus.com/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">承诺/A+</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">承诺代表异步操作的最终结果。与承诺互动的主要方式是…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">promisesaplus.com</p></div></div></div></a></div><p id="0025" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，让我们一起写一个Promise函数。</p><h1 id="85bb" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">执行者</h1><p id="8326" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">我们知道，当您创建一个Promise实例时，我们需要传入一个执行器函数。执行器函数应该采用两个函数参数:函数<code class="fe my mz na nb b">resolve</code>和函数<code class="fe my mz na nb b">rejec</code>。当<code class="fe my mz na nb b">resolve</code>函数被调用时，承诺实例被解析。如果执行器函数发生异常，则应调用<code class="fe my mz na nb b">reject</code>函数，承诺实例的状态将被拒绝。</p><p id="d712" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们编写一个基本上满足这些要求的MyPromise函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f2da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，为了更好的理解，我使用ES6的<code class="fe my mz na nb b">class</code>语法。这实际上是构造函数的语法糖。</p><p id="dd62" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好了，现在让我们简单地测试一下我们刚刚编写的函数。</p><pre class="kd ke kf kg gt ne nb nf ng aw nh bi"><span id="7b37" class="ni mc in nb b gy nj nk l nl nm">let p1 = new MyPromise((resolve, reject) =&gt; {<br/>    resolve(1);<br/>})</span><span id="591c" class="ni mc in nb b gy nn nk l nl nm">let p2 = new MyPromise((resolve, reject) =&gt; {<br/>    reject(2);<br/>})</span><span id="4ae3" class="ni mc in nb b gy nn nk l nl nm">console.log(p1);<br/>console.log(p2);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/20f49cca8a07ed3a74ec4ccbe5ea588c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0ejzjpNzlGdENvnHeNdfA.png"/></div></div></figure><p id="eba1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好了，现在我们已经编写了MyPromise函数，可以通过解析和拒绝函数正确地改变状态。</p><h1 id="3384" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">然后</h1><p id="32cf" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">接下来，让我们为我的承诺写下<code class="fe my mz na nb b">.then</code>方法。<code class="fe my mz na nb b">then</code>方法应有两个函数参数，第一个在承诺成功后执行，第二个在承诺失败后执行。</p><p id="6254" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">同时，<code class="fe my mz na nb b">.then</code>方法支持链调用，在每次执行后返回一个承诺实例。</p><pre class="kd ke kf kg gt ne nb nf ng aw nh bi"><span id="4e0b" class="ni mc in nb b gy nj nk l nl nm">new Promise((resolve, reject) =&gt; {<br/>  resolve(1)<br/>}).then(null, error =&gt; {<br/>  console.log(error)<br/>}).then(value =&gt; {<br/>  console.log(1)<br/>});</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/da34a4c1d6b7f3d489c737198399f9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INU_H94FGYb7QAem6f_Kvw.png"/></div></div></figure><p id="eaef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们改进前面的代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="c3ab" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">捕捉</h1><p id="23f1" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated"><code class="fe my mz na nb b">.catch</code>方法用于捕捉异常。与<code class="fe my mz na nb b">.then</code>方法的第二个回调函数相同。</p><p id="78d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，我们可以这样写:</p><pre class="kd ke kf kg gt ne nb nf ng aw nh bi"><span id="e9c2" class="ni mc in nb b gy nj nk l nl nm">catch(rejectFn) {<br/>    return this.then(null, rejectFn)<br/>}</span></pre><h1 id="5d86" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">解决并拒绝</h1><p id="b7e2" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">我们知道<code class="fe my mz na nb b">Promise.resolve(…)</code>方法是返回一个已解决状态的承诺实例，而<code class="fe my mz na nb b">Promise.reject(…)</code>方法是返回一个已拒绝状态的承诺实例。这两种方法非常容易实现:</p><pre class="kd ke kf kg gt ne nb nf ng aw nh bi"><span id="9ab9" class="ni mc in nb b gy nj nk l nl nm">static resolve(result) {<br/>    return new MyPromise(resolve =&gt; {<br/>        resolve(result)<br/>    })<br/>}</span><span id="5888" class="ni mc in nb b gy nn nk l nl nm">static reject(reason) {<br/>    return new MyPromise((_, reject) =&gt; {<br/>        reject(reason);<br/>    })<br/>}</span></pre><h1 id="dd63" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">最后</h1><p id="c0f3" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated"><code class="fe my mz na nb b">finally()</code>方法返回一个承诺。当承诺完成时，即履行或拒绝时，执行指定的回调函数。这为代码的运行提供了一种方式，无论承诺是成功实现还是在承诺被处理后被拒绝。</p><p id="c84f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是代码片段:</p><pre class="kd ke kf kg gt ne nb nf ng aw nh bi"><span id="cd7a" class="ni mc in nb b gy nj nk l nl nm">finally(finallyFn) {<br/>    let P = this.constructor;<br/>    return this.then(<br/>        value =&gt; P.resolve(finallyFn()).then(() =&gt; value),<br/>        reason =&gt; P.reject(finallyFn()).then(() =&gt; reason)<br/>    )<br/>}</span></pre><p id="6fac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是完整的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="1708" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">全部</h1><p id="b2c9" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated"><code class="fe my mz na nb b">Promise.all()</code>方法返回一个单一的<code class="fe my mz na nb b">Promise</code>,当作为可迭代对象传递的所有承诺都已履行时，或者当可迭代对象不包含承诺时，或者当可迭代对象包含已履行的承诺和已返回的非承诺时，该方法履行。它拒绝的原因是第一个拒绝的承诺，或者是第一个参数捕获的错误(如果该参数使用try/catch/throw块捕获了其中的错误)。</p><pre class="kd ke kf kg gt ne nb nf ng aw nh bi"><span id="7d03" class="ni mc in nb b gy nj nk l nl nm">// Receive array parameter<br/>static all(promiseList) {<br/>    // Returns a new instance<br/>    return new MyPromise((resolve, reject) =&gt; {<br/>        let index = 0,     <br/>            results = []; <br/>        <br/>        for(let i = 0; i &lt; promiseList.length; i++) {<br/>            let item = promiseList[i];<br/>            <br/>            if(!(item instanceof MyPromise)) return;<br/>            <br/>            item.then(result =&gt; {<br/>                index++;<br/>                results[i] = result;<br/>                if(index === promiseList.length) {<br/>                    resolve(results);<br/>                }<br/>            }).catch(reason =&gt; {<br/>                reject(reason);<br/>            })<br/>        }<br/>    })<br/>}</span></pre><h2 id="d0dc" class="ni mc in bd md nq nr dn mh ns nt dp ml lc nu nv mn lg nw nx mp lk ny nz mr oa bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="1ca9" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ks" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kv io"> AI in Plain English </strong> </a>，<a class="ae ks" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kv io">UX in Plain English</strong></a>，<a class="ae ks" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kv io">Python in Plain English</strong></a><strong class="kv io"/>——谢谢，继续学习！</p><p id="b157" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ks" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">submissions @ plain English . io</strong></a><strong class="kv io"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>