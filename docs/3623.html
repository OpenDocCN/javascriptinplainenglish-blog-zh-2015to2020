<html>
<head>
<title>What is Static Regeneration in Next.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js中的静态再生是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/static-regeneration-next-js-fca80134991a?source=collection_archive---------4-----------------------#2020-10-13">https://javascript.plainenglish.io/static-regeneration-next-js-fca80134991a?source=collection_archive---------4-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1730" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">静态页面和服务器端呈现相结合</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/40368365a3146abe901a041a4d202253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTh5-6mtnif5EN3G3XrS0Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: The Author</figcaption></figure><p id="ebfb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Next.js目前版本为9.5。随着最近一次重大更新，有一个特性尤其吸引了很多关注:<strong class="kx ir">静态再生</strong>，它现在是Next.js不可或缺的一部分</p><h1 id="3e74" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">静态再生是什么意思？</h1><p id="cf01" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果你只是想看一个代码示例，并且已经理解了这个原理是如何工作的，你可以跳过这一部分。</p><p id="5cea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顾名思义，它是关于重新生成静态交付的页面。与交付的静态页面相反的是服务器端呈现——在用户请求后显示给用户的内容尚未生成的过程。</p><p id="4ec6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">服务器端呈现的一个很好的例子是新闻页面。当用户请求页面时，服务器在后台从数据库中检索最新的条目，组装一个HTML结构，然后进行回复。</p><p id="c0ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从逻辑上讲，这个过程比简单地一遍又一遍地发送同一个HTML文件更耗费时间和性能。</p><p id="24df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">静态页面的缺点是不能动态改变。</p><p id="c2db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Next.j的新特性叫做静态再生，结合了两者的优点。我们发布静态页面，但在某些情况下，我们会重新生成它们，从数据库或API获取最新数据。</p><p id="a190" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">重要提示:</strong>静态再生不适用于Next.js的静态导出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/c5457b346b8260b53821e0afe53fc7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5VpTQxcj5OvgVF0CVPw5Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae mp" href="https://nextjs.org/docs/advanced-features/static-html-export" rel="noopener ugc nofollow" target="_blank">nextjs.org</a></figcaption></figure><p id="1cbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理解这一点很重要。当您对Next.js使用静态导出时，您必须将<code class="fe mq mr ms mt b">next export</code>添加到package.json中，静态页面会生成一次并存储在<em class="mu">/out</em>-目录中。</p><p id="d64d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为页面是完全静态的，所以页面可以托管在几乎任何web服务器上。</p><p id="c3b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">另一方面，静态再生</strong>通过我们Next.js应用程序的经典构建版本工作。我们仍然需要启动服务器，然后它会自动将我们的应用程序作为静态页面发送，所以在后台，页面会作为HTML文件发送。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a10b760fb6684189ce616b5159087901.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*ByBAiAXqshcRujXvNUTNJw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Static vs. active SSR (below)</figcaption></figure><p id="bd68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于静态重新生成，我们仍然需要下一个服务器，因为它必须重新生成页面。</p><p id="59a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一下代码，然后我们理解其余的部分。</p><h1 id="dd29" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">代码示例</h1><p id="6ef7" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本例中，我们有一个Node.js API，它返回Date.now()，这是当前时间(自1970年1月1日以来以毫秒为单位)。因此，如果我们发出第一个请求，两秒钟后又发出另一个请求，我们会得到两个不同的响应。</p><p id="d84c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Next.js应用程序将获取这个API，然后从API输出Date.now()。我决定使用Date.now()，因为这样我们可以监控我们的静态页面是否真的定期更新。</p><p id="9cb0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们将这一切付诸实践:</p><ol class=""><li id="d417" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">为项目创建一个新目录。</li><li id="0d9a" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated"><code class="fe mq mr ms mt b">npm init -y</code> &amp; <code class="fe mq mr ms mt b">npm install express react react-dom cors next</code></li><li id="dd48" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">创建一个名为<em class="mu"> pages </em>的文件夹。这里我们将保存Next.js应用程序。在项目文件夹的根目录下，我们可以创建一个<em class="mu"> server.js </em>。</li><li id="2dc2" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">在pages文件夹中，我们创建一个<em class="mu"> index.js </em>，即登陆页面，它应该由Next.js交付。</li><li id="0e87" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">之后必须对<em class="mu"> package.json </em>进行调整，这样我们才能运行我们的应用程序。添加以下代码:</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2b29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> server.js: </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cfc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>CORS中间件只确保我们不会遇到CORS问题。</p><p id="9668" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">pages文件夹中的<strong class="kx ir"> index.js </strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f288" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">呈现的是app组件，它作为函数存储在下面。为了让静态再生工作，我们需要getStaticProps函数。重要的是，它也必须出口。<br/>该函数自动执行，查询我们的API，然后将响应作为道具传递给我们的应用程序。</p><p id="d43b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">指定页面应该以10秒的间隔静态重新生成——这就是神奇之处。</p><p id="6933" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们应该运行Node.js API服务器。然后我们可以执行<code class="fe mq mr ms mt b">npm run build</code>和<code class="fe mq mr ms mt b">npm start</code>。这将启动我们的Next.js应用程序的生产版本。</p><p id="e4d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">重要提示:</strong>在生成的时候，API必须和<code class="fe mq mr ms mt b">npm run build</code>一起运行——毕竟，它必须被应用程序获取。但是如果在那之后API再次不可达，那也没什么大不了的。如果Next.js不能重新生成API，它将会以先前的状态交付——因此总会有一个后备，即先前生成的静态页面。</p><p id="c29e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们设置的时间间隔并不意味着每x秒静态生成一次页面。这将非常耗时，而且通常没有帮助，因为我们的页面不需要每隔几秒钟就被调用一次。</p><p id="8d0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是它的详细工作原理。例如，我们取10秒的间隔。</p><ul class=""><li id="a20f" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nm nc nd ne bi translated">通过<code class="fe mq mr ms mt b">npm run build</code>,我们生成了Next.js应用程序的生产版本。在这个过程中，我们获取API——它必须可用。</li><li id="1d78" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nm nc nd ne bi translated">从现在开始倒计时。如果用户在上线大约5秒后调用页面，应用程序将提供一个静态页面，显示构建过程的状态。</li><li id="907a" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nm nc nd ne bi translated">如果用户在上线15秒后调用应用程序，Next.js会注意到必须执行重新生成。<br/>然后再次提取API并交付当前状态。</li></ul><p id="a2bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它也不是客户端缓存。如果您硬重新加载页面并且当前在10秒的时间范围内，输出不会改变。只有在10秒后刷新，并且距离上次重建已经过去了更长时间，您才会看到以秒为单位的新时间。</p><h1 id="bbfd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">静态再生什么时候有用？</h1><p id="e72a" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">当然，此过程中的决定性因素是，不一定要交付所有最新的数据。然而，通过重新验证，可以自由定义间隔。<br/>该程序对于不需要提供最新数据的站点非常有用。将revalidate设置为1当然也没有用——然后我们又有了经典的服务器端呈现。</p><p id="a80f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于一个博客来说，我觉得静态再生是一个合适的方法。它提供了静态页面的速度，并且您不必向用户发送大量的JavaScript代码来更新界面。</p><p id="5314" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae mp" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">加入我的简讯获取更新</strong> </a></p></div></div>    
</body>
</html>