<html>
<head>
<title>How to Full Stack JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用全堆栈JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-full-stack-javascript-e546518f56a4?source=collection_archive---------10-----------------------#2020-07-16">https://javascript.plainenglish.io/how-to-full-stack-javascript-e546518f56a4?source=collection_archive---------10-----------------------#2020-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/219e15f8990f91ac01f367af6833d57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FV3UOyQD2NWUlcZ2xs4UAw.jpeg"/></div></div></figure><p id="f9f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript使桌面和移动设备上的浏览器能够与网站交互。包和框架的eco系统使开发人员能够编写代码来更好地帮助开发人员。近年来，在浏览器以外的地方使用JavaScript变得很流行。</p><blockquote class="kt ku kv"><p id="8b45" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">JavaScript已经成为互联网的语言。任何有想法的人都可以通过使用JavaScript快速创建、构建和部署全堆栈应用程序。</p></blockquote><p id="f023" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整堆栈意味着我们在浏览器上创建、构建和部署服务，比如Chrome或Safari，并托管连接到数据库和处理事件的后端服务器。</p><h2 id="05ef" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">前端</h2><ul class=""><li id="e434" class="lt lu in jx b jy lv kc lw kg lx kk ly ko lz ks ma mb mc md bi translated">应用程序的外观和感觉。</li><li id="f3eb" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">它将如何与用户互动</li><li id="85e4" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">提供服务。</li></ul><h2 id="0def" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">后端</h2><ul class=""><li id="c5bc" class="lt lu in jx b jy lv kc lw kg lx kk ly ko lz ks ma mb mc md bi translated">服务器Api</li><li id="4d94" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">数据存储。</li><li id="5df7" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">它将如何认证用户和保护人们的数据。</li><li id="cfa9" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">将数据发送到前端进行显示。</li></ul><p id="6f71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经定义了我们的术语，让我们构建一个可以让我们很快构建的初始项目。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="7e93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将设置一个mono repo，使用Docker来配置开发环境，这样我们就可以开始创建、构建和部署我们的应用程序。</p><div class="mq mr gp gr ms mt"><a href="https://github.com/andrewgbliss/beta-access" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">andrewgbliss/beta-access</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">通过在GitHub上创建一个帐户，为andrewgbliss/beta-access开发做出贡献。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jt mt"/></div></div></a></div><p id="bfa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是这个项目的报告。</p><p id="56ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们谈谈回购的结构，我们将使用哪些服务，以及需要创建哪些文件夹和文件。</p><ul class=""><li id="b027" class="lt lu in jx b jy jz kc kd kg ni kk nj ko nk ks ma mb mc md bi translated">Api —此文件夹包含将运行ExpressJs服务器的NodeJs项目。连接到一个数据库，并创建一个供我们在前端使用的Api。</li><li id="0e44" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">客户端-该文件夹包含将用于前端的ReactJs项目。</li><li id="719f" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">数据库—该文件夹包含用于Docker连接到本地数据库的开发脚本。</li><li id="745d" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">Nginx —此文件夹包含负载平衡器Nginx，因此我们可以在本地主机上为所有服务进行开发。</li></ul><p id="e0ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以在技术上设置任何我们想要的服务。为它创建一个文件夹，并将其添加到docker-composite . yml中</p><div class="mq mr gp gr ms mt"><a href="https://docs.docker.com/compose/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">码头工人写作概述</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">寻找撰写文件参考？在这里找到最新版本。撰写是一个定义和运行…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">docs.docker.com</p></div></div><div class="nc l"><div class="nl l ne nf ng nc nh jt mt"/></div></div></a></div></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="f9ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们在docker-composite . yml中讨论我们的服务。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="06d0" class="la lb in nr b gy nv nw l nx ny">version: "3"<br/>services:  </span><span id="accf" class="la lb in nr b gy nz nw l nx ny">  client:    <br/>    build: .    <br/>    depends_on:      <br/>      - db      <br/>      - api    <br/>    env_file:     <br/>      - .env    <br/>    environment:  <br/>      - PORT=3000 <br/>    ports:     <br/>      - "3000:3000" <br/>   stdin_open: true <br/>   tty: true<br/>   volumes:<br/>     - .:/usr/src/app:cached   <br/>   command: ["npm", "run", "client:start"]</span><span id="9cfb" class="la lb in nr b gy nz nw l nx ny">...</span></pre><p id="5837" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个docker-composite . yml文件中，我们将定义我们所有的服务，这样我们就可以在我们的机器上进行本地开发。由于这是一个单一报告和一个Dockerfile，我们将从当前目录构建，并将整个报告放入一个Docker容器中，以服务于我们的Full Stack应用程序。您可以在所有其他服务的回购协议中看到文件的其余部分。</p><p id="f871" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们将Docker容器保持在最低限度，不要包含要构建到图像中的特定文件。我们通过使用. dockerignore文件来实现这一点。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="2b05" class="la lb in nr b gy nv nw l nx ny">.git<br/>Dockerfile<br/>docker-compose.yml<br/>.DS_Store<br/>.gitignore<br/>README.md<br/>env.*<br/>sample.env<br/>.env<br/>nginx<br/>db </span><span id="7f60" class="la lb in nr b gy nz nw l nx ny"># To prevent storing dev/temporary container data<br/>*.csv<br/>tmp</span></pre><p id="d3e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">容器中任何您不需要的文件都可以在这里列出来忽略它们。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="cda4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经浏览了文件夹和设置，让我们创建一个。用于所有环境变量的环境文件。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="1565" class="la lb in nr b gy nv nw l nx ny"># Environment<br/>NODE_ENV=local<br/>TZ=America/Denver<br/>PORT=3000</span><span id="e123" class="la lb in nr b gy nz nw l nx ny"># Auth<br/>JWT_SECRET=ta8fbfdaf2a7869903a644d2827c888b81461a47dd5ab6b6014473eb83c7d4a1X_<br/>SERVICE_TOKEN=ta8fbfdaf2a7869903a644d2827c888b81461a47dd5ab6b6014473eb83c7d4a1</span><span id="3bf5" class="la lb in nr b gy nz nw l nx ny"># DB<br/>DATABASE_URL=postgres://postgres:postgres@db:5432/postgres</span></pre><p id="9fb9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的Api服务中，我们将使用JWT (JSON Web Token)进行身份验证，因此我们将创建一个环境变量来存储我们的秘密。我们还将在这里存储我们的本地数据库凭证。</p><p id="a947" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以运行docker-compose up，构建我们的容器，应用程序应该在本地主机上启动并运行。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="8e15" class="la lb in nr b gy nv nw l nx ny">docker-compose up</span></pre></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="6e35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译和运行我们的应用程序都由项目根文件夹中的一个package.json控制。它可以通过运行npm命令来运行所有部署脚本。在README.md中，它显示了如何运行迁移和种子。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="64e0" class="la lb in nr b gy nv nw l nx ny">docker-compose run --rm api npm run migrate<br/>docker-compose run --rm api npm run seed</span></pre><p id="6763" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来讨论一下我们设置了哪些命令。</p><ul class=""><li id="f2bf" class="lt lu in jx b jy jz kc kd kg ni kk nj ko nk ks ma mb mc md bi translated">start —这将在api构建完成后启动它</li><li id="f98a" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">API:build——这将把应用程序从类型脚本编译成可部署的JavaScript</li><li id="e502" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">API:dev——这将启动一个开发服务器，运行并监视Typescript文件</li><li id="d3d5" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">api:test —这将在我们的api上运行测试</li><li id="22dc" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">api:db-utils —这将运行数据库脚本</li><li id="b4a4" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">API:sequel ize——这使我们能够访问Sequelize CLI</li><li id="cd20" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">客户端:启动—这将启动React应用程序开发服务器</li><li id="074f" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">client:build —这将构建React应用程序，为部署做好准备</li><li id="83dd" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">客户端:复制—这将客户端复制到api到服务器静态文件中</li><li id="2219" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">构建—这将构建和编译所有的服务</li><li id="7768" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">测试—这将测试所有服务</li><li id="16c6" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">迁移—这将运行数据库迁移</li><li id="9710" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">种子—这将为数据库植入数据</li><li id="148f" class="lt lu in jx b jy me kc mf kg mg kk mh ko mi ks ma mb mc md bi translated">heroku-post build——这将为Heroku构建我们所有的服务</li></ul><p id="c7f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在docker-compose.yml中看到它为本地开发服务使用了哪些npm命令。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="f9a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经在本地设置好了，让我们来讨论一下部署。在本教程中，我们将使用Heroku和Github。我们将在Github中托管我们的repo，并在Heroku中创建一个与之连接的项目。</p><p id="2bda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们设置一个Procfile，它将在我们推送新代码时运行任何迁移。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="7df7" class="la lb in nr b gy nv nw l nx ny">release: npm run migrate</span></pre><p id="88bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当Heroku看到这个文件并发布新代码时，它将运行迁移。</p><p id="f8f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们也为Heroku添加一些忽略脚本。我们通过创建一个. slugignore文件来实现这一点。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="e0dc" class="la lb in nr b gy nv nw l nx ny">./db<br/>./nginx<br/>.dockerignore<br/>docker-compose.yml<br/>Dockerfile<br/>.env<br/>sample.env<br/>README.md<br/>log<br/>tmp</span></pre><p id="bf5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">任何你不想在Heroku服务的最终版本中出现的东西都在这个文件中。</p></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><p id="8280" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Api服务器</p><p id="5e8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个Api将运行ExpressJs，我们将使用JWT进行认证。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="fea4" class="la lb in nr b gy nv nw l nx ny">/** <br/> * JWT Authentication <br/> */<br/>app.use(  <br/>  expressjwt({    <br/>    algorithms: ['HS256'],    <br/>    secret: process.env.JWT_SECRET,    <br/>    credentialsRequired: false,   <br/>    getToken(req) {     <br/>      if (req.headers.authorization &amp;&amp;       req.headers.authorization.split(' ')[0] === 'Bearer') {       <br/>        return req.headers.authorization.split(' ')[1];      <br/>      } else if (req.query &amp;&amp; req.query.token) {        <br/>        return req.query.token;      <br/>      }      <br/>      return null;    <br/>    },  <br/>  })<br/>);</span></pre><p id="1dbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将采用我们的JWT_SECRET环境变量并设置我们的身份验证。然后，它将在头或查询字符串中查找令牌。</p><p id="9528" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，让我们启动服务器，监听我们的端口环境变量。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="39ae" class="la lb in nr b gy nv nw l nx ny">const server = app.listen(process.env.PORT, () =&gt; {  <br/>  console.log(    <br/>    `<br/>     Express Server started. <br/>     Port: ${app.get('port')}<br/>    `<br/>  );<br/>});</span></pre><div class="mq mr gp gr ms mt"><a href="https://expressjs.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">Express - Node.js web应用程序框架</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">Express是一个最小且灵活的Node.js web应用程序框架，它为web和…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">expressjs.com</p></div></div><div class="nc l"><div class="oa l ne nf ng nc nh jt mt"/></div></div></a></div><p id="0e2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们设置一个登录路径，以便用户可以登录。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="1243" class="la lb in nr b gy nv nw l nx ny">import express, { Request, Response, NextFunction } from 'express';<br/>import { asyncEndpoint, validateSchema } from '../../../../../../middleware';<br/>import joi from '@hapi/joi'; </span><span id="2c0a" class="la lb in nr b gy nz nw l nx ny">const router = express.Router(); </span><span id="5e26" class="la lb in nr b gy nz nw l nx ny">const loginSchema = {  <br/>  path: 'body',  <br/>  schema: joi.object().keys({  <br/>    email: joi.string().required(),  <br/>    password: joi.string().required(),<br/>  }),<br/>}; </span><span id="c003" class="la lb in nr b gy nz nw l nx ny">const login = async (req: Request, res: Response, next: NextFunction) =&gt; {  <br/>  const { Users } = req.app.get('db'); <br/>  const user = await Users.findOne({   <br/>    attributes: ['id', 'accountId', 'email', 'password'],  <br/>    where: {    <br/>      email: req.body.email,  <br/>    },  <br/>  });  </span><span id="aae3" class="la lb in nr b gy nz nw l nx ny">  if (!user || !user.verifyPassword(req.body.password)) {  <br/>    throw {     <br/>      status: 403,    <br/>      message: 'Email or Password is incorrect',  <br/>    };  <br/>  }  <br/>  <br/>  req.refreshJWT(user.id, user.accountId);  <br/>  res.end();<br/>}; </span><span id="1d05" class="la lb in nr b gy nz nw l nx ny">router.post('/', validateSchema(loginSchema), asyncEndpoint(login)); </span><span id="abef" class="la lb in nr b gy nz nw l nx ny">export default router;</span></pre><p id="4f50" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个文件中，我们将从@hapi/joi包中引入一些数据验证。我们将验证只允许输入电子邮件和密码。然后我们会检查数据库和密码，看看是否有正确的。</p><p id="dca9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了登录系统的端点，我们可以在React中编写一个登录组件。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="c75a" class="la lb in nr b gy nv nw l nx ny">import React, { useState } from 'react';<br/>import { useObserver } from 'mobx-react-lite';<br/>import { useAuth } from '../store/Context';<br/>import Button from '@material-ui/core/Button';<br/>import TextField from '@material-ui/core/TextField';<br/>import Dialog from '@material-ui/core/Dialog';<br/>import DialogActions from '@material-ui/core/DialogActions';<br/>import DialogContent from '@material-ui/core/DialogContent';<br/>import DialogContentText from '@material-ui/core/DialogContentText';<br/>import DialogTitle from '@material-ui/core/DialogTitle';<br/>import useSnackbar from 'hooks/useSnackbar';<br/>import Slide from '@material-ui/core/Slide';<br/>import { TransitionProps } from '@material-ui/core/transitions';<br/>import Api from 'services/Api'; </span><span id="608c" class="la lb in nr b gy nz nw l nx ny">const Transition = React.forwardRef(function Transition( <br/>  props: TransitionProps &amp; { children?: React.ReactElement&lt;any, any&gt; },  <br/>  ref: React.Ref&lt;unknown&gt;) {  <br/>    return &lt;Slide direction="up" ref={ref} {...props} /&gt;;<br/>  }); </span><span id="a426" class="la lb in nr b gy nz nw l nx ny">const Login: React.FC = () =&gt; {  <br/>  const auth: any = useAuth();  <br/>  const [email, setEmail] = useState('');  <br/>  const [password, setPassword] = useState('');  <br/>  const handleClose = () =&gt; {   <br/>    auth.setOpenLoginDialog(false);  <br/>  };  <br/>  const handleRegister = () =&gt; {   <br/>    auth.setOpenLoginDialog(false); <br/>    auth.setOpenRegisterDialog(true); <br/>  };  <br/>  const handleForgotPassword = () =&gt; {<br/>    auth.setOpenLoginDialog(false);     <br/>    auth.setOpenRegisterDialog(false);  <br/>    auth.setOpenForgotPasswordDialog(true); <br/>  };  <br/>  const handleSubmit = useSnackbar(async (snackbar: any) =&gt; {  <br/>    await Api.post('/api/v1/login', {     <br/>      email,     <br/>      password,  <br/>    });    <br/>    window.location.href = '/dashboard'; <br/>  });  <br/>  return useObserver(() =&gt; {  <br/>    return (    <br/>      &lt;Dialog      <br/>        open={auth.openLoginDialog}    <br/>        TransitionComponent={Transition}    <br/>        onClose={handleClose}       <br/>        aria-labelledby="login"      <br/>      &gt;        <br/>        &lt;DialogTitle id="login"&gt;Login&lt;/DialogTitle&gt;   <br/>          &lt;DialogContent&gt;         <br/>            &lt;DialogContentText&gt;         <br/>              To login to this website, please enter your email address and          <br/>              password here.          <br/>            &lt;/DialogContentText&gt;         <br/>            &lt;TextField      <br/>              autoFocus       <br/>              margin="dense"       <br/>              id="email"       <br/>              label="Email Address"       <br/>              type="email"          <br/>              fullWidth   <br/>              value={email}    <br/>              onChange={(e: any) =&gt; setEmail(e.target.value)}         /&gt;     <br/>            &lt;TextField    <br/>              autoFocus          <br/>              margin="dense"     <br/>              id="password"      <br/>              label="Password"    <br/>              type="password"      <br/>              fullWidth         <br/>              value={password}      <br/>              onChange={(e: any) =&gt; setPassword(e.target.value)}          /&gt;        <br/>         &lt;/DialogContent&gt;    <br/>       &lt;DialogActions&gt;       <br/>         &lt;Button onClick={handleClose} color="secondary"&gt;            Cancel         <br/>         &lt;/Button&gt;   <br/>         &lt;Button onClick={handleForgotPassword} color="primary"&gt;            Forgot Password       <br/>         &lt;/Button&gt;      <br/>         &lt;Button onClick={handleRegister} color="primary"&gt;            Register        <br/>         &lt;/Button&gt;    <br/>         &lt;Button    <br/>           onClick={handleSubmit}  <br/>           color="primary"         <br/>           disabled={!email || !password} <br/>         &gt;          <br/>           Login     <br/>         &lt;/Button&gt;     <br/>       &lt;/DialogActions&gt;     <br/>     &lt;/Dialog&gt;   <br/>   );  <br/>  });<br/>}; </span><span id="2d68" class="la lb in nr b gy nz nw l nx ny">export default Login;</span></pre><p id="936a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个组件使用一个Mobx存储来处理电子邮件和密码的状态。当用户点击登录按钮时，它将启动handleSubmit函数并调用我们的后端Api。</p><div class="mq mr gp gr ms mt"><a href="https://mobx-react.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">MobX与反应</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">让您的组件真正与MobX反应</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">mobx-react.js.org</p></div></div></div></a></div></div><div class="ab cl mj mk hr ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ig ih ii ij ik"><h2 id="a6c5" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">开发人员注意</h2><p id="9688" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg ob ki kj kk oc km kn ko od kq kr ks ig bi translated">该应用程序中还有一些其他组件，只是订阅测试版访问电子邮件列表的一些基本形式。</p><p id="e04b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在mono repo中开发任何您想开发的应用程序。您可以运行任何后端api。只需替换api和客户端文件夹中的内容，您就可以满足您的需求。</p><p id="6bd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请留下评论，说明这是否对您有所帮助，或者您如何解决使用完整堆栈JavaScript部署mono repo的问题。</p><div class="mq mr gp gr ms mt"><a href="https://nodejs.org/en/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">Node.js</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">Node.js是一个基于Chrome V8 JavaScript引擎的JAVAScript运行时。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">nodejs.org</p></div></div><div class="nc l"><div class="oe l ne nf ng nc nh jt mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://reactjs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd io gy z fp my fr fs mz fu fw im bi translated">反应-一个用于构建用户界面的JavaScript库</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">反应使创建交互式用户界面变得毫无痛苦。为应用程序中的每个状态设计简单的视图，并做出反应…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">reactjs.org</p></div></div><div class="nc l"><div class="of l ne nf ng nc nh jt mt"/></div></div></a></div></div></div>    
</body>
</html>