<html>
<head>
<title>Seven different ways to check presence of an element in an array with performance benchmarks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用性能指标评测检查数组中元素存在性的七种不同方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/seven-ways-to-check-existence-of-an-element-in-javascript-array-with-performance-benchmarks-a7f9312c8904?source=collection_archive---------1-----------------------#2020-06-18">https://javascript.plainenglish.io/seven-ways-to-check-existence-of-an-element-in-javascript-array-with-performance-benchmarks-a7f9312c8904?source=collection_archive---------1-----------------------#2020-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4096760d746b82d72e0f347cb1bc59f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2mzh3NA0DRx4ZQqyYofGw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk"><a class="ae jd" href="https://unsplash.com/photos/g1uBcKvRIs4" rel="noopener ugc nofollow" target="_blank">Image credit</a></figcaption></figure><div class=""/><p id="060d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中查找数组中的元素时，有几种不同的方法。这就带来了下一个问题:使用什么，哪种性能更好。在这篇文章中，我将列出所有七种不同的方法，并进行一些测试，看看哪种方法更好。</p><h1 id="b246" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">七种不同的方式:</strong></h1><p id="3b00" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们先详细讨论一下每种方法。</p><ol class=""><li id="21c4" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><strong class="kf jh"> Array.indexOf方法</strong></li></ol><p id="ccc4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">Array.indexOf</code>接受一个元素和一个可选的从索引开始。当start-from-index被传入时，该算法寻找从该索引开始的元素。该方法返回第一个元素出现的索引，如果没有找到，则返回<code class="fe mn mo mp mq b">-1</code>。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mr"><img src="../Images/4d4accc7cbf4f77c8d814f7ba5198eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfWFcCd1-LblcOgbmomwug.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Array.indexOf example</figcaption></figure><p id="d808" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<strong class="kf jh">本机for循环</strong></p><p id="21c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过递增索引直到索引小于数组长度，循环直到找到所需的元素。在任何找到元素的情况下，我们将把我们的局部变量<code class="fe mn mo mp mq b">isPresent</code>设置为<code class="fe mn mo mp mq b">true</code>并中断循环。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/45790627fd2c46896f9caffc99a0eeb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apJaxD0w7FliSd3c6m3IpQ.png"/></div></div></figure><p id="44e3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<strong class="kf jh"> for…of loop </strong></p><p id="b7f6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自https://developer.mozilla.org/的文件:</p><blockquote class="mx my mz"><p id="fc72" class="kd ke na kf b kg kh ki kj kk kl km kn nb kp kq kr nc kt ku kv nd kx ky kz la ij bi translated"><code class="fe mn mo mp mq b"><strong class="kf jh">for...of</strong></code> <strong class="kf jh">语句</strong>创建一个遍历可迭代对象的循环，包括:内置<code class="fe mn mo mp mq b"><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank">String</a></code>、<code class="fe mn mo mp mq b"><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">Array</a></code>、类数组对象</p></blockquote><p id="9401" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，我们将坚持使用数组。</p><p id="4c78" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与native-for-loop相同，一旦发现元素buy打破循环，我们就可以退出循环。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/ab5851628513a150475202440cc6c93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcgSE3YwN8VXYYLs8BV_IQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">for….of example</figcaption></figure><p id="cb7d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.<strong class="kf jh">数组. some </strong></p><p id="5f5a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">Array.some()</code>接受一个<code class="fe mn mo mp mq b">callback</code>函数，并对数组中的每个元素执行一次该函数，直到找到一个<code class="fe mn mo mp mq b">callback</code>返回一个<em class="na">真值</em>的元素。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/0af1e31cf1d2fc1a1547ce9e9bd88173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUACU_W3UHI2ZIIapNmQug.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Array.some example</figcaption></figure><p id="282c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.<strong class="kf jh">数组.包含</strong></p><p id="ddf1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Array.includes方法接受一个元素和一个可选的start from index，如果我们想从一个特定的索引开始搜索并返回一个布尔值。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/d29a0fdbda3f93ebd1a0a7bf54b1a14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gfF9Fdv_Ej2GZwlZIHFJg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Array.includes example</figcaption></figure><p id="c95a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.<strong class="kf jh"> Array.find </strong></p><p id="5361" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b"><strong class="kf jh">find()</strong></code>方法返回所提供数组中满足所提供回调函数的<strong class="kf jh">第一个元素</strong>的<strong class="kf jh">值</strong>。如果没有找到元素，则返回<code class="fe mn mo mp mq b">undefined</code>。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/c36cb0dcbe868bee1b77545b8651164c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LP21npHL42FnblDcCSFQyQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Array.find example</figcaption></figure><p id="e9d2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">7.<strong class="kf jh"> Array.findIndex </strong></p><p id="d565" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">Array.findIndex</code>接受一个回调函数，它对每个元素执行该函数，直到找到一个在执行回调时返回<em class="na"> truthy </em>值的元素。类似于<code class="fe mn mo mp mq b">Array.indexOf</code>，如果没有找到元素，它返回<code class="fe mn mo mp mq b">-1</code>。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/06ec9f8e5f4f770ab5ccc79692654fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9EcJe7ji-wPZfmDQjcXQQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Array.findIndex example</figcaption></figure><p id="f88f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们已经介绍了寻找元素存在的所有方法。现在让我们做一些测试，看看这些方法的性能如何。</p><h1 id="385b" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">测试用例:</strong></h1><p id="57d1" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们创建一个包含一百万条记录的数组，起始值从1到1000000。</p><pre class="ms mt mu mv gt nf mq ng nh aw ni bi"><span id="9705" class="nj lc jg mq b gy nk nl l nm nn"><strong class="mq jh">let array = new Array(1000000).fill(0).map((_v, i) =&gt; i + 1);</strong></span></pre><p id="0e70" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是我们的四个测试案例:</p><pre class="ms mt mu mv gt nf mq ng nh aw ni bi"><span id="2ad8" class="nj lc jg mq b gy nk nl l nm nn"><strong class="mq jh">const testCases = [1, 500000, 1000000, 1000010];</strong></span></pre><p id="89f3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">testCases</code>数组包括<code class="fe mn mo mp mq b">array</code>中的第一个值、中间值(500000)、最后一个值(1000000)和一个不存在的值。</p><p id="beda" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一个util函数，它接受一个回调函数来对每个方法执行这些测试。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/2a335e3dfcf319e62d27f3345c534ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZlcvn-5fzbhu2b_PS8GSw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">A simple util function which takes in a callback function and executes all the test cases on it</figcaption></figure><p id="75cb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的util函数接受一个回调函数和name函数的名称作为输入，并使用不同的输入调用回调函数，同时监视和更新<code class="fe mn mo mp mq b">result</code>对象中每个场景所用的时间。一旦所有的测试用例都运行了，平均花费的时间就被计算出来，并添加到以<code class="fe mn mo mp mq b">Average</code>作为专有名称的对象中。上图中还添加了一个简单的用例，说明我们如何使用这种方法。类似地，我们可以用上面列出的其他类型的方法调用util方法。</p><p id="5d69" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是完整的代码</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6d68" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些测试用例在windows机器上的chrome开发工具中运行。这里是所有情况下的性能指标</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/de02257372fb237ff5fe2546518098f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ml2jpyGXS6fMLSmxEqM6Q.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Performance metrics</figcaption></figure><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/ca6411155f8670a05990abe89b6dc64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_Uq1EnmUIwNh-irPykRKw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Sorted by average time asc</figcaption></figure><p id="43eb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过观察平均时间，似乎<code class="fe mn mo mp mq b">Array.indexOf</code>对于原始情况更有性能。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="76f7" class="lb lc jg bd ld le nz lg lh li oa lk ll lm ob lo lp lq oc ls lt lu od lw lx ly bi translated"><strong class="ak">结论:</strong></h1><p id="4859" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有许多不同的方法来检查数组中元素的存在</p><p id="f29f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于原语，<code class="fe mn mo mp mq b">Array.indexOf</code>，<code class="fe mn mo mp mq b">Array.includes</code>似乎是正确的候选者，因为它们对于具有1 mill元素的不同测试用例都花费了大约1ms。</p><p id="0e61" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！关注我更多有趣的文章。</p></div></div>    
</body>
</html>