<html>
<head>
<title>Be careful with JavaScript getters and setters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小心JavaScript的getters和setters</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/be-careful-with-javascript-getters-and-setters-32752bb2d496?source=collection_archive---------2-----------------------#2020-02-04">https://javascript.plainenglish.io/be-careful-with-javascript-getters-and-setters-32752bb2d496?source=collection_archive---------2-----------------------#2020-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="254a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简短有用的JavaScript课程。让它变得简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ac8a97c6330d63325d519baa1d3fa1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2uervCF122ZcHH8O1KntQ.png"/></div></div></figure><p id="b306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对象的默认“Get”和“Put”操作分别控制如何将值设置为新属性或现有属性，或者如何从现有属性中检索值。但是如果你不小心的话，就很容易犯一些不被注意到的错误。</p><p id="3061" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><h2 id="3e95" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">案例1:</h2><p id="6661" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">get方法总是返回相同的值给我们。无论我们赋予“a”什么值，在这种情况下，foo.a总是返回1。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="63e4" class="ln lo iq mm b gy mq mr l ms mt">var foo ={<br/>    <!-- -->get a<!-- -->() {<strong class="mm ir">return 1</strong>}<br/>}</span><span id="873a" class="ln lo iq mm b gy mu mr l ms mt"><em class="mv">//Another way (deprecated)<br/>//__defineGetter__ and this.__defineSetter__ are deprecated!<br/>//var foo = {}<br/>//foo.__defineGetter__('a', () =&gt; 1);</em></span><span id="9911" class="ln lo iq mm b gy mu mr l ms mt">foo.a=5;<br/>foo.b=2</span><span id="93b8" class="ln lo iq mm b gy mu mr l ms mt">const sum = (a, b) =&gt; a +b;</span><span id="38e3" class="ln lo iq mm b gy mu mr l ms mt">console.log(sum(foo.a, foo.b));// 5+2 =<strong class="mm ir"> 3!!</strong></span></pre><h2 id="dcf2" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">案例二:</h2><p id="1d07" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在这里，您触发了递归调用的无限堆栈，导致浏览器崩溃。</p><p id="00bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在案例2.1中</p><p id="5c88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为您引用了person.age属性，所以JavaScript需要获取该属性。当这种情况发生时，getter被触发。JavaScript调用getter，但getter随后被告知做完全相同的事情:获取它要处理的属性。该函数总是调用自身，从而创建无限的递归调用。</p><p id="5a0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在2.2的情况下，同样的想法也适用于setter。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="19b2" class="ln lo iq mm b gy mq mr l ms mt"><strong class="mm ir">//case2.1</strong><br/>function Person(age){<br/> this.age = age ;<br/>}</span><span id="51a1" class="ln lo iq mm b gy mu mr l ms mt">Person<!-- -->.prototype = {<br/>    get age() {<br/>        return this.age //<strong class="mm ir"><em class="mv">Maximum call stack size exceeded!!</em></strong><br/>    }<br/>};</span><span id="50aa" class="ln lo iq mm b gy mu mr l ms mt">var thePerson= new Person();</span><span id="3e31" class="ln lo iq mm b gy mu mr l ms mt">//This generates the error.<br/>thePerson.age</span><span id="81b3" class="ln lo iq mm b gy mu mr l ms mt"><strong class="mm ir">//case 2.2</strong><br/>function Person(age){<br/> this.age = age ;<br/>}</span><span id="5a8d" class="ln lo iq mm b gy mu mr l ms mt">Person<!-- -->.prototype = {<br/>    get age() {<br/>        return this.age;<br/>    },<br/>    set age(age) {<br/>        this.age = age; //<strong class="mm ir"><em class="mv">Maximum call stack size exceeded!!</em></strong><br/>    }<br/>};</span><span id="b240" class="ln lo iq mm b gy mu mr l ms mt">//This generates the error.<br/>var thePerson= new Person(40);</span></pre><h2 id="2d26" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">案例3</h2><p id="635a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在这个例子中，相反，我们实际上是把赋值的指定值5([[Put]]操作)i <strong class="kt ir">存储到另一个变量_a_ </strong>中。_a_ name在这个例子中完全是约定俗成的，并不意味着它的行为有什么特别之处——它和其他任何属性一样，都是一个普通的属性。<strong class="kt ir">通过这样做，我们避免了使用gets和sets </strong>时的递归调用。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="085e" class="ln lo iq mm b gy mq mr l ms mt">var myObject = {<br/>    // define a getter for 'a'<br/>    get a() {<br/>        return this._a_;<br/>    },<br/>    // define a setter for 'a'<br/>    set a(val) {<br/>        this._a_ = val;<br/>    }<br/>};</span><span id="f833" class="ln lo iq mm b gy mu mr l ms mt">myObject.a = 5; //<strong class="mm ir">OK!!</strong></span><span id="9a1d" class="ln lo iq mm b gy mu mr l ms mt">console.log(myObject.a); //5 <strong class="mm ir">OK!!</strong></span></pre><p id="d1e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇小文章能够帮助您理解getters和setters可能给代码带来的危险。</p><h2 id="0280" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">如果这对你有帮助，请点击下面的拍手按钮。非常感谢！</h2></div></div>    
</body>
</html>