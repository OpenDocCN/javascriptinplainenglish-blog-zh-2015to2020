<html>
<head>
<title>Build an 8 Puzzle Game With Pure JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用纯JavaScript构建一个8字谜游戏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-an-8-puzzle-game-with-pure-javascript-efe424bc252a?source=collection_archive---------0-----------------------#2020-05-22">https://javascript.plainenglish.io/build-an-8-puzzle-game-with-pure-javascript-efe424bc252a?source=collection_archive---------0-----------------------#2020-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8463" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过有趣的项目提高您的JavaScript技能</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/2bacbcb9a1323985b3b565c2a416da26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*lU8yM6ObWDangeBPMOGw7A.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">What we will be creating!</figcaption></figure><p id="3aab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lk">本帖最早出现在我的</em> <a class="ae ll" href="https://medium.com/javascript-in-plain-english/understanding-javascript-execution-context-call-stack-and-stack-overflow-157b7b358e88" rel="noopener"> <em class="lk">个人博客</em> </a></p><p id="5b7f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">嘿哟！在这篇文章中，我们将用基本的网页设计技巧来创建一个游戏。你需要的只是HTML、CSS和JavaScript的基础知识。我们正在做的游戏是流行的8字谜游戏。</p><p id="e54c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它由9块瓷砖组成，其中8块填满了内容，最后一块是空的。要解决这个难题，玩家必须重新排列瓷砖。</p><p id="f961" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">打开您最喜欢的文本编辑器，我正在使用VSCode，并创建以下文件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/7f28287cc0775b1b27afd1217ea6f8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*wi4FmmjDGiqNA6xO-n8Vtg.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Project folder structure</figcaption></figure><p id="829d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们用一个无序列表创建一个div容器，在<code class="fe ln lo lp lq b">index.html</code>中有9个列表元素:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="fe85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，让我们添加一些样式。首先，我通过使用<code class="fe ln lo lp lq b">*</code>选择页面上的每个元素来移除默认填充和边距。<br/>我还把主体做成一个flex容器，这样我们就可以使用flexbox来设计页面的样式。容器div的高度和宽度为500px，有一个很好的背景，与主体的背景相匹配。</p><p id="f8e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这条线<code class="fe ln lo lp lq b">margin: 10px auto</code>；居中对齐容器div，在顶部和底部给它10px的边距，在左侧和右侧给它“自动”(相等)的边距。</p><p id="e4b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/css/style.css</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="b095" class="lx ly in lq b gy lz ma l mb mc">* {<br/>    padding: 0;<br/>    margin: 0;<br/>    box-sizing: border-box;<br/>}</span><span id="3ebb" class="lx ly in lq b gy md ma l mb mc">body {<br/>    display: flex;<br/>    background-color: #114B5F;<br/>    text-align: center;<br/>    flex-direction: column;<br/>    padding-top: 2%;</span><span id="c0c6" class="lx ly in lq b gy md ma l mb mc">}</span><span id="c5eb" class="lx ly in lq b gy md ma l mb mc">#container {<br/>    width: 500px;<br/>    height: 500px;<br/>    background: #E4FDE1;<br/>    margin: 10px auto;<br/>}</span></pre><p id="b71a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在你最喜欢的浏览器中预览<code class="fe ln lo lp lq b">index.html</code>，你应该也有这个:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/bc2f47f0cd41fc9d78966093c59bd6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgG4CN3JvWNEm_1-izUtlw.png"/></div></div></figure><p id="220a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，让我们来设计列表项的样式。我将使<code class="fe ln lo lp lq b">ul</code>也成为一个flex容器，并且均匀地分隔列表项:</p><p id="0002" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意</strong> : <em class="lk">一些用户报告说</em> <code class="fe ln lo lp lq b"><em class="lk">flexbox</em></code> <em class="lk">在FireFox和edge浏览器上对齐不一致，我建议在Google Chrome浏览器中查看这个项目或为您的特定浏览器找到一个修复程序。</em></p><p id="39e3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/css/style.css</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="df18" class="lx ly in lq b gy lz ma l mb mc">* {<br/>    padding: 0;<br/>    margin: 0;<br/>    box-sizing: border-box;<br/>}</span><span id="049c" class="lx ly in lq b gy md ma l mb mc">body {<br/>    display: flex;<br/>    background-color: #114B5F;<br/>    text-align: center;<br/>    flex-direction: column;<br/>    padding-top: 2%;</span><span id="2fdd" class="lx ly in lq b gy md ma l mb mc">}</span><span id="a0d7" class="lx ly in lq b gy md ma l mb mc">#container {<br/>    width: 500px;<br/>    height: 500px;<br/>    background: #E4FDE1;<br/>    margin: 10px auto;<br/>}</span><span id="0272" class="lx ly in lq b gy md ma l mb mc">ul {<br/>    display: flex;<br/>    flex-wrap: wrap;<br/>    list-style-type: none;<br/>    justify-content: space-evenly;<br/>    font-family: 'Audiowide';<br/>    color: #E4FDE1;<br/>}<br/>ul li {<br/>    background: #456990;<br/>    width: 30%;<br/>    height: 150px;<br/>    border: 1px solid #028090;<br/>    margin-top: 10px;<br/>    text-align: center;<br/>    font-size: 2rem;<br/>    padding-top: 3rem;<br/>}</span></pre><p id="e58b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">再预览一下<code class="fe ln lo lp lq b">index.html</code>，你应该有这样的东西:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/35aaaa7115b11659baf1f64cb68dcfb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7nRF4VjatwV8FJ8QKgntg.png"/></div></div></figure><p id="43a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很好。</p><p id="8018" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在8块滑动拼图中，第9块拼图应该是空的，所以我们将创建一个类来设计空拼图的样式。在此之前，让我们给出列表项的内容，更新<code class="fe ln lo lp lq b">index.html</code>以包含以下内容(我已经包含了<code class="fe ln lo lp lq b">Audiowide </code>字体的链接)；</p><p id="2b7c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/index.html</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="6844" class="lx ly in lq b gy lz ma l mb mc">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;</span><span id="957f" class="lx ly in lq b gy md ma l mb mc">&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;<br/>    &lt;link rel="stylesheet" href="css/style.css"&gt;<br/>    &lt;link href='<a class="ae ll" href="https://fonts.googleapis.com/css?family=Audiowide'" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css?family=Audiowide'</a> rel='stylesheet'&gt;<br/>    &lt;title&gt;Sliding Tile Puzzle&lt;/title&gt;<br/>&lt;/head&gt;</span><span id="98a1" class="lx ly in lq b gy md ma l mb mc">&lt;body&gt;<br/>    &lt;div id="container"&gt;<br/>        &lt;ul&gt;<br/>            &lt;li&gt;A&lt;/li&gt;<br/>            &lt;li&gt;B&lt;/li&gt;<br/>            &lt;li&gt;C&lt;/li&gt;<br/>            &lt;li&gt;D&lt;/li&gt;<br/>            &lt;li&gt;E&lt;/li&gt;<br/>            &lt;li&gt;F&lt;/li&gt;<br/>            &lt;li&gt;G&lt;/li&gt;<br/>            &lt;li&gt;H&lt;/li&gt;<br/>            &lt;li class="empty"&gt;&lt;/li&gt;<br/>        &lt;/ul&gt;<br/>    &lt;/div&gt;</span><span id="5a5f" class="lx ly in lq b gy md ma l mb mc">&lt;/body&gt;<br/>&lt;script src="js/script.js"&gt;&lt;/script&gt;</span><span id="e335" class="lx ly in lq b gy md ma l mb mc">&lt;/html&gt;</span></pre><p id="b9b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将以下内容添加到样式表中，以设置<code class="fe ln lo lp lq b">empty </code>图块的样式:</p><p id="f167" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/css/style.css</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="dc26" class="lx ly in lq b gy lz ma l mb mc">...<br/>.empty {<br/>    background: #DAD4EF;<br/>    border: 2px solid #114B5F;<br/>}<br/>...</span></pre><p id="1f2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">再次预览:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/8694e68c00f919d4ef38605746bc1c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oU5zyQSAWvJ8dA5PRUIQ-A.png"/></div></div></figure><p id="4b48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们在容器前添加一个漂亮的标题:</p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="1327" class="lx ly in lq b gy lz ma l mb mc">...<br/>&lt;body&gt;<br/>    &lt;h1&gt;Sliding Tile Puzzle&lt;/h1&gt;<br/>    &lt;div id="container"&gt;<br/>        &lt;ul&gt;<br/>            &lt;li&gt;A&lt;/li&gt;<br/>            &lt;li&gt;B&lt;/li&gt;<br/>...</span></pre><p id="71b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以下是标题的样式:</p><p id="fa9b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/css/style.css</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="3500" class="lx ly in lq b gy lz ma l mb mc">h1 {<br/>    color: #E4FDE1;<br/>    font-family: 'Sofia';<br/>    text-align: center;<br/>    <br/>}</span></pre><p id="ede7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在标题部分包含了一个指向<code class="fe ln lo lp lq b">Sofia </code>字体的链接:</p><p id="59ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/index.html</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="6c48" class="lx ly in lq b gy lz ma l mb mc">...<br/>&lt;link href='<a class="ae ll" href="https://fonts.googleapis.com/css?family=Sofia'" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css?family=Sofia'</a> rel='stylesheet'&gt;</span><span id="9103" class="lx ly in lq b gy md ma l mb mc">&lt;link href='<a class="ae ll" href="https://fonts.googleapis.com/css?family=Audiowide'" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css?family=Audiowide'</a> rel='stylesheet'&gt;<br/>    &lt;title&gt;Sliding Tile Puzzle&lt;/title&gt;<br/>...</span></pre><p id="5ef4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">再次预览网页，您应该看到:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mk"><img src="../Images/c4834de1a759ae7fb340245e5690f85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wcKskNX_sxgGzsv3anvhPA.png"/></div></div></figure><p id="2ade" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Boomshakala！游戏的设计已经完成，现在让我们用JavaScript赋予它生命吧！</p><h1 id="5728" class="ml ly in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">用JavaScript实现功能</h1><p id="6aed" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">要玩这个游戏，玩家必须将方块拖放到可用的空方块中。我们将使用<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" rel="noopener ugc nofollow" target="_blank"> HTML拖放API </a>。</p><p id="95d3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个api让我们把一些元素<strong class="kq io">做成可拖动的</strong>和一些<strong class="kq io">做成可放下的</strong>，为此我们必须在脚本文件中定义拖放事件处理程序。打开<code class="fe ln lo lp lq b">script.js</code>，填入以下内容:</p><p id="3b38" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/js/script.js</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="6988" class="lx ly in lq b gy lz ma l mb mc">const dragstart_handler = ev =&gt; {<br/>    console.log("dragstart")<br/>    ev.dataTransfer.setData("text/plain", ev.target.id)<br/>    ev.dataTransfer.dropEffect = "move";<br/>}</span></pre><p id="aa4d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">dragstart_handler</code>处理用户开始拖动时发出的事件<code class="fe ln lo lp lq b">ev </code>。因为我们将在拖动时传输数据，所以我们获取附加到元素的数据，并将其添加到<code class="fe ln lo lp lq b">dataTransfer </code>对象，该对象用于保存在拖放操作中被拖动的数据。</p><p id="3dfa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">用以下内容更新script . js:<br/><code class="fe ln lo lp lq b">/js/script.js/</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="5457" class="lx ly in lq b gy lz ma l mb mc">...<br/>const dragover_handler = ev =&gt; {<br/>    console.log("dragOver");<br/>    ev.preventDefault();<br/>}</span><span id="00c1" class="lx ly in lq b gy md ma l mb mc">const drop_handler = ev =&gt; {<br/>    console.log("drag")<br/>    ev.preventDefault();<br/>    // Get the id of the target and add the moved element to the target's DOM<br/>    const data = ev.dataTransfer.getData("text/plain");<br/>    ev.target.innerText = document.getElementById(data).innerText;<br/>}</span><span id="4341" class="lx ly in lq b gy md ma l mb mc">const dragend_handler = ev =&gt; {<br/>  console.log("dragEnd");<br/>  // Remove all of the drag data<br/>  ev.dataTransfer.clearData();<br/>}</span></pre><p id="cefe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">dragover_handler</code>事件处理程序是一个简单的函数，我们用它执行的唯一重要操作是调用<code class="fe ln lo lp lq b">preventDefault()</code>来阻止对该事件的额外事件处理。我们记录该事件，以便我们可以跟踪它是何时触发的。</p><p id="f74c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ln lo lp lq b">drop_handler</code>事件处理程序中，我们获取存储在<code class="fe ln lo lp lq b">dataTransfer </code>对象中的<code class="fe ln lo lp lq b">data </code>，然后将它“转移”到我们要放入的元素:</p><p id="a046" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">ev.target.innerText = document.getElementById(data).innerText</code></p><p id="6203" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ln lo lp lq b">dragend_handler</code>中，当拖动事件结束时，我们清除存储在<code class="fe ln lo lp lq b">dataTransfer</code>中的数据。</p><p id="9c85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们需要更新<code class="fe ln lo lp lq b">index.html</code>文件，我们将使空磁贴(‘H’磁贴)之前的列表项可拖动，并使空磁贴可放下。</p><p id="f95c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/index.html</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="8663" class="lx ly in lq b gy lz ma l mb mc">...<br/>&lt;ul&gt;<br/>            &lt;li&gt;A&lt;/li&gt;<br/>            &lt;li&gt;B&lt;/li&gt;<br/>            &lt;li&gt;C&lt;/li&gt;<br/>            &lt;li&gt;D&lt;/li&gt;<br/>            &lt;li&gt;E&lt;/li&gt;<br/>            &lt;li&gt;F&lt;/li&gt;<br/>            &lt;li&gt;G&lt;/li&gt;</span><span id="c7fc" class="lx ly in lq b gy md ma l mb mc">            &lt;li id="li8" draggable="true" ondragstart="dragstart_handler(event)" ondragend="dragend_handler(event)"&gt;H&lt;/li&gt;</span><span id="ae53" class="lx ly in lq b gy md ma l mb mc">            &lt;li id="li9" class="empty" ondrop="drop_handler(event);" ondragover="dragover_handler(event);"&gt;&lt;/li&gt;</span><span id="c864" class="lx ly in lq b gy md ma l mb mc">        &lt;/ul&gt;<br/>...</span></pre><p id="e1c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我给了两个列表项id，因为在我们的事件处理程序中，我们必须通过它们的id来获取它们的内容(参见<code class="fe ln lo lp lq b">dragstart_handler</code>中的<code class="fe ln lo lp lq b">ev.dataTransfer.setData(“text/plain”, ev.target.id)</code>)。</p><p id="2a10" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“H”磁贴被制作成<code class="fe ln lo lp lq b">draggable</code>，我还将它的<code class="fe ln lo lp lq b">ondragstart</code>和<code class="fe ln lo lp lq b">ondragend</code>属性设置为相关的事件处理程序。<br/>空磁贴变成了<code class="fe ln lo lp lq b">droppable</code>，它现在拥有了<code class="fe ln lo lp lq b">ondrop </code>和<code class="fe ln lo lp lq b">ondragover </code>事件处理的属性。</p><p id="0211" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">预览网页，将“H”标题拖放到空白标题上:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/0e117571f7274710ab9e29dc41b47f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPHNJypXVqDVrgzhQxN-1Q.png"/></div></div></figure><p id="bce1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">拖放功能可以工作，但是有一个问题。删除“H”图块的内容后，我们现在有两个包含“H”的图块。在删除操作之后，我们需要清空第一个图块。稍后，我们将在拖放操作后更改图块的样式。</p><p id="964e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要在拖放操作后清空源切片，请按如下方式更新脚本文件:</p><p id="1d9d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/js/script.js</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="a216" class="lx ly in lq b gy lz ma l mb mc">...<br/>const drop_handler = ev =&gt; {<br/>    console.log("drag")<br/>    ev.preventDefault();</span><span id="3911" class="lx ly in lq b gy md ma l mb mc">    // Get the id of the target and add the moved element to the target's DOM    <br/>const data = ev.dataTransfer.getData("text/plain");</span><span id="45d0" class="lx ly in lq b gy md ma l mb mc">    ev.target.innerText = document.getElementById(data).innerText;</span><span id="a1ff" class="lx ly in lq b gy md ma l mb mc">    document.getElementById(data).innerText = "";<br/>}<br/>...</span></pre><h1 id="a00e" class="ml ly in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">将所有功能转移到JavaScript</h1><p id="2daa" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">这些图块当前包含html文件中定义的内容，我们将删除这些内容并用JavaScript填充它们。按如下方式更新<code class="fe ln lo lp lq b">index.html </code>文件:</p><p id="db82" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/index.html</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="d719" class="lx ly in lq b gy lz ma l mb mc">...<br/>&lt;ul&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;/li&gt;<br/>        &lt;/ul&gt;<br/>...</span></pre><p id="6ea3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ln lo lp lq b">script.js</code>中键入以下内容:</p><p id="9777" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="2c8d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我使用<code class="fe ln lo lp lq b">querySelectorAll</code>将所有的<code class="fe ln lo lp lq b">li </code>项放入一个<code class="fe ln lo lp lq b">node list</code>(类似于数组的东西)中。<code class="fe ln lo lp lq b">letters</code>数组有一个字母列表，最后一项是空字符串，这是用于空图块的。</p><p id="c2da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ln lo lp lq b">setId</code>函数中，我通过对每个列表项调用<code class="fe ln lo lp lq b">setAttribute()</code>函数来为它们设置id，id由前缀<code class="fe ln lo lp lq b">li</code>和for循环的索引组成。</p><p id="1cb9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ln lo lp lq b">fillGrid</code>函数中，我遍历所有的<code class="fe ln lo lp lq b">li</code>项，同时跟踪它们的索引<code class="fe ln lo lp lq b">i</code>，我用来自<code class="fe ln lo lp lq b">letters</code>数组的一个元素填充每个<code class="fe ln lo lp lq b">list item</code>，用索引<code class="fe ln lo lp lq b">i</code>访问它。</p><p id="404d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你预览网页，你已经像我们之前一样填充了瓦片，但是现在我们是通过JavaScript来完成的。酷:)(还不用担心空磁贴的显示)</p><h2 id="25da" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">随机化瓷砖</h2><p id="afc8" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">瓷砖是用字母A-H的内容填充的，使用当前的脚本，我们将始终拥有相同的瓷砖配置。我们想要的是瓷砖应该被洗牌，这样我们总是得到一个随机的配置，然后必须重新排列来解决这个难题。</p><h2 id="6f39" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">填写前先打乱字母排列</h2><p id="9fc3" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">我们怎样才能写一个函数来洗牌呢？该函数的算法如下<br/> —遍历数组<br/> —对于循环中的每个索引I，选择另一个随机索引j <br/> —交换索引I和j处的元素</p><p id="534e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">停下来。！！在看到我的实现之前，尝试实现这个算法。</p><p id="ecc4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7520" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你有没有想到类似的东西？</p><p id="661f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意，在洗牌之前，我在洗牌函数中对数组做了一个<code class="fe ln lo lp lq b">copy</code>，这确保了我们不会改变(又名<code class="fe ln lo lp lq b">mutate</code>)传入的数组，而是返回一个新的洗牌后的数组。</p><p id="3209" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，更新<code class="fe ln lo lp lq b">fillGrid</code>函数，在填充瓷砖之前首先洗牌:</p><p id="35b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="95b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当您刷新页面时，每次都会获得一个新的磁贴配置！</p><h2 id="dc7c" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">设置可拖放和可拖动的图块</h2><p id="e80f" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">现在，我们将编写一个函数，它将接受一个列表中的<code class="fe ln lo lp lq b">li</code>项，找到内容为空的项，并使其可被丢弃。</p><p id="927a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还将编写一个函数，使页面上的所有磁贴都可以拖动，我们稍后将更改该函数，以便只有空磁贴的顶部、底部、左侧和右侧的磁贴才可以拖动。</p><p id="5987" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这些函数之前，我们将创建一个<code class="fe ln lo lp lq b">setUp</code>函数，从这里我们将进行所有的函数调用。将我们目前拥有的所有函数调用转移到<code class="fe ln lo lp lq b">setUp</code>函数中。</p><p id="5a24" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="2e38" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意，我已经创建了一个<code class="fe ln lo lp lq b">state </code>对象来保存游戏的状态。更新<code class="fe ln lo lp lq b">index.html</code>文件，以便当主体加载时，调用<code class="fe ln lo lp lq b">setUp </code>函数:</p><p id="e0d4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/index.html</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="8066" class="lx ly in lq b gy lz ma l mb mc">...<br/>&lt;body onload="setUp()"&gt;<br/>    &lt;h1&gt;Sliding Tile Puzzle&lt;/h1&gt;<br/>...</span></pre><p id="cebc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您预览页面，您会注意到您可以将磁贴拖放到空磁贴上，但是当您这样做时，磁贴会被填满，但它仍然是空磁贴，并且是您可以拖放磁贴的唯一磁贴。</p><p id="465f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在将更新应用程序，这样，当一个空瓷砖从源瓷砖下降，它会变得“填满”,不再下降。请记住，我们使用了<code class="fe ln lo lp lq b">setAttribute(key, value)</code>函数来设置属性，我们将使用相同的函数来删除属性，我们将把要删除的属性的值设置为一个空字符串。然后，我们将使源图块可丢弃并为空:</p><p id="7a2c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c2c5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在测试应用程序，你会发现每次你拖放一个瓷砖，源成为一个空瓷砖和目的地成为充满！。您还会注意到，您可以拖放与空图块不相邻的图块，稍后我们将解决这个问题。</p><h2 id="ea09" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">获取游戏状态和维度</h2><p id="e712" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">每当玩家拖放一个方块时，方块的排列就会改变，我们希望在<code class="fe ln lo lp lq b">state</code>对象中跟踪这种变化。让我们创建一个获取状态的函数。我们还将创建一个函数，将瓷砖的可视化表示存储为数组的数组。按如下方式更新<code class="fe ln lo lp lq b">script</code>文件:</p><p id="a27d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e196" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">getDimension</code>函数遍历内容(长度为9的字母数组)三次，每次它将三个内容切片并放入一个数组中，这给了我们一个包含3个数组的数组。第一个数组代表游戏的第一行，第二个数组代表第二行，第三个数组代表第三行。</p><p id="a93a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着我们现在有了以两种格式存储的游戏状态:<code class="fe ln lo lp lq b">state.content</code>以线性顺序存储瓷砖(1D数组)；<code class="fe ln lo lp lq b">state.dimension</code>将图块存储在2D数组中作为其视觉表示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/11626aa7a4e71664a3cc9c015330fff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLgait--YZW8kyzjSRDYEQ.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">state.content vs state.dimension</figcaption></figure><p id="99f3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ln lo lp lq b">setUp</code>函数中，我注销了<code class="fe ln lo lp lq b">getDimension</code>函数的输出，你会看到它在一个漂亮的2D数组中存储了游戏的视觉表现。请注意，我在<code class="fe ln lo lp lq b">setDroppable</code>函数中添加了一个新行来存储处于app状态的<strong class="kq io">空图块</strong>的索引，<code class="fe ln lo lp lq b">state.emptyCellIndex = i</code>；这里存储的索引是来自<code class="fe ln lo lp lq b">li</code>项的1D线性数组的索引。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ns"><img src="../Images/0359a720de9fb723be2f0709d61ade41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTS1GS2x0zqHZDaDWl8v1g.png"/></div></div></figure><h2 id="a32e" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">获取空单元格</h2><p id="9a87" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">我们需要得到一个空的单元格，这样我们就可以只拖动其相邻的图块。现在我们可以拖动任何瓷砖到空瓷砖，见下图。在每张图片中，只有虚线块(红色)应该是可拖动的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nt"><img src="../Images/5dbf058fe9f72d928cf9c5ad03d5707e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dm551XG40oDeLyPP6BWaGQ.png"/></div></div></figure><p id="b847" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将创建一个<code class="fe ln lo lp lq b">getEmptyCell</code>函数，从<code class="fe ln lo lp lq b">state.dimension</code>返回空单元格的2D位置。我们已经将空单元的索引存储在存储空单元的1D索引的<code class="fe ln lo lp lq b">state.emptyCellIndex</code>中。</p><h2 id="6cb9" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">如何从1D指数中获得2D头寸</h2><p id="88d8" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">我们将做一些数学运算，以便根据1D指数计算空单元格的2D位置。游戏的2D表示有3行3列；它总共由9块瓷砖组成。<code class="fe ln lo lp lq b"> state.emptyCellIndex</code>包含空单元的线性索引，由于数组的索引从0开始，所以空数组的实际单元号为<code class="fe ln lo lp lq b">state.emptyCellIndex+1</code>。</p><p id="15ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了得到它所在的行，我们将单元格数除以3(一行中的单元格数)。我们取结果的<code class="fe ln lo lp lq b">ceil </code>，这是空值所在的行号。</p><p id="de93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">获取空单元格所在的列是相当棘手的；我们将<code class="fe ln lo lp lq b">emptyCellRow</code>数字乘以3，从结果中减去<code class="fe ln lo lp lq b">emptyCellNumber</code>，然后从3中减去总结果。</p><p id="9d77" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ln lo lp lq b">getState</code>函数之后创建一个<code class="fe ln lo lp lq b">getEmptyCell</code>函数:</p><p id="603e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="7cbb" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">仅使与空单元格相邻的图块可拖动</h2><p id="dfae" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">既然我们已经有了一个获取空单元格位置的方法，我们可以只拖动它周围的相邻单元格。空单元格的上方、下方、左侧或右侧可以有一个可拖动的单元格。空单元有时可能不具有所有4个相邻边:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nt"><img src="../Images/5706d3d1cb8885cdbab9cf32aa6a7f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*benACbtEddNyayse3SDEUg.png"/></div></div></figure><p id="404f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们如何获得与空瓷砖相邻的瓷砖的指数？让我们举个例子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nt"><img src="../Images/5854731d7b46b97bee0c64b97d3a9722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrfULBSmgByNyaA0ylJrJw.png"/></div></div></figure><p id="0590" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的示例中，空图块位于第1行第1列。它左边和右边的图块都在同一行1上。左边的图块在第0列(空图块的行— 1)。右边的图块在第2列(空图块行+ 1)。类似地，顶部和底部瓦片与空瓦片在同一列1上，但是分别在行0和行2上。<br/>让我们更新一下<code class="fe ln lo lp lq b">setDraggable</code>功能:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8f8e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们得到相邻的瓷砖，并只使这些瓷砖可拖动。<br/>测试游戏，您会注意到只有与空方块相邻的方块可以拖动。如果你对游戏进行了足够的测试，你将会注意到，一些在空方块相邻时已经可以拖动的方块，在空文件填满后仍然可以拖动。</p><p id="5705" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们如何解决这个问题？<strong class="kq io">简单的</strong>:我们需要在每次完成拖拽的时候更新应用状态和维度。按如下方式更新<code class="fe ln lo lp lq b">script</code>文件:</p><p id="5214" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c95b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有一个微妙的问题与我们刚刚解决的问题类似。所有我们在空的时候设置为可丢弃的瓷砖仍然是可丢弃的，即使它们被填满，我们现在将创建一个函数(名为<code class="fe ln lo lp lq b">removeDroppable</code>)来使瓷砖一旦被填满就不可丢弃。</p><p id="30ef" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将在<code class="fe ln lo lp lq b">dragend_handler</code>函数中调用这个函数。在<code class="fe ln lo lp lq b">setDroppable</code>函数后创建一个<code class="fe ln lo lp lq b">removeDroppable</code>函数，并在<code class="fe ln lo lp lq b">dragend_handler</code>函数中调用，如下所示:</p><p id="2d7e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">/js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="83d8" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">直到最后一步</h2><p id="d590" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">游戏几乎完成了，我们现在必须检查用户是否按照正确的顺序排列了方块。在此之前，我们需要考虑8-puzzle tile的一个重要性质:<strong class="kq io">并不是所有的构型都是可解的</strong>。</p><p id="b413" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为我们是在随机化瓷砖，所以有可能得到一个不可解的配置。我们如何判断给定的谜题实例是否是可解的？</p><p id="8449" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">只有在配置</strong>中<em class="lk">反转</em>的数量为偶数时，给定的8字谜实例才是可解的。</p><p id="12b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">什么是倒置？当一对瓦片处于本应处于正确配置的<code class="fe ln lo lp lq b">reverse </code>顺序时，就会发生反转。例如，给定以下配置:</p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="1370" class="lx ly in lq b gy lz ma l mb mc">[<br/> ["A", "B", "C"],<br/> ["D", "", "E"],<br/> ["H", "F",  "G"]<br/>]</span></pre><p id="796f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构型(H，F)和(H，G)有两个逆，由于逆的个数是两个(偶数)，这个构型将是可解的。为了知道一个给定的构型是否可解，我们计算了反演的次数。我们如何做到这一点？</p><p id="7902" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">简单的</strong>:我们挑选每一个元素，并与它后面的其他元素进行比较，如果第一个元素‘大于’第二个元素，那么我们就遇到了反演。打开<code class="fe ln lo lp lq b">script.js</code>文件，在<code class="fe ln lo lp lq b">fillGrid</code>函数之前创建一个<code class="fe ln lo lp lq b">inSolvable</code>函数，我们还将更新<code class="fe ln lo lp lq b">fillGrid</code>函数，以便仅在生成的配置可解的情况下填充图块:</p><p id="a187" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="18e9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们确信配置将总是可解的！</p><h1 id="d22b" class="ml ly in bd mm mn mo mp mq mr ms mt mu jt mv ju mw jw mx jx my jz mz ka na nb bi translated">检查正确的解决方案</h1><p id="e187" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">我们现在必须检查玩家何时解决了这个难题。我们将创建一个<code class="fe ln lo lp lq b">isCorrect</code>函数，它将接受<code class="fe ln lo lp lq b">state.content</code>和<code class="fe ln lo lp lq b">letters</code>数组，将它们转换成一个字符串，然后比较这两个字符串以检查它们是否相等。在<code class="fe ln lo lp lq b">isSolvable</code>功能后创建功能:</p><p id="fec7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="6d50" class="lx ly in lq b gy lz ma l mb mc">...<br/>const isCorrect = (solution, content) =&gt; {<br/>    if(JSON.stringify(solution) == JSON.stringify(content)) return true;<br/>    return false;<br/>}<br/>...</span></pre><p id="b5a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们什么时候检查解决方案？在每个拖动事件结束时，我们必须更新<code class="fe ln lo lp lq b">dragend_handler</code>函数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="53f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尝试游戏，当排列正确时，消息被记录到控制台。我们不希望我们的游戏玩家检查控制台，以了解他们何时解决了难题。我们将创建一个模型，当谜题被解决时会弹出，我将移动得快一点，代码很容易理解:</p><p id="e938" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">index.html</code></p><pre class="kd ke kf kg gt lt lq lu lv aw lw bi"><span id="692e" class="lx ly in lq b gy lz ma l mb mc">...<br/>&lt;body onload="setUp()"&gt;<br/>    &lt;h1&gt;Sliding Tile Puzzle&lt;/h1&gt;<br/>    &lt;div id="modal" class="hide"&gt;<br/>        &lt;div id="header"&gt;&lt;button id="closeBtn" onclick="hideModal()"&gt;x&lt;/button&gt;&lt;/div&gt;<br/>        &lt;h1 id="message"&gt;You won!&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>    &lt;div id="container"&gt;<br/>...</span></pre><p id="b513" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">css/style.css</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f0fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ln lo lp lq b">js/script.js</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="9eb8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">立即尝试游戏:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/1348d309bb846c9f14f5dc50aa0e07dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0vz9zA3R6-akb4RWApiBA.png"/></div></div></figure><h2 id="4e08" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated">恭喜你！！！</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6a2375cf24c81321498fb0abfd676315.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*TjM-dFtrbq_SVJklVBGOIw.gif"/></div></figure><p id="ee05" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">哇！这是一个漫长的旅程，我希望你已经学到了一些新的东西，并在构建8益智游戏时获得了乐趣。完整的代码在github <a class="ae ll" href="https://github.com/Olusamimaths/8-Puzzle-Game-Js-Tutorial-Files" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="f807" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你觉得这篇文章有帮助，请分享它，你也可以在Twitter<a class="ae ll" href="https://twitter.com/solathecoder" rel="noopener ugc nofollow" target="_blank">@ sola the code</a>上关注我，获取更多精彩的技术文章。</p><p id="b726" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">直到我们再次相见，编码快乐！</p><h2 id="9a27" class="lx ly in bd mm nh ni dn mq nj nk dp mu kx nl nm mw lb nn no my lf np nq na nr bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="fca8" class="pw-post-body-paragraph ko kp in kq b kr nc jo kt ku nd jr kw kx ne kz la lb nf ld le lf ng lh li lj ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae ll" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae ll" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">订阅我们的YouTube频道</strong> </a> <strong class="kq io">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>