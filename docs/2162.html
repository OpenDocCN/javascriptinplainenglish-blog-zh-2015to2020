<html>
<head>
<title>Deploy your Node app to AWS Container Service via GitHub Actions &amp; build a pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过GitHub Actions将您的节点应用程序部署到AWS容器服务，并构建一个管道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deploy-your-node-app-to-aws-container-service-via-github-actions-build-a-pipeline-c114adeb8903?source=collection_archive---------0-----------------------#2020-05-26">https://javascript.plainenglish.io/deploy-your-node-app-to-aws-container-service-via-github-actions-build-a-pipeline-c114adeb8903?source=collection_archive---------0-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/735f734bb2134701bc8682df4f552051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yu0XZWVlnbUufcQ_aRnS9w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A successful build &amp; deployment 💚</figcaption></figure><p id="d564" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将您的应用程序部署到一个平台上是必须的，这一点没有人可以否认。</p><p id="2faa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">没有它，你的应用程序就无法从互联网上访问，人们也无法体验你努力开发的应用程序😢。</p><p id="a8c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，<strong class="ke ir">自动化部署</strong>——当您或您的团队将一些全新的新代码推向源代码控制时——同样重要，因为您不想浪费宝贵的时间来进行手动、繁琐的部署。</p><p id="0b3f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">设置复杂的CI/CD管道可能很棘手，但也相当昂贵💸。有时使用像Jenkins这样复杂的工具可能是值得的(也是必要的)，但是大多数时候，通过使用简单的工具，您可以使您的生活变得更加简单。比如GitHub的动作。</p><p id="388c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我们将利用GitHub Actions和Amazon Elastic Container Service的强大功能来创建一个自动化流程，该流程从您的应用程序自动构建Docker映像，并将其部署到您的AWS ECS集群。</p><p id="2da7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将以Node.js应用程序为例:一个服务器端呈现的Next.js应用程序，并围绕它构建解决方案。但是，您可以使用任何具有公开端口(如3000、8080、4000或任何数字)和docker文件的节点应用程序。实际上，您可以使用任何具有Dockerfile文件和公开端口的应用程序🎉。<br/>你将不得不根据你的需要调整一些东西，但是一般步骤是完全一样的，这篇文章将指导你完成这个过程。</p><p id="60a1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以让我们开始吧！🔥</p><h1 id="16d4" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动机</h1><h2 id="5a43" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">为什么是AWS？</h2><p id="c86a" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">没人能否认亚马逊网络服务(AWS)是☁️.云计算领域的领导者对拥有AWS技能的开发人员有巨大的需求，因为许多公司要么迁移到云，要么已经在云上运行他们的应用程序。</p><p id="8b71" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">AWS弹性容器服务(ECS)使运行您的集装箱码头应用程序变得简单。基本上，如果您有一个Docker映像，您可以在AWS ECS中轻松部署它。您不需要管理基础设施或任何底层操作(假设您使用的是AWS Fargate——您将会使用)。</p><p id="be16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我们还将使用其他核心AWS组件，如弹性负载平衡器、弹性容器注册表(用于存储Docker图像)、安全组、IAM等。</p><h2 id="e559" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">为什么选择GitHub Actions？</h2><p id="130a" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">有时团队努力建立一个复杂且昂贵的CI/CD渠道，就像Jenkins一样。GitHub Actions使得创建CI/CD管道变得容易，至少对于某些用例是这样。</p><p id="a6a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最好的事？GitHub actions对公共存储库是免费的，你对私有存储库也有2000分钟的免费时间，如果你刚开始用一个app的话，这是绰绰有余的(事后也确实便宜，目前每分钟0.008美元)。</p><p id="53cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将设置GitHub操作来从我们的代码构建Docker映像，将其推送到AWS容器注册中心，然后部署到我们的AWS弹性容器服务应用程序。</p><h2 id="67d3" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">为什么是Next.js？</h2><p id="e991" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated"><a class="ae mp" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>最近被大肆宣传，但理由很充分。Next.js以非常简单的方式支持服务器端呈现。服务器端渲染可以在很多方面提供帮助，比如潜在地加快你的应用程序的加载时间和提升你的搜索引擎优化。</p><p id="5019" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，Next.js并不仅仅是因为方面而伟大。Next是一个很好的开发工具，在JS解决方案中自带了很好的CSS，路由很容易，它还能生成静态站点，有很好的文档，它的受欢迎程度非常高。很有前途🚀。</p><p id="80bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如上所述，您可以使用任何带有Dockerfile文件的应用程序，并围绕它轻松构建GitHub Actions + AWS ECS。</p><h1 id="0720" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们将完成什么？</h1><p id="8ef0" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们希望最终有一个托管在GitHub上的Next.js应用程序，每次我们向<em class="mq">主</em>分支推送新的更改，新的应用程序版本将自动构建并部署在AWS ECS上，因此任何人都可以在互联网上访问🎆。</p><p id="7560" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文并不是对AWS或Next.js的完整介绍。为AWS创建一个帐户超出了本文的范围，但是您肯定会找到很多很好的入门资源💪。</p><p id="3568" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将构建的下一个. js应用程序也是基本的，它只是作为概念的证明。然而，在您设置了整个CI/CD流之后，您可以使用它来制作一个生产就绪的应用程序，或者将这个概念应用到您现有的节点应用程序中😎。</p><h1 id="2a19" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><ol class=""><li id="1719" class="mr ms iq ke b kf mk kj ml kn mt kr mu kv mv kz mw mx my mz bi translated">首先，您需要有一个AWS帐户，并且可能需要一些信用来开始使用AWS ECS(使用Fargate)。</li><li id="7174" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">确保安装了AWS CLI，并且您拥有必要的访问权限。</li><li id="8dcb" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">你需要在GitHub上托管你的项目。对于公共项目，GitHub的所有操作都是终身免费的，因为GitHub支持开源项目。那真的很酷。</li></ol><h1 id="c9cf" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入门指南</h1><h2 id="1210" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">创建一个新的Next.js项目并将其推送到GitHub</h2><p id="cda8" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们将创建一个简单的单页Next应用程序，它将从<a class="ae mp" href="http://postcodes.io/" rel="noopener ugc nofollow" target="_blank">的邮政编码中随机获取一个英国邮政编码。使用这种方法，我们可以测试服务器端的渲染。我们将通过服务器端呈现(最终将在ECS上运行)在服务器端发出请求，而不是在客户端发出请求。</a></p><p id="0f14" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我已经创建了项目，你可以在这里找到:<a class="ae mp" href="https://github.com/adamkss/next-uk-post-codes" rel="noopener ugc nofollow" target="_blank">https://github.com/adamkss/next-uk-post-codes</a>。</p><p id="afd5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">克隆并把它推送到你的GitHub账户，或者把它取出来，这样你也可以把这个项目放在你自己的GitHub用户下。</p><p id="76f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要在本地运行项目，请在终端中执行以下命令:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="219e" class="ly lb iq nk b gy no np l nq nr">npm install &amp;&amp; npm run dev</span></pre><p id="ffc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们快速浏览一下这个项目的一些文件。</p><p id="02ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> index.js </strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/921ba41c14b5d8e359d0a2a3554a3eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLQ9jpX3oEFMRso5q3Ge0g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">pages/index.js</figcaption></figure><p id="f265" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是主页。我们正在定义一个<code class="fe nt nu nv nk b">getServerSideProps</code> <strong class="ke ir"> </strong>异步函数。这就是服务器端渲染奇迹发生的地方，⭐️.该功能在服务器上执行，并在实际的React组件(主页)中添加了某些道具。</p><p id="64dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的例子中，我们使用<strong class="ke ir"> axios </strong>(一个HTTP客户端库)从public postcodes.io API获取一个随机的邮政编码，并将结果作为一个属性传递给组件。</p><p id="7e97" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">页面如下所示(每次页面刷新显示不同的邮政编码):</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/d5c465072d15b634311f6badc582b73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERc6sc8Rpms67l2derSuYg.png"/></div></div></figure><p id="75fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Dockerfile </strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/ea0cb80eeddf2b60b661aef5dcfb37c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfeOhH078qvBpch5yr0lfw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Dockerfile</figcaption></figure><p id="82d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个标准的Docker文件，告诉Docker如何建立我们的应用程序的形象。</p><p id="9320" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，所有的文件都被复制到镜像中，<code class="fe nt nu nv nk b">npm install</code>被运行，<code class="fe nt nu nv nk b">npm run build</code> <em class="mq"> </em>构建Next.js app，依次调用<code class="fe nt nu nv nk b">next build</code> <em class="mq"> </em>，在<code class="fe nt nu nv nk b">package.json</code> <em class="mq">中指定。</em></p><p id="3638" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">映像的启动命令是<code class="fe nt nu nv nk b">npm start</code>，它运行构建和优化的Next.js应用程序🆒。</p><p id="9a9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">ECS-任务-定义. json </strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/a8ce548e24dfa63da8c59319bee85452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrT-OExdHcWlSya8fkUEPg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">ecs-task-definition.json</figcaption></figure><p id="6cb4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该文件用于定义我们将在ECS集群中运行的容器。</p><p id="1a1d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看一下<code class="fe nt nu nv nk b">containerDefinitions</code>属性。您可以看到Docker映像的名称和标签以及端口映射。我们将根据您自己的情况重新访问和更新这些属性。</p><p id="3db8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该文件的最后两个属性用于定义任务定义所需的处理能力和内存。这里我们为CPU设置了512(相当于0.5个ECS虚拟CPU)和1024 MB的RAM。对于单个容器来说，这些值应该足够了，尤其是对于刚开始的时候。</p><p id="fec7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nt nu nv nk b">cpu</code>属性的最小值是256(一个ECS虚拟CPU的25%)，对于<code class="fe nt nu nv nk b">memory</code>是512。</p><h2 id="7557" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">AWS ECS定价</h2><p id="b464" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">在继续之前，我们必须谈一谈ECS定价。</p><p id="eca3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">ECS有多种发布类型。这意味着，您可以手动指定EC2机器(虚拟机)——您的容器将在其上运行——或者您可以让Amazon管理并指定虚拟CPU和内存量。</p><p id="c0a6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将采用第二种方案，因为它更简单，也更现代。此外，这种方法被称为<strong class="ke ir"> Fargate </strong>发射类型。</p><p id="e93c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在撰写本文时，使用0.5 vCPU和1GB RAM运行一个ECS任务定义(一个或多个容器/应用程序)每月将花费大约18美元。</p><h2 id="ab4c" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">我们需要从AWS获得的东西</h2><p id="134d" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">为了在ECS上成功运行Docker容器，我们需要以下组件:</p><ol class=""><li id="efb1" class="mr ms iq ke b kf kg kj kk kn nz kr oa kv ob kz mw mx my mz bi translated">ECS集群</li><li id="9db2" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">一个ECR(弹性容器注册)库。这是我们的Docker图像将被存储的地方📷</li><li id="f862" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">ECS任务定义。这基本上就是我们将要运行的容器的描述。我们将有一个容器，我们的应用程序:下一个英国邮政编码。我们已经有了一个JSON形式的任务定义:<code class="fe nt nu nv nk b">ecs-task-definition.json</code></li><li id="993c" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">ECS服务，它将在我们创建的ECS集群中运行我们的任务定义</li></ol><h2 id="182b" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">设置AWS ECS集群</h2><p id="7972" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们将使用AWS在线控制台来设置和配置将保存您的应用程序的ECS群集。</p><p id="2774" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，导航到弹性容器服务:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/8936010e231a7ecd1f52a43917722c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9Ku0FSBDmon_eocJfaFWQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">AWS ECS (Elastic Container Service) homepage</figcaption></figure><p id="3368" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">点击<strong class="ke ir">创建集群</strong>，创建一个新的集群来存放您的应用。然后选择“仅联网”——由Fargate供电。</p><blockquote class="od oe of"><p id="dfc8" class="kc kd mq ke b kf kg kh ki kj kk kl km og ko kp kq oh ks kt ku oi kw kx ky kz ij bi translated">Fargate是ECS中使用容器的一种方式。基本上，使用Fargate，您不必管理底层基础设施，如AWS EC2机器。只需指定容器需要的处理能力，其他一切都由Fargate负责。</p></blockquote><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/5487432192dcf772c94154d562e98660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0weMjGm1SSM-Mk0GmmjcQ.png"/></div></div></figure><p id="cbfd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">点击<strong class="ke ir">下一步，</strong>为您的集群命名，然后点击<strong class="ke ir">创建:</strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/42b74e88904ca7c0dcd2c34f2b81e3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAJ-ICMS7qFsgEbTr_od5w.png"/></div></div></figure><p id="cc10" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">太好了！现在我们有了一个集群，我们的应用程序将位于其中:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/292e7412c2398b3069b70f2196c85f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s47EENArHDBEkcPgGuWvwQ.png"/></div></div></figure><p id="a0be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一步中，我们将创建一个ECR来保存我们生成的容器图像。点击左侧导航栏中的<strong class="ke ir">Amazon ECR-Repositories</strong>。</p><h2 id="b893" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">为您的应用程序创建ECR存储库</h2><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/ca9e6b53bc25ec0bbc78a2b96810e768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upOL7bCxzvrmVYe8xjk97A.png"/></div></div></figure><p id="dfa5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在ECR存储库页面上，点击<strong class="ke ir">创建存储库，</strong>为您的ECR存储库命名，然后点击<strong class="ke ir">创建存储库:</strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/4d102b5aded53e068af5909c85a9a104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUoux4lib0EtgqgbJ3krsA.png"/></div></div></figure><p id="6887" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">干得好！现在，您应该有了一个带有特定URI的工作ECR存储库。复制那个URI，放入你的应用项目的<code class="fe nt nu nv nk b">ecs-task-definition.json</code>、<code class="fe nt nu nv nk b">image</code>属性<strong class="ke ir"> : </strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/e91bd8f18923e2f77e3fe0b937221a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqwbRnaqBW0bUQPJGZpqqw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">You can take the URI from the repositories’ overview list</figcaption></figure><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/0dcf1b586dde399b364749cf55041a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cumjzscG-ImvM6O5VcYUbA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">ecs-task-definition.json</figcaption></figure><p id="fa65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">粘贴URI时要格外小心。您还必须将<code class="fe nt nu nv nk b">latest</code> <strong class="ke ir"> </strong>标记留在其后，因为标记有<code class="fe nt nu nv nk b">latest</code>的Docker映像将被部署到ECS上。</p><h2 id="9dc5" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">配置执行角色</h2><p id="a6c6" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">对于ECS中的每个任务定义(我们的<code class="fe nt nu nv nk b">ecs-task-definition.json</code>是我们的任务定义)，您必须有一个适当的执行角色。</p><p id="fbfd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您必须将自己的执行角色的ARN (Amazon Resource Number)放在<code class="fe nt nu nv nk b">ecs-task-definition.json</code>中。</p><p id="08c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要检查您是否已经拥有这样的角色，请导航到在线控制台中的ECS -&gt;任务定义，然后单击<strong class="ke ir">创建新的任务定义。</strong></p><p id="abf6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们实际上不会在在线控制台上创建任务定义，但是这是确保我们有一个<code class="fe nt nu nv nk b">ecsTaskExecution</code>角色的最简单的方法。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/debfb34ec113873201187895f39bf80e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VzMvIdnhPGfgjJd8z2KIQ.png"/></div></div></figure><p id="348f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在创建新任务定义页面上，您应该选择Fargate，单击<strong class="ke ir">下一步</strong>并滚动到<strong class="ke ir">任务执行IAM角色</strong>部分。</p><p id="6688" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您应该已经在下拉列表中看到该角色(<code class="fe nt nu nv nk b">ecsTaskExecutionRole</code>):</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/3126bf5fd55760aefed9557a4a91e376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xd9PQLIXujxkqIbl5n4Oqg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The task execution IAM role</figcaption></figure><p id="80df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完美！现在我们应该得到这个角色的ARN。</p><p id="1ef9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在AWS控制台中导航到IAM，然后导航到Roles。从列表中选择<code class="fe nt nu nv nk b">ecsTaskExecutionRole</code>并复制<strong class="ke ir">角色ARN: </strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/cf450ebaf40b6f43b9cb2d71db9fed21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TK4uKE2U_BnEh6udfP3SIQ.png"/></div></div></figure><p id="3388" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在将它粘贴到您的<code class="fe nt nu nv nk b">ecs-task-definition.json</code>中的<code class="fe nt nu nv nk b">executionRoleArn</code>属性中:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/54486c2233733a73864fd27f195aae7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTLXXt0O3A0sDEAqXLMTFw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We now also have the executionRoleArn in our ecs-task-definition.json</figcaption></figure><h2 id="f45a" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">将我们的任务定义导入AWS</h2><p id="a6bc" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">对于这一步，我们将使用AWS CLI。</p><p id="c570" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将通过AWS CLI导入<code class="fe nt nu nv nk b">ecs-task-definition.json</code>中描述的任务定义。</p><p id="e922" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请确保您已登录到AWS CLI，并执行以下命令，该命令根据<code class="fe nt nu nv nk b">ecs-task-definition.json:</code>创建您的ECS任务定义</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="ec0a" class="ly lb iq nk b gy no np l nq nr">aws ecs register-task-definition --region us-east-2 --cli-input-json file://./ecs-task-definition.json</span></pre><p id="e9ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请确保相应地更改您的地区🌎。</p><h2 id="86c0" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">配置负载平衡器</h2><p id="7049" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">拥有一个负载平衡器总是一个好主意。</p><p id="2f30" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用我们选择的AWS负载平衡器(应用程序负载平衡器— ALB)可以帮助我们横向扩展我们的应用程序，拥有SSL终端(免费使用HTTPS保护)并以不会影响客户端的方式更改我们的AWS设置的内部组件。</p><p id="3140" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，安装负载平衡器是要花钱的，如果全天候运行的话，每月大约需要10-20美元🕐。</p><p id="879b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在AWS在线控制台中，导航到EC2页面，然后导航到负载平衡器子部分，并单击<strong class="ke ir">创建负载平衡器。</strong>选择符合我们需求的<strong class="ke ir">应用负载平衡器</strong>。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/a7f85145f7ed2d8029995773ccbfd082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6p5gyx0a8cu3UbUxc--bA.png"/></div></div></figure><p id="c57a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在配置页面上，确保为您的ALB命名，选择“面向互联网”，确保您在端口80上有一个HTTP侦听器，并选择您的VPC和子网。点击<strong class="ke ir">下一步</strong>。</p><p id="534a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第二页上，它可能会告诉您尚未配置安全端口(我们可以用于HTTPS)。暂时没问题。通过负载均衡器实现TLS不是本文讨论的范围，但是设置它真的很容易。点击下一个的<strong class="ke ir">。</strong></p><p id="9858" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在“配置安全组”页面上，确保创建一个新的安全组，为其命名，并打开端口80:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/8673a6206ce963ad686e7a622b9db75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tg6NXWJnEsyBSKZgnvBqlw.png"/></div></div></figure><p id="c812" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一页，您将创建一个目标组。创建一个新的目标组，并为其命名。保持其他设置不变，然后单击下一步。</p><blockquote class="od oe of"><p id="e96b" class="kc kd mq ke b kf kg kh ki kj kk kl km og ko kp kq oh ks kt ku oi kw kx ky kz ij bi translated">一个<strong class="ke ir">目标组</strong>是一组机器(在我们的例子中是容器)，负载均衡器会将传入的请求路由到这些机器。</p></blockquote><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/f84bd08eb6bdc6aa87e2d6ae2f799bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6C-GNrX8vb_HoVksMcDP_A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Specify a new target group name and click next</figcaption></figure><p id="1e9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一页，您可以注册目标组中的目标。我们没有设置任何，因为ECS稍后会自动将它们设置到我们应用程序的容器实例中。只需单击Next，您的应用程序负载平衡器就应该创建好了🎆。</p><h2 id="06a8" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">创建ECS服务</h2><p id="f84e" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">现在，您已经有了任务定义、ECS中的集群以及负载平衡器，唯一缺少的是ECS服务。</p><p id="b5af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我们的ECS设置的组件，它实际上在我们的ECS集群中运行指定数量的任务定义。</p><p id="b5ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在在线控制台中转至AWS ECS，并导航至<strong class="ke ir">集群</strong>。选择您创建的集群。默认视图应该是服务选项卡。点击<strong class="ke ir">创建:</strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/d0fe0152fa24e4757686bb3389873f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUHxyl_OCblJxMk-NIA0iw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We can create a new service in the cluster, that will actually run our task definition</figcaption></figure><p id="00d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir">配置服务</strong>页面选择Fargate作为启动类型，确保任务定义是正确的，给服务一个名称并指定任务数量，现在应该是一个。</p><p id="e135" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在“部署”部分下，保留“滚动更新”。然后点击<strong class="ke ir">下一步</strong>。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/b258a7c44c63268ab6406fe73bb3b3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6TTFkTWj5ROrPhxBIt4Eg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Select Fargate, specify a service name and task definition count (only 1 for now)</figcaption></figure><p id="2f66" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一页中，选择您选择的VPC和子网(您已经在创建负载平衡器时选择了它们)。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/8163881fc06997503ff862355af3c761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1xcExhxCTSNn5raV3PVyA.png"/></div></div></figure><p id="3e13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Security groups -&gt; Edit下，创建一个新的安全组，并只打开端口3000(这是一个自定义的TCP端口)。</p><blockquote class="od oe of"><p id="5d62" class="kc kd mq ke b kf kg kh ki kj kk kl km og ko kp kq oh ks kt ku oi kw kx ky kz ij bi translated">我们使用端口3000，因为这是我们的容器公开Next.js应用程序的端口。您需要设置应用程序公开的任何端口。</p></blockquote><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/087a33c807eab850d2f9eda7fca09eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4c8YpCmIee94_X71U7hgJQ.png"/></div></div></figure><p id="7331" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，在<strong class="ke ir">负载平衡器类型</strong>部分，选择应用程序负载平衡器，并选择您刚刚创建的ALB:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/5d1fa0f1bee37b2e906fe2a16a9957d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M5SbBHfEzLjQiYz06R-mQ.png"/></div></div></figure><p id="bd5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">选择ALB后，在<strong class="ke ir">负载平衡器类型</strong>之前的部分，您现在可以指定<strong class="ke ir">健康检查宽限期</strong>。<strong class="ke ir"> </strong>在那里放10(如在10秒内)。</p><blockquote class="od oe of"><p id="bc2b" class="kc kd mq ke b kf kg kh ki kj kk kl km og ko kp kq oh ks kt ku oi kw kx ky kz ij bi translated">健康检查宽限期告诉ECS在它认为容器不健康之前应该等待多少秒。由于我们的Next.js应用程序不会立即启动，我们应该将其设置为几秒钟。</p></blockquote><p id="fa55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，在<strong class="ke ir">容器到负载平衡器</strong>部分，确保“next-uk-post-codes”容器被选中(根据任务定义，您只有这一个),并单击<strong class="ke ir">添加到负载平衡器</strong>:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/27019a22ce388f3d1597902711859e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1FAZnMQmxYUwUuCBrvPNQ.png"/></div></div></figure><p id="578b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">进行以下修改:</p><ol class=""><li id="c398" class="mr ms iq ke b kf kg kj kk kn nz kr oa kv ob kz mw mx my mz bi translated">选择<strong class="ke ir"> 80:HTTP </strong>作为生产监听器端口</li><li id="62e7" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">创建一个新的目标组，并给它一个名字(如果你想知道，不幸的是，似乎不可能重用我们用ALB创建的目标组)</li><li id="a7d2" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">选择HTTP作为目标组协议</li><li id="69e4" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">对于路径模式put <code class="fe nt nu nv nk b">/</code>，评估顺序为1(因此它在ALB中首先被评估)</li><li id="22c9" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">对于健康检查路径，也放入<code class="fe nt nu nv nk b">/</code>(这是到Next.js中我们主页的路径)。这通常可以是您的应用程序公开的、可用于检查其健康状况的任何端点。</li></ol><p id="31f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<strong class="ke ir">服务发现</strong>部分下，取消选中<strong class="ke ir">启用服务发现集成</strong>，因为我们不需要它。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/4754f6d41826938132b77d10a157d0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJvnGBCS_--j6dJWNu2CCg.png"/></div></div></figure><p id="66f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">点击<strong class="ke ir">下一步</strong>后，您将看到自动缩放选项。选择暂时不调整。点击<strong class="ke ir">下一步</strong>，然后在最后一页点击<strong class="ke ir">创建服务</strong>。</p><h2 id="53ab" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">为GitHub操作创建IAM用户</h2><p id="1b02" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">因为GitHub Actions需要访问以下AWS资源:</p><ol class=""><li id="80f4" class="mr ms iq ke b kf kg kj kk kn nz kr oa kv ob kz mw mx my mz bi translated">将应用程序的Docker映像推送到ECR存储库中</li><li id="0d7d" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">将应用程序部署到ECS</li></ol><p id="2b56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">，您需要在AWS IAM中为它创建一个用户。为此:</p><ol class=""><li id="4cb6" class="mr ms iq ke b kf kg kj kk kn nz kr oa kv ob kz mw mx my mz bi translated">导航到AWS在线控制台中的IAM</li><li id="a694" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">选择用户，点击<strong class="ke ir">添加用户。</strong>给用户一个名称并选择编程访问。点击<strong class="ke ir">下一步</strong></li></ol><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/94ab9306fe70caeeadc8564b40a74adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pXGlXbIlvkaZnO3glL7EQ.png"/></div></div></figure><p id="fe3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.在下一页上，选择<strong class="ke ir">直接附加现有策略</strong>，并搜索ECS。选择<code class="fe nt nu nv nk b">AmazonECS_FullAccess</code>，然后搜索“Container”并选择<code class="fe nt nu nv nk b">AmazonEC2ContainerRegistryFullAccess</code>——这将让GitHub Actions推送至您的ECR存储库。点击<strong class="ke ir">下一个</strong>。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/c6b6085122775347b7bee8d4845b3f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Epp4OdwX_BNtsmKu-pWZbA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This policy is used to control ECS</figcaption></figure><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/bedefbe945aa2dee936df00d2a2a7751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZvX-6oWnTBskxImZKToUg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This policy is used to push to ECR</figcaption></figure><p id="4841" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.在<strong class="ke ir">标签</strong>页面上，将其留空并点击下一步，然后在最后一个页面上点击<strong class="ke ir">创建用户</strong></p><p id="ee5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.在最后一个页面上，您应该可以看到新创建的用户的所有信息。将访问密钥ID和秘密访问密钥保存在安全的地方，或者将其导出为CSV文件</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/46a6001c9c2c7cea210fede78d74dff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UC05HkFfNCkVR50PmScdHw.png"/></div></div></figure><p id="aa7b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将马上把这个用户的证书添加到你的GitHub项目的秘密中。</p><h1 id="2683" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置GitHub操作</h1><p id="3ef1" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">在我们继续之前，你应该在GitHub上有你自己的应用程序代码库。如果你正在使用我的Next.js的例子，你要么分叉它，拉它，然后把它推到你自己的遥控器上，要么从头开始做一个项目。</p><p id="503d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们必须将AWS凭证添加到GitHub Secrets中。这样，GitHub Actions将能够在执行工作流时读取它们。</p><ol class=""><li id="7627" class="mr ms iq ke b kf kg kj kk kn nz kr oa kv ob kz mw mx my mz bi translated">在您项目的GitHub页面上选择<strong class="ke ir">设置</strong>并导航到<strong class="ke ir">秘密</strong></li></ol><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/d0b74e5840e536659a9350a4d97425a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBvlUxFqAw-akP0YlUsuOg.png"/></div></div></figure><p id="9a13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.创建两个秘密，一个名为<code class="fe nt nu nv nk b">AWS_ACCESS_KEY_ID</code>，另一个名为<code class="fe nt nu nv nk b">AWS_SECRET_ACCESS_KEY</code>。用您刚刚从AWS控制台保存的AWS凭证填充它们。</p><p id="846f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">酷，现在一切都设置好配置我们的GitHub行动！🕺</p><p id="c86b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">再次指出，GitHub Actions是<strong class="ke ir">免费的，</strong>无论如何，如果你的库是公开的🎆。去开源！</p><p id="56da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，如果你有一个私有的存储库，你每个月都有大量的GitHub动作的自由执行时间，这可能绰绰有余，至少对于启动项目来说是如此。</p><p id="1dc7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">说够了，让我们开始吧！</p><p id="178e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">需要注意的是，GitHub动作会在您的GitHub存储库中的<code class="fe nt nu nv nk b">.github/workflows</code>文件夹下创建一个文件。如果你已经克隆/派生了我的例子，并且已经有了这个目录，请删除它并把修改推送到GitHub，因为最好从零开始。</p><p id="9ec1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们在GitHub项目的在线编辑器中点击工具栏中的<strong class="ke ir">动作</strong>，然后点击<strong class="ke ir">创建新工作流:</strong></p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/068d2ed8bb7581c3a0f644df7e7efdca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLE9l9k0OHgSFEMzdDlSVA.png"/></div></div></figure><p id="3da9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">搜索<strong class="ke ir">部署到Amazon ECS </strong>工作流，并点击<strong class="ke ir">设置该工作流。</strong></p><p id="cfee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在您应该会看到一个类似page的编辑器:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/5f3f99a2ad6a03fe43ed32ad4c29a4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Q0MSzt8prE1738nxoIeLQ.png"/></div></div></figure><p id="a272" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是您实际配置GitHub动作的地方🤔。如果仔细观察，这个动作实际上使用了多个其他动作，比如配置AWS凭证的动作、登录Amazon ECR的动作、配置任务定义的动作和部署任务定义的动作。</p><p id="0a06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，对代码进行以下更改:</p><ol class=""><li id="ab38" class="mr ms iq ke b kf kg kj kk kn nz kr oa kv ob kz mw mx my mz bi translated">在注释掉的块之后，您将看到一个<code class="fe nt nu nv nk b">on:</code>属性。这指定了该特定工作流应该何时运行。有许多选项，如每次推送时运行、每次合并等。我们将设置它，使它在<code class="fe nt nu nv nk b">master</code>分支上的每次推送时运行:</li></ol><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6380856bf903700510ac91fe4dbf4c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*402YIVS45Dyb3pgQbHs8Wg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We set the Action to run on every push to the master branch</figcaption></figure><p id="613e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.看一下配置AWS凭证操作。它使用你刚刚设置的秘密！确保机密的名称与代码中的名称相匹配。此外，如果需要，修改您的AWS区域</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/8b1b359ef83de1c366a4b8279b3b2f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_S3omIjjkxJuhKd7-q4v9A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Look, it uses the GitHub secrets we’ve set!</figcaption></figure><p id="5adc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.在<code class="fe nt nu nv nk b">build-image</code>步骤下，将您的ECR存储库的名称和<code class="fe nt nu nv nk b">latest</code>作为图像标签</p><blockquote class="od oe of"><p id="8a41" class="kc kd mq ke b kf kg kh ki kj kk kl km og ko kp kq oh ks kt ku oi kw kx ky kz ij bi translated">在本教程中，我们总是使用<strong class="ke ir">最新的</strong>作为图像的标签。我们不会根据版本或提交哈希来标记图像。</p></blockquote><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/178c8703c2ab4e27c0076d4eb83a5d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MsD0MG1B71hGANDx28AW3w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Put the correct ECR repository name and “latest” as image tag</figcaption></figure><p id="7bf4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.在<code class="fe nt nu nv nk b">task-def</code>步骤中，确保放置正确的路径到您的<code class="fe nt nu nv nk b">ecs-task-definition.json</code>(基于您的项目的根)和容器名，也在JSON中设置</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/c3f6b58ab4a775b50e2c7681c7182799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOaAb53NQeBMRWaWqMNvKw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Put the right path to the task definition JSON and container name</figcaption></figure><p id="7f63" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.在最后一步中，确保输入您创建的正确的ECS群集名称和ECS服务名称</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/e1f395cd430a028772b4795004f7ed15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3Ugm0T8hA-eiRCXxDNR6g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Put the right ECS service &amp; cluster names</figcaption></figure><p id="d48c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，点击<strong class="ke ir">开始提交</strong>，点击<strong class="ke ir">提交新文件</strong>:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/c197f6de0458620d9f433b27601cd618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-chkKPELqS2a3NpTfCv43Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We are committing our action! 🎉</figcaption></figure><p id="b41c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在应该发生的是GitHub开始执行这个动作，实际上在你的应用程序之外构建一个Docker映像，把它推送到ECR，基于任务定义把它部署到ECS上，你的应用程序应该很快就可以运行了！</p><h2 id="17f9" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">测试结果</h2><p id="59e2" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">导航到GitHub项目中的<strong class="ke ir">动作</strong>，点击新创建的工作流。您应该会看到与此类似的页面:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/1886a07d0edb19340c91261be495556e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJNqpJcrCw8pwIkZogynMA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">GitHub is working for us! For free!</figcaption></figure><p id="dcad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GitHub Actions正在执行工作流！如果尚未完成，您可以在这里看到所有步骤的小勾号或黄色圆圈。在ECS上部署可能需要一些时间，因为实例必须通过运行状况检查。</p><p id="c081" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">耐心点，检查结果！如果有问题，请查看错误消息。通常是相当明确的。本教程中有很多步骤，你很容易犯一两个错误。当我开始做的时候，我亲自重新做了好几次！不在话下👍。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/fb55a8d04a627a4407d9ba383e7e7759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKUsS7Mx0JpEQ9PyRU3TUA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">It should be all green in the end ✅</figcaption></figure><h1 id="0252" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">进行最后的烟雾测试</h1><p id="02a6" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">太好了！现在一切都应该就位并开始工作了🍾。</p><p id="eb43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以导航到我们的负载平衡器，并通过它的公共URL访问它。</p><ol class=""><li id="3e8f" class="mr ms iq ke b kf kg kj kk kn nz kr oa kv ob kz mw mx my mz bi translated">在AWS在线控制台中，导航到EC2，然后导航到负载平衡器部分</li><li id="b566" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">选择您创建的负载平衡器</li><li id="1128" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">复制DNS名称</li></ol><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/71f2d093d2be638e50da912953cd52de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68yNnDaykYuWc2vdtYo83Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Take the DNS name from the ALB (Application Load Balancer)</figcaption></figure><p id="d8f8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，在浏览器中访问这个URL。您应该看到您的应用程序在运行！💍</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/063ca4dbc946c576355bac138c00d12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCIuHfpYjxIZZba-CJ1MMQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The app is working!</figcaption></figure><p id="3b18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完美。这是一次累人的旅行，但非常值得！</p><h1 id="582c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们取得了什么成就</h1><p id="b66c" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们已经成功地建立了一个GitHub Actions工作流，每次推送GitHub项目的主分支时都会触发这个工作流。</p><p id="ea31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">反过来，在构建Docker映像之后，您的自动化工作流将使用您的ECS任务定义将其部署到您的ECS集群。该应用程序将通过负载平衡器可用，等待一些热情的客户端访问。有希望地😉。</p><h1 id="8b09" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">从这里去哪里</h1><p id="d683" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">这篇文章作为一个例子/概念证明。我们已经看到了GitHub Actions如何与AWS ECS集成。GitHub Actions要么是免费的，要么非常便宜，这非常方便，尤其是如果你已经在使用GitHub托管git的话。</p><p id="3823" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以使用这些知识为您的应用程序构建一个类似的工作流。如本文开头所述，任何类型的应用程序都可以使用这种方法。它只需要有一个用于构建它的docker文件和一个要公开的端口。如果是网络应用，当然可以🗺。</p><p id="2f8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谢谢你一路看完这篇文章，你太棒了！干杯！</p><h1 id="9d01" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">资源</h1><ol class=""><li id="67b3" class="mr ms iq ke b kf mk kj ml kn mt kr mu kv mv kz mw mx my mz bi translated">示例项目的GitHub回购—<a class="ae mp" href="https://github.com/adamkss/next-uk-post-codes" rel="noopener ugc nofollow" target="_blank">https://github.com/adamkss/next-uk-post-codes</a></li><li id="b03c" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">AWS ECS概述—【https://aws.amazon.com/ecs/ T2】</li><li id="45ff" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">GitHub行动概述—【https://github.com/features/actions T4】</li></ol><h1 id="6b55" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="3d32" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae mp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae mp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">订阅我们的YouTube频道</strong> </a> <strong class="ke ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>