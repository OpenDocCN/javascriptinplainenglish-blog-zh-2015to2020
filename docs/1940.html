<html>
<head>
<title>Plain JavaScript Versions of Lodash Methods to Slice and Join Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于对数组进行切片和连接的Lodash方法的纯JavaScript版本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/plain-javascript-versions-of-lodash-methods-to-slice-and-join-arrays-cb5bad7cc1a7?source=collection_archive---------13-----------------------#2020-05-05">https://javascript.plainenglish.io/plain-javascript-versions-of-lodash-methods-to-slice-and-join-arrays-cb5bad7cc1a7?source=collection_archive---------13-----------------------#2020-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/99dd54c76735d5a8e1df30ffd8106930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U9HyHfQ6SPi4FmTO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jtbean?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Josh Bean</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bd6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的实用程序库，它让我们可以很容易地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在追赶Lodash这样的库，我们可以用简单的方法实现许多功能。</p><p id="5b39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何用简单的JavaScript代码替换<code class="fe lb lc ld le b">takeWhile</code>、<code class="fe lb lc ld le b">union</code>、<code class="fe lb lc ld le b">unionBy</code>和<code class="fe lb lc ld le b">unionWith</code>。</p><h1 id="f452" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">takeWhile</code></h1><p id="0cb9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">takeWhile</code>与<code class="fe lb lc ld le b">takeRightWhile</code>相反。它返回一个数组的切片，其元素从开始处开始，直到带有给定数组条目的<code class="fe lb lc ld le b">predicate</code>函数返回<code class="fe lb lc ld le b">true</code>。</p><p id="b65b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很容易地通过<code class="fe lb lc ld le b">slice</code>自己实现，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2c00" class="mq lg iq le b gy mr ms l mt mu">const takeWhile = (arr, predicate) =&gt; {<br/>  let takenArr = [];<br/>  for (const a of arr) {<br/>    if (!predicate(a)) {<br/>      takenArr.push(a);<br/>    } else {<br/>      return takenArr;<br/>    }<br/>  }<br/>  return takenArr;<br/>}</span></pre><p id="5c1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用<code class="fe lb lc ld le b">for...of</code>循环遍历条目，如果<code class="fe lb lc ld le b">predicate(a)</code>返回<code class="fe lb lc ld le b">true</code>，则返回<code class="fe lb lc ld le b">takenArr</code>。</p><p id="c101" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果循环结束，我们也返回<code class="fe lb lc ld le b">takenArr</code>，如果<code class="fe lb lc ld le b">predicate(a)</code>从未返回<code class="fe lb lc ld le b">true</code>。</p><p id="f38c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们这样称呼它时:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0e7a" class="mq lg iq le b gy mr ms l mt mu">const result = takeWhile([30, 40, 50], a =&gt; a &gt; 40);</span></pre><p id="c0c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[30, 40]</code>，因为我们指定如果一个元素大于40，我们就停止。</p><h1 id="fa4b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">union</code></h1><p id="7d53" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">union</code>方法使用SameValueZero等式比较，从多个数组中按顺序返回具有唯一值的新数组。</p><p id="8e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过spread运算符自己实现，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="29f9" class="mq lg iq le b gy mr ms l mt mu">const union = (...arrs) =&gt; {<br/>  return arrs.reduce((arr1, arr2) =&gt; [...new Set([...arr1, ...arr2])])<br/>}</span></pre><p id="77a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们在<code class="fe lb lc ld le b">arrs</code>上调用了<code class="fe lb lc ld le b">reduce</code>，并使用了一个回调函数来返回用spread运算符扩展的两个数组的唯一值。然后，新数组被转换为一个集合，然后使用扩展运算符转换回一个数组。</p><p id="d84b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a0b0" class="mq lg iq le b gy mr ms l mt mu">const result = union([30, 40, 50], [30, 60]);</span></pre><p id="8056" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[30, 40, 50, 60]</code>，因为先前数组的值被保留，然后不在累积数组中的后面的值被添加。</p><h1 id="1ee0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">unionBy</code></h1><p id="c1c7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">unionBy</code>方法返回一个数组，每个数组中有唯一的项。这与<code class="fe lb lc ld le b">union</code>的区别在于<code class="fe lb lc ld le b">unionBy</code>允许我们在进行唯一性比较之前传递一个映射值的方法。</p><p id="8c5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过以下方式实施:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a3be" class="mq lg iq le b gy mr ms l mt mu">const unionBy = (iteratee, ...arrs) =&gt; {<br/>  let unionArr = [];  <br/>  for (const arr of arrs) {<br/>    const mapped = arr.map(iteratee);<br/>    const unionMapped = unionArr.map(iteratee);<br/>    const uniques = mapped.filter(a =&gt; !unionMapped.includes(a));<br/>    unionArr = [...unionArr, ...uniques];<br/>  }<br/>  return unionArr;<br/>}</span></pre><p id="5151" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe lb lc ld le b">iteratee</code>作为第一个参数，而不是最后一个，这样我们就可以使用rest操作符和<code class="fe lb lc ld le b">arrs</code>来返回在<code class="fe lb lc ld le b">iteratee</code>函数之后传入的数组参数的数组。</p><p id="760e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有一个<code class="fe lb lc ld le b">for...of</code>循环来遍历条目，在循环内部，我们用<code class="fe lb lc ld le b">iteratee</code>函数映射<code class="fe lb lc ld le b">arr</code>条目。</p><p id="bd4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们用相同的函数映射了<code class="fe lb lc ld le b">unionArr</code>数组，这样我们就可以使用<code class="fe lb lc ld le b">includes</code>方法和<code class="fe lb lc ld le b">filter</code>来获得在用<code class="fe lb lc ld le b">iteratee</code>转换值后进行比较后还不是<code class="fe lb lc ld le b">unionArr</code>的条目。</p><p id="a8e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3f68" class="mq lg iq le b gy mr ms l mt mu">const result = unionBy(Math.floor, [30.1, 40, 50], [30.2, 60]);</span></pre><p id="2f0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">result</code>的<code class="fe lb lc ld le b">[30, 40, 50, 60]</code>，因为在进行比较之前，我们用<code class="fe lb lc ld le b">Math.floor</code>映射了所有数组中的值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/a412c9a67e32648fa8c614c56890ab35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-OwIR1YAGSEofuOm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clay Banks</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fa3e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">unionWith</code></h1><p id="db2d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">unionWith</code>类似于<code class="fe lb lc ld le b">union</code>,除了它接受一个比较器来比较元素并选择第一个唯一的元素。</p><p id="8bcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现自己的<code class="fe lb lc ld le b">unionWith</code>功能:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8f68" class="mq lg iq le b gy mr ms l mt mu">const unionWith = (comparator, ...arrs) =&gt; {<br/>  let unionArr = [];<br/>  for (const arr of arrs) {<br/>    const uniques = arr.filter(a =&gt; !unionArr.find(u =&gt; comparator(a, u)));<br/>    unionArr = [...unionArr, ...uniques];<br/>  }<br/>  return unionArr;<br/>}</span></pre><p id="617c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用一个<code class="fe lb lc ld le b">for...of</code>循环遍历了<code class="fe lb lc ld le b">arrs</code>。在循环内部，我们调用了<code class="fe lb lc ld le b">arr</code>上的<code class="fe lb lc ld le b">filter</code>来返回一个包含不在<code class="fe lb lc ld le b">unionArr</code>数组中的值的数组，并将该数组赋给<code class="fe lb lc ld le b">uniques</code>常量。</p><p id="484e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们扩展现有的<code class="fe lb lc ld le b">unionArr</code>数组和<code class="fe lb lc ld le b">uniques</code>数组的值，然后将新数组分配给<code class="fe lb lc ld le b">unionArr</code>。</p><p id="c182" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们返回<code class="fe lb lc ld le b">unionArr</code>。那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ec80" class="mq lg iq le b gy mr ms l mt mu">const result = unionWith((a, b) =&gt; Object.is(a, b), [30, 40, 50], [30, 60]);</span></pre><p id="9222" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[30, 40, 50, 60]</code>，因为我们将这些值与<code class="fe lb lc ld le b">Object.is</code>进行了比较，以确定它们是否唯一。</p><h1 id="d8aa" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="012a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">union</code>、<code class="fe lb lc ld le b">unionBy</code>和<code class="fe lb lc ld le b">unionWith</code>方法可以通过spread运算符和使用array的<code class="fe lb lc ld le b">filter</code>方法来实现。</p><p id="5205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">takeWhile</code>可以通过<code class="fe lb lc ld le b">for...of</code>循环实现，并在每次迭代中检查给定的谓词。</p><h2 id="8694" class="mq lg iq bd lh mw mx dn ll my mz dp lp ko na nb lt ks nc nd lx kw ne nf mb ng bi translated">简明英语笔记</h2><p id="f12a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="1eac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>