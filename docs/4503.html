<html>
<head>
<title>Cracking The JavaScript Coding Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解JavaScript编码面试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cracking-coding-interview-javascript-strings-8c26fb043cd8?source=collection_archive---------8-----------------------#2020-12-16">https://javascript.plainenglish.io/cracking-coding-interview-javascript-strings-8c26fb043cd8?source=collection_archive---------8-----------------------#2020-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9b1c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:字符串</h2></div><p id="21f8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是帮助您准备应对编码挑战的系列文章的第一部分。在本文中，我将重点讨论与JavaScript字符串相关的问题。</p><p id="5944" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">先决条件:</strong>在继续之前，我假设您应该对JavaScript有基本的了解。至少你应该知道它是如何工作的。</p><p id="1883" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注:</strong> <em class="ky">这不是一本</em> <a class="ae kz" href="https://en.wikipedia.org/wiki/Gayle_Laakmann_McDowell" rel="noopener ugc nofollow" target="_blank"> <em class="ky">格利_拉克曼</em> </a> <em class="ky">的书。这本书太棒了。我一有时间就喜欢读它。然而，一些样本/问题取自该书。虽然这本书用Java解决了问题，但我已经用JavaScript (TypeScript)解决了同样的问题。</em></p><p id="2090" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">字符串</strong>:字符串是唯一的，几乎用于所有数据集。JavaScript字符串很简单，不太复杂。然而，这也是JavaScript的问题。如果你不注意，它会导致记忆问题。在这里，我挑选了一些容易和常见的字符串问题。</p><h2 id="6cfb" class="la lb in bd lc ld le dn lf lg lh dp li kl lj lk ll kp lm ln lo kt lp lq lr ls bi translated"><strong class="ak"> 1。是唯一的</strong></h2><p id="633d" class="pw-post-body-paragraph kc kd in ke b kf lt jo kh ki lu jr kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated"><em class="ky">对于给定的字符串，查找该字符串中所有的字符都是唯一的。</em></p><p id="ce37" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有很多方法可以解决这个问题。最简单的使用字符的<strong class="ke io">映射</strong>。遍历字符串中的所有字符，并在map中设置它。如果地图已经有了那个字符，函数返回false。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="af1a" class="la lb in md b gy mh mi l mj mk">export const isUniqueChars = (txt = "") =&gt; {<br/>  const chars = new Map&lt;string, true&gt;();<br/>  for (let i = 0; i &lt; txt.length; i++) {<br/>    if (chars.has(txt.charAt(i))) return false;<br/>    chars.set(txt.charAt(i), true);<br/>  }<br/>  return true;<br/>};</span><span id="dc01" class="la lb in md b gy ml mi l mj mk">console.log(isUniqueChars("background")); // true<br/>console.log(isUniqueChars("bawdyhouse")); // true<br/>console.log(isUniqueChars("rhythm")); //false</span></pre><p id="35f6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您也可以使用ES6/ES2015操作器来解决这个问题。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="e8e3" class="la lb in md b gy mh mi l mj mk">export const isUniqueChars2 = (txt = "") =&gt; {<br/>  const chars = new Map&lt;string, true&gt;();<br/>  // [...txt] is equivalent of Array.from(txt)<br/>  return ![...txt].some((char) =&gt; {<br/>    if (chars.has(char)) return true;<br/>    chars.set(char, true);<br/>  });<br/>};<br/>console.log(isUniqueChars2("background")); // true<br/>console.log(isUniqueChars2("bawdyhouse")); // true<br/>console.log(isUniqueChars2("rhythm")); //false</span></pre><h2 id="400f" class="la lb in bd lc ld le dn lf lg lh dp li kl lj lk ll kp lm ln lo kt lp lq lr ls bi translated"><strong class="ak"> 2。检查排列</strong></h2><p id="91a8" class="pw-post-body-paragraph kc kd in ke b kf lt jo kh ki lu jr kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated"><em class="ky">给定两个字符串，找出一个字符串是否被置换成另一个字符串。即</em><strong class="ke io"><em class="ky">ABC</em></strong><em class="ky">和</em><strong class="ke io"><em class="ky">ACB</em></strong><em class="ky">相互置换。</em></p><p id="67c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最简单的解决方案，您可以对字符串进行排序并匹配两个字符串。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a991" class="la lb in md b gy mh mi l mj mk">const sort = (str: string) =&gt; [...str].sort().join();</span><span id="0369" class="la lb in md b gy ml mi l mj mk">export const isPermuted = (str1: string, str2: string) =&gt; {<br/>  if (str1.length !== str2.length) return false;<br/>  return sort(str1) === sort(str2);<br/>};</span><span id="ef64" class="la lb in md b gy ml mi l mj mk">console.log(isPermuted("abc", "acb")); // true</span></pre><p id="4408" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的解决方案很简单，但不是很有效。排序算法的复杂度为<strong class="ke io"> <em class="ky"> n log(n)。我们可以通过计算字符数来解决这个问题。保留一个字符串中所有字符的计数，并与另一个字符串中字符的计数相匹配。如果不匹配，给定的字符串就不是其他字符串的排列。</em></strong></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="edf5" class="la lb in md b gy mh mi l mj mk">export const isPermuted2 = (str1: string, str2: string) =&gt; {<br/>  if (str1.length !== str2.length) return false;<br/>  // map to keep count<br/>  const chars: { [key: string]: number } = {};</span><span id="497a" class="la lb in md b gy ml mi l mj mk">  for (let i = 0; i &lt; str1.length; i++) {<br/>    if (!chars[str1.charAt(i)]) chars[str1.charAt(i)] = 0;<br/>    chars[str1.charAt(i)]++;<br/>  }</span><span id="803d" class="la lb in md b gy ml mi l mj mk">  for (let i = 0; i &lt; str2.length; i++) {<br/>    if (!chars[str2.charAt(i)]) chars[str2.charAt(i)] = 0;<br/>    chars[str2.charAt(i)]--;<br/>    if (chars[str2.charAt(i)] &lt; 0) return false;<br/>  }<br/>  return true;<br/>};</span><span id="c7fa" class="la lb in md b gy ml mi l mj mk">console.log(isPermuted2("abc", "acb")); // true<br/>console.log(isPermuted2("abc", "acd")); // false<br/></span></pre><figure class="ly lz ma mb gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/2a9097f8a00dda58037820bc839b8f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00qDqrQtKTgSfzp2vTL0Yw.png"/></div></div></figure><h2 id="47fb" class="la lb in bd lc ld le dn lf lg lh dp li kl lj lk ll kp lm ln lo kt lp lq lr ls bi translated"><strong class="ak"> 3。URLify/encodeURI </strong></h2><p id="d947" class="pw-post-body-paragraph kc kd in ke b kf lt jo kh ki lu jr kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated"><em class="ky">给定字符串用其编码值替换所有特殊字符。</em></p><p id="33ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，你可以使用<strong class="ke io">编码组件</strong>来编码特殊字符。然而，这个例子对于构建util来编码任何类型的字符串都非常有用。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="75b0" class="la lb in md b gy mh mi l mj mk">// map to keep track of all special chars</span><span id="7e20" class="la lb in md b gy ml mi l mj mk">const specialChars: { [k: string]: string } = {<br/>  "@": "%40",<br/>  " ": " %20",<br/>  "#": "%23",<br/>  "%": "%25",<br/>  "^": "%5E",<br/>  "&amp;": "%26",<br/>  ":": "%3A",<br/>  "&lt;": "%3C",<br/>  "&gt;": "%3E",<br/>};</span><span id="ab71" class="la lb in md b gy ml mi l mj mk">export const encodeString = (txt = ""): string =&gt; {<br/>  // /\W/g is reg to find not Alphabetic chars<br/>  <br/>  return txt.replace(/\W/g, (m) =&gt; specialChars[m] || "");<br/>};</span><span id="ed2a" class="la lb in md b gy ml mi l mj mk">console.log(encodeString("&lt;name:deepak&gt;")); // %3Cname%3Adeepak%3E</span></pre><p id="8091" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以使用同样的技术来构建一个表情符号文本生成器。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="bad3" class="la lb in md b gy mh mi l mj mk">const emojiChars: { [k: string]: string } = {<br/>  love: "💚",<br/>  india: "🇮🇳",<br/>  i: "ℹ️",<br/>};<br/>const WORD_REG = /(\w+)/g;<br/>export const encodeString2 = (txt = ""): string =&gt; {<br/>  return txt.replace(WORD_REG, (_, m) =&gt; emojiChars[m.toLowerCase()] || "");<br/>};</span><span id="1c07" class="la lb in md b gy ml mi l mj mk">console.log(encodeString2("I love India")); // ℹ️ 💚 🇮🇳</span></pre><p id="2774" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的解决方案中，我使用正则表达式来标记单词，并用它们的表情符号替换它们。</p><figure class="ly lz ma mb gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mu"><img src="../Images/a7e8afc00b7df26d509a068af89259f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpRr9IUJCHTQZt1c-LkGOw.png"/></div></div></figure><h2 id="e5a2" class="la lb in bd lc ld le dn lf lg lh dp li kl lj lk ll kp lm ln lo kt lp lq lr ls bi translated"><strong class="ak"> 4。字符串压缩</strong></h2><p id="ee64" class="pw-post-body-paragraph kc kd in ke b kf lt jo kh ki lu jr kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated">写一个程序来压缩一个字符串，用它的计数代替重复的字符。即。<strong class="ke io"><em class="ky">aaabbbbb</em></strong><em class="ky">=&gt;</em><strong class="ke io"><em class="ky">a3 B4</em></strong>。</p><p id="ad74" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题的解决方案既复杂又简单。我们可以使用match and repeat regex来对<strong class="ke io">字符串进行标记化，并用HOC函数替换<strong class="ke io">字符串的</strong>方法。</strong></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="876c" class="la lb in md b gy mh mi l mj mk">export const compress = (txt = "") =&gt; {<br/>  return txt.replace(<strong class="md io">/(\w)(\1+)/g</strong>, (_, m1, m2) =&gt; `${m1}${m2.length + 1}`);<br/>};</span><span id="43bf" class="la lb in md b gy ml mi l mj mk">console.log(compress("aaabbbb")); // a3b4</span></pre><p id="79f7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个解决方案是，遍历字符并计算连续的字符。<strong class="ke io"> <em class="ky"> /(\w)(\1+)/g </em> </strong>是查找所有字符并匹配重复<strong class="ke io"> (\1) </strong>的正则表达式。<em class="ky"> `\1` </em>表示重复先前匹配的字符</p><h2 id="37b3" class="la lb in bd lc ld le dn lf lg lh dp li kl lj lk ll kp lm ln lo kt lp lq lr ls bi translated"><strong class="ak"> 5。缩写</strong></h2><p id="97dd" class="pw-post-body-paragraph kc kd in ke b kf lt jo kh ki lu jr kk kl lv kn ko kp lw kr ks kt lx kv kw kx ig bi translated"><em class="ky">创建一个缩写函数，取一个字符串并返回一个字符串，同时取</em> <strong class="ke io"> <em class="ky">第一个</em> </strong> <em class="ky">和</em> <strong class="ke io"> <em class="ky">最后一个</em> </strong> <em class="ky"> char并用char的个数替换剩余的char。比如</em> <strong class="ke io"> <em class="ky">国际化</em> </strong> <em class="ky">就会变成</em><strong class="ke io"><em class="ky">i18n</em></strong><em class="ky">。</em></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d334" class="la lb in md b gy mh mi l mj mk">const abbrev = (text: string = "") =&gt; {<br/>  if (text.length &lt; 3) return text;<br/>  const first = text.charAt(0);<br/>  const last = text.slice(-1);<br/>  const remLen = text.length - 2;<br/>  return `${first}${remLen}${last}`;<br/>};</span><span id="dc4f" class="la lb in md b gy ml mi l mj mk">console.log(abbrev("internationalization")); // i18n</span></pre><p id="e998" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的解决方案中，我使用方法<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt" rel="noopener ugc nofollow" target="_blank"> String.charAt </a>和<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice" rel="noopener ugc nofollow" target="_blank"> String.slice </a>分别获取第一个和最后一个char。我们可以用charAt代替<em class="ky">切片</em>。但在这种情况下，我们需要找到最后一个指数，并做一些计算。我还使用ES2015 <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板字符串</a>来追加字符串。</p><p id="f4cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在添加更多边缘案例的同时，让这个变得复杂一点。让我们来转换这个函数，它可以接受由特殊字符分隔的一组单词。即<em class="ky">我爱javascript！</em>会变成<em class="ky"> I l2e j8t！</em></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c000" class="la lb in md b gy mh mi l mj mk">const word = /\w+/g;<br/>const abbrevPlus = (text: string = "") =&gt; {<br/>  return text.replace(word, (matched: string) =&gt; abbrev(matched));<br/>};</span><span id="c861" class="la lb in md b gy ml mi l mj mk">console.log(abbrevPlus("I love javascript!")); // I l2e j8t!</span></pre><p id="bcc5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的解决方案中，我们使用了<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace" rel="noopener ugc nofollow" target="_blank"> String.replace </a>方法，该方法接受一个RegExp和一个<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">回调函数/高阶函数</a>来查找所有有效单词并替换为其缩写。很好！看起来比分裂和连接更简单。</p><p id="35b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你会喜欢这篇文章，如果你有一些常见的问题需要解决，请告诉我。</p></div></div>    
</body>
</html>