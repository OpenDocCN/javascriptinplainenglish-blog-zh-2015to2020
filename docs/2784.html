<html>
<head>
<title>Understanding animated graphs in D3.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解D3.js中的动画图形</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-animated-graphs-in-d3-js-67488accb467?source=collection_archive---------12-----------------------#2020-07-23">https://javascript.plainenglish.io/understanding-animated-graphs-in-d3-js-67488accb467?source=collection_archive---------12-----------------------#2020-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3.js </a>是一个伟大的，在我看来非常优雅的库，用于在web浏览器中构建可视化。不幸的是，有些概念不太容易从文档中理解，尤其是在制作动画图表时。当我试图使用<a class="ae kl" href="https://github.com/d3/d3/wiki" rel="noopener ugc nofollow" target="_blank">官方资源</a>向我的学生教授这些概念时，我自己也有过这样的经历。</p><p id="759d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我确信<a class="ae kl" href="https://observablehq.com/@d3/learn-d3" rel="noopener ugc nofollow" target="_blank"> ObservableHQ </a>是修补和学习某些特性的好方法，但是它的灵感来源于自动更新的电子表格，这使得它很难理解这些特性在现实世界的应用程序中是如何组合的。</p><p id="7eeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我将尝试用一个非常简单的例子来解释我(也可能是其他人)在学习D3.js时遇到的困难。这不会涵盖D3.js的很多不同特性，但会解释我觉得最难理解的部分。本指南在D3.js主页上的<a class="ae kl" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank">介绍中增加了一些内容，这会让我更容易学习D3.js。</a></p><p id="36e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">下面的例子假设</em> <code class="fe kn ko kp kq b"><em class="km">d3</em></code> <em class="km">变量和一个</em> <code class="fe kn ko kp kq b"><em class="km">&lt;svg&gt;</em></code> <em class="km">标签在作用域内。这可以通过使用D3.js文档</em>  <em class="km">中描述的脚本标签</em> <a class="ae kl" href="https://github.com/d3/d3/wiki#installing" rel="noopener ugc nofollow" target="_blank"> <em class="km">来完成。</em></a></p><pre class="kr ks kt ku gt kv kq kw kx aw ky bi"><span id="4bf4" class="kz la iq kq b gy lb lc l ld le">&lt;svg /&gt;<br/>&lt;script src="https://d3js.org/d3.v5.js"&gt;&lt;/script&gt;</span></pre><h1 id="601d" class="lf la iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构建一个简单的图表</h1><p id="7759" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">基本上D3.js允许你基于数据生成不同的标记(比如HTML或者SVG)。让我们来看一个例子，它将数组中的数字可视化为不同大小的圆圈。</p><pre class="kr ks kt ku gt kv kq kw kx aw ky bi"><span id="981d" class="kz la iq kq b gy lb lc l ld le"><strong class="kq ir">const</strong> data <strong class="kq ir">=</strong> [10, 30, 20];</span><span id="d5f9" class="kz la iq kq b gy mh lc l ld le">d3.select('svg').selectAll('circle')<br/>    .data(data)<br/>        .join(<br/>            (enter) <strong class="kq ir">=&gt;</strong> enter<br/>                .append('circle')<br/>                    .style('fill', 'red')<br/>                    .attr('r', (d) <strong class="kq ir">=&gt;</strong> d)<br/>                    .attr('cx', (d, i) <strong class="kq ir">=&gt;</strong> (i <strong class="kq ir">+</strong> 1) <strong class="kq ir">*</strong> 50)<br/>                    .attr('cy', 50)<br/>        )</span></pre><p id="c9c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kn ko kp kq b">data</code>变量保存我们想要可视化的数据。为此，我们需要<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#select" rel="noopener ugc nofollow" target="_blank">d3.select</a></code> <a class="ae kl" href="https://github.com/d3/d3-selection#select" rel="noopener ugc nofollow" target="_blank">函数</a>，它返回一个<a class="ae kl" href="https://github.com/d3/d3-selection" rel="noopener ugc nofollow" target="_blank"> D3.js选择</a>。这样的选择充当DOM的包装器，它侧重于使用数据的大规模操作。<code class="fe kn ko kp kq b">d3.select</code>函数返回一个选择，其中第一个元素匹配其传递的CSS选择器，因此是我们的HTML文档中唯一的<code class="fe kn ko kp kq b">&lt;svg&gt;</code>标签。D3.js利用了一个<a class="ae kl" href="https://www.martinfowler.com/bliki/FluentInterface.html" rel="noopener ugc nofollow" target="_blank"> fluent接口</a>，使我们能够使用刚刚返回的选择，并进行另一个<a class="ae kl" href="https://github.com/d3/d3-selection#selectAll" rel="noopener ugc nofollow" target="_blank">函数调用</a> <code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#selectAll" rel="noopener ugc nofollow" target="_blank">selectAll</a></code>。这将返回所有的<code class="fe kn ko kp kq b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle" rel="noopener ugc nofollow" target="_blank">cirlce</a></code> <a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle" rel="noopener ugc nofollow" target="_blank">元素</a>，它们是我们文档中第一个<code class="fe kn ko kp kq b">&lt;svg&gt;</code>标签的后代。这感觉有点奇怪，因为这会导致一个空的选择，但是我们马上就会看到这一点。</p><p id="101b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以使用<code class="fe kn ko kp kq b">d3.select('svg').selectAll('circle')</code>调用，我们有一个空的选择，因为在<code class="fe kn ko kp kq b">&lt;svg&gt;</code>标签中还没有圆。现在我们可以使用<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#selection_data" rel="noopener ugc nofollow" target="_blank">data</a></code> <a class="ae kl" href="https://github.com/d3/d3-selection#selection_data" rel="noopener ugc nofollow" target="_blank">函数</a>给我们的<code class="fe kn ko kp kq b">data</code>变量赋值。这将给我们一个数据选择，知道哪些元素我们必须添加到我们的可视化。这就是开始变得有趣的地方。</p><p id="bb72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样的数据选择提供了一个<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#selection_join" rel="noopener ugc nofollow" target="_blank">join</a></code> <a class="ae kl" href="https://github.com/d3/d3-selection#selection_join" rel="noopener ugc nofollow" target="_blank">方法</a>，最多可以接受三个参数。在上面的例子中，只使用了一个参数，是一个接受<code class="fe kn ko kp kq b">enter</code>选择的函数。这个选择保存了我们的数据集(<code class="fe kn ko kp kq b">10</code>、<code class="fe kn ko kp kq b">30</code>和<code class="fe kn ko kp kq b">20</code>)中当前没有绑定到SVG <code class="fe kn ko kp kq b">circle</code>元素的所有值。因为还没有元素存在，所以我们的工作就是创建它们。这就是<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#selection_append" rel="noopener ugc nofollow" target="_blank">append</a></code> <a class="ae kl" href="https://github.com/d3/d3-selection#selection_append" rel="noopener ugc nofollow" target="_blank">方法</a>的作用。我们用<code class="fe kn ko kp kq b">'circle'</code>参数调用它，这意味着一旦调用结束，将有三个<code class="fe kn ko kp kq b">circle</code>元素，每个元素对应一个丢失的数据点。</p><p id="b24b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在这些圆上使用<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#style" rel="noopener ugc nofollow" target="_blank">style</a></code>和<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#selection_attr" rel="noopener ugc nofollow" target="_blank">attr</a></code>调用，以便以某种方式设计它们。查看MDN 上的<code class="fe kn ko kp kq b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle" rel="noopener ugc nofollow" target="_blank">circle</a></code> <a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle" rel="noopener ugc nofollow" target="_blank">文档，以了解可用的属性。这些函数不仅接受简单的值；它们也接受函数作为参数。<strong class="jp ir">如果一个函数通过了，这个函数将被当前数据点的值(</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">d</strong></code> <strong class="jp ir">变量)和索引(</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">i</strong></code> <strong class="jp ir">变量)调用。</strong>这样我们可以将半径<code class="fe kn ko kp kq b">r</code>设置为传递的值，并使用索引向右移动圆来计算<code class="fe kn ko kp kq b">cx</code>属性。</a></p><p id="26e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这几行代码，我们已经创建了三个半径分别为10、30和20像素的红色圆圈。</p><h1 id="60c2" class="lf la iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更新当前选择</h1><p id="fcdf" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">到目前为止，我们只有三个值作为圆的静态表示。到目前为止这并不有趣。我们可以自己简单地编写几行SVG来实现相同的结果。D3.js的流行来自于它更高级的特性。让我们看看当一个新的数据集到达时，我们如何改变数据。开始时，我想知道这是如何工作的，因为从文档中看不出来。<strong class="jp ir">基本上，诀窍是用不同的数据集再次调用完全相同的代码。然后，D3.js将找出哪些元素已经存在，哪些必须被添加，以及是否有任何元素必须被删除。我们唯一要做的事情(除了再次调用该代码之外)是告诉D3.js它应该如何处理这些不同的元素集。</strong></p><p id="7676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过向<code class="fe kn ko kp kq b">join</code>方法传递更多的函数参数来做到这一点。第三个参数处理即将被移除的元素，第二个基于<code class="fe kn ko kp kq b">selectAll</code>调用处理之前已经存在的元素，这解释了为什么它从一开始就在上面的代码中。我们将把上面的整个D3.js代码放到一个单独的函数中，当新数据到达时将再次调用这个函数。所以<code class="fe kn ko kp kq b">selectAll</code>只会在第一次调用时返回一个空集，但是它的连续调用会返回旧的<code class="fe kn ko kp kq b">circle</code>元素。</p><p id="60d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码展示了这个概念，并假设您的HTML中有一个<code class="fe kn ko kp kq b">&lt;button&gt;</code>标签，当它被点击时将加载下一个数据集(为简洁起见，没有越界检查):</p><pre class="kr ks kt ku gt kv kq kw kx aw ky bi"><span id="53c7" class="kz la iq kq b gy lb lc l ld le"><strong class="kq ir">const</strong> data <strong class="kq ir">=</strong> [<br/>    [10, 30, 20, 40],<br/>    [20, 20, 20],<br/>    [40, 10, 20, 10, 20],<br/>    [20, 10, 20],<br/>];</span><span id="181c" class="kz la iq kq b gy mh lc l ld le"><strong class="kq ir">let</strong> currentIndex <strong class="kq ir">=</strong> 0;</span><span id="23b8" class="kz la iq kq b gy mh lc l ld le">document.getElementsByTagName('button')[0].addEventListener(<br/>    'click',<br/>    () <strong class="kq ir">=&gt;</strong> update(<strong class="kq ir">++</strong>currentIndex)<br/>);</span><span id="699f" class="kz la iq kq b gy mh lc l ld le"><strong class="kq ir">function</strong> update(index) {<br/>    d3.select('svg').selectAll('circle')<br/>        .data(data[index])<br/>            .join(<br/>                (enter) <strong class="kq ir">=&gt;</strong> enter.append('circle'),<br/>                (update) <strong class="kq ir">=&gt;</strong> update,<br/>                (exit) <strong class="kq ir">=&gt;</strong> exit.remove(),<br/>            )<br/>                .style('fill', 'red')<br/>                .attr('r', (d) <strong class="kq ir">=&gt;</strong> d)<br/>                .attr('cx', (d, i) <strong class="kq ir">=&gt;</strong> (i <strong class="kq ir">+</strong> 1) <strong class="kq ir">*</strong> 50)<br/>                .attr('cy', 50);<br/>}</span><span id="7c95" class="kz la iq kq b gy mh lc l ld le">update(0);</span></pre><p id="c7ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kn ko kp kq b">data</code>变量现在包含一个数组的数组，因此内部数组被解释为一个数据集。我们有一个以<code class="fe kn ko kp kq b">0</code>开头的索引变量，每次点击文档的第一个按钮都会调用<code class="fe kn ko kp kq b">update</code>函数，增加索引的值。<code class="fe kn ko kp kq b">update</code>函数包含D3.js特定代码，但也使用<code class="fe kn ko kp kq b">index</code>参数访问当前数据集。如前所述，<code class="fe kn ko kp kq b">join</code>方法与3个回调一起使用:</p><ol class=""><li id="c938" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><code class="fe kn ko kp kq b"><strong class="jp ir">enter</strong></code> <strong class="jp ir">回调</strong>用于当前未在可视化中表示的数据点。在这里，<code class="fe kn ko kp kq b">append</code>方法用于为每个新数据点添加一个<code class="fe kn ko kp kq b">circle</code> SVG元素。</li><li id="7203" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">对于已经在可视化中表示的数据点，调用<code class="fe kn ko kp kq b"><strong class="jp ir">update</strong></code> <strong class="jp ir">回调</strong>。目前我们没有对这些元素做任何特殊的处理，所以我们只是返回那个集合。</li><li id="b0b7" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">对于在新数据集中不再有数据点的可视化中的元素，调用<code class="fe kn ko kp kq b"><strong class="jp ir">exit</strong></code> <strong class="jp ir">回调</strong>。这个例子使用<code class="fe kn ko kp kq b">remove</code>方法立即删除这些元素。</li></ol><p id="dd3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">如果你熟悉</em><a class="ae kl" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"><em class="km">React</em></a><em class="km">，你可以想到D3.js做着类似的工作:你只需要告诉它在每种情况下应该发生什么，D3.js就会为你计算出何时调用哪个函数。</em></p><p id="cb53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为除了为<code class="fe kn ko kp kq b">enter</code>集合添加新的圆之外，我们经常想要以同样的方式处理<code class="fe kn ko kp kq b">enter</code>和<code class="fe kn ko kp kq b">update</code>集合，<code class="fe kn ko kp kq b">join</code>方法将合并这两个集合并返回两者的组合。所以<code class="fe kn ko kp kq b">join</code>方法的返回值可以用来设置这两个集合的样式和其他属性(我们也可以直接在<code class="fe kn ko kp kq b">enter</code>和<code class="fe kn ko kp kq b">update</code>回调中添加后续的方法调用，这通常是在这些集合之间的处理不同时完成的)。这部分代码是从第一个例子中复制过来的。</p><h1 id="52b1" class="lf la iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为更平滑的动画添加过渡</h1><p id="3ad0" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">前面的例子改变了每一次按钮点击的可视化，但是它仍然不像一个复杂的可视化。D3.js还支持过渡，这将使动画更加流畅。实现这一点的最重要的方法叫做<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-transition#selection_transition" rel="noopener ugc nofollow" target="_blank">transition</a></code>，它返回一个类似于D3.js选择的对象。<strong class="jp ir">调用</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">transition</strong></code> <strong class="jp ir">后，您可以使用前面描述的</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">attr</strong></code> <strong class="jp ir">和</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">style</strong></code> <strong class="jp ir">方法，但这些更改将会被激活，而不是立即应用。</strong>为了控制动画的速度，这个类似选择的对象还包含了<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-transition#transition_duration" rel="noopener ugc nofollow" target="_blank">duration</a></code> <a class="ae kl" href="https://github.com/d3/d3-transition#transition_duration" rel="noopener ugc nofollow" target="_blank">方法</a>。为了延迟动画，可以使用<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-transition#transition_delay" rel="noopener ugc nofollow" target="_blank">delay</a></code> <a class="ae kl" href="https://github.com/d3/d3-transition#transition_delay" rel="noopener ugc nofollow" target="_blank">方法</a>。这两个函数都接受一个被解释为毫秒的参数。</p><p id="63f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个非常重要的旁注:<strong class="jp ir">一个过渡对象，尽管相似，但不是D3.js选择。</strong>如果传递的是过渡而不是选择，D3.js可能会抛出错误。因此<code class="fe kn ko kp kq b"><a class="ae kl" href="https://github.com/d3/d3-selection#selection_call" rel="noopener ugc nofollow" target="_blank">call</a></code> <a class="ae kl" href="https://github.com/d3/d3-selection#selection_call" rel="noopener ugc nofollow" target="_blank">方法</a>存在。<code class="fe kn ko kp kq b">call</code>方法将执行传递的函数，但不是返回传递的函数返回的值，而是总是返回执行<code class="fe kn ko kp kq b">call</code>方法的选择。通过这种方式，方法链可以被分成几个部分，而不会创建使代码膨胀的独立变量。参见下面的例子，它只是显示了上面的<code class="fe kn ko kp kq b">update</code>函数的新主体:</p><pre class="kr ks kt ku gt kv kq kw kx aw ky bi"><span id="ba2a" class="kz la iq kq b gy lb lc l ld le">d3.select('svg').selectAll('circle')<br/>    .data(data[index])<br/>        .join(<br/>            (enter) <strong class="kq ir">=&gt;</strong> enter.append('circle')<br/>                .attr('r', 0)<br/>                .attr('cy', 50),<br/>            (update) <strong class="kq ir">=&gt;</strong> update,<br/>            (exit) <strong class="kq ir">=&gt;</strong> exit.call((exit) <strong class="kq ir">=&gt;</strong> exit<br/>                .transition()<br/>                    .duration(500)<br/>                        .attr('r', 0)<br/>                        .remove()<br/>            )<br/>        )<br/>            .transition()<br/>                .duration(500)<br/>                    .attr('r', (d) <strong class="kq ir">=&gt;</strong> d)<br/>                    .attr('cx', (d, i) <strong class="kq ir">=&gt;</strong> (i <strong class="kq ir">+</strong> 1) <strong class="kq ir">*</strong> 50)</span></pre><p id="68b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这几乎与上面的代码相同，但是为了使数据集之间的转换具有动画效果，做了三个关键的更改:</p><ol class=""><li id="bd6a" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><strong class="jp ir">后称</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">transition</strong></code> <strong class="jp ir">法为</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">join</strong></code> <strong class="jp ir">法。</strong>这样我们告诉<code class="fe kn ko kp kq b">join</code>方法的<code class="fe kn ko kp kq b">enter</code>和<code class="fe kn ko kp kq b">update</code>集合的合并，后续的<code class="fe kn ko kp kq b">attr</code>调用应该被动画化，持续时间为500毫秒</li><li id="3829" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir"/><code class="fe kn ko kp kq b"><strong class="jp ir">join</strong></code><strong class="jp ir">方法的</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">enter</strong></code> <strong class="jp ir">集合立即得到一个</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">r</strong></code> <strong class="jp ir">和</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">cy</strong></code> <strong class="jp ir">值。</strong>这些值是动画前的起始值。立即设置<code class="fe kn ko kp kq b">cy</code>并保持不动将导致圆圈仅在x轴上移动。</li><li id="350d" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir"/><code class="fe kn ko kp kq b"><strong class="jp ir">join</strong></code><strong class="jp ir">方法的</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">exit</strong></code> <strong class="jp ir">集合也使用</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">transition</strong></code> <strong class="jp ir">和</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">duration</strong></code> <strong class="jp ir">调用。</strong>在<code class="fe kn ko kp kq b">transition</code>方法后再次调用<code class="fe kn ko kp kq b">attr</code>方法，这将使cirlce缩小直到不再可见。过渡的<code class="fe kn ko kp kq b">remove</code>将在动画结束后移除元素(与标准选择的<code class="fe kn ko kp kq b">remove</code>方法相反，后者会立即移除元素)。虽然对于<code class="fe kn ko kp kq b">exit</code>设置来说不是必需的(因为它不会被进一步操作)，但是为了返回正确的选择而不是从第三次回调的转换，已经使用了<code class="fe kn ko kp kq b">call</code>方法。</li></ol><h1 id="ef1f" class="lf la iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用键识别数据点</h1><p id="b8bf" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这已经形成了一个相当光滑的可视化！但是另一个重要的部分不见了:圈子目前没有任何身份。这意味着，如果传递的数字比以前多，则差值被传递到<code class="fe kn ko kp kq b">enter</code>集合，如果传递的数字少，则差值被传递到<code class="fe kn ko kp kq b">exit</code>集合。但在许多情况下，这还不够。想象一下选举的可视化:可能有两个新的政党，一个政党已经不存在了，所以在<code class="fe kn ko kp kq b">enter</code>和<code class="fe kn ko kp kq b">exit</code>集合中应该有一些元素。为了使这成为可能，我们必须能够以某种方式识别数据。这也是为什么 <code class="fe kn ko kp kq b"><strong class="jp ir">data</strong></code>中的关键功能<strong class="jp ir">方法被引入的原因。</strong></p><p id="7559" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用上面的代码来显示不同选举的结果。我知道条形图是更好的可视化方法，但是我们将再次使用圆圈，所以请耐心等待。为了让D3.js能够识别这个圆，并允许它移动现有的圆，而不是让它们消失和再次出现，我们将使用作为第二个参数传递给<code class="fe kn ko kp kq b">data</code>方法的<code class="fe kn ko kp kq b">key</code>函数。我们也不再使用普通数字作为数据，而是使用由一个<code class="fe kn ko kp kq b">fill</code>和一个<code class="fe kn ko kp kq b">value</code>属性组成的对象。<code class="fe kn ko kp kq b">value</code>替换之前的数字，<code class="fe kn ko kp kq b">fill</code>属性描述圆的颜色，作为圆的标识符。让我们看一下代码:</p><pre class="kr ks kt ku gt kv kq kw kx aw ky bi"><span id="0993" class="kz la iq kq b gy lb lc l ld le"><strong class="kq ir">const</strong> data <strong class="kq ir">=</strong> [<br/>    [<br/>        {fill: 'green', value: 30},<br/>        {fill: 'red', value: 18},<br/>        {fill: 'blue', value: 9},<br/>    ],<br/>    [<br/>        {fill: 'black', value: 35},<br/>        {fill: 'red', value: 27},<br/>        {fill: 'green', value: 18},<br/>        {fill: 'pink', value: 3},<br/>    ],<br/>    [<br/>        {fill: 'red', value: 30},<br/>        {fill: 'green', value: 15},<br/>        {fill: 'black', value: 14},<br/>        {fill: 'pink', value: 6},<br/>    ],<br/>];</span><span id="ca33" class="kz la iq kq b gy mh lc l ld le"><strong class="kq ir">let</strong> currentIndex <strong class="kq ir">=</strong> 0;</span><span id="de46" class="kz la iq kq b gy mh lc l ld le">document.getElementsByTagName('button')[0].addEventListener(<br/>    'click',<br/>    () <strong class="kq ir">=&gt;</strong> update(<strong class="kq ir">++</strong>currentIndex)<br/>);</span><span id="39c4" class="kz la iq kq b gy mh lc l ld le"><strong class="kq ir">function</strong> update(index) {<br/>    d3.select('svg').selectAll('circle')<br/>        .data(data[index], (d) <strong class="kq ir">=&gt;</strong> d.fill)<br/>            .join(<br/>                (enter) <strong class="kq ir">=&gt;</strong> enter.append('circle')<br/>                    .style('fill', (d) <strong class="kq ir">=&gt;</strong> d.fill)<br/>                    .attr('r', 0)<br/>                    .attr('cy', 50),<br/>                (update) <strong class="kq ir">=&gt;</strong> update,<br/>                (exit) <strong class="kq ir">=&gt;</strong> exit.call((exit) <strong class="kq ir">=&gt;</strong> exit<br/>                    .transition()<br/>                        .duration(500)<br/>                            .attr('r', 0)<br/>                            .remove()<br/>                )<br/>            )<br/>                .transition()<br/>                    .duration(500)<br/>                        .attr('r', (d) <strong class="kq ir">=&gt;</strong> d.value)<br/>                        .attr('cx', (d, i) <strong class="kq ir">=&gt;</strong> (i <strong class="kq ir">+</strong> 1) <strong class="kq ir">*</strong> 50)<br/>}</span><span id="623e" class="kz la iq kq b gy mh lc l ld le">update(0);</span></pre><p id="5243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了一些我想强调的小差异之外，它看起来与我们之前的产品非常相似:</p><ol class=""><li id="1317" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><strong class="jp ir"/><code class="fe kn ko kp kq b"><strong class="jp ir">data</strong></code><strong class="jp ir">变量如前所述已经改变。</strong>它是数组的数组，内部数组包含颜色为<code class="fe kn ko kp kq b">fill</code>和<code class="fe kn ko kp kq b">value</code>的对象。选举的结果可能以类似的方式表示。</li><li id="6627" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir"/><code class="fe kn ko kp kq b"><strong class="jp ir">data</strong></code><strong class="jp ir">函数传递第二个参数，这个参数称为</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">key</strong></code> <strong class="jp ir">函数。</strong>我们返回<code class="fe kn ko kp kq b">data</code>变量的<code class="fe kn ko kp kq b">fill</code>值，该值将被用作圆的标识符。</li><li id="e8c8" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">中的</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">transition</strong></code> <strong class="jp ir">后的</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">join</strong></code> <strong class="jp ir">调用的</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">attr</strong></code> <strong class="jp ir">调用的</strong> <code class="fe kn ko kp kq b"><strong class="jp ir">r</strong></code> <strong class="jp ir">必须进行改编</strong>，因为数据点现在是一个对象而不是一个数字。</li></ol><p id="1221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在D3.js能够正确地将圆分配给<code class="fe kn ko kp kq b">enter</code>、<code class="fe kn ko kp kq b">update</code>和<code class="fe kn ko kp kq b">exit</code>组。当点击不同的数据点时，圆圈现在应该保持它们的颜色并四处移动。如果操作不正确，圆圈会改变颜色，而不是移动正确的位置。这可能会很容易地挫败这种可视化的目的，因为数据发生了什么对于查看者来说是不清楚的。</p><h1 id="b064" class="lf la iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="e006" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">希望以上几点能帮助别人比我更快地理解D3.js。<strong class="jp ir">最后，我想说的是，在许多情况下，使用一个简单的图表库可能会更容易，但这些库并不强大，你可能很快就会走进死胡同。一旦你理解了D3.js，你也可以很快地开发简单的条形图和折线图，同时如果需要的话，还可以将你的图表变得更加复杂。还有一个额外的好处:可视化数据很有趣！</strong></p><h1 id="f668" class="lf la iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">简单英语的JavaScript</h1><p id="cff1" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kl" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jp ir">！</strong></p></div></div>    
</body>
</html>