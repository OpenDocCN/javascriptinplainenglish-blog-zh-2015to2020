<html>
<head>
<title>Collision “Event Listener” in Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Three.js中的冲突“事件监听器”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/collision-event-listener-in-three-js-12055fcb2b4a?source=collection_archive---------2-----------------------#2019-11-19">https://javascript.plainenglish.io/collision-event-listener-in-three-js-12055fcb2b4a?source=collection_archive---------2-----------------------#2019-11-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7a4d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">当两个对象碰撞时，在JavaScript中产生某种效果</h2></div><p id="04b9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最近用Three.js做了一个游戏，它很大程度上依赖于两个3D物体碰撞时发生的事情。得知以下代码不起作用时，我非常难过:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="650b" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">sphere</strong>.addEventListener('bonk', (<strong class="ld io">e</strong>) =&gt; {<br/>  <strong class="ld io">e</strong>.target.explode<br/>}</span></pre><figure class="ky kz la lb gt lo gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/5003552a273f1b6830fd1564d47581ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*q35XZTAngPgRKLmzv_KnOA.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Game behavior</figcaption></figure><p id="2d05" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lv">“哎呀，这可能比想象的要难，”</em>我心想。实际上，这相当简单，我终于明白了如何在不使用另一个Three.js插件的情况下创建这个行为<strong class="ke io">。这个秘密存在于一个你在Three.js中可能已经熟悉的方法中…</strong></p><p id="b051" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">DOM不同于画布</strong></p><p id="031f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“以什么方式，”你问？画布只是一个可以呈现Three.js(以及其他动画作品)的DOM元素。这意味着向它添加事件侦听器与向按钮或整个窗口添加事件侦听器没有什么不同。长话短说，<code class="fe lw lx ly ld b">.addEventListener()</code>不会给我们想要的东西，因为我们需要<code class="fe lw lx ly ld b">sphere</code>来“听”碰撞，而不是整个画布。另外，<em class="lv">画布上呈现的3D形状不是DOM元素！</em>也许可以解释为什么我上面的迷因代码不起作用…</p><h2 id="8835" class="lh li in bd lz ma mb dn mc md me dp mf kl mg mh mi kp mj mk ml kt mm mn mo mp bi translated">秘密就在动画方法中</h2><p id="13ad" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">在我的游戏中，只有当你的滑动物体的形状和/或颜色与你的滑块的轮廓相匹配时，下落的物体才会被你的滑动物体摧毁。这是一个基本的匹配游戏。你的游戏可能不同，但概念大多是相同的。</p><p id="9b70" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Three.js中，<code class="fe lw lx ly ld b">animate()</code>函数用于在画布上移动3D对象。这个方法中的代码每秒运行60次，或者更恰当地说，以60fps的<em class="lv">帧速率运行。</em>这意味着无论你在动画函数中写什么，每秒钟都会执行60次<em class="lv"/>。当我意识到这一点时，一切都明白了。我不需要一个事件监听器，我只需要一个逻辑来计算下落物体相对于滑块的位置。</p><figure class="ky kz la lb gt lo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e2be50c887e0de2642af177f52304419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*f7a7YFc1kFhBKwOANlxRwg.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">requestAnimationFrame</figcaption></figure><p id="f127" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我并不是说这是一个Three.js教程，因为互联网上已经有了更好的教程，但是这个方法内置在JavaScript中，可以在页面上显示对象。在Three.js中，这意味着你可以让物体旋转，翻转，以及其他一些很棒的东西。这也意味着你可以让它每秒钟检查60次它的位置！</p><p id="b645" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我用来实际创建您在上面看到的行为的代码对您来说很可能看起来像意大利面条，所以我将只在Three.js中介绍创建碰撞“事件侦听器”的基础知识:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4923" class="lh li in ld b gy lj lk l ll lm">function animate(){</span><span id="af04" class="lh li in ld b gy mx lk l ll lm">//af is a hoisted variable for our animation frame</span><span id="c9ef" class="lh li in ld b gy mx lk l ll lm"> <strong class="ld io">af</strong> = requestAnimationFrame(animate)</span><span id="b7a8" class="lh li in ld b gy mx lk l ll lm">//declare your variables, it'll make your code cleaner<br/>//here, we declare our variables of X and Y position on the page, //you may do this for Z if necessary as well<br/>//our sliding object (see gif above) is abstracted to a variable called <strong class="ld io">slider</strong></span><span id="5e95" class="lh li in ld b gy mx lk l ll lm">  var <strong class="ld io">xDif</strong> = <strong class="ld io">slider</strong>.position.x - <strong class="ld io">newSphere</strong>.position.x<br/>  var <strong class="ld io">yDif</strong> = <strong class="ld io">slider</strong>.position.y - <strong class="ld io">newSphere</strong>.position.y</span><span id="246a" class="lh li in ld b gy mx lk l ll lm">// these will update 60 times per second</span><span id="8da1" class="lh li in ld b gy mx lk l ll lm">// our spheres have a radius of 3, so we use |3| as upper and lower // bounds since the position is determined from the center point</span><span id="086e" class="lh li in ld b gy mx lk l ll lm">if (<strong class="ld io">yDif</strong> &lt; 3 &amp;&amp; <strong class="ld io">yDif</strong> &gt; -3 &amp;&amp; <strong class="ld io">xDif</strong> &lt; 3 &amp;&amp; <strong class="ld io">xDif</strong> &gt; -3){<br/> *stuff you want to do when there is a collision*</span><span id="7d9c" class="lh li in ld b gy mx lk l ll lm">cancelAnimationFrame( <strong class="ld io">af</strong> ); // animation frame stops</span><span id="a530" class="lh li in ld b gy mx lk l ll lm"><strong class="ld io">scene</strong>.remove(<strong class="ld io">newSphere</strong>); </span><span id="b6a6" class="lh li in ld b gy mx lk l ll lm">//sphere is removed from the scene, it has made contact with the slider</span><span id="c5e6" class="lh li in ld b gy mx lk l ll lm">}</span><span id="481e" class="lh li in ld b gy mx lk l ll lm">}</span></pre><p id="d05c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不要再用废弃的库碰壁了。在Three.js中处理碰撞“事件”实际上并没有那么糟糕！</p><h2 id="1a99" class="lh li in bd lz ma mb dn mc md me dp mf kl mg mh mi kp mj mk ml kt mm mn mo mp bi translated">这难道不会表现得很糟糕吗？</h2><p id="2fb6" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">这并不像你想象的那么糟糕，但是如果你有一个程序同时在屏幕上显示成百上千个对象，那么是的，它可能不能很好地运行。对于我的游戏来说，它运行得相当流畅。顺便提一下，背景中的星星都在旋转，发光的立方体用三个. js渲染，它们在Z轴上非常远，所以实际上屏幕上同时有很多项目…</p><figure class="ky kz la lb gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/aac96196208a6a464efe5026f4d28f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNv5hlyz-cmssU5LFLMwSQ.png"/></div></div></figure><h2 id="c7e5" class="lh li in bd lz ma mb dn mc md me dp mf kl mg mh mi kp mj mk ml kt mm mn mo mp bi translated">把这个逻辑放在Slider类中会不会更好？</h2><p id="b72f" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">这会让游戏运行得更快吗？也许吧。很难说。不是每个下落物体都检查它自己相对于滑块的位置，而是滑块必须检查它相对于所有下落物体的位置。这个设计选择取决于你。但这不是你点击这篇文章的原因！您只是想知道如何为对象碰撞创建一个事件监听器！</p></div></div>    
</body>
</html>