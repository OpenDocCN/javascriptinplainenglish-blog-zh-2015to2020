<html>
<head>
<title>Functional Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数式编程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-programming-in-javascript-9c608eab368b?source=collection_archive---------2-----------------------#2020-09-10">https://javascript.plainenglish.io/functional-programming-in-javascript-9c608eab368b?source=collection_archive---------2-----------------------#2020-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="11f0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">什么是函数式编程？它提供了什么？</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/3237cbd09e15d5bea6379d57432683a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gp13S0egi8VlNqvS2isTDA.png"/></div></div></figure><p id="73d9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们来谈谈函数的原始编写方式。函数根据我们的需求执行一组特定的动作，包括获取数据、更新状态、改变一组可变值和更新DOM等等。</p><p id="847e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后我们的代码库变得越来越大，在某个特定点之后，我们必须处理bug。啊！</p><p id="f419" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">大多数情况下，修复bug是一个乏味的过程，因为你必须经历潜在的问题，有时会有很多！我们修复它们，然后我们有更多的错误，恶性循环继续！在某些时候，我们可能只是看着我们的代码库，最后说这是可行的，虽然我真的不知道怎么做到的！太神奇了！:D</p><p id="1a9b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">作为魔术师，你需要清楚地了解你玩的把戏。如果你打算重构你的代码或者写一个新的，你可能需要考虑你代码中的应用程序状态更新。</p><p id="d53e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">应用状态</strong></p><p id="d808" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应用程序状态是定义程序实例的所有值的整体。一些值将从这个状态中派生出来，例如动态按钮颜色或“p”标记中的动态内容。用户也可以使用<strong class="ku ir">事件</strong>与状态持续交互。</p><p id="abdb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">状态包含最重要的值，如果处理不当会导致错误。所以直接改变任何地方的状态值都不是一个好主意。</p><p id="0e06" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">把逻辑执行和状态更新分开怎么样？换句话说，如果我们把我们的代码库分成纯粹的函数和状态变化(也就是副作用)会怎么样？</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="834c" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated"><strong class="ak">功能编程</strong></h2><p id="329f" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">函数式编程是一种编程范式，在这种编程范式中，你广泛地使用函数，更重要的是，大多数函数都是纯函数。</p><p id="4e9e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是在深入纯函数之前，有两件事需要说明，一是副作用，二是高阶函数。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="3020" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">副作用</h2><p id="2d0b" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">在函数式编程环境中，副作用是非常有趣的。副作用是任何改变程序状态的东西，比如DOM更新、获取请求，甚至是登录到控制台。</p><p id="7291" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">换句话说，函数在其本地环境之外所做的任何永久改变都是副作用。</p><p id="d0df" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这些效果正是我们实际上需要我们的程序来实现的。但我们也需要确保它们得到妥善管理。</p><p id="f049" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里的目标是以这样一种方式构建您的代码，即副作用不会扩散到任何地方，而是被包含和限制在需要它的地方。您仍然需要编写大量的逻辑，这就是纯函数发挥作用的地方。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="41ed" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">高阶函数</h2><p id="b3db" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">函数是JavaScript中的一等公民，这意味着:</p><ul class=""><li id="a85d" class="mt mu iq ku b kv kw ky kz lb mv lf mw lj mx ln my mz na nb bi translated">可以使用匿名函数将它们赋给任何变量。</li><li id="8945" class="mt mu iq ku b kv nc ky nd lb ne lf nf lj ng ln my mz na nb bi translated">它们可以在另一个函数中作为参数传递。</li><li id="dd57" class="mt mu iq ku b kv nc ky nd lb ne lf nf lj ng ln my mz na nb bi translated">它们也可以像其他数据类型一样从另一个函数返回。</li></ul><p id="2c8b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这确实有助于<strong class="ku ir">函数组合</strong>和<strong class="ku ir">声明式</strong>编码风格，它们是函数式编程的显著特征。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="8403" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">纯函数</h2><p id="ba82" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">纯函数的整体思想是让你的代码更容易推理。你知道输入，你可以很容易地预测输出。</p><p id="9a3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">纯函数的灵感来自于函数的数学定义。在数学中，函数由以下等式表示:</p><pre class="kh ki kj kk gt nh ni nj nk aw nl bi"><span id="a96f" class="lv lw iq ni b gy nm nn l no np">f(x)=y </span></pre><p id="01d2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里<strong class="ku ir"> x </strong>是输入，<strong class="ku ir"> y </strong>是输出，该函数仅代表输入和输出之间的关系。</p><p id="6029" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="nq">一个纯粹的函数就像一个数学函数，给定一个特定的输入值，它会给你始终相同的输出，没有副作用。</em></p><p id="0f6b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">看待纯函数的一个更基本的方式是通过<strong class="ku ir">引用透明性。</strong></p><p id="9aaa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当函数调用可以用它的评估值替换并且它根本不改变程序的行为时，这个函数被称为<strong class="ku ir">引用透明的</strong>。</p><p id="6b9f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们来看一个登录函数和实现它的不同方法:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6fbb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在<em class="nq">“登录功能”</em>的纯形式中有两处改变。一个是<strong class="ku ir">不变性</strong>。我们不希望输入或任何外部变量发生突变，这将是一个副作用。当我们写大量的逻辑时，副作用会使我们的函数更难推理。</p><p id="411c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">另一个变化是将'<em class="nq"> userinput' </em>'作为参数，因为我们的函数输出依赖于该变量。这使得函数输出更加可预测和可靠。</p><p id="308b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">想象一个场景，其中'<em class="nq"> globaldata' </em>不正确，在这种情况下，您不必查看纯'<em class="nq"> login函数'</em>,寻找任何不想要的突变，如果您知道输入，您可以很容易地预测它的输出。毕竟我们都喜欢可靠性！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="681d" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">声明式风格和代码重用</h2><p id="c53d" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">函数式编程真正有帮助的另一件事是编码的声明方式。</p><p id="911c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">声明式</strong>方式和<strong class="ku ir">命令式</strong>方式是两种编码方式。声明式编码的思想是将代码的重复部分一般化，这样我们的主代码看起来更小更整洁。以数组中的方法'<em class="nq"> map' </em>和'<em class="nq"> reduce' </em>为例，它主要用于循环数组值。坦率地说，我很少用<strong class="ku ir">代替</strong>和<strong class="ku ir">，而</strong>现在用数组循环。我已经被'<em class="nq">地图'</em>和'<em class="nq">还原'</em>惯坏了。唉！</p><p id="bf70" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是它的迷人之处在于'<em class="nq"> map' </em>和'<em class="nq"> reduce' </em>都在幕后使用<strong class="ku ir"> for/while </strong>循环来循环数组。当你在幕后做事情时，那是<strong class="ku ir">声明式</strong>的编码风格，因为你没有进入事情应该如何做的本质细节。更确切地说，你是在宣告你想要什么。</p><p id="acf9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您只需定义一次<em class="nq">【map】</em>和<em class="nq">【reduce】</em>，然后您就可以随时使用它。看一看:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="f52e" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">Currying</h2><p id="f266" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">我不知道是谁给这个概念起的名字，但它听起来确实很印度！Currying有助于使函数在调用和分配参数时更加灵活。</p><p id="fb43" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Currying的特殊之处在于，每次调用它只接受一个输入，然后返回一个输出，如果需要更多的参数，这个输出就是函数，否则就是输出。</p><p id="5f61" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一个使用currying的简单示例:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c798" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">基本思想是每个函数调用只有一个输入和一个输出，这在我们编写或管道时很方便，我们将会看到。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="589f" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">操作组合</h2><p id="5403" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">功能组合是将两个功能结合起来，得到一个产品功能。组合它们的方法是将一个函数的输出作为输入提供给下一个函数。等式看起来像:</p><pre class="kh ki kj kk gt nh ni nj nk aw nl bi"><span id="7d3e" class="lv lw iq ni b gy nm nn l no np">var resultant = (x)=&gt;f(g(x)); //here the output of function 'g' is<br/>                                provided as input to function 'f'.</span></pre><p id="1393" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">功能组合可用于组合多个功能来创建自定义结果。有两种方法可以做到:</p><p id="72c8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">构成和管道</strong></p><p id="81be" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">假设你有3个函数<em class="nq"> f() </em>，<em class="nq"> g() </em>和<em class="nq"> h()。</em>您希望通过f、g和h传递输入。它应该类似于:</p><pre class="kh ki kj kk gt nh ni nj nk aw nl bi"><span id="2f78" class="lv lw iq ni b gy nm nn l no np">var output=(input)=&gt;h(g(f(input))); </span></pre><p id="f378" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这看起来很复杂，有点像回调地狱。为了避免这种复杂性，我们可以使用<strong class="ku ir">组合</strong>和<strong class="ku ir">管道</strong>。</p><p id="2be7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Compose </strong>所做的是将函数(<em class="nq"> f，g，h </em>)作为参数，然后返回一个从右向左运行输入的函数。</p><p id="8e83" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">管道</strong>类似于compose，除了它从左到右运行输入。我看不出左右的区别，但这就是区别。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="701e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里需要注意的重要一点是，每个函数的返回都作为参数传递给下一个函数，这就是为什么我们在组合中需要<strong class="ku ir">一元函数</strong>，尽管第一个函数可以有多个参数。</p><p id="63dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，我们如何利用<strong class="ku ir">的功能组合</strong>和<strong class="ku ir">的巧妙组合</strong>来制作出一些很酷的东西呢？我制作了一个小例子来展示我们如何使用这些概念从URL中提取参数:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="720c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，所有这些都可以用一个函数来执行，但是这个函数可以为一个单独的任务定制。</p><p id="a8b4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我们将大任务分解成小任务时，我们可以寻找的是小功能的可重用性，比如这里重用的<strong class="ku ir"> split </strong>。同样，如果我们将其他函数更一般化，我们也可以在代码的其他部分重用它们。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="9e55" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">状态管理</h2><p id="a57c" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">大多数逻辑可以使用纯函数编写，但是逻辑必须在某个点应用于状态，减少这些突变点极大地帮助我们找出代码中的小错误。</p><p id="4b66" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有趣的是，我们可以用这里的函数来更新状态。功能和功能无处不在！:D</p><p id="5196" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里的想法是使状态不可直接访问，并使用函数来访问或更新它。大概是这样的:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="26fd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了简单起见，我在这个例子中做了简单的复制，但是你已经得到了它的要点。我希望这能给你一个函数式编程的基本概念。</p><p id="187d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="nq">享受函数带来的乐趣！</em></p></div></div>    
</body>
</html>