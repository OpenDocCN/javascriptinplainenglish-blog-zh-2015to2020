<html>
<head>
<title>Frontend Architecture: Pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端架构:分页</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/frontend-architecture-pagination-c71b5c2c8a41?source=collection_archive---------2-----------------------#2020-04-09">https://javascript.plainenglish.io/frontend-architecture-pagination-c71b5c2c8a41?source=collection_archive---------2-----------------------#2020-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2039" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React.js的完整分页指南</h2></div><p id="93f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前端应用程序中有许多正确的分页方法，但也有许多错误的方法。通常，前端的功能性分页实现和“好的”分页实现之间的差别非常微妙，但是可以很容易地解决。让我们快速了解一种在React应用程序中创建分页的有效方法。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/be95c42e9c920e50a9d56654d33ca0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1i079nX8o8ws3XSE"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@d_mccullough?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel McCullough</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9f67" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置</h1><p id="63c8" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们用最快的方式来引导React应用程序:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="53b6" class="mu lt iq mq b gy mv mw l mx my">npx create-react-app sample-project-name</span></pre><p id="e42f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本指南，我想显示一个带有分页组件的神奇宝贝表，用户可以点击它在页面之间跳转。我想为UI逻辑而不是CSS创建一个指南，所以我使用了<a class="ae lr" href="https://react.semantic-ui.com/" rel="noopener ugc nofollow" target="_blank">语义UI </a>来实现。以下是如何将它添加到您的项目中:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="f6e7" class="mu lt iq mq b gy mv mw l mx my">yarn add semantic-ui-react</span><span id="1009" class="mu lt iq mq b gy mz mw l mx my">yarn add semantic-ui-css</span></pre><p id="d93a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我只是在我的<code class="fe na nb nc mq b">index.js</code>上添加了semantic-ui-css文件，看起来像这样:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="0776" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">初始实施</h1><p id="b590" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">像我的大多数其他教程一样，我决定在这个项目中使用<a class="ae lr" href="https://pokeapi.co/" rel="noopener ugc nofollow" target="_blank"> PokéApi </a>。最初的实现是简单地使用Semantic-UI的<a class="ae lr" href="https://react.semantic-ui.com/collections/table/" rel="noopener ugc nofollow" target="_blank"> Table </a>和<a class="ae lr" href="https://react.semantic-ui.com/addons/pagination/" rel="noopener ugc nofollow" target="_blank"> Pagination </a>组件来创建一个视图，在这个视图中，每一个页面更改都会重新触发一个带有新偏移值的对PokéApi的获取。</p><p id="85a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您不熟悉分页，那么“offset”值就是我们要获取记录的范围的起始编号。“limit”值是我们希望在页面上显示的记录数。例如，向<code class="fe na nb nc mq b">https://my-api.co/entities?offset=0&amp;limit=2</code>发出请求将会返回一个示例响应，如下所示:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="f4fc" class="mu lt iq mq b gy mv mw l mx my">[<br/>    { "name": "Dante", "id": 0 },<br/>    { "name": "Vergil", "id" 1 }<br/>]</span></pre><p id="69d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向<code class="fe na nb nc mq b">https://my-api.co/entities?offset=2&amp;limit=2</code>发出请求将返回如下示例响应:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="ea0a" class="mu lt iq mq b gy mv mw l mx my">[<br/>    { "name": "Nero", "id": 2 },<br/>    { "name": "Sparda", "id": 3 }<br/>]</span></pre><p id="0649" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抱歉，如果您已经知道这一点，但是现在我们可以看看我最初的分页实现了:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1d66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们可以看到，我们使用一个常量将页面上显示的神奇宝贝的总数限制为10个(这个常量应该在UPPER_SNAKE_CASE中，不过没关系😅).我们将页面初始化为1，并且在每次页面改变时，我们使用来自<code class="fe na nb nc mq b">useState</code>的setter来改变我们的<code class="fe na nb nc mq b">page</code>变量。当然，我们也从JSON和response中的<code class="fe na nb nc mq b">results</code>属性接收<code class="fe na nb nc mq b">pokemon</code>,并将神奇宝贝的<code class="fe na nb nc mq b">total</code>号作为<code class="fe na nb nc mq b">count</code>属性。我们通过<code class="fe na nb nc mq b">results</code>映射以在我们的表上显示神奇宝贝，由于分页的语义UI实现将需要总页数，我们使用total/ <code class="fe na nb nc mq b">count</code>并除以我们的页面限制，因为我们每页不显示一个神奇宝贝。为了避免小数，我们使用了<code class="fe na nb nc mq b">Math.ceil</code>。</p><p id="fa55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常标准的分页实现，很有效，很常见，但是还有很大的改进空间。我发现这个实现的最大问题是，如果我转到应用程序的第二页，然后重新加载页面，我会回到第一页。我们可以通过使用<code class="fe na nb nc mq b">localStorage</code>或<code class="fe na nb nc mq b">sessionStorage</code>来解决这个问题，但是如果一个用户与另一个用户共享这个列表，并且想要在某个页面向他们显示神奇宝贝的相同视图，他/她也必须与他们共享页码。如果我们能够将这种状态保存在url中，而不是使用本地或会话存储，这将会更好，这也将允许用户彼此共享。将它保存在url中还允许“超级用户”利用“高级”功能。一个技术“超级”用户，会了解一个url的搜索参数，如果你正在创建一个像JIRA这样的B2B软件，这样的功能可以派上用场。让我们来实现它:</p><h1 id="5df5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">改进的分页</h1><p id="57dd" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">下面是改进后的代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cec6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在使用<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" rel="noopener ugc nofollow" target="_blank"> URLSearchParams </a>来解析和编辑URL中的“页面”搜索参数，以便用户所在的活动页面可以在页面刷新或URL共享时得到维护。现在在页面改变时，我们用页码替换窗口的搜索参数，我们的<code class="fe na nb nc mq b">useEffect</code>钩子监听这个页面参数的改变，而不是<code class="fe na nb nc mq b">state</code>变量<code class="fe na nb nc mq b">page</code>。对于初始状态，由于参数可能不存在，我们默认使用<code class="fe na nb nc mq b">1</code>。简单地增加几行代码就已经极大地提高了我们web应用程序的功能！你认为你还能在这里做些什么改进吗？欢迎在下方回复。</p><p id="d6eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这样的内容，请跟我来这里吧！😁</p><h2 id="1c03" class="mu lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated"><strong class="ak">用简单的英语写的JavaScript的注释:</strong></h2><p id="d876" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae lr" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kh ir">AI in Plain English</strong></a><a class="ae lr" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kh ir">UX in Plain English</strong></a><a class="ae lr" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kh ir">Python in Plain English</strong></a><strong class="kh ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>