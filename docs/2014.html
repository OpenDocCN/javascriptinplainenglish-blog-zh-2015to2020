<html>
<head>
<title>Lodash Methods Implemented with Plain JavaScript — Flattening Arrays and Searching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普通JavaScript实现的Lodash方法——展平数组和搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lodash-methods-implemented-with-plain-javascript-flattening-arrays-and-searching-6e40c8f78d5c?source=collection_archive---------8-----------------------#2020-05-12">https://javascript.plainenglish.io/lodash-methods-implemented-with-plain-javascript-flattening-arrays-and-searching-6e40c8f78d5c?source=collection_archive---------8-----------------------#2020-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42f4bb2304de0197864a781daee79d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UQihrst0GstOF3LY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@dnunis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Darren Nunis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6c37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="ea21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用<code class="fe lb lc ld le b">flattenDeep</code>和<code class="fe lb lc ld le b">flattenDepth</code>来展平递归数组，并用<code class="fe lb lc ld le b">fromPair</code>将数组键值对转换成对象。</p><h1 id="abee" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">flattenDeep</code></h1><p id="d2ba" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">洛达什的<code class="fe lb lc ld le b">flattenDeep</code>递归展平数组。现在JavaScript有了一个用于展平数组的<code class="fe lb lc ld le b">flat</code>实例方法，我们不再需要这个方法了。</p><p id="859e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一更好的是，它返回一个新数组，而不是修改原来的数组。</p><p id="4400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它来创建我们自己的<code class="fe lb lc ld le b">flattenDeep</code>方法；</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f75c" class="mq lg iq le b gy mr ms l mt mu">const flattenDeep = arr =&gt; arr.flat(Infinity)</span></pre><p id="428c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传入<code class="fe lb lc ld le b">Infinity</code>递归变平。</p><p id="3e14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d6b6" class="mq lg iq le b gy mr ms l mt mu">const flattened = flattenDeep([1, [2],<br/>  [<br/>    [3]<br/>  ], 4, 5<br/>])</span></pre><p id="db01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lb lc ld le b">flattened</code>就是<code class="fe lb lc ld le b">[1, 2, 3, 4, 5]</code>。更难的方法是我们自己从头开始实施。但是，我们可以使用spread运算符使其更短，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="901e" class="mq lg iq le b gy mr ms l mt mu">const flattenDeep = arr =&gt; {<br/>  let flattened = [];<br/>  for (const a of arr) {<br/>    if (Array.isArray(a)) {<br/>      flattened = [...flattened, ...a];<br/>      flattened = [...flattenDeep(flattened)]<br/>    } else {<br/>      flattened.push(a);<br/>    }<br/>  }<br/>  return flattened;<br/>}</span></pre><p id="14a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们递归地调用了自己的<code class="fe lb lc ld le b">flattenDeep</code>函数。只有当条目是数组时，我们才递归调用它。</p><p id="0a5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它们都给我们带来了相同的结果。</p><h1 id="e7ef" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">平坦深度</h1><p id="31e1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">方法递归地展平一个数组直到给定的深度级别。</p><p id="08aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们从上面的<code class="fe lb lc ld le b">flattenDeep</code>例子中看到的，JavaScript的内置<code class="fe lb lc ld le b">flat</code>方法使用一个参数来指定要展平的深度。</p><p id="dddd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以实现自己的<code class="fe lb lc ld le b">flattenDepth</code>功能，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="db0c" class="mq lg iq le b gy mr ms l mt mu">const flattenDepth = (arr, depth) =&gt; arr.flat(depth)</span></pre><p id="7747" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是用自己的<code class="fe lb lc ld le b">depth</code>调用<code class="fe lb lc ld le b">flat</code>。因此，当我们这样称呼它时:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ca3c" class="mq lg iq le b gy mr ms l mt mu">const flattened = flattenDepth([1, [2],<br/>  [<br/>    [3]<br/>  ], 4, 5<br/>], 1)</span></pre><p id="a658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到的<code class="fe lb lc ld le b">flattened</code>是:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8880" class="mq lg iq le b gy mr ms l mt mu">[<br/>  1,<br/>  2,<br/>  [<br/>    3<br/>  ],<br/>  4,<br/>  5<br/>]</span></pre><p id="c194" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们指定将给定的数组展平一级深度。</p><p id="3e89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想自己实现<code class="fe lb lc ld le b">flattenDepth</code>，我们可以实现类似于我们从头开始实现<code class="fe lb lc ld le b">flattenDeep</code>的东西:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7ad3" class="mq lg iq le b gy mr ms l mt mu">const flattenDepth = (arr, depth, flattenedDepth = 0) =&gt; {<br/>  let flattened = [];<br/>  for (const a of arr) {<br/>    if (Array.isArray(a)) {<br/>      flattened = [...flattened, ...a];<br/>      if (depth &lt; flattenedDepth) {<br/>        flattened = [...flattenDepth(flattened, flattenedDepth + 1)]<br/>      }<br/>    } else {<br/>      flattened.push(a);<br/>    }<br/>  }<br/>  return flattened;<br/>}</span></pre><p id="1e82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个额外的<code class="fe lb lc ld le b">flattenDepth</code>参数，它被设置为0，这样我们就可以跟踪被展平的数组的深度。</p><p id="024e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只在</p><p id="d0cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在递归调用<code class="fe lb lc ld le b">flattenedDepth</code>时将<code class="fe lb lc ld le b">flattenedDepth</code>加1。</p><p id="b4fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到了与用数组的<code class="fe lb lc ld le b">flat</code>方法实现的<code class="fe lb lc ld le b">flattenDepth</code>相同的结果。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8a3bcb835e7b880fb5ada528cf68e9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bcffC9yvxN45BrLM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@itfeelslikefilm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">🇸🇮 Janko Ferlič</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fa42" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">fromPairs</code></h1><p id="9ce7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">fromPairs</code>方法转换返回一个对象，该对象具有一个数组条目，其中键作为第一个条目，值作为第二个条目。</p><p id="1364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript已经有一个<code class="fe lb lc ld le b">Object.fromEntries</code>做同样的事情，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="09b4" class="mq lg iq le b gy mr ms l mt mu">const obj = Object.fromEntries([<br/>  ['a', 1],<br/>  ['b', 2]<br/>])</span></pre><p id="39c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以得出<code class="fe lb lc ld le b">obj</code>对象是:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f08b" class="mq lg iq le b gy mr ms l mt mu">{<br/>  "a": 1,<br/>  "b": 2<br/>}</span></pre><p id="bf28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Object.fromEntries</code>返回与<code class="fe lb lc ld le b">fromPairs</code>相同的结果，所以我们肯定不再需要<code class="fe lb lc ld le b">fromPairs</code>了。</p><h1 id="ff7f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">索引Of</h1><p id="434e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lb lc ld le b">indexOf</code>方法与普通JavaScript的<code class="fe lb lc ld le b">indexOf</code>方法相同。Lodash <code class="fe lb lc ld le b">indexOf</code>可以使用一个开始索引来搜索一个项目，plain <code class="fe lb lc ld le b">indexOf</code>方法也使用这个索引。</p><p id="e032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用普通的<code class="fe lb lc ld le b">indexOf</code>方法来实现<code class="fe lb lc ld le b">indexOf</code>方法，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c9ad" class="mq lg iq le b gy mr ms l mt mu">const indexOf = (arr, value, start) =&gt; arr.indexOf(value, start)</span></pre><p id="f6bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，我们只是使用了<code class="fe lb lc ld le b">indexOf</code>方法的所有参数。唯一的区别是在<code class="fe lb lc ld le b">arr</code>上调用了<code class="fe lb lc ld le b">indexOf</code>，这是一个数组实例。</p><h1 id="32dd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="0543" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以调用我们自己的数组展平函数或者数组实例的<code class="fe lb lc ld le b">flat</code>方法，这两个方法都会展平一个数组。</p><p id="8cde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Object.fromEntries</code>方法取代了Lodash中的<code class="fe lb lc ld le b">fromPair</code>方法。</p><p id="b910" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，数组实例的<code class="fe lb lc ld le b">indexOf</code>方法替换了Lodash的<code class="fe lb lc ld le b">indexOf</code>方法。</p><h2 id="2c72" class="mq lg iq bd lh mw mx dn ll my mz dp lp ko na nb lt ks nc nd lx kw ne nf mb ng bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="b7ca" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="0eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>