<html>
<head>
<title>Protect your users from Cross-Site Request Forgery (CSRF)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护您的用户免受跨站点请求伪造(CSRF)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/protect-your-users-from-cross-site-request-forgery-csrf-8b341b9beea2?source=collection_archive---------5-----------------------#2020-08-11">https://javascript.plainenglish.io/protect-your-users-from-cross-site-request-forgery-csrf-8b341b9beea2?source=collection_archive---------5-----------------------#2020-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b66a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">类似“特洛伊木马”的攻击，可能会带来灾难性后果</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/668bfb433af2035159d4c0db9b491a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZO1kVtBsQnZm67KyIHBI5Q.png"/></div></div></figure><p id="4899" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">黑客最有可能通过利用互联网协议的设计来成功危害用户帐户。在本文中，我将重点介绍HTTP的一个特性，它已经被证明也是一个缺点:cookies。</p><h2 id="e6b8" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated"><strong class="ak">饼干可能是个负担，但它们非常有用</strong></h2><p id="cd79" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">是的，饼干超级有用。网站广泛利用cookies进行会话存储。一旦您登录到一个网站，服务器会发送一些会话cookiess，您的web浏览器会在一段时间内记住这些cookie。Cookies极大地改善了用户体验。我的意思是，你能想象在一个网站上每个页面导航都要登录吗？</p><p id="8ea7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是它们的有用性是以安全为代价的——它们使得一种最常见的HTTP攻击变得容易实现:跨站点请求伪造(CSRF)。让我们讨论一个假设的例子来说明CSRF袭击的危险。将使用一个名为PurplePay的虚拟支付处理器。</p><h1 id="e895" class="ml lo iq bd lp mm mn mo ls mp mq mr lv jw ms jx ly jz mt ka mb kc mu kd me mv bi translated">CSRF受害者示例:PurplePay</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/d34a35a5ad7f0442da65b65b5f4e73c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDV3H1Ya5XBEnaKrBqmtlQ.png"/></div></div></figure><p id="82a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">PurplePay是一个简单的在线支付处理器，允许您向任何拥有PurplePay帐户的人汇款。在您登录PurplePay网站后，会显示上面的屏幕。这意味着当您登录时，PurplePay会指示您的浏览器存储有关您成功认证尝试的会话cookies。记住这一点，因为这对以后很重要。</p><p id="0cd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">PurplePay的开发人员决定将上面显示的表单实现为一个接受姓名和金额(以美元为单位)的<strong class="kt ir"> HTTP POST </strong>请求。如果我们放大表单提交并检查它的主体，它看起来会像这样:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2029" class="ln lo iq my b gy nc nd l ne nf">POST <a class="ae ng" href="http://purplepay.com/send-money" rel="noopener ugc nofollow" target="_blank">http://purplepay.com/send-money</a></span><span id="bd50" class="ln lo iq my b gy nh nd l ne nf">{<br/>    "name": "Bill Gates",<br/>    "amount": 50<br/>}</span></pre><p id="0808" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如前所述，浏览器将自动插入会话cookie和POST方法，PurplePay将使用这些会话cookie来验证是哪个人发起了这个事务。这消除了未经授权的人执行交易的可能性。这似乎足够安全，对不对？</p><h1 id="53bb" class="ml lo iq bd lp mm mn mo ls mp mq mr lv jw ms jx ly jz mt ka mb kc mu kd me mv bi translated">输入:CSRF·哈克</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9d51e4ed4609720086484746a34380e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItX3B8AYqS1wtyN5dnHAqg.png"/></div></div></figure><p id="65e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一名黑客偶然发现PurplePay，并研究了<code class="fe ni nj nk my b">purplepay.com/send-money</code> POST请求的消息格式。黑客意识到，除了会话cookies，成功调用服务器上的<code class="fe ni nj nk my b">send-money</code>资源不需要其他任何东西。</p><p id="a992" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于PurplePay将会话cookies存储在用户的浏览器中，黑客意识到他可以创建一个钓鱼网站，该网站可以悄悄地向<code class="fe ni nj nk my b">purplepay.com/send-money. </code>提交POST请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fe2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当页面加载时，<code class="fe ni nj nk my b">hacked.html </code>页面会自动向<code class="fe ni nj nk my b">purplepay.com/send-money</code>发送POST请求。当浏览器准备发送POST请求时，它意识到已经有了一些用于PurplePay的cookies，并决定自动将它们附加到请求中。</p><p id="dbd0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意到什么不好的事情了吗？<strong class="kt ir"> </strong>如果黑客能说服用户简单地加载那个网页，黑客就已经自动获得了用户PurplePay会话cookies的访问权。如果会话cookies仍然有效，那么黑客对<code class="fe ni nj nk my b">purplepay.com/send-money</code>的隐藏请求被认为是通过PurplePay认证的，黑客现在完全有能力将所有的钱从用户的账户中转出，而无需直接访问它！</p><p id="686c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种强迫浏览器传递用来访问受限资源的存储cookies的方法被称为<strong class="kt ir">跨站点请求伪造</strong> (CSRF)。正如你现在所能想象的，如果不被发现和禁用，其规模和破坏可能是灾难性的。银行账户可能会被清空，信用卡可能会被盗，您可以在网上安全执行的任何其他操作都可能受到威胁。</p><h1 id="b5fd" class="ml lo iq bd lp mm mn mo ls mp mq mr lv jw ms jx ly jz mt ka mb kc mu kd me mv bi translated"><strong class="ak">保护自己免受CSRF的伤害</strong></h1><p id="2a26" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">幸运的是，通过一些被广泛接受的缓解措施，您可以继续使用cookies进行会话存储，而不用担心CSRF攻击。让我们来看看几个最流行的解决方案。</p><h1 id="83c3" class="ml lo iq bd lp mm mn mo ls mp mq mr lv jw ms jx ly jz mt ka mb kc mu kd me mv bi translated">(反)CSRF代币</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/20d61bf93590acb6c912baabf33e2da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVn_nJXxISgUnMf_7iCKyA.png"/></div></div></figure><p id="f4c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回想一下，CSRF是可能的，因为服务器只检查会话cookies来验证请求。不幸的是，这被证明是不安全的，因为浏览器会自动传递它们。</p><p id="0100" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个简单而有效的解决方案是在服务器端生成一个加密令牌，在这里上下文命名为<strong class="kt ir"> CSRF令牌</strong>。服务器会在需要表单提交(或任何其他POST请求交互)的页面上将令牌传递给客户机。<strong class="kt ir">重要的是，服务器不要将这个令牌作为cookie传递，否则我们又回到了同样的情况。</strong></p><p id="29e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，每当客户端提交POST请求时，都必须提供CSRF令牌，通常包含在请求体中。服务器在会话cookies上验证CSRF令牌的真实性。</p><h1 id="c0a8" class="ml lo iq bd lp mm mn mo ls mp mq mr lv jw ms jx ly jz mt ka mb kc mu kd me mv bi translated"><strong class="ak">相同站点cookie</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6abd56cf746e66863eaa17f80aec80bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRw06hJW3gWIBp6Oyj2VuQ.png"/></div></div></figure><p id="e1a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自从CSRF攻击出现以来，网络浏览器已经增加了安全机制，比如完全禁止跨源站点请求(CORS)。此外，服务器可以拒绝来自不同来源的请求。</p><p id="d286" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同一个网站的cookies在对抗CSRF病毒攻击时也是以同样的方式工作的。当cookies被创建时，你可以限制它们只能是<code class="fe ni nj nk my b">SameSite</code>，这意味着如果一个请求是从一个单独的源发起的，浏览器将不会传递它们。这也可以提供一些针对CSRF攻击的安全性。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="e2f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想做更详细的阅读，维基百科有一个关于CSRF的很棒的条目:<a class="ae ng" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a></p></div></div>    
</body>
</html>