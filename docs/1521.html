<html>
<head>
<title>Compile Svelte in your Head</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你的头脑中编译苗条</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/compile-svelte-in-your-head-part-2-8bfec935e09c?source=collection_archive---------7-----------------------#2020-03-26">https://javascript.plainenglish.io/compile-svelte-in-your-head-part-2-8bfec935e09c?source=collection_archive---------7-----------------------#2020-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1192" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第二部分</h2></div><p id="290b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae lb" href="https://lihautan.com/compile-svelte-in-your-head-part-1/" rel="noopener ugc nofollow" target="_blank">第1部分</a>中，我提到了<code class="fe lc ld le lf b">$$invalidate</code>函数，我解释了<code class="fe lc ld le lf b">$$invalidate</code>函数的工作原理如下:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="e6a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这并不是<code class="fe lc ld le lf b">$$invaldiate</code>功能的确切实现。所以在这篇文章中，我们将看看<code class="fe lc ld le lf b">$$invalidate</code>是如何在Svelte中实现的。</p><p id="7e7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在撰写本文时，Svelte处于<a class="ae lb" href="https://github.com/sveltejs/svelte/blob/v3.20.1/CHANGELOG.md#3201" rel="noopener ugc nofollow" target="_blank"> v3.20.1 </a>。</p><h1 id="5b73" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">3 . 16 . 0版之前</strong></h1><p id="2b41" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在<a class="ae lb" href="https://github.com/sveltejs/svelte/blob/master/CHANGELOG.md#3160" rel="noopener ugc nofollow" target="_blank"> v3.16.0 </a>中，也就是在<a class="ae lb" href="https://github.com/sveltejs/svelte/pull/3945" rel="noopener ugc nofollow" target="_blank"> #3945 </a>中，有一个很大的优化改变了<code class="fe lc ld le lf b">$$invalidate</code>函数的底层实现。基本概念没有改变，但是在改变之前理解<code class="fe lc ld le lf b">$$invalidate</code>和单独了解优化改变会容易得多。</p><p id="cffa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们解释一下你将会看到的一些变量，其中一些已经在<a class="ae lb" href="https://gist.github.com/compile-svelte-in-your-head-part-1" rel="noopener ugc nofollow" target="_blank">第一部分</a>中介绍过了:</p><h2 id="9372" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">$$.ctx</h2><p id="b98b" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">它没有正式的名字。您可以称之为<strong class="kh ir"> context </strong>，因为它是模板渲染到DOM所基于的上下文。</p><p id="4980" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我把它叫做<a class="ae lb" href="https://lihautan.com/compile-svelte-in-your-head-part-1/#instance-variable" rel="noopener ugc nofollow" target="_blank">实例变量</a>。因为它是一个包含所有变量的JavaScript对象，您可以:</p><ul class=""><li id="976c" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">在<code class="fe lc ld le lf b">&lt;script&gt;</code>标签中声明</li><li id="f6ba" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">变异或重新分配</li><li id="8da1" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">模板中引用的</li></ul><p id="14db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属于组件实例的。</p><p id="1327" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实例变量本身可以是原始值、对象、数组或函数。</p><p id="6fe0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">instance</code>函数创建并返回<code class="fe lc ld le lf b">ctx</code>对象。</p><p id="0e7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lc ld le lf b">&lt;script&gt;</code>标签中声明的函数将引用在<code class="fe lc ld le lf b">instance</code>函数闭包中作用域的实例变量:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="b7d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的REPL</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="4fc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当创建一个组件的新实例时，就会调用<code class="fe lc ld le lf b">instance</code>函数，并在新的闭包范围内创建和捕获<code class="fe lc ld le lf b">ctx</code>对象。</p><h2 id="0500" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">$$.肮脏的</h2><p id="36e7" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated"><code class="fe lc ld le lf b">$$.dirty</code>是一个对象，用于跟踪哪个实例变量刚刚发生了变化，需要更新到DOM上。</p><p id="f2c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在下面的细长组件中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="c2ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的REPL</p><p id="10a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初的<code class="fe lc ld le lf b">$$.dirty</code>是<code class="fe lc ld le lf b">null</code> ( <a class="ae lb" href="https://github.com/sveltejs/svelte/blob/v3.15.0/src/runtime/internal/Component.ts#L124" rel="noopener ugc nofollow" target="_blank">源代码</a>)。</p><p id="6516" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您点击了<strong class="kh ir">“+敏捷”</strong>按钮，<code class="fe lc ld le lf b">$$.dirty</code>将变成:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="4059" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您点击了<strong class="kh ir">“升级”</strong>按钮，<code class="fe lc ld le lf b">$$.dirty</code>将变成:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="51da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">$$.dirty</code>对Svelte很有用，这样就不会不必要地更新DOM。</p><p id="297c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你查看了编译代码的<strong class="kh ir"> p (u <em class="nk"> p </em> date) </strong>函数，你会看到在更新DOM之前，Svelte检查变量是否在<code class="fe lc ld le lf b">$$.dirty</code>中被标记。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="2351" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Svelte更新DOM之后，<code class="fe lc ld le lf b">$$.dirty</code>被设置回<code class="fe lc ld le lf b">null</code>以指示所有的更改都已经应用到DOM上。</p><h2 id="fbbe" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">$ $无效</h2><p id="714d" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated"><code class="fe lc ld le lf b">$$invalidate</code>是苗条身材反应性背后的秘密。</p><p id="02b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当变量被</p><p id="66a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Svelte将使用<code class="fe lc ld le lf b">$$invalidate</code>函数完成分配或更新:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="5cfb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">$$invalidate</code>功能将:</p><ol class=""><li id="5a8a" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nl nc nd ne bi translated">更新<code class="fe lc ld le lf b">$$.ctx</code>中的变量</li><li id="839a" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">在<code class="fe lc ld le lf b">$$.dirty</code>中标记变量</li><li id="e879" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">计划更新</li><li id="6008" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">返回赋值或更新表达式的值</li></ol><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="c8b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/sveltejs/svelte/blob/v3.15.0/src/runtime/internal/Component.ts#L130-L136" rel="noopener ugc nofollow" target="_blank">源代码</a></p><p id="8375" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于函数<code class="fe lc ld le lf b">$$invalidate</code>的一个有趣的注意事项是，它包装了赋值或更新表达式，并返回表达式计算的结果。</p><p id="a618" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得<code class="fe lc ld le lf b">$$invalidate</code>可链接:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="a93d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一条语句中有很多赋值或更新表达式时，这看起来很复杂！🙈</p><p id="4dd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">$$invalidate</code>的第二个参数是赋值或更新表达式。但是如果它包含任何赋值或更新子表达式，我们用<code class="fe lc ld le lf b">$$invalidate</code>递归地包装它。</p><p id="7c56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果赋值表达式改变了一个对象的属性，我们把这个对象作为<code class="fe lc ld le lf b">$$invalidate</code>函数的第三个参数传入，例如:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="15fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将变量<code class="fe lc ld le lf b">"obj"</code>更新为<code class="fe lc ld le lf b">obj</code>，而不是第二个参数<code class="fe lc ld le lf b">"hello"</code>的值。</p><h2 id="f793" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">计划_更新</h2><p id="ea22" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">调度Svelte用目前为止所做的更改来更新DOM。</p><p id="7a7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Svelte，在写的时候(<a class="ae lb" href="https://github.com/sveltejs/svelte/blob/v3.20.1/CHANGELOG.md#3201" rel="noopener ugc nofollow" target="_blank"> v3.20.1 </a>)用<a class="ae lb" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="noopener ugc nofollow" target="_blank">微任务队列</a>批量更改更新。实际的DOM更新发生在下一个微任务中，因此在同一个任务中发生的任何同步<code class="fe lc ld le lf b">$$invalidate</code>操作都会被批量处理到下一个DOM更新中。</p><p id="48ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了安排下一个微任务，Svelte使用了Promise回调。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="fcf5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lc ld le lf b">flush</code>中，我们为每个标记为脏的组件调用update:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="641c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/sveltejs/svelte/blob/v3.15.0/src/runtime/internal/scheduler.ts#L14" rel="noopener ugc nofollow" target="_blank">源代码</a></p><p id="1cc3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，如果你像这样写一个细长的组件:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="53eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的REPL</p><p id="c7c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">givenName</code>和<code class="fe lc ld le lf b">familyName</code>的DOM更新发生在同一个微任务中:</p><ol class=""><li id="dba6" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nl nc nd ne bi translated">点击<strong class="kh ir">“更新”</strong>调用<code class="fe lc ld le lf b">update</code>功能</li><li id="a2ab" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><code class="fe lc ld le lf b">$$invalidate('givenName', givenName = 'Li Hau')</code></li><li id="c119" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">将变量<code class="fe lc ld le lf b">givenName</code>标记为脏，<code class="fe lc ld le lf b">$$.dirty['givenName'] = true</code></li><li id="ad1f" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">安排一次更新，<code class="fe lc ld le lf b">schedule_update()</code></li><li id="f986" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">因为这是调用堆栈中的第一次更新，所以将<code class="fe lc ld le lf b">flush</code>函数推入微任务队列</li><li id="478d" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><code class="fe lc ld le lf b">$$invalidate('familyName', familyName = 'Tan')</code></li><li id="fc21" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">将变量<code class="fe lc ld le lf b">familyName</code>标记为脏，<code class="fe lc ld le lf b">$$.dirty['familyName'] = true</code></li><li id="1e41" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">安排一次更新，<code class="fe lc ld le lf b">schedule_update()</code></li><li id="5012" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">自<code class="fe lc ld le lf b">update_scheduled = true</code>以来，无所事事。</li><li id="cd60" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><strong class="kh ir"> —任务结束— </strong></li><li id="96fc" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><strong class="kh ir"> —微任务开始— </strong></li><li id="5b86" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><code class="fe lc ld le lf b">flush()</code>为每个标记为脏的组件调用<code class="fe lc ld le lf b">update()</code></li><li id="41c3" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">通话<code class="fe lc ld le lf b">$$.fragment.p($$.dirty, $$.ctx)</code>。</li></ol><ul class=""><li id="b399" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe lc ld le lf b">$$.dirty</code>现在是<code class="fe lc ld le lf b">{ givenName: true, familyName: true }</code></li><li id="c3f5" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lc ld le lf b">$$.ctx</code>现在是<code class="fe lc ld le lf b">{ givenName: 'Li Hau', familyName: 'Tan' }</code></li></ul><p id="ce79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">14.在<code class="fe lc ld le lf b">function p(dirty, ctx)</code>中，</p><ul class=""><li id="d29d" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">如果<code class="fe lc ld le lf b">$$.dirty['givenName'] === true</code>，则将第一个文本节点更新为<code class="fe lc ld le lf b">$$.ctx['givenName']</code></li><li id="c671" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">如果<code class="fe lc ld le lf b">$$.dirty['familyName'] === true</code>，则将第二个文本节点更新为<code class="fe lc ld le lf b">$$.ctx['familyName']</code></li></ul><p id="9dcd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">15.将<code class="fe lc ld le lf b">$$.dirty</code>重置为<code class="fe lc ld le lf b">null</code></p><p id="870e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">16. …</p><p id="faf5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">17。—微任务结束— </p><h2 id="102d" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">TL；博士；医生</h2><ul class=""><li id="42ca" class="mw mx iq kh b ki mf kl mg ko nm ks nn kw no la nb nc nd ne bi translated">对于每次赋值或更新，Svelte调用<code class="fe lc ld le lf b">$$invalidate</code>来更新<code class="fe lc ld le lf b">$$.ctx</code>中的变量，并在<code class="fe lc ld le lf b">$$.dirty</code>中将变量标记为dirty。</li><li id="e55d" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">实际的DOM更新被分批到下一个微任务队列中。</li><li id="3746" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">为了更新每个组件的DOM，组件<code class="fe lc ld le lf b">$$.fragment.p($$.diry, $$.ctx)</code>被调用。</li><li id="3797" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">在DOM更新之后，<code class="fe lc ld le lf b">$$.dirty</code>被重置为<code class="fe lc ld le lf b">null</code>。</li></ul><h1 id="fbab" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak"> v3.16.0 </strong></h1><p id="808c" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">v3.16.0中的一个大变化是PR <a class="ae lb" href="https://github.com/sveltejs/svelte/pull/3945" rel="noopener ugc nofollow" target="_blank"> #3945 </a>，即<strong class="kh ir">基于位掩码的变更跟踪</strong>。</p><p id="0b68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不使用对象将变量标记为脏:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="4642" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Svelte给每个变量分配一个索引:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="18a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并使用<a class="ae lb" href="https://en.wikipedia.org/wiki/Mask_(computing)" rel="noopener ugc nofollow" target="_blank">位掩码</a>来存储脏信息:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="4c2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比以前编译的代码要紧凑得多。</p><h2 id="f711" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">位掩码</h2><p id="d10e" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">对于不理解的人，请允许我快速解释一下它是什么。</p><p id="9ee0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果你想了解更多，可以随意阅读更详细的解释，像<a class="ae lb" href="https://blog.bitsrc.io/the-art-of-bitmasking-ec58ab1b4c03" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae lb" href="https://dev.to/somedood/bitmasks-a-very-esoteric-and-impractical-way-of-managing-booleans-1hlf" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="99f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表示一组<code class="fe lc ld le lf b">true</code>或<code class="fe lc ld le lf b">false</code>的最简洁的方式是使用位。如果该位是<code class="fe lc ld le lf b">1</code>，则为<code class="fe lc ld le lf b">true</code>，如果是<code class="fe lc ld le lf b">0</code>，则为<code class="fe lc ld le lf b">false</code>。</p><p id="5036" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个数可以用二进制表示，<strong class="kh ir"> 5 </strong>就是二进制的<code class="fe lc ld le lf b">0b0101</code>。</p><p id="8b0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<strong class="kh ir"> 5 </strong>用4位二进制表示，那么它可以存储4个布尔值，第0位和第2位为<code class="fe lc ld le lf b">true</code>，第1位和第3位为<code class="fe lc ld le lf b">false</code>(从右向左读取，从<a class="ae lb" href="https://en.wikipedia.org/wiki/Bit_numbering#Least_significant_bit" rel="noopener ugc nofollow" target="_blank">最低有效位</a>到<a class="ae lb" href="https://en.wikipedia.org/wiki/Bit_numbering#Most_significant_bit" rel="noopener ugc nofollow" target="_blank">最高有效位</a>)。</p><p id="9353" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">一个数可以存储多少个布尔值？</strong></p><p id="9976" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这取决于语言，Java中的16位整数可以存储16个布尔值。</p><p id="8104" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，数字可以用64位的<a class="ae lb" href="https://2ality.com/2012/04/number-encoding.html" rel="noopener ugc nofollow" target="_blank">来表示。但是，当对数字使用</a><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" rel="noopener ugc nofollow" target="_blank">位操作</a>时，JavaScript会将数字视为32位。</p><p id="2a04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查或修改存储在数字中的布尔值，我们使用<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" rel="noopener ugc nofollow" target="_blank">位操作</a>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="2e15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在按位运算中使用的第二个操作数就像是一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Mask_(computing)" rel="noopener ugc nofollow" target="_blank">掩码</a>，它允许我们锁定第一个数中的一个特定位，该位存储我们的布尔值。</p><p id="b19d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称这个掩码为<strong class="kh ir">位掩码</strong>。</p><h2 id="6595" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated"><strong class="ak">纤细的位掩码</strong></h2><p id="731e" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">如前所述，我们给每个变量分配一个索引:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="fa4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们现在不是将实例变量作为JavaScript对象返回，而是将其作为JavaScript数组返回:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="5133" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过<strong class="kh ir">索引</strong>、<code class="fe lc ld le lf b">$$.ctx[index]</code>而不是<strong class="kh ir">变量名</strong>访问变量:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="0f85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">$$invalidate</code>函数的工作原理相同，除了它接受的是<strong class="kh ir">索引</strong>而不是<strong class="kh ir">变量名</strong>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="9544" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">$$.dirty</code>现在存储一个数字列表。每个数字携带31个布尔值，每个布尔值指示该索引的变量是否脏。</p><p id="eb9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将变量设置为脏，我们使用按位运算:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="b0a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了验证一个变量是否脏，我们也使用了位运算！</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="98d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用位掩码，<code class="fe lc ld le lf b">$$.dirty</code>现在被重置为<code class="fe lc ld le lf b">[-1]</code>，而不是<code class="fe lc ld le lf b">null</code>。</p><p id="1fb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">花絮:</strong> <code class="fe lc ld le lf b">-1</code>是二进制的<code class="fe lc ld le lf b">0b1111_1111</code>，这里所有的位都是<code class="fe lc ld le lf b">1</code>。</p><h2 id="37d9" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">解构$$。肮脏的</h2><p id="e379" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">Svelte所做的一个代码大小优化是，如果变量少于32个，总是析构<strong class="kh ir"> u <em class="nk"> p </em> date函数</strong>中的<code class="fe lc ld le lf b">dirty</code>数组，因为我们无论如何都会访问<code class="fe lc ld le lf b">dirty[0]</code>:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><h2 id="d5bd" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated">TL；博士；医生</h2><ul class=""><li id="5a29" class="mw mx iq kh b ki mf kl mg ko nm ks nn kw no la nb nc nd ne bi translated"><code class="fe lc ld le lf b">$$invalidate</code>和<code class="fe lc ld le lf b">schedule_update</code>的基本机制不变</li><li id="f024" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">使用位掩码，编译后的代码更加紧凑</li></ul><h1 id="09b5" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">被动声明</h1><p id="ae1a" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">允许我们通过<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label" rel="noopener ugc nofollow" target="_blank">标签声明</a>、<code class="fe lc ld le lf b">$:</code>声明反应值</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="51eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的REPL</p><p id="08e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您查看编译后的输出，您会发现声明性语句出现在<code class="fe lc ld le lf b"><a class="ae lb" href="https://gist.github.com/compile-svelte-in-your-head-part-1/#instanceself-props-invalidate" rel="noopener ugc nofollow" target="_blank">instance</a></code> <a class="ae lb" href="https://gist.github.com/compile-svelte-in-your-head-part-1/#instanceself-props-invalidate" rel="noopener ugc nofollow" target="_blank">函数</a>中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="bd3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尝试对反应声明重新排序，并观察编译输出中的变化:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="8eb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的REPL</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="e39b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些观察结果:</p><ul class=""><li id="13c9" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">当有反应声明时，Svelte定义一个定制的<code class="fe lc ld le lf b">$$.update</code>方法。</li><li id="2386" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lc ld le lf b"><em class="nk">$$.update</em></code> <em class="nk">是</em> <a class="ae lb" href="https://en.wikipedia.org/wiki/NOP_(code)" rel="noopener ugc nofollow" target="_blank"> <em class="nk">的无运算功能</em> </a> <em class="nk">默认。(参见</em><a class="ae lb" href="https://github.com/sveltejs/svelte/blob/v3.20.1/src/runtime/internal/Component.ts#L111" rel="noopener ugc nofollow" target="_blank"><em class="nk">src/runtime/internal/component . ts</em></a><em class="nk">)</em></li><li id="c7ef" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">Svelte也使用<code class="fe lc ld le lf b">$$invalidate</code>来更新反应变量的值。</li><li id="148d" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">Svelte根据声明和语句之间的依赖关系对反应性声明和语句进行排序</li><li id="812a" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe lc ld le lf b">quadrupled</code>依赖<code class="fe lc ld le lf b">doubled</code>，所以<code class="fe lc ld le lf b">quadrupled</code>被求值<code class="fe lc ld le lf b">$$invalidate</code> d在<code class="fe lc ld le lf b">doubled</code>之后。</li></ul><p id="7502" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于所有的反应性声明和语句都归入了<code class="fe lc ld le lf b">$$.update</code>方法，而且事实上Svelte将根据它们的依赖关系对声明和语句进行排序，这与声明它们的位置和顺序无关。</p><p id="d65b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下组件仍然工作:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="4a8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://svelte.dev/repl/fc6995856489402d90291c4c30952939?version=3.20.1" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="0163" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">接下来你可能会问，</strong> <code class="fe lc ld le lf b"><strong class="kh ir">$$.update</strong></code> <strong class="kh ir">是什么时候被调用的？</strong></p><p id="59f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得在<code class="fe lc ld le lf b">flush</code>函数中被调用的<code class="fe lc ld le lf b">update</code>函数吗？</p><p id="7ec6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我放了个<code class="fe lc ld le lf b">NOTE:</code>评论说后面会很重要。现在这很重要。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="e1ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就在我们调用<code class="fe lc ld le lf b">$$.fragment.p()</code>更新DOM之前，<code class="fe lc ld le lf b">$$.update</code>函数在同一个微任务中被调用<strong class="kh ir">。</strong></p><p id="9f55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述事实的含义是</p><p id="09b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 1。所有反应性声明和语句的执行都是批处理的</strong></p><p id="7a1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如DOM更新是如何批处理的一样，反应式声明和语句也是批处理的！</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="9db7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://svelte.dev/repl/941195f1cd5248e9bd14613f9513ad1d?version=3.20.1" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="1846" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe lc ld le lf b">update()</code>被呼叫时，</p><ol class=""><li id="6a31" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nl nc nd ne bi translated">类似于上述流程，<code class="fe lc ld le lf b">$$invalidate</code>两者<strong class="kh ir">【给定名称】</strong>和<strong class="kh ir">【家庭名称】</strong>，并且安排更新</li><li id="aee9" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><strong class="kh ir"> —任务结束— </strong></li><li id="9876" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><strong class="kh ir"> —微任务开始— </strong></li><li id="3bd1" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated"><code class="fe lc ld le lf b">flush()</code>为每个标记为脏的组件调用<code class="fe lc ld le lf b">update()</code></li><li id="f04f" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nl nc nd ne bi translated">跑步<code class="fe lc ld le lf b">$$.update()</code></li></ol><ul class=""><li id="0d58" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated">由于<strong class="kh ir">【given name】</strong><strong class="kh ir">【family name】</strong>发生了变化，评估为<code class="fe lc ld le lf b">$$invalidate</code><strong class="kh ir">【name】</strong></li><li id="39f4" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated">随着<strong class="kh ir">【姓名】</strong>的改变，执行<code class="fe lc ld le lf b">console.log('name', name);</code></li></ul><p id="f4c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.调用<code class="fe lc ld le lf b">$$.fragment.p(...)</code>来更新DOM。</p><p id="9931" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，尽管我们已经更新了<code class="fe lc ld le lf b">givenName</code>和<code class="fe lc ld le lf b">familyName</code>，我们只计算<code class="fe lc ld le lf b">name</code>并执行<code class="fe lc ld le lf b">console.log('name', name)</code> <strong class="kh ir">一次</strong>而不是两次:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="3898" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2。反应声明和语句之外的反应变量值可能不是最新的</strong></p><p id="5164" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为反应性声明和语句是在下一个微任务中批处理和执行的，所以不能期望值被同步更新。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="24b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的REPL</p><p id="b810" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，你必须在另一个反应声明或语句中引用反应变量:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><h2 id="d458" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated"><strong class="ak">反应性声明和报表的排序</strong></h2><p id="646a" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">Svelte试图尽可能地保持反应性声明和陈述的顺序。</p><p id="eb04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果一个反应性声明或语句引用了由另一个反应性声明定义的变量，那么，<strong class="kh ir">将被插入后一个反应性声明</strong>之后:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><h2 id="9a04" class="mk lo iq bd lp ml mm dn lt mn mo dp lx ko mp mq lz ks mr ms mb kw mt mu md mv bi translated"><strong class="ak">不反应的反应变量</strong></h2><p id="95bb" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">苗条编译器跟踪所有在<code class="fe lc ld le lf b">&lt;script&gt;</code>标签中声明的变量。</p><p id="df49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个反应性声明或语句所引用的所有变量从未发生变异或重新分配，那么该反应性声明或语句将不会被添加到<code class="fe lc ld le lf b">$$.update</code>中。</p><p id="8e3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="9d31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的REPL</p><p id="acec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为，<code class="fe lc ld le lf b">count</code>永远不会变异或重新分配，Svelte通过不定义<code class="fe lc ld le lf b">$$self.$$.update</code>来优化编译后的输出。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="ac7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解更多，请在Twitter上关注我。</p><p id="7ad9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当下一部分准备好的时候，我会把它发布在Twitter上，在那里我会涵盖<a class="ae lb" href="https://svelte.dev/tutorial/if-blocks" rel="noopener ugc nofollow" target="_blank">逻辑块</a>、<a class="ae lb" href="https://svelte.dev/tutorial/slots" rel="noopener ugc nofollow" target="_blank">插槽</a>、<a class="ae lb" href="https://svelte.dev/tutorial/context-api" rel="noopener ugc nofollow" target="_blank">上下文</a>以及许多其他内容。</p><p id="78ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> ⬅ ⬅先前在</strong> <a class="ae lb" href="https://lihautan.com/compile-svelte-in-your-head-part-1/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">第一部</strong> </a> <strong class="kh ir">。</strong></p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="2f23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nk">最初发表于</em><a class="ae lb" href="https://lihautan.com/compile-svelte-in-your-head-part-2/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://lihautan.com</em></a></p></div></div>    
</body>
</html>