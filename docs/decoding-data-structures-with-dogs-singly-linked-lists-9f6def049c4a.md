# 用狗解码数据结构:单链表

> 原文：<https://javascript.plainenglish.io/decoding-data-structures-with-dogs-singly-linked-lists-9f6def049c4a?source=collection_archive---------10----------------------->

学习 JS 的所有细节可能会让人不知所措，尤其是当一个人开始处理数据结构时。在这个系列中，我将尝试分解一些基础知识，从单链表开始，用狗的图片来减轻我们的痛苦。

![](img/92fe448fcf664d43135ed95f3ccf932d.png)

In an array, elements are indexed based on their position.

作为程序员新手，我们学习使用的第一个数据结构是数组。概括地说，数组是一个项的列表，这些项根据它们在数组中的位置被赋予一个索引或一个数值。想象一个像楼梯一样的阵列，每个台阶上都有一个可爱的木偶。每一步都有一个值，我们可以通过计算他们所处的步骤来找到他们。第一只小狗在底部，还不是一个台阶，所以我们给它的值或索引为 0，下一只小狗在第一个台阶上，所以它的索引为 1。

**链表**有点不同。不是每个 pup(或节点，而不是元素)都有一个索引，而是每个节点都指向下一个节点。把它想象成一列火车，每节车厢与下一节车厢相连，下一节车厢又与下一节车厢相连，以此类推。在数组中，我们可以说“给我第六个 pup”，但是在链表中，我们必须从火车的开头开始，从第一节车厢到第二节车厢，等等。

![](img/d27651eee00c74e2f78483dbe60f8011.png)

In a linked list, each node is connected to the next, like a train!

链表中的每个节点都有一个值，以及一个指向另一个节点的指针，否则如果它在列表的末尾就指向 null。

链表有 3 个属性:

*   *头-* 名单的开始
*   *尾-* 列表结束
*   *长度* -头部和尾部之间的长度

![](img/099e84cdafea91ec46da108c8bc222e4.png)

We can’t pet one pup without petting all the pups!

那么为什么要使用链表而不是数组呢？数组元素似乎比列表节点更容易访问，对吗？因为数组是索引的，所以插入和删除在内存方面会非常昂贵。数组支持直接访问，这意味着所有的元素都存储在一个连续的内存块中，这使得我们可以很容易地获取我们想要的任何随机元素，但会占用更多的内存。如果我们想向数组中添加一个元素，数组中的所有其他元素都必须被重新索引，根据数组周围的内存大小，整个数组可能都必须在内存中重新定位。

![](img/422d8f4c771f8d2fa3e3e9eb7c0e2849.png)

All elements in an array are stored in a continuous block of memory.

链表支持顺序访问，这意味着节点可以存储在内存中的任何地方，但是没有索引，只有指向下一个节点的指针。这意味着在链表中添加和删除节点的速度要比数组快得多，并且分配给链表其余部分的内存不需要重新定位，只要内存中有空间，就可以创建新的节点。

![](img/7db9b63c22a0cf76995d5e9dd2084ddb.png)

Nodes can be stored anywhere in memory, and are connected together by pointers.

**单链表** **的设置和设计相当简单。**我们将使用 Javascript 类来演示这一点，所以如果你不熟悉 JS 类，请查看这里的文档。链表最重要的部分是节点的构造方式:每个节点都需要某种类型的数据，以及指向下一个节点的指针。我们将从创建一个节点类开始，如下所示:

data 属性包含我们希望列表存储的任何内容，next 属性是我们将用来访问列表中下一个节点的内容。我们最初将 next 设置为 null，因为我们还不知道下一个节点是什么。

我们将链表中的第一个节点称为 head，因此我们创建了`head`变量来表示第一个节点。然后，我们能够通过使用下一个指针来创建后续节点，以指示它们是下一个链接。列表中的最后一个`next`指针仍然是`null`。

我们设置链表的下一步是创建一个 linked list 类，这样我们就可以稍微清理一下，这样我们就不必在每次想要向链表添加新节点时都添加`next`指针。让我们从定义类和添加构造函数开始。记住，单链表总是接受几个东西:头部、尾部和长度。所以我们可以添加这些作为我们的属性。我们将头部和尾部都设置为`null`来开始，因为我们还没有传入任何东西，并且还将长度设置为 0。现在我们的构造函数完成了，我们可以传入一堆方法，实际上开始利用我们的单链表！

我们的`push`函数需要完成以下工作:

*   接受一个值作为参数
*   用所述值创建一个新节点
*   如果还没有 head 属性，则将该值指定为 head 和 tail，
*   否则，将当前尾部的下一个属性设置为新节点
*   将新节点设置为新尾部
*   将长度增加 1
*   归还名单

我们首先将我们的`new Node`赋给一个变量，在这种情况下我称之为`newNode.`，然后我们检查是否没有头部，如果没有，那么将头部和尾部都赋给`newNode.`，否则，如果有头部，那么将尾部赋给`newNode.`，然后我们增加长度，并返回列表。

现在，当我们向我们的 push 方法发送一个值时，我们得到了相同的结果，并且不必跟踪我们有多少个`next`指针。此 SinglyLinkedList 类创建以下数据结构:

![](img/fff5d2a70e9a0e31f33aa63e11bfa4eb.png)

作为开发人员，数据结构可能会让我们难以理解，但是分解它们(用狗)至少会有一点帮助！

## 简单英语的 JavaScript

喜欢这篇文章吗？如果有，通过 [**订阅获取更多类似内容解码，我们的 YouTube 频道**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw) **！**