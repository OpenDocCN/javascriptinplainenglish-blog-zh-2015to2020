<html>
<head>
<title>Client-Side Rendering a React App with Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express.js在客户端呈现React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/back-to-basics-client-side-rendering-a-react-app-using-express-js-c828e3664b88?source=collection_archive---------4-----------------------#2020-10-30">https://javascript.plainenglish.io/back-to-basics-client-side-rendering-a-react-app-using-express-js-c828e3664b88?source=collection_archive---------4-----------------------#2020-10-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="07d0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何通过实现客户端渲染解决方案来使用Express.js服务React应用程序</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/858bcabb38accd6ed51bff1832ec4bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JkjfltOfBXUv1PlR"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@k8townsend?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kate Townsend</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4c61" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您已经设置并创建了react应用程序(使用create-react-app、其他样板文件，甚至从头开始创建)。现在你试图把它发布到网上，让全世界都能看到你的成果。当然，为了便于部署和最小化设置，您可以使用已经建立的平台，如Netlify、Heroku、Firebase Hosting、Github Pages或许多其他平台。然而，这篇文章不是关于这个的。这篇文章是关于使用good ol' Express.js设置你自己的服务器和部署你的站点/应用的。</p><p id="e146" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可能会问，为什么？当然是为了学习。了解服务器如何交付你的应用/站点对你的编程基础是有益的。它还可以帮助您将来部署(和配置)您的站点。</p><p id="8874" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我将重点介绍在使用Express.js部署react应用程序时客户端渲染是如何工作的。为了更好地理解，您还应该检查一下服务器端渲染是如何工作的，作为比较。这样，您将对每种方法的工作原理有一个更清晰的理解，并获得客户端和服务器端渲染解决方案的整体视图。我写过一篇关于服务器端渲染的文章。所以，看看这个:</p><div class="lp lq gp gr lr ls"><a href="https://medium.com/javascript-in-plain-english/back-to-basics-server-side-rendering-a-react-app-using-express-js-6fab99db5770" rel="noopener follow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">使用Express.js在服务器端呈现React应用程序</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">如何通过服务器端渲染使用Express.js为React应用提供服务</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">medium.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg km ls"/></div></div></a></div><p id="91e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，您应该清楚地了解什么是客户端渲染，以及如何使用Express.js应用客户端渲染解决方案。除此之外，您还应该清楚地了解服务器如何工作，以及站点/应用程序如何部署到服务器。</p><h1 id="7812" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">该项目</h1><p id="73a8" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">如果你已经有一个react应用，你可以使用现有的react应用，或者你可以使用create-react-app创建一个新的应用，并保留<code class="fe ne nf ng nh b">src</code>目录中的主要代码(因为我们关注的是后端)。你也可以尝试从头开始创建一个react应用程序，这可以增强你对react应用程序内部的点点滴滴的理解。</p><p id="2c3e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要了解react应用程序是如何从头开始构建的，您可以点击下面的链接，阅读我之前的文章:</p><div class="lp lq gp gr lr ls"><a href="https://medium.com/swlh/back-to-basics-how-to-set-up-a-react-app-from-scratch-2020-134908e17490" rel="noopener follow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">回归基础:如何从零开始设置React应用程序2020</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">使用最新的Webpack和Babel从空目录构建React应用程序。</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">medium.com</p></div></div><div class="mb l"><div class="ni l md me mf mb mg km ls"/></div></div></a></div><p id="dbb6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将使用上面文章中从头开始创建react应用程序的代码。请注意，通过“从头开始反应应用程序”的例子，您将理解公共文件夹中的JavaScript文件是如何产生的(这对于理解本文末尾解释的客户端呈现非常重要)。您的项目目录至少应包含以下文件夹结构和文件:</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="08b6" class="nn mi in nh b gy no np l nq nr">react-app/<br/>|--public/<br/>|  |--index.html<br/>|  |--bundle.js<br/>|--src/<br/>|  |--app.js<br/>|--babel.config.js<br/>|--package-lock.json<br/>|--package.json<br/>|--webpack.config.js</span></pre><p id="6ca7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将假设您已经对JavaScript、Node.js和React有了基本的了解。如果没有，对于基本设置(比如Node和React)，我推荐你按照上面的链接从头开始做一个react-app。</p><h1 id="2623" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">快递. js</h1><p id="92f9" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">Express.js将自己标榜为“快速、非个人化、极简主义的网络框架”。如果您正在为项目构建后端，Express是一个必不可少的JavaScript框架。到目前为止，如果JavaScript用于服务器端语言，您应该不会感到惊讶。</p><p id="0785" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要安装Express.js，请运行以下命令:</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="ca30" class="nn mi in nh b gy no np l nq nr">npm install express</span></pre><p id="18e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">安装Express后，在项目的根目录下创建一个名为<code class="fe ne nf ng nh b">server</code>的新目录。</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="b25e" class="nn mi in nh b gy no np l nq nr">mkdir server</span></pre><p id="a580" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个目录是我们将设置Express后端的地方。到目前为止，你至少应该在根目录下有三个目录(如果你是从“从头开始创建react应用”这篇文章开始的)，分别叫做<code class="fe ne nf ng nh b">public</code>、<code class="fe ne nf ng nh b">src</code>和<code class="fe ne nf ng nh b">server</code>。</p><p id="c182" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe ne nf ng nh b">server</code>目录下，创建一个名为<code class="fe ne nf ng nh b">index.js</code>的文件:</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="2667" class="nn mi in nh b gy no np l nq nr">touch server/index.js</span></pre><p id="702d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您的服务器目录现在应该如下所示:</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="3ace" class="nn mi in nh b gy no np l nq nr">react-app<br/>|-server<br/>|  |-index.js<br/>|...</span></pre><p id="b792" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe ne nf ng nh b">server/index.js</code>中，添加以下代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/63e80e02dc122e7987d7be4697d426fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Wwhdsk2H7d89V258TgRIw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">server/index.js</figcaption></figure><ol class=""><li id="a59b" class="nt nu in kv b kw kx kz la lc nv lg nw lk nx lo ny nz oa ob bi translated">我们需要express模块并调用顶部的express函数，<code class="fe ne nf ng nh b">express()</code>。我们还设置了所需的端口号，在本例中是3000。</li><li id="e07f" class="nt nu in kv b kw oc kz od lc oe lg of lk og lo ny nz oa ob bi translated">我们指示express启动服务器并监听我们设置的端口。控制台将输出“服务器正在监听http://localhost:3000。</li></ol><p id="eb6d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要启动服务器，请在项目目录的根目录下的终端中输入以下命令:</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="d647" class="nn mi in nh b gy no np l nq nr">node server/index.js</span></pre><p id="1d7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们打开<a class="ae ks" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>时，浏览器中不会显示任何内容。反而只会出现一个错误信息“无法获取/”。这是因为我们还没有在Express中指定任何路线，尤其是要从“/”(home)路线传递的内容。我们只需要express模块，并指示express启动服务器并监听<code class="fe ne nf ng nh b">server/index.js</code>中的端口3000。</p><h1 id="94ee" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">Nodemon</h1><p id="6811" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">在我们对<code class="fe ne nf ng nh b">server/index.js</code>进行任何修改以提供react内容之前，让我们将Nodemon合并到我们的应用程序中。Nodemon是一个开发基于节点的应用程序的工具，当检测到目录中的文件改变时，它帮助自动重启所述应用程序。这样，我们就不必在每次想要查看我们所做的更改是如何发生的时候，手动取消并重启我们的express服务器。</p><p id="b959" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过键入以下命令全局安装Nodemon(推荐):</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="5040" class="nn mi in nh b gy no np l nq nr">npm install -g nodemon</span></pre><p id="e4b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，您可以在机器中的其他项目上使用Nodemon，因为它是全局安装在您的机器中的。</p><p id="bae2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们使用<code class="fe ne nf ng nh b">nodemon</code>而不是使用<code class="fe ne nf ng nh b">node</code>命令来启动我们的express服务器:</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="8d74" class="nn mi in nh b gy no np l nq nr">nodemon server/index.js</span></pre><p id="1079" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">像<code class="fe ne nf ng nh b">node</code>指令一样，该命令将启动我们的express服务器。然而，这一次，无论何时在我们的<code class="fe ne nf ng nh b">server/index.js</code>中进行任何更改并保存，我们的服务器将自动重启以使这些更改生效。</p><p id="98cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更好的是，让我们在<code class="fe ne nf ng nh b">package.json</code>中添加一个名为<code class="fe ne nf ng nh b">serve</code>的npm脚本，用于使用nodemon启动我们的express服务器:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/745050498ddf09372e16b3f683246fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOBDByoOR_e4Xn8xlq9apA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">package.json</figcaption></figure><p id="bb4c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，要启动服务器，我们可以从项目终端的根目录调用以下命令:</p><pre class="kd ke kf kg gt nj nh nk nl aw nm bi"><span id="b6de" class="nn mi in nh b gy no np l nq nr">npm run serve</span></pre><h1 id="fc13" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">快递()。静电</h1><p id="624e" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">为了服务我们的react应用程序，我们将使用Express.js的内置<code class="fe ne nf ng nh b">express().static</code>中间件。Express.js应用程序基本上是一系列中间件和路由功能。中间件函数告诉Express.js如何处理传入的请求。是转换请求数据、发回响应，还是将其传递给下一个中间件。中间件指示express提供来自指定目录的静态文件。</p><p id="69da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们的<code class="fe ne nf ng nh b">server/index.js</code>中，添加以下代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/127a945d6e999f56a30d3cff903b4933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vh0ikib1h7Snq5dJqQddww.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">server/index.js</figcaption></figure><p id="f9be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3.我们使用Node的path模块来获取到我们的<code class="fe ne nf ng nh b">public</code>目录的路径，我们绑定的react应用程序(在一个名为<code class="fe ne nf ng nh b">bundle.js</code>的JavaScript文件中)和它对应的html ( <code class="fe ne nf ng nh b">index.html</code>)就位于这个目录中。使用<code class="fe ne nf ng nh b">public</code>目录路径，我们指示express静态地服务于所述目录中的文件。</p><p id="fb9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，当我们再次转到localhost时，我们的react应用程序内容应该可以成功地在主路由('/')中提供:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/7684351355784205117006a2dbfffaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk9xhXjHEk5Fwb_QSQAJeQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">react-app served through localhost</figcaption></figure><p id="7a16" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">瞧啊。我们已经通过Express.js后端成功提供了react-app。当指向home ('/')路径时，express将在公共目录中搜索并提供它找到的第一个<code class="fe ne nf ng nh b">index.html</code>(包括该html中所有必需的文件，如JavaScript和css)。</p><p id="ada6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一个问题出现了，如果用户输入不同路线(如<code class="fe ne nf ng nh b">/home</code>、<code class="fe ne nf ng nh b">/about</code>、<code class="fe ne nf ng nh b">/sdfsadfs</code>等)会怎样。)不是专门设置在我们后端的？用户可能会收到错误“无法获取”。</p><p id="32b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了解决这个问题，我们应该指示Express将所有传入请求重定向到home ('/')路由。我们通过在我们的<code class="fe ne nf ng nh b">server/index.js</code>文件中添加更多的代码来做到这一点:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ok"><img src="../Images/fe712694e557a1a2f3cadd053d69996f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njhC6IPk65yH8yEfhKrLCQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">server/index.js</figcaption></figure><p id="0965" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4.我们添加了另一个中间件，它指示Express将除了本地路由('/')之外的任何路由重定向回本地路由('/')。这样，用户将无法输入任何随机路线，并得到一个“不能得到”的错误。</p><p id="c04a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，每次用户访问我们的网站时，我们的后端会自动将传入的请求路由到“/”(home)路由。</p><h1 id="89bf" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">客户端渲染</h1><p id="baaa" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">我们已经成功地使用express.js后端服务了react应用程序。在这个项目中，我们的react应用程序是通过客户端呈现的(因此得名“客户端呈现”)。当请求到达本地路由时，我们指示<code class="fe ne nf ng nh b">express().static</code>发送回<code class="fe ne nf ng nh b">index.html</code>文件以及html文件所需的JavaScript和css文件。我们的<code class="fe ne nf ng nh b">index.html</code>文件只包含一个空的<code class="fe ne nf ng nh b">div</code>元素，在body标签中有id‘root’。页面UI的实际呈现是由JavaScript文件<code class="fe ne nf ng nh b">bundle.js</code>完成的，我们所有的react代码都驻留在这个文件中。这就是为什么它被称为“客户端渲染”，在JavaScript文件被成功发送到客户端浏览器并由客户端浏览器下载之后，UI渲染过程由客户端浏览器在客户端完成。这是“服务器端渲染”的反义词(另一篇文章中有更多相关内容，敬请关注！).</p><p id="95c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">客户端渲染有其优点和缺点。客户端渲染最大的优势是它丰富且易于交互。在初始加载之后，UI交互应该非常灵敏，因为所有需要的JavaScript代码都已经在初始加载时下载好了。当然，缺点是初始负载本身。随着应用程序变得越来越丰富和复杂，浏览器在初始加载时需要下载的文件越来越大。这可能对用户体验不利。</p><p id="e220" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，最大的缺点是与搜索引擎优化(SEO)有关。因为我们应用程序的所有内容都是从服务器发送的JavaScript文件中提供给客户端的，所以它可能会阻止网络爬虫抓取我们应用程序的内容。因此，谷歌搜索结果将受到冲击。</p><h1 id="c806" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">摘要</h1><p id="84cf" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">在本文中，我们已经使用Express.js后端成功地提供了一个react应用程序(从头开始构建)。在下载了所有需要的JavaScript(和css)文件之后，通过客户端浏览器的客户端呈现来呈现UI。</p></div></div>    
</body>
</html>