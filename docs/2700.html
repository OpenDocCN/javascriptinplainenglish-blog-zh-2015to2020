<html>
<head>
<title>How to add React Router to your React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将React路由器添加到React应用程序中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-react-router-to-your-react-app-bf764a776122?source=collection_archive---------0-----------------------#2020-07-16">https://javascript.plainenglish.io/how-to-add-react-router-to-your-react-app-bf764a776122?source=collection_archive---------0-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4569" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React应用程序中的实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d72afef54c9d3848f50c697983c532ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ngqSFJgQ1fkpW_1Y"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image from <a class="ae kv" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank">https://github.com/ReactTraining/react-router</a></figcaption></figure><p id="f8a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React-router是一个可以在React应用程序之上实现的工具。React本身并不支配任何路由。路由可以将应用程序与URL以及浏览器提供的导航功能(如地址栏和导航按钮)同步，从而增强React应用程序的功能。React router提供了一种编写代码的方法，这样，只有当路由与定义的内容匹配时，才会呈现特定的组件。</p><p id="1f4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本指南中，我们将介绍如何在react应用程序中实现react-router。</p><h1 id="3365" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">服务器端与客户端路由</h1><p id="43d9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们开始实现react-router之前，让我们讨论一下服务器端和客户端路由的区别。服务器端是更传统的方法，我们在服务器上定义路由。客户端是更现代的方法，我们使用客户端Javascript来动态改变屏幕上显示的内容。通过客户端路由，我们可以处理应用程序的呈现。</p><p id="c40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器端的流程是客户端向服务器发出请求，服务器用要呈现的HTML进行响应。客户端的过程包括观察URL的变化，并基于这些变化，为路径呈现特定的组件。</p><p id="723a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在客户端，当用户点击不同的页面或基于某个动作被重定向时，这将由客户端Javascript处理，这意味着我们不需要在服务器上往返以重新进入页面。相反，我们使用浏览器提供的HTML历史API，它允许我们观察URL的变化，并在发生变化时运行一些Javascript代码。</p><p id="7459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">借助react-router，我们能够使用客户端Javascript动态呈现应用程序，这将允许我们创建一个单页面应用程序，我们可以在其中切换组件来模拟“页面更改”</p><h1 id="e405" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">入门指南</h1><p id="b3da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要开始实现react-router，您需要有一个react应用程序。如果您需要创建一个，您可以使用以下命令来生成一个并更改到生成的目录中:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b94a" class="mu lt iq mq b gy mv mw l mx my">npx create-react-app &lt;app_name&gt;<br/>cd &lt;app_name&gt;</span></pre><p id="cf51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React-router有三个包:<code class="fe mz na nb mq b">react-router</code>、<code class="fe mz na nb mq b">react-router-dom</code>、<code class="fe mz na nb mq b">react-router-native</code>。<code class="fe mz na nb mq b">React-router</code>几乎不需要安装，而<code class="fe mz na nb mq b">react-router-dom</code>是特定于浏览器的，而<code class="fe mz na nb mq b">react-router-native</code>是特定于本地反应的。我们将关注网站，因此需要安装<code class="fe mz na nb mq b">react-router-dom</code>,使用:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a59c" class="mu lt iq mq b gy mv mw l mx my">npm install react-router-dom</span></pre><h1 id="4111" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现反应路由器</h1><p id="9d7e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设你已经用<code class="fe mz na nb mq b">npx create-react-app</code>生成了一个React应用，打开<code class="fe mz na nb mq b">index.js</code>，可以在<code class="fe mz na nb mq b">/src/index.js</code>下找到。在文件的顶部，我们将从<code class="fe mz na nb mq b">react-router-dom</code>包中导入一个命名的导出，<code class="fe mz na nb mq b">BrowserRouter</code>。我们希望用<code class="fe mz na nb mq b">BrowserRouter</code>包装整个React应用程序，即<code class="fe mz na nb mq b">App</code>组件。我们在<code class="fe mz na nb mq b">index.js</code>中的文件结构应该看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">index.js</figcaption></figure><p id="de9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的整个应用程序都用<code class="fe mz na nb mq b">BrowserRouter</code>包装起来了，我们可以启用客户端路由了。让我们打开<code class="fe mz na nb mq b">App.js</code>，它也可以在<code class="fe mz na nb mq b">/src/App.js</code>下找到。这将是一个文件，我们在其中定义路线和应该呈现什么组件。让我们从<code class="fe mz na nb mq b">react-router-dom</code>导入命名的导出<code class="fe mz na nb mq b">Route</code>，它将用于每条路径。让我们也导入每个路径所需的组件。</p><h2 id="16bf" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">转换</h2><p id="923a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们需要从<code class="fe mz na nb mq b">react-router-dom</code>、<code class="fe mz na nb mq b">Switch</code>再导入一个指定的导出。它不需要任何道具。<code class="fe mz na nb mq b">Switch</code>将按顺序遍历每个<code class="fe mz na nb mq b">Route</code>，一旦找到匹配的路径，它将呈现相关的组件。在<code class="fe mz na nb mq b">return</code>语句中，在<code class="fe mz na nb mq b">div</code>容器中，我们将包含<code class="fe mz na nb mq b">Switch</code>并在其中定义路线。</p><h2 id="2bcb" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">途径</h2><p id="8c59" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个<code class="fe mz na nb mq b">Route</code>一般用两个道具来定义，<code class="fe mz na nb mq b">path</code>和<code class="fe mz na nb mq b">component</code>。<code class="fe mz na nb mq b">path</code>表示我们正在监听的URL路由，而<code class="fe mz na nb mq b">component</code>将接收将在该路径上呈现的组件。如果某条路线的<code class="fe mz na nb mq b">path</code>仅设置为<code class="fe mz na nb mq b">"/"</code>，那么<code class="fe mz na nb mq b">Switch</code>将始终为所有路径渲染该路线，因为它是匹配的。例如，如果我们所在的路径是<code class="fe mz na nb mq b">/sample</code>，那么该路径确实包含一个<code class="fe mz na nb mq b">/</code>。只要包含该字符，就会被认为是匹配的，<strong class="ky ir">包含嵌套路线的</strong>有哪些。</p><p id="6b2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了防止这种情况，我们为该路线添加了另一个道具，<code class="fe mz na nb mq b">exact</code>。顾名思义，路径必须完全相同。如果一个<code class="fe mz na nb mq b">Route</code>没有提供<code class="fe mz na nb mq b">path</code>道具，它将在没有匹配时被渲染。这对于处理未在路径中定义但以某种方式被访问的路径非常理想。</p><h2 id="0ebc" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">渲染道具</h2><p id="6d58" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">然而，对于<code class="fe mz na nb mq b">Route</code>的<code class="fe mz na nb mq b">component</code>道具，如果我们需要的话，我们无法将道具传递给实际的组件。如果一个组件确实需要传递给它的道具，我们将使用<code class="fe mz na nb mq b">render</code>道具。我们没有传递组件，而是传递一个在位置匹配时调用的函数。</p><p id="a452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数接收原始路由器属性作为参数，使它们可用于您的渲染组件。我们可以利用spread运算符来复制路由器属性的内容。而常规道具可以像法线一样传递给组件。</p><h2 id="3061" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">再直接的</h2><p id="6be4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">关于<code class="fe mz na nb mq b">render</code>这个话题，我们也可以利用<code class="fe mz na nb mq b">react-router-dom</code>、<code class="fe mz na nb mq b">Redirect</code>的另一个资源。渲染一个<code class="fe mz na nb mq b">Redirect</code>会导航到一个新的位置。新位置将覆盖历史堆栈中的当前位置。<code class="fe mz na nb mq b">Redirect</code>需要一个属性<code class="fe mz na nb mq b">to</code>，它可以是要重定向到的URL的字符串。</p><p id="923f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是目前为止我们的<code class="fe mz na nb mq b">App.js</code>应该看起来的样子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App.js</figcaption></figure><p id="2f47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">访问每个定义的路径应该呈现适当的组件。否则，它将默认为没有路径的<code class="fe mz na nb mq b">Route</code>,并呈现相关组件。目前，我们已经实现了客户端路由。然而，react-router附带了一些工具，允许我们与路由进行交互。</p><h1 id="2572" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">路线之间的链接</h1><p id="4c23" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">目前，我们正在通过直接在URL上键入来更改路线。通常，<code class="fe mz na nb mq b">a</code> HTML标签处理允许我们点击改变URL的功能。然而，点击一个<code class="fe mz na nb mq b">a</code>标签会触发一个对服务器端的请求。相反，我们将利用来自react-router<code class="fe mz na nb mq b">Link</code>的资源。</p><h2 id="6b46" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">环</h2><p id="43e6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在<code class="fe mz na nb mq b">App.js</code>中，让我们从<code class="fe mz na nb mq b">react-router-dom</code>导入资源<code class="fe mz na nb mq b">Link</code>。在幕后，<code class="fe mz na nb mq b">Link</code>是一个<code class="fe mz na nb mq b">a</code> HTML标签，但是Javascript覆盖了浏览器的默认行为。<code class="fe mz na nb mq b">Link</code>期望里面的文本以及一个属性<code class="fe mz na nb mq b">to</code>，通知它点击时重定向到哪里。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7b91" class="mu lt iq mq b gy mv mw l mx my">&lt;Link to="/sample"&gt;Click to get redirected&lt;/Link&gt;</span></pre><p id="4ea4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击<code class="fe mz na nb mq b">Link</code>后，不需要刷新整个页面。相反，Javascript会动态交换组件，并进行新的调用来做出反应和重新呈现。</p><h2 id="1c6f" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">Navlink</h2><p id="cf00" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个<code class="fe mz na nb mq b">Link</code>的替代品是<code class="fe mz na nb mq b">NavLink</code>，另一个来自<code class="fe mz na nb mq b">react-router-dom</code>的资源。使用<code class="fe mz na nb mq b">NavLink</code>，我们可以附加一个道具<code class="fe mz na nb mq b">activeClassName</code>，它允许我们提供一个类名。只有当我们在<code class="fe mz na nb mq b">to</code>道具上定义的路线上时，它才适用于链接。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="90c7" class="mu lt iq mq b gy mv mw l mx my">&lt;NavLink to="/sample" activeClassName="active"&gt;Click to get redirected&lt;/Link&gt;</span></pre><p id="2660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两者都是<code class="fe mz na nb mq b">Link</code>和<code class="fe mz na nb mq b">NavLink</code>一模一样。一个对CSS样式更有利，但是选择一个不会错。我们有能力使用链接来改变URL路由。让我们对<code class="fe mz na nb mq b">App.js</code>进行修改以反映这些变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App.js with NavLink (also works with Link)</figcaption></figure><p id="7e40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，期望在每条路线上看到的元素或组件必须在<code class="fe mz na nb mq b">Switch</code>之外定义，比如<code class="fe mz na nb mq b">Header</code>或<code class="fe mz na nb mq b">Footer</code>组件。</p><h1 id="db47" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">查询字符串和URL参数</h1><p id="5f27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">提醒一下，在<code class="fe mz na nb mq b">Route</code>中，一旦一个路径被匹配，它就会呈现相关组件的一个实例。不仅组件被渲染，来自<code class="fe mz na nb mq b">react-router </code>的<code class="fe mz na nb mq b">props</code>也被传递给这些组件。在被渲染的组件的文件中，我们可以<code class="fe mz na nb mq b">console.log(props)</code>确定到底提供了什么。在我的例子中，我会把它放在<code class="fe mz na nb mq b">src/components/Sample.js</code>中定义的函数/类中。</p><p id="bb4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看这些道具:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4476d75e9a616d67a9309e33e907ef4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*tQyE8OU-N3zHMDw2kKtMMQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Props provided passed down from Route</figcaption></figure><h2 id="f8bc" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">历史</h2><p id="5e94" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们正在接收三个键值对。先从<code class="fe mz na nb mq b">history</code>说起吧。它的值是一个包含允许我们操作历史的方法的对象。它还允许我们通过Javascript以编程方式重定向用户。例如，使用方法<code class="fe mz na nb mq b">props.history.push("/another_route")</code>来改变路线。</p><h2 id="5f48" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">比赛</h2><p id="c1c4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于<code class="fe mz na nb mq b">match</code>，它的值是一个包含关于<code class="fe mz na nb mq b">params</code>对象的有用信息的对象。它包含为什么当前路由被视为匹配的信息。</p><h2 id="cc91" class="mu lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">位置</h2><p id="647e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">而<code class="fe mz na nb mq b">location</code>有一个包含当前URL信息的值，组织散列值如<code class="fe mz na nb mq b">/#contact-us</code>和查询字符串如<code class="fe mz na nb mq b">?query=hello</code>。</p><p id="573f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拥有这样的信息对我们的React应用程序有什么好处呢？在设置<code class="fe mz na nb mq b">Route</code>时，动态路由也是可能的。例如，我们可以有一个<code class="fe mz na nb mq b">Route</code>,</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3f4a" class="mu lt iq mq b gy mv mw l mx my">&lt;Route path="/photos/:id" component={SpecificPhotoComponent}/&gt;<!-- --> </span></pre><p id="702c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自URL的<code class="fe mz na nb mq b">id</code>可以用来从组件的状态中提取特定的信息。这可能是我们需要的另一种储存信息的方式。</p><h1 id="e9c9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结束语</h1><p id="0e9c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">React-router是一个强大的工具，可以增强任何React应用程序。它可以帮助组织基于路线呈现哪些组件。本指南涵盖了由<code class="fe mz na nb mq b">react-router-dom</code>提供的精选资源及其实施。如需更深入的信息，请参考<a class="ae kv" href="https://reactrouter.com/web/api/Link" rel="noopener ugc nofollow" target="_blank"> react-router文档</a>和我的代码示例，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Code Sandbox React-Router Practice</figcaption></figure><p id="1f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>