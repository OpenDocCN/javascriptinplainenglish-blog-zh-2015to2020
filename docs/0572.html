<html>
<head>
<title>Web Components Crash Course (Templates)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件速成班(模板)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-components-crash-course-b0a2feb11be1?source=collection_archive---------6-----------------------#2019-11-10">https://javascript.plainenglish.io/web-components-crash-course-b0a2feb11be1?source=collection_archive---------6-----------------------#2019-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8c4c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:模板</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8fd492b1726e8185071cedb29b6b3b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huON82ngbYi-v_BeSLLNeg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ryoji__iwata?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ryoji Iwata</a> on <a class="ae kv" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="585c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="9f17" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/web-components-crash-course-7c0df961a8b7?source=friends_link&amp;sk=918d3ee449edf0c3c626c6dccf9a5867" rel="noopener">这个三部分系列的第1部分介绍了定制元素</a>。特别是，我们如何处理属性，以及如何/何时利用元素生命周期的不同阶段。</p><p id="d94d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本帖中，我们将关注<strong class="lq ir">模板</strong>，它们是如何工作的，如何最大限度地利用它们，一些陷阱以及我们使用模板的不同方式。最后，我们将使用自定义元素和模板知识创建一个迷你模板查看器应用程序。</p><p id="d04d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mp">你可以通过从</em> <a class="ae kv" href="https://github.com/Haseeb90/web-components-crash-course" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mp">这里</em> </strong> </a> <em class="mp">克隆Git库来跟随本文中的代码示例。克隆存储库后，运行</em> <code class="fe mq mr ms mt b">npm install</code> <em class="mp">来设置项目。一旦一切都设置好了，切换到起始模板分支</em></p><p id="f5a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mq mr ms mt b">git checkout starting-templates</code></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="f0c6" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">预模板</h1><p id="22d6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我们开始讨论什么是模板以及如何使用模板之前，让我们先来看看在第1部分中向DOM呈现元素的几种方法。</p><h2 id="9e25" class="ng kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">createElement API</h2><p id="3207" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">以编程方式创建DOM节点有许多不同的技术。其中之一就是使用<code class="fe mq mr ms mt b">document.createElement</code> API如下:</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="05fd" class="ng kx iq mt b gy nw nx l ny nz">const root = document.getElementById('root');</span><span id="90ec" class="ng kx iq mt b gy oa nx l ny nz">const container = document.createElement('div');<br/>const heading = document.createElement('h1');<br/>heading.innerHTML = 'I am a heading!';</span><span id="e329" class="ng kx iq mt b gy oa nx l ny nz">container.appendChild(heading);<br/>root.appendChild(container);</span></pre><p id="7601" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如你所猜测的，如果我们对所有的元素都这样做，特别是如果我们要创建大型的节点嵌套层次结构，那么这将会变得非常难看和难以维护。</p><h2 id="dc08" class="ng kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">串并置</h2><p id="290c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">另一种方法是用字符串表示HTML，就像这样:</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="8d0f" class="ng kx iq mt b gy nw nx l ny nz">const root = document.getElementById('root');<br/>root.innerHTML = '&lt;div&gt;&lt;h1&gt;I am a heading!&lt;/h1&gt;&lt;/div&gt;';</span><span id="15cd" class="ng kx iq mt b gy oa nx l ny nz">// or...<br/>root.innerHTML = <br/>  '&lt;div&gt;' +<br/>    '&lt;h1&gt;' +<br/>      'I am a heading!' +<br/>    '&lt;/h1&gt;' +<br/>  '&lt;/div&gt;';</span></pre><p id="2440" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这也会变得相当糟糕。第一种方法是将HTML放在一行中，这似乎对一些小的东西很好，但是如果我们想要的HTML有几行呢？很难读懂。第二种方法是连接，格式很好，但是必须添加<code class="fe mq mr ms mt b">+</code>还是很烦人。最重要的是，如果我们在标记中犯了错误，我们的IDE将无法给我们帮助。</p><h2 id="f0d9" class="ng kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">模板文字</h2><p id="b5b3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在ES6中，我们介绍了模板字面语法。这由反勾(<code class="fe mq mr ms mt b">`</code>)字符表示，而不是像我们一直使用的传统字符串那样用单引号(<code class="fe mq mr ms mt b">‘</code>)或双引号(<code class="fe mq mr ms mt b">“</code>)表示。模板文字允许我们在字符串中有新的行，也允许在字符串中插入变量。下面是一个例子，说明我们如何给innerHTML分配模板文本:</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="ebdb" class="ng kx iq mt b gy nw nx l ny nz">const headingText = 'I am a heading!';</span><span id="1fb4" class="ng kx iq mt b gy oa nx l ny nz">const root = document.getElementById('root');<br/>root.innerHTML = `&lt;div&gt;<br/>  &lt;h1&gt; ${headingText} &lt;/h1&gt;<br/>&lt;/div&gt;`;</span></pre><p id="7b77" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe mq mr ms mt b">${}</code>语法允许我们将值直接放在字符串中，而不必像处理常规字符串那样使用<code class="fe mq mr ms mt b">+</code>。同样，这比普通的字符串好，甚至更好，但是这不允许我们使用IDE的能力来帮助我们写标记。</p><h1 id="3369" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">模板</h1><p id="bd2e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">想一想，到目前为止，我们一直用字符串或模板文字在JavaScript文件中添加标记，甚至用<code class="fe mq mr ms mt b">createElement</code>在DOM API中添加标记。如果我们有一个设计师团队来编写我们的HTML会怎么样？我们会将该标记复制粘贴到我们的<code class="fe mq mr ms mt b">.js</code>文件中，并修改它以得到我们想要显示的值吗？</p><p id="4e61" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">处理这个问题的最好方法是分离关注点。我们的自定义元素类不应该担心HTML的结构，也不应该关心CSS。我们应该将HTML标记放在一个<code class="fe mq mr ms mt b">.html</code>文件中，将CSS放在一个<code class="fe mq mr ms mt b">.css</code>文件中，将定制元素及其逻辑放在一个<code class="fe mq mr ms mt b">.js</code>文件中。</p><h2 id="ece7" class="ng kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated"><template>标签</template></h2><p id="7701" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">标签本身非常简单，因为它提供了一种保存不呈现在DOM中的HTML的方法。您可以将这个标签放在页面上的任何地方，这没有关系，因为我们可以使用JavaScript获取模板的内容，并将该内容放在另一个要呈现的元素中。</p><p id="b8c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mp">如果你克隆了Git repo，通过</em> <code class="fe mq mr ms mt b">git checkout starting-templates</code>切换到starting-templates分支</p><p id="5545" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们从添加一个模板到我们的<code class="fe mq mr ms mt b">index.html</code>文件开始</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="ff15" class="ng kx iq mt b gy nw nx l ny nz">// index.html<br/>...<br/>&lt;body&gt;<br/>  &lt;div id="root"&gt;<br/>    <strong class="mt ir">&lt;template&gt;<br/>      Hey there, this is a template.<br/>    &lt;/template&gt;</strong><br/>    &lt;app-toolbar&gt;&lt;/app-toolbar&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;<br/>...</span></pre><p id="34bc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">完成更改后，运行<code class="fe mq mr ms mt b">npm run serve</code>。当浏览器打开时，你什么也看不到。这是为什么呢？嗯，让我们看看开发者工具，看看HTML是什么样子的</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/e328e6efb4c521350e54fbcc8d8d415e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vn9NDS6BIkPvNlP_UgclVQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The template tag consists of a document-fragment that has our content inside.</figcaption></figure><p id="e138" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">模板就在那里，如果我们展开它看看里面有什么，我们会看到一个<code class="fe mq mr ms mt b">document-fragment</code>，在片段内部我们会看到我们的内容。</p><p id="e7e3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们更深入地了解一下<code class="fe mq mr ms mt b">document-fragment</code>是什么以及它是如何工作的。</p><h2 id="18be" class="ng kx iq bd ky nh ni dn lc nj nk dp lg lx nl nm li mb nn no lk mf np nq lm nr bi translated">文件碎片</h2><p id="fb47" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了理解什么是文档片段以及它们是如何工作的，让我们来看一个例子。打开名为<code class="fe mq mr ms mt b">toolbar.component.js</code>的文件，并在<code class="fe mq mr ms mt b">AppToolbar</code>类中添加以下位</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="1e21" class="ng kx iq mt b gy nw nx l ny nz">connectedCallback() {<br/>  <strong class="mt ir">const fragment = document.createDocumentFragment();</strong></span><span id="eaf9" class="ng kx iq mt b gy oa nx l ny nz">  for (let i = 0; i &lt; 3; i++) {<br/>    const paragraph = document.createElement('p');<br/>    paragraph.innerText = `This is paragraph ${i}`;<br/>    <strong class="mt ir">fragment.appendChild(paragraph);</strong><br/>  }<br/>  <strong class="mt ir">this.appendChild(fragment);</strong><br/>}</span></pre><p id="c74b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的代码中，我们</p><ul class=""><li id="f81e" class="oc od iq lq b lr mk lu ml lx oe mb of mf og mj oh oi oj ok bi translated">创建了一个文档片段</li><li id="7d98" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">向片段追加子元素</li><li id="c04d" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">最后，将片段作为子元素添加到我们的自定义元素中</li></ul><p id="3a75" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您运行<code class="fe mq mr ms mt b">npm run serve</code>时，您应该会看到类似如下的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/c491d63ef3dd5e4c1c9f7b50e094a99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hEiYaIKJAAWgKOVS3POTVQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The contents of the document-fragment was added directly to our custom element without having to first create a containing element.</figcaption></figure><p id="f168" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里发生了什么？我们的文档片段的内容被直接添加到我们的自定义元素中，而不必先创建一个包含元素。</p><p id="6261" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，使用模板和文档片段有一个“陷阱”。一旦将片段的内容添加到DOM中，片段本身就变成了空的，也就是说，它不再包含内容。如果我们在将片段添加到DOM之前和之后做一个控制台日志，我们可以看到:</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="30ab" class="ng kx iq mt b gy nw nx l ny nz">connectedCallback() {<br/>  const fragment = document.createDocumentFragment();</span><span id="9fc8" class="ng kx iq mt b gy oa nx l ny nz">  for (let i = 0; i &lt; 3; i++) {<br/>    const paragraph = document.createElement('p');<br/>    paragraph.innerText = `This is paragraph ${i}`;<br/>    fragment.appendChild(paragraph);<br/>  }</span><span id="8c93" class="ng kx iq mt b gy oa nx l ny nz">  <strong class="mt ir">console.log(`Content before appending: ${fragment.textContent}`);</strong><br/>  this.appendChild(fragment);<br/>  <strong class="mt ir">console.log(`Content after appending: ${fragment.textContent}`);</strong><br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/3343b62f50151a233a789f2ce99396f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9tL03CBmd7kuXq7EHpODA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Content of the fragment is lost after being added to the DOM</figcaption></figure><p id="fa52" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个例子中，您可以看到，一旦文档片段被添加到DOM中，它就失去了它的内容。</p><p id="38b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这意味着我们可以使用模板和文档片段一次，而<strong class="lq ir">只能使用一次！</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5d09188bce3683fcb6e8103ddf926c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*zp8yVV7HYiXsVU6Iu5ciBA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Document-Fragments lose their content once added to the DOM</figcaption></figure><p id="b522" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">任何后续尝试都将导致内容为空。这似乎有点没用，对吧？为什么你要大费周章才能用一次？你不会的。为了有效地使用模板和片段，您必须首先克隆内容。通常在其他例子中，您会看到内容是这样被克隆的:</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="a621" class="ng kx iq mt b gy nw nx l ny nz">connectedCallback() {<br/>  const fragment = document.createDocumentFragment();</span><span id="d84a" class="ng kx iq mt b gy oa nx l ny nz">  for (let i = 0; i &lt; 3; i++) {<br/>    const paragraph = document.createElement('p');<br/>    paragraph.innerText = `This is paragraph ${i}`;<br/>    fragment.appendChild(paragraph);<br/>  }</span><span id="3f34" class="ng kx iq mt b gy oa nx l ny nz"><strong class="mt ir">  </strong>console.log(`Content before appending: ${fragment.textContent}`);<br/>  <strong class="mt ir">const clone = fragment.cloneNode(true);</strong><br/>  this.appendChild(<strong class="mt ir">clone</strong>);<br/>  console.log(`Content after appending: ${fragment.textContent}`);<br/>}</span></pre><p id="5243" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们不再将片段附加到自定义元素上，而是添加了它的一个克隆。如果您继续执行并做出了这一更改，您应该会在浏览器和控制台中看到如下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/a9519a033905a0eb9edb5312df523bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hc8vzLC-Vocs9gum7LvTMg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The fragment retains its content and we’re able to display the clone on the DOM</figcaption></figure><p id="4fd2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为我们克隆了片段并添加了克隆，所以片段保留了它的内容，我们也能够在屏幕上显示内容。</p><p id="a8e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是模板可重用的原因。现在，每当我们需要使用模板时，我们只需首先克隆它的内容，然后将克隆的内容添加到DOM中。</p><p id="6a7a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <code class="fe mq mr ms mt b">cloneNode(true)</code> <em class="mp">当传入</em> <code class="fe mq mr ms mt b">true</code> <em class="mp">时，意味着我们要对正在克隆的节点做一个</em> <strong class="lq ir"> <em class="mp">深度克隆</em> </strong> <em class="mp">。这是常见的情况，因为我们希望确保克隆与我们拥有的模板完全相同。</em></p><h1 id="c986" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">活生生的例子</h1><p id="fc79" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mp">如果您正在跟随，您可以通过运行</em> <code class="fe mq mr ms mt b">git checkout templates-example</code> <em class="mp">切换到模板-示例分支，从起点开始，或者您可以跳转到</em> <code class="fe mq mr ms mt b">templates-example-final</code> <em class="mp">分支来查看示例的完成版本。</em></p><p id="2a44" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们用自定义元素和模板的知识来创建一些东西。我们要创建的非常简单，但它将涵盖我们到目前为止所学的内容。我们将有一个模板选项的选择下拉列表来查看，我们将呈现所选的选项。</p><p id="6f3a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将从向模板查看器定制元素添加一个属性开始。让我们称这个属性为布局，当这个属性改变时，我们想要克隆和渲染正确的布局。因此，打开<code class="fe mq mr ms mt b">template-viewer.component.js</code>并添加以下位:</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="3a13" class="ng kx iq mt b gy nw nx l ny nz">export default class TemplateViewer extends HTMLElement {<br/>  <br/>  static get observedAttributes() {<br/>    return ['layout'];<br/>  }</span><span id="a97d" class="ng kx iq mt b gy oa nx l ny nz">  get layout() {<br/>    return this.getAttribute('layout');<br/>  }</span><span id="337a" class="ng kx iq mt b gy oa nx l ny nz">  set layout(value) {<br/>    this.setAttribute('layout', value);<br/>  }</span><span id="aba2" class="ng kx iq mt b gy oa nx l ny nz">  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name === 'layout') {<br/>      const template = document.getElementById(<strong class="mt ir">newValue</strong>);<br/>      const clone = template.<strong class="mt ir">content</strong>.cloneNode(true);<br/>      this.appendChild(clone);<br/>    }<br/>  }<br/>}</span></pre><p id="4fc2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">很简单，没有什么我们以前没有涉及过的。在<code class="fe mq mr ms mt b">attributeChangedCallback </code>方法中，我们将通过id检索一个元素，并将<code class="fe mq mr ms mt b">newValue</code>用作id。然后我们获取模板的内容并克隆它，最后将克隆添加到我们的定制元素中。现在在你的<code class="fe mq mr ms mt b">index.html</code>中添加以下内容:</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="3765" class="ng kx iq mt b gy nw nx l ny nz">&lt;template-viewer <strong class="mt ir">layout="first"</strong>&gt;&lt;/template-viewer&gt;</span></pre><p id="8a2d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样一来，让我们创建一些模板。</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="4d59" class="ng kx iq mt b gy nw nx l ny nz">&lt;template <strong class="mt ir">id="first"</strong>&gt;<br/>  &lt;div class="container"&gt;<br/>    &lt;div class="circle"&gt;<br/>      &lt;!-- image place holder --&gt;<br/>    &lt;/div&gt;</span><span id="1e49" class="ng kx iq mt b gy oa nx l ny nz">    &lt;div class="name-container"&gt;<br/>      &lt;p class="name"&gt;Billy Bob&lt;/p&gt;<br/>      &lt;p class="email"&gt;billy@bob.com&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="95e9" class="ng kx iq mt b gy oa nx l ny nz">&lt;template <strong class="mt ir">id="second"</strong>&gt;<br/>  &lt;div class="container"&gt;<br/>    &lt;div class="circle"&gt;<br/>      &lt;!-- image place holder --&gt;<br/>    &lt;/div&gt;</span><span id="c231" class="ng kx iq mt b gy oa nx l ny nz">    &lt;div class="name-container"&gt;<br/>      &lt;p class="name"&gt;Jimmy Jumpin' Jiminy&lt;/p&gt;<br/>      &lt;p class="email"&gt;jj@jiminy.com&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="224d" class="ng kx iq mt b gy oa nx l ny nz">&lt;template <strong class="mt ir">id="third"</strong>&gt;<br/>  &lt;div class="container"&gt;<br/>    &lt;div class="circle"&gt;<br/>      &lt;!-- image place holder --&gt;<br/>    &lt;/div&gt;</span><span id="b8aa" class="ng kx iq mt b gy oa nx l ny nz">    &lt;div class="name-container"&gt;<br/>      &lt;p class="name"&gt;Sir Jay J. Jamison&lt;/p&gt;<br/>      &lt;p class="email"&gt;jj@jamison.com&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="0ff4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我已经给每个模板分配了id。这样，当我们选择一个新的模板来查看时，我们可以通过id来获取模板。看到没，开始说得通了:)。</p><p id="932e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们现在看一下我们的浏览器，从控制台改变属性，我们可以看到它像预期的那样工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/001178096a82a2acf4d997c88e575579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnIF9YaGjB3UVWAlNBZrdg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Every time we change the attribute the correct template gets added to the DOM.</figcaption></figure><p id="8fb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每当我们改变自定义元素的<code class="fe mq mr ms mt b">layout</code>属性时，正确的模板就会被添加到DOM中。</p><p id="7181" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是我们不想追加一个新的，我们只想替换它。所以让我们现在就做出改变。在自定义元素类中进行以下更改。</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="b88f" class="ng kx iq mt b gy nw nx l ny nz">attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name === 'layout') {<br/>      <strong class="mt ir">this.innerHTML = '';</strong><br/>      const template = document.getElementById(newValue);<br/>      const clone = template.content.cloneNode(true);<br/>      this.appendChild(clone);<br/>    }<br/>  }</span></pre><p id="7a7a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样做的目的是，每当<code class="fe mq mr ms mt b">layout</code>属性改变时，我们清除自定义元素的<code class="fe mq mr ms mt b">innerHTML</code>，然后追加正确的模板。这样，我们只显示一个模板。现在，如果我们再次尝试，它会像我们期望的那样工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/975bbd9839ae4a1b7e6ed6b30f9d1d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxNLxipNCVhqIcHa7h8v6w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Changing the attribute clears out the innerHTML of the element and then appends the correct template that we want to view.</figcaption></figure><p id="a733" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">太好了！让我们添加一些样式，而我们在这一点上。在根文件夹中创建一个名为<code class="fe mq mr ms mt b">styles.css</code>的新文件，并添加以下内容。</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="c46f" class="ng kx iq mt b gy nw nx l ny nz">.container {<br/>  width: 350px;<br/>  height: 250px;<br/>  border: solid 1px black;<br/>  border-radius: 10px;<br/>  padding: 10px;<br/>  text-align: center;<br/>}</span><span id="0f0b" class="ng kx iq mt b gy oa nx l ny nz">.circle {<br/>  width: 100px;<br/>  height: 100px;<br/>  border: solid 1px black;<br/>  border-radius: 100px;<br/>  margin: 15px auto;<br/>}</span><span id="cccd" class="ng kx iq mt b gy oa nx l ny nz">.name {<br/>  font-size: 24px;<br/>  letter-spacing: 5px;<br/>}</span><span id="4218" class="ng kx iq mt b gy oa nx l ny nz">.email {<br/>  font-size: 18px;<br/>  color: gray;<br/>}</span></pre><p id="b17e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为我们已经将webpack设置为将css文件作为模块导入，所以我们可以在我们的<code class="fe mq mr ms mt b">app.js</code>文件<em class="mp">(或任何js文件)</em>中执行以下操作，webpack会自动将样式表添加到我们的<code class="fe mq mr ms mt b">index.html</code>文件中</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="d354" class="ng kx iq mt b gy nw nx l ny nz">// app.js</span><span id="c8bc" class="ng kx iq mt b gy oa nx l ny nz">import TemplateViewer from './template-viewer/template-viewer.component';</span><span id="5d02" class="ng kx iq mt b gy oa nx l ny nz"><strong class="mt ir">import styles from '../styles.css';</strong></span><span id="e70e" class="ng kx iq mt b gy oa nx l ny nz">if (!customElements.get('template-viewer')) {<br/>  customElements.define('template-viewer', TemplateViewer);<br/>}</span></pre><p id="daed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">保存项目并查看您的浏览器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/0aa89d301ead2ab1e81e0f48aa0acc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLfKkaQdTWtM0b-cY3YRvQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">With the styles added we can now see the templates.</figcaption></figure><p id="3717" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">添加了样式后，我们可以看到模板了。嗯，我们以前也可以看到它，但现在它只是看起来很漂亮。让我们通过控制台再次尝试更改<code class="fe mq mr ms mt b">layout</code>属性，看看一切看起来如何。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/7daa20d160ebe2e0a2f9065481c7251e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msPAmQWhgv6x1oRvfy2kug.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Changing the layout attribute loads the correct template with the styles applied.</figcaption></figure><p id="6423" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">改变<code class="fe mq mr ms mt b">layout</code>属性加载正确的模板并应用样式。这太棒了！我们能够按需加载模板，并用样式呈现它们。现在样式是全局应用的，这意味着如果我们想让其他组件拥有。容器类看起来应该是一样的。在本系列的下一部分中，当我们讨论Shadow DOM时，我们将对此进行更深入的探讨。但是，现在，这很好。</p><p id="ea9a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们添加一个下拉菜单，这样我们就不必通过控制台手动更改<code class="fe mq mr ms mt b">layout</code>属性。将以下内容添加到您的<code class="fe mq mr ms mt b">index.html</code>中。</p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="4795" class="ng kx iq mt b gy nw nx l ny nz">...<br/>&lt;div id="root"&gt;<br/>  <strong class="mt ir">&lt;select id="template-selector" style="margin-bottom: 10px;"&gt;<br/>    &lt;option value="first"&gt;First Layout&lt;/option&gt;<br/>    &lt;option value="second"&gt;Second Layout&lt;/option&gt;<br/>    &lt;option value="third"&gt;Third Layout&lt;/option&gt;<br/>  &lt;/select&gt;</strong><br/>  &lt;template-viewer layout="first"&gt;&lt;/template-viewer&gt;<br/>...</span></pre><p id="d7f8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有了这些，我们可以在<code class="fe mq mr ms mt b">template-selector</code>上添加一个<em class="mp">事件监听器</em>来监听变更事件。当change事件被触发时，我们希望将自定义元素上的<code class="fe mq mr ms mt b">layout</code>属性的值更改为从<code class="fe mq mr ms mt b">template-selector</code>中选择的值。将以下内容添加到<code class="fe mq mr ms mt b">app.js</code></p><pre class="kg kh ki kj gt ns mt nt nu aw nv bi"><span id="1f7c" class="ng kx iq mt b gy nw nx l ny nz">...<br/>const templateSelector = document.getElementById('template-selector');<br/>const templateViewer = document.querySelector('template-viewer');</span><span id="28c3" class="ng kx iq mt b gy oa nx l ny nz">templateSelector.<strong class="mt ir">addEventListener</strong>('change', (event) =&gt; {<br/>  const valueSelected = <strong class="mt ir">event.target.value</strong>;<br/>  <strong class="mt ir">templateViewer.layout = valueSelected;</strong><br/>});</span></pre><p id="cbfe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这方面，我们正在做以下事情</p><ul class=""><li id="d16f" class="oc od iq lq b lr mk lu ml lx oe mb of mf og mj oh oi oj ok bi translated">通过id 获取选择元素<em class="mp"/></li><li id="000c" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">获取我们的自定义元素</li><li id="c9c1" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">向select元素添加一个<em class="mp">事件监听器</em>，并监听“<em class="mp">变更</em>事件</li><li id="c90e" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">当事件被触发时，我们捕获它并获得目标元素的<em class="mp">值属性</em></li><li id="3cf4" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">将自定义元素的<em class="mp">布局属性</em>设置为触发事件的元素的值。</li></ul><p id="8eca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">保存更改并在浏览器中查看签出。当您选择想要查看的模板时，它会被加载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/32f0603549f931dc69079b7a6efc06b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*MjyBFfL9eggGe6tw6A21lQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Selecting a layout from the dropdown should change the template you’re viewing.</figcaption></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="0b0a" class="kw kx iq bd ky kz nb lb lc ld nc lf lg jw nd jx li jz ne ka lk kc nf kd lm ln bi translated">结论</h1><p id="9925" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这篇文章中，我们讨论了</p><ul class=""><li id="0454" class="oc od iq lq b lr mk lu ml lx oe mb of mf og mj oh oi oj ok bi translated">创建不可伸缩模板的方法，即字符串连接和createElement API</li><li id="efa9" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">关注点分离，将html、css和js放在不同的文件中。</li><li id="e5c5" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">模板标签以及如何使用它</li><li id="84ea" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">关于文档片段及其工作方式的详细信息。同时要记住，文档片段在被添加到DOM后会丢失其内容，除非被克隆。</li><li id="596b" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated">一个活生生的例子展示了我们对定制元素和使用模板的综合知识。</li></ul><p id="cae3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个系列的下一篇也是最后一篇文章中，我将讨论阴影DOM。</p><p id="4c38" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你喜欢这篇文章，请分享给你的朋友，并期待下一篇！</p><p id="de9e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">直到下一次，和平！</p></div></div>    
</body>
</html>