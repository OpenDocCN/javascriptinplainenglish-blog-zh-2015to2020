<html>
<head>
<title>Do you know why this.x is Undefined when x is declared with Const or Let?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">知道为什么用Const或Let声明x时this.x是未定义的吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/do-you-know-why-this-x-is-undefined-when-x-is-declared-with-const-or-let-8f6e00dcd490?source=collection_archive---------0-----------------------#2020-01-09">https://javascript.plainenglish.io/do-you-know-why-this-x-is-undefined-when-x-is-declared-with-const-or-let-8f6e00dcd490?source=collection_archive---------0-----------------------#2020-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2b08" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Java Script语言</h2><div class=""/><div class=""><h2 id="ecd4" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">这是因为ECMAScript规范</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d829936b37aec4d2c39887d0e295273c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3zTTlbqKtiq4CoFV"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@hannahbusing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hannah Busing</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0b24" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我在为帖子做一些例子。这是关于普通函数和箭头函数的区别。我在变量声明中使用了关键字<code class="fe mb mc md me b">const</code>,并创建了一个从内部调用外部变量的函数，如下所示。</p><pre class="kp kq kr ks gt mf me mg mh aw mi bi"><span id="61e8" class="mj mk iq me b gy ml mm l mn mo">const x = 1;</span><span id="74ee" class="mj mk iq me b gy mp mm l mn mo">function f() {<br/>  console.log(this.x);<br/>}</span><span id="f143" class="mj mk iq me b gy mp mm l mn mo">f(); // <strong class="me ja">undefined</strong></span></pre><p id="6aba" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但给出的结果是<code class="fe mb mc md me b">undefined</code>。(在你的控制台上运行这个)所以我想为什么…这有什么问题…</p><p id="7e77" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我钻研了ECMAScript规范来找出确切的原因，因为没有“只是”，就像“它只是未定义的”。我通过研究文档编造了我的故事。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="b989" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">免责声明</strong> <br/>你可能对此有不同的观点。当然，我可能是错的，因为我没有研究v8代码。因此，如果你有不同的想法，请随时发表评论，并与我们分享你的想法。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="6b65" class="mx mk iq bd my mz na nb nc nd ne nf ng kf nh kg ni ki nj kj nk kl nl km nm nn bi translated">执行上下文和领域</h1><p id="57a5" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">我认为你应该对JavaScript中的执行上下文有一个基本的了解。如果你完全不知道这是什么，我建议你读一读我关于执行上下文的帖子。</p><div class="nt nu gp gr nv nw"><a href="https://medium.com/better-programming/execution-context-lexical-environment-and-closures-in-javascript-b57c979341a5" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ja gy z fp ob fr fs oc fu fw iz bi translated">JavaScript中的执行上下文、词汇环境和闭包</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">你应该知道的高级JavaScript概念</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ky nw"/></div></div></a></div><p id="24b0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">根据文档，对于所有的执行上下文，有三个组成部分——代码评估状态、函数和领域。我们将研究第三个组件，领域。</p><p id="93b1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">领域是一种与ECMAScript资源相关联的世界。并且运行执行的领域被称为<em class="ol">当前领域</em>。为什么这是一个问题？当您执行JavaScript代码时，它会创建一个全局执行上下文，其当前领域<em class="ol">是全局领域。在这个领域中，一个名为<em class="ol"> globalEnv </em>的对象被创建和envolved，它包含一个词法环境。</em></p><h1 id="084d" class="mx mk iq bd my mz om nb nc nd on nf ng kf oo kg ni ki op kj nk kl oq km nm nn bi translated">全球词汇环境</h1><p id="a44b" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">每个词法环境都有一个环境记录，其中包含您的变量并不断跟踪它们。</p><pre class="kp kq kr ks gt mf me mg mh aw mi bi"><span id="425c" class="mj mk iq me b gy ml mm l mn mo">var name = 10;</span><span id="fade" class="mj mk iq me b gy mp mm l mn mo">var globalLexicalEnvironment = {<br/>  environmentRecord: {<br/>    name: name<br/>  }<br/>};</span></pre><p id="bb46" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在全局执行上下文中创建的词汇环境包含了<code class="fe mb mc md me b">window</code>对象。</p><p id="65cc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是为什么和如何？</p><p id="03db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当生成全局执行上下文时，它的环境记录被创建，它被认为是所有ECMAScript元素共享的最外层范围。在全球环境记录中有一个领域，换句话说，它是最外层的范围。这个环境记录为内置变量或函数提供绑定。这是那些内置东西的列表。</p><ul class=""><li id="0bb9" class="or os iq lh b li lj ll lm lo ot ls ou lw ov ma ow ox oy oz bi translated">无穷</li><li id="86b7" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated">圆盘烤饼</li><li id="ff6d" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated">不明确的</li><li id="00b8" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated">evaluate 评价</li><li id="d641" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated">排列</li><li id="add2" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated">布尔代数学体系的</li><li id="3412" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi">…</li></ul><p id="db58" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些属性被分配到的对象被称为<code class="fe mb mc md me b">window</code>，对于浏览器JavaScript来说。这种关系可以表示如下，然而，当然，这不是JavaScript的工作方式。</p><pre class="kp kq kr ks gt mf me mg mh aw mi bi"><span id="cd65" class="mj mk iq me b gy ml mm l mn mo">var window = {<br/>  Infinity: ...,<br/>  NaN: ...,<br/>  undefined: ...,<br/>  eval: ...,<br/>  Array: ...,<br/>  Boolean: ...,<br/>};</span><span id="46ef" class="mj mk iq me b gy mp mm l mn mo">var globalExecutionContext = {<br/>  environmentRecords: {<br/>    window: window<br/>  }<br/>};</span></pre><h1 id="609f" class="mx mk iq bd my mz om nb nc nd on nf ng kf oo kg ni ki op kj nk kl oq km nm nn bi translated">Var与Const &amp; Let</h1><p id="8c7c" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">那为什么<code class="fe mb mc md me b">var</code>变量变成了<code class="fe mb mc md me b">window</code>的财产而<code class="fe mb mc md me b">const</code>和<code class="fe mb mc md me b">let</code>没有呢？如果你到目前为止都很好的跟着我就很好理解了！</p><p id="9fce" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当事物被声明并分配给全局环境记录中涉及的名为<code class="fe mb mc md me b">window</code>的对象时，会有另一个声明被添加到全局环境记录中。它叫做<em class="ol">TopLevelVarDeclaredNames</em>。它定义了JavaScript如何处理顶层范围内的<code class="fe mb mc md me b">var</code> ed变量。根据规范，在程序的开始是一个空数组。</p><p id="cf16" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">问题是，没有<em class="ol">topleveletdeclarednames</em>或<em class="ol">toplevelcontdeclarednames</em>。意思是，<code class="fe mb mc md me b">const</code> ed和<code class="fe mb mc md me b">let</code> ed变量不添加到全局对象，<code class="fe mb mc md me b">window</code>。</p><h1 id="8399" class="mx mk iq bd my mz om nb nc nd on nf ng kf oo kg ni ki op kj nk kl oq km nm nn bi translated">那我就永远不能访问它们了？</h1><p id="46d9" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">你可以。别担心。但这肯定不是推荐的方式。</p><pre class="kp kq kr ks gt mf me mg mh aw mi bi"><span id="8693" class="mj mk iq me b gy ml mm l mn mo">const x = 1;</span><span id="779d" class="mj mk iq me b gy mp mm l mn mo">function print() {<br/>  console.log(this.x);<br/>}</span><span id="5f61" class="mj mk iq me b gy mp mm l mn mo">window.x = x;<br/>print(); // 1</span></pre><p id="8a9a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">创建变量，赋值，并将它们放入<code class="fe mb mc md me b">window</code>。</p><p id="fbe8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">清晰，简单，但不好。(仅作为示例)</p><h1 id="b652" class="mx mk iq bd my mz om nb nc nd on nf ng kf oo kg ni ki op kj nk kl oq km nm nn bi translated"><strong class="ak">结论</strong></h1><p id="2230" class="pw-post-body-paragraph lf lg iq lh b li no ka lk ll np kd ln lo nq lq lr ls nr lu lv lw ns ly lz ma ij bi translated">“为什么不能访问用<code class="fe mb mc md me b">const</code>或<code class="fe mb mc md me b">let</code>关键字声明的变量”的结论非常简单。当程序开始运行时，会创建全局执行，并且所有ECMAScript元素的最外层作用域(称为全局领域)的公共区域会被赋予属性。<code class="fe mb mc md me b">var</code> ed变量可以被访问，因为全局领域知道如何处理，但是对于<code class="fe mb mc md me b">const</code> ed和<code class="fe mb mc md me b">let</code> ed变量，全局领域什么也做不了。没有任何关于他们的报道。(没有将<code class="fe mb mc md me b">const</code>和<code class="fe mb mc md me b">let</code>作为全局变量的声明或文档)</p><h1 id="ed08" class="mx mk iq bd my mz om nb nc nd on nf ng kf oo kg ni ki op kj nk kl oq km nm nn bi translated">资源</h1><ul class=""><li id="9db7" class="or os iq lh b li no ll np lo pf ls pg lw ph ma ow ox oy oz bi translated"><a class="ae le" href="https://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts" rel="noopener ugc nofollow" target="_blank">执行上下文— ECMAScript规范</a></li><li id="4e44" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated"><a class="ae le" href="https://www.ecma-international.org/ecma-262/6.0/#sec-code-realms" rel="noopener ugc nofollow" target="_blank">代码领域— ECMAScript规范</a></li><li id="eef8" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated"><a class="ae le" href="https://www.ecma-international.org/ecma-262/6.0/#sec-lexical-environments" rel="noopener ugc nofollow" target="_blank">词法环境— ECMAScript规范</a></li><li id="ac69" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated"><a class="ae le" href="https://www.ecma-international.org/ecma-262/6.0/#sec-global-environment-records" rel="noopener ugc nofollow" target="_blank">全球环境记录— ECMAScript规范</a></li><li id="f125" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated"><a class="ae le" href="https://www.ecma-international.org/ecma-262/6.0/#sec-global-object" rel="noopener ugc nofollow" target="_blank">全局对象— ECMAScript规范</a></li><li id="89f9" class="or os iq lh b li pa ll pb lo pc ls pd lw pe ma ow ox oy oz bi translated"><a class="ae le" href="https://www.ecma-international.org/ecma-262/6.0/#sec-block-static-semantics-toplevellexicallyscopeddeclarations" rel="noopener ugc nofollow" target="_blank">顶级词汇范围声明— ECMAScript规范</a></li></ul></div></div>    
</body>
</html>