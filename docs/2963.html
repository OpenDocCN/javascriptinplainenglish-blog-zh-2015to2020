<html>
<head>
<title>Building a poker hand evaluator without conditional branches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个没有条件分支的扑克手评估器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-poker-hand-evaluator-without-conditional-branches-556c39c8e33e?source=collection_archive---------2-----------------------#2020-08-11">https://javascript.plainenglish.io/building-a-poker-hand-evaluator-without-conditional-branches-556c39c8e33e?source=collection_archive---------2-----------------------#2020-08-11</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><div class=""><h2 id="b2c8" class="pw-subtitle-paragraph jl in io bd b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dk translated">JavaScript All In:一个没有条件分支的扑克手评估器</h2></div><figure class="ke kf kg kh gu ki gi gj paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gi gj kd"><img src="../Images/82f7d6d8d741461abab3a68ad2764647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XlyiUpG88Df7uF3e"/></div></div><figcaption class="kp kq gk gi gj kr ks bd b be z dk">Photo by <a class="ae kt" href="https://unsplash.com/@exxteban?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Esteban Lopez</a> on <a class="ae kt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cd27" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">建立一个开发团队需要一种方法来衡量候选人的天赋和技能。在一家公司的早期阶段，建立一个核心高层团队需要一种方法来淘汰骗子和印象深刻者。使用技术编码挑战是实现这一目标的一个途径。</p><p id="475c" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我的首选测试包括我最喜欢的消遣之一，扑克。具体来说，结合一个扑克手评估机制。如果不将候选人引向某个特定的实现，这个挑战就是开放式的，允许他们展示自己的基础编程知识和经验水平。</p><p id="9b0d" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我目睹了各种解决方案，从优雅的复制/粘贴代码到跨越数百行的可怕的冗余代码。有些完全是抄袭，没有注明原作者。但是贯穿这些提交的共同线索总是包含导致混乱或无关代码的条件分支。</p><p id="72ab" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我面临的一个挑战是编写一个不使用大型查找矩阵或任何条件分支的评估器，如<strong class="kw ip"> if/else </strong>或<strong class="kw ip"> switch </strong>块。也不鼓励使用链式三元运算符的代码。</p><p id="d34f" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这是我迎接挑战的旅程。</p><h2 id="57fb" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">背景</h2><p id="fa81" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">在我早年编程的时候，在Timex Sinclair ZX-81上，在资源极其有限的情况下，跳入机器语言是代码优化的极限。使用按位运算符进行数学运算对我来说很神奇。这些按位运算或逻辑运算符的结果可以用作内联决策树，为寄存器分配一个或另一个值。</p><p id="4b9e" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我继续研究Commodore 64，然后是Apple II，在6502芯片上用机器语言编码。随着计算机变得更强大、更快、内存和存储更便宜，程序员转向更高级的语言并开始懈怠，他们的代码变得更加冗长和草率。</p><p id="ca24" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">每次迁移到另一个计算平台，我都坚持用更少的代码来执行相同的操作。我试图从每一行代码中挤出最多的内容，有时会因为混淆而损害可读性。</p><p id="9579" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">在这个练习中，我将从头到尾使用逻辑操作符，并将解释代码是如何完成多分支机制的工作的。除了逻辑操作符，使用对象映射也有助于这项工作。我更喜欢自顶向下读取和操作的代码，而不需要创建深度分支树。</p><p id="bb4b" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我们开始工作吧。</p></div><div class="ab cl mo mp hs mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ih ii ij ik il"><h2 id="2a91" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">规划</h2><p id="365d" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">在写出代码之前，总是需要少量的计划。我经常回到纸笔这个屡试不爽的模拟工具上，快速勾画出我的想法。绘图纸再多也不嫌多；这是制定计划的最终手段。我想将一手牌的评估嵌入到二进制映射矩阵中，下一张牌的每个值都比前一张牌高一个二进制数值。</p><p id="188d" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">使用二进制映射表示法会导致每种卡片组合在加在一起时都有唯一的值。获胜者由“得分”最高的一手牌决定</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="2bab" class="lq lr io mw b gz na nb l nc nd">A: 8192<br/>K: 4096<br/>Q: 2048<br/>J: 1024<br/>T:  512<br/>9:  256<br/>8:  128<br/>7:   64<br/>6:   32<br/>5:   16<br/>4:    8<br/>3:    4<br/>2:    2<br/>A:    1</span></pre><p id="9aa7" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">为什么王牌反反复复？在一手扑克中，a通常被视为最高牌值，但在低a顺子中，a是最低值；因此，它在地图上有双重位置。</p><p id="703f" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">扑克中有九个级别，其中皇家同花顺是排名第九的牌中最高的(在这种情况下，为了清楚起见，我们给它打10分)。现在让我们把它们列出来，指定一个排名号。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="446b" class="lq lr io mw b gz na nb l nc nd">10: Royal Flush<br/> 9: Straight Flush<br/> 8: Quads (4 of a kind)<br/> 7: Full House<br/> 6: Flush<br/> 5: Straight<br/> 4: Trips (3 of a kind)<br/> 3: Two Pairs<br/> 2: Pair<br/> 1: High Card</span></pre><p id="a371" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">等级的对象映射将用于保存标志，在映射中最高等级排在最前面。默认情况下，<strong class="kw ip"> high_card </strong>等级设置为“真”。在评估这手牌的过程中，相应的匹配等级将被翻转为“真”遍历对象图并在第一个“真”值上停止将确定手的等级。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="9bbc" class="lq lr io mw b gz na nb l nc nd">const ranks = {<br/>  royal_flush: false,<br/>  straight_flush: false,<br/>  quads: false,<br/>  full_house: false,<br/>  flush: false,<br/>  straight: false,<br/>  trips: false,<br/>  two_pairs: false,<br/>  pair: false,<br/>  high_card: true,<br/>};</span></pre><p id="4a6c" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated"><em class="ne">在我们开始编码之前，我想先说明一下，这不是生产就绪的代码。它不包括错误处理或验证，并假设您熟悉扑克、排名牌，并对JavaScript语法有基本的了解。</em></p></div><div class="ab cl mo mp hs mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ih ii ij ik il"><h2 id="78ea" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">常数</h2><p id="1b2f" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">现在计划已经完成，让我们分配一些将在整个练习中使用的常量。其中一些是不言自明的，对那些可能需要额外细节的评论。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="0b94" class="lq lr io mw b gz na nb l nc nd"><strong class="mw ip">ACE_VALUE</strong> equates to 8192, but let's use the <em class="ne">Math.pow</em> function to calculate that for us, which is 2^13, the 13th position from our map above (using a zero index).</span><span id="b484" class="lq lr io mw b gz nh nb l nc nd">A way to visualize a hand in the binary matrix, is how the <strong class="mw ip">STRAIGHT_LOW_ACE_INDICATOR</strong> is constructed as a binary number. It represents a low-ace-straight with the Ace in the high position. The ace will effectively be moved to a lower position during the conversion, which we will see later in the exercise.</span><span id="962f" class="lq lr io mw b gz nh nb l nc nd">Without counting the low Ace position, using a zero-index, the "Ten" card is in the 8th position, hence the <strong class="mw ip">TEN_CARD_POSITION</strong> constant. This will be used later to detect a Royal Flush.</span><span id="7128" class="lq lr io mw b gz nh nb l nc nd">A high value is desired for a <strong class="mw ip">RANK_BASE_VALUE</strong> which will be added to the total score of the hand. It should be higher than the highest sum that can be calculated, which equates to a hand with quad Aces and a King: AAAAK. This value is 268,439,552. I chose 10^9 (1 billion) since it gives a visual clue to its rank by looking at the most significant digit of the final total score.</span><span id="cf70" class="lq lr io mw b gz nh nb l nc nd">10,000,000,000 &lt; Royal Flush<br/>9,000,000,000 &lt; Straight Flush &lt; 10,000,000<br/>8,000,000,000 &lt; Quads &lt; 7,000,000,000<br/>...<br/>1,000,000,000 &lt; High Card &lt; 2,000,000,000</span></pre><h2 id="740d" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">甲板和洗牌</h2><p id="5b75" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">我们需要做一副牌，然后洗牌。参考我以前写的关于JavaScript洗牌的文章，我们可以使用。</p><div class="ni nj gq gs nk nl"><a href="https://medium.com/swlh/the-javascript-shuffle-62660df19a5d" rel="noopener follow" target="_blank"><div class="nm ab fp"><div class="nn ab no cl cj np"><h2 class="bd ip gz z fq nq fs ft nr fv fx in bi translated">Javascript洗牌</h2><div class="ns l"><h3 class="bd b gz z fq nq fs ft nr fv fx dk translated">编写洗牌算法的旅程。</h3></div><div class="nt l"><p class="bd b dl z fq nq fs ft nr fv fx dk translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kn nl"/></div></div></a></div><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="110a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这副牌是一组从0到51的数字。下面显示的矩阵将牌分成四种花色:梅花、方块、红心和黑桃。使用改进的Fisher-Yates洗牌算法，对于这个练习应该足够了。来自<em class="ne"> buildDeck.js </em>的第5行从未洗牌的牌池中随机选择一张牌，并将其从牌堆中拉出，推回牌堆顶部，然后继续处理其余的牌。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="91fb" class="lq lr io mw b gz na nb l nc nd"><strong class="mw ip">Card Matrix<br/>.  2  3  4  5  6  7  8  9  T  J  Q  K  A</strong><br/><strong class="mw ip">C</strong> 00 01 02 03 04 05 06 07 08 09 10 11 12<br/><strong class="mw ip">D</strong> 13 14 15 16 17 18 19 20 21 22 23 24 25<br/><strong class="mw ip">H</strong> 26 27 28 29 30 31 32 33 34 35 36 37 38<br/><strong class="mw ip">S</strong> 39 40 41 42 43 44 45 46 47 48 49 50 51</span></pre><h2 id="8d2c" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">展示卡</h2><p id="561d" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">对于一个人来说，仅使用数字来确定手里有哪些牌是困难的。让我们写一个函数来显示扑克术语中的牌；更易于阅读的格式。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="3d3d" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我最喜欢的JavaScript数组函数是<strong class="kw ip">。减少</strong>。当遍历一组条目以返回单个值或构建一个列表时，使用<strong class="kw ip">。reduce </strong>实际上减少了所需的代码量。在这种情况下，它将基于数字牌值矩阵构建一个可读扑克牌面的数组。最终，<strong class="kw ip">。join </strong>将把它连接成一个字符串。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="3276" class="lq lr io mw b gz na nb l nc nd">It takes an array like this [ 12, 16, 33, 7, 49 ] and displays it like A♣︎ 5♦︎ 9♥︎ 9♣︎ Q♠︎</span></pre><h2 id="0361" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">给手排序</h2><p id="3b09" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">这段代码是练习的核心，也是编写起来最复杂、最有趣的。该函数假设基于上面定义的卡片矩阵的5张卡片的阵列是该函数的输入。如前所述，没有错误处理或输入验证。假设该函数的使用者正在传递有效信息。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="94d5" class="lq lr io mw b gz na nb l nc nd">Outline of the rankHand function:<br/>• Build and count occurences of suits and values<br/>• Calculate the total value of the cards<br/>• Determine the rank of the hand<br/>• Handle a Low-Ace Straight<br/>• Build the description and human readable version<br/>• Return an object with all properties</span></pre><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="fac8" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">首先，此函数构建一个花色和值的数组映射，以计算这手牌中出现的次数。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="4d62" class="lq lr io mw b gz na nb l nc nd">A Straight Flush would have the resulting array maps:<br/>suits: [ 0, 5, 0, 0 ]<br/>values: [ 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 ]</span><span id="480c" class="lq lr io mw b gz nh nb l nc nd">A Full House would look like this:<br/>suits: [ 1, 2, 2, 0 ]<br/>values: [ 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0 ]</span></pre><p id="045f" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">当遍历值数组时，执行求和。这段代码是通过在reducer方法中使用逻辑运算符来消除条件分支的一个例子。两次计算加在一起。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="23df" class="lq lr io mw b gz na nb l nc nd">Line 11:<br/>  ((val === 1 &amp;&amp; Math.pow(2, index + 1)) || 0)</span></pre><p id="b96c" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">第一次计算将使用<strong class="kw ip"> Math.pow(2，index + 1) </strong>基于其位置+ 1的二进制扩展来添加卡的值。表达式<strong class="kw ip"> val === 1 </strong>需要为真才能继续数学表达式；否则，由于逻辑OR (||)运算符，它将为零。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="5513" class="lq lr io mw b gz na nb l nc nd">Line 12:<br/>  ((val &gt; 1 &amp;&amp; Math.pow(2, index + 1) * ACE_VALUE * val) || 0))</span></pre><p id="8957" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">第二个计算具有相同的结构，但仅适用于出现次数大于1的情况。这一次，二进制扩展乘以<strong class="kw ip"> ACE_VALUE </strong>值，然后再乘以该值出现的次数。它将通过相应增加等级值来调整双人、三人、满屋和四人。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="a4ae" class="lq lr io mw b gz na nb l nc nd">Line 15:<br/>  const firstCardIndex = values.findIndex((index) =&gt; index === 1);</span></pre><p id="44ea" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">常数<strong class="kw ip">first car index</strong>有双重用途。它用于查找第一个非零计数的位置，然后用于确定这手牌是否被列为顺子。</p><p id="1bf8" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">第16–34行为每个等级设置了标志，该标志由每个等级属性上设置的条件和逻辑决定。最后执行同花顺和同花等级的逻辑，以利用已经为同花顺和同花设置的标志。每个表达式相当于一个布尔值。这个代码块通过使用对象映射和布尔表达式完全消除了条件分支的使用。</p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="d524" class="lq lr io mw b gz na nb l nc nd">Line 37:<br/>  Object.keys(ranks).every((key, index) =&gt; {</span></pre><p id="f4bb" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我使用了<em class="ne"> Array.every </em>来在发现第一个真标志时使循环短路，也就是当<strong class="kw ip">！【关键等级】</strong>是假的。这消除了必须构建一个循环和初始化跟踪的额外变量。我使用这种方法来减少代码量，这也减少了可能引入的bug的数量。</p><p id="336e" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">第42–44行将<strong class="kw ip"> RANK_BASE_VALUE </strong>乘以在前一个区块中找到的<strong class="kw ip"> rankIndex，</strong>的数值相加，然后减去<strong class="kw ip"> ACE_VALUE </strong>(如果是低牌顺子)。这里再次使用条件逻辑操作符，而不是使用任何分支逻辑。</p></div><div class="ab cl mo mp hs mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ih ii ij ik il"><h2 id="e969" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">扑克派对</h2><p id="7b4d" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">既然我们已经完成了困难的部分，让我们玩得开心点。我们首先需要有一个方法来比较手找到赢家。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="ac0a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">此函数将返回按排名顺序排序的手牌，第一手牌为“赢家”如果编写一个完整的扑克游戏，在分彩池的情况下确定多手牌的平等性。</p><h2 id="4093" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">得克萨斯扑克</h2><p id="6c2e" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">玩扑克有很多种方式，有些变化可能有点复杂，但最受欢迎的是德州扑克。世界扑克锦标赛(WSOP)巡回赛基于无限注德州扑克规则。假设这种类型的扑克游戏正在进行，让我们编写一个函数来发牌。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="0606" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我没有把棋盘上的发牌包在一个循环中，而是把它展开，让它非常清楚地显示出正在发生的事情。将牌发给玩家后，第一张<strong class="kw ip"> deck.pop() </strong>是烧牌，然后连续三张<strong class="kw ip"> board.push(deck.pop()) </strong>是翻牌。接下来的<strong class="kw ip"> deck.pop() </strong>又是一张烧卡，然后是转卡，最后对河卡重复同样的模式。</p><p id="88da" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">该函数还可以处理一种叫做奥马哈的扑克游戏的发牌，在这种游戏中，玩家收到四张底牌，而不是两张。他们需要使用其中两张底牌和三张牌来完成这手牌。</p><h2 id="4b45" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">找到最好的牌</h2><p id="b6a1" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">棋盘上有五张公共牌和两张底牌，我们需要一个程序来找出所有牌中最好的一手。在德州扑克中，你可以使用1张、2张底牌或不使用底牌来凑成一手牌。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="ffad" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">纸牌被放在棋盘的复制品上，然后被推到一排手牌中。包括作为可能的一手牌的棋盘，该函数产生21种可能的组合。我相信可能有一个更优雅的方式来完成这一点，但在这个时候，我想不起来了。所以现在，对循环的强力<em class="ne">就足够了。</em></p><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="e32c" class="lq lr io mw b gz na nb l nc nd">For Texas Hold 'Em rules:</span><span id="3c19" class="lq lr io mw b gz nh nb l nc nd">The board is 1 possible hand</span><span id="7494" class="lq lr io mw b gz nh nb l nc nd">The first set of loops iterates through each index and replaces it with each hole card, producing 10 hands</span><span id="e26d" class="lq lr io mw b gz nh nb l nc nd">The second set of loops replaces the board with 2 hole cards, resulting in another 10 hands</span></pre><p id="34f9" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">以下是寻找奥马哈规则最佳牌型的方法。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="69ab" class="lq lr io mw b gz na nb l nc nd">With Omaha, the loops iterates through the 4 hole cards and replaces 2 of the board cards, resulting in 60 different hands. This increases the difficulty of identifying combinations of hands, causing Omaha players to adopt a different betting strategy.</span></pre><p id="5024" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这些函数将在我们进行一轮游戏并决定获胜者时使用。</p><h2 id="cad1" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">发牌</h2><p id="0097" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">既然我们已经有了发牌和确定最佳手牌的方法，那么让我们一起来发牌吧。这个函数应该能够处理玩家数量、底牌和评估最佳手牌组合的变化。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="e74a" class="lq lr io mw b gz na nb l nc nd">The <strong class="mw ip">findBestHand</strong> parameter is assuming that a function will be passed in based on the required evaluation for the game being played. With this strategy, the dealRound function can support various rules for different variations of poker.</span></pre><p id="3c78" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">现在让我们用一个函数把它们放在一起，为一个特定类型的游戏发一轮扑克。第一次德州扑克。注意到<em class="ne"> holeCards </em>属性被设置为<strong class="kw ip"> 2 </strong>并且<em class="ne"> findBestHand </em>属性被设置为<strong class="kw ip"> findBestHandTexasHoldEm </strong>。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="c5b9" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这是一轮奥马哈的玩法。注意<em class="ne"> holeCards </em>属性被设置为<strong class="kw ip"> 4 </strong>并且<em class="ne"> findBestHand </em>属性被切换为<strong class="kw ip"> findBestHandOmaha </strong>。</p><figure class="ke kf kg kh gu ki"><div class="bz fq l di"><div class="nf ng l"/></div></figure><pre class="ke kf kg kh gu mv mw mx my aw mz bi"><span id="b8e9" class="lq lr io mw b gz na nb l nc nd">If you copy all of the gists code into a single file and then add either:</span><span id="7138" class="lq lr io mw b gz nh nb l nc nd">dealTexasHoldEm(9)</span><span id="f687" class="lq lr io mw b gz nh nb l nc nd">or</span><span id="4bf8" class="lq lr io mw b gz nh nb l nc nd">dealOmaha(9)</span><span id="c8eb" class="lq lr io mw b gz nh nb l nc nd">Passing in 9 equates to 9 players. If you execute the file, you should see something like this for Texas Hold 'Em:</span><span id="7a94" class="lq lr io mw b gz nh nb l nc nd">[<br/>  {<br/>    name: "Player 5",<br/>    hole: "8♣︎ 3♣︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 6, 19],<br/>      suits: [2, 1, 0, 2],<br/>      values: [0, 0, 0, 0, 0, 0, 3, 0, 1, 1, 0, 0, 0],<br/>      rankValue: 4003147264,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: true,<br/>        two_pairs: false,<br/>        pair: false,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Trips",<br/>      display: "J♠︎ T♣︎ 8♠︎ 8♣︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 1",<br/>    hole: "J♥︎ 3♠︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 35, 19],<br/>      suits: [1, 1, 1, 2],<br/>      values: [0, 0, 0, 0, 0, 0, 2, 0, 1, 2, 0, 0, 0],<br/>      rankValue: 3018874880,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: true,<br/>        pair: false,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Two Pairs",<br/>      display: "J♠︎ T♣︎ 8♠︎ J♥︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 8",<br/>    hole: "5♠︎ 7♣︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 42, 45, 3, 19],<br/>      suits: [1, 1, 0, 3],<br/>      values: [0, 0, 0, 2, 0, 0, 2, 0, 0, 1, 0, 0, 0],<br/>      rankValue: 3002360320,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: true,<br/>        pair: false,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Two Pairs",<br/>      display: "J♠︎ 5♠︎ 8♠︎ 5♣︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 2",<br/>    hole: "A♣︎ 6♥︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 12, 19],<br/>      suits: [2, 1, 0, 2],<br/>      values: [0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 1],<br/>      rankValue: 2002106880,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: false,<br/>        pair: true,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Pair",<br/>      display: "J♠︎ T♣︎ 8♠︎ A♣︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 3",<br/>    hole: "9♥︎ A♦︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 25, 19],<br/>      suits: [1, 2, 0, 2],<br/>      values: [0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 1],<br/>      rankValue: 2002106880,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: false,<br/>        pair: true,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Pair",<br/>      display: "J♠︎ T♣︎ 8♠︎ A♦︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 7",<br/>    hole: "2♥︎ Q♣︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 10, 19],<br/>      suits: [2, 1, 0, 2],<br/>      values: [0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 1, 0, 0],<br/>      rankValue: 2002100736,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: false,<br/>        pair: true,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Pair",<br/>      display: "J♠︎ T♣︎ 8♠︎ Q♣︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 9",<br/>    hole: "Q♦︎ 7♠︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 23, 19],<br/>      suits: [1, 2, 0, 2],<br/>      values: [0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 1, 0, 0],<br/>      rankValue: 2002100736,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: false,<br/>        pair: true,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Pair",<br/>      display: "J♠︎ T♣︎ 8♠︎ Q♦︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 4",<br/>    hole: "2♦︎ 6♠︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 43, 19],<br/>      suits: [1, 1, 0, 3],<br/>      values: [0, 0, 0, 0, 1, 0, 2, 0, 1, 1, 0, 0, 0],<br/>      rankValue: 2002098720,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: false,<br/>        pair: true,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Pair",<br/>      display: "J♠︎ T♣︎ 8♠︎ 6♠︎ 8♦︎",<br/>    },<br/>  },<br/>  {<br/>    name: "Player 6",<br/>    hole: "3♦︎ 2♠︎",<br/>    board: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    bestHand: {<br/>      hand: [48, 8, 45, 3, 19],<br/>      suits: [2, 1, 0, 2],<br/>      values: [0, 0, 0, 1, 0, 0, 2, 0, 1, 1, 0, 0, 0],<br/>      rankValue: 2002098704,<br/>      ranks: {<br/>        royal_flush: false,<br/>        straight_flush: false,<br/>        quads: false,<br/>        full_house: false,<br/>        flush: false,<br/>        straight: false,<br/>        trips: false,<br/>        two_pairs: false,<br/>        pair: true,<br/>        high_card: true,<br/>      },<br/>      rankDescription: "Pair",<br/>      display: "J♠︎ T♣︎ 8♠︎ 5♣︎ 8♦︎",<br/>    },<br/>  },<br/>]</span></pre><h2 id="e2d9" class="lq lr io bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">后续步骤</h2><p id="b4ab" class="pw-post-body-paragraph ku kv io kw b kx mj jp kz la mk js lc ld ml lf lg lh mm lj lk ll mn ln lo lp ih bi translated">如果您能够通读发布的全部代码，您会注意到没有使用一个“If”、“switch”或三元语句。改变设计以利用对象映射和逻辑操作符消除了嵌套条件分支的混乱，反过来减少了行数，形成了一个干净的自顶向下的执行结构。</p><p id="c38a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">这里写的函数，可以作为一个跳板，开个好头，建立一个处理卡和等级的核心。要构建一个全功能的扑克游戏，需要额外的功能和机制:下注回合、底池管理、筹码管理、玩家管理和用户界面。如果在互联网上操作，那么一个成熟的扑克应用程序需要网络、API和状态管理代码。</p><p id="5f11" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">在编程中，解决一个问题总是有多种方法，有些是非传统的。在编写一行代码之前，花一些时间来计划一种方法。敢于超越你最初的倾向。</p><p id="1f1a" class="pw-post-body-paragraph ku kv io kw b kx ky jp kz la lb js lc ld le lf lg lh li lj lk ll lm ln lo lp ih bi translated">我持续的挑战是编写最少的代码，利用通过例子、文章和大量实验学到的策略。走出你的舒适区，你可能会发现一条捷径或新技术，并在此过程中成为一名更好的软件开发人员。</p></div></div>    
</body>
</html>