<html>
<head>
<title>How to implement useEffect() by recreating its Automatic Update feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过重新创建useEffect()的自动更新特性来实现它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-how-to-implement-the-useeffect-hook-by-re-creating-the-automatic-update-feature-709999463656?source=collection_archive---------5-----------------------#2019-11-25">https://javascript.plainenglish.io/understanding-how-to-implement-the-useeffect-hook-by-re-creating-the-automatic-update-feature-709999463656?source=collection_archive---------5-----------------------#2019-11-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bde2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在我之前的博客中，我接触了一下<code class="fe kc kd ke kf b">useEffect()</code>钩子的表面，在本地存储中设置了一个编码令牌。我决定更深入地实现这个钩子，作为生命周期方法的替代。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/6d262cbd124bcf456ed63bad280a4951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_WowkY6mRopV1CMjHN1EoA.jpeg"/></div></div></figure><p id="8a81" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了简洁和熟悉起见，演示使用<code class="fe kc kd ke kf b">useEffect()</code>挂钩的代码将是我的<a class="ae lo" href="https://medium.com/javascript-in-plain-english/update-feature-while-double-checking-assumptions-8c42e30564d6" rel="noopener">通过创建自动更新功能完全理解React</a>和我的<a class="ae lo" href="https://medium.com/swlh/custom-routes-with-mirage-js-3d0cc4124897" rel="noopener">用Mirage JS </a>博客定制路线中使用的代码的组合。更新功能博客包含要替换的<code class="fe kc kd ke kf b">componentDidMount</code>和<code class="fe kc kd ke kf b">componentDidUpdate</code>生命周期方法，而Mirage JS博客将利用触发这些生命周期方法的自定义路线。如果一开始这一切听起来很混乱，不要担心，我会一步一步地分解每件事。</p><h1 id="90b7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">App.js的起点</h1><p id="e7b2" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">让我们从一些代码开始。这段代码对我的更新功能博客来说应该非常熟悉。到目前为止，唯一的主要区别是我通过Mirage JS使用模拟API来分离数据。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Initial App.js</figcaption></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Initial MovieCard.js</figcaption></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Initial Server.js</figcaption></figure><p id="9346" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在App.js中，我使用<code class="fe kc kd ke kf b">useEffect()</code>钩子作为<code class="fe kc kd ke kf b">componentDidMount</code>来获取我的模拟服务器中的后端数据。请密切注意，我在钩子中还有第二个参数<code class="fe kc kd ke kf b">[]</code>。在<a class="ae lo" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">反应使用效果文档</a>中，</p><blockquote class="ms mt mu"><p id="a7c4" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated"><strong class="ku io">注</strong></p><p id="6faa" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated">如果使用这种优化，确保数组包含来自组件范围(如props和state)的所有值，这些值会随着时间的推移而改变，并由效果使用。否则，您的代码将引用以前呈现的过时值。了解更多关于<a class="ae lo" href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" rel="noopener ugc nofollow" target="_blank">如何处理函数</a>和<a class="ae lo" href="https://reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often" rel="noopener ugc nofollow" target="_blank">当数组变化太频繁时该做什么</a>。</p><p id="a5ca" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated">如果您想运行一个效果并只清理一次(在挂载和卸载时)，您可以传递一个空数组(<code class="fe kc kd ke kf b">[]</code>)作为第二个参数。这告诉React你的效果不依赖于道具或状态的任何值，所以它不需要重新运行。这不是作为特例来处理的——它直接源于依赖关系数组的工作方式。</p><p id="31eb" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated">如果你传递一个空数组(<code class="fe kc kd ke kf b">[]</code>)，效果里面的道具和状态都会有初始值。而通过<code class="fe kc kd ke kf b">[]</code>作为第二个论证更接近大家熟悉的<code class="fe kc kd ke kf b">componentDidMount</code>和<code class="fe kc kd ke kf b">componentWillUnmount</code>心智模型，通常会有<a class="ae lo" href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" rel="noopener ugc nofollow" target="_blank">更好的</a> <a class="ae lo" href="https://reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often" rel="noopener ugc nofollow" target="_blank">解决方案</a>来避免过于频繁的重新运行效果。此外，不要忘记React将运行<code class="fe kc kd ke kf b">useEffect</code>推迟到浏览器完成绘制之后，所以做额外的工作不是问题。</p></blockquote><p id="7cd6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果没有第二个参数<code class="fe kc kd ke kf b">[]</code>，那么<code class="fe kc kd ke kf b">useEffect()</code>钩子将总是被调用(类似于一个无限循环)。</p><p id="5f98" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">MovieCard.js gist中没有发生什么，因为它只是根据来自其父组件(即App.js)的数据来格式化和显示数据。gist包含<code class="fe kc kd ke kf b">handleChange</code>函数，该函数使MovieCard组件成为一个受控组件。对于Server.js要点，我遵循了Mirage JS网站上的<a class="ae lo" href="https://miragejs.com/quickstarts/react/development" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>。</p><p id="a8ff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">重复一下，我们仍然在重新创建我的更新功能博客中显示的相同功能，但这次我们将使用<code class="fe kc kd ke kf b">useEffect()</code>钩子。现在我们已经做好了基础工作，让我们开始实施吧！</p><h1 id="c7de" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">创建onSubmit函数</h1><p id="06d7" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">作为该功能的快速复习，每当我们改变一部电影的描述时，所有同名电影也应该自动改变。让我们创建提交函数，它将向后端提交新的描述。提交函数将在App组件中，因为该组件知道所有处于<code class="fe kc kd ke kf b">theater</code>状态的电影。</p><p id="8262" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">首先，让我们将<code class="fe kc kd ke kf b">onSubmit</code>事件监听器添加到MovieCard组件的表单中。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Adding the onSubmit event listener</figcaption></figure><p id="846d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来，我们给App.js添加提交功能。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Adding the submitting function</figcaption></figure><p id="1487" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe kc kd ke kf b">handleSubmit</code>函数是对后端的标准更新请求。注意第20行，这是到我的模拟服务器的自定义路由。因为定制路由还没有在模拟服务器中创建，所以让我们来创建它。</p><h1 id="d4ca" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">创建自定义路线和逻辑</h1><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Adding the custom route to the mock server</figcaption></figure><p id="0ab6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在第47行，我添加了与App.js的第20行中显示的URL相匹配的自定义路由。在更新特性博客中，我通过迭代电影数组更新了描述，并在电影标题相同的地方更改了电影描述。我们可以在我自定义路由函数处理程序中利用相同的逻辑。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Adding the function handler in the custom route</figcaption></figure><p id="43f9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第54–64行是更新描述的逻辑。这实际上是从更新功能博客中复制和粘贴的。添加第50、51和67行是为了支持更新逻辑。第50行获取我们想要更新的确切的<code class="fe kc kd ke kf b">theater</code>模型，第51行获取带有ES6对象析构的App.js <code class="fe kc kd ke kf b">handleSubmit</code>函数中更新请求主体的信息，第67行使用第54–64行的新剧院数据更新所选的剧院。第50、51和67行都使用了Mirage JS自带的函数(即分别为<code class="fe kc kd ke kf b">.attrs</code>、<code class="fe kc kd ke kf b">request.requestBody</code>和<code class="fe kc kd ke kf b">.update()</code>)。</p><p id="7e8f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">既然theater已经更新，我想从前端再次获取它以检索新数据。因为我将使用与之前相同的路径和逻辑，所以我可以从<code class="fe kc kd ke kf b">useEffect()</code>钩子体中提取逻辑，并创建一个单独的函数来获取。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Adding the fetch function</figcaption></figure><p id="7134" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来，我需要以某种方式触发<code class="fe kc kd ke kf b">useEffect</code>钩子，以便重新运行fetch函数。</p><h1 id="273c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">将componentDidMount和componentDidUpdate与useEffect结合使用</h1><p id="7dd6" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">目前在我的<code class="fe kc kd ke kf b">useEffect()</code>钩子中，第二个参数是一个空数组。在通读了useEffect文档之后，我找到了再次触发我的<code class="fe kc kd ke kf b">useEffect()</code>钩子的方法。摘自文件:</p><blockquote class="ms mt mu"><p id="b688" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated">在某些情况下，每次渲染后清除或应用效果可能会导致性能问题。在类组件中，我们可以通过在<code class="fe kc kd ke kf b">componentDidUpdate</code>中编写一个与<code class="fe kc kd ke kf b">prevProps</code>或<code class="fe kc kd ke kf b">prevState</code>的额外比较来解决这个问题:</p><p id="9a01" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated"><code class="fe kc kd ke kf b">componentDidUpdate(prevProps, prevState) {<br/> if (prevState.count !== this.state.count) {<br/> document.title = `You clicked ${this.state.count} times`;<br/> }<br/>}</code></p><p id="f9dc" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated">这个需求很常见，它被内置到了<code class="fe kc kd ke kf b">useEffect</code> Hook API中。如果某些值在重新渲染之间没有改变，你可以告诉React to <em class="in"> skip </em>应用效果。为此，将一个数组作为可选的第二个参数传递给<code class="fe kc kd ke kf b">useEffect</code>:</p><p id="e120" class="ks kt mv ku b kv kw jo kx ky kz jr la mw lc ld le mx lg lh li my lk ll lm ln ig bi translated"><code class="fe kc kd ke kf b">useEffect(() =&gt; {<br/> document.title = `You clicked ${count} times`;<br/>}, [count]); // Only re-run the effect if count changes</code></p></blockquote><p id="2df3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在我们的例子中，我们感兴趣的变化值是电影描述。但是，由于以下原因，不可能使用<code class="fe kc kd ke kf b">theater</code>状态作为第二个可选参数。</p><p id="387b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">假设我们想使用<code class="fe kc kd ke kf b">[ theater.movies ]</code>作为第二个参数。这将导致空错误。<code class="fe kc kd ke kf b">theater</code>状态是<code class="fe kc kd ke kf b">null</code>，因为初始状态是用<code class="fe kc kd ke kf b">const [theater, setTheater] = useState()</code>的空括号定义的。</p><p id="4b6b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">那么用<code class="fe kc kd ke kf b">[ theater ]</code>呢？这将导致无限的获取循环。当组件挂载时，<code class="fe kc kd ke kf b">useEffect()</code>钩子将触发(第一次)，调用<code class="fe kc kd ke kf b">fetchTheater</code>函数。解析获取请求后，<code class="fe kc kd ke kf b">setTheater</code>将为解析获取的解析数据设置新的<code class="fe kc kd ke kf b">theater</code>状态。由于<code class="fe kc kd ke kf b">theater</code>状态改变，再次触发<code class="fe kc kd ke kf b">useEffect()</code>效果(第二次)。这将调用<code class="fe kc kd ke kf b">fetchTheater</code>功能，并且<code class="fe kc kd ke kf b">setTheater</code>将再次设置新的<code class="fe kc kd ke kf b">theater</code>状态(即使数据根本没有改变)。由于<code class="fe kc kd ke kf b">theater</code>状态改变，<code class="fe kc kd ke kf b">useEffect()</code>挂钩将再次触发(第三次)。这就产生了一个无限循环，因为<code class="fe kc kd ke kf b">theater</code>状态是不断变化的，尽管数据每次都是相同的。</p><p id="6f3d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了避开这些场景，一个新的变量被创造出来，它的唯一目的是触发<code class="fe kc kd ke kf b">useEffect()</code>成为<code class="fe kc kd ke kf b">componentDidUpdate</code>。让我们称这个新变量为<code class="fe kc kd ke kf b">toggle.</code></p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Creating a new variable to trigger useEffect()</figcaption></figure><p id="cb04" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">由于<code class="fe kc kd ke kf b">toggle</code>的目的是触发<code class="fe kc kd ke kf b">useEffect()</code>钩子，<code class="fe kc kd ke kf b">toggle</code>被用作我们的第二个参数。<code class="fe kc kd ke kf b">toggle</code>的初始状态无关紧要，因为我们只关心改变<code class="fe kc kd ke kf b">toggle</code>的状态，而不是值本身。更新后的<code class="fe kc kd ke kf b">useEffect()</code>挂钩现在应该如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Updated the useEffect() hook</figcaption></figure><p id="46c5" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了触发<code class="fe kc kd ke kf b">useEffect()</code>，我们需要通过<code class="fe kc kd ke kf b">setToggle</code>改变<code class="fe kc kd ke kf b">toggle</code>的状态。下一个问题是何时改变<code class="fe kc kd ke kf b">toggle</code>状态。由于<code class="fe kc kd ke kf b">fetchTheater</code>函数获取特定的剧院，我们应该在更新该剧院后改变<code class="fe kc kd ke kf b">toggle</code>的状态。这发生在<code class="fe kc kd ke kf b">handleSubmit</code>函数中解决更新获取请求之后。所以看起来我们应该在解决更新获取请求后改变<code class="fe kc kd ke kf b">toggle</code>的状态。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Updated the handleSubmit function in order to change the toggle’s state</figcaption></figure><p id="9630" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">将所有内容拼凑在一起后，完成的App.js如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Completed App.js</figcaption></figure><h1 id="7514" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">MovieCard.js中的useEffect()</h1><p id="1783" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">与更新功能博客中发生的类似，MovieCard.js也需要一个<code class="fe kc kd ke kf b">useEffect()</code>钩子来捕获任何电影描述更新。这类似于它也需要<code class="fe kc kd ke kf b">componentDidUpdate</code>来反映这些变化。通过遵循App组件中的<code class="fe kc kd ke kf b">useEffect()</code>钩子的相同逻辑，在MovieCard组件中实现了一个<code class="fe kc kd ke kf b">useEffect()</code>钩子。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Added the useEffect() hook to reflect movie description changes</figcaption></figure><p id="1335" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">第8–12行实现了<code class="fe kc kd ke kf b">useEffect()</code>钩子。在钩子的主体中，如果需要的话，我使用了<code class="fe kc kd ke kf b">setDescription</code>来更新电影描述。我只想在父组件(即App.js)中来自<code class="fe kc kd ke kf b">theater</code>状态的电影描述发生变化时触发这个挂钩，因此第二个参数是<code class="fe kc kd ke kf b">[ props.movie.description ]</code>。</p><p id="dd69" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个最终实现中，我们使用钩子重新创建了自动更新特性！</p><h1 id="7719" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">关键外卖</h1><p id="3a69" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">最初，当我切换到使用<code class="fe kc kd ke kf b">useEffect()</code>钩子时，我认为在需要更新的组件上使用另一个<code class="fe kc kd ke kf b">useEffect()</code>钩子(例如，MovieCard.js)来代替更新嵌套对象中的键值对时的<code class="fe kc kd ke kf b">componentDidUpdate</code>(例如，<code class="fe kc kd ke kf b">theater</code>)会有所帮助。在此示例之后，情况并非如此。嵌套对象中对其他组件有下游影响的更新必须单独考虑。</p></div></div>    
</body>
</html>