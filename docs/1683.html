<html>
<head>
<title>How Prototypal Inheritance works in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的原型继承是如何工作的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-prototypal-inheritance-works-in-javascript-and-how-to-convert-it-to-class-based-inheritance-632e31e6350d?source=collection_archive---------3-----------------------#2020-04-14">https://javascript.plainenglish.io/how-prototypal-inheritance-works-in-javascript-and-how-to-convert-it-to-class-based-inheritance-632e31e6350d?source=collection_archive---------3-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="95ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何将其转换为基于类的继承</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c80bf674b2745b7cfda2db93c49ac034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zt8_1US8hq0MltBm"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@bharat_patil_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bharat Patil</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="26aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在从<code class="fe ls lt lu lv b">prototypal inheritance</code>开始之前，让我们先了解一下<code class="fe ls lt lu lv b">prototype</code>是什么。</p><blockquote class="lw lx ly"><p id="0b14" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">JavaScript中的所有对象，如<code class="fe ls lt lu lv b">Array</code>、<code class="fe ls lt lu lv b">Boolean</code>、<code class="fe ls lt lu lv b">Date</code>等，都继承了它们原型的属性和方法。</p></blockquote><p id="f473" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Object</code>在原型链的顶端意味着所有其他对象从<code class="fe ls lt lu lv b">Object.prototype</code>继承它们的属性和方法</p><p id="9a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有<code class="fe ls lt lu lv b">Person</code>对象构造函数</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="f5d7" class="mh mi iq lv b gy mj mk l ml mm">function Person(name, age) {<br/> this.name = name;<br/> this.age = age;<br/>}</span></pre><p id="2884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们如下创建<code class="fe ls lt lu lv b">Person</code>的对象</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="fd15" class="mh mi iq lv b gy mj mk l ml mm">const person1 = new Person("David", 30);<br/>const person2 = new Person("John", 35);</span><span id="6ab3" class="mh mi iq lv b gy mn mk l ml mm">console.log(person1); // {name: "David", age: 30}<br/>console.log(person2); // {name: "John", age: 35}</span></pre><p id="ea22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想给<code class="fe ls lt lu lv b">Person</code>对象添加另一个属性，我们可以像这样给一个单独的对象添加:</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="593e" class="mh mi iq lv b gy mj mk l ml mm">person1.gender = 'Male';</span></pre><p id="679a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这只会将该属性添加到<code class="fe ls lt lu lv b">person1</code>对象中。</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="57c5" class="mh mi iq lv b gy mj mk l ml mm">console.log(person1.gender); // Male<br/>console.log(person2.gender); // undefined</span></pre><p id="f5e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要将属性添加到<code class="fe ls lt lu lv b">Person</code>对象本身，我们必须在创建对象之前将其添加到其原型，这样它将对其所有对象可用。</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="c08e" class="mh mi iq lv b gy mj mk l ml mm">Person.prototype.gender = 'Male';</span><span id="5639" class="mh mi iq lv b gy mn mk l ml mm">const person1 = new Person("David", 30);<br/>const person2 = new Person("John", 35);</span><span id="de32" class="mh mi iq lv b gy mn mk l ml mm">console.log(person1.gender); // Male<br/>console.log(person2.gender); // Male</span></pre><p id="31c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以向<code class="fe ls lt lu lv b">Person</code>原型添加方法</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="b09a" class="mh mi iq lv b gy mj mk l ml mm">Person.prototype.display = function() {<br/> console.log(this.name, this.age);<br/>};</span><span id="b173" class="mh mi iq lv b gy mn mk l ml mm">const person1 = new Person("David", 30);<br/>const person2 = new Person("John", 35);</span><span id="cb81" class="mh mi iq lv b gy mn mk l ml mm">person1.display(); // David 30<br/>person2.display(); // John 35</span></pre><p id="636b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，要向对象添加任何属性或方法，我们需要将其添加到其原型中。</p><p id="4ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们比较<code class="fe ls lt lu lv b">person1</code>和<code class="fe ls lt lu lv b">person2</code>显示方法，我们会看到它返回true</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="5553" class="mh mi iq lv b gy mj mk l ml mm">console.log(person1.display === person2.display) // true</span></pre><p id="047f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">它返回true，因为在内存中只有显示函数的一个副本，因为我们将该方法添加到了它的原型中，所以它由所有对象共享。</em></p><p id="bc14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看将它直接添加到<code class="fe ls lt lu lv b">Person</code>构造函数中会发生什么</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="e075" class="mh mi iq lv b gy mj mk l ml mm">function Person(name, age) {<br/> this.name = name;<br/> this.age = age;<br/> this.display = function() {<br/>  console.log(this.name, this.age);<br/> };<br/>}</span><span id="a6c6" class="mh mi iq lv b gy mn mk l ml mm">const person1 = new Person("David", 30);<br/>const person2 = new Person("John", 35);</span><span id="0f88" class="mh mi iq lv b gy mn mk l ml mm">person1.display(); // David 30<br/>person2.display() // John 35</span></pre><p id="368c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们比较显示方法</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="ff38" class="mh mi iq lv b gy mj mk l ml mm">console.log(person1.display === person2.display) // false</span></pre><p id="f0d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在它显示false，因为我们已经将该方法直接添加到构造函数中，从<code class="fe ls lt lu lv b">Person</code>创建的每个对象都有自己的函数副本，所以内存中有两个显示函数副本，随着我们创建更多的对象，内存中显示函数副本的数量也会增加。</p><p id="e611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这是一个不好的做法，不推荐直接在构造函数中创建方法，我们应该把它们添加到原型中。</p><p id="0494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们有了一些原型的基本知识，让我们现在来理解原型继承。</p><p id="9f79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">原型遗传</strong></p><p id="e9f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从上面同样的<code class="fe ls lt lu lv b">Person</code>例子开始</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="0f1d" class="mh mi iq lv b gy mj mk l ml mm">function Person(name, age) {<br/> this.name = name;<br/> this.age = age;<br/>}</span><span id="8a96" class="mh mi iq lv b gy mn mk l ml mm">Person.prototype.display = function() {<br/> console.log(this.name, this.age);<br/>};</span></pre><p id="142e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建<code class="fe ls lt lu lv b">Employee</code>构造函数，它将继承Person的属性和方法</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="2ab3" class="mh mi iq lv b gy mj mk l ml mm">function Employee(name, age, salary) {<br/> Person.call(this, name, age);<br/> this.salary = salary;<br/>}</span><span id="3cbc" class="mh mi iq lv b gy mn mk l ml mm">const emp = new Employee('Mike', 20, 4000);</span></pre><p id="a418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用<code class="fe ls lt lu lv b">Person.call</code>函数来调用<code class="fe ls lt lu lv b">Person</code>的构造函数，并将<code class="fe ls lt lu lv b">name</code>和<code class="fe ls lt lu lv b">age</code>传递给它</p><p id="ec0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看<code class="fe ls lt lu lv b">emp</code>包含了什么</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="3054" class="mh mi iq lv b gy mj mk l ml mm">console.log(emp); // {name: "Mike", age: 20, salary: 4000}</span></pre><p id="2762" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，它包含了<code class="fe ls lt lu lv b">Person</code>的所有属性加上它自己的属性</p><p id="3a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用<code class="fe ls lt lu lv b">emp</code>对象调用显示方法。</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="9454" class="mh mi iq lv b gy mj mk l ml mm">emp.display(); //  Error: emp.display is not a function</span></pre><p id="6a1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么我们会得到这个错误？</p><p id="c456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们只提到了使用<code class="fe ls lt lu lv b">Person.call(this, name, age)</code>继承<code class="fe ls lt lu lv b">Person</code>的属性</p><p id="8892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了继承方法，我们需要链接原型，然后创建一个对象</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="b699" class="mh mi iq lv b gy mj mk l ml mm">Employee.prototype = Object.create(Person.prototype);</span><span id="7e18" class="mh mi iq lv b gy mn mk l ml mm">const emp = new Employee('Mike', 20, 4000);<br/>emp.display(); // Mike 20</span></pre><p id="1e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们检查一下<code class="fe ls lt lu lv b">Employee</code>的类型，我们可以使用构造函数属性来检查它</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="62df" class="mh mi iq lv b gy mj mk l ml mm">console.log(emp.constructor) // Person<br/>console.log(Employee.prototype.constructor) // Person</span></pre><p id="52f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它打印出<code class="fe ls lt lu lv b">Person</code>，这是错误的，因为我们知道，它应该是<code class="fe ls lt lu lv b">Employee</code>。<code class="fe ls lt lu lv b">constructor</code>属性应该总是返回正确的类型。</p><p id="729e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设，我们有一个数组</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="cfff" class="mh mi iq lv b gy mj mk l ml mm">const numbers = [1, 2, 3, 4];</span><span id="4288" class="mh mi iq lv b gy mn mk l ml mm">console.log(typeof numbers); // "object"</span></pre><p id="7695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到object，因为JavaScript中的每个数组都是一个对象，所以要得到它的正确类型，我们可以使用返回正确类型的<code class="fe ls lt lu lv b">constructor</code>属性。</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="5838" class="mh mi iq lv b gy mj mk l ml mm">console.log(numbers.constructor) // Array<br/>console.log(numbers.constructor === Array) // true</span></pre><p id="8eb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以要解决<code class="fe ls lt lu lv b">Employee</code>构造函数的问题，我们需要改变它的构造函数类型</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="d556" class="mh mi iq lv b gy mj mk l ml mm">Employee.prototype.constructor = Employee;</span><span id="19a7" class="mh mi iq lv b gy mn mk l ml mm">console.log(emp.constructor) // Employee<br/>console.log(Employee.prototype.constructor) // Employee</span></pre><p id="bad9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们得到了正确的结果。</p><p id="7f21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的原型继承将如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="4fd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，即使对于简单的原型继承，我们也必须添加许多额外的代码。</p><p id="8e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以ES6增加了类语法，允许我们以一种简单的方式实现同样的功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="11b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，与原型继承相比，基于类的语法简短且易于理解。</p><p id="717e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>最后的类使用原型继承本身。只是，我们不需要担心它</p><p id="253e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。我希望你学到了新东西。</p><p id="c13a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">别忘了订阅我的每周简讯，里面有惊人的技巧、诀窍和文章，直接在这里的收件箱里</strong> <a class="ae kv" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">。</strong> </a></p></div></div>    
</body>
</html>