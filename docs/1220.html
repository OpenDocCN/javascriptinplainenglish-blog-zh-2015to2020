<html>
<head>
<title>What are Sets in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的集合是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-set-object-12039b62c628?source=collection_archive---------10-----------------------#2020-02-13">https://javascript.plainenglish.io/the-set-object-12039b62c628?source=collection_archive---------10-----------------------#2020-02-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/6cc9250e8457cca08e3f00fb714d6cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*PgxxbIGV-jjBPTTcVeJQ2A.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">There can only be one...</figcaption></figure><p id="522c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">刚碰到一个对JavaScript有用的工具:<code class="fe kt ku kv kw b">Set</code>。从来没有人教过我，我也没有在文献中发现它…直到现在。也许它不常用，或者我只是错过了机会。我确实读到过那是一个<code class="fe kt ku kv kw b">ES6</code>附加物。在最近进行代码挑战时，我发现挑战通常需要使用一组独特的值，通常是从数组中提取的。在<code class="fe kt ku kv kw b">Ruby</code>中，有一个名为<code class="fe kt ku kv kw b"><a class="ae kx" href="https://ruby-doc.com/core/Array.html#method-i-uniq" rel="noopener ugc nofollow" target="_blank">.uniq</a></code>的内置方法，它产生一个被调用数组的副本，所有重复的值都被删除。例如:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="d2be" class="lg lh in kw b gy li lj l lk ll">arr = [1, 1, 2, 2, 3, 3]</span><span id="fabb" class="lg lh in kw b gy lm lj l lk ll">arr.uniq<br/># =&gt; [1, 2, 3]</span></pre><p id="b26b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我一直在用<code class="fe kt ku kv kw b">JavaScript</code>写，没有这样的内置方法。有多种方法可以将数组转换为唯一值的数组。两个流行的选择是利用<code class="fe kt ku kv kw b"><a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">.filter()</a></code>或<code class="fe kt ku kv kw b"><a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">.reduce()</a></code>，但是这些可能需要额外的方法，并且很冗长。另一种选择是利用<code class="fe kt ku kv kw b">Set</code>！</p><p id="b49d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Set</code>是存储任何数据类型的唯一值集合的对象。原始值、对象、<code class="fe kt ku kv kw b">undefined</code>，应有尽有。阅读<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">文档</a>会很高兴，但是这里有一些关于<code class="fe kt ku kv kw b">Set</code>的主要品质的要点:</p><ul class=""><li id="3d4d" class="ln lo in jx b jy jz kc kd kg lp kk lq ko lr ks ls lt lu lv bi translated">它具有类似<code class="fe kt ku kv kw b">.size</code>的属性</li><li id="594a" class="ln lo in jx b jy lw kc lx kg ly kk lz ko ma ks ls lt lu lv bi translated">它有一个名为<code class="fe kt ku kv kw b">.has(arg)</code>的评估方法</li><li id="0a13" class="ln lo in jx b jy lw kc lx kg ly kk lz ko ma ks ls lt lu lv bi translated">它有类似<code class="fe kt ku kv kw b">.add(arg)</code>、<code class="fe kt ku kv kw b">.delete(arg)</code>和<code class="fe kt ku kv kw b">.clear()</code>的变异方法</li><li id="2712" class="ln lo in jx b jy lw kc lx kg ly kk lz ko ma ks ls lt lu lv bi translated">它有类似<code class="fe kt ku kv kw b">.forEach(callBack)</code>和<code class="fe kt ku kv kw b">.values()</code>的迭代方法</li></ul><p id="2048" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Set</code>的实际构造移除了所有重复的值，因此这是一个非常简单的将数组转换成唯一数组的工具。香肠是这样制作的:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="d591" class="lg lh in kw b gy li lj l lk ll">// declare variable and assign value of raw array<br/>const arr = [4, 1, 1, 2, 5, 3, 4, 5, 2, 3]</span><span id="8b17" class="lg lh in kw b gy lm lj l lk ll">// construct Set and provide arr as an input argument<br/>const set = new Set(arr)</span><span id="e824" class="lg lh in kw b gy lm lj l lk ll">console.log(set)<br/>// =&gt; {4, 1, 2, 5, 3} <br/>// *note: set is bound to insertion order</span><span id="0bf6" class="lg lh in kw b gy lm lj l lk ll">// declare variable and assign values of set to new array<br/>const uniqueArr = [...set]<br/>// *note: ES6 spread operator = schwing</span><span id="7dbe" class="lg lh in kw b gy lm lj l lk ll">console.log(uniqueArr)<br/>// =&gt; [4, 1, 2, 5, 3]</span></pre><p id="2f5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，这是一个非常简单的工具，用来创建数组的唯一副本。上面的例子甚至可以简化为:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="0db1" class="lg lh in kw b gy li lj l lk ll">const arr = [4, 1, 1, 2, 5, 3, 4, 5, 2, 3]</span><span id="e783" class="lg lh in kw b gy lm lj l lk ll">const uniqueArr = [...new Set(arr)]</span><span id="20e2" class="lg lh in kw b gy lm lj l lk ll">console.log(uniqueArr)<br/>// =&gt; [4, 1, 2, 5, 3]</span></pre></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="145e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于<code class="fe kt ku kv kw b">Set</code>的另一个很酷的事情是它可以按原样操作。我最近完成了一项代码挑战，要求程序接受两个参数:</p><ol class=""><li id="77e2" class="ln lo in jx b jy jz kc kd kg lp kk lq ko lr ks mi lt lu lv bi translated">一个整数数组，<em class="mj">如</em> <code class="fe kt ku kv kw b">[n, n, n, n, n]</code></li><li id="ba14" class="ln lo in jx b jy lw kc lx kg ly kk lz ko ma ks mi lt lu lv bi translated">一个加数值，<em class="mj">如</em> <code class="fe kt ku kv kw b">k</code></li></ol><p id="9365" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并返回一个整数，该整数表示数组中能够在此等式<code class="fe kt ku kv kw b">n + k = n</code>内成功求值的<em class="mj">唯一</em>对的数量。</p><p id="c180" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe kt ku kv kw b">Set</code>创建输入数组的唯一副本的能力是一个有用的快捷方式，它提供了一个集合或值的集合，更容易操作，并且没有必要从集合中创建新的数组。</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="2175" class="lg lh in kw b gy li lj l lk ll">const arr = [1, 2, 3, 4, 5, 6]</span><span id="d1c9" class="lg lh in kw b gy lm lj l lk ll">function findAddendSumPairs(arr, k) {<br/>  const set = new Set(arr)<br/>  const pairs = []</span><span id="9b82" class="lg lh in kw b gy lm lj l lk ll">  for (n of set) {<br/>    if (set.has(n - k)) pairs.push([n, n - k])<br/>  }<br/>  console.log('pairs', pairs)<br/>  return pairs.length<br/>}</span><span id="fba7" class="lg lh in kw b gy lm lj l lk ll">findAddendSumPairs(arr, 2)<br/>// =&gt; 4<br/>// =&gt; pairs [[3, 1], [4, 2], [5, 3], [6, 4]]</span></pre><p id="ae0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且，如果您真的想坚持使用数组，这也是可行的:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="c07e" class="lg lh in kw b gy li lj l lk ll">const arr = [6, 6, 1, 5, 10, 0, -5]</span><span id="202f" class="lg lh in kw b gy lm lj l lk ll">function findAddendSumPairs(arr, k) {<br/>  const uArr = [...new Set(arr)]<br/>  const pairs = []</span><span id="efbf" class="lg lh in kw b gy lm lj l lk ll">  for (let i = 0; i &lt; uArr.length; i++) {<br/>    if (uArr.includes(uArr[i] - k)) {<br/>      pairs.push([uArr[i], uArr[i] - k])<br/>    }<br/>  }<br/>  console.log('pairs', pairs)<br/>  return pairs.length<br/>}</span><span id="37e7" class="lg lh in kw b gy lm lj l lk ll">findAddendSumPairs(arr, -5)<br/>// =&gt; 4<br/>// =&gt; pairs [[ 1, 6], [5, 10], [0, 5], [-5, 0]]</span></pre></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="7ca2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你还没用过<code class="fe kt ku kv kw b">JavaScript</code>的<code class="fe kt ku kv kw b">Set</code>对象，那就试试吧！这是一个很酷的工具，可以很容易地创建一个独特的值集合，然后可以对其进行操作，并且还有其他实用工具。现在，今天的单词是:</p><h1 id="187f" class="mk lh in bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated"><strong class="ak">加数</strong></h1><p id="8d2d" class="pw-post-body-paragraph jv jw in jx b jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko nl kq kr ks ig bi translated">/ˈaˌdend/ <br/> <strong class="jx io">名词</strong> <br/> <em class="mj"> def。</em>加到另一个数上的数。<br/><code class="fe kt ku kv kw b">addend + addend = sum</code></p><p id="d92c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能已经注意到了本文中的“加数”这个词。在这个词汇单调、同质的时代，我喜欢学习简洁的描述词。</p><p id="f93f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kx" href="https://github.com/dangrammer" rel="noopener ugc nofollow" target="_blank">github.com/dangrammer</a><br/><a class="ae kx" href="https://www.linkedin.com/in/danieljromans/" rel="noopener ugc nofollow" target="_blank">linked.com/in/danieljromans</a><br/>T29】danromans.com</p></div></div>    
</body>
</html>