<html>
<head>
<title>Brushing up on React best practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复习React最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/brushing-up-on-react-best-practices-98ac58a74070?source=collection_archive---------8-----------------------#2020-01-02">https://javascript.plainenglish.io/brushing-up-on-react-best-practices-98ac58a74070?source=collection_archive---------8-----------------------#2020-01-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2743" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">保持你的代码干净、模块化和干燥</h2></div><p id="c3a1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">正在进行的系列</em> <a class="ae kz" href="https://medium.com/@mdazmainamin/brushing-up-on-react-basics-18ad67528b85" rel="noopener"> <em class="ky">的一部分温习React </em> </a> <em class="ky">。</em></p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/0496db2cc5be7db99024b022a4bcbd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_iybdFtfGvVeHvoS"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2838" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">容器和视图组件也称为智能和非智能组件</h1><p id="4a62" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这是迄今为止我最喜欢的反应模式，并加强了单一责任的神圣编码规则。想法很简单:将您的逻辑(即业务逻辑或获取数据)封装到一个组件(容器或智能组件)中，将您的表示逻辑封装到另一个组件(视图或哑组件)中，后者的唯一职责是获取数据并呈现html。容器组件将完成所有繁重的工作，并呈现传入所需数据的视图组件。</p><p id="ad67" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">丹·阿布拉莫夫<em class="ky">曾经</em>是这种模式的大力支持者，但是在<a class="ae kz" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React Hooks </a>发明之后，他已经缓和了他的说教。我从他的中帖(下面的链接)的更新中了解到的是，他反对<em class="ky">强制</em>这个模式，这是有道理的。永远不要强迫一种模式。只有当它有意义时才跟随它。模式就像语言一样，是实现特定结果的工具。</p><p id="bcc5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即使有挂钩，我也喜欢这种图案。我喜欢组件的<em class="ky">单一责任主体</em>的想法。智能和非智能组件意味着更小的组件，这反过来意味着它们更容易理解和编写测试。如果我想为我的表示逻辑编写测试，我应该不需要担心嘲笑一堆东西来绕过钩子。如果您将表示和核心逻辑捆绑在一起，那么无论您试图测试什么，您都必须模拟整个组件。</p><p id="72b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多向男人本人学习:<a class="ae kz" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">智能vs哑巴组件</a>。</p><h1 id="c928" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">高阶组件</h1><p id="cfd3" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">高阶分量这个名字来源于高阶函数，它以其他函数作为自变量。HoC接受一个组件作为一个<code class="fe mn mo mp mq b">arg</code>，添加一些逻辑并返回另一个添加了逻辑的组件。这个想法是“增加的逻辑”可以与任何其他组件不加区分地重用，从而保持您的代码“干燥”。HoC也融合了React的全部功能。</p><h1 id="dc57" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">受控组件</h1><p id="26f8" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">受控组件处理HTML表单元素，如<input/>和<select/>。您用一个定制组件包装这些元素，并规定它们的行为，就像当用户点击一个单选按钮时，使用包装组件的<code class="fe mn mo mp mq b">state</code>会发生什么。为什么这么问？这与更有效地从DOM获取数据有关。大概吧。从<a class="ae kz" href="https://reactjs.org/docs/forms.html" rel="noopener ugc nofollow" target="_blank">这里</a>阅读更多内容。</p><h1 id="f323" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">一个组件应该是一个独立的模块</h1><p id="365e" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">React背后的整个理念是创建可重用和模块化的组件。这确保了整个应用程序的可维护性和一致性。我喜欢把我的组件源代码、测试代码和<code class="fe mn mo mp mq b">css</code>文件放在同一个目录下。这样可以更容易地找到该组件所需的一切。你不必去野外狩猎。此外，它强化了组件是可重用性来源的观点。如果您想在不同的项目中使用您的组件，您只需复制该目录并使用该组件。或者更好的是，发布您的组件库，然后在您的整个产品套件中重用该库。</p><h1 id="f550" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">创建包装第三方组件</h1><p id="e0bf" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">这有助于整个应用程序的一致性。假设您正在使用第三方carousel组件。将其包装在自定义组件中，并添加您自己的修改和配置。现在，当您需要在其他地方再次使用它时，您只需使用。您不需要再次添加您的修改或配置。如果你想使用不同的配置，只需将它们作为道具传入即可。</p><pre class="lb lc ld le gt mr mq ms mt aw mu bi"><span id="54de" class="mv lr in mq b gy mw mx l my mz">import Carousel from 'carousel-number-one';<br/>import './myCarousel.less';</span><span id="5a77" class="mv lr in mq b gy na mx l my mz">const carouselConfig = {<br/>    alignment: 'vertical'<br/>};</span><span id="b05e" class="mv lr in mq b gy na mx l my mz">export default function MyCarousel(props) {<br/>    return (&lt;div className='my-carousel'&gt;<br/>                 &lt;Carousel config={carouselConfig}/&gt;<br/>             &lt;/div&gt;);<br/>}</span></pre><h1 id="05d4" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">使用propTypes和defaultProps</h1><p id="e2a0" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">JS的一个缺点(或者优点，取决于你问谁)是它不是类型安全的。当然，您可以使用TypeScript，但这不是本文档的一部分。你可以给你的组件增加一点类型安全并使它们更健壮的一个方法是使用<a class="ae kz" href="https://reactjs.org/docs/typechecking-with-proptypes.html" rel="noopener ugc nofollow" target="_blank"> propTypes </a>。</p><p id="0d74" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用React的静态类属性<code class="fe mn mo mp mq b">defaultProps</code>。如果没有向组件传递任何属性，组件将使用该组件。</p><h1 id="71cb" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">更新状态时，始终使用prevState</h1><p id="72df" class="pw-post-body-paragraph kc kd in ke b kf mi jo kh ki mj jr kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">很容易忘记setState是异步的，因此当前状态可能不是您所想的那样。因此，当您调用setState时，最安全的做法是使用prevState来更新较新的状态。</p><pre class="lb lc ld le gt mr mq ms mt aw mu bi"><span id="e0a9" class="mv lr in mq b gy mw mx l my mz">this.setState((prevState) =&gt; { <br/>    return { <br/>           numOfClicks: prevState.numOfClicks + 1<br/>   } <br/>});</span></pre></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="e529" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">正在进行的系列</em> <a class="ae kz" href="https://medium.com/@mdazmainamin/brushing-up-on-react-basics-18ad67528b85" rel="noopener"> <em class="ky">的一部分，温习React </em> </a> <em class="ky">。</em></p></div></div>    
</body>
</html>