<html>
<head>
<title>Node.JS and Relational Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点。JS和关系数据库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-and-relational-databases-2198152732b6?source=collection_archive---------5-----------------------#2020-08-08">https://javascript.plainenglish.io/node-js-and-relational-databases-2198152732b6?source=collection_archive---------5-----------------------#2020-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/51d3c5962c046ff8117a0b5203f8e382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*af_kLxa3TrrdhiFS"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d6e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据存储是任何计算机应用程序的重要组成部分。需要存储收集的数据以供以后分析，或者需要检索数据以生成所需的输出。存储内存的方式有很多种——文件存储(包括文本和/或二进制选项)、关系数据库、<a class="ae jz" href="https://en.wikipedia.org/wiki/NoSQL" rel="noopener ugc nofollow" target="_blank"> NoSQL </a>系统，我确定我错过了几种。</p><p id="b93f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/SQL" rel="noopener ugc nofollow" target="_blank"> SQL </a>是许多不同关系数据库管理系统(又名<em class="ky"> RDBMS </em>)共享的标准。实现的SQL有时与官方标准不同。如果您在同一个数据库平台内，这些差异不会有太大影响。然而，当您开始在不同的数据库供应商之间，甚至在同一个供应商的不同版本之间转移时，差异就变得很重要了。在关系系统和非关系系统之间转换会带来更多的工作。</p><p id="8e12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以使用特定于DB的库来与您的数据库对话。例如，您可以做<code class="fe kz la lb lc b">npm install sqlite3 mysql pgsql,mssql</code>来引入与SQLite、MySQL/MariaDB、PostgreSQL或Microsoft SQL Server系统通信的能力——您通常只会看到应用程序使用其中的一个。</p><p id="9761" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用这个特定的数据库库确实可以工作，并且可以展示数据库系统的全部功能。如果数据库发生了变化——或者更糟糕的是，直到实际的系统安装完成后，您才知道数据库会是什么——那么这个问题很快就会解决。一种类型的数据库的库不能正确地与另一种类型的数据库对话。</p><p id="f27a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果有一种方法可以让您编写代码，而不必担心应用程序可能会使用哪个数据库系统，这不是很好吗？</p><p id="2570" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">进入数据库抽象的概念。简而言之，这是一个在特定数据库库之上呈现一个层的库。这一层将数据库细节从应用程序代码中分离出来。您只需编写一次代码，然后如果/当数据库需要更改时，您只需做一个小的配置更改(并安装可能需要的支持库)。但是您的代码本身——以及它所有的查询优点——不会改变。</p><p id="b67c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里需要一个免责声明。如果您使用一个数据库抽象系统，然后使用一个非常特定于您的数据库的特性，那么当数据库供应商发生变化时，您的代码肯定需要更改来解决这个问题。</p><p id="6a20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，存储过程通常是特定于平台的SQL扩展——如果使用该功能，需要在新的数据库系统中重新创建。但这并不意味着不能使用存储过程。他们只是需要有意识地使用这些暗示。</p><h2 id="7103" class="ld le in bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated">抽象层与对象关系映射系统</h2><p id="c925" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">抽象层和对象关系映射系统之间有一些重叠。两者都提供了一些与数据库对话的自动化方式。ORM则更进一步，试图理解你的数据库结构。有了抽象层，您可以创建一个INSERT语句，该语句可以在任何配置的DB系统上工作。使用ORM，您可以扩展insert，用一个命令创建新记录和相关记录。</p><p id="ec81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ORM在某些情况下可能是强大而方便的。我自己的经验表明，它们是有代价的，使用它们会很快导致不必要的工作量。(如果有人感兴趣，我可能会在某个时候发布相关内容)</p><p id="ec50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能认为这里应该提到顺序。Sequelize是一个ORM，不仅仅是简单的数据库抽象。我对Sequelize的经验有限，但它从来就不适合我。</p><p id="3ee7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我想使用ORM，我会使用Objection.JS. Objection是建立在Knex.JS之上的。我试图为一个大型项目实现Objection，最终不得不退回到只使用Knex。不是因为异议不可行，而是因为我们的用例打破了异议应该对关系做什么的限制。(这*可能*是开发人员的一些糟糕的设计选择——呃，就是我…)</p><h2 id="02b6" class="ld le in bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated">节点。JS选项</h2><p id="1777" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我肯定我错过了一些很棒的选择，但对我来说<a class="ae jz" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex。JS </a>是唯一真正的选择。它是轻量级的，并试图尽可能的非个人化。</p><p id="5000" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Knex非常简单，非常符合普通SQL语言。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="4900" class="ld le in lc b gy mj mk l ml mm">const records = knex('tasks')<br/>    .where({user_id: 5})<br/>    .orderBy('task_date');</span></pre><p id="4c03" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个JS代码会产生<code class="fe kz la lb lc b">select * from tasks where user_id = 5 order by task_date</code>。括号内有许多选项，并且都可以是动态的。虽然SQL很简单，但是Knex所代表的功能非常强大。</p><h2 id="63d3" class="ld le in bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated">Knex入门。射流研究…</h2><p id="7453" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在<a class="ae jz" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex阅读文档。JS </a>。这是Knex信息的事实上的“来源”。</p><p id="de90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">入门就像做一个<code class="fe kz la lb lc b">npm install</code>一样简单。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="f017" class="ld le in lc b gy mj mk l ml mm">mkdir dbProject<br/>cd dbProject<br/>npm init -y<br/>npm  install knex pg</span></pre><p id="313d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将建立一个练习项目并安装knex。我们还安装了“pg”库来与PostgreSQL数据库对话。如果你打算使用mysql，那么用“MySQL”替换“pg”。如果您要使用不同的数据库系统，那么只需确保您安装了一个库来与它对话。Knex文档给出了更多的信息。</p><p id="abea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了knex，我们需要设置一些东西。我喜欢用NPM的剧本来做这件事。所以我修改了我的<code class="fe kz la lb lc b">package.json</code>的剧本部分</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="91e3" class="ld le in lc b gy mj mk l ml mm">"scripts": {<br/>  "knex": "knex",<br/>  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>},</span></pre><p id="0fcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以在项目目录中发出命令<code class="fe kz la lb lc b">npm run knex init</code>。这将创建一个<code class="fe kz la lb lc b">knexfile.js</code>文件。检查该文件，您将看到一个标准节点模块返回一个具有特定于环境的配置的对象。这允许您使用SQLite进行测试，使用MySQL进行开发，但是如果您愿意，可以使用MSSQL进行生产。(这听起来是个糟糕的组合，但却是可行的)。您可以根据环境的需要改变连接。您可以删除“暂存”和“生产”对象，只使用“开发”对象。</p><p id="ccb3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您设置了<code class="fe kz la lb lc b">client</code>属性来匹配您正在使用的数据库系统。然后用连接到服务器的详细信息设置<code class="fe kz la lb lc b">connection</code>属性——主机名/ip、用户名、密码等。</p><p id="3cd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成后，您现在可以与数据库对话并对其执行命令。</p><h2 id="4fb9" class="ld le in bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated">迁移</h2><p id="47cb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Knex使用所谓的“迁移”来创建、删除和更改数据库元素。这些迁移文件可以设置索引、外键，如果需要，甚至可以运行定制的SQL。这里的目的是，我们可以“应用”尚未应用到我们的数据库的迁移，并更新系统。或者将系统返回到添加有问题的索引(或表)之前的状态。</p><p id="07e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Knex为创建和运行迁移提供了一种方便的方法。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="99ae" class="ld le in lc b gy mj mk l ml mm">npm run knex migrate:make create_tasks_table</span></pre><p id="f381" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将在<code class="fe kz la lb lc b">migrations</code>目录下生成一个文件。如果目录不存在，则创建该目录。您可以在<code class="fe kz la lb lc b">knexfile.js</code>文件中指定创建目录的位置以及如何命名它。生成的文件以<code class="fe kz la lb lc b">20200807222531_create_tasks_table</code>的形式命名。即年、月、日、小时、分钟、秒，后跟描述。尽管允许更改名称，但不要改变该名称的格式，除非它已经应用于数据库。(如果您应用更改，然后更改文件名，然后尝试回滚，您将遇到错误，因为原始文件名不再存在。)</p><p id="4489" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该文件的内容如下所示:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="6f03" class="ld le in lc b gy mj mk l ml mm">exports.up = function(knex) {</span><span id="d312" class="ld le in lc b gy mn mk l ml mm">};</span><span id="d5d0" class="ld le in lc b gy mn mk l ml mm">exports.down = function(knex) {</span><span id="5241" class="ld le in lc b gy mn mk l ml mm">};</span></pre><p id="73b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们可以调用Knex模式系统来创建和删除我们的表，无论这个迁移是否被应用。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="b55a" class="ld le in lc b gy mj mk l ml mm">exports.up = function(knex) {<br/>  return knex.schema.createTable('tasks', table =&gt; {<br/>    table.increments('id')<br/>    table.string('name')<br/> })<br/>};</span><span id="d637" class="ld le in lc b gy mn mk l ml mm">exports.down = function(knex) {<br/>  return knex.schema.dropTable('tasks')<br/>};</span></pre><p id="043d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要注意的是<code class="fe kz la lb lc b">up</code>和<code class="fe kz la lb lc b">down</code>方法必须返回一个承诺。请参见<a class="ae jz" href="http://knexjs.org/#Schema-Building" rel="noopener ugc nofollow" target="_blank">模式文档</a>了解您在这里可以做什么的更多细节。</p><p id="13de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以运行<code class="fe kz la lb lc b">npm run knex migrate:latest</code>将更改应用到数据库。如果您的连接已经设置好并且没有错误，那么您的数据库现在应该有一个tasks表。但是它也有“迁移”和“迁移锁”表。这些有助于跟踪应用了哪些迁移。</p><h2 id="be97" class="ld le in bd lf lg lh dn li lj lk dp ll kl lm ln lo kp lp lq lr kt ls lt lu lv bi translated">在模块中使用Knex</h2><p id="7d98" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">最后，为了在我们的应用程序中使用Knex，我们需要调用它。</p><p id="3582" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我通常创建一个<code class="fe kz la lb lc b">_connection.js</code>文件，其中包含如何连接到数据库的细节。这个文件使用适当的配置设置调用Knex对象。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="cf7d" class="ld le in lc b gy mj mk l ml mm">const config = require('./knexfile.js')<br/>const Knex = require('knex')<br/>module.exports = Knex(config[process.env.NODE_ENV || 'development'])</span></pre><p id="ddbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我这样做是因为有时我需要一些更复杂的东西。我可能正在设置多个连接，或者做其他与设置数据库相关的工作。得益于模块系统，knex对象被当作<a class="ae jz" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例</a>处理。</p><p id="b22f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦完成，我就创建一个我称之为“模型”的东西来做数据工作。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="a932" class="ld le in lc b gy mj mk l ml mm">// src/models/task.js</span><span id="48de" class="ld le in lc b gy mn mk l ml mm">const knex = require('./connection.js')</span><span id="c8de" class="ld le in lc b gy mn mk l ml mm">async function getAll() {<br/>  return knex('tasks').orderBy('name')<br/>}</span><span id="459b" class="ld le in lc b gy mn mk l ml mm">module.exports = {<br/>  getAll<br/>}</span></pre><p id="f431" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我可以要求该文件，并在应用程序中的任何需要的地方使用它:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="f43a" class="ld le in lc b gy mj mk l ml mm">// src/services/current.js</span><span id="9b21" class="ld le in lc b gy mn mk l ml mm">const TaskModel = require('../models/task.js')<br/>console.log(TaskModel.getAll())</span></pre><p id="e263" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我的tasks表中有数据，我将得到一个对象数组来表示表中的每条记录。</p><p id="f99d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嘣！我们拥有潜力巨大的RDBMS连接。</p><p id="b5a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，细节变得有点复杂，但是这应该让你开始并指向正确的方向。</p></div></div>    
</body>
</html>