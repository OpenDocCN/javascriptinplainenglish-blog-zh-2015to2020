<html>
<head>
<title>Creating GraphQL Scalar Types with Express-GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express-GraphQL创建GraphQL标量类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-graphql-scalar-types-with-express-graphql-aafa275e25c1?source=collection_archive---------0-----------------------#2020-03-28">https://javascript.plainenglish.io/creating-graphql-scalar-types-with-express-graphql-aafa275e25c1?source=collection_archive---------0-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f479325796c5844ef9d930d2e412ffa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p7Ys9owC0s-SCI4t"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mroz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Filip Mroz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f46e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用GraphQL，我们可以像创建对象类型和其他复合数据类型一样创建标量类型。</p><p id="b532" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用Express-GraphQL创建标量类型。</p><h1 id="b871" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">GraphQLScalarType</h1><p id="1e05" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">GraphQLScalarType</code>构造函数创建一个GraphQL标量类型。要创建标量类型，我们必须给它一个名称、一个可选的描述以及序列化和解析值的方法。</p><p id="cdc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数接受一个具有以下字段的对象:</p><ul class=""><li id="20b3" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated"><code class="fe me mf mg mh b">name</code> —我们要定义为字符串的标量类型的名称</li><li id="3bad" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe me mf mg mh b">description</code> —描述我们的类型的可选字符串</li><li id="df75" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe me mf mg mh b">serialize</code>——一个函数，接受一个<code class="fe me mf mg mh b">value</code>参数，这个参数可以是任何东西，然后返回我们想要转换成的东西以便传输</li><li id="1b82" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe me mf mg mh b">parseValue</code> —一个可选的函数，带有一个<code class="fe me mf mg mh b">value</code>参数，这个参数可以是任何值，然后根据我们的意愿返回解析后的值</li><li id="8232" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe me mf mg mh b">parseLiteral</code> —一个采用抽象语法树对象的函数，抽象语法树对象是文字的值，然后我们返回我们想要将值转换成的内容。</li></ul><h1 id="e9e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">例子</h1><p id="90ed" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">例如，我们可以编写以下代码来创建一个标量类型，并在响应中返回它:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="632a" class="ne lc iq mh b gy nf ng l nh ni">const express = require('express');<br/>const graphqlHTTP = require('express-graphql');<br/>const graphql = require('graphql');</span><span id="0264" class="ne lc iq mh b gy nj ng l nh ni">const dateValue = (value) =&gt; {<br/>  if (value instanceof Date) {<br/>    return +value;<br/>  }<br/>}</span><span id="be3b" class="ne lc iq mh b gy nj ng l nh ni">const DateType = new graphql.GraphQLScalarType({<br/>  name: 'Date',<br/>  serialize: dateValue,<br/>  parseValue: dateValue,<br/>  parseLiteral(ast) {<br/>    return dateValue(ast.value);<br/>  }<br/>});</span><span id="342d" class="ne lc iq mh b gy nj ng l nh ni">const queryType = new graphql.GraphQLObjectType({<br/>  name: 'Query',<br/>  fields: {<br/>    currentDate: {<br/>      type: DateType,<br/>      resolve: () =&gt; {<br/>        return new Date();<br/>      }<br/>    }<br/>  }<br/>});</span><span id="0e43" class="ne lc iq mh b gy nj ng l nh ni">const schema = new graphql.GraphQLSchema({ query: queryType });</span><span id="5a20" class="ne lc iq mh b gy nj ng l nh ni">const app = express();<br/>app.use('/graphql', graphqlHTTP({<br/>  schema: schema,<br/>  graphiql: true,<br/>}));</span><span id="6bba" class="ne lc iq mh b gy nj ng l nh ni">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="e094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe me mf mg mh b">dateValue</code>函数定义如下:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="4d1d" class="ne lc iq mh b gy nf ng l nh ni">const dateValue = (value) =&gt; {<br/>  if (value instanceof Date) {<br/>    return +value;<br/>  }<br/>}</span></pre><p id="530e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个函数中，我们检查<code class="fe me mf mg mh b">value</code>是否是从<code class="fe me mf mg mh b">Date</code>构造函数创建的，如果是，那么我们返回转换成时间戳的<code class="fe me mf mg mh b">Date</code>对象。</p><p id="812b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用它来创建一个名为<code class="fe me mf mg mh b">Date</code>的新标量类型，如下所示:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="f223" class="ne lc iq mh b gy nf ng l nh ni">const DateType = new graphql.GraphQLScalarType({<br/>  name: 'Date',<br/>  serialize: dateValue,<br/>  parseValue: dateValue,<br/>  parseLiteral(ast) {<br/>    return dateValue(ast.value);<br/>  }<br/>});</span></pre><p id="4d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入了名字，是<code class="fe me mf mg mh b">'Date'</code>。然后我们用带有<code class="fe me mf mg mh b">dateValue</code>的<code class="fe me mf mg mh b">serialize</code>属性返回时间戳作为标量类型的序列化版本。</p><p id="4cca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们用相同的函数将<code class="fe me mf mg mh b">Date</code>对象解析成一个UNIX时间戳。</p><p id="fdfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">parseLiteral</code>函数中，我们将值传递给<code class="fe me mf mg mh b">dateValue</code>函数，将<code class="fe me mf mg mh b">Date</code>对象转换成UNIX时间戳。</p><p id="e4f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们创建我们的查询类型，以便我们可以向用户返回时间戳响应，如下所示:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="bc0e" class="ne lc iq mh b gy nf ng l nh ni">const queryType = new graphql.GraphQLObjectType({<br/>  name: 'Query',<br/>  fields: {<br/>    currentDate: {<br/>      type: DateType,<br/>      resolve: () =&gt; {<br/>        return new Date();<br/>      }<br/>    }<br/>  }<br/>});</span></pre><p id="818b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe me mf mg mh b">Query</code>对象类型，这样我们就可以查询它，然后在<code class="fe me mf mg mh b">fields</code>属性中，我们返回一个<code class="fe me mf mg mh b">currentDate</code>字段，它属于我们之前定义的<code class="fe me mf mg mh b">Date</code>标量类型。</p><p id="46e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">resolve</code>方法中，我们只返回<code class="fe me mf mg mh b">new Date()</code>，它将自动解析为响应中的UNIX时间戳，因为这是我们决定在<code class="fe me mf mg mh b">dateValue</code>函数中序列化它的方式。</p><p id="c7aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们进行如下查询时:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="bed1" class="ne lc iq mh b gy nf ng l nh ni">{<br/>  currentDate<br/>}</span></pre><p id="cca3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到这样的结果:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="cc2f" class="ne lc iq mh b gy nf ng l nh ni">{<br/>  "data": {<br/>    "currentDate": 1579464244268<br/>  }<br/>}</span></pre><p id="dc13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中的<code class="fe me mf mg mh b">currentDate</code>被当前的UNIX时间戳替换。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/89e440d893adba259b074af629cea45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iTgmF-XV9ibAugjp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tchompalov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vlad Tchompalov</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4f90" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7dcd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">GraphQLScalarType</code>构造函数创建一个标量类型。</p><p id="fa9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要定义一个，我们必须传入函数来序列化和解析我们想要的值。</p></div></div>    
</body>
</html>