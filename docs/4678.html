<html>
<head>
<title>How to Merge PDF files with Serverless Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用无服务器功能合并PDF文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-merge-pdf-files-with-serverless-functions-7b7e8e4d770a?source=collection_archive---------3-----------------------#2020-12-30">https://javascript.plainenglish.io/how-to-merge-pdf-files-with-serverless-functions-7b7e8e4d770a?source=collection_archive---------3-----------------------#2020-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fde6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在AWS Lambda函数中使用Ghostscript</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a725cdce9f8dedee1301f0b922c79d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpWQyBDZOJbg7fhPiRTUxQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@maxlarochelle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Max LaRochelle</a> on <a class="ae ks" href="https://unsplash.com/s/photos/join?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e6f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无服务器是当今构建简单且经济高效的服务的热门技术。我们还可以使用它在云中运行一些实验，而不需要启动服务器实例。</p><p id="e72c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将创建一个lambda函数来连接pdf文件。乍一看，这似乎是一项容易完成的任务。但是当我们需要在无服务器的基础设施中运行我们的代码时，它有一些挑战。</p><h2 id="86ea" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">Ghostscript</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/bd0399b730d71dead38e5a8a3ffffb58.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*qDzx_yjjxSIIHAOJhuFVxw.png"/></div></div></figure><p id="57f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了能够合并pdf，我们需要一个库或工具来完成。我们在寻找一种无需写太多代码就能合并pdf的东西。一个可以像做两个数的和一样连接pdf的工具。我们找到了Ghostscript。</p><blockquote class="mj mk ml"><p id="fb1e" class="kt ku mm kv b kw kx jo ky kz la jr lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">Ghostscript是用于<a class="ae ks" href="https://en.wikipedia.org/wiki/PostScript" rel="noopener ugc nofollow" target="_blank"> PostScript </a>语言和<a class="ae ks" href="https://en.wikipedia.org/wiki/PDF" rel="noopener ugc nofollow" target="_blank"> PDF </a>文件的解释器。它可以从<a class="ae ks" href="https://artifex.com/" rel="noopener ugc nofollow" target="_blank"> Artifex Software，Inc </a>获得<a class="ae ks" href="https://www.gnu.org/licenses/agpl-3.0.html" rel="noopener ugc nofollow" target="_blank"> GNU GPL Affero许可</a>或<a class="ae ks" href="https://artifex.com/licensing/commercial/" rel="noopener ugc nofollow" target="_blank">商业使用许可</a>。它已经被积极开发了30多年，并在此期间被移植到几个不同的系统中。Ghostscript由PostScript解释器层和图形库组成。</p></blockquote><p id="edfb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您使用的是Mac，安装GhostScript非常简单:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="1211" class="lp lq in mr b gy mv mw l mx my">brew install ghostscript</span></pre><p id="6255" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">合并两个文件就像:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="ebd1" class="lp lq in mr b gy mv mw l mx my">gs -q -sPAPERSIZE=letter -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf in1.pdf in2.pdf</span></pre><p id="c055" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好的，这看起来很简单，但是我们如何将这段代码运行到Node.js函数中呢？</p><h2 id="77d9" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">创建项目</h2><p id="3e9a" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">让我们从创建一个新的无服务器项目开始。为此，我们将使用<a class="ae ks" href="https://www.serverless.com/framework/docs/providers/aws/cli-reference/create/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>。在您<a class="ae ks" href="https://www.serverless.com/framework/docs/providers/aws/guide/installation/" rel="noopener ugc nofollow" target="_blank">安装了</a>框架之后，转到您想要存储项目的目录并运行:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="848c" class="lp lq in mr b gy mv mw l mx my">serverless create --template aws-nodejs --path pdfMergeService</span></pre><p id="1f05" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个命令将创建一个空的Node.js项目，我们将把它部署到AWS。</p><h2 id="da98" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">获取要合并的PDF文件</h2><p id="185f" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">如果我们想容易地做到这一点，我们可以只添加两个pdf文件到项目中，并从那里合并它们。但通常，我们会合并通过我们的服务上传的文件或存储在AWS S3桶中的文件。在这个例子中，我们将做最后一个，合并存储在AWS S3存储桶中的文件。然后，合并结果将被上传回S3存储桶。</p><p id="d361" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们继续之前，有一个我们在Lambda函数中处理文件时要处理的问题。大多数用于合并PDF文件的库或工具都是从磁盘获取文件，而不是动态合并。在Lambda基础设施中运行我们的代码的一个问题是，我们无权更改附加到它的文件系统。那么，我们怎么合并文件呢？嗯，Lambda函数可以访问一个临时目录<code class="fe ne nf ng mr b">/tmp</code>，这个目录可以在函数运行时用作临时存储。</p><p id="3655" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以这个过程应该是:</p><ul class=""><li id="8af5" class="nh ni in kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">从S3下载文件到<code class="fe ne nf ng mr b">/tmp</code>目录</li><li id="9331" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">合并存储在<code class="fe ne nf ng mr b">/tmp</code>的文件</li><li id="49b5" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">将结果上传到S3</li></ul><p id="0185" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">先说第一个。我们将在<code class="fe ne nf ng mr b">handler.js</code>中创建一个新功能:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="9e6c" class="lp lq in mr b gy mv mw l mx my">const fs = require('fs');<br/>const AWS = require('aws-sdk');<br/>AWS.config.setPromisesDependency(require('bluebird'));<br/><br/>const s3 = new AWS.S3();</span><span id="23f2" class="lp lq in mr b gy nv mw l mx my">const mergeFiles = async (s3Files) =&gt; {<br/><br/>    let filesToMerge = "";<br/>    for(const file of s3Files) {<br/>        const paramsFile = {<br/>            Bucket: "&lt;bucket-name&gt;",<br/>            Key: `${file}.pdf`<br/>        };<br/><br/>        let readStream = await s3.getObject(paramsFile).promise();<br/><br/>        await fs.promises.writeFile(`/tmp/${file}.pdf`, readStream.Body);<br/><br/>        filesToMerge += `/tmp/${file}.pdf` + " ";<br/>    }<br/>}</span></pre><p id="c1cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个函数接收一个文件名列表，我们希望从S3存储桶中合并这些文件名。然后，它检索每个文件，并将它们存储在<code class="fe ne nf ng mr b">tmp</code>目录中。</p><h2 id="6f3a" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">合并文件</h2><p id="26c4" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">现在我们已经有了想要合并的文件，我们需要一种方法在lambda函数中运行GhostScript。有几种方法可以做到这一点，但我们发现最简单的方法是使用Lambda层。要使用GhostScript工具添加层，请转到<code class="fe ne nf ng mr b">serverless.yml</code>文件，并将以下内容添加到函数声明中:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="2d18" class="lp lq in mr b gy mv mw l mx my">functions:<br/>  hello:<br/>    handler: handler.hello<br/>    memorySize: 128<br/>    timeout: 40<br/>    layers:<br/>      - arn:aws:lambda:us-east-1:764866452798:layer:ghostscript:6</span></pre><p id="f44b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这使得在Lambda函数中可以通过Linux终端使用<code class="fe ne nf ng mr b">gs</code>命令。但是我们如何从Node.js代码运行Linux命令呢？我们将使用一个名为<code class="fe ne nf ng mr b">shelljs</code>的库。更新<code class="fe ne nf ng mr b">mergeFiles</code>函数，如下所示:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="78a1" class="lp lq in mr b gy mv mw l mx my">const fs = require('fs');<br/>const shell = require('shelljs');<br/><br/>const AWS = require('aws-sdk');<br/>AWS.config.setPromisesDependency(require('bluebird'));<br/><br/>const s3 = new AWS.S3();</span><span id="0f1f" class="lp lq in mr b gy nv mw l mx my">const mergeFiles = async (s3Files) =&gt; {<br/><br/>    let filesToMerge = "";<br/>    for(const file of s3Files) {<br/>        const paramsFile = {<br/>            Bucket: "&lt;bucket-name&gt;",<br/>            Key: `${file}.pdf`<br/>        };<br/><br/>        let readStream = await s3.getObject(paramsFile).promise();<br/><br/>        await fs.promises.writeFile(`/tmp/${file}.pdf`, readStream.Body);<br/><br/>        filesToMerge += `/tmp/${file}.pdf` + " ";<br/>    }<br/><br/><br/>    await shell.exec(`gs -dNOPAUSE -sDEVICE=pdfwrite -sOUTPUTFILE=/tmp/result.pdf -dBATCH ${filesToMerge}`);<br/><br/>}</span></pre><p id="4910" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，将结果上传到S3存储区:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="81d0" class="lp lq in mr b gy mv mw l mx my">const fs = require('fs');<br/>const shell = require('shelljs');<br/><br/>const AWS = require('aws-sdk');<br/>AWS.config.setPromisesDependency(require('bluebird'));<br/><br/>const s3 = new AWS.S3();</span><span id="eecd" class="lp lq in mr b gy nv mw l mx my">const mergeFiles = async (s3Files) =&gt; {<br/><br/>    let filesToMerge = "";<br/>    for(const file of s3Files) {<br/>        const paramsFile = {<br/>            Bucket: "&lt;bucket-name&gt;",<br/>            Key: `${file}.pdf`<br/>        };<br/><br/>        let readStream = await s3.getObject(paramsFile).promise();<br/><br/>        await fs.promises.writeFile(`/tmp/${file}.pdf`, readStream.Body);<br/><br/>        filesToMerge += `/tmp/${file}.pdf` + " ";<br/>    }<br/><br/><br/>    await shell.exec(`gs -dNOPAUSE -sDEVICE=pdfwrite -sOUTPUTFILE=/tmp/result.pdf -dBATCH ${filesToMerge}`);<br/><br/>    const fileContent = await fs.createReadStream(`/tmp/result.pdf`);<br/><br/>    const params = {<br/>        Bucket: "&lt;bucket-name&gt;",<br/>        Key: `results/result.pdf`,<br/>        Body: fileContent,<br/>        ContentType: "application/pdf"<br/>    };<br/><br/>    const uploadResponse = await s3.upload(params).promise();<br/><br/>    return uploadResponse;<br/>}</span></pre><p id="c90f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了从导出的<code class="fe ne nf ng mr b">hello</code>模块中调用这个函数，我们可以这样做:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="6705" class="lp lq in mr b gy mv mw l mx my">await mergeFiles(["file1", "file2"]);</span></pre><p id="dfe4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其中<code class="fe ne nf ng mr b">file1</code>和<code class="fe ne nf ng mr b">file2</code>是我们在S3存储桶中的pdf文件名。</p><h2 id="ec05" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">部署解决方案</h2><p id="7044" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">根据需要自定义代码后，可以通过运行以下命令轻松部署它:</p><pre class="kd ke kf kg gt mq mr ms mt aw mu bi"><span id="7726" class="lp lq in mr b gy mv mw l mx my">sls deploy</span></pre><p id="0027" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将使用您在计算机中配置的AWS凭据部署解决方案。(通常运行<code class="fe ne nf ng mr b">aws config</code>)</p><h2 id="bd3e" class="lp lq in bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">资源</h2><ul class=""><li id="3400" class="nh ni in kv b kw mz kz na lc nw lg nx lk ny lo nm nn no np bi translated"><a class="ae ks" href="https://www.ghostscript.com/" rel="noopener ugc nofollow" target="_blank">https://www.ghostscript.com/</a></li><li id="49e6" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated"><a class="ae ks" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">https://www.serverless.com/</a></li><li id="13cb" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated"><a class="ae ks" href="https://aws.amazon.com/lambda/faqs/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/lambda/faqs/</a></li><li id="20b8" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated"><a class="ae ks" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/configuration-layers . html</a></li></ul></div></div>    
</body>
</html>