<html>
<head>
<title>JavaScript Patterns — Modules and Sandbox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript模式——模块和沙箱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-patterns-modules-and-sandbox-76f8a3cf3b1c?source=collection_archive---------2-----------------------#2020-06-05">https://javascript.plainenglish.io/javascript-patterns-modules-and-sandbox-76f8a3cf3b1c?source=collection_archive---------2-----------------------#2020-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c767997b991dd69e4f8e200b9ddd10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kvSU4M137f5nq_aU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@cinziafm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cinzia Orsina</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8bb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="9766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何创建和使用对象，包括模块模式和沙箱模式。</p><h1 id="863e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建构造函数或类的模块</h1><p id="dfdc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以拥有创建构造函数的模块。</p><p id="b470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="afb0" class="mn lc iq mj b gy mo mp l mq mr">const Foo = (() =&gt; {<br/>  class Foo {<br/>    //...<br/>  }<br/>  return Foo;<br/>})();</span></pre><p id="c968" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建一个类并返回它。</p><p id="8657" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以对构造函数做同样的事情。</p><p id="8ae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建一个构造函数并返回它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c259" class="mn lc iq mj b gy mo mp l mq mr">const Foo = (() =&gt; {<br/>  function Foo() {<br/>    //...<br/>  }</span><span id="21d0" class="mn lc iq mj b gy ms mp l mq mr">  Foo.prototype.fn = function() {<br/>    //...<br/>  }<br/>  return Foo;<br/>})();</span></pre><p id="8fa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这和创建一个类然后返回它没有什么不同。</p><p id="0a1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在模块中使用构造函数，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9dcf" class="mn lc iq mj b gy mo mp l mq mr">const foo = new Foo();</span></pre><h1 id="c037" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将全局变量导入模块</h1><p id="ba4c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以让我们的生活接受参数，这样我们就可以把全局变量传递给它。</p><p id="96b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9f51" class="mn lc iq mj b gy mo mp l mq mr">const module = ((global) =&gt; {<br/>  //...<br/>})(this);</span></pre><p id="0be3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在安全的环境中使用全局变量了。</p><h1 id="255f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">沙盒模式</h1><p id="85f3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">沙箱模式解决了上面使用的名称空间模式的问题。</p><p id="1076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它解决了依赖单个全局变量作为应用程序的全局变量。</p><p id="c623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有，我们有带点的名字，比其他名字长。</p><p id="659e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用沙盒模式:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9f92" class="mn lc iq mj b gy mo mp l mq mr">new Sandbox((box) =&gt; {  <br/>  // ... <br/>});</span></pre><p id="bf7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将一个函数作为基本模式传递给构造函数。</p><p id="dbd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以传入一个字符串数组来传递模块名。</p><p id="cfe8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4655" class="mn lc iq mj b gy mo mp l mq mr">Sandbox(['foo', 'bar'], (box) =&gt; {<br/>  // console.log(box);<br/>});</span></pre><p id="36a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">'foo'</code>和<code class="fe mt mu mv mj b">'bar'</code>是模块名。</p><p id="b3e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以多次启动沙盒。因此，如果我们想要启动包含不同模块的，我们可以编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="29d6" class="mn lc iq mj b gy mo mp l mq mr">Sandbox(['foo'], (box) =&gt; {<br/>  // console.log(box);<br/>});</span></pre><p id="f8cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7e0c" class="mn lc iq mj b gy mo mp l mq mr">Sandbox(['foo', 'bar'], (box) =&gt; {<br/>  // console.log(box);<br/>});</span></pre><p id="802a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现沙盒模式，我们可以编写以下代码来包含我们的模块:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="88c5" class="mn lc iq mj b gy mo mp l mq mr">class Sandbox {<br/>  constructor(modules, callback) {<br/>    if (!(this instanceof Sandbox)) {<br/>      return new Sandbox(modules, callback);<br/>    }<br/>    for (const name of Object.keys(Sandbox.modules)) {<br/>      Sandbox.modules[name](this);<br/>    }<br/>    callback(this);<br/>  }<br/>}<br/>Sandbox.modules = {}</span><span id="4bd4" class="mn lc iq mj b gy ms mp l mq mr">Sandbox.modules.foo = (box) =&gt; {<br/>  box.foo = "bar";<br/>};</span><span id="7c3d" class="mn lc iq mj b gy ms mp l mq mr">Sandbox.modules.bar = (box) =&gt; {<br/>  box.getBar = () =&gt; {<br/>    console.log('bar');<br/>  };<br/>};</span><span id="84f7" class="mn lc iq mj b gy ms mp l mq mr">const sandbox = new Sandbox(['foo', 'bar'], (box) =&gt; {<br/> console.log(box)<br/>})</span></pre><p id="53a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，通过用<code class="fe mt mu mv mj b">this</code>回调模块来初始化沙箱。</p><p id="4df7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后可以用<code class="fe mt mu mv mj b">box</code>参数访问我们的沙箱。</p><p id="a26e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们是这样做的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7247" class="mn lc iq mj b gy mo mp l mq mr">for (const name of Object.keys(Sandbox.modules)) {<br/>  Sandbox.modules[name](this);<br/>}</span></pre><p id="b83b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们用<code class="fe mt mu mv mj b">this</code>调用了构造函数中的<code class="fe mt mu mv mj b">callback</code>参数，这样我们也可以在回调中访问我们的类实例。</p><p id="8cbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以添加更多的检查，看看每个模块和回调是否是函数。</p><p id="c515" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ae45" class="mn lc iq mj b gy mo mp l mq mr">class Sandbox {<br/>  constructor(modules, callback) {<br/>    if (!(this instanceof Sandbox)) {<br/>      return new Sandbox(modules, callback);<br/>    }<br/>    for (const name of Object.keys(Sandbox.modules)) {<br/>      const fn = Sandbox.modules[name];<br/>      if (typeof fn === 'function') {<br/>        Sandbox.modules[name](this);<br/>      }</span><span id="1ec7" class="mn lc iq mj b gy ms mp l mq mr">      if (typeof callback === 'function') {<br/>        callback(this);<br/>      }<br/>    }<br/>  }<br/>}<br/>Sandbox.modules = {}</span><span id="9df4" class="mn lc iq mj b gy ms mp l mq mr">Sandbox.modules.foo = (box) =&gt; {<br/>  box.foo = "bar";<br/>};</span><span id="8fd0" class="mn lc iq mj b gy ms mp l mq mr">Sandbox.modules.bar = (box) =&gt; {<br/>  box.getBar = () =&gt; {<br/>    console.log('bar');<br/>  };<br/>};</span><span id="6165" class="mn lc iq mj b gy ms mp l mq mr">const sandbox = new Sandbox(['foo', 'bar'], (box) =&gt; {<br/>  console.log(box)<br/>})</span></pre><p id="c7cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们检查所有东西都是函数。</p><p id="6ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以向类中添加额外的方法，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="11c0" class="mn lc iq mj b gy mo mp l mq mr">class Sandbox {<br/>  constructor(modules, callback) {<br/>    if (!(this instanceof Sandbox)) {<br/>      return new Sandbox(modules, callback);<br/>    }<br/>    for (const name of Object.keys(Sandbox.modules)) {<br/>      const fn = Sandbox.modules[name];<br/>      if (typeof fn === 'function') {<br/>        Sandbox.modules[name](this);<br/>      }</span><span id="520d" class="mn lc iq mj b gy ms mp l mq mr">      if (typeof callback === 'function') {<br/>        callback(this);<br/>      }<br/>    }<br/>  }</span><span id="b51f" class="mn lc iq mj b gy ms mp l mq mr">  hello() {<br/>    //...<br/>    console.log('hello');<br/>  }<br/>}<br/>Sandbox.modules = {}</span><span id="7a71" class="mn lc iq mj b gy ms mp l mq mr">Sandbox.modules.foo = (box) =&gt; {<br/>  box.foo = "bar";<br/>};</span><span id="0ae2" class="mn lc iq mj b gy ms mp l mq mr">Sandbox.modules.bar = (box) =&gt; {<br/>  box.getBar = () =&gt; {<br/>    console.log('bar');<br/>  };<br/>};</span><span id="83d0" class="mn lc iq mj b gy ms mp l mq mr">const sandbox = new Sandbox(['foo', 'bar'], (box) =&gt; {<br/>  box.hello();<br/>})</span></pre><p id="f507" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe mt mu mv mj b">hello</code>方法，它将在沙箱的原型中。</p><p id="10f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过<code class="fe mt mu mv mj b">box</code>参数访问它来调用它。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a98c731c33fd8f8c1dff679b04742e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OESRC6h0BvVUGiCE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pooya_ramezani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">pooya ramezani</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7abb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="32f5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在IIFEs中返回构造函数或类。这样，我们可以在内部保存一些私有变量并使用它们。</p><p id="3940" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使命名空间更加灵活，我们可以使用沙箱模块。</p><p id="72bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获取模块的名称，然后在我们的函数<code class="fe mt mu mv mj b">this</code>中调用它们，这样它们就可以访问我们的构造函数和类实例。</p><p id="6fa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们对传入的回调也做了同样的处理，以便回调可以访问我们的构造函数或类实例。</p><h2 id="505d" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">说白了</strong></h2><p id="ea24" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达爱意吧！</strong></p></div></div>    
</body>
</html>