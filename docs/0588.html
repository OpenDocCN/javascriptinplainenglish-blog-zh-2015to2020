<html>
<head>
<title>How to avoid try/catch statements nesting/chaining in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免JavaScript中的try/catch语句嵌套/链接？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-avoid-try-catch-statements-nesting-chaining-in-javascript-a79028b325c5?source=collection_archive---------0-----------------------#2019-11-13">https://javascript.plainenglish.io/how-to-avoid-try-catch-statements-nesting-chaining-in-javascript-a79028b325c5?source=collection_archive---------0-----------------------#2019-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c2be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何让你的代码更整洁，看起来更有序！用一种简单、容易、高效的错误处理方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/519472cdb7e5c8025ed5ac83505ac4b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPxDCiS9IYdEm0CPRuPz0Q.png"/></div></div></figure><p id="5a22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">💡注意:</strong> <em class="ln">经过读者的一些反馈，我想澄清一些事情。首先，下面的模式</em> <strong class="kt ir"> <em class="ln">并不是经典的尝试/捕捉错误处理策略</em> </strong> <em class="ln">的替代。事实上，在某些用例中，它甚至可以是一个反模式。本文展示这种模式的方式是作为</em> <strong class="kt ir"> <em class="ln">处理错误的一种补充方式</em> </strong> <em class="ln">当您想要采取直接行动来响应错误时。最后，</em> <strong class="kt ir"> <em class="ln">你将在这里读到的一切都取决于每个人的编程风格</em> </strong> <em class="ln">还有许多其他可用的模式。谢谢你的好意🙏🏻现在让我们继续文章</em></p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="d481" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发人员每天都在编写代码，我们需要用它们来检查潜在的错误。</p><p id="ad68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“Try / Catch”语句无处不在…有时它们甚至是嵌套的或链式的。这导致了这样的例子:</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="610d" class="ma mb iq lw b gy mc md l me mf">async function anyFunction() {<br/>  try {<br/>    const result = await fetch("http://test.com");<br/>  } catch (e) {<br/>    // Some thing<br/>  }</span><span id="d1b4" class="ma mb iq lw b gy mg md l me mf">try {<br/>    const anotherresult = await someOtherAsync();<br/>  } catch (error) {<br/>    // some other error<br/>  }<br/>}</span></pre><p id="1d09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您到处都在编写try/catch块，以防止导致应用程序崩溃的错误。有时过度是因为:</p><ul class=""><li id="ada5" class="mh mi iq kt b ku kv kx ky la mj le mk li ml lm mm mn mo mp bi translated">你想标准化你的错误管理。</li><li id="ec9d" class="mh mi iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">并且你不想依赖外部库的错误格式(或者定制它)。</li></ul><p id="4163" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你会承认:这真的很无聊、多余而且麻烦。</p><p id="0855" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是我们将在下面看到，我们可以用少量代码做一些更薄且非常强大的东西。</p><h1 id="17fe" class="mv mb iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">🙏🏻以冷静的方式处理JavaScript错误</h1><p id="ff24" class="pw-post-body-paragraph kr ks iq kt b ku nm jr kw kx nn ju kz la no lc ld le np lg lh li nq lk ll lm ij bi translated">在每种语言中，处理异常都很常见。</p><p id="f7b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些语言——比如PHP——能够在catch指令中提供错误类型，并且能够使用多个catch块。有些没有，而且处理错误的方式有点糟糕，比如JavaScript。</p><p id="93f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会很快陷入这样一种情况，即您正在编写大量带有嵌套或链接的代码，这可能会变得非常冗长且不易于维护。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="79b4" class="ma mb iq lw b gy mc md l me mf">async function anyFunction() {<br/>  try {<br/>    const result = await fetch("http://test.com");</span><span id="7248" class="ma mb iq lw b gy mg md l me mf">    try {<br/>      const another = await fetch("http://blabla.com");<br/>    } catch(anotherError) {<br/>      console.log(anotherError);<br/>    } <br/>  } catch (e) {<br/>    // Some other error handling<br/>  }</span><span id="3bf7" class="ma mb iq lw b gy mg md l me mf">  try {<br/>    const anotherResult = await someOtherAsync();<br/>  } catch (errorFromAnotherResult) {<br/>    // Some other error<br/>  }<br/>}</span></pre><h2 id="47ba" class="ma mb iq bd mw nr ns dn na nt nu dp ne la nv nw ng le nx ny ni li nz oa nk ob bi translated"><strong class="ak">💡一些语言已经有很好的工具来处理错误</strong></h2><p id="8d7b" class="pw-post-body-paragraph kr ks iq kt b ku nm jr kw kx nn ju kz la no lc ld le np lg lh li nq lk ll lm ij bi translated">像GOlang这样的语言可以从函数的返回语句中返回多个值。这允许我们返回一个error(或null)加上一个带有来自Promise的期望值的对象，所有的都在同一个语句中。</p><p id="c75a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下示例是网络订户的GO示例。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="02d6" class="ma mb iq lw b gy mc md l me mf">func Listen(host string, port uint16) (net.Listener, error) {<br/>  addr, addrErr := net.ResolveTCPAddr("tcp", fmt.Sprintf("%s:%d", host, port))<br/>  if addrErr != nil {<br/>    return nil, fmt.Errorf("Listen: %s", addrErr)<br/>  }<br/><br/>  listener, listenError := net.ListenTCP("tcp", addr)<br/>  if listenError != nil {<br/>    return nil, fmt.Errorf("Listen: %s", listenError)<br/>  }<br/><br/>  return listener, nil<br/>}</span></pre><p id="6eec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，这与NodeJS回调具有“几乎”相同的模式，第一个参数是值，第二个参数是错误(事实上NodeJS回调以相反的顺序使用这些参数…但是您得到了逻辑)。</p><h2 id="eaa9" class="ma mb iq bd mw nr ns dn na nt nu dp ne la nv nw ng le nx ny ni li nz oa nk ob bi translated">✅您也可以使用相同的模式处理JavaScript错误</h2><p id="46bc" class="pw-post-body-paragraph kr ks iq kt b ku nm jr kw kx nn ju kz la no lc ld le np lg lh li nq lk ll lm ij bi translated">虽然JS没有多个return语句，但是有另一种方法来实现我们上面看到的模式。</p><p id="070e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以通过返回一个包含两个数据的数组来模仿这种行为，这也适用于任何支持数组的语言。</p><blockquote class="od oe of"><p id="2f59" class="kr ks ln kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated">❓:好的，你现在能给我看看代码吗？</p></blockquote><p id="5527" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实现这一点，我们需要用一个小的实用函数来包装我们的异步代码。这个函数将解析和拒绝参数格式化为两个元素的数组。这个包装函数在这里将被称为<code class="fe oj ok ol lw b">to</code>，但是你可以随意给它取任何名字。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="098f" class="ma mb iq lw b gy mc md l me mf">/**<br/> * @param { Promise } promise<br/> * @param { Object } improved - If you need to enhance the error.<br/> * @return { Promise }<br/> */<br/>export function to(promise, improved){<br/>  return promise<br/>    .then((data) =&gt; [null, data])<br/>    .catch((err) =&gt; {<br/>      if (improved) {<br/>        Object.assign(err, improved);<br/>      }<br/><br/>      return [err]; // which is same as [err, undefined];<br/>    });<br/>}</span></pre><p id="3428" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数返回两个元素的数组:</p><ul class=""><li id="79c8" class="mh mi iq kt b ku kv kx ky la mj le mk li ml lm mm mn mo mp bi translated"><strong class="kt ir">在随后的回调</strong>(如果承诺已解决):如果没有错误，则返回<code class="fe oj ok ol lw b">null</code>和<code class="fe oj ok ol lw b">data</code>。</li><li id="4b66" class="mh mi iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated"><strong class="kt ir">在catch回调</strong>(如果承诺被拒绝):由于没有数据，返回可扩展的<code class="fe oj ok ol lw b">err</code>和作为第二个元素的<code class="fe oj ok ol lw b">undefined</code>。</li></ul><p id="64cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以使用原始的try/catch块，并以这种方式更新它。这里所做的只是用我们的<code class="fe oj ok ol lw b">to</code>函数包装<code class="fe oj ok ol lw b">someAsyncData</code>承诺。</p><pre class="kg kh ki kj gt lv lw lx ly aw lz bi"><span id="8c18" class="ma mb iq lw b gy mc md l me mf">const [error, result] = await to(someAsyncData());</span><span id="58e7" class="ma mb iq lw b gy mg md l me mf">if(error){<br/>  // log something and return ?<br/>}</span><span id="5e20" class="ma mb iq lw b gy mg md l me mf">const [error2, result2] = await to(someAsyncData2());</span><span id="3d3c" class="ma mb iq lw b gy mg md l me mf">if(error2){<br/>  // do something else<br/>} else {<br/>  // Here we are sure that result2 is defined and a valid value<br/>}</span></pre><p id="0c05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看起来很酷，不是吗？就这么简单。如果promise解析，我们返回一个包含null和数据的数组，否则我们返回错误和undefined。</p><p id="c968" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，除了传统的try/catch块之外，您还可以使用顺序like语法来处理错误。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="4953" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你知道这种模式吗？你已经在用了吗？请在这里分享你的感受。在我看来，这改变了游戏规则，尽管它很简单，没有什么新意😅。但是请注意，这不是传统处理错误方式的替代，只是尝试一下并建立自己的观点。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="9700" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里提供了一些实现这种模式的库:</p><ul class=""><li id="599a" class="mh mi iq kt b ku kv kx ky la mj le mk li ml lm mm mn mo mp bi translated"><a class="ae oc" href="https://www.npmjs.com/package/await-to-js" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/await-to-js</a></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e7ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae oc" href="https://codingspark.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> 🇫🇷STOP！你是法国人吗🥖？</strong>您也可以访问ici以接收法国的私人简讯🙂</a></p></div></div>    
</body>
</html>