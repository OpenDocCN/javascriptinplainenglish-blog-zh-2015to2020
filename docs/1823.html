<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Avoiding Bad Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践——避免坏代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-avoiding-bad-code-e21a2249d4a9?source=collection_archive---------9-----------------------#2020-04-26">https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-avoiding-bad-code-e21a2249d4a9?source=collection_archive---------9-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4928881d3d2e6a17aee5794a51be44a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q_-qu_4EvecJuH0P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bbh_singapore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">BBH Singapore</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dd2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="c736" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些糟糕的代码，如果我们想编写更健壮的JavaScript代码，就应该避免这些代码。</p><h1 id="58a0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免大型模块</h1><p id="c672" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">大型模块不好，因为它们有太多的成员，这使得它们难以跟踪和调试。</p><p id="2863" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">较长的代码也很难阅读。</p><p id="a4a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块应该很小。例如，我们可以有一个只做数学运算的模块。</p><p id="39ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dc16" class="mn lc iq mj b gy mo mp l mq mr">export const add = (a, b) =&gt; a + b;<br/>export const subtract = (a, b) =&gt; a - b;</span></pre><p id="ea61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码简短易读。</p><h1 id="d3dc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免具有多重职责的模块</h1><p id="7ae8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">多重职责的模块可能做得太多了。</p><p id="6d28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这违反了单一责任原则，这是不好的，因为在一段代码中有许多不同的事情会令人困惑。</p><p id="d882" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有多重职责的模块让许多人感到困惑，因为它们做了太多的事情。让一个模块做多件事情是不合理的。</p><p id="b675" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f59d" class="mn lc iq mj b gy mo mp l mq mr">export const add = (a, b) =&gt; a + b;<br/>export const foo = () =&gt; console.log("foo");</span></pre><p id="cbfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那就不好了，因为我们在一个模块中有做多种事情的函数。</p><p id="486c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个将2个数相加的<code class="fe ms mt mu mj b">add</code>函数，和另一个记录<code class="fe ms mt mu mj b">'foo'</code>的函数。</p><p id="0cb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是没有意义的，因为它做多件事。这使得使用它变得更加困难，因为我们必须查看它来了解这个模块是做什么的。</p><p id="9456" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果模块只做一件事，并且模块名表明确实如此，那么人们就不必太费力就能发现一个模块在做什么。</p><h1 id="58e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免紧密耦合</h1><p id="b15a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">紧密耦合是不好的，因为当我们需要更改代码时，很容易破坏代码，这是不可避免的。</p><p id="1e63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免紧密耦合，我们应该避免将模块中的太多成员暴露给外部。</p><p id="fc5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当两个模块紧密耦合时，这意味着两个类必须一起改变。</p><p id="ddf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，模块的松散耦合意味着它们大多是独立的。</p><p id="6570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他可能紧密耦合的实体包括类和函数。例如，如果我们有以下代码:</p><p id="be33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">index.js</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3a09" class="mn lc iq mj b gy mo mp l mq mr">import { greet } from "./module";<br/>export class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="3efe" class="mn lc iq mj b gy mv mp l mq mr">  greet(greeting) {<br/>    greet(`${greeting} ${this.name}`);<br/>  }<br/>}</span></pre><p id="5317" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">module.js</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="104a" class="mn lc iq mj b gy mo mp l mq mr">import { Person } from "./index";<br/>export const greet = greeting =&gt;<br/>  console.log(`${greeting} ${new Person("foo")}`);</span></pre><p id="51b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们在<code class="fe ms mt mu mj b">index.js</code>之外添加了<code class="fe ms mt mu mj b">greet</code>函数，并在<code class="fe ms mt mu mj b">greet</code>函数中导入了<code class="fe ms mt mu mj b">Person</code>。在<code class="fe ms mt mu mj b">index.js</code>中，我们有从<code class="fe ms mt mu mj b">module.js</code>导入<code class="fe ms mt mu mj b">greet</code>函数的<code class="fe ms mt mu mj b">Person</code>类。</p><p id="f8b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种依赖结构耦合得太紧，因为<code class="fe ms mt mu mj b">Person</code>依赖于<code class="fe ms mt mu mj b">greet</code>,<code class="fe ms mt mu mj b">greet</code>依赖于<code class="fe ms mt mu mj b">Person</code>。</p><p id="79b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个改变时，我们不得不担心它是否会破坏另一个，这是不好的，因为它会使我们的代码更加脆弱，并在我们试图做出改变时减慢我们的速度。</p><p id="3022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对他们来说最好是独立的。如果我们不需要他们依赖对方，那么我们应该消除这种依赖。</p><p id="5c99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下内容:</p><p id="44ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">index.js</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ff3e" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="d12c" class="mn lc iq mj b gy mv mp l mq mr">  greet(greeting) {<br/>    console.log(`${greeting} ${this.name}`);<br/>  }<br/>}</span></pre><p id="e825" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">module.js</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0598" class="mn lc iq mj b gy mo mp l mq mr">export const greet = greeting =&gt; console.log(greeting);</span></pre><p id="4d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过消除依赖项的导入和引用来保持它们的独立性。</p><p id="19da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这要干净得多，我们不必担心破坏项目所在的模块代码之外的东西，因为它们彼此不依赖。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/3fd327b0a9dfa53ab7847d16c7c59432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xwdTJEu3CzUDkRPR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@designecologist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">DESIGNECOLOGIST</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ed5e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免神奇的数字</h1><p id="41c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">幻数是出现在多个地方的数字，其含义无法解释。它们经常被用作常量。</p><p id="d7e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它们被用作常量，所以应该用命名的常量替换。</p><p id="5128" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，代替编写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5074" class="mn lc iq mj b gy mo mp l mq mr">const foo = 1;<br/>const bar = 1;<br/>const baz = 1;</span></pre><p id="18e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该使用一个命名的常量来代替1。例如，我们可以编写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7378" class="mn lc iq mj b gy mo mp l mq mr">const CONSTANT = 1;<br/>const foo = CONSTANT;<br/>const bar = CONSTANT;<br/>const baz = CONSTANT;</span></pre><p id="41c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们知道1是常数，并赋予它意义。JavaScript中的常量名通常是大写的，以表明它是一个常量。</p><h1 id="6d83" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="29c1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要编写健壮的JavaScript，我们应该创建只做一件事的小模块。</p><p id="8996" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该消除实体之间的紧密耦合。最后，应该避免幻数，应该用常数代替。</p><h2 id="2045" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="c719" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="761c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>