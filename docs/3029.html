<html>
<head>
<title>How to Customize an Angular Project Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何自定义Angular项目构建</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-customize-an-angular-project-build-2e7e2c31ca6b?source=collection_archive---------2-----------------------#2020-08-21">https://javascript.plainenglish.io/how-to-customize-an-angular-project-build-2e7e2c31ca6b?source=collection_archive---------2-----------------------#2020-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a4b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">迟早会出现这样的情况，当构建Angular应用程序时，会出现一个超出构建Angular开箱即用所能提供的任务。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f49e1635925416bebb0affda52f2de02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kl11ZAh_Ndy9QP1pyzXCGg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://www.pexels.com/photo/build-builder-construction-equipment-585419/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><blockquote class="kw"><p id="1770" class="kx ky iq bd kz la lb lc ld le lf lg dk translated">如你所知，这发生在我身上。</p></blockquote><p id="fe52" class="pw-post-body-paragraph lh li iq lj b lk ll jr lm ln lo ju lp lq lr ls lt lu lv lw lx ly lz ma mb lg ij bi translated">有一天天气很好，我想优化我们的应用程序，以提高它在<a class="ae kv" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank">灯塔</a>中的分数，但马上就遇到了一个经典问题，出于某种原因，Angular还没有找到通用的解决方案。我们使用的所有自定义字体都需要为浏览器添加信息，以便通过<code class="fe mc md me mf b"><a class="ae kv" href="https://developer.mozilla.org/ru/docs/Web/HTML/Preloading_content" rel="noopener ugc nofollow" target="_blank">&lt;link rel = ”preload” /&gt;</a></code>预加载它们。这将允许字体开始加载，而无需等待CSS内容加载，并将提高性能。问题，坦率地说，不是很关键，但当从一个项目到另一个项目面对它时，我想一劳永逸地解决它。</p><p id="f886" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">那么你需要做什么？获取项目字体的信息，并将这些信息添加到Angular生成的【index.html】的<em class="ml">中。德洛夫什么的！但是，像往常一样，为了编写一个定制的程序集，需要经历接受不可避免的所有阶段(如果您不想和我一起经历这些阶段，只需转到有现成解决方案的部分)。</em></p><h1 id="d4fc" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">1.否定。无需任何定制即可解决问题</h1><p id="58e3" class="pw-post-body-paragraph lh li iq lj b lk ne jr lm ln nf ju lp lq ng ls lt lu nh lw lx ly ni ma mb lg ij bi translated">根据字体的路径是如何编写的，Angular下的webpack要么用一个唯一的哈希为它们生成新的名称，并把它们放在你的程序集的根目录下，要么根本不接触它们，然后在设置中，你可以启用简单的把源文件所在的文件夹复制到程序集…</p><p id="756c" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">我们不需要唯一的名称:在接下来的许多年里，我们几乎没有计划在我们的项目中改变字体，缓存也不会有问题。创建了资产的绝对路径后，就可以在<em class="ml"> angular.json </em>的资产设置中注册一个带有字体的文件夹，并将我们需要的链接直接硬编码到HTML中。但是，正如您已经理解的，如果一切都这么简单，这篇文章就不会存在🙂</p><p id="edb5" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">因为我们使用的是Angular 9内置的本地化，所以我们在不同语言的几个文件夹中生成一个项目。试图指定字体的绝对路径导致了路径的破坏，因为资产位于带有地区名称的文件夹中，语言前缀没有添加到资产之前的路径中，并且除了Chrome之外，全局前缀<code class="fe mc md me mf b">&lt;base href="/fr"&gt;</code>在任何地方都不能与绝对路径一起使用(你必须承认，这很奇怪，因为它不应该工作)。因此，试图通过良好的旧硬编码已经失败了。</p><h1 id="81c3" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">2.愤怒和npm脚本</h1><p id="9589" class="pw-post-body-paragraph lh li iq lj b lk ne jr lm ln nf ju lp lq ng ls lt lu nh lw lx ly ni ma mb lg ij bi translated">因为链接不能硬编码，所以在读取资产名称、生成缺失的HTML代码并将其添加到Angular build谨慎创建的<em class="ml">index.html</em>中的想法产生了。使用post命令，您可以在每次构建后自动执行npm脚本，任务就解决了。</p><p id="9eaa" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">这条路上的陷阱不是很深，而是在水面上。首先，必须编写脚本，以便同事可以在不同的操作系统上执行。其次，我们再次遇到了本地化问题:对于每种语言，Angular collector都创建了一个单独的文件夹，每个文件夹都包含自己的index.html和自己的字体，浏览所有的文件夹并更改每个HTML文件有点太多了。我天生的懒惰没有为这个测试做好准备，我出发去寻找下一个解决方案。</p><h1 id="4eab" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">3.讨价还价。Github上的现成包</h1><p id="b8b8" class="pw-post-body-paragraph lh li iq lj b lk ne jr lm ln nf ju lp lq ng ls lt lu nh lw lx ly ni ma mb lg ij bi translated">在这里的某个地方，很明显不定制装配是不可能的。很快就清楚了，在Angular CLI第8版中，有一个CLI构建器API，允许您创建自己的构建器。他有<a class="ae kv" href="https://angular.io/guide/cli-builder" rel="noopener ugc nofollow" target="_blank">相当广泛的</a>文档，甚至有<a class="ae kv" href="https://angular24.ru/guide/cli-builder" rel="noopener ugc nofollow" target="_blank">俄文</a>！但是常见的是，伙计们，当有人可能已经为您编写了一个快速、现成且不是非常最优的解决方案(这也会将一打或两个不必要的依赖项拖到您的项目中)并将其发布在GitHub上时，谁想要阅读冗长乏味的文档呢？</p><p id="947f" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">事实上，在GitHub上快速搜索立即显示出<a class="ae kv" href="https://github.com/manfredsteyer/ngx-build-plus" rel="noopener ugc nofollow" target="_blank"> npx-build-plus </a>，在撰写本文时有915颗星，最后一次提交是在5个月前，还有<a class="ae kv" href="https://github.com/just-jeb/angular-builders/tree/master/packages/custom-webpack" rel="noopener ugc nofollow" target="_blank">@ angular-builders/custom-web pack</a>，这是几天前更新的，但他只有736颗星。</p><p id="f651" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">群星压倒一切，我决定给ngx-build-plus一个机会，但很快就清楚了，Angular中的<em class="ml">index.html</em>的生成不包括在标准的webpack汇编中，这意味着没有<a class="ae kv" href="https://github.com/GoogleChromeLabs/preload-webpack-plugin" rel="noopener ugc nofollow" target="_blank"> Preload Webpack插件</a>可以再连接，因为这样你就必须生成自己的<em class="ml">索引。html </em>带基础hrefs和语言，听起来甚至太复杂了。</p><p id="12df" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">第二个插件解决了所有问题:它允许你指定标准webpack配置的扩展和index.html的转换。在这两种情况下，都需要在设置中添加带有必要转换的文件路径。问题是，在一个文件中，我们需要从webpack中获取资产列表，在另一个文件中，将关于它们的信息添加到HTML中，但是为此，我们决定暂时使用对象<code class="fe mc md me mf b">global</code>。</p><p id="d746" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">为了从webpack程序集提取我们需要的文件名，编写了以下微插件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1b3d" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">带有webpack-config扩展名的文件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="96db" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">为了转换HTML，我使用了正则表达式，并简单地将结果HTML添加到样式的第一个链接之前或结束标记<code class="fe mc md me mf b">&lt;/head&gt;</code>之前:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="acee" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">所有的缺点在这里立即可见:对于每个设置，我们需要一个单独的文件，使用它不是一个好主意<code class="fe mc md me mf b">global</code>，这意味着我们需要一个orchestrator。我们得到三个文件加上一个第三方的包，有了它的支持以后可能会有问题。当然，这个插件是通用的，允许你以不同的方式扩展配置，但是我们不需要这种通用性:我们想要的只是重复标准的组装，将关于字体的信息添加到html中。</p><p id="7271" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">在这里，我们顺利地来到了需要写自己的自行车。</p><h1 id="7503" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">4.抑郁症和不可避免的阅读文件</h1><p id="7483" class="pw-post-body-paragraph lh li iq lj b lk ne jr lm ln nf ju lp lq ng ls lt lu nh lw lx ly ni ma mb lg ij bi translated">Angular CLI中的构建器任务由一个名为Architect的特殊工具处理，该工具可以在@ angular-devkit / architect包中找到。链接器任务是执行任务来构建和维护我们的代码的特殊函数。他们潜伏着等待命令，比如<code class="fe mc md me mf b">ng build</code>、<code class="fe mc md me mf b">ng lint</code>、<code class="fe mc md me mf b">ng test</code>。</p><p id="0891" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">一个名为architect的特殊<em class="ml"> angular.json </em>配置部分负责控制台中的命令和链接器之间的通信。在这里，您可以设置命令和执行命令的特定连接器之间的关系。</p><p id="19fc" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">每个命令都有三个配置选项。键<code class="fe mc md me mf b">builder</code>指示将使用哪个链接器，设置默认参数<code class="fe mc md me mf b">options</code>，可选键<code class="fe mc md me mf b">configurations</code>允许您覆盖各种配置的默认参数。在这种情况下，链接器名称<code class="fe mc md me mf b">builder</code>由两部分组成:npm包的名称和直接在这个包内的链接器的名称。</p><p id="e7e8" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">例如，我们最感兴趣的命令<code class="fe mc md me mf b">build</code>(正如我们所知，正是构建启动了网络包并生成了<em class="ml">index.html</em>)使用了@ angle-dev kit/build-angle:浏览器链接器。因此，为了了解它是如何工作的，您可以在这里查看<a class="ae kv" href="https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/build_angular/src/browser" rel="noopener ugc nofollow" target="_blank">(在@ angular-devkit / build-angular软件包中)。</a></p><p id="a170" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">架构师如何在这样的包中找到需要的任务，以及他如何理解他需要什么参数？在的<em class="ml">包. json中，任何带有链接器的项目都必须有一个特殊的属性<a class="ae kv" href="https://github.com/angular/angular-cli/blob/2039f286d84efa743914b80bb9dec7815eeee8fe/packages/angular_devkit/build_angular/package.json#L8" rel="noopener ugc nofollow" target="_blank"> builders </a>，该属性<a class="ae kv" href="https://github.com/angular/angular-cli/blob/2039f286d84efa743914b80bb9dec7815eeee8fe/packages/angular_devkit/build_angular/package.json#L8" rel="noopener ugc nofollow" target="_blank">指定了JSON文件的</a>路径(通常但不一定是<em class="ml"> builders.json </em>)，并且该文件中已经包含了当前项目中该<a class="ae kv" href="https://github.com/angular/angular-cli/tree/master/packages/angular_devkit/build_angular" rel="noopener ugc nofollow" target="_blank">方案</a>的所有链接器任务的信息。</em></p><p id="f921" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">是的，是的，在胸(<strong class="lj ir"> <em class="ml"> angular.json </em> </strong>)一只野兔(<strong class="lj ir"> architect </strong>),在一只野兔(<code class="fe mc md me mf b">architect.build.builder</code>)——一只鸭子(@<strong class="lj ir">angular-devkit/build-angular</strong>:browser)，在一只鸭子(<strong class="lj ir">@ angular-devkit/build-angular</strong>)——鸡蛋(<strong class="lj ir"><em class="ml">builder . JSON</em></strong>，你在这里)，在鸡蛋针(builder code)里。也就是说，最后一步仍然是最终找到我们需要的收集器的代码。如果你还没有完全糊涂，让我们继续前进😉</p><p id="94e3" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">我们的<strong class="lj ir"> <em class="ml"> builders.json </em> </strong>必须包含<a class="ae kv" href="https://github.com/angular/angular-cli/blob/2039f286d84efa743914b80bb9dec7815eeee8fe/packages/angular_devkit/build_angular/builders.json#L3" rel="noopener ugc nofollow" target="_blank"> builders </a>键。它的值将是一个对象，其键是各个链接器任务的名称(特别是，对于这样的对象中的<strong class="lj ir">@ angular-dev kit/build-angular</strong>，我们肯定会找到<a class="ae kv" href="https://github.com/angular/angular-cli/blob/2039f286d84efa743914b80bb9dec7815eeee8fe/packages/angular_devkit/build_angular/builders.json#L9" rel="noopener ugc nofollow" target="_blank"> browser </a>键)，值是关于从哪里获得实现细节的信息。</p><p id="6168" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">实现细节有三个部分:代码的路径(实现)，描述链接器所需参数的模式的文件的路径(模式)，最后只是描述。因此，我们看到角度收集器代码在处显示为<a class="ae kv" href="https://github.com/angular/angular-cli/blob/master/packages/angular_devkit/build_angular/src/browser/index.ts" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="59f7" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">我保证，我们还需要耐心一点，通过手指在键盘上的灵巧移动，我们将扩展角状收集器😉</p><p id="fdc1" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">所以，说几句关于实现的话。</p><p id="1be5" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">创建任何链接器都需要一个由<strong class="lj ir">@ angular-dev kit/architect</strong>提供的方法<code class="fe mc md me mf b">createBuilder()</code>。这个方法接受一个异步函数，这个函数执行我们所有的链接器逻辑。对于来自<strong class="lj ir">@ angular-dev kit/build-angular</strong>的浏览器构建器来说，它看起来像<a class="ae kv" href="https://github.com/angular/angular-cli/blob/2039f286d84efa743914b80bb9dec7815eeee8fe/packages/angular_devkit/build_angular/src/browser/index.ts#L840" rel="noopener ugc nofollow" target="_blank">这个</a>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="893f" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">同时也是<code class="fe mc md me mf b">buildWebpackBrowser</code>后来以<code class="fe mc md me mf b"><a class="ae kv" href="https://github.com/angular/angular-cli/blob/2039f286d84efa743914b80bb9dec7815eeee8fe/packages/angular_devkit/build_angular/src/index.ts#L37" rel="noopener ugc nofollow" target="_blank">executeBrowserBuilder</a></code>的名义对外输出(意思是——可以重复使用！).</p><p id="df6f" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">我们最后来看看<code class="fe mc md me mf b"><a class="ae kv" href="https://github.com/angular/angular-cli/blob/2039f286d84efa743914b80bb9dec7815eeee8fe/packages/angular_devkit/build_angular/src/browser/index.ts#L245" rel="noopener ugc nofollow" target="_blank">buildWebpackBrowser</a></code>是什么功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="10ab" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">无需深入实施细节，很容易看出该方法采用可选参数<code class="fe mc md me mf b">webpackConfiguration</code>和<code class="fe mc md me mf b">indexHtml</code>，其中</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5848" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated"><strong class="lj ir">什么意思？标准的Angular builder实际上允许您添加webpack配置和HTML内容的异步转换，并且您不需要完全重新发明轮子！这就是:有了这些知识，您终于可以看到我是如何创建链接器并向它传递预加载资产的必要逻辑的了。</strong></p><h1 id="5f74" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">5.领养。我们为angular编写自己的收集器</h1><p id="f9f0" class="pw-post-body-paragraph lh li iq lj b lk ne jr lm ln nf ju lp lq ng ls lt lu nh lw lx ly ni ma mb lg ij bi translated">要解决的第一个问题是将自定义链接器(收集器)放在哪里？在官方文档和大多数示例中，建议为此创建一个单独的项目，并将其发布到npm。但事实上——哒哒！—这不是必需的，如果您不想担心支持一个单独的包，只需记住您已经有了至少一个包含<em class="ml"> package.json </em>的存储库，准备好指向所需的链接器:您的项目本身。</p><p id="13fd" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">因此，在我的项目的<em class="ml"> package.json中，我指定了</em></p><pre class="kg kh ki kj gt nl mf nm nn aw no bi"><span id="e5d7" class="np mn iq mf b gy nq nr l ns nt"><strong class="mf ir">"builders"</strong>: "builders.json",</span></pre><p id="c1c4" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">并且我确保@ angular-devkit / architect和@ angular-devkit / build-angular出现在我的依赖项中。</p><p id="e7c4" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">因为我扩展了标准的Angular构建器，所以我将构建器命名为相同的名称:browser。我的构建器不需要任何不同于标准构建器的新参数，所以我也决定不创建模式，而是轻率地添加了一个来自<strong class="lj ir">@ angular-devkit/build-angular</strong>的到浏览器构建器模式的链接和某种描述:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d36d" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">为了<code class="fe mc md me mf b">ng build</code>使用自定义收集器而不是标准收集器，在<em class="ml"> angular.json </em>中，用新的收集器替换标准收集器就足够了(由于链接器配置在当前项目中，而不是包名中，所以需要用<strong class="lj ir"> <em class="ml"> package.json </em> </strong>指定目录的相对路径):</p><pre class="kg kh ki kj gt nl mf nm nn aw no bi"><span id="e062" class="np mn iq mf b gy nq nr l ns nt"><strong class="mf ir">"architect"</strong>: {<br/>  <strong class="mf ir">"build"</strong>: {<br/>    <strong class="mf ir">"builder"</strong>: "./:browser",</span></pre><p id="4b9f" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">因为所有参数都保持不变，所以不需要改变任何东西！</p><p id="3a8f" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">很好，现在您所要做的就是编写收集器本身的实现。为了简单起见，我抛弃了TypeScript，使用了纯JavaScript。</p><p id="19d8" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">一个不会做任何新事情的自定义收集器看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="88bf" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">在这里，我们可以使用webpack插件和方法来添加缺少的HTML部分，上面写的使用<strong class="lj ir">@ angular-builders/custom-web pack</strong>，和<code class="fe mc md me mf b">global</code>用一些局部变量(例如<code class="fe mc md me mf b">sharedSpace</code>)替换使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="81a4" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">就这些，我们的收集器已经准备好了，并且很好地完成了它的新任务！总的来说，我们有一个JSON配置，一个带有实现的JS文件，以及对<em class="ml"> package.json </em>和<em class="ml"> angular.json </em>的一些更改。看起来删除它并不困难，如果😀</p><p id="a07f" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">而你，如果你把这篇课文读完了，甚至明白了一些东西，就是一个了不起的家伙。</p><p id="d51b" class="pw-post-body-paragraph lh li iq lj b lk mg jr lm ln mh ju lp lq mi ls lt lu mj lw lx ly mk ma mb lg ij bi translated">借此机会，我想感谢这些酷家伙们关于linkers的文章，并建议你进一步研究这篇文章和官方文档(现在你肯定会掌握它):</p><ul class=""><li id="c41d" class="nu nv iq lj b lk mg ln mh lq nw lu nx ly ny lg nz oa ob oc bi translated"><a class="ae kv" href="https://medium.com/angular-in-depth/angular-cli-flows-big-picture-9ed1a0d1930" rel="noopener">亚历山大波什塔鲁克角CLI流。大图</a>；</li><li id="6f6a" class="nu nv iq lj b lk od ln oe lq of lu og ly oh lg nz oa ob oc bi translated"><a class="ae kv" href="https://medium.com/angular-in-depth/angular-cli-under-the-hood-builders-demystified-v2-e73ee0f2d811" rel="noopener">杰布巴拉巴诺夫。引擎盖下的Angular CLI建设者揭秘v2</a>；</li><li id="db44" class="nu nv iq lj b lk od ln oe lq of lu og ly oh lg nz oa ob oc bi translated"><a class="ae kv" href="https://medium.com/angular-in-depth/customizing-angular-cli-build-an-alternative-to-ng-eject-v2-c655768b48cc" rel="noopener">杰布巴拉巴诺夫。定制Angular CLI构建——ng eject(v2)的替代方案</a>；</li><li id="b19c" class="nu nv iq lj b lk od ln oe lq of lu og ly oh lg nz oa ob oc bi translated"><a class="ae kv" href="https://angular.io/guide/cli-builder" rel="noopener ugc nofollow" target="_blank"> Angular CLI Builders API官方文档</a>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi nk l"/></div></figure></div></div>    
</body>
</html>