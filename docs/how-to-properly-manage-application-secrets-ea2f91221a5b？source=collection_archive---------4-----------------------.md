# 如何正确管理应用程序机密

> 原文：<https://javascript.plainenglish.io/how-to-properly-manage-application-secrets-ea2f91221a5b?source=collection_archive---------4----------------------->

## 从最差到行业标准的 5 个级别

![](img/fd54a61488f39c161102dc69a80f3c75.png)

Photo by [Kristina Flour](https://unsplash.com/@tinaflour?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

如果您构建 web 应用程序，您将不可避免地拥有需要保护的密码或秘密。在这篇文章中，我将分解秘密管理的五个层次，从糟糕的实践到行业最佳实践。假设您正在开发令人惊叹的 web 应用程序，并且希望保护用户的数据。您已经设置了数据库，现在需要验证应用程序。你用密码做什么？

我将经历五个级别的凭据管理，从最差的选项开始，以行业领先的方法结束。与软件中的许多事情一样，凭证管理包含权衡。在这种情况下，需要在安全性和便利性之间进行权衡。我们希望确保我们为每个项目实现了适当的安全级别，同时也实现了流畅方便的开发人员工作流。

## 1.将秘密硬编码到代码库中任何需要它们的地方

从技术上讲，您可能会做一些最糟糕的事情，比如完全关闭身份验证，或者将您的所有密码设置为攻击者可能会猜到的简单值，但是我将假设您没有做这些事情。所以这就是我要开始的地方。在这一级，你把你的密码放入代码中，任何需要的地方。简单而简单，对吗？不。有很多理由说明这是个糟糕的主意。首先，你会在你的代码库中散布一些私人信息。如果你以后真的想回来清理，你需要记住你清理的每一个地方。

第二，如果您使用像 git 这样的分布式版本控制系统，即使远程存储库是私有的，参与项目的每个人都将克隆存储库，并因此在系统上存储他们秘密的副本。即使您在以后的提交中删除它们，它们仍然可以在 git 历史中使用。第三，没有好的方法来支持多种环境，例如拥有单独的开发阶段或生产环境。如果情况如此糟糕，我们该如何改善？这让我更上一层楼。

## 2.将秘密提取到单独的配置文件中

假设您正在处理一个节点。JS + Mongo 项目。在这种情况下，我们将有一个包含数据库密码的 config.env 文件，然后我们可以使用类似 dotenv 包的东西将它作为环境变量加载，然后在初始化数据库客户机时可以使用它。这更好，主要有三个原因。

首先，没有神奇的字符串会更干净，不管它们是否是秘密的，在代码库中浮动。第二，现在我们知道了所有秘密的所在，并可以相应地调整我们的行为。例如，我们可以添加一个. gitignore 文件来防止意外地将文件签入存储库。第三，我们现在可以为不同的环境拥有单独的配置文件。这意味着我们可以拥有一个开发环境和一个生产环境。

这通常是开发凭据的适当安全级别。只要您在开发环境中没有敏感数据，就可以签入开发。配置一般还好。它有助于为新开发人员加入项目提供方便。在本文的剩余部分，我将重点关注生产凭证，它将用于访问用户数据或系统基础设施。所以如果我不能检查。配置文件以纯文本格式存储到我的存储库中，我该怎么办？

## 3.提交前加密机密文件

如果您真的坚持将秘密存储在存储库中，您至少应该加密它们。有几种方法可以实现这一点。一种选择是在双向加密算法中使用 OpenSSL 这样的工具，将我们的纯文本配置文件转换为加密文件，只有拥有正确密钥的人才能读取该文件。虽然这是一个比前两个更好的方法，但它确实回避了一个问题，我在哪里存储加密密钥？我见过这里使用的一些方法。一些人将使用共享密码库在团队中共享密码，或者使用密钥管理服务，许多云提供商提供这些服务来安全地创建和管理加密密钥。

这种方法相当安全。最大的缺点是，如果你把所有的秘密都存储在一个文件中，那么提供对那个文件的访问将会授予某人打开这个王国的所有钥匙。如果我们将它拆分到许多文件中，我们将面临管理所有加密密钥的复杂性增加的问题。此外，在一些行业中，需要能够审计谁在何时访问了凭证。这种方法真的没有提供太多的帮助。

## 4.将秘密转移到专门的秘密管理器

在这一点上，我们采用了局部的概念。尽我们所能打开 config 文件。下一步是将这些凭证转移到专门为管理机密而设计的系统中。这里的理由与永远不要使用自己的密码的普遍建议一致。虽然你可以建立一个系统来加密和管理所有这些秘密，但更明智的做法是将这一责任推卸给那些拥有整个团队致力于建立这样的系统、配备专家的公司。无论您使用哪种云提供商，都可能有一个与访问权限控制紧密集成的秘密管理系统。

使用这种方法还将提供关于谁有权访问每个机密的完全可审计性，以及创建多个版本的机密的功能，这在需要轮换机密时会很有用。这些秘密可以通过几种不同的方式被使用。如果应用程序有一个具有适当角色的服务帐户标识，则可以使用客户端库在应用程序内部读取该秘密。或者，当部署应用程序时，可以从机密管理器中读取机密，并作为环境变量应用。这个水平大概看起来挺不错的。我的意思是，我们所有的秘密都被安全地存储起来，可以按需访问，并且系统提供了访问日志的可审计性。那么，我们该何去何从？

## 5.使用临时凭证

剩下的最大挑战是，我们有一组相对静态的长期凭据，轮换它们可能是一件非常痛苦的事情。为了实现完全开明的凭证管理，我们需要添加短暂或临时凭证的概念。如果凭据仅持续很短的一段时间，则可以显著降低潜在泄漏的影响。我见过的这个概念的最好例子是使用 HashiCorp 的工具 vault 实现的。它不仅具有许多与之前描述的云提供商秘密管理器相同的功能，包括审计日志，而且还实现了按需临时凭证的概念。

跳马是如何工作的？当应用程序或开发人员需要访问特定资源(例如数据库)时，他们会向 Vault 发出请求，Vault 会专门为该用例生成一个新的用户名和密码，该用户名和密码仅在预先指定的时间段内有效。这可能需要几天甚至几个小时。该时间过后，Vault 将撤销这些凭据。

至此，我相信我已经达到了凭证管理的最新水平。正如我前面提到的，在安全性和便利性之间总是有权衡，并不是每个项目都需要在第 5 级运行。根据你的项目明智地选择你的等级。