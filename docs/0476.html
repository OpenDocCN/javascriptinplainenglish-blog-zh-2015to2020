<html>
<head>
<title>How to build a Chrome/Firefox Extension that tracks your Github Activity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个Chrome/Firefox扩展来跟踪你的Github活动</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/walkthrough-the-github-activity-indicator-web-extension-7c220cc29337?source=collection_archive---------3-----------------------#2019-10-23">https://javascript.plainenglish.io/walkthrough-the-github-activity-indicator-web-extension-7c220cc29337?source=collection_archive---------3-----------------------#2019-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="95a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢Github上的“令人敬畏的XYZ”列表。它们通常提供了开发生态系统中最重要的库/主题的精彩摘要。然而，链接的存储库经常是孤立的，多年来没有任何活动发生。因此，我为Firefox 和Chrome<a class="ae kl" href="https://chrome.google.com/webstore/detail/github-activity-indicator/ppedpdikbacabbebipimhdcijkkdefkc?hl=en&amp;authuser=0" rel="noopener ugc nofollow" target="_blank">编写了一个小小的浏览器扩展</a><a class="ae kl" href="https://addons.mozilla.org/en-US/firefox/addon/github-activity-indicator/" rel="noopener ugc nofollow" target="_blank">,它显示了多少天以来一个库没有被更改。它是免费和开源的——试试吧！</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/9e887769d950d19b485e28a28ad4b4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SsCqPmeJWXQUmy7OwyoYg.png"/></div></div></figure><p id="78f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我想浏览一下我的第一个web扩展的源代码并分享我的经验。</p><h1 id="0895" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Mozilla MDN很棒</h1><p id="89c3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Mozilla <a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>非常棒。我是一个平庸的Javascript开发者，对浏览器扩展开发毫无经验。然而，该文档包含了快速启动和运行所需的几乎所有内容。</p><h1 id="2ce7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">文件组织</h1><p id="13e4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">该插件由我将在本文中讨论的以下相关文件组成:</p><p id="6087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">manifest.json</code>位于扩展的根文件夹中，包含重要的元数据:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/1e4f6d2c2a2dfcd7614601a603917192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ymfXJ6cQ1AwVg5bG.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">manifest.json — basic information</figcaption></figure><p id="56d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先我描述我的扩展，并给它一个漂亮的图标。对于<code class="fe mb mc md me b">version</code>字段，建议使用<a class="ae kl" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/91a9451321b58e72a05f951a1cb9da32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4WSxLkF_HDwgCUK4.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">manifest.json — Firefox Setings + Plugin Permission Requests</figcaption></figure><p id="b849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Firefox，需要一些额外的设置:</p><ul class=""><li id="0fbc" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">将<code class="fe mb mc md me b">id</code>设置为guid。即使在文档中它被声明为可选的，您也应该这样做。否则，您以后会遇到问题(例如，您无法访问本地存储)</li><li id="5713" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">将<code class="fe mb mc md me b">strict_min_version</code>设置为最近的某个时间。否则，当您尝试访问早期版本中不可用的API时，将会收到警告。</li></ul><p id="ed2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，Chrome会抱怨它不知道这个部分。我只是忽略了这个警告。</p><p id="48cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">permissions</code>部分，你必须指定插件需要的权限。插件以高权限运行，所以只询问你真正需要的权限:</p><ul class=""><li id="e71d" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">我请求访问github api子域中的所有页面。然后你可以使用<code class="fe mb mc md me b">fetch</code>，CORS不会妨碍你。</li><li id="f235" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">我还想访问本地存储，这样我就可以保存插件的设置。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/3154786a5281a3f266111fa613c4f0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qJWIuG1BpHHOhMjO.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">manifest.json —defining the settings page; injecting scripts on github.com</figcaption></figure><p id="4b62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">options_ui</code>中，您定义html页面，该页面将在插件的设置页面中呈现为iframe。在我的插件中，它允许你设置一个自定义的Github API访问令牌。</p><p id="0cc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mb mc md me b">content_scripts</code>允许您将自定义Javascript注入任意页面:</p><p id="76f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">经验教训:</strong>脚本的顺序很重要。首先，我在我的脚本后添加了polyfill，我花了一段时间才弄明白为什么它不起作用。</p><h1 id="65c0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">履行</h1><p id="d603" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><code class="fe mb mc md me b">addindicators.js</code>包含插件的实现。总的流程非常简单:</p><ol class=""><li id="5512" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk my mq mr ms bi translated">启用或禁用调试日志</li><li id="cf2a" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk my mq mr ms bi translated">从设置中获取API密钥或使用缺省值。</li><li id="f0dd" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk my mq mr ms bi translated">找到Github库的所有链接</li><li id="3ebf" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk my mq mr ms bi translated">组装一个GraphQl查询并查询Github</li><li id="a7cd" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk my mq mr ms bi translated">为每个存储库链接添加一个指示器</li></ol><p id="b9bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一些代码:</p><h2 id="c428" class="mz kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">调试标志</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/617c6a0b1dcc37417897aacbf2a97830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z6dMjwbLAgBGqiUd.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — enable or disable debugging</figcaption></figure><p id="cfb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我检查浏览器本地存储中是否设置了调试标志，并相应地设置了一个全局变量。您稍后看到的所有<code class="fe mb mc md me b">dlog</code>代码只是检查<code class="fe mb mc md me b">debugEnabled</code>标志，或者将消息打印到控制台，或者不打印。</p><p id="d6a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong> : <code class="fe mb mc md me b">browser</code>只能在Firefox中使用，除非你使用polyfill。</p><h2 id="a9d7" class="mz kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">获取API令牌</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/843ad5b1fe7f996a9ec91ea770074936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aZjKDifDWZnlP3iG.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js —getting a custom auth token or using the default</figcaption></figure><p id="ddeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我花了惊人数量的代码从本地存储(通过设置对话框设置)获取令牌，或者使用默认令牌。非常欢迎改进建议！</p><p id="a8bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意一些事情:</p><ul class=""><li id="4b21" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">我用<code class="fe mb mc md me b">browser.storage.sync</code>代替<code class="fe mb mc md me b">browser.storage.local</code>。这可确保令牌在用户设备间同步(如果已启用)。</li><li id="f387" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">在<code class="fe mb mc md me b">isTokenValid</code>函数中，我还检查了字符串<em class="nl">‘未定义’</em>。我需要这样做，因为我在设置对话框实现中偷懒了...</li><li id="6b49" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><strong class="jp ir">安全备注:</strong>我为我的帐户创建了一个非特权Github令牌，我将它用作默认令牌。总的来说，这是一个可怕的安全罪，所以请不要在家里这样做。不跳可爱的OAuth舞，我就是找不到更方便的方法。</li><li id="60da" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">我的函数命名在整个代码库中既不一致也不自动化。很抱歉。</li></ul><h2 id="7207" class="mz kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">找到Github库的链接</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/4b3ff0869106f8a49700f569e5d2da22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hb_6Nxq408_KWSox.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — find links to augment</figcaption></figure><p id="1d54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我通过<code class="fe mb mc md me b">document.getElementsByTagName</code>获取页面上的所有链接，然后过滤掉所有不是github库链接的链接。</p><p id="40d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">经验教训:</strong>乍一看<code class="fe mb mc md me b">document.getElementsByTagName</code>好像是返回一个数组。您还可以使用for循环对其进行迭代，如下所示:</p><pre class="kn ko kp kq gt nm me nn no aw np bi"><span id="6eaf" class="mz kz iq me b gy nq nr l ns nt">for(const x of document.getElementsByTagName('a')){ <br/>// do something <br/>}</span></pre><p id="348e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，这不是一个真正的阵列，这就是为什么会失败:</p><pre class="kn ko kp kq gt nm me nn no aw np bi"><span id="9e9b" class="mz kz iq me b gy nq nr l ns nt">// this will fail!! <br/>document.getElementsByTagName('a').map(x =&gt; x.href());</span></pre><p id="7841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你得用<code class="fe mb mc md me b">Array.from</code>把它改成数组。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/add3a723b3192844d3d75799d13ac848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7sjE6hPqRUi3LK6b.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — checking if a link is a link to a repository</figcaption></figure><p id="a334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">maybe_repo_link</code>中，我过滤出匹配<em class="nl">所有者/存储库</em>模式的github urls。</p><p id="691c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多Github内部链接匹配相同的模式，所以我编写了<code class="fe mb mc md me b">is_repository</code>来捕捉至少更多的链接，以避免以后出现错误。</p><p id="b45a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">经验教训:</strong>起初，我试图像那样过滤内部URL，但很恼火它不起作用:</p><pre class="kn ko kp kq gt nm me nn no aw np bi"><span id="9571" class="mz kz iq me b gy nq nr l ns nt">// this does not work! <br/>norepo.forEach(x =&gt; { <br/>  if(mayberepo.startsWith(x)){ <br/>    return false; <br/>  }}); </span><span id="bcd7" class="mz kz iq me b gy nu nr l ns nt">return true;</span></pre><p id="e584" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如在<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>中非常清楚地描述的那样，如果您对触发副作用感兴趣的话，<code class="fe mb mc md me b">forEach</code>是非常有用的。然而你不能打破这个循环。我的return语句被忽略，函数总是返回<code class="fe mb mc md me b">true</code>。</p><h2 id="f6fb" class="mz kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">通过GraphQL查询Github</h2><p id="799a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">GraphQL是一种访问你的API的语言。与REST相比，在定义单个调用中要查询什么以及响应中应该包含哪些数据方面，您有更多的灵活性。</p><p id="9f9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用了<a class="ae kl" href="https://developer.github.com/v4/" rel="noopener ugc nofollow" target="_blank"> Github GraphQL API </a>,因为它只需要一个HTTP调用就可以查询页面上所有存储库的信息:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/fbaad7b9d72d85cf3ed7e15c57e972f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*42mUoQY-_Rn0ceck.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — getting the repository information via graphql</figcaption></figure><p id="98a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先组装查询，然后查询Github，最后从响应中提取信息。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/8d5117352a4bc45e7a1021f8c4ae9d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ia_do-HjpOoClBxx.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — building the graphql query</figcaption></figure><p id="03f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用一个GraphQL查询一次获取所有存储库的最后一个存储库推送日期。</p><p id="c655" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">graphql_fragment_for</code>中，我为单个存储库组装查询。为了拥有多个<code class="fe mb mc md me b">repository</code>子句，我需要用一个任意的惟一名称作为它们的前缀。</p><p id="e227" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe mb mc md me b">...fields</code>部分:这表明在这个位置应该插入名为“fields”的片段。片段有点像makros，避免重复。</p><p id="5ada" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数的响应如下所示:</p><pre class="kn ko kp kq gt nm me nn no aw np bi"><span id="b465" class="mz kz iq me b gy nq nr l ns nt">r0: repository(owner:"derhackler",name:"catexcel"){ ...fields },</span></pre><p id="5180" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> SECURITY_ALERT: </strong>我使用字符串串联来传入<code class="fe mb mc md me b">owner</code>和<code class="fe mb mc md me b">name</code>。这是危险的，一般来说是非常糟糕的想法。想想SQL注入，但只针对您的API。GraphQL支持应该使用的<a class="ae kl" href="https://graphql.org/learn/queries/#variables" rel="noopener ugc nofollow" target="_blank">变量</a>的概念。但是我不知道如何在我的场景中使用它们...</p><p id="4227" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">graphql_for_repos</code>中，我为存储库组装子查询。此外，我询问我还剩下多少API调用(用于调试目的)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/19551e2e3610dad6c46f0b403f0666e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r7145vOWNGvhnxzt.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — executing the graphql query on github</figcaption></figure><p id="bd97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际的查询是对Github的Graphql端点的HTTP POST。与REST相比，GraphQL APIs通过单个URL公开。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/b78b337a6f738a4e71a251306cf205bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oBL5lNzc2PXws0j1.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — extracting only valid responses</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/cecfd2c5845d185b912f0474c1586ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DQcEURPowuSJgvsu.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">addindicators.js — calculate the number of days until today</figcaption></figure><p id="eb19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mb mc md me b">extract_from_graph</code>中，我过滤掉所有找不到存储库数据的响应(并忽略它)，并将时间戳转换为天数，直到<em class="nl">现在是</em>。</p><h2 id="bedd" class="mz kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">扩充存储库链接</h2><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/dc8eb692ca8ebb61a40a85cf069eed1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zSh6b0XA8Fz1THfP.png"/></div></div></figure><p id="0ddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后一步中，我为每个存储库链接添加了一个小指示器。我没有使用最初查询的DOM元素，而是再次单独查询每个链接。我认为这更干净，因为原始元素可能已经消失了。</p><h1 id="cdff" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定论</h1><ul class=""><li id="1fa4" class="mk ml iq jp b jq lw ju lx jy nv kc nw kg nx kk mp mq mr ms bi translated">编写浏览器扩展很有趣，而且出乎意料的轻松</li><li id="4b07" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">写博客评论我自己的代码比写代码花的时间要长得多</li></ul></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="5117" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nl">原载于2019年10月23日</em><a class="ae kl" href="https://dev.to/derhackler/walkthrough-the-github-activity-indicator-web-extension-pj2" rel="noopener ugc nofollow" target="_blank"><em class="nl">https://dev . to</em></a><em class="nl">。</em></p></div></div>    
</body>
</html>