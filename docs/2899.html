<html>
<head>
<title>Learn Big O Notation in 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5分钟学会大O记谱法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learn-big-o-notation-in-5-minutes-c24e647c4309?source=collection_archive---------3-----------------------#2020-08-03">https://javascript.plainenglish.io/learn-big-o-notation-in-5-minutes-c24e647c4309?source=collection_archive---------3-----------------------#2020-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b65" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">比大家想象的要简单！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/06c85780eff7953b52be09396ad52b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xem1rbG0Fa8DAhtez7mvsA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@aronvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Aron Visuals</a> on <a class="ae kv" href="https://unsplash.com/s/photos/hourglass?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大O符号经常被开发者忽略。然而，这是一个基本的概念，<strong class="ky ir">非常有用并且非常容易理解</strong>。</p><p id="34fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在几分钟内了解它是什么。</p><h1 id="3dc5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">大O符号</h1><p id="7f47" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">大O符号(或算法复杂度)是衡量算法性能的标准方式。<strong class="ky ir">它用一种数学的方式来判断你的代码的有效性</strong>。</p><p id="364c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要太害怕“数学”这个词。这只是你已经知道的基本操作。</p><p id="a457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种符号允许您测量与输入数据相比的算法增长率的演变。<strong class="ky ir">它将描述你的代码</strong>在性能方面可能出现的最坏情况。</p><p id="ff93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种符号的强大之处在于能够不受外部事件(如连接不良、硬件问题等)的影响来衡量算法的效率。它基于一个单一的标准:要执行的操作数量。</p><h1 id="6bd8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一个基本例子</h1><p id="8c52" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们通过一个基本的例子来真正理解这个符号。</p><p id="d20b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象你正在参加一个工作面试。其中一项技术测试是创建一个函数，该函数将数字n作为输入，并返回从0到n的数字之和。</p><p id="e89b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的实现是从0到n进行迭代，并在每次迭代中执行加法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/862fd2811c154c7bd3d220aedee57eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*UXCEpUH01ADv7Zg_Qyb5cw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Basic example using JavaScript</figcaption></figure><p id="f32a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我收到10个输入，我将有10次迭代。如果我有100万个输入，我将有100万次迭代。迭代次数等于给定的输入。</p><p id="0840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个线性的执行时间。我们可以说这个算法的复杂度是O(n)。括号中的数字n表示要执行的迭代次数等于输入。</p><p id="4f06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个练习的最佳解决方案是使用著名的方法n * (n + 1) / 2。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/0e649931bcd4ffbad2bed2158e4217d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*M_-O1SRPXVQdSGXIXVoV7A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Basic example optimized</figcaption></figure><p id="a846" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个解决方案，无论给定的数字是多少，都只有一个操作。该算法需要一个恒定的时间来执行，我们说我们有O(1)的复杂度。</p><p id="f476" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mr">在这种情况下，O(1)不一定意味着算法非常快。这可能需要几纳秒(就像我们的</em> <code class="fe ms mt mu mv b"><em class="mr">sumFrom0ToN</em></code> <em class="mr">函数)或三分钟，这取决于该函数做什么。这意味着无论输入中给出多少数据，算法都需要一个恒定的执行时间。</em></p><h1 id="c09c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">常见错误的例子</h1><p id="7501" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你开始理解大O符号是如何工作的了。现在我们来看一个在开发者世界中非常常见的案例。</p><p id="f948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一个练习中，您有两个数组，每个数组包含n个数字。你必须写一个函数，如果一个数是两个数组共有的，它返回true。</p><p id="030a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单(和天真)的方法是迭代两个数组，当有匹配时返回。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/0810b51661095694a3ce7c5e276e0c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4OvErmQrlFKwmawVWgWUUg.png"/></div></div></figure><p id="540a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设两个数组的大小都是10。在最坏的情况下(没有公约数)，我们会有10 * 10次迭代，总共100次迭代。该算法的复杂度为O(n)。</p><p id="85f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本练习的最佳解决方案是对一个数组使用一个映射，以避免出现两个嵌套循环。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/c88bff15f5827f14a94ff9239a53e8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZmRdPBqIZE_bysshxcmNg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The same example optimized</figcaption></figure><p id="8763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个优化的解决方案中，我们仍然有两个循环，但它们不再嵌套。在最坏的情况下(没有公约数)，我们将有10，加上10次迭代，所以总共20次迭代。该算法的复杂度为O(2n ),这是一个很好的结果。</p><h1 id="8419" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">复杂示例</h1><p id="15c5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们为最后一个例子尝试一个更复杂的例子。</p><p id="9566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一个练习中，你必须编写一个优化的算法，在一组从低到高排序的数字中找到一个数字的位置。</p><p id="b037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的(也是天真的)方法是从数组的开头到结尾进行迭代以找到位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/40510baa3d606fffe69a93dd4b401629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E2ltoo-RKelaoOxcHZ5eA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The algorithm return -1 if the number is not find, but this is not important</figcaption></figure><p id="f9a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到这个算法和第一个算法的相似之处。一个循环，遍历数组中作为参数给出的所有元素。你猜对了，这个算法的复杂度是O(n)。</p><p id="6def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是数组包含有序数字的事实允许我们使用更好的算法:二分搜索法算法。</p><p id="08de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们不是尝试数组中的每个数字，而是首先尝试中间的数字。如果这个数字比我们的数字小，我们将对从这个数字到结尾的数组重复相同的操作。另一方面，如果元素大于我们的数字，我们将从开始到这个元素重复数组的操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/47ee2456b71d986f3570bc6075ec027c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_x8G2UkItmHnLi5j0z9wpA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Visualization of the binary search algorithm where 7 is the target value. Picture from <a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="fed6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二分搜索法算法在对数时间内运行，其复杂度为O(log(n))。这意味着，算法的执行时间仍然取决于输入(这里是数组的大小)。但是当输入数变大时，迭代次数增加不多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/88a071152c55218404ab3903ec3b18ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFkds6mQnHclBYQI84GqCg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An implementation of the binary search algorithm in JavaScript using recursive functions.</figcaption></figure><h1 id="e0f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不同复杂时间概述</h1><p id="ff68" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">了解不同类型的复杂时间是很有趣的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/5fddfd75bb29cb852c5ba8fc54aec16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n28Z1EJYLNPHWLEl1_rLRg.jpeg"/></div></div></figure><p id="1154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您需要处理大量数据时，执行时间为常数或对数的算法总是最好的。</p><p id="c644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具有线性执行时间的算法也很好，但是在处理大量数据时可能会遇到一些性能问题。</p><p id="5711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，无论如何都要避免执行时间呈指数增长的算法，因为它们太贪婪了，你迟早会遇到问题。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="5eda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">知道大O符号很重要，它代表算法的效率，让你找到更优化的方法来达到同样的结果。</p><p id="f71b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使在性能无关紧要或者数据量非常小的时候，您仍然需要挑战自己算法的效率。而且往往，最优化的方式也是最优雅的写法！</p><h1 id="d35b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">来源:</h1><p id="9452" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://www.jesuisundev.com/comprendre-la-notation-big-o-en-7-minutes/" rel="noopener ugc nofollow" target="_blank">https://www . jesuisundev . com/comprendre-la-notation-big-o-en-7-minutes/</a></p></div></div>    
</body>
</html>