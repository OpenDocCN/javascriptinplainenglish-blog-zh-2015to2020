<html>
<head>
<title>11 JavaScript Concepts Every Web Developer Should Know to Take Their Skills to The Next Level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Web开发人员都应该知道的11个JavaScript概念，让他们的技能更上一层楼</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/11-javascript-concepts-every-web-developer-should-know-to-take-their-skills-to-the-next-level-37ef6693111a?source=collection_archive---------0-----------------------#2020-09-10">https://javascript.plainenglish.io/11-javascript-concepts-every-web-developer-should-know-to-take-their-skills-to-the-next-level-37ef6693111a?source=collection_archive---------0-----------------------#2020-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5db3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不了解这些概念，就无法掌握JavaScript。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/65245eb8aecd7188f87adeafbc0a8823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lLL8xoXqjW8uIvGx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4e67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个JavaScript开发人员都应该理解这种复杂语言的基本概念。</p><p id="f5d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的概念并不是全部，但是这些是你向前迈出一步需要知道的基本概念。</p><p id="5448" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。</p><h1 id="6b5f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.生活</h1><p id="e1eb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">它代表立即调用的函数表达式。它是在创建后立即被调用的函数。</p><p id="bb89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你如何定义生活？请看下面的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="15e2" class="mu lt iq mq b gy mv mw l mx my">(() =&gt; console.log(‘Hello world’))();</span></pre><p id="5c5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着代码的执行，控制台将立即记录<strong class="ky ir"> Hello world </strong>。</p><p id="3f47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用IIFE的原因是为了保护变量的可访问性。生命中定义的变量不能从外部访问。这是编写可维护代码并防止您的源代码变得一团糟的方法。</p><h1 id="c891" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.MVC结构</h1><p id="ced8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不仅在JavaScript中，这种结构在几乎所有编程语言中都有使用。与MVC的名字相去甚远，将代码组织成不同的层(如数据、视图和逻辑)并分别对待是一个流行的概念。</p><p id="eaae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个大项目，你需要一个结构来扩大规模，而不用碰壁。从长远来看，MVC是最好的选择之一。在将来的某个时候，当添加新功能或调查错误时，您会感谢自己过去花时间实现MVC。</p><h1 id="2144" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.关闭</h1><p id="1d1f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们在讨论内部函数时使用这个概念，这个内部函数总是可以访问它的外部函数的变量和参数，甚至在外部函数返回之后。</p><p id="81cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">闭包允许你访问函数内部的数据，而不需要直接修改它们。这样，您可以保护您的代码，同时给予其他人扩展它的能力。尤其是当你公开一个图书馆的时候。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5563" class="mu lt iq mq b gy mv mw l mx my">const sayHelloTo = name =&gt; {<br/>  let message = ‘Hello ‘ + name;<br/>  return () =&gt; console.log(message);<br/>}</span><span id="a44c" class="mu lt iq mq b gy mz mw l mx my">const sayHelloToAmy = sayHelloTo(‘Amy’);<br/>sayHelloToAmy(); // Hello Amy</span></pre><h1 id="30c2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.异步/等待</h1><p id="6ff6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Async/await允许您使用异步处理。在处理调用API时，您通常会陷入异步任务。在视图上显示之前，需要完全提取数据。</p><p id="6c8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我对使用async/await感到满意的是，我可以摆脱回调地狱。如果你和我一样，你不喜欢嵌套代码。它使你的代码变得难看，更难维护。</p><p id="2cb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关async/await的用法，请参见下面的示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6a29" class="mu lt iq mq b gy mv mw l mx my">const displayData = async () =&gt; {<br/>  const data = await fetch(‘https://api.github.com/repositories');<br/>  const jsonData = await data.json();<br/>  console.log(jsonData);<br/>};</span><span id="ab5b" class="mu lt iq mq b gy mz mw l mx my">displayData();</span></pre><h1 id="780f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.范围</h1><p id="cdc9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JavaScript中有两种类型的作用域。局部范围和全局范围。你可以想象一个可变作用域是一头被绳子拴在柱子上的牛。它只能在有限的区域内移动，这取决于绳子的长度。</p><p id="a979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用这个比喻，局部变量就像一头被短绳子拴着的牛，全局变量就像一头没有绳子的牛。</p><p id="cfab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5fec" class="mu lt iq mq b gy mv mw l mx my">// Global scope<br/>const globalCow = ‘global cow’;</span><span id="b840" class="mu lt iq mq b gy mz mw l mx my">const showCow = () =&gt; {<br/>  const localCow = ‘local cow’;<br/>  return globalCow;<br/>};</span><span id="e877" class="mu lt iq mq b gy mz mw l mx my">const clonedCow = globalCow;</span><span id="1bed" class="mu lt iq mq b gy mz mw l mx my">const mixedCow = globalCow + localCow; // error: Uncaught ReferenceError: localCow is not defined</span></pre><p id="099e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，变量<strong class="ky ir"> globalCow </strong>可以在任何地方使用，甚至是在函数<strong class="ky ir"> showCow </strong>的本地上下文中。但是你不能在函数<strong class="ky ir"> showCow </strong>之外使用变量<strong class="ky ir"> localCow </strong>，因为它是局部定义的。</p><h1 id="dc1a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.值类型与引用类型</h1><p id="c066" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当你给变量赋值时，不仅仅是赋值这么简单。您需要了解它是实际值还是引用，否则，您可能会无意中更改这些值。</p><p id="167b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您分配诸如字符串、数字或布尔之类的基本类型时，事情就简单了。它们是实际值。</p><p id="4968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果给对象、数组或函数赋值的话，会稍微复杂一点。这一次，变量不会保存实际值，而是保存对内存中实际值的引用。</p><p id="9dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3f82" class="mu lt iq mq b gy mv mw l mx my">let num1 = 1;<br/>let num2 = num1;</span><span id="0453" class="mu lt iq mq b gy mz mw l mx my">// Changing num2’s value does not change num1’s value<br/>num2 = 4;<br/>console.log(num1); // 1<br/>console.log(num2); // 4</span><span id="9ab3" class="mu lt iq mq b gy mz mw l mx my"><br/>let arr1 = [‘Amy’, ‘John’];<br/>let arr2 = arr1;</span><span id="66ef" class="mu lt iq mq b gy mz mw l mx my">// Changing elements’ value in arr2 leads to changing elements’ value in arr1<br/>arr2[0] = ‘Jane’;<br/>console.log(arr1); // [“Jane”, “John”]<br/>console.log(arr2); // [“Jane”, “John”]</span></pre><h1 id="faee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.回收</h1><p id="fc0a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在JavaScript中，回调函数是在调用另一个函数后执行的函数。您可以将回调函数作为参数传递给其他函数。</p><p id="629f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们为什么要用回调呢？通常，我们编写的代码是从上到下顺序运行的。然而，在某些情况下，有些任务需要在执行其他任务之前完成。这时回调就派上了用场。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="74ed" class="mu lt iq mq b gy mv mw l mx my">const fetchUsers = callback =&gt; {<br/>  setTimeout(() =&gt; {<br/>    let response = ‘[{name: “Amy”}, {name: “John”}]’;<br/>    callback(response);<br/>  }, 500);<br/>};</span><span id="5103" class="mu lt iq mq b gy mz mw l mx my">const showUsers = users =&gt; console.log(users);<br/>fetchUsers(showUsers);</span></pre><p id="c22b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们调用了<strong class="ky ir"> fetchUsers </strong>函数，并将<strong class="ky ir"> showUsers </strong>回调函数作为参数传递。当所有数据全部加载后，<strong class="ky ir">显示用户</strong>将在屏幕上显示。</p><h1 id="9661" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">8.原型</h1><p id="c50f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">每当我们用JavaScript创建一个函数或对象时，都会在其中添加一个原型属性。默认情况下，原型是与函数和对象相关联的对象，我们可以在其中附加其他属性，这些属性可以由其他对象继承。</p><p id="1967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9c05" class="mu lt iq mq b gy mv mw l mx my">function Person() {<br/>  this.name = ‘Amy’;<br/>  this.age = 28;<br/>}</span><span id="2675" class="mu lt iq mq b gy mz mw l mx my">Person.prototype.job = ‘Programmer’;<br/>Person.prototype.showName = function() {<br/>  console.log(‘My name is ‘ + this.name);<br/>}</span><span id="8780" class="mu lt iq mq b gy mz mw l mx my">let person = new Person();<br/>person.showName(); // My name is Amy</span></pre><h1 id="7976" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">9.班级</h1><p id="8a65" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在ES6之前，JavaScript中没有类。你只能用函数的方式来处理类的概念。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3ea8" class="mu lt iq mq b gy mv mw l mx my">function Book(title) {<br/>  this.title = title;<br/>}</span><span id="0292" class="mu lt iq mq b gy mz mw l mx my">Book.prototype.showTitle = function() {<br/>  console.log(this.title);<br/>};</span><span id="fe02" class="mu lt iq mq b gy mz mw l mx my">let book = new Book(‘JavaScript’);<br/>book.showTitle(); // JavaScript</span></pre><p id="1500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在ES6中，您可以像创建任何基于类的语言背景一样创建一个实际的类:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c67f" class="mu lt iq mq b gy mv mw l mx my">class Book {<br/>  constructor(title) {<br/>    this.title = title;<br/>  }</span><span id="65a5" class="mu lt iq mq b gy mz mw l mx my">  showBook() {<br/>    console.log(this.title);<br/>  }<br/>}</span><span id="f804" class="mu lt iq mq b gy mz mw l mx my">let book = new Book(‘ES6’);<br/>book.showBook();</span></pre><p id="f1de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很方便，因为它将创建类的几种方法统一到一个单独的方法中。</p><h1 id="b46d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">10.破坏</h1><p id="0041" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是一种从对象中提取属性的干净方式。</p><p id="5679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本用法:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9ef5" class="mu lt iq mq b gy mv mw l mx my">const person = {<br/>  name: ‘Amy’,<br/>  age: 28<br/>};</span><span id="169e" class="mu lt iq mq b gy mz mw l mx my">let { name, age } = person;<br/>console.log(name); // Amy<br/>console.log(age); // 28</span></pre><p id="5991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以保持变量与上述属性名称相同，或者定义新的变量:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8eb7" class="mu lt iq mq b gy mv mw l mx my">let { name: newName, age: newAge } = person;</span><span id="4ed2" class="mu lt iq mq b gy mz mw l mx my">console.log(newName); // Amy<br/>console.log(newAge); // 28</span></pre><h1 id="8d5e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">11.传播算子</h1><p id="02e6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个可以让你访问一个可迭代对象的内部。简单地说，这是一种快速而简洁的方法，可以向数组中添加项，合并对象，或者从数组中取出单个项，然后将它们传递给函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1098" class="mu lt iq mq b gy mv mw l mx my">// Combining Arrays<br/>let arr1 = [1, 2, 3];<br/>let arr2 = [4, 5, 6];<br/>let arr3 = […arr1, …arr2];<br/>console.log(arr3); // [1, 2, 3, 4, 5, 6]</span><span id="cc13" class="mu lt iq mq b gy mz mw l mx my">// Combining Objects<br/>let obj1 = {<br/>  name: ‘Amy’,<br/>  age: 28<br/>};</span><span id="7277" class="mu lt iq mq b gy mz mw l mx my">let obj2 = {<br/>  job: ‘programmer’<br/>};</span><span id="0f9d" class="mu lt iq mq b gy mz mw l mx my">let obj3 = { …obj1, …obj2 };</span><span id="40db" class="mu lt iq mq b gy mz mw l mx my">console.log(obj3); // {name: “Amy”, age: 28, job: “programmer”}</span><span id="edca" class="mu lt iq mq b gy mz mw l mx my">// Spreading out an array and pass it to a function<br/>const sum = (…arr) =&gt; {<br/>  const length = arr.length;<br/>  let sum = 0;</span><span id="afb1" class="mu lt iq mq b gy mz mw l mx my">  for (let i = 0; i &lt; length; i++) {<br/>    sum += arr[i];<br/>  }</span><span id="a433" class="mu lt iq mq b gy mz mw l mx my">  return sum;<br/>};</span><span id="42ae" class="mu lt iq mq b gy mz mw l mx my">let arr = [3, 5, 3, 2, 1];<br/>console.log(sum(…arr)); // 14<br/>console.log(sum(3, 5, 4, 1)); // 13</span></pre><h1 id="a60a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="ce15" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你完全理解上面所有的概念吗？如果没有，现在是时候检查所有这些，并准备将你的技能提升到一个新的水平。</p><p id="97dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我错过什么了吗？请留下评论让我知道。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="0380" class="mu lt iq bd lu nh ni dn ly nj nk dp mc lf nl nm me lj nn no mg ln np nq mi nr bi translated">进一步阅读</h2><div class="ns nt gp gr nu nv"><a href="https://medium.com/javascript-in-plain-english/13-super-useful-chrome-devtools-tips-to-speed-up-your-developing-workflow-e9ecb60fda5c" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">13个超级有用的Chrome DevTools技巧来加速你的开发工作流程</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">一套很棒的web开发工具。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div><h2 id="6075" class="mu lt iq bd lu nh ni dn ly nj nk dp mc lf nl nm me lj nn no mg ln np nq mi nr bi translated">简单英语的JavaScript</h2><p id="5e88" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>