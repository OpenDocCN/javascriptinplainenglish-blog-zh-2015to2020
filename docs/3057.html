<html>
<head>
<title>Open Source Series: Automation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开源系列:自动化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/open-source-series-automation-fe826e365b54?source=collection_archive---------7-----------------------#2020-08-24">https://javascript.plainenglish.io/open-source-series-automation-fe826e365b54?source=collection_archive---------7-----------------------#2020-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5445" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何通过什么都不做来做更多事情</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/445566281ecf7af0545299ff80991b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8_iSirZKBjHRufT6silGw.jpeg"/></div></div></figure><p id="7b4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的 <a class="ae kv" href="https://www.justjeb.com/blog" rel="noopener ugc nofollow" target="_blank"> <em class="ku">个人博客</em> </a> <em class="ku">上可以免费获得这篇文章和其他文章。请务必注册以获得最新最棒的！</em></p><p id="cbe7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，欢迎来到我的系列文章的最新部分！在前一章中，我们讨论了管理贡献(即问题和PRs)。今天我们将谈论自动化——可能是OSS项目管理最重要的方面之一。对于那些没有读过我的系列文章的人，或者想知道我计划增加哪些内容的人，下面是我一直在做的工作的概述:</p><h1 id="3a72" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">目录</h1><ul class=""><li id="d204" class="lu lv in jm b jn lw jr lx jv ly jz lz kd ma kh mb mc md me bi translated"><a class="ae kv" href="https://medium.com/@justjeb/owning-an-open-source-part-1-b63abc60236" rel="noopener">简介</a></li><li id="c309" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated"><a class="ae kv" href="https://medium.com/@justjeb/owning-an-open-source-project-part-2-2b55810aeb8" rel="noopener">开始一个项目</a></li><li id="b7d8" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated"><a class="ae kv" href="https://medium.com/@justjeb/open-source-series-documentation-96ed1420ce81" rel="noopener">文档</a></li><li id="0a2e" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated"><a class="ae kv" href="https://medium.com/@justjeb/open-source-series-publicity-8b3be7d65c17" rel="noopener">宣传</a></li><li id="2c7f" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated"><a class="ae kv" href="https://medium.com/@justjeb/open-source-series-issues-and-prs-8cb1de880fd4" rel="noopener">问题和PRs </a></li><li id="1ead" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated"><strong class="jm io">自动化</strong></li><li id="3c27" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated"><a class="ae kv" href="https://justjeb.medium.com/open-source-series-version-management-dc91424aa63d" rel="noopener">版本管理</a></li></ul><h1 id="c853" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么要自动化</h1><p id="d474" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">如果说我在拥有开源系统的这些年里学到了什么的话，那就是你必须自己做的例行工作越少，你就有越多的时间从事实际工作(比如修复bug和开发新功能)。因此，我尽我所能寻求自动化。T25】</p><p id="b02d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是我希望我们如何实现这一目标；让我们首先检查两种工作流程，(非自动化和全自动化)，看看你有多少时间实际上被投入到日常任务中。然后，我们将探讨如何改进工作流程，以便有更多的时间来修复bug。</p><h2 id="a31b" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">最坏的情况—没有自动化</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/27c3932a54331ba9847e86dc36c96622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vNW0vs4ma3TmLdyzhsUrg.png"/></div></div></figure><p id="4d36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，在没有自动化的情况下，所有的工作都由您来做。仅仅是修复一个bug就要做很多工作，除此之外，这也是每次有一个bug修复或者一个新特性的时候<em class="ku">你</em>不得不<em class="ku">做的工作！现在让我们看看另一种情况。</em></p><h2 id="7607" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">最好的情况—一切都是自动化的</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/74e83314354323cd962019eba909c874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPVSgve_dHyqudEqHiXWbw.png"/></div></div></figure><p id="e4f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，您只需要做您必须做的事情——检查代码并(有时)批准拉取请求。其他一切都是自动完成的。<br/>科幻小说？不，这叫<strong class="jm io">持续集成</strong>和<strong class="jm io">持续部署</strong>。我们不会深入到构建脚本和特定于系统的配置的细节中，相反，我们将回顾使其工作所需的工具，并且我将让您自己决定细节。</p><h2 id="06f8" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">持续集成</h2><blockquote class="nb nc nd"><p id="6cb6" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">持续集成(CI)是将来自多个参与者的代码变更自动集成到一个软件项目中的实践。CI过程由自动工具组成，这些工具在集成之前断言新代码的正确性。</p></blockquote><p id="7cab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个非常基本的CI运行将包括<strong class="jm io">构建</strong>和<strong class="jm io">单元测试</strong>，然而它并不局限于这两个。它还可能包括各种静态代码分析工具、linters等。这是你定义标准的地方。</p><h2 id="1a22" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">端到端测试</h2><p id="cf67" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">虽然构建和单元测试为您提供了代码更改的快速反馈，但花费的时间相对较短，如果出现问题，很快就会失败；端到端(E2E)测试在竞争情报中有着特殊的地位。E2E测试不仅应该涵盖代码的正确性，还应该涵盖您的部署流程、包完整性等等。当我偶然发布了一个不包含任何代码的包的新版本时，我自己也意识到了这一点。构建已经通过，单元测试和E2E测试都是绿色的(那些是通过链接测试项目的构建输出目录安装的)。哪里失败了？在包装阶段。这里有一个要点:E2E测试应该像真实用户一样测试你的包。</p><p id="4a9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了实现这一点，我建议如下:</p><ol class=""><li id="6990" class="lu lv in jm b jn jo jr js jv nh jz ni kd nj kh nk mc md me bi translated">在CI运行期间，启动一个本地包注册表。每种语言/生态系统都有一些选项，例如对于Java或Scala项目，你有<a class="ae kv" href="https://blog.sonatype.com/using-nexus-3-as-your-repository-part-1-maven-artifacts" rel="noopener ugc nofollow" target="_blank"> Nexus Repository </a>，对于JavaScript有<a class="ae kv" href="https://github.com/verdaccio/verdaccio" rel="noopener ugc nofollow" target="_blank"> Verdaccio </a>(我在<a class="ae kv" href="https://github.com/just-jeb/angular-builders" rel="noopener ugc nofollow" target="_blank"> @angular-builders </a>中使用了它)</li><li id="df1d" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">有一个单独的项目使用您的包(这可以驻留在同一个repo中)。这个项目中的测试应该测试您的包的功能。</li><li id="d3fb" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">将此项目配置为使用本地包注册表。</li><li id="841d" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">在构建您的包之后，将其发布到本地包注册中心(在您的CI系统中启动)。</li><li id="cb67" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">将最新版本的包(您刚刚发布的)安装到您的测试项目中。</li><li id="9f2b" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">进行测试。</li></ol><p id="d989" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它不仅会测试您的包的完整性和可靠性，还会在持续部署时为您节省一些工作。</p><h2 id="129d" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">竞争情报系统</h2><p id="d728" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">有很多CI系统都有开源项目的免费计划，其中有<a class="ae kv" href="https://travis-ci.com/" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>、<a class="ae kv" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>、<a class="ae kv" href="https://www.appveyor.com/" rel="noopener ugc nofollow" target="_blank"> AppVeyor </a>、<a class="ae kv" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github Actions </a>等等。它们都是一样的，基本上是一样的，它们将你的代码签出到虚拟机，运行你定义的脚本(通常运行构建和测试)，然后向Github报告成功或失败。</p><p id="7e55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些系统都有一个用于与Github集成的<a class="ae kv" href="https://github.com/marketplace?category=continuous-integration&amp;type=apps" rel="noopener ugc nofollow" target="_blank">应用</a>,所有这些系统的集成流程都非常相似:</p><ol class=""><li id="60e4" class="lu lv in jm b jn jo jr js jv nh jz ni kd nj kh nk mc md me bi translated">在平台上注册。</li><li id="2ee3" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">在你的Github账号里安装相应的app。</li><li id="7bb8" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated"><a class="ae kv" href="https://github.com/settings/installations" rel="noopener ugc nofollow" target="_blank">配置对所选存储库的访问权限</a>。</li><li id="9182" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">创建一个配置文件(如<code class="fe nl nm nn no b">travis.yaml</code>)来定义构建矩阵、所需的构建链和CI脚本。</li><li id="5d90" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">把它推给主人</li></ol><p id="d8ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将使您的CI在每个PR上运行，并向Github报告状态，但是，这还不够。您真正想要的是阻止合并到主分支，直到PR通过所有检查。</p><p id="b927" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是通过定义分支保护规则来实现的。为了定义这些规则，您应该转到存储库"<strong class="jm io">设置"</strong>中的"<strong class="jm io">分支"</strong>部分，然后点击"<strong class="jm io">添加规则"</strong>按钮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/d5dfad41971feb20401ae32f5dc2b1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35pBLH8nGtTFpuCAz7isEw.png"/></div></div></figure><p id="27f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后选中“<strong class="jm io">合并前需要通过状态检查”</strong>复选框:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/0615712a1429e735a70dbbca6e3d3636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_Q3w35JwJ-r72bfrenvIg.png"/></div></div></figure><p id="1a49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，相应的Github Apps复选框已经出现在这里，所以剩下的唯一事情就是启用它们。确切的构建脚本实际上取决于您的生态系统、编写项目的语言、您使用的框架等等。因此，我们不会在这里讨论它——您必须自己查阅CI系统的文档来了解细节。但是，您现在已经对CI是什么以及它如何自动化您的PRs有了相当好的了解，所以让我们继续。</p><h2 id="5fa0" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">持续部署(CD)</h2><blockquote class="nb nc nd"><p id="61ec" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">连续部署(CD)是一个软件发布过程，它使用自动化测试来验证对代码库的更改是否正确和稳定，以便立即自主部署到生产环境中。</p></blockquote><p id="25e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，生产环境是当一个包在包注册中心公开时。这是一个不可逆转的阶段，因为一旦您发布了它，您就不能取消发布，因为它是公开可用的(因此可能会被使用)。</p><p id="d8be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">持续部署有多种策略，这实际上取决于项目及其复杂性，但在我看来，发布应该只从主分支进行，因为这使得工作流非常容易。方法如下:</p><ol class=""><li id="91bd" class="lu lv in jm b jn jo jr js jv nh jz ni kd nj kh nk mc md me bi translated">每个PR代表一个bug修复或者一个新特性。</li><li id="0314" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">代码在到达主程序之前就已经被测试过了(包括E2E)。</li><li id="207d" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">主服务器是受保护的分支，因此只要您不合并失败的PRs，主服务器就保持稳定。</li><li id="26d9" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">每次PR合并到主配置项都会触发主配置项运行，最终发布新版本。</li></ol><p id="2345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将确保所有的发布都是连续的，并且将使特定的PR与特定的版本联系起来变得非常容易。</p><p id="06ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了自动化软件包发布，我们需要一些东西:</p><ol class=""><li id="703f" class="lu lv in jm b jn jo jr js jv nh jz ni kd nj kh nk mc md me bi translated">基于提交消息的自动版本升级。</li><li id="362b" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">基于提交消息的自动变更日志更新。</li><li id="cbce" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">自动将包发布到公共包存储库中。</li><li id="35fd" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh nk mc md me bi translated">Github上的自动发布。</li></ol><p id="ea71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好消息:所有这些都已经得到了语义发布的支持。坏消息:你将不得不投入一些时间来让它工作(但最终它会有回报)。</p><h2 id="d927" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">语义释放</h2><blockquote class="nb nc nd"><p id="f4ef" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">semantic-release自动化了整个包发布工作流，包括:确定下一个版本号、生成发布说明和发布包。</p><p id="ec7e" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">这消除了人类情感和版本号之间的直接联系，严格遵循了<a class="ae kv" href="http://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>规范。</p></blockquote><p id="73b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不会在这里涵盖整个集成过程，因为他们有非常好的文档，没有理由在这里复述。不过，我要提几点:</p><ul class=""><li id="8a6c" class="lu lv in jm b jn jo jr js jv nh jz ni kd nj kh mb mc md me bi translated">在开始语义发布之前，确保你理解了<a class="ae kv" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本规范</a>和<a class="ae kv" href="https://www.conventionalcommits.org/en/v1.0.0/" rel="noopener ugc nofollow" target="_blank">常规提交</a>格式。</li><li id="5fa1" class="lu lv in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">为了让语义发布工作得更好，您应该强制执行某些提交消息格式。为此，您可以将<a class="ae kv" href="https://github.com/conventional-changelog/commitlint" rel="noopener ugc nofollow" target="_blank">commit list</a>作为<a class="ae kv" href="https://github.com/typicode/husky" rel="noopener ugc nofollow" target="_blank"> husky </a>预提交钩子来运行。当有人创建本地提交时，它将强制执行常规提交，但它不能对直接从Github web UI执行的提交做任何事情(当有人想要快速修复他们的PR时，经常会发生这种情况)。因此我建议你通过<a class="ae kv" href="https://github.com/marketplace/actions/commit-linter" rel="noopener ugc nofollow" target="_blank"> commitlint Github Action </a>来备份。</li></ul><p id="92d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您将语义发布设置为工作流的一部分之后，您就差不多完成了，并且您不再需要将您的时间花费在这些常规流程上。虽然还有一个优化你可以做。</p><h2 id="dbd3" class="mn kx in bd ky mo mp dn lc mq mr dp lg jv ms mt lk jz mu mv lo kd mw mx ls my bi translated">使项目保持最新</h2><p id="1a76" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">如果您的项目没有外部依赖关系，请跳过这一部分。然而，大多数项目依赖于其他包，而其他包往往会发生变化。保持你的项目和它的依赖项保持同步是很重要的，但是<em class="ku">这很耗时</em>。幸运的是，我们有一个解决方案。其实有<a class="ae kv" href="https://greenkeeper.io/" rel="noopener ugc nofollow" target="_blank">绿人</a>、<a class="ae kv" href="https://renovate.whitesourcesoftware.com/" rel="noopener ugc nofollow" target="_blank">翻新</a>、<a class="ae kv" href="https://dependabot.com/" rel="noopener ugc nofollow" target="_blank">依赖机器人</a>这几个。所有这些产品的想法都差不多，所以我只引用Dependabot的“它是如何工作的”一节:</p><blockquote class="nb nc nd"><p id="b981" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated"><strong class="jm io"> 1。dependent bot检查更新<br/></strong>dependent bot下载你的依赖文件，寻找任何过时或不安全的需求。</p><p id="bcf7" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated"><em class="in"> 2。</em><strong class="jm io"><em class="in">dependent bot打开拉取请求<br/> </em> </strong>如果您的任何依赖项过期，dependent bot会打开单独的拉取请求来更新每个请求。</p><p id="7a95" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated"><em class="in"> 3。</em> <strong class="jm io"> <em class="in">您检查并合并<br/> </em> </strong>您检查您的测试是否通过，扫描包含的变更日志和发布说明，然后满怀信心地点击合并。</p></blockquote><p id="9c6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能已经注意到，只有当您有一个工作配置项时，这才有意义。</p><h1 id="4e9f" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="5231" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">如果你有一个完全自动化的CI/CD周期，并且在你的OSS库中有一个新的问题，你可以在几分钟内提供一个错误修复。事实上，您可以从手机进入移动Github版本，修复一两行bug，并提交代码。剩下的是自动完成的，您的客户会马上得到一个新版本。我自己能够多次快速、轻松地为我的客户获得一个固定版本。</p><blockquote class="nb nc nd"><p id="e78a" class="jk jl ku jm b jn jo jp jq jr js jt ju ne jw jx jy nf ka kb kc ng ke kf kg kh ig bi translated">拥有强大的自动化并不意味着腾出一些时间来休闲，而是将你的时间投入到真正重要的事情上，并提高你的响应能力。</p></blockquote><p id="cb2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本系列的下一篇文章中，我们将讨论<strong class="jm io">版本管理</strong>，它总是与每个拥有大量用户的OSS项目相关。如果你喜欢我的写作，学到了一些新的或有见地的东西，或者如果你不想错过下一部分，请确保你在<a class="ae kv" href="https://twitter.com/_Just_JeB_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或Medium上关注我。干杯！</p></div></div>    
</body>
</html>