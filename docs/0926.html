<html>
<head>
<title>React: Dead-Simple Component Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:非常简单的组件通信</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-dead-simple-component-communication-4582c0cb18c1?source=collection_archive---------7-----------------------#2020-01-03">https://javascript.plainenglish.io/react-dead-simple-component-communication-4582c0cb18c1?source=collection_archive---------7-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3721" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">尽快:尽可能简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9b267150595dbf168eeee1a41d6c8868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6FvQMZ43-PKXOwx_PRAFQ.jpeg"/></div></div></figure><p id="a2be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在React中，有一种非常简单的方法来建立孩子与父母之间的交流:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="f860" class="ls lt iq lo b gy lu lv l lw lx">class Parent extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>     title: "Foo"<br/>    }<br/>    this.onTitleChange = function(){<br/>      this.setState({"title":"bar"})<br/>    }<br/>  }  <br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;The Title: {this.state.title}&lt;/h1&gt;<br/>        &lt;Child onTitleChange={this.onTitleChange.bind(this)}&gt;&lt;/Child&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}<br/>class Child extends React.Component {<br/>  constructor(props){<br/>    super(props);<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;button onClick={this.props.onTitleChange}&gt;Go&lt;/button&gt;<br/>    )<br/>  }<br/>}<br/>ReactDOM.render(&lt;Parent /&gt;, document.querySelector("#app"))</span></pre><p id="f479" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">工作提琴<a class="ae ly" href="https://jsfiddle.net/mtyson/21fm7c6t/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="9aee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以它所做的是获取一个在父组件中定义的函数<code class="fe lz ma mb lo b">onTitleChange</code>，并把它作为一个道具传递给子组件。</p><p id="68d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个函数道具，或者换句话说，一个普通的JavaScript回调函数。</p><p id="092d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">香草很好，因为香草很简单。</p><p id="1b40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你必须用父级中的<code class="fe lz ma mb lo b">bind(this)</code>来传入函数，这样当子级执行回调时，就会发生在父级的作用域内。</p><p id="0034" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们接受这一点之前，应该注意的是，从react引擎的角度来看，这种方法会导致回调属性看起来像是重新呈现的。</p><p id="bb68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能会影响性能。可能还不够担心，但是让我们看看更好的方法。</p><h2 id="bf98" class="ls lt iq bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr ms bi translated">使用组件级箭头函数</h2><p id="ddc6" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">获得正确范围的更好方法是在组件上使用箭头功能:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="a2f5" class="ls lt iq lo b gy lu lv l lw lx">class Parent extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>     title: "Foo"<br/>    }<br/>  }<br/>  onTitleChange = () =&gt; {<br/>    this.setState({"title":"bar"})<br/>  }  <br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;The Title: {this.state.title}&lt;/h1&gt;<br/>        &lt;Child onTitleChange={this.onTitleChange}&gt;&lt;/Child&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}<br/>class Child extends React.Component {<br/>  constructor(props){<br/>    super(props);<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;button onClick={this.props.onTitleChange}&gt;Go&lt;/button&gt;<br/>    )<br/>  }<br/>}<br/>ReactDOM.render(&lt;Parent /&gt;, document.querySelector("#app"))</span></pre><p id="7a83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以在这里我们已经移除了<code class="fe lz ma mb lo b">bind()</code>调用，只使用了arrows函数自动使用‘词法’作用域的事实。这意味着<code class="fe lz ma mb lo b">this</code>将解析到父组件。</p><p id="44cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重要的是，我们在组件本身上定义函数，而不是在render方法中内联。(后一种方法与在render方法中调用bind()具有相同的性能影响)。</p><p id="838f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以这是一个处理亲子沟通的简单好方法，可以避免任何陷阱。</p><p id="4ce0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您确实想使用绑定方法，可以在构造函数中设置该函数，然后在render中使用它。</p><h2 id="9b5d" class="ls lt iq bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr ms bi translated">发回参数</h2><p id="19e8" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">通常我们会希望在函数调用时发送一些参数。没问题，将子调用更改为lambda包装的调用:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="2317" class="ls lt iq lo b gy lu lv l lw lx">class Parent extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>     title: "Foo"<br/>    }<br/>  }<br/>  onTitleChange = (newTitle) =&gt; {<br/>    this.setState({"title":newTitle})<br/>  }<br/>  <br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;The Title: {this.state.title}&lt;/h1&gt;<br/>        &lt;Child onTitleChange={this.onTitleChange}&gt;&lt;/Child&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="2267" class="ls lt iq lo b gy my lv l lw lx">class Child extends React.Component {<br/>  constructor(props){<br/>    super(props);<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;button onClick={() =&gt; this.props.onTitleChange("baz")}&gt;Go&lt;/button&gt;<br/>    )<br/>  }<br/>}<br/>ReactDOM.render(&lt;Parent /&gt;, document.querySelector("#app"))</span></pre><p id="58ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ly" href="https://jsfiddle.net/mtyson/21fm7c6t/18/" rel="noopener ugc nofollow" target="_blank">拨弄这里。</a></p><h2 id="4e3a" class="ls lt iq bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr ms bi translated">功能组件</h2><p id="4126" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">这是功能型的。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="8997" class="ls lt iq lo b gy lu lv l lw lx">import React, { useState } from "react";<br/>import ReactDOM from "react-dom";<br/>function FChild(props) {<br/> return &lt;button <br/>          onClick={() =&gt; props.onTitleChange("Baz")}&gt;Go&lt;/button&gt;; <br/>}<br/>function Parent() {<br/>  let [title, setTitle] = useState("Foo");<br/>  const onTitleChange = newTitle =&gt; setTitle(newTitle);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;The Title: {title}&lt;/h1&gt;<br/>      &lt;FChild onTitleChange={onTitleChange} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;Parent /&gt;, rootElement);</span></pre><p id="3d47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顺便提一下，您可以看到相对于基于类的简化语法的好处:props语法相当简洁。</p><p id="658e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ly" href="https://codesandbox.io/s/react-hooks-usestate-jf66b" rel="noopener ugc nofollow" target="_blank">工作沙盒。</a></p><p id="ecfc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们介绍了<code class="fe lz ma mb lo b">useState</code>钩。这个钩子只是让一个功能组件处理状态。底线是，其余的机制是完全相同的。</p><h2 id="9554" class="ls lt iq bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr ms bi translated">路由器</h2><p id="46fa" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">最后，既然它被如此广泛地使用，让我提一下，你可以直接通过一个路由器传递这样的函数属性，正如这里描述的<a class="ae ly" href="https://tylermcginnis.com/react-router-pass-props-to-components/" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="022f" class="ls lt iq lo b gy lu lv l lw lx">&lt;Route path=’/foopath’ render={(props) =&gt; &lt;Child {…props} /&gt;} /&gt;</span></pre><p id="4a8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，您可以像以前一样继续操作(从父级开始):</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="1110" class="ls lt iq lo b gy lu lv l lw lx">&lt;Route appProps={{ onTitleChange }} /&gt;</span></pre></div></div>    
</body>
</html>