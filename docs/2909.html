<html>
<head>
<title>Node.js Best Practices — Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—错误处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-best-practices-error-handling-e121cff5e52a?source=collection_archive---------5-----------------------#2020-08-04">https://javascript.plainenglish.io/node-js-best-practices-error-handling-e121cff5e52a?source=collection_archive---------5-----------------------#2020-08-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e842f3838f6e35ceea9b23f782c0a2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oz3JlH-92wbSKitm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@iam_aspencer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Spencer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1adf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="7f67" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理错误</h1><p id="3028" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果一段代码有可能出错，我们应该处理这个错误。</p><p id="ff3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们改变了承诺，我们应该调用<code class="fe me mf mg mh b">catch</code>,并向其传递一个错误处理程序回调。</p><p id="7ec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c26a" class="mq lc iq mh b gy mr ms l mt mu">doSomething()<br/>  .then(doNextStage)<br/>  .then(doMoreThins)<br/>  .then(updateInterestedParties)<br/>  .then(cleanUp)<br/>  .catch(errorHandler);</span></pre><p id="db5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有传递了<code class="fe me mf mg mh b">errorHandler</code>回调函数的<code class="fe me mf mg mh b">catch</code>方法。</p><p id="d0d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当链中的任何承诺抛出错误时，将调用回调。</p><h1 id="81dd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">确保我们的应用程序自动重启</h1><p id="ecd0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该确保我们的应用程序自动重启。</p><p id="0948" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，当我们的应用程序遇到未处理的错误时，我们就不必自己去做了。</p><p id="e704" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个像Nodemon、forever或PM2这样的流程管理器来做这件事。</p><p id="d6b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后两个用于生产用途。</p><p id="519b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Nodemon更多的是用于开发。</p><p id="6517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过以下方式在全球范围内安装PM2:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4831" class="mq lc iq mh b gy mr ms l mt mu">npm install pm2 -g</span></pre><p id="9c5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以启动我们的节点应用程序:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e8a" class="mq lc iq mh b gy mr ms l mt mu">pm2 start app.js</span></pre><h1 id="b937" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将我们的应用集群化，以提高性能和可靠性</h1><p id="d8dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对我们的应用程序进行处理，这样我们就有了一个以上的实例。</p><p id="827a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们可以将工作分配给所有内核。</p><p id="a811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要这样做，因为节点应用程序在单个进程中运行。</p><p id="dd20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PM2让我们通过跑步轻松做到这一点:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d6ca" class="mq lc iq mh b gy mr ms l mt mu">pm2 start app.js -i max</span></pre><p id="e525" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使我们能够运行与服务器中存在的内核数量相等的多个进程。</p><p id="648d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些进程不共享内存或资源。</p><p id="73fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，它们都有自己的数据库连接。</p><p id="5f9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该使用Redis之类的东西来跨所有实例保持会话状态。</p><h1 id="22dd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">预先要求所有依赖关系</h1><p id="e278" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们的<code class="fe me mf mg mh b">require</code>调用都在顶部是个好主意，这样我们就不必在代码的各个部分寻找它们了。</p><p id="0b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以更早地发现他们的任何问题。</p><p id="d7a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5dd3" class="mq lc iq mh b gy mr ms l mt mu">const datastore = require("db")(someConfig);</span><span id="be02" class="mq lc iq mh b gy mv ms l mt mu">app.get("/my-service", (request, response) =&gt; {<br/>  db.get(req.query.someKey)<br/>  // ...<br/>});</span></pre><p id="f1ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在顶部调用<code class="fe me mf mg mh b">require</code>,这样我们可以更早地运行它们。</p><p id="3e79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们有任何错误，它们将在开始时被抛出。</p><p id="eb03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<code class="fe me mf mg mh b">require</code>是同步的，所以如果它需要很长时间运行，它会耽误我们的应用程序。</p><p id="9d95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有这样的问题，如果我们早点要求他们，我们会早点发现他们。</p><h1 id="e3bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用日志库来增加错误的可见性</h1><p id="0e71" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">任何环境下都可能发生错误。</p><p id="be1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望它们是可见的，这样我们就可以修复它们。</p><p id="da62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">console.log</code>在生产环境中非常有限。</p><p id="909f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更好的日志库可以让我们更好地控制如何记录日志。</p><p id="ba08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以有各种类型的日志记录或将数据保存在某个地方。</p><p id="d243" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些好的图书馆包括Loggly和Winston。Winston是基本日志记录的基础包。</p><p id="5d99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Node-Loggly使用Winston进行日志记录。</p><p id="2e7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们将在一个可搜索的中心位置看到错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/bf9a72f64fcb5d963cd10d7015370599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sBp7jhMKl3Hqtxu0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mbriney?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Briney</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5e9c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a39f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过对我们的代码进行一些修改，可以使错误处理变得容易。</p><p id="a05e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该捕捉错误并记录下来，这样我们就可以修复它们。</p><h2 id="7890" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="5711" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>