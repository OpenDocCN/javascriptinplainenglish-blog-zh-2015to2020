<html>
<head>
<title>The JavaScript Ecosystem #1 — Vanilla Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript生态系统# 1——普通的Web组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-javascript-ecosystem-blog-1-vanilla-web-components-7d6960f34ff9?source=collection_archive---------10-----------------------#2020-11-13">https://javascript.plainenglish.io/the-javascript-ecosystem-blog-1-vanilla-web-components-7d6960f34ff9?source=collection_archive---------10-----------------------#2020-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="728d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，欢迎来到我的关于JavaScript生态系统的新博客系列。我希望你和你认识的每个人在这个前所未有的时代保持安全和健康。我开始撰写这个博客系列，作为探索和实际实现JavaScript和Node.js中不同库的新事业的一部分。我希望以一种帮助web开发人员探索和开始使用新的库、框架或技术概念的方式来组织这个系列。希望你们喜欢学习！</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="a2b2" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">简介</strong></h1><p id="2fc3" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">在本系列的第一篇博文中，我们不要谈论任何库和框架，而是让我们深入到<strong class="jm io">普通JavaScript </strong> <em class="ls">(没有库。没有框架。只是编程语言JavaScript) </em>和实现<strong class="jm io"> Web组件</strong>的概念，而不使用任何现有的库或框架。Web组件在推动现代web用户界面方面发挥了巨大的作用，其基本概念被用作许多使用前端框架(如ReactJS、VueJS和Angular)构建的web应用程序的架构基础。根据MDN文档:</p><blockquote class="lt lu lv"><p id="3ae6" class="jk jl ls jm b jn jo jp jq jr js jt ju lw jw jx jy lx ka kb kc ly ke kf kg kh ig bi translated">Web组件可以定义为一套不同的技术，允许您创建可重用的自定义HTML元素，将它们的功能封装在代码的其余部分之外，并在您的web应用程序中使用它们。</p></blockquote><p id="0458" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单的基于浏览器的web组件的概念由三种主要技术组成:</p><ol class=""><li id="bf8b" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated"><strong class="jm io">自定义元素</strong> —一组JavaScript API方法，用于定义自定义HTML元素，修改它们的行为，并根据需要在UI中重用。</li><li id="70d3" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">影子DOM </strong> —一组JavaScript API方法，用于将封装的“影子”DOM树附加到元素上。简而言之，Shadow DOM API提供了一种有效的方法，可以将隐藏的独立DOM附加到HTML元素上，保持元素特性的私有性，并与文档的其他部分隔离开来。</li><li id="293b" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io"> HTML模板</strong> —渲染页面中不显示的HTML标签为<em class="ls"> &lt;模板&gt; </em>和&lt;槽&gt;。这些标签可以多次重复使用，作为定制元素结构的基础。</li></ol><p id="4377" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试着在一个简单的项目中实现这些技术。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="8520" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">项目介绍</h1><p id="ecd6" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">为了简单展示web组件如何使用普通JavaScript工作，我们将使用开放天气地图API构建一个简单的天气仪表板，以获取一个城市的实时天气信息。本项目的主要目标是满足以下要求:</p><ol class=""><li id="9a72" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">定义可以在整个UI中重用的自定义HTML元素。</li><li id="2f64" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">创建用于显示自定义元素的HTML模板。</li><li id="03c2" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">使用Shadow DOM添加特定于元素的特性。</li><li id="6250" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">在整个文档中重用和显示自定义元素。</li></ol><h2 id="337b" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated"><strong class="ak">文件结构:</strong></h2><p id="9925" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">用如下所示的文件初始化您的项目目录，并将一个基本的初学者模板添加到index.html文件中。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="264f" class="mn kq in ne b gy ni nj l nk nl">-webComponentBasics<br/>----index.html<br/>----weather.js</span></pre><h2 id="0866" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated"><strong class="ak">第一步。创建自定义HTML元素</strong></h2><p id="b0ac" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">打开你最喜欢的代码编辑器，打开<em class="ls"> weather.js </em>文件。您可以通过使用扩展HTML element接口的ES6 JavaScript类语法来创建自定义HTML元素。在<em class="ls"> weather.js </em>文件中，添加以下几行代码:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ff2b" class="mn kq in ne b gy ni nj l nk nl">class Weather extends HTMLElement {<br/>    constructor(){<br/>        this.innerHTML = "&lt;h2&gt;Simple Weather Dashboard&lt;/h2&gt;";<br/>    }</span><span id="a949" class="mn kq in ne b gy nm nj l nk nl">    connectedCallback(){}</span><span id="9e8a" class="mn kq in ne b gy nm nj l nk nl">    disconnectedCallback()<br/>}<br/>window.customElements.define("weather-card", Weather);</span></pre><p id="5d1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<em class="ls">&lt;&gt;</em>标签将<em class="ls"> weather.js </em>文件包含在您的<em class="ls">index.html</em>中，并将元素添加为<em class="ls">&lt;weather-card&gt;&lt;/weather-card&gt;</em>。瞧啊。您已经成功创建了第一个自定义HTML元素。</p><p id="effa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自定义HTML元素还为您提供了生命周期方法，如:</p><ol class=""><li id="31d2" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated"><strong class="jm io"> connectedCallback() </strong> —在DOM中插入元素时调用。</li><li id="a6ab" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">disconnectedCallback()</strong>—从DOM中移除元素时调用。</li><li id="fbad" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">attributeChangedCallback(attributeName，oldValue，newValue) </strong> —在添加、删除、更新或替换属性时调用。</li></ol><h2 id="ed6e" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated"><strong class="ak">步骤二。创建一个HTML模板</strong></h2><p id="1eb6" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">在weather.js文件中，使用以下代码行创建一个自定义HTML模板。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="069f" class="mn kq in ne b gy ni nj l nk nl">const template = document.createElement('template');<br/>template.innerHTML = `<br/>    &lt;style&gt;<br/>        .flex-child {<br/>            flex: 1;<br/>            border: 2px solid;<br/>        }<br/>        .card {<br/>            background: #f4f4f4;<br/>            width: 250px;<br/>            display: grid;<br/>            grid-gap: 10px;<br/>            margin-bottom: 15px;<br/>            padding: 15px;<br/>        }<br/>        .container {<br/>            padding: 2px 16px;<br/>        }<br/>        #toggle-info {<br/>            cursor: pointer;<br/>            background: darkred;<br/>            color: #fff;<br/>            border: 0;<br/>            border-radius: 5px;<br/>            padding: 5px 10px;<br/>        }<br/>    &lt;/style&gt;<br/>    &lt;div class="grid-child card"&gt;<br/>        &lt;div class="card-header"&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/div&gt;<br/>        &lt;div&gt;<br/>            &lt;h4 class="card-title"&gt;&lt;/h4&gt;<br/>            &lt;div class="temp"&gt;&lt;/div&gt;<br/>            &lt;h2 class="temp"&gt;&lt;span class="degree"&gt;&lt;/span&gt;&lt;/h2&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="more-info"&gt;&lt;/div&gt;<br/>        &lt;button id="toggle-info"&gt;Hide Info&lt;/button&gt;<br/>    &lt;/div&gt;<br/>`;</span></pre><p id="68ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要将这个特定的模板附加到您的定制HTML元素，您需要初始化Weather元素的Shadow DOM。在初始化Shadow DOM时，它将返回一个Shadow Root对象，该对象可用于修改Weather元素的行为。更新Weather类的构造函数，如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f3ca" class="mn kq in ne b gy ni nj l nk nl">class Weather extends HTMLElement {<br/>    constructor(){<br/>      this.attachShadow({ mode: 'open' }); //returns shadowRoot<br/>      this.shadowRoot.appendChild(template.content.cloneNode(true));<br/>    }<br/>    connectedCallback(){}<br/>    disconnectedCallback(){}<br/>}</span></pre><p id="081d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经设置了模板和定制元素，让我们继续进行API调用并更新相应的DOM元素。</p><h2 id="3d0f" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated">第三步。从打开的天气图API获取数据</h2><p id="d3a7" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">为了检索对应于给定位置的实时天气信息，我们将使用Open Weather Map API和JavaScript Fetch方法来处理这个API请求。将API请求方法包含在Weather元素类的构造函数中，以便在每次初始化元素时执行该方法。用下面的代码更新Weather元素类的构造函数。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="d0f3" class="mn kq in ne b gy ni nj l nk nl">constructor() {<br/>    super();<br/>    this.info = {};<br/>    this.attachShadow({ mode: 'open' });<br/>    this.shadowRoot.appendChild(template.content.cloneNode(true));</span><span id="cb13" class="mn kq in ne b gy nm nj l nk nl">    fetch(`https://community-open-weather-map.p.rapidapi.com/weather?q=London&amp;units=imperial`, {<br/>        "method": "GET",<br/>        "headers": {<br/>            "x-rapidapi-key": "YOUR_API_KEY",<br/>            "x-rapidapi-host": "community-open-weather-map.p.rapidapi.com"<br/>        }<br/>    }).then(response =&gt; return response.json();)<br/>      .then(data =&gt; {<br/>          this.info["temp"] = data["main"]["temp"];<br/>          this.info["maxTemp"] = data["main"]["temp_max"];<br/>          this.info["minTemp"] = data["main"]["temp_min"];<br/>          this.info["feelsLike"] = data["main"]["feels_like"];<br/>          this.info["weather"] = data["weather"][0];<br/>          this.info["windSpeed"] = data["wind"]["speed"];<br/>          return this.info<br/>    }).then(info =&gt; {<br/>          this.shadowRoot.querySelector('.card-title').innerText = info["weather"]["main"];<br/>          this.shadowRoot.querySelector('.temp').innerHTML = `&lt;h2&gt;${info.temp}&lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/h2&gt;`;<br/>          this.shadowRoot.querySelector('.more-info').innerHTML =<br/>`&lt;p&gt;Maximum Temp: ${info.maxTemp} &lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/p&gt;&lt;p&gt;Minimum Temp: ${info.minTemp} &lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/p&gt;<br/>&lt;p&gt;Feels Like: ${info.feelsLike} &lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/p&gt;<br/>&lt;p&gt;Wind Speed: ${info.windSpeed} MPH&lt;/p&gt;<br/>`;<br/>    }).catch(err =&gt; {<br/>        console.error(err);<br/>    });<br/>}</span></pre><p id="7ec6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们浏览一下上面的代码。我们已经初始化了一个简单的hashmap，用于存储来自API调用的相关数据。在收到来自API的响应时，hashmap根据需要用相关信息更新，并沿着<strong class="jm io">承诺管道链</strong>传递。使用影子根对象，我们选择模板中定义的类，并使用<em class="ls"> innerHTML </em>和<em class="ls"> innerText </em>方法更新DOM。</p><h2 id="9b28" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated">第四步。添加位置属性</h2><p id="599c" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">为了根据需要在不同的位置重用天气组件，让我们添加一个属性，我们可以将该属性与用于查询天气结果的自定义元素一起传递。在<em class="ls"/>中，将<em class="ls">位置</em>属性添加到&lt; <em class="ls">天气卡&gt;&lt;/天气卡&gt; </em>组件中。你最终的<em class="ls">index.html</em>文件应该如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0501" class="mn kq in ne b gy ni nj l nk nl">&lt;!doctype html&gt;<br/>&lt;html lang="en"&gt;<br/>    &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;<br/>    &lt;title&gt;Web Components Basics&lt;/title&gt;<br/>    &lt;style&gt;<br/>        .grid-container {<br/>            padding: 20px;<br/>            display: grid;<br/>            grid-template-columns: 1fr 1fr 1fr 1fr;<br/>            grid-gap: 20px;<br/>        }<br/>    &lt;/style&gt;<br/>    &lt;/head&gt;</span><span id="4286" class="mn kq in ne b gy nm nj l nk nl">    &lt;body&gt;<br/>        &lt;div class="grid-container"&gt;<br/>            &lt;weather-comp location="Mumbai"&gt;&lt;/weather-comp&gt;<br/>            &lt;weather-comp location="London"&gt;&lt;/weather-comp&gt;<br/>            &lt;weather-comp location="Sydney"&gt;&lt;/weather-comp&gt;<br/>        &lt;/div&gt;</span><span id="afa9" class="mn kq in ne b gy nm nj l nk nl">        &lt;script src="./weather.js"&gt;&lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d95c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了访问与自定义天气元素一起传递的属性值，我们可以在天气元素的构造函数中使用<em class="ls"> getAttribute() </em>方法。更新构造函数中的代码以检索属性的值，并使用该值从API进行查询。天气元素的构造函数应该如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="307c" class="mn kq in ne b gy ni nj l nk nl">constructor() {<br/>    super();<br/>    this.info = {};</span><span id="10dd" class="mn kq in ne b gy nm nj l nk nl">    //get value of attribute<br/>    this.location = this.getAttribute('location');</span><span id="feaf" class="mn kq in ne b gy nm nj l nk nl">    this.attachShadow({ mode: 'open' });<br/>    this.shadowRoot.appendChild(template.content.cloneNode(true));</span><span id="afaf" class="mn kq in ne b gy nm nj l nk nl">//substitute value of location in the API query<br/>    fetch(`https://community-open-weather-map.p.rapidapi.com/weather?q=${this.location}&amp;units=imperial`, {...})<br/>      .then(...)<br/>      .then(...)<br/>      .then(info =&gt; {</span><span id="09ba" class="mn kq in ne b gy nm nj l nk nl">      //Add this line to display the location on the weather card<br/>        this.shadowRoot.querySelector('.card-header h2').innerText = this.location;<br/>     })<br/>      .catch(err =&gt; {<br/>        console.error(err);<br/>     });<br/>}</span></pre><p id="27c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！我们现在有了一个可重用的天气组件，它可以呈现一个卡片，显示特定位置的实时天气数据。现在让我们添加一个切换功能来隐藏/显示一些天气信息。</p><h2 id="5bb2" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated">第五步。添加切换功能</h2><p id="163f" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">正如您在我们的元素模板中看到的，我们已经用ID #toggle-info定义了一个<button>元素。在元素构造函数中初始化一个布尔值，我们可以用它来确定元素的切换状态。在构造函数中添加以下代码行。</button></p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e255" class="mn kq in ne b gy ni nj l nk nl">constructor(){<br/>    this.showInfo = true;<br/>    ...<br/>}</span></pre><p id="facc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们添加一个方法，在切换值改变时更新DOM。在Weather类中添加以下方法:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="03be" class="mn kq in ne b gy ni nj l nk nl">toggleInfo() {<br/>    this.showInfo = !this.showInfo;<br/>    const moreInfo = this.shadowRoot.querySelector('.more-info');<br/>    const toggleBtn = this.shadowRoot.querySelector('#toggle-info');<br/>    if (this.showInfo) {<br/>        moreInfo.style.display = 'block';<br/>        toggleBtn.innerText = 'Hide Info';<br/>    } else {<br/>        moreInfo.style.display = 'none';<br/>        toggleBtn.innerText = 'More Info';<br/>    }<br/>}</span></pre><p id="46ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还必须为切换按钮注册一个事件侦听器，并且我们将使用元素生命周期方法在元素插入DOM时注册一个事件侦听器，在元素从DOM中移除时注销一个事件侦听器。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="95fd" class="mn kq in ne b gy ni nj l nk nl">connectedCallback() {<br/>    this.shadowRoot.querySelector('#toggle-info').addEventListener('click', () =&gt; {<br/>        this.toggleInfo();<br/>    });<br/>}</span><span id="5528" class="mn kq in ne b gy nm nj l nk nl">disconnectedCallback() {<br/>    this.shadowRoot.querySelector('#toggle-info').removeEventListener();<br/>}</span></pre><h2 id="15fb" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated">第六步。包扎</h2><p id="94a0" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">为了防止你在中途迷失方向，请在下面找到<em class="ls"> weather.js </em>的完整代码</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="dbe7" class="mn kq in ne b gy ni nj l nk nl">const template = document.createElement('template');<br/>template.innerHTML = `<br/>    &lt;style&gt;<br/>        .card {<br/>            background: #f4f4f4;<br/>            width: 250px;<br/>            display: grid;<br/>            grid-gap: 10px;<br/>            margin-bottom: 15px;<br/>            padding: 15px;<br/>        }<br/>        .container {<br/>           padding: 2px 16px;<br/>        }<br/>        #toggle-info {<br/>           cursor: pointer;<br/>           background: darkred;<br/>           color: #fff;<br/>           border: 0;<br/>           border-radius: 5px;<br/>           padding: 5px 10px;<br/>        }<br/>    &lt;/style&gt;<br/>    &lt;div class="grid-child card"&gt;<br/>        &lt;div class="card-header"&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/div&gt;<br/>        &lt;div&gt;<br/>            &lt;h4 class="card-title"&gt;&lt;/h4&gt;<br/>            &lt;div class="temp"&gt;&lt;/div&gt;<br/>            &lt;h2 class="temp"&gt;&lt;span class="degree"&gt;&lt;/span&gt;&lt;/h2&gt;<br/>       &lt;/div&gt;<br/>       &lt;div class="more-info"&gt;&lt;/div&gt;<br/>       &lt;button id="toggle-info"&gt;Hide Info&lt;/button&gt;&lt;/div&gt;<br/>`</span><span id="7ec7" class="mn kq in ne b gy nm nj l nk nl">class Weather extends HTMLElement {<br/>    constructor() {<br/>      super();<br/>      this.showInfo = true;<br/>      this.info = {};<br/>      this.location = this.getAttribute('location');<br/>      this.attachShadow({ mode: 'open' });<br/>      this.shadowRoot.appendChild(template.content.cloneNode(true));<br/>      fetch(`https://community-open-weather-map.p.rapidapi.com/weather?q=${this.location}&amp;units=imperial`, {    "method": "GET","headers": {<br/>        "x-rapidapi-key": "YOUR_API_KEY",<br/>        "x-rapidapi-host": "community-open-weather-map.p.rapidapi.com"<br/>     }})<br/>      .then(response =&gt; {<br/>          return response.json();<br/>      })<br/>      .then(data =&gt; {<br/>          this.info["temp"] = data["main"]["temp"];<br/>          this.info["maxTemp"] = data["main"]["temp_max"];<br/>          this.info["minTemp"] = data["main"]["temp_min"];<br/>          this.info["feelsLike"] = data["main"]["feels_like"];<br/>          this.info["weather"] = data["weather"][0];<br/>          this.info["windSpeed"] = data["wind"]["speed"];<br/>          return this.info<br/>      })<br/>      .then(info =&gt; {<br/>        this.shadowRoot.querySelector('.card-header h2').innerText = this.location;<br/>        this.shadowRoot.querySelector('.card-title').innerText = info["weather"]["main"];<br/>        this.shadowRoot.querySelector('.temp').innerHTML = `&lt;h2&gt;${info.temp}&lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/h2&gt;`;<br/>        this.shadowRoot.querySelector('.more-info').innerHTML = `<br/>          &lt;p&gt;Maximum Temp: ${info.maxTemp} &lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/p&gt;<br/>          &lt;p&gt;Minimum Temp: ${info.minTemp} &lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/p<br/>          &lt;p&gt;Feels Like: ${info.feelsLike} &lt;span&gt;&amp;#176;&lt;/span&gt; F&lt;/p<br/>          &lt;p&gt;Wind Speed: ${info.windSpeed} MPH&lt;/p&gt;<br/>        `;<br/>      })<br/>      .catch(err =&gt; {<br/>          console.error(err);<br/>      });<br/>    }</span><span id="a565" class="mn kq in ne b gy nm nj l nk nl">    toggleInfo() {<br/>        this.showInfo = !this.showInfo;<br/>        const moreInfo = this.shadowRoot.querySelector('.more-info');<br/>        const toggleBtn = this.shadowRoot.querySelector('#toggle-info');<br/>        if (this.showInfo) {<br/>            moreInfo.style.display = 'block';<br/>            toggleBtn.innerText = 'Hide Info';<br/>        } else {<br/>            moreInfo.style.display = 'none';<br/>            toggleBtn.innerText = 'More Info';<br/>        }<br/>    }</span><span id="b5b5" class="mn kq in ne b gy nm nj l nk nl">    connectedCallback() {<br/>        this.shadowRoot.querySelector('#toggle-info').addEventListener('click', () =&gt; {<br/>            this.toggleInfo();<br/>        });<br/>    }</span><span id="fe09" class="mn kq in ne b gy nm nj l nk nl">    disconnectedCallback() {<br/>        this.shadowRoot.querySelector('#toggle-info').removeEventListener();<br/>    }</span><span id="86f7" class="mn kq in ne b gy nm nj l nk nl">}</span><span id="964b" class="mn kq in ne b gy nm nj l nk nl">window.customElements.define('weather-comp', Weather);</span></pre><h2 id="44ad" class="mn kq in bd kr mo mp dn kv mq mr dp kz jv ms mt ld jz mu mv lh kd mw mx ll my bi translated">应用预览</h2><p id="3ddb" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">恭喜你！您已经使用用普通JavaScript、HTML和CSS开发的Web组件构建了一个简单的天气仪表板应用程序。您可以使用Bootstrap或任何您喜欢的CSS框架进一步定制和修改它。</p><p id="6a84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在这里找到这个应用<a class="ae nn" href="https://github.com/msalvi96/Essential-JS-Libraries/tree/main/webComponentBasics" rel="noopener ugc nofollow" target="_blank">的源代码:</a></p><figure class="mz na nb nc gt np gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi no"><img src="../Images/8f1f2cd918d2cbdc6fd894cfd4bce00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VmjTAsJbhhu16ctDQsqNcQ.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">App Preview</figcaption></figure></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="4ff6" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论:</h1><p id="aada" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">Web组件的概念已经被许多现有的前端框架使用，如ReactJS、VueJS和Angular，允许开发人员创建自定义的可重用组件，这些组件可以在用户界面中多次使用。</p><p id="c3a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Web组件确实提供了一种封装代码逻辑的有效方法，并且更好地构建了应用程序的“视图”部分。尽管使用定制的JavaScript元素和HTML模板已经成为新兴前端框架的过去式，但是了解如何使用普通JavaScript构建这些组件可以确保您在Web组件和相关技术方面有一个坚实的基础。</p><p id="261f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你从这篇文章中学到了一些新的东西，任何反馈/评论都将不胜感激。谢谢你，保持安全，保重，我会在下一篇文章中看到你！</p></div></div>    
</body>
</html>