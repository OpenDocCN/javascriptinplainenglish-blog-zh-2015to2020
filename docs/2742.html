<html>
<head>
<title>JavaScript Best Practices — No Useless Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—没有无用的语法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-no-useless-syntax-baf369813bed?source=collection_archive---------11-----------------------#2020-07-19">https://javascript.plainenglish.io/javascript-best-practices-no-useless-syntax-baf369813bed?source=collection_archive---------11-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/25353fbee3eb633c83b0b8c1d4ab2e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4uEbuAsBv-duiHA5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@heftiba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Toa Heftiba</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4692" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="2423" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有承诺就没有等待</h1><p id="3e1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该只在承诺的时候使用<code class="fe me mf mg mh b">await</code>。</p><p id="7616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe me mf mg mh b">await</code>与其他任何东西一起使用，这肯定是一个错误。</p><p id="f0b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cd2f" class="mq lc iq mh b gy mr ms l mt mu">async function foo(){<br/>  return 10;<br/>}</span></pre><p id="b428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a90" class="mq lc iq mh b gy mr ms l mt mu">async function foo(){<br/>  const val = await aPromise;<br/>}</span></pre><h1 id="4b70" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有逗号运算符</h1><p id="327e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用逗号运算符。</p><p id="3f08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它所做的只是返回列表中的最后一项。</p><p id="4502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写"</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5900" class="mq lc iq mh b gy mr ms l mt mu">switch (foo) {<br/>  case 1, 2, 3:<br/>    return true;<br/>  case 4, 5:<br/>    return false;<br/>}</span></pre><p id="edef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5079" class="mq lc iq mh b gy mr ms l mt mu">switch (foo) {<br/>  case 3:<br/>    return true;<br/>  case 5:<br/>    return false;<br/>}</span></pre><h1 id="1ac0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对if、for、do或while语句使用大括号</h1><p id="4f50" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在这些语句中使用花括号，这样我们就可以知道块在哪里开始或结束。</p><p id="2911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="896a" class="mq lc iq mh b gy mr ms l mt mu">if (foo === 'baz')<br/>  foo = 10;</span></pre><p id="0112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="89a3" class="mq lc iq mh b gy mr ms l mt mu">if (foo === 'baz') {<br/>  foo = 10;<br/>}</span></pre><p id="bb98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，如果我们在它下面有任何东西，我们就不会误认为它在块内。</p><h1 id="2ad5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">for-in应该使用if语句进行过滤</h1><p id="8b79" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们写一个for-in循环，我们应该用<code class="fe me mf mg mh b">hasOwnProperty</code>过滤掉继承的属性。</p><p id="a1a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="968e" class="mq lc iq mh b gy mr ms l mt mu">for (let key in obj) {<br/>  // do something<br/>}</span></pre><p id="5355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="98bd" class="mq lc iq mh b gy mr ms l mt mu">for (let key in obj) {<br/>  if (obj.hasOwnProperty(key)) {<br/>    // do something<br/>  }<br/>}</span></pre><h1 id="6071" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有函数构造函数</h1><p id="f87a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe me mf mg mh b">Function</code>构造函数来创建函数。</p><p id="7b76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码在一个字符串中，这意味着我们不能分析或优化它。</p><p id="577f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也是一个安全风险。</p><p id="7924" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ab35" class="mq lc iq mh b gy mr ms l mt mu">let multiply = new Function('a', 'b', 'return a * b');</span></pre><p id="92bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3691" class="mq lc iq mh b gy mr ms l mt mu">let multiply = (a: number, b: number) =&gt; a * b</span></pre><h1 id="0cf4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">标签的使用</h1><p id="9f10" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">标签只能用于<code class="fe me mf mg mh b">do</code>、<code class="fe me mf mg mh b">for</code>、<code class="fe me mf mg mh b">while</code>或<code class="fe me mf mg mh b">switch</code>语句。</p><p id="5bc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们与<code class="fe me mf mg mh b">break</code>或<code class="fe me mf mg mh b">continue</code>一起用于控制回路。</p><p id="75fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="00da" class="mq lc iq mh b gy mr ms l mt mu">A:<br/>  while (foo) {<br/>    if (bar) {<br/>      continue A;<br/>    }<br/>  }</span></pre><p id="42a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">A</code>标记这个循环。</p><p id="212d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在上面用了<code class="fe me mf mg mh b">continue</code>，如果<code class="fe me mf mg mh b">bar</code>是<code class="fe me mf mg mh b">true</code>就运行。</p><h1 id="d985" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用参数属性</h1><p id="45ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe me mf mg mh b">arguemnt.callee</code>来获取调用函数的函数。</p><p id="9658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得优化变得不可能。</p><p id="96e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在严格模式下也是不允许的。</p><h1 id="f9ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有等待就没有异步</h1><p id="5678" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该不用<code class="fe me mf mg mh b">await</code>而用<code class="fe me mf mg mh b">async</code>。</p><p id="df75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有<code class="fe me mf mg mh b">await</code>，这意味着我们没有在函数中使用任何承诺。</p><p id="c3de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那就意味着我们不需要它。</p><p id="2e0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7d8" class="mq lc iq mh b gy mr ms l mt mu">async function f() {<br/>  doSomething();<br/>}</span></pre><p id="37c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d374" class="mq lc iq mh b gy mr ms l mt mu">async function f() {<br/>  await makeRequest();<br/>}</span></pre><p id="e129" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">makeRequest</code>是一个返回承诺的函数。</p><h1 id="8ea4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">条件句中没有赋值</h1><p id="4767" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在没有比较或其他布尔表达式的条件中赋值可能是错误的。</p><p id="2472" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们应该检查一下。</p><p id="f3fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:"</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f24f" class="mq lc iq mh b gy mr ms l mt mu">if (foo == bar ){<br/>  //...<br/>}</span></pre><p id="e5c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该确保它是有效的。</p><h1 id="7045" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有重复的超级呼叫</h1><p id="8fae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在一个子类的<code class="fe me mf mg mh b">constructor</code>中，我们只需要调用<code class="fe me mf mg mh b">super</code>一次。</p><p id="f04a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用它不止一次，我们会得到一个错误。</p><p id="bc14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6143" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends Bar {<br/>  constructor() {<br/>    super(name);<br/>    super(name);<br/>  }<br/>}</span></pre><p id="d990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a829" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends Bar {<br/>  constructor() {<br/>    super(name);<br/>  }<br/>}</span></pre><h1 id="4cbd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有重复的开关盒</h1><p id="ddb3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在一个<code class="fe me mf mg mh b">switch</code>块中，我们不应该有多个具有相同值的<code class="fe me mf mg mh b">case</code>语句。</p><p id="7e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于短路，只有第一种情况会运行。</p><p id="2f03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，代替书写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cd01" class="mq lc iq mh b gy mr ms l mt mu">switch (bar) {<br/>  case 1:<br/>    return 'foo';<br/>  case 1:<br/>    return 'bar';<br/>  case 2:<br/>    return 'baz';<br/>}</span></pre><p id="0101" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a29a" class="mq lc iq mh b gy mr ms l mt mu">switch (bar) {<br/>  case 1:<br/>    return 'foo';<br/>  case 2:<br/>    return 'baz';<br/>}</span></pre><h1 id="c994" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有重复变量</h1><p id="c8ae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中不应该有重复的变量。</p><p id="38f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">var</code>声明可以有JavaScript解释器没有选择的副本。</p><p id="e164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们要确保不会出现这样的情况:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8fb6" class="mq lc iq mh b gy mr ms l mt mu">var a = 1;<br/>var a = 2;</span></pre><p id="b585" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该去掉其中一个，或者更好，用<code class="fe me mf mg mh b">let</code>或<code class="fe me mf mg mh b">const</code>代替<code class="fe me mf mg mh b">var</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/2d07136f163e8d06fd93c1fcb6b68bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*muKGyk1umValcHB9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@marius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marius Masalar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d620" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4a91" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有重复的<code class="fe me mf mg mh b">var</code>声明或<code class="fe me mf mg mh b">case</code>块。</p><p id="9817" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">花括号有助于分隔块。</p><p id="8ee1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">await</code>只能与承诺一起使用。</p><h2 id="6bde" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">简单英语的JavaScript</h2><p id="af1d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>