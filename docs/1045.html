<html>
<head>
<title>JavaScript Events Handlers — onfullscreenerror and onpaste</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序— onfullscreenerror和onpaste</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-events-handlers-onfullscreenerror-and-onpaste-b8ff6d4f1625?source=collection_archive---------4-----------------------#2020-01-20">https://javascript.plainenglish.io/javascript-events-handlers-onfullscreenerror-and-onpaste-b8ff6d4f1625?source=collection_archive---------4-----------------------#2020-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi jr"><img src="../Images/541ae5e8d10f14cd9ef993843535fddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jTXPYkSNX5_HqvPA"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/@dearseymour?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ksenia Makagonova</a> on <a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6380" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配事件处理程序来处理这些事件。发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将看看<code class="fe jn jo jp jq b">onfullscreenerror</code>和<code class="fe jn jo jp jq b">onpaste</code>事件处理程序。</p><h1 id="77f1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">window . document . onfull screen error</h1><p id="eb0d" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated"><code class="fe jn jo jp jq b">onfullscreenerror</code>属性让我们分配一个事件处理程序来处理<code class="fe jn jo jp jq b">fullscreenerror</code>事件。如果尝试调用<code class="fe jn jo jp jq b">requestFullScreen</code>方法失败，那么<code class="fe jn jo jp jq b">fullscreenerror</code>将被触发，而<code class="fe jn jo jp jq b">onfullscreenerror</code>事件处理程序将运行。例如，如果我们有以下代码:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="3413" class="mq lg iq jq b gy mr ms l mt mu">document.documentElement.requestFullscreen();</span><span id="dc74" class="mq lg iq jq b gy mv ms l mt mu">document.onfullscreenerror = event =&gt; {<br/>  console.log("onfullscreenerror");<br/>  console.log(event);<br/>};</span></pre><p id="9745" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">那么<code class="fe jn jo jp jq b">onfullscreenerror</code>处理程序将会运行，因为<code class="fe jn jo jp jq b">fullscreenerror</code>事件被触发。它被触发是因为<code class="fe jn jo jp jq b">requestFullScreen</code>只对用户与之交互的元素起作用。出于安全原因，它不能自动发生，所以会失败。错误事件如下所示:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="aeb9" class="mq lg iq jq b gy mr ms l mt mu">bubbles: true<br/>cancelBubble: false<br/>cancelable: false<br/>composed: true<br/>currentTarget: null<br/>defaultPrevented: false<br/>eventPhase: 0<br/>isTrusted: true<br/>path: (3) [html, document, Window]<br/>returnValue: true<br/>srcElement: html<br/>target: html<br/>timeStamp: 144.4549998268485<br/>type: "fullscreenerror"</span></pre><p id="d384" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这些是属于<code class="fe jn jo jp jq b">Event</code>对象的属性。一个<code class="fe jn jo jp jq b">Event</code>对象有以下值属性，其中许多是上面列出的:</p><ul class=""><li id="484c" class="mw mx iq kj b kk kl ko kp ks my kw mz la na le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">bubbles</code> —是一个只读布尔属性，指示事件是否在DOM树中冒泡。</li><li id="ca22" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">cancelBubble </code> —是<code class="fe jn jo jp jq b">stopPropagation</code>方法的历史别名。在从事件处理程序返回之前将其值设置为<code class="fe jn jo jp jq b">true</code>可防止事件传播。</li><li id="33da" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">cancelable</code> —只读布尔属性，指示事件是否可以取消。</li><li id="a7b5" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">composed </code> —是一个只读的布尔属性，指示事件是否可以跨越阴影DOM和常规DOM之间的边界。</li><li id="c0e0" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">currentTarget</code> —只读属性，引用当前注册的事件目标。这是当前计划将事件发送到的对象，但有可能在重定目标的过程中已经发生了变化。</li><li id="ea89" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">deepPath</code> —是事件冒泡通过的DOM节点数组。</li><li id="324e" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">defaultPrevented</code> —是一个只读布尔属性，指示是否在事件上调用了<code class="fe jn jo jp jq b">event.preventDefault()</code>。</li><li id="80f3" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">eventPhase</code> —是一个只读属性，指示正在处理事件流的哪个阶段。</li><li id="0d14" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">explicitOriginalTarget </code> —是一个只读属性，具有事件的显式原始目标。该属性仅在Mozilla浏览器中可用。</li><li id="6791" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">originalTarget </code> —是一个只读属性，在任何重定目标之前具有事件的原始目标。该属性仅在Mozilla浏览器中可用。</li><li id="3efa" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">returnValue </code> —是由Internet Explorer引入的历史属性，最终被纳入DOM规范，以确保现有站点继续工作。理想情况下，您应该尝试使用<code class="fe jn jo jp jq b">preventDefault()</code>和<code class="fe jn jo jp jq b">defaultPrevented </code>来取消事件并检查事件是否被取消，但是如果您选择这样做，也可以使用returnValue。</li><li id="e514" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">srcElement </code> —是旧版本Microsoft Internet Explorer中用于<code class="fe jn jo jp jq b">target</code>的非标准别名，出于web兼容性目的，其他一些浏览器也开始支持该别名。</li><li id="04d7" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">target </code> —只读属性，是对事件最初调度到的目标的引用。</li><li id="acab" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">timeStamp </code> —只读，包含事件的创建时间(以毫秒为单位)。根据规范，该值是自1970年1月1日以来的时间，但实际上浏览器的定义各不相同。</li><li id="b192" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">type </code> —具有事件名称的只读属性(不区分大小写)。</li><li id="fca6" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">isTrusted </code> —是一个只读属性，指示事件是由用户交互后的浏览器发起的，还是由使用类似<code class="fe jn jo jp jq b">initEvent</code>的事件创建方法的脚本发起的。</li></ul><p id="befd" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">上面的列表是部分属性。它只包含<code class="fe jn jo jp jq b">Event</code>对象的值属性。</p><figure class="mi mj mk ml gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nk"><img src="../Images/6c29bd8cbdff3d28983e20e7bb453d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YUcrwjYpyYSvxNWq"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/@foodism360?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">FOODISM360</a> on <a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2380" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">window.document.onpaste</h1><p id="c0bc" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated">属性让我们分配一个事件处理程序来处理<code class="fe jn jo jp jq b">paste</code>事件，当我们将剪贴板中的数据粘贴到web页面中时，就会触发该事件。例如，我们可以在下面的代码中使用它:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="a158" class="mq lg iq jq b gy mr ms l mt mu">document.onpaste = event =&gt; {<br/>  console.log(event);<br/>}</span></pre><p id="acaa" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们可以使用<code class="fe jn jo jp jq b">clipboardData</code>属性获取粘贴到应用程序中的剪贴板数据，这是一个具有<code class="fe jn jo jp jq b">getData</code>方法的<code class="fe jn jo jp jq b">DataTransfer</code>对象。<code class="fe jn jo jp jq b">DataTransfer</code>对象具有以下值属性:</p><ul class=""><li id="8ac1" class="mw mx iq kj b kk kl ko kp ks my kw mz la na le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">dropEffect </code> —返回当前所选拖放操作类型的字符串，或将该操作设置为新类型。可能的值有<code class="fe jn jo jp jq b">none</code>、<code class="fe jn jo jp jq b">copy</code>、<code class="fe jn jo jp jq b">link</code>或<code class="fe jn jo jp jq b">move</code>。</li><li id="aa87" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">effectAllowed </code> —返回可能的操作类型的字符串。可能的值是<code class="fe jn jo jp jq b">none</code>、<code class="fe jn jo jp jq b">copy</code>、<code class="fe jn jo jp jq b">copyLink</code>、<code class="fe jn jo jp jq b">copyMove</code>、<code class="fe jn jo jp jq b">link</code>、<code class="fe jn jo jp jq b">linkMove</code>、<code class="fe jn jo jp jq b">move</code>、<code class="fe jn jo jp jq b">all</code>或<code class="fe jn jo jp jq b">uninitialized</code>中的一个。</li><li id="a103" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">files </code>—<code class="fe jn jo jp jq b">FileList</code>数据传输中可用的所有本地文件的对象。如果拖动操作不涉及拖动文件，则该属性为空列表。</li><li id="aa7b" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">items</code> —是一个只读的给出了一个<code class="fe jn jo jp jq b">DataTransferItemList</code>对象，它是所有拖动数据的列表。</li><li id="f2fb" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">types</code> —是一个只读属性，它有一个字符串数组，给出了在<code class="fe jn jo jp jq b">dragstart</code>事件中设置的格式</li></ul><p id="fe5d" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">具有以下方法的<code class="fe jn jo jp jq b">DataTransfer</code>对象:</p><ul class=""><li id="816a" class="mw mx iq kj b kk kl ko kp ks my kw mz la na le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">clearData()</code>-删除与给定类型相关的数据。type参数是可选的。如果类型为空或未指定，则删除与所有类型关联的数据。如果指定类型的数据不存在，或者数据传输对象没有数据，则此方法不执行任何操作。它采用一个可选参数，该参数是一个带有要清除的数据类型的字符串。</li><li id="9ef3" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">getData() </code> —检索作为参数传入的字符串类型的数据，如果该类型的数据不存在或数据传输不包含数据，则检索空字符串。它接受一个参数，该参数是包含要检索的数据类型的字符串。</li><li id="d7a4" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">setData()</code> —设置给定类型的数据。它需要两个参数。第一个参数是被拖动数据的格式字符串，第二个参数是包含拖动对象数据的字符串。如果该类型的数据不存在，那么它将被添加到末尾，这将是新的格式。如果该类型的数据已经存在，现有数据将在相同位置被替换。</li><li id="0261" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">setDragImage() </code> —如果需要自定义图像，设置用于拖动的图像。它需要三个参数。第一个是图像<code class="fe jn jo jp jq b">Element</code>对象，用于拖动反馈图像。第二个和第三个参数是图像中的水平和垂直偏移量。</li></ul><p id="2595" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">要获得粘贴的文本数据，我们可以使用带有<code class="fe jn jo jp jq b">'Text'</code>参数的<code class="fe jn jo jp jq b">getData</code>方法，如下面的代码所示:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="da66" class="mq lg iq jq b gy mr ms l mt mu">document.onpaste = event =&gt; {<br/>  console.log(event);<br/>  console.log(event.clipboardData.getData('Text'));<br/>}</span></pre><p id="02ca" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们应该得到粘贴到页面上的文本数据。</p><p id="786a" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b">onfullscreenerror</code>事件处理程序让我们处理任何切换到全屏失败的情况，比如试图自动切换到全屏，而不需要用户交互，比如试图在<code class="fe jn jo jp jq b">documentElement</code>对象上调用<code class="fe jn jo jp jq b">requestFullScreen</code>。我们可以使用<code class="fe jn jo jp jq b">onpaste</code>事件处理程序来处理从剪贴板粘贴数据到我们的页面所触发的<code class="fe jn jo jp jq b">paste</code>事件，并通过使用<code class="fe jn jo jp jq b">event.clipboardData.getData(‘Text’)</code>方法调用来获取数据。</p></div></div>    
</body>
</html>