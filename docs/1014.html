<html>
<head>
<title>ES6 Promises: A better way of handling callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6承诺:处理回调的更好方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/es6-promises-a-better-way-of-handling-callbacks-fe9ecb847ad1?source=collection_archive---------0-----------------------#2020-01-15">https://javascript.plainenglish.io/es6-promises-a-better-way-of-handling-callbacks-fe9ecb847ad1?source=collection_archive---------0-----------------------#2020-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="05c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用承诺编写更易管理的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b7f11f59c31c64bc953e4bfc99a836a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYRGkQGzIOejPZMF8KHDzQ.jpeg"/></div></div></figure><p id="4bb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ES6引入了promises作为本机实现。在ES6之前，我们使用回调来处理异步操作。</p><p id="3df4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们来了解一下什么是回拨，什么与回拨相关的问题是通过承诺来解决的。</p><p id="d314" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑一下，我们有一个帖子列表和他们各自的评论。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="02b9" class="ls lt iq lo b gy lu lv l lw lx">const posts = [<br/>  { post_id: 1, post_title: 'First Post' },<br/>  { post_id: 2, post_title: 'Second Post' },<br/>  { post_id: 3, post_title: 'Third Post' },<br/>];<br/><br/>const comments = [<br/>  { post_id: 2, comment: 'Great Post!'},<br/>  { post_id: 2, comment: 'Nice Post!'},<br/>  { post_id: 3, comment: 'Awesome Post!'},<br/>];</span></pre><p id="f3f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将编写一个函数，通过传递帖子id来获取帖子，如果找到帖子，我们将获得与该帖子相关的评论</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="92f9" class="ls lt iq lo b gy lu lv l lw lx">const getPost = (id, callback) =&gt; {<br/> const post = posts.find( post =&gt; post.post_id === id);<br/> if(post) {<br/>   callback(null, post);<br/> } else {<br/>   callback("No such post", undefined);<br/> }<br/>};</span><span id="8904" class="ls lt iq lo b gy ly lv l lw lx">const getComments = (post_id, callback) =&gt; {<br/> const result = comments.filter( comment =&gt; comment.post_id === post_id);<br/> if(result) {<br/>   callback(null, result);<br/> } else {<br/>   callback("No comments found", undefined);<br/> }<br/>}</span></pre><p id="cb95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的<code class="fe lz ma mb lo b">getPost</code>和<code class="fe lz ma mb lo b">getComments</code>函数中，如果有错误，我们将把它作为第一个参数传递，如果我们得到了结果，我们将调用回调函数，把结果作为第二个参数传递。</p><p id="c926" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您熟悉Nodejs，那么您会知道这是每个Nodejs回调函数中使用的一种非常常见的做法。</p><p id="bc26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们使用这些函数</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="e3f5" class="ls lt iq lo b gy lu lv l lw lx">getPost(2, (error, post) =&gt; {<br/>    if(error) {<br/>     return console.log(error);<br/>    }<br/>    console.log('Post:', post);<br/>    getComments(post.post_id, (error, comments) =&gt; {<br/>        if(error) {<br/>          return console.log(error);<br/>        }<br/>        console.log('Comments:', comments);<br/>    });<br/>});</span></pre><p id="2824" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">执行上述代码后，您将看到以下输出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/9f856f88e9546d906a263a28ec8be70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGdycknCviRHAOGqYdTZ_g.png"/></div></div></figure><p id="4a70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">演示:<a class="ae md" href="https://codepen.io/myogeshchavan97/pen/PoweVgR?editors=0011#0" rel="noopener ugc nofollow" target="_blank">https://codepen.io/myogeshchavan97/pen/PoweVgR?editors=0011#0 </a></p><p id="2c9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，我们在<code class="fe lz ma mb lo b">getPost</code>回调函数中嵌套了<code class="fe lz ma mb lo b">getComments</code>函数。想象一下，如果我们也想找到注释之类的东西，那么它们也会嵌套在<code class="fe lz ma mb lo b">getComments</code>回调函数中，这样会产生更多的嵌套，这会使代码难以理解。</p><p id="0dca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回调的这种嵌套被称为回调地狱。</p><p id="a70e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，您可以看到错误处理条件不断重复，这产生了不好的重复代码。</p><p id="9d0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，为了解决这个问题，承诺被引入。</p><p id="c685" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">为了创建一个新的承诺，我们使用了承诺构造函数</strong></p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="d3fa" class="ls lt iq lo b gy lu lv l lw lx">const promise = new Promise((resolve, reject) =&gt; {</span><span id="4e96" class="ls lt iq lo b gy ly lv l lw lx">});</span></pre><p id="add2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Promise构造函数接受一个函数作为第一个参数。</p><p id="9915" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">resolve和reject是自动传递给函数的函数。</p><p id="86cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个承诺经历了三个阶段。</p><p id="8d9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">a)待定<br/> b)完成<br/> c)拒绝</p><p id="aae3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们创建一个承诺时，它处于<strong class="kt ir">待定</strong>状态，当我们调用resolve函数时，它进入<strong class="kt ir">已履行</strong>状态，如果我们调用reject，它将进入<strong class="kt ir">已拒绝</strong>状态。</p><p id="e39f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在传递给Promise构造函数的函数中执行异步操作，当我们得到异步操作的响应并且响应是ok时，我们调用resolve函数，如果有错误，我们调用reject函数。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="4fe4" class="ls lt iq lo b gy lu lv l lw lx">const resolvedPromise = () =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    resolve('worked!');<br/>  });<br/>};</span></pre><p id="17e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了访问已解析承诺的值，我们需要附加<strong class="kt ir">然后是</strong>处理程序，当承诺被解析时将调用该处理程序。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="df9a" class="ls lt iq lo b gy lu lv l lw lx">resolvedPromise().then((result) =&gt; {<br/>  console.log(result); // worked!<br/>});</span></pre><p id="8992" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当承诺被拒绝时，<strong class="kt ir"> catch </strong>处理程序将被执行</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="b16c" class="ls lt iq lo b gy lu lv l lw lx">const rejectedPromise = () =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    reject('something went wrong!');<br/>  });<br/>};<br/><br/>rejectedPromise().catch((error) =&gt; {<br/>  console.log('Error', error); // Error something went wrong!<br/>});</span></pre><p id="e619" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意，我们可以只传递一个值来解析和拒绝函数。</strong></p><p id="137f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看看下面的代码</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="08e4" class="ls lt iq lo b gy lu lv l lw lx">const multiply = number =&gt; {<br/>  if(number &gt; 0) {<br/>    return number * number;<br/>  } else {<br/>    return "Error while multiplying";<br/>  }<br/>};<br/><br/>const getPromise = value =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    const result = multiply(value);<br/>    if(typeof result === "number") {<br/>      resolve(result);<br/>    } else {<br/>      reject(result)<br/>    }<br/>  });<br/>};<br/><br/>getPromise(4)<br/> .then(result =&gt; console.log(result)) // 16<br/> .catch(error =&gt; console.log(error));<br/><br/>getPromise(-5)<br/> .then(result =&gt; console.log(result))<br/> .catch(error =&gt; console.log(error)); // Error while multiplying</span></pre><p id="7c9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，在getPromise函数中，我们传递一些值。如果该值是一个数字，那么我们返回该数字与其自身的乘积，否则返回一个错误。</p><p id="1497" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">演示:【https://codepen.io/myogeshchavan97/pen/PowaYBO?editors=0011 T2】</p><p id="f4b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="me">我们也可以附加多个then处理程序</em></p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="ba8d" class="ls lt iq lo b gy lu lv l lw lx">getPromise(4)<br/> .then(result =&gt; {<br/>   return getPromise(result);<br/>  })<br/> .then(output =&gt; console.log('result', output))<br/> .catch(error =&gt; console.log('error', error));</span></pre><p id="2642" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从第一个<strong class="kt ir">然后</strong>调用返回的值将被传递给第二个<strong class="kt ir">然后</strong>调用，依此类推。<br/>这种附加多个<strong class="kt ir">然后</strong>调用的方式被称为<strong class="kt ir">承诺链</strong>。</p><p id="594e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">演示:<a class="ae md" href="https://codepen.io/myogeshchavan97/pen/eYmKYZN?editors=0011" rel="noopener ugc nofollow" target="_blank">https://codepen.io/myogeshchavan97/pen/eYmKYZN?editors=0011</a></p><p id="74ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="me">如果承诺链中的任何一个承诺被拒绝，则链中的下一个承诺将不会被执行，而是在那里停止执行，并执行catch处理程序。</em></p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="7b61" class="ls lt iq lo b gy lu lv l lw lx">const multiply = number =&gt; {<br/>  if(number &gt; 0) {<br/>    return number * number;<br/>  } else {<br/>    return "Error while multiplying";<br/>  }<br/>};</span><span id="2aa4" class="ls lt iq lo b gy ly lv l lw lx">const getPromise = value =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    const result = multiply(value);<br/>    if(typeof result === "number") {<br/>      resolve(result);<br/>    } else {<br/>      reject(result)<br/>    }<br/>  });<br/>};</span><span id="5201" class="ls lt iq lo b gy ly lv l lw lx">getPromise(4)<br/> .then(result =&gt; {<br/>   console.log('first');<br/>   return getPromise(result);<br/>  })<br/> .then(result =&gt; {<br/>   console.log('second');<br/>   return getPromise(-5); // passing negative value will call reject<br/>  })<br/> .then(result =&gt; { // this will not be executed<br/>   console.log('third');<br/>   return getPromise(2);<br/>  })<br/> .then(output =&gt; console.log('last:', output))<br/> .catch(error =&gt; console.log('error:', error));</span></pre><p id="e536" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">演示:<a class="ae md" href="https://codepen.io/myogeshchavan97/pen/rNaKNWx?editors=0011" rel="noopener ugc nofollow" target="_blank">https://codepen.io/myogeshchavan97/pen/rNaKNWx?editors=0011</a></p><p id="19f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您在这里看到的，只有第一个和第二个<strong class="kt ir">然后是</strong>块被执行，第三个被跳过，因为承诺由于乘法函数中的负值检查而被拒绝。</p><p id="9bdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您对承诺和承诺链有了很好的理解，让我们看看如何使用承诺链解决第一个帖子和评论示例的回调问题。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="085e" class="ls lt iq lo b gy lu lv l lw lx">const posts = [<br/>  { post_id: 1, post_title: 'First Post' },<br/>  { post_id: 2, post_title: 'Second Post' },<br/>  { post_id: 3, post_title: 'Third Post' },<br/>];</span><span id="b459" class="ls lt iq lo b gy ly lv l lw lx">const comments = [<br/>  { post_id: 2, comment_id: 1, comment: 'Great Post!'},<br/>  { post_id: 2, comment_id: 2, comment: 'Nice Post!'},<br/>  { post_id: 3, comment_id: 3, comment: 'Awesome Post!'},<br/>];</span><span id="6bb3" class="ls lt iq lo b gy ly lv l lw lx">const getPost = (id) =&gt; {<br/> return new Promise((resolve, reject) =&gt; {<br/>   const post = posts.find( post =&gt; post.post_id === id);<br/>   if(post) {<br/>     resolve(post);<br/>   } else {<br/>     reject("No such post");<br/>   }<br/> });<br/>};</span><span id="223f" class="ls lt iq lo b gy ly lv l lw lx">const getComments = (post_id) =&gt; {<br/>   return new Promise((resolve, reject) =&gt; {<br/>     const result = comments.filter( comment =&gt; comment.post_id === post_id);<br/>     if(result) {<br/>       resolve(result);<br/>     } else {<br/>       reject("No comments found");<br/>     }<br/>   });<br/>}</span><span id="1f56" class="ls lt iq lo b gy ly lv l lw lx">getPost(2)<br/>  .then(post =&gt; {<br/>    console.log('Post:', post);<br/>    return post; // return the post to next then call to acess post_id<br/>   })<br/>  .then(post =&gt; getComments(post.post_id))<br/>  .then(comments =&gt; console.log('Comments:', comments))<br/>  .catch(error =&gt; console.log(error));</span></pre><p id="691a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">演示:<a class="ae md" href="https://codepen.io/myogeshchavan97/pen/YzPvzVe?editors=0011" rel="noopener ugc nofollow" target="_blank">https://codepen.io/myogeshchavan97/pen/YzPvzVe?editors=0011</a></p><p id="18a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您比较回调和承诺的代码，您可以看到如下所示的差异</p><div class="kg kh ki kj gt ab cb"><figure class="mf kk mg mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/7f252244937355bb0af47139dfd8e6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*6IhAOVM97zEVkRQVM-i9ug.png"/></div></figure><figure class="mf kk ml mh mi mj mk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/63b72905c5ef7d351a1f36f0318fb306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*PyB0AcLJnIxAl9JCA4jCnw.png"/></div></figure></div><p id="0f41" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们将回调函数调用更改为根据响应进行解析或拒绝，并使用承诺链来避免函数调用的嵌套。我们还避免了仅使用一个catch处理程序进行重复的错误条件检查。</p><p id="6c43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天到此为止。希望你今天学到了新东西。</p><p id="788e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">别忘了直接在你的收件箱</strong> <a class="ae md" href="https://yogeshchavan.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">这里</strong> </a> <strong class="kt ir">订阅我的每周时事通讯，里面有惊人的技巧、诀窍和文章。</strong></p></div></div>    
</body>
</html>