<html>
<head>
<title>Facebook coding interview questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">脸书编码面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/facebook-coding-interview-questions-9e40bdbbec35?source=collection_archive---------2-----------------------#2020-03-13">https://javascript.plainenglish.io/facebook-coding-interview-questions-9e40bdbbec35?source=collection_archive---------2-----------------------#2020-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6d0e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过每天解决一个问题，变得非常擅长编写面试代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d75523dd4f3fea51cf211b2064387d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcwDxpDVN_vnWAmb1fVGgQ.png"/></div></div></figure><p id="25a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">(2020年4月28日更新)</em></p><h1 id="8c9e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">日常编码问题</h1><p id="e0aa" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">它们是受真实编程面试启发的各种各样的问题，带有深入的解决方案，清晰地带您了解每个核心概念。</p><blockquote class="ml"><p id="eff4" class="mm mn iq bd mo mp mq mr ms mt mu lm dk translated">通过每天解决一个问题，变得格外擅长编写面试代码。</p></blockquote><p id="3c54" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">我们将一起使用JavaScript解决这些问题。</p><h1 id="ce46" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#1</h1><h2 id="0765" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">问题</h2><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="b873" class="nb lp iq no b gy ns nt l nu nv">Given the mapping a = 1, b = 2, … z = 26, and an encoded message, count the number of ways it can be decoded.</span></pre><p id="a237" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，消息<code class="fe nw nx ny no b">‘111’</code>将给出<code class="fe nw nx ny no b">3</code>，因为它可以被解码为<code class="fe nw nx ny no b">‘aaa’, ‘ka’, and ‘ak’</code>。</p><p id="40bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以假设这些消息是可解码的。比如<code class="fe nw nx ny no b">‘001’</code>是不允许的。</p><h2 id="5012" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">解决办法</h2><p id="699a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">首先，我们定义函数isDecodable <code class="fe nw nx ny no b">(message)</code>,如果消息可解码，则返回1，否则返回0。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="e79d" class="nb lp iq no b gy ns nt l nu nv">function isDecodable(message) {<br/>    for (let i = 0; i &lt; message.length; i++) {<br/><br/>        var parsed = parseInt(message[i], 10)<br/><br/>        if (isNaN(parsed)) {<br/>            return false<br/>        }<br/><br/>        if ((parsed &gt; 0 &amp;&amp; parsed &lt; 27) != true) {<br/>            return false<br/>        }<br/>    }<br/>    return true<br/>}</span></pre><p id="504c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们假设消息是可解码的。为了解决这个问题，我们使用了基于递归的解决方案。</p><p id="b813" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果一个字符串的长度是1，总有一种方法可以解码，所以这是我们的基本情况。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="97fd" class="nb lp iq no b gy ns nt l nu nv">'1':<br/>    ['1']<br/><br/>----------<br/>F('1') = 1</span><span id="9aa2" class="nb lp iq no b gy nz nt l nu nv">if (message.length &lt;=1) {<br/>    return 1<br/>}</span></pre><p id="0088" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果长度是2，我们总是有1路分别处理所有数字，如果一个数字小于<code class="fe nw nx ny no b">26</code>，则加1，我们也使用这一路作为基本情况。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="4ae6" class="nb lp iq no b gy ns nt l nu nv">'12':<br/>    ['1', '2']<br/>    ['12']<br/>---------------------<br/>F('12') = f('12') + 1</span></pre><p id="bb63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果长度为3，我们可以使用之前计算的结果，因为我们已经知道如何处理更短的字符串。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="9082" class="nb lp iq no b gy ns nt l nu nv">F('123') = f('1') * F('23') + F('12') * f('3') = 3</span></pre><p id="fef6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，所有接下来的情况都可以用这种方法计算。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="800c" class="nb lp iq no b gy ns nt l nu nv">F('4123') = f('4') * F('123') + f('41') * F('23') = 3</span></pre><p id="7e04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个问题的最终源代码</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="9b07" class="nb lp iq no b gy ns nt l nu nv">function decode_cnt_no_zero(message) {<br/><br/>    let length = message.length<br/><br/>    if (length &lt;=1) {<br/>        return 1<br/>    }<br/><br/>    if (length &gt;=2) {<br/><br/>        var parsed = parseInt(message.substring(0,2),10)<br/><br/>        if (parsed &gt;=0 &amp;&amp; parsed &lt;= 26) {<br/>            return (decode_cnt_no_zero(message.substring(1,length)) <br/>            + decode_cnt_no_zero(message.substring(2, length)))<br/>        }<br/>        return decode_cnt_no_zero(message.substring(1, length))<br/><br/>    }<br/>}</span></pre><p id="2dd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们尝试探索我们的解决方案。</p><ul class=""><li id="d017" class="oa ob iq kt b ku kv kx ky la oc le od li oe lm of og oh oi bi translated">解码1字符串的结果是1。</li></ul><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="dbbc" class="nb lp iq no b gy ns nt l nu nv">decode_cnt_no_zero(“1”)<br/>&lt;&lt; 1</span></pre><ul class=""><li id="3bdc" class="oa ob iq kt b ku kv kx ky la oc le od li oe lm of og oh oi bi translated">解码12字符串的结果是2。</li></ul><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="eaf4" class="nb lp iq no b gy ns nt l nu nv">decode_cnt_no_zero(“12”)<br/>&lt;&lt; 2</span></pre><ul class=""><li id="1c61" class="oa ob iq kt b ku kv kx ky la oc le od li oe lm of og oh oi bi translated">解码123字符串的结果是3。</li></ul><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="8893" class="nb lp iq no b gy ns nt l nu nv">decode_cnt_no_zero(“123”)<br/>&lt;&lt; 3</span></pre><ul class=""><li id="4bd0" class="oa ob iq kt b ku kv kx ky la oc le od li oe lm of og oh oi bi translated">解码4123字符串的结果是3。</li></ul><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="7622" class="nb lp iq no b gy ns nt l nu nv">decode_cnt_no_zero(“4123”)<br/>&lt;&lt; 3</span></pre><h1 id="b19e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#2</h1><h2 id="36d2" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">问题</h2><p id="f2e1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">给定一个太大而无法存储在内存中的元素流，以均匀的概率从流中选取一个随机元素。</p><h2 id="e048" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">解决办法</h2><p id="3301" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">返回一个函数，该函数为每个元素流选择一个随机元素。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="6dd9" class="nb lp iq no b gy ns nt l nu nv">const selectRandomizer = function () {<br/>    let streamCount = 0<br/>    let selected<br/><br/>    const rand = function (stream) {<br/>        for (let i = 0; i &lt; stream.length; i++) {<br/>            streamCount++<br/>            if (streamCount === 0) selected = stream[i]<br/>            else if (Math.random() &lt;= 1 / streamCount) {<br/>                selected = stream[i]<br/>            }<br/>        }<br/>        return selected<br/>    }<br/><br/>    return rand<br/>}</span></pre><h1 id="58c4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#3</h1><h2 id="745d" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">问题</h2><p id="222d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一个建筑商想要建造一排N栋房子，它们可以有K种不同的颜色。他的目标是最小化成本，同时确保没有两个相邻的房子是相同的颜色。</p><p id="847e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定一个N乘K的矩阵，其中第N行和第K列表示建造第N个颜色的房子的成本，返回实现这个目标的最小成本。</p><h2 id="ce37" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">解决办法</h2><p id="5e8e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">返回用K种不同颜色建造N栋房屋的最小成本，其中没有两栋相邻的房屋颜色相同。</p><p id="68bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个解，时间复杂度为O(NKK)，空间复杂度为O(NK)。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="e4ea" class="nb lp iq no b gy ns nt l nu nv">const minCostHouseColorInitialSolution = function(costs) {<br/>    if (costs.length === 0) return 0<br/>  <br/>    const n = costs.length<br/>    const k = costs[0].length<br/>  <br/>    // 2d array with n length and k rows<br/>    const dp = [...Array(n)].map(() =&gt; Array(k))<br/>  <br/>    // fill first row<br/>    for (let col = 0; col &lt; k; col++) {<br/>      dp[0][col] = costs[0][col]<br/>    }<br/>  <br/>    for (let row = 1; row &lt; n; row++) {<br/>      // Finding the lowest costs for each column in this row<br/>      for (let col = 0; col &lt; k; col++) {<br/>        dp[row][col] = Number.MAX_SAFE_INTEGER<br/>  <br/>        for (let numCol = 0; numCol &lt; k; numCol++) {<br/>          // we dont want the same column, as that is 2 houses of same color<br/>          if (numCol !== col) {<br/>            dp[row][col] = Math.min(<br/>              dp[row][col],<br/>              dp[row - 1][numCol] + costs[row][col]<br/>            );<br/>          }<br/>        }<br/>      }<br/>    }<br/>  <br/>    let minCost = Number.MAX_SAFE_INTEGER;<br/>    // get minimum of last row in dp table<br/>    for (let col = 0; col &lt; k; col++) {<br/>      minCost = Math.min(minCost, dp[n - 1][col])<br/>    }<br/>  <br/>    return minCost<br/>  }</span></pre><p id="2487" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，仍然是<code class="fe nw nx ny no b">O(NKK)</code>时间复杂度，而是<code class="fe nw nx ny no b">O(K)</code>空间复杂度。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="b5c0" class="nb lp iq no b gy ns nt l nu nv">const minCostHouseColorII = function (costs) {<br/>    if (costs.length === 0) return 0<br/><br/>    const n = costs.length<br/>    const k = costs[0].length<br/><br/>    const dp1 = [] // the last row<br/>    const dp2 = [] // the current row<br/><br/>    // start the first row of costs, as the last row, and build from the second row onwards<br/>    for (let i = 0; i &lt; k; i++) {<br/>        dp1[i] = costs[0][i]<br/>    }<br/><br/>    for (let row = 1; row &lt; n; row++) {<br/>        for (let j = 0; j &lt; k; j++) {<br/>            // Finding the lowest costs for each column in this row<br/>            dp2[j] = Number.MAX_SAFE_INTEGER;<br/><br/>            for (let m = 0; m &lt; k; m++) {<br/>                if (m !== j) {<br/>                    dp2[j] = Math.min(dp2[j], dp1[m] + costs[row][j])<br/>                }<br/>            }<br/>        }<br/><br/>        // copy all the current row to last row<br/>        for (let j = 0; j &lt; k; j++) {<br/>            dp1[j] = dp2[j]<br/>        }<br/>    }<br/><br/>    let minCost = Number.MAX_SAFE_INTEGER;<br/>    for (let i = 0; i &lt; k; i++) {<br/>        minCost = Math.min(minCost, dp1[i])<br/>    }<br/>    return minCost<br/>}</span></pre><p id="ea95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，这里是时间复杂度为O(NK)，空间复杂度为O(1)的最佳解。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="c4af" class="nb lp iq no b gy ns nt l nu nv">const minCostHouseColorBest = function (costs) {<br/>    if (costs.length === 0) return 0<br/><br/>    const n = costs.length<br/>    const k = costs[0].length<br/><br/>    let min1 = 0<br/>    let min2 = 0<br/>    let idx1 = -1<br/><br/>    for (let i = 0; i &lt; n; i++) {<br/>        let m1 = Number.MAX_SAFE_INTEGER<br/>        let m2 = Number.MAX_SAFE_INTEGER<br/>        let idx2 = -1<br/><br/>        for (let j = 0; j &lt; k; j++) {<br/>            let cost = costs[i][j]<br/>            cost += j === idx1 ? min2 : min1<br/><br/>            if (cost &lt; m1) {<br/>                m2 = m1<br/>                m1 = cost<br/>                idx2 = j<br/>            } else if (cost &lt; m2) {<br/>                m2 = cost<br/>            }<br/>        }<br/><br/>        min1 = m1<br/>        min2 = m2<br/>        idx1 = idx2<br/>    }<br/><br/>    return min1;<br/>}</span></pre><p id="49f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很简单，对吧？</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="7f9f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我会更新脸书周刊在这篇文章中提出的新问题🔖它重新阅读并获得最新的问题和解决方案。</p><p id="6121" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读😘，再见👋，别忘了👏最多50次并跟随！</p></div></div>    
</body>
</html>