<html>
<head>
<title>Never miss a switch case with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript，不要错过任何一个开关</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/never-miss-a-switch-case-with-typescript-684bf5d0e1d1?source=collection_archive---------0-----------------------#2020-05-29">https://javascript.plainenglish.io/never-miss-a-switch-case-with-typescript-684bf5d0e1d1?source=collection_archive---------0-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="896b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Switch语句有时被认为是一种代码味道，但是当它们确实有意义使用时，你最好确保你没有忘记一个<em class="kl">案例</em>。幸运的是，TypeScript可以提供帮助。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f2dd906fdc38078545f3d28c5dc09933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1kwGnlqtqR5oQKsh9LhWg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Image courtesy of <a class="ae lc" href="https://unsplash.com/@kellysikkema" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a></figcaption></figure><p id="c378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我不会讨论为什么您应该在应用程序中避免switch语句(例如，它们可能很容易违反DRY和Open/Closed原则，如果您忘记了break，可能会引入微妙的错误，等等)。众所周知，switch语句经常导致代码不稳定。</p><p id="2684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也不会解释编写switch语句的替代方法(例如，策略模式、命令模式、高阶函数等)。</p><p id="3182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我会假设您知道自己在做什么，并且switch语句对于您的用例来说是一个很好的解决方案。</p><p id="dcc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将向您展示如何利用TypeScript的<code class="fe ld le lf lg b">never</code>类型来确保您确实涵盖了所有可能的情况，例如在针对枚举使用开关时。</p><h1 id="cf1d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">出发点</h1><p id="8a25" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">让我们假设我们有下面的枚举作为起点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="8a21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的枚举描述了“某物”的状态。目前只有几种可能的状态。</p><p id="0cf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们有以下枚举:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="49af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分描述了应用程序中不同的用户角色。</p><p id="702f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，假设我们需要创建一个基本的权限系统，根据一组标准确定谁可以做什么，一个是元素的状态，另一个是用户的当前角色。</p><p id="8efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着应用程序的发展，枚举可能也会发展，需要我们随着时间的推移来调整规则。</p><h1 id="996d" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">不安全的解决方案</h1><p id="2662" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果你的目标是定义一个函数来决定用户是否可以编辑一个元素，你可以这样开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="e4ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来<em class="kl">有点</em>干净，因为它确实涵盖了此时所有可能的情况<strong class="jp ir">。</strong></p><p id="9e72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能找出上面代码中最大的问题吗？事实上有很多，但是我想集中讨论一个:如果一个新的ElementState被添加到<code class="fe ld le lf lg b">ElementState</code>枚举中会怎么样？</p><p id="a3e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是，上面的代码将继续编译良好，因为有一个默认的情况下，将击中，如果你没有在任何以前的情况。这可能会引入错误，因为默认情况下总是返回<code class="fe ld le lf lg b">false</code>，这可能不是您想要的新状态。注意，对于另一个枚举来说也是如此，但是现在让我们忽略它。</p><p id="3388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们能做些什么来避免这种情况呢？马上，您可能想用throw语句替换默认情况下的<code class="fe ld le lf lg b">retVal = false</code>，但是这在编译时没有任何帮助。</p><p id="abc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器真的能帮助我们吗？</p><h1 id="d7b2" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">打字稿从不打字来拯救</h1><p id="f637" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">好消息是，TypeScript可以帮助我们使编码人员更加安全。<a class="ae lc" href="http://typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank"> TypeScript的基本类型</a>之一叫做<a class="ae lc" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#never" rel="noopener ugc nofollow" target="_blank"> never </a>。<code class="fe ld le lf lg b">never</code>类型可以用来表示<em class="kl">永远不会</em>出现的值。</p><p id="f18e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想知道这有什么帮助？</p><p id="da11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢<code class="fe ld le lf lg b">never</code>类型，我们可以向编译器解释，我们永远不应该在switch语句的默认情况下结束。让我告诉你怎么做。</p><p id="2570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们创建一个永远不应该用实际值调用的函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3edb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，上面的函数接受了一个类型为<code class="fe ld le lf lg b">never</code>的参数。实际上，这个函数永远不能用非<code class="fe ld le lf lg b">never</code>类型的参数(即实际值)调用。</p><p id="2701" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们重温一下我们的函数，以利用我们超级有用的函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在调用switch的默认子句中的<code class="fe ld le lf lg b">assertUnreachable</code>函数。目前，<code class="fe ld le lf lg b">ElementState</code>枚举的每个可能值都有一种情况。这段代码编译得很好，因为默认情况可能永远不会出现(因为我们通过这些情况使用了所有可能的值)。</p><p id="046e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们修改<code class="fe ld le lf lg b">ElementState</code>枚举并向其添加一个新元素，上面的代码将不再编译，直到我们为新的可能值添加一个case。</p><p id="a102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个更安全的switch语句版本。</p><h1 id="1a13" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="731e" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在本文中，我分享了一个<code class="fe ld le lf lg b">never</code>类型的TypeScript支持的小技巧。多亏了我们的<code class="fe ld le lf lg b">assertUnreachable(never)</code>函数，我们能够编写一个详尽的switch语句，我们确信编译器会在我们忘记修改代码的时候告诉我们，以防后备枚举发生变化。</p><p id="5c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式通过确保涵盖所有可能的情况，极大地提高了编译时的安全性。</p><p id="ee2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，小心使用switch语句的一般建议仍然存在；不要在你的代码中滥用它们。但是如果你确实需要使用它，请安全地使用它！:)</p><p id="c0bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p><p id="ced2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你想学习大量关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的其他很酷的东西，那么不要犹豫<a class="ae lc" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">去拿一本我的书</a>并订阅<a class="ae lc" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h2 id="f153" class="mt li iq bd lj mu mv dn ln mw mx dp lr jy my mz lv kc na nb lz kg nc nd md ne bi translated"><strong class="ak">用简单英语写的便条</strong></h2><p id="1df3" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae lc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae lc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅我们的YouTube频道</strong> </a> <strong class="jp ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>