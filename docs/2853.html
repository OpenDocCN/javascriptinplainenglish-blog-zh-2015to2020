<html>
<head>
<title>A Beginner’s Guide to DOM Manipulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DOM操作初学者指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dom-manipulation-985995eb858a?source=collection_archive---------8-----------------------#2020-07-29">https://javascript.plainenglish.io/dom-manipulation-985995eb858a?source=collection_archive---------8-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d8d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DOM操纵可以使web应用程序可定制，并且网页的数据可以在不刷新页面的情况下更新。通过DOM操作，我们可以添加、更改和删除任何HTML元素或属性以及与之相关的CSS样式。任何事件也可以附加到元素。</p><p id="f169" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们了解什么是DOM以及它是如何创建的。</p><h1 id="d0ca" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是DOM？</h1><p id="277b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">DOM(文档对象模型)是HTML或XML文档在逻辑树结构中的面向对象的表示，其中每个节点包含一个表示文档一部分的对象。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/936469cf027ea08347eabf7a40c4f296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*0poukmfxSJxjiY3-b6CKIA.png"/></div></figure><p id="8b35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">节点还可以附加事件，当事件被触发时，附加到节点的事件处理程序将被执行。<strong class="jp ir"> DOM </strong>还充当JavaScript和HTML或XML文档之间的接口，允许创建可定制的网页。</p><h1 id="4e3d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">DOM是怎么创造出来的？</strong></h1><p id="02fd" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">浏览器以<strong class="jp ir">原始字节</strong>格式读取网页的HTML，并将其翻译成单独的<strong class="jp ir">字符</strong>。该字符串然后被转换成W3C指定的不同的<strong class="jp ir">标记</strong>。尖括号&lt; &gt;之间字符串的记号有特殊的含义，有自己的一套规则。在令牌产生后，它们被转换成具有其属性和规则的<strong class="jp ir">对象</strong>。这些对象按照HTML标记中的标签(即<strong class="jp ir"> DOM </strong>)构建在一个具有父子关系的树形结构中。</p><p id="2bad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流程如下:</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/5cc93aa91d7e0fb8f7184c37e0d21ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wL_N872VQQAbPglNPnffA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">DOM Creation</figcaption></figure><h1 id="7902" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">DOM操作方法</h1><p id="ea5a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">DOM方法允许访问树，通过它我们可以改变DOM结构并根据需要操作DOM。以下是最常见的方法和操作DOM的方式。</p><ul class=""><li id="b05b" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">document . createelement(tagName)</em>-</strong>在您的JavaScript代码中动态创建HTML元素的新节点。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="e80c" class="mu km iq mq b gy mv mw l mx my"> var paraEle = document.createElement(‘p’);</span></pre><ul class=""><li id="0a4f" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">【document . Create text node(文本)- </em> </strong> <em class="mo">创建一个文本节点。</em></li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="208e" class="mu km iq mq b gy mv mw l mx my">var node = document.createTextNode(“This is a para”);</span></pre><ul class=""><li id="8d2f" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">Document . createdocumentfragment()-</em></strong>文档片段基本上就是虚拟不可见的HTML元素<strong class="jp ir"> <em class="mo">。</em> </strong>。createDocumentFragment()<strong class="jp ir"><em class="mo"/></strong>用于创建文档片段，将元素追加到文档片段，然后将文档片段追加到DOM树。在DOM树中，文档片段被它的所有子元素替换。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="1f50" class="mu km iq mq b gy mv mw l mx my">var fragment = document.createDocumentFragment(); </span></pre><ul class=""><li id="07d3" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">如果我们正在编写一个进行大量DOM操作的页面，使用这种方法可以极大地提高页面的性能。将子元素附加到片段可以防止UI回流，从而提高性能，并且因为这个原因，createElement()不同于<em class="mo">createDocumentFragment()</em>。</li><li id="257e" class="mf mg iq jp b jq mz ju na jy nb kc nc kg nd kk mk ml mm mn bi translated"><strong class="jp ir">parent element . append child(new element)</strong>:该方法插入子节点(在参数中传递)作为父元素的最后一个子节点。即它将子节点元素附加到父节点元素</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="3c57" class="mu km iq mq b gy mv mw l mx my">paraEle.appendChild(node);<br/>fragment.appendChild(paraEle);</span><span id="be1e" class="mu km iq mq b gy ne mw l mx my">document.body.appendChild(fragment);</span></pre><ul class=""><li id="8c8b" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">parent element . insert before(new element，element) </em> </strong>:允许在现有父节点元素中插入新的子节点元素(作为第一个参数传递)，放在父元素中它的一个子节点(作为第二个参数传递)之前。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="21df" class="mu km iq mq b gy mv mw l mx my">const list = document.createElement('ul');<br/>document.body.insertBefore(list, paraEle);</span></pre><ul class=""><li id="2eab" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"> <em class="mo"> Node.setAttribute(name，value)</em></strong>:<strong class="jp ir"><em class="mo"/></strong>动态设置HTML中元素的属性。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="40ca" class="mu km iq mq b gy mv mw l mx my">paraEle.setAttribute('class','paragraph');</span></pre><p id="9f2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以为类段落设置CSS，样式将应用于元素。</p><ul class=""><li id="a1c2" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">【node . text content()</em></strong>:<strong class="jp ir"><em class="mo"/></strong>允许设置和获取节点的文本内容(俗称元素)。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="7841" class="mu km iq mq b gy mv mw l mx my">const para = document.getElementByClassName('paragraph');<br/>console.log(para.textContent); // console the para text<br/>para.textContent = "This is the changed paragraph" ; /*set the paragraph text*/</span></pre><ul class=""><li id="aa57" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">node . innerhtml()</em></strong>:设置内部HTML内容。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="2a17" class="mu km iq mq b gy mv mw l mx my">para.innerHTML = '&lt;em&gt;This is the changed paragraph&lt;/em&gt;'; // text will be italics</span></pre><p id="a652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">innerHTML()和textContent()的区别在于，innerHTML()可以设置HTML标记和元素中的文本，而在text Content()中只能设置文本。</p><ul class=""><li id="6972" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">node . class list</em></strong>:允许你修改附加到元素上的类。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="238d" class="mu km iq mq b gy mv mw l mx my">console.log(paraEle.classList); <br/>//console all the classes attached</span><span id="fb86" class="mu km iq mq b gy ne mw l mx my">paraEle.classList.add('myClass') <br/>//styles of myClass class will be applied</span><span id="a495" class="mu km iq mq b gy ne mw l mx my">paraEle.classList.remove('myClass'); <br/>// remove the class</span><span id="17f7" class="mu km iq mq b gy ne mw l mx my">paraEle.classList.replace('myClass1','myClass2'); <br/>//replaces one class with other;</span><span id="d214" class="mu km iq mq b gy ne mw l mx my">paraEle.classList.toggle('myClass') <br/>//if class present removes it, else if not present attaches the class to the element;</span><span id="4370" class="mu km iq mq b gy ne mw l mx my">paraEle.classList.contains('myClass')<br/>//returns true or false whether the class is in the classList or not</span></pre><ul class=""><li id="1764" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"> <em class="mo"> Node.dataset </em> </strong>:允许您设置和获取HTML元素上的自定义数据属性的值。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="5abf" class="mu km iq mq b gy mv mw l mx my">//HTML file<br/>&lt;div id="myDiv" data-name="Item" data-item-price="10"&gt;&lt;/div&gt;</span><span id="e76f" class="mu km iq mq b gy ne mw l mx my">//JavaScript<br/>const myDiv = document.getElementById('myDiv');</span><span id="adef" class="mu km iq mq b gy ne mw l mx my">console.log(myDiv.dataset)<br/>//{name:"Iteml", item-price:"10"}</span><span id="9c00" class="mu km iq mq b gy ne mw l mx my">myDiv.dataset.name = "new Item1" <br/>//changes the name property of </span><span id="c5e4" class="mu km iq mq b gy ne mw l mx my">myDiv.removeAttribute('data-name')<br/>//removes the name attribute of data</span></pre><ul class=""><li id="e092" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">node . clone node</em></strong>:允许在节点上进行复制或克隆。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="e4c9" class="mu km iq mq b gy mv mw l mx my">var paraCopy = paraEle.cloneNode();<br/>//It doesn't include the childNode by default it only copies the current node which is &lt;p&gt;&lt;/p&gt;</span><span id="baaf" class="mu km iq mq b gy ne mw l mx my">var paraCopy = paraEle.cloneNode(true);<br/>//deep copy happends i.e. childNode will also be copied</span><span id="dc82" class="mu km iq mq b gy ne mw l mx my">document.body.appendChild(paraCopy);</span></pre><ul class=""><li id="b7a6" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">node . nextelementsibling</em></strong>:给出正在调用的元素的下一个元素。</li><li id="3894" class="mf mg iq jp b jq mz ju na jy nb kc nc kg nd kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">Node . next sibling</em></strong>:<strong class="jp ir"><em class="mo"/></strong>给出下一个节点。它还考虑任何类型的节点，包括文本节点，但nextElementSibling不考虑。</li><li id="765b" class="mf mg iq jp b jq mz ju na jy nb kc nc kg nd kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">element . getboundingclientrect()</em></strong>:该方法将返回一个包含元素属性的对象，如宽度、高度、上、下、左、右、下值以及x、y坐标。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="7a34" class="mu km iq mq b gy mv mw l mx my">console.log(paraEle.getBoundingClientRect());</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a6d8132e09695aea6a9d5ade70e58494.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*M2Ag0X4B8EH9wYJ77oXKyw.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk"><strong class="bd ng"><em class="nh">.getBoundingClientRect() object contains these values</em></strong></figcaption></figure><ul class=""><li id="0be9" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">element . outer HTML</em></strong>:给出元素标签的外层HTML，包括id、类等。</li><li id="a52c" class="mf mg iq jp b jq mz ju na jy nb kc nc kg nd kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">document . getelementbyid(</em></strong><em class="mo">idname</em><strong class="jp ir"><em class="mo">)</em></strong>:让您找到具有所提供Id的元素</li><li id="ca4e" class="mf mg iq jp b jq mz ju na jy nb kc nc kg nd kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">document . getelementbyclass name(</em></strong><em class="mo">class name</em><strong class="jp ir"><em class="mo">)</em></strong>:让您找到具有所提供类名的元素</li><li id="0438" class="mf mg iq jp b jq mz ju na jy nb kc nc kg nd kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">Element . query selector(</em></strong><em class="mo">选择器</em> <strong class="jp ir"> <em class="mo"> ) </em> </strong>:用于查找与CSS选择器匹配的第一个元素。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="6e6b" class="mu km iq mq b gy mv mw l mx my">document.querySelector('#myDiv');<br/>//gives element with the above selector i.e. id of myDiv</span><span id="3254" class="mu km iq mq b gy ne mw l mx my">document.querySelector('.myClass');<br/>//gives element with the above selector i.e. class of myClass</span></pre><ul class=""><li id="2d99" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">element . query selector all(</em></strong><em class="mo">选择器</em> <strong class="jp ir"> <em class="mo"> )- </em> </strong>用于查找与CSS选择器匹配的元素列表。</li></ul><pre class="lp lq lr ls gt mp mq mr ms aw mt bi"><span id="1674" class="mu km iq mq b gy mv mw l mx my">document.querySelectorAll('.myClass');<br/>//gives the array of element with the above selector</span></pre><ul class=""><li id="76a9" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir"><em class="mo">window . parent</em></strong>:document等于window.parent.document引用我们的HTML文档</li></ul><p id="edd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在浏览器呈现页面之前，先构造DOM。因此，我们需要确保尽可能快速地将HTML交付给浏览器。过多的DOM操作会导致页面一次又一次的渲染，从而导致UI的回流，这是一种昂贵的代价。</p><p id="72de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们必须确保没有过度的DOM操作。此外，React等一些库使用虚拟DOM，因此性能不会受到影响，网页也是动态的。</p></div></div>    
</body>
</html>