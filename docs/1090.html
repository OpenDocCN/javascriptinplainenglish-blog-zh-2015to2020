<html>
<head>
<title>JavaScript Events Handlers — Mouse Over and Mouse Up Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序—鼠标悬停和鼠标抬起事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-events-handlers-mouse-over-and-mouse-up-events-6bda72b07101?source=collection_archive---------3-----------------------#2020-01-28">https://javascript.plainenglish.io/javascript-events-handlers-mouse-over-and-mouse-up-events-6bda72b07101?source=collection_archive---------3-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f4af79ad554a0036e7a55c9b272dd28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gRc6TytRMsDlVeJ2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sweetmangostudios?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ricky Kharawala</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ebce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配一个事件处理器来处理这些事件。发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将看看如何使用DOM元素的<code class="fe lb lc ld le b">onmouseover</code>和<code class="fe lb lc ld le b">onmouseup</code>属性。</p><h1 id="4424" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">onmouseover</h1><p id="c6be" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">DOM元素的<code class="fe lb lc ld le b">onmouseover</code>属性允许我们给它分配一个事件处理函数来处理<code class="fe lb lc ld le b">mouseover</code>事件。当使用鼠标或触控板等定点设备将光标移动到元素或其子元素之一上时，它会在元素上触发。</p><p id="3c8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着无论鼠标移动到另一个元素，无论它在层次结构中的位置如何，都会触发<code class="fe lb lc ld le b">mouseenter</code>事件。因此，<code class="fe lb lc ld le b">mouseenter</code>事件可能会被触发多次，这会导致严重的性能问题。如果当鼠标在一个有很多后代的大元素上时，我们需要监听整个元素树中的事件，那么最好使用<code class="fe lb lc ld le b">mouseover</code>事件。</p><p id="ccce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当与鼠标离开一个元素时触发的<code class="fe lb lc ld le b">mouseout</code>事件结合时，<code class="fe lb lc ld le b">mouseover</code>事件的行为方式非常类似于CSS <code class="fe lb lc ld le b">:hover</code>伪类。</p><p id="7dc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用它在图像上创建一个偷窥效果，当鼠标指针悬停在图像的一部分上时，我们显示图像的一部分。</p><p id="44b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们添加图像的HTML代码和隐藏图像的黑盒。此外，我们添加了一个circle div元素来显示我们所悬停的图像的一部分。为此，我们放入以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3271" class="mq lg iq le b gy mr ms l mt mu">&lt;div class='container'&gt;<br/>  &lt;div class="view" hidden&gt;&lt;/div&gt;<br/>  &lt;img src='<a class="ae kc" href="https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'</a>&gt;</span><span id="9130" class="mq lg iq le b gy mv ms l mt mu">&lt;/div&gt;</span></pre><p id="ce96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加<code class="fe lb lc ld le b">.container</code> div是为了显示遮盖图像的黑盒。<code class="fe lb lc ld le b">.view</code> div是一个圆圈，当我们将鼠标悬停在它上面时，它会显示图像的一部分，而<code class="fe lb lc ld le b">img</code>元素则显示图像本身。</p><p id="2982" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将CSS代码添加到样式<code class="fe lb lc ld le b">div</code>元素中，就像我们刚刚描述的那样，添加以下CSS代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1444" class="mq lg iq le b gy mr ms l mt mu">.container {<br/>  background: black;<br/>  width: 500px;<br/>}</span><span id="9f2e" class="mq lg iq le b gy mv ms l mt mu">.view {<br/>  position: absolute;<br/>  width: 200px;<br/>  height: 200px;<br/>  background: white;<br/>  border-radius: 50%;<br/>}</span><span id="3b2e" class="mq lg iq le b gy mv ms l mt mu">img {<br/>  mix-blend-mode: darken;<br/>  width: 500px;<br/>}</span></pre><p id="5b26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们添加JavaScript代码来完成我们刚刚描述的工作:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9acd" class="mq lg iq le b gy mr ms l mt mu">const img = document.querySelector('img');<br/>const view = document.querySelector('.view');<br/>const container = document.querySelector('.container');</span><span id="9df4" class="mq lg iq le b gy mv ms l mt mu">const showView = (event) =&gt; {<br/>  view.removeAttribute('hidden');<br/>  view.style.left = event.clientX - 50 + 'px';<br/>  view.style.top = event.clientY - 50 + 'px';<br/>  event.preventDefault();<br/>}</span><span id="dcbd" class="mq lg iq le b gy mv ms l mt mu">const moveView = (event) =&gt; {<br/>  view.style.left = event.clientX - 50 + 'px';<br/>  view.style.top = event.clientY - 50 + 'px';<br/>}</span><span id="0eb3" class="mq lg iq le b gy mv ms l mt mu">container.onmousemove = moveView;<br/>container.onmouseover = showView;</span></pre><p id="8ad0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过使用<code class="fe lb lc ld le b">querySelector</code>方法获得了<code class="fe lb lc ld le b">.container</code>元素。我们对<code class="fe lb lc ld le b">img</code>和<code class="fe lb lc ld le b">.view</code>元素做同样的事情。一旦我们这样做了，我们编写事件处理函数。</p><p id="a419" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">.container</code> <code class="fe lb lc ld le b">div</code>元素的<code class="fe lb lc ld le b">onmouseover</code>属性被设置为<code class="fe lb lc ld le b">showView</code>函数，该函数在鼠标按钮按下时运行。在函数内部，我们从<code class="fe lb lc ld le b">.view</code> <code class="fe lb lc ld le b">div</code>元素中移除了<code class="fe lb lc ld le b">hidden</code>属性，以显示<code class="fe lb lc ld le b">div</code>下面的图像。从拥有<code class="fe lb lc ld le b">Event</code>对象的<code class="fe lb lc ld le b">event</code>参数中，我们获得了<code class="fe lb lc ld le b">clientX</code>和<code class="fe lb lc ld le b">clientY</code>属性，它们拥有点击位置的鼠标坐标。我们将其设置为代表<code class="fe lb lc ld le b">.view</code>元素的<code class="fe lb lc ld le b">view</code> DOM对象的位置。然后我们调用<code class="fe lb lc ld le b">event.preventDefault()</code>来停止默认动作，因为我们已经用它之前的代码进行了揭示。</p><p id="dfdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">.container</code> <code class="fe lb lc ld le b">div</code>元素的<code class="fe lb lc ld le b">onmousemove</code>事件处理程序被设置为<code class="fe lb lc ld le b">moveView</code>函数，该函数处理<code class="fe lb lc ld le b">mousemove</code>事件。当鼠标移动时触发该事件。在函数中，我们将<code class="fe lb lc ld le b">.view</code>元素设置为鼠标指针当前所在的位置，同样使用<code class="fe lb lc ld le b">event</code>参数的<code class="fe lb lc ld le b">clientX</code>和<code class="fe lb lc ld le b">clientY</code>属性，该参数是<code class="fe lb lc ld le b">MouseEvent</code>对象。</p><p id="a8c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们做了所有这些，当我们将鼠标悬停在黑盒上时，我们就会显示下面的那部分图像。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/67e87977706bfbd683b88a12916a7f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e2RvKcpZBI_nPKnO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zmachacek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zdeněk Macháček</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="449b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">onmouseup</h1><p id="fb68" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">DOM元素的<code class="fe lb lc ld le b">onmouseup</code>属性允许我们为它分配一个事件处理函数来处理<code class="fe lb lc ld le b">mouseup</code>事件。当用户释放鼠标按钮时它被触发。<code class="fe lb lc ld le b">mouseup</code>事件与<code class="fe lb lc ld le b">mousedown</code>事件相对应。</p><p id="6841" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将它与<code class="fe lb lc ld le b">mousedown</code>和<code class="fe lb lc ld le b">mousemove</code>事件处理程序一起使用来制作一个简单的白板。首先，我们在HTML代码中创建一个<code class="fe lb lc ld le b">canvas</code>元素:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6631" class="mq lg iq le b gy mr ms l mt mu">&lt;canvas width="300" height="300"&gt;&lt;/canvas&gt;</span></pre><p id="d9b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们创建CSS代码，为<code class="fe lb lc ld le b">canvas</code>元素添加边框:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c10a" class="mq lg iq le b gy mr ms l mt mu">canvas {<br/>  border: 1px solid black;<br/>}</span></pre><p id="ef3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们添加JavaScript代码在<code class="fe lb lc ld le b">canvas</code>元素上进行绘制:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="84ab" class="mq lg iq le b gy mr ms l mt mu">let isDrawing = false;<br/>let x = 0;<br/>let y = 0;</span><span id="dd92" class="mq lg iq le b gy mv ms l mt mu">const canvas = document.querySelector('canvas');<br/>const context = canvas.getContext('2d');<br/>const rect = canvas.getBoundingClientRect();<br/>const drawLine = (context, x1, y1, x2, y2) =&gt; {<br/>  context.beginPath();<br/>  context.strokeStyle = 'red';<br/>  context.lineWidth = 1;<br/>  context.moveTo(x1, y1);<br/>  context.lineTo(x2, y2);<br/>  context.stroke();<br/>  context.closePath();<br/>}</span><span id="4f29" class="mq lg iq le b gy mv ms l mt mu">canvas.onmousedown = e =&gt; {<br/>  x = e.clientX - rect.left;<br/>  y = e.clientY - rect.top;<br/>  isDrawing = true;<br/>};</span><span id="20dc" class="mq lg iq le b gy mv ms l mt mu">canvas.onmousemove = e =&gt; {<br/>  if (isDrawing === true) {<br/>    drawLine(context, x, y, e.clientX - rect.left, e.clientY - rect.top);<br/>    x = e.clientX - rect.left;<br/>    y = e.clientY - rect.top;<br/>  }<br/>};</span><span id="5515" class="mq lg iq le b gy mv ms l mt mu">document.onmouseup = e =&gt; {<br/>  if (isDrawing === true) {<br/>    drawLine(context, x, y, e.clientX - rect.left, e.clientY - rect.top);<br/>    x = 0;<br/>    y = 0;<br/>    isDrawing = false;<br/>  }<br/>};</span></pre><p id="5a0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码通过获取<code class="fe lb lc ld le b">canvas</code>元素并从中获取允许我们在画布上绘制的上下文对象来工作。</p><p id="52a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了<code class="fe lb lc ld le b">drawLine</code>函数，它接受<code class="fe lb lc ld le b">canvas</code>上下文、直线起始坐标的x和y坐标(分别为<code class="fe lb lc ld le b">x1</code>和<code class="fe lb lc ld le b">y1</code>)以及直线终点的x和y坐标(分别为<code class="fe lb lc ld le b">x2</code>和<code class="fe lb lc ld le b">y2</code>)。</p><p id="5229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在函数中，我们在<code class="fe lb lc ld le b">canvas</code>上下文对象上调用<code class="fe lb lc ld le b">beginPath</code>。然后，我们将<code class="fe lb lc ld le b">strokeStyle</code>设置为<code class="fe lb lc ld le b">red</code>，这将使线条变为红色。然后我们将<code class="fe lb lc ld le b">lineWidth</code>设置为1个像素。接下来我们用<code class="fe lb lc ld le b">x1</code>和<code class="fe lb lc ld le b">y1</code>调用<code class="fe lb lc ld le b">moveTo</code>来开始在这些坐标中绘图，然后我们用参数<code class="fe lb lc ld le b">x2</code>和<code class="fe lb lc ld le b">y2</code>调用<code class="fe lb lc ld le b">lineTo</code>方法来定义从(<code class="fe lb lc ld le b">x1</code>、<code class="fe lb lc ld le b">y1</code>)到(<code class="fe lb lc ld le b">x2</code>、<code class="fe lb lc ld le b">y2</code>)的线段。然后我们调用context对象上的<code class="fe lb lc ld le b">stroke</code>方法来实际绘制。最后我们调用<code class="fe lb lc ld le b">closePath</code>方法把线画回起点(<code class="fe lb lc ld le b">x1</code>，<code class="fe lb lc ld le b">y1</code>)。</p><p id="f349" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们附加我们的事件处理程序。我们分配<code class="fe lb lc ld le b">onmousedown</code>事件处理函数来设置<code class="fe lb lc ld le b">x</code>和<code class="fe lb lc ld le b">y</code>坐标，并将<code class="fe lb lc ld le b">isDrawing</code>设置为<code class="fe lb lc ld le b">true</code>以表示我们将开始绘制。</p><p id="856d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们设置<code class="fe lb lc ld le b">canvas</code>元素的<code class="fe lb lc ld le b">onmousemove</code>属性，给它分配一个事件处理函数，当<code class="fe lb lc ld le b">isDrawing</code>为<code class="fe lb lc ld le b">true</code>时运行代码。如果是<code class="fe lb lc ld le b">true</code>，那么我们调用上面定义的<code class="fe lb lc ld le b">drawLine</code>方法，用(<code class="fe lb lc ld le b">x</code>、<code class="fe lb lc ld le b">y</code>)作为线段的起点，(<code class="fe lb lc ld le b">e.clientX — rect.left</code>、<code class="fe lb lc ld le b">e.clientY — rect.top</code>)作为直线线段的终点。<code class="fe lb lc ld le b">e.clientX</code>是鼠标指针所在位置的x坐标，<code class="fe lb lc ld le b">clientY</code>是鼠标指针所在位置的y坐标。<code class="fe lb lc ld le b">rect</code>从上下文的<code class="fe lb lc ld le b">getBoundingClientRect</code>方法返回，该方法返回元素的大小及其相对于视口的位置。我们减去<code class="fe lb lc ld le b">rect</code>尺寸，这样我们绘制的线段的端点和起点将与绘制直线后鼠标指针的位置相同。</p><p id="c5b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们为<code class="fe lb lc ld le b">onmouseup</code>事件设置一个事件处理函数，以便在<code class="fe lb lc ld le b">isDrawing</code>为<code class="fe lb lc ld le b">true</code>时绘制剩余的线，然后将<code class="fe lb lc ld le b">isDrawing</code>设置为<code class="fe lb lc ld le b">false</code>以停止绘制，因为我们松开了鼠标按钮。</p><p id="a36d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DOM元素的<code class="fe lb lc ld le b">onmouseover</code>属性允许我们给它分配一个事件处理函数来处理<code class="fe lb lc ld le b">mouseover</code>事件。当使用鼠标或触控板等定点设备将光标移动到元素或其子元素之一上时，它会在元素上触发。</p><p id="0291" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DOM元素的<code class="fe lb lc ld le b">onmouseup</code>属性允许我们为它分配一个事件处理函数来处理<code class="fe lb lc ld le b">mouseup</code>事件。当用户释放鼠标按钮时它被触发。<code class="fe lb lc ld le b">mouseup</code>事件与<code class="fe lb lc ld le b">mousedown</code>事件相对应。</p><p id="4aa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它与其他鼠标事件处理程序一起使用来创建有用的东西，如白板或当鼠标悬停在某物上时改变内容。</p></div></div>    
</body>
</html>