<html>
<head>
<title>Start Your Journey with Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Next.js开始您的旅程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/start-your-journey-with-next-js-958705cfc299?source=collection_archive---------9-----------------------#2020-11-04">https://javascript.plainenglish.io/start-your-journey-with-next-js-958705cfc299?source=collection_archive---------9-----------------------#2020-11-04</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="453a" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">React开发人员的一个很好的框架</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/9fa933b2d0eeca838ef73d4bf1cef6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8h_5UEnN1erjyU-1DDKJFg.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">image credit : google</figcaption></figure><h1 id="59ae" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">Next.js是什么？</h1><p id="3ac6" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">Next.js是React的一个框架。它使得React的开发更加干净和高效。在他们的<a class="ae mk" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">文档</a>中，他们将Next.js定义为:“t<em class="ml">he React Framework for Production”</em></p><p id="7dda" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">它的特征确实证明了这种说法。我们稍后会谈到它们。</p><h1 id="d467" class="kw kx ir bd ky kz la lb lc ld le lf lg jx lh jy li ka lj kb lk kd ll ke lm ln bi translated">为什么是Next.js？</h1><p id="243e" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">Next.js为您提供了最佳的开发体验，拥有生产所需的所有特性。混合静态和服务器渲染、类型脚本支持、智能捆绑、路由预取等等。不需要配置。</p><p id="7087" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">一坏(还是好？React的特点是它非常不固执己见。它并不强迫开发者为特定的任务使用特定的库。</p><p id="ced4" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">但是这是有代价的。大多数时候，你不得不求助于外部库或社区支持，甚至是路由、优化等最常见的功能。</p><p id="0b1b" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">但Next.js却不是这样，它内置了很多功能。你可以立即开始使用它。此外，它还支持<strong class="lq is"> SSR </strong>(服务器端渲染)，这是<strong class="lq is"> SEO </strong>优化所必需的。因此，如果你正在建立一个类似电子商务的东西，你关心的是搜索引擎优化，那么Next.js可能是一个不错的选择。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="bf7e" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">好的，我听到了。给我看看代码！</h1><p id="0d47" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">你可以像<strong class="lq is"> React </strong>一样构建一个Next.js应用程序。打开您的终端并键入以下命令</p><pre class="kh ki kj kk gu nd ne nf ng aw nh bi"><span id="69af" class="ni kx ir ne b gz nj nk l nl nm">npx create-next-app name-of-your-app</span></pre><p id="0f60" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">要运行开发服务器</p><pre class="kh ki kj kk gu nd ne nf ng aw nh bi"><span id="3cf9" class="ni kx ir ne b gz nj nk l nl nm">cd name-of-your-app<br/>yarn dev</span></pre><p id="200c" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">转到<a class="ae mk" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，你会看到你那令人敬畏的应用程序的登陆页面。就这么简单。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nn"><img src="../Images/b72110cba1cf154e1972d6937653a04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9r2L1CTtLeC8wsAU95PiLA.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Landing page of Next.js application</figcaption></figure></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="c91d" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">下一步是什么？</h1><p id="2303" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">Next.js有很棒的文档(是我见过的最好的文档之一)。你可以(也应该)从那里学到所有基本的东西。但是如果你想留下来，我会在这里解释一些基本概念。我们开始吧</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="b125" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">声明路由</h1><p id="f31a" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">Next.js遵循声明式路由。在您的项目目录中有一个名为<code class="fe no np nq ne b">pages</code>的文件夹(您不应该弄乱它)。在该组件中，您可以创建一个名为<code class="fe no np nq ne b">home.js</code>的新组件</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nr ns l"/></div></figure><p id="1156" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">现在，如果你打开浏览器，浏览http://localhost:3000/home ，你可以看到主页。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nt"><img src="../Images/2921b1184aaf2297b3c3b14e600090a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0j5rS8MUBTnH_yxNdRIRQw.png"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Home page</figcaption></figure><p id="d1d4" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">那超级简单。无需安装react-router或任何其他库。不需要将页面导入到任何其他页面。只要创建文件，它就在你的浏览器上。</p><ul class=""><li id="dea9" class="nu nv ir lq b lr mm lu mn lx nw mb nx mf ny mj nz oa ob oc bi translated">如果您需要复杂的路由结构，您可以创建另一个页面，如home/details.js，您的新页面将在<a class="ae mk" href="http://localhost:3000/home" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/home</a>下提供</li><li id="a4ee" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">如果您需要动态路由，您可以添加一个新页面，如user/[id]。如果你去<a class="ae mk" href="http://localhost:3000/user/1" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/user/1</a>或者<a class="ae mk" href="http://localhost:3000/user/2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/user/2</a>你会看到你的新页面。</li></ul></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="6302" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">航行</h1><p id="8b65" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">您不需要安装react-router或任何其他导航库。Next.js为您提供了一个名为<code class="fe no np nq ne b">Link</code>的组件，您可以使用它在页面之间导航。</p><ul class=""><li id="f2ec" class="nu nv ir lq b lr mm lu mn lx nw mb nx mf ny mj nz oa ob oc bi translated">如果你想导航到一个名为<code class="fe no np nq ne b">/about</code>的路径，你可以在你的主页上这样声明。</li></ul><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nr ns l"/></div></figure><ul class=""><li id="8a4d" class="nu nv ir lq b lr mm lu mn lx nw mb nx mf ny mj nz oa ob oc bi translated">href属性将决定您要走的路线。</li></ul></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="2648" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">静态资产</h1><p id="e198" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">您可以将图像等静态资产放在顶级公共目录中。例如，将一个名为<code class="fe no np nq ne b">user.png</code>的图像放入<code class="fe no np nq ne b">public</code>文件夹中，您可以像这样提供该图像</p><pre class="kh ki kj kk gu nd ne nf ng aw nh bi"><span id="5841" class="ni kx ir ne b gz nj nk l nl nm">&lt;img src="/user.png" alt="user image" className="user-image" /&gt;</span></pre></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="b1ce" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">式样</h1><ul class=""><li id="3ace" class="nu nv ir lq b lr ls lu lv lx oi mb oj mf ok mj nz oa ob oc bi translated">在新的顶层<code class="fe no np nq ne b">component</code>文件夹下创建一个名为<code class="fe no np nq ne b">layout.jsx</code>的新组件。</li><li id="ba19" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">在某个地方创建一个名为<code class="fe no np nq ne b">layout.module.css</code>的样式文件(我在同一个文件夹中做)。</li><li id="c073" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">记住一件事，样式文件名必须有<strong class="lq is"> .module.css </strong>作为后缀。</li><li id="0bb6" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">现在将文件导入到您的<code class="fe no np nq ne b">Layout</code>组件中。并将该样式用作一个<strong class="lq is"> className </strong>属性。</li></ul><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nr ns l"/></div></figure><p id="5468" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">它的一个优点是Next.js会自动创建一个格式为<code class="fe no np nq ne b">layout_container_random</code>的类属性。随机后缀有助于避免类名冲突。多棒啊。</p><p id="edf3" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">如果你想使用<strong class="lq is"> sass </strong>来设计你的风格，那么<strong class="lq is"> </strong> Next.js也支持开箱即用。但是不要忘记首先安装依赖项。</p><pre class="kh ki kj kk gu nd ne nf ng aw nh bi"><span id="de2a" class="ni kx ir ne b gz nj nk l nl nm">npm install sass</span></pre><p id="0142" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">安装后，您可以开始直接使用<code class="fe no np nq ne b">.scss</code>或<code class="fe no np nq ne b">.sass</code>文件。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="fd7f" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">全球国家的概念</h1><p id="28c4" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">通常我们在<strong class="lq is"> React </strong>项目中有一个<code class="fe no np nq ne b">App.js</code>文件。该组件充当我们所有子组件的容器。但是在Next.js中我们没有这样的组件。</p><p id="5c81" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">注意一件事。我们没有将页面导入任何其他组件。所以没有可以被认为是全局子持有人的组件。但是有一个名为<code class="fe no np nq ne b">_app.js</code>的文件。这充当了母组件。它执行一个<code class="fe no np nq ne b">App.js</code>组件的动作。</p><p id="210e" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">它可以应用所有样式，并可以处理页面之间的全局变量。因此，如果我们想在所有页面之间应用全局样式或某种公共状态，那么<code class="fe no np nq ne b">_app.js</code>就是这样做的地方。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="5beb" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">预渲染</h1><p id="0669" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">预渲染是Next.js中一个非常重要的概念，默认情况下，Next.js会预渲染每个页面。这意味着所需的HTML文件是预先构建的，与React相反，JavaScript代码负责构建HTML</p><p id="5fa7" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">有两种类型的预渲染</p><ul class=""><li id="fbe0" class="nu nv ir lq b lr mm lu mn lx nw mb nx mf ny mj nz oa ob oc bi translated">静态站点生成(SSG)</li><li id="545f" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">服务端渲染(SSR)</li></ul><p id="6c8f" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">让我们简单地讨论一下它们，并尝试理解它们的用例。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="5e0d" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">静态站点生成</h1><p id="5fd6" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">如果你的网站有一些不太可能经常改变的静态内容(比如你的作品集),那么你不必担心任何事情。Next.js会自动为你做SSG。因为它已经知道要渲染什么了。所以它会提前生成所需的HTML，从而带来超快的体验。</p><p id="729a" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">但是在任何严肃的web应用程序中，我们都依赖于一些来自外部API源(您的后端服务器)的动态内容。那么Next.js究竟要如何预渲染一个依赖于一些外部api数据的页面呢？</p><p id="2acc" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">方法是由名为<code class="fe no np nq ne b">getStaticProps</code>的<strong class="lq is"> NestJS </strong>提供的一个函数。</p><p id="4f4e" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">这是一个可以从页面返回的异步函数。它将提前交付一些api调用的结果，并将结果作为道具传递给页面组件。</p><p id="5d41" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">因此，Next.js将提前从这个函数中解析必要的属性，并预先呈现您的页面。需要注意的一点是，<strong class="lq is"> <em class="ml">你只能从你的页面类型组件内部返回这个函数。您不能在任何其他组件中定义它。</em> </strong></p><h2 id="e816" class="ni kx ir bd ky ol om dn lc on oo dp lg lx op oq li mb or os lk mf ot ou lm ov bi translated">SSG的使用案例</h2><p id="00ca" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">当你已经提前知道api的结果时，你只能使用<code class="fe no np nq ne b">getStaticProps</code>。这里我们使用<a class="ae mk" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lq is">JsonPlaceHolder</strong></a>API来获取博客文章列表。在你的主页中，你已经知道你将要调用的api来获取你所有的文章。它不依赖于在每次请求时都会改变的某些路由参数。所以你可以在这样的场景中使用<code class="fe no np nq ne b">getStaticProps</code>它。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nr ns l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Static Site Generation (SSG)</figcaption></figure><p id="eaf1" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">但是，如果你有一个像<code class="fe no np nq ne b">blogs/[id]</code>这样的路径，用一个特定的id显示一篇博文的细节，会发生什么呢？Next.js如何提前知道要传递哪个id并渲染页面？</p><p id="b915" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">不幸的是，你不能在这个场景中使用SSG。我们必须使用服务器端渲染(SSR)。</p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h1 id="5f65" class="kw kx ir bd ky kz my lb lc ld mz lf lg jx na jy li ka nb kb lk kd nc ke lm ln bi translated">服务器端渲染</h1><p id="ffa9" class="pw-post-body-paragraph lo lp ir lq b lr ls js lt lu lv jv lw lx ly lz ma mb mc md me mf mg mh mi mj ik bi translated">我们将从前面的例子继续我们的讨论。我们需要通过id获取具体的博客细节，并显示在我们的<code class="fe no np nq ne b">blogs/[id]</code>页面上。这里我们将使用另一个名为<code class="fe no np nq ne b">getServerSideProps</code>的函数。</p><p id="46fb" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">这个函数有一个名为<strong class="lq is"> context </strong>的额外参数，可以用来获得关于所请求路线的额外信息。因此，我们可以从请求的路由中获取博客id，获取博客详细信息，并将其作为道具传递到详细信息页面。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nr ns l"/></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Server Side Rendering (SSR)</figcaption></figure><p id="773e" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">这里发生了什么？</p><ul class=""><li id="ffc8" class="nu nv ir lq b lr mm lu mn lx nw mb nx mf ny mj nz oa ob oc bi translated">首先，我们的<code class="fe no np nq ne b">getServerSideProps</code>函数获取路由请求的id。例如，如果请求的路由是<a class="ae mk" href="http://localhost:3000/blogs/2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/blogs/2</a>，那么博客id是2。</li><li id="a2f7" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">然后，它获取这个特定博客的详细信息。</li><li id="420b" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">将数据作为道具传递给我们的组件。</li><li id="e03a" class="nu nv ir lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">然后，我们的页面用服务器生成的HTML呈现。</li></ul><p id="c9f9" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">这就是开始使用Next.js需要知道的所有基本概念。你可以认真考虑用它来构建你的下一个项目。工作起来真是轻而易举。</p><p id="19ce" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">如果你已经知道React，那么Next.js可以成为你的工具箱的另一个重要的补充。</p><p id="4ea5" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated">谢谢你能走到这一步。编码快乐！</p><p id="4215" class="pw-post-body-paragraph lo lp ir lq b lr mm js lt lu mn jv lw lx mo lz ma mb mp md me mf mq mh mi mj ik bi translated"><strong class="lq is">通过</strong><a class="ae mk" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="lq is">LinkedIn</strong></a><strong class="lq is">或我的</strong> <a class="ae mk" href="https://www.mohammadfaisal.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq is">个人网站</strong> </a> <strong class="lq is">与我取得联系。</strong></p></div><div class="ab cl mr ms hv mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ik il im in io"><h2 id="4c3e" class="ni kx ir bd ky ol om dn lc on oo dp lg lx op oq li mb or os lk mf ot ou lm ov bi translated"><strong class="ak">延伸阅读</strong></h2><div class="ow ox gq gs oy oz"><a rel="noopener  ugc nofollow" target="_blank" href="/data-fetching-with-next-js-13s-bleeding-edge-features-a-primer-a60ddd3f7570"><div class="pa ab fp"><div class="pb ab pc cl cj pd"><h2 class="bd is gz z fq pe fs ft pf fv fx iq bi translated">使用Next.js 13的前沿特性获取数据——入门</h2><div class="pg l"><h3 class="bd b gz z fq pe fs ft pf fv fx dk translated">NextJS 13中的数据获取使用了应用程序目录、流、暂挂以及混合服务器和客户端组件。</h3></div><div class="ph l"><p class="bd b dl z fq pe fs ft pf fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn kq oz"/></div></div></a></div></div></div>    
</body>
</html>