# 重新思考 JavaScript 中的坚实原则

> 原文：<https://javascript.plainenglish.io/rethinking-solid-principles-in-javascript-7effdd4dc37d?source=collection_archive---------4----------------------->

## 如何理解和应用坚实的原则

![](img/0e9689114b76186c89b2ff08ffba8ea2.png)

Photo by [NESA by Makers](https://unsplash.com/@nesabymakers?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

固体原理的发明始于 80 年代末。Robert C. Martin 在 USENET(一种早期的脸书)上讨论软件设计原则时开始发展这些原则。经过加减运算，罗伯特·c·马丁在 21 世纪初制定了这些原则。直到 2004 年才整理出原理，称之为固本原理。这是一个缩写，代表五个具体的设计原则。

*   S 代表单一责任原则
*   **O** 代表开启关闭原理
*   **L** 代表利斯科夫替代原理
*   **I** 代表界面分离原理
*   **D** 表示依赖倒置原则

坚实的原则在构建单个模块或更大的架构时都很有用。因此，我们将通过 JavaScript 中的例子来探究每个原则。

# 单一责任原则

这个原理在汤姆·狄马克和梅里尔·佩奇-琼斯的著作中有所描述。他们称之为凝聚力。他们把内聚定义为一个模块中元素的功能相关性。

## SRP 出了什么问题？

事实上，这个原则可能是最不容易理解的，因为有一个特别不恰当的名称。许多开发人员明白每个模块应该只做一件事。毫无疑问，有这样一个原则。但它不是一个坚实的原则，它实际上不是 SRP。

## 那么，什么是 SRP 呢？

描述如下:“*每个软件模块有且只有一个理由改变*”。因为，软件系统的改变是为了满足用户需求，满足利益相关者，所以我们可以这样重新表述这个原则:“*每个模块应该对一个，并且仅仅是一个，用户或利益相关者*”*。*但是很可能会有不止一个用户或利益相关者希望系统以同样的方式改变，我们称他们为行动者或小组，所以最终的版本是:“*每个模块应该对一个，且只能对一个行动者*负责”。

## 我们通过一些例子来了解什么是 SRS

假设我们有一个`Employee`对象，它有三个功能:`calculatePay()`、`reportHours()`和`save()`。

不幸的是，它违反了 SRP，因为这三项职能由三个不同的参与者负责。

*   `calculatePay()`职能由会计部门负责。
*   `reportHours()`功能由人力资源部使用。
*   `save()`功能由数据库管理员指定。

因此，避免这个问题的方法是分离支持不同参与者的代码。

*   `EmployData`对象保存一个共享的简单数据结构，它由所有三个角色使用。

*   `PayCalculator`对象有`calculatePay()`方法。

*   `HourReporter`对象有`reportHours()`方法。

*   `EmployeeServer`对象有`save()`方法。

这就是我们如何使用 SRS 来重构糟糕的代码。每个功能负责一个特定的参与者。SRP 是最简单的原则之一，也是最难实现的原则之一。

# 开闭原则

Bertrand Meyer 在 20 世纪 80 年代将这一原则公之于众，出现在他的著作《面向对象的软件构造》中。软件系统被设计成允许那些系统的行为通过添加新代码而不是改变现有代码来改变。

## 什么是开闭原则(OCP)？

OCP 声明如下:“*软件实体(类、模块、函数等)应该对扩展开放，但对修改关闭”*Meyer，Bertrand *。*这个原则建议我们重构系统，这样进一步的改变就不会引起更多的修改。大多数开发人员认为 OCP 是指导他们设计类和模块的原则。

OCP 有两个主要属性，它们是。

*   开放扩展—我们能够扩展模块的功能。
*   对修改关闭—扩展模块的行为不会导致模块的源代码或二进制代码发生变化。

这两个属性似乎相互矛盾，因为扩展模块行为的正常方式是对该模块的源代码进行更改。

## 那么，如何实现 OCP 呢？

假设每个雇员都有一个角色和被授予的特权。但是，如果我们在系统中引入一个新的角色，而不修改现有的东西。所以我们可以像下面的例子一样，让它通过 OCP。

因此，在上面的例子中，我们不必修改现有的代码，而是可以扩展它来添加一个新的角色。OCP 是系统架构背后的驱动力之一。目标是使系统易于扩展，而不会受到变化的严重影响。

# 利斯科夫替代原理

Barbara Liskov 对子类型的著名定义，来自 1988 年在一次题为《数据抽象和层次结构》的会议主题演讲中。简而言之，这一原则认为，要用可互换的部件构建软件系统，这些部件必须遵守一个允许这些部件相互替换的契约。

## 你可以这样理解它

这个原理的一个经典例子是一个有四条边的矩形。矩形的高度可以是任何值，宽度可以是任何值。正方形是宽度和高度相等的长方形。所以可以说可以把 rectangle 类的属性扩展到 square 类。为了做到这一点，您需要将子类(正方形)与父类(矩形)交换，以符合具有四条等边的正方形的定义，但派生类不会影响父类的行为，因此如果您这样做，将违反 Liskov 替换原则。

## 看到哪里出问题了吗？

假设我们有一个应用程序，它使用一个矩形对象，定义如下。

基于正方形是边长相等的矩形的知识，我们决定创建一个正方形对象来代替矩形。

不幸的是，当应用程序试图用正方形代替矩形时，就发现了一个问题。原来其中一个方法是这样计算矩形的面积的。

当使用`square`调用该方法时，乘积是 16，而不是预期值 12。我们的`square`对象违反了关于`area`函数的利斯科夫替换原则。在这种情况下，长度和宽度属性的存在暗示了我们的正方形可能不会 100%与矩形兼容，但我们不会总是有这样明显的暗示。

# 界面分离原理

这个原则建议软件设计者避免依赖他们不用的东西。

## 举一个简单的例子来理解 ISP

假设你进入一家餐馆，你是一个纯素食者。那家餐馆的服务员给了你菜单卡，上面有素食、非素食、饮料和糖果。在这种情况下，作为顾客，你应该有一张菜单卡，上面只包括素食，而不是你不吃的任何东西。对于不同类型的顾客，菜单应该是不同的。每个人的公共或通用菜单卡可以分成多个卡片，而不是一个。使用这个原则有助于减少副作用和所需更改的频率。

## 如何用 JavaScript 实现 ISP？

因为我们在 JavaScript 中默认没有接口。但是我们都可能会遇到这样的情况，我们想在一个类的构造函数上做很多事情。那么，现在如何实现 ISP 呢？

先说一些我们要在构造函数里做的设置。我们所做的设置应该与构造函数中其他不需要的设置分开。

在这里，`validateUser()`函数将在`initiateUser()`构造函数调用中被调用，尽管它并不总是需要的。我们可以用下面的代码将它引入 ISP。

正如上面的代码，我们将不需要的逻辑从`contractor`函数中分离出来。

# 依存倒置原则

在我们讨论这个主题之前，请记住依赖倒置和依赖注入都是不同的概念。大多数人对此感到困惑，认为两者是一样的。现在关键点在这里，记住这个原则。

## 不要与依赖注入原则混淆

依赖倒置原则(DIP)告诉我们，最灵活的系统是那些源代码依赖仅指抽象而非具体的系统。相反，细节应该取决于政策。

## 看一个真实的例子

您可以考虑电视遥控器电池的真实例子。您的遥控器需要电池，但这与电池品牌无关。你可以使用任何你想要的 XYZ 品牌，它会工作。所以我们可以说电视遥控器和品牌名称是松耦合的。依赖反转使你的代码更加可重用。

## 如何用 JavaScript 实现 DIP？

在静态类型语言(如 Java)中，这意味着 use、import 和 include 语句应该只引用包含接口、抽象类或其他某种抽象声明的源模块。不应该依赖任何具体的东西。对于 JavaScript，我们如何实现 DIP？

让我们举一个简单的例子来理解我们如何轻松地做到这一点。

我想联系服务器获取一些数据。如果不使用 DIP，可能会如下所示。

使用 DIP，我可能会编写如下代码

```
fillFromServer("/address/to/data", thingyView)
```

对于我们想要使用 jQuery 的 Ajax 的特殊情况，抽象函数`fillFromServer`可以实现如下。

抽象`view`可以基于 id 为`thingy1`和`thingy2`的元素为视图的特殊情况实现，如下所示。

很简单，对吧？我希望这能让你对如何在 JavaScript 中应用坚实的原则有一个基本的了解。

## **用简单英语写的 JavaScript 笔记**

我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:[**AI in Plain English**](https://medium.com/ai-in-plain-english)，[**UX in Plain English**](https://medium.com/ux-in-plain-english)，[**Python in Plain English**](https://medium.com/python-in-plain-english)**—谢谢，继续学习！**

**我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至[**submissions @ plain English . io**](mailto:submissions@plainenglish.io)**，使用您的 Medium 用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。****

# ****参考****

****[1]结构化分析和系统规范。汤姆·狄马克，你的儿子。出版社计算系列，1979 年。****

****[2]结构化系统设计实用指南，第 2 版。由…编辑梅里尔·佩奇·琼斯。Your-don 出版社计算系列，1988 年。****

****[3]面向对象的软件构造。伯特兰·梅尔。普伦蒂斯霍尔，1988 年。****