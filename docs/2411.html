<html>
<head>
<title>React Best Practices — Spacing Old Features and Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应最佳实践—分隔旧功能和道具</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-best-practices-spacing-and-props-b54e28119567?source=collection_archive---------9-----------------------#2020-06-21">https://javascript.plainenglish.io/react-best-practices-spacing-and-props-b54e28119567?source=collection_archive---------9-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/992e366fc8eaa89f33e43c71f37dd498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LkemXmtOvNmQV9y4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@henry_be?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Henry Be</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ccf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何种类的应用程序一样，React应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="d58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写React应用程序时的一些最佳实践。</p><p id="b2b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们还会查看应该避免的旧React特性。</p><h1 id="0c0e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有未被空格分隔的相邻行内元素</h1><p id="e47a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有没有被空格分隔的嵌套的行内元素。</p><p id="5ca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该有这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4399" class="mn lc iq mj b gy mo mp l mq mr">&lt;div&gt;&lt;a&gt;&lt;/a&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt;</span></pre><p id="29bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很难读，我们可能会因此而犯错误。</p><p id="2c1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6668" class="mn lc iq mj b gy mo mp l mq mr">&lt;div&gt;&lt;a&gt;&lt;/a&gt; &lt;a&gt;&lt;/a&gt;&lt;/div&gt;</span></pre><p id="8cef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们有一些空间。</p><h1 id="142a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要对键使用数组索引</h1><p id="451c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用数组索引作为<code class="fe ms mt mu mj b">key</code>属性的值。</p><p id="253a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为数组索引不能唯一地标识我们的元素。</p><p id="5cdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果对其进行排序或重新排列，索引会发生变化。</p><p id="745b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们需要在每个数组条目中有一个唯一可识别的值来传递给key prop。</p><p id="f91d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1e93" class="mn lc iq mj b gy mo mp l mq mr">things.map((thing, index) =&gt; (<br/>  &lt;Foo key={index} /&gt;<br/>));</span></pre><p id="028a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="30e4" class="mn lc iq mj b gy mo mp l mq mr">things.map((thing, index) =&gt; (<br/>  &lt;Foo key={thing.id} /&gt;<br/>));</span></pre><h1 id="1f98" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">路过的孩子当道具</h1><p id="c631" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不应该在我们的组件中显式写出<code class="fe ms mt mu mj b">children</code>属性。</p><p id="4a15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为<code class="fe ms mt mu mj b">children</code>是在标签之间传递元素和组件的特殊道具。</p><p id="b8cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="767f" class="mn lc iq mj b gy mo mp l mq mr">&lt;div children='Children' /&gt;</span></pre><p id="24c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="77b6" class="mn lc iq mj b gy mo mp l mq mr">&lt;Foo&gt;<br/>  &lt;span&gt;Child 1&lt;/span&gt;<br/>  &lt;span&gt;Child 2&lt;/span&gt;<br/>&lt;/Foo&gt;</span></pre><h1 id="3c64" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用危险的JSX道具</h1><p id="96f5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该避开<code class="fe ms mt mu mj b">dangerouslySetInnerHTML</code>。</p><p id="5584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它不经过任何净化就呈现HTML。</p><p id="99bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这肯定不好，因为任何人都可以运行任何类型的代码，包括恶意代码。</p><h1 id="c134" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要同时使用儿童道具和危险道具</h1><p id="f9f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">children</code>道具和<code class="fe ms mt mu mj b">dangerouslySetInnerHTML</code>不能同时使用。</p><p id="59db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f157" class="mn lc iq mj b gy mo mp l mq mr">&lt;div dangerouslySetInnerHTML={{ __html: "HTML" }}&gt;<br/>  Children<br/>&lt;/div&gt;</span></pre><p id="ea04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6df3" class="mn lc iq mj b gy mo mp l mq mr">&lt;Hello&gt;<br/>  Children<br/>&lt;/Hello&gt;</span></pre><p id="2a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="13ed" class="mn lc iq mj b gy mo mp l mq mr">&lt;div dangerouslySetInnerHTML={{ __html: "HTML" }} /&gt;</span></pre><h1 id="e74a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用不推荐的方法</h1><p id="b5fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有些React方法已被弃用。</p><p id="cdb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括<code class="fe ms mt mu mj b">render</code>、<code class="fe ms mt mu mj b">unmountComponentAtNode</code>、<code class="fe ms mt mu mj b">findDOMNode</code>、<code class="fe ms mt mu mj b">renderYoString</code>、<code class="fe ms mt mu mj b">renderToStaticMarkup</code>和<code class="fe ms mt mu mj b">createClass</code>。</p><p id="653a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些方法不应该再使用了，因为它们将来会被删除。</p><h1 id="a48b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要在componentDidMount中使用setState</h1><p id="ce87" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">组件挂载后更新状态将触发第二次渲染，因此性能将受到影响。</p><p id="21b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="581a" class="mn lc iq mj b gy mo mp l mq mr">componentDidMount: function() {<br/>  this.setState({<br/>    name: this.props.name<br/>  });<br/>}</span></pre><h1 id="7c7c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">componentDidUpdate中没有setState</h1><p id="60c5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像使用<code class="fe ms mt mu mj b">componentDidMount</code>一样，使用<code class="fe ms mt mu mj b">setState</code>和<code class="fe ms mt mu mj b">componentDidUpdate</code>会导致第二次渲染，因此性能会受到影响。</p><p id="e5af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2f6f" class="mn lc iq mj b gy mo mp l mq mr">componentDidUpdate() {<br/>  this.setState({<br/>    name: this.props.name.toUpperCase()<br/>  });<br/>}</span></pre><p id="3695" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="51a7" class="mn lc iq mj b gy mo mp l mq mr">componentDidUpdate() {<br/>  onUpdate();<br/>}</span></pre><p id="bfa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样可以提高性能。</p><h1 id="8dab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要对这个状态进行直接突变</h1><p id="4309" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要改变一个组件的状态，我们应该调用<code class="fe ms mt mu mj b">setState</code>。</p><p id="0bbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为如果调用<code class="fe ms mt mu mj b">setState</code>，直接设置<code class="fe ms mt mu mj b">this.state</code>将不起作用。</p><p id="b2b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">setState</code>将覆盖<code class="fe ms mt mu mj b">this.state</code>的值。</p><p id="a9f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fbe2" class="mn lc iq mj b gy mo mp l mq mr">this.state.name = this.props.name;</span></pre><p id="c76b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2024" class="mn lc iq mj b gy mo mp l mq mr">this.setState({<br/>  name: this.props.name;<br/>});</span></pre><h1 id="2afa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用findDOMNode</h1><p id="34ce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">findDOMNode</code>阻止了React的某些改进，所以我们不应该使用它来获取DOM元素。</p><p id="6e6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用参考文献。</p><p id="6d50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="26bf" class="mn lc iq mj b gy mo mp l mq mr">findDOMNode(this).scrollIntoView();</span></pre><p id="d96d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5b82" class="mn lc iq mj b gy mo mp l mq mr">function Foo {<br/>  const ref = useRef();</span><span id="bd1f" class="mn lc iq mj b gy mv mp l mq mr">  useEffect({} =&gt; {<br/>    ref.current.scrollIntoView()<br/>  }, []);</span><span id="38b5" class="mn lc iq mj b gy mv mp l mq mr">  return &lt;div ref={ref} /&gt;<br/>}</span></pre><h1 id="744c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用isMounted</h1><p id="a835" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">isMounted</code>不应该使用，因为它是反模式。</p><p id="d92f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该检查一个组件是否与它一起安装。</p><p id="e4d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该用状态来检查组件是否被安装。</p><p id="8b1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它在类或函数组件中不可用。</p><p id="48ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f9b8" class="mn lc iq mj b gy mo mp l mq mr">if (this.isMounted()) {<br/>  return;<br/>}</span></pre><p id="ddfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该移除它们。</p><h1 id="5e85" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为每个文件定义一个组件</h1><p id="882b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们为每个文件定义一个组件，就更容易跟踪组件。</p><p id="12e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该这样做。</p><h1 id="beed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">扩展React时不要使用shouldComponentUpdate。纯组件</h1><p id="d0ab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">拥有一个纯组件的全部在于我们想要使用内置的<code class="fe ms mt mu mj b">shouldComponentUpdate</code>实现。</p><p id="31f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该在我们的类组件中有<code class="fe ms mt mu mj b">shouldComponentUpdate</code>，即使我们可以使用它。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a80b8c2fb84de1232446c75de435dccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aRAnoQZ0x4sYWvW_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ramche?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ramiz Dedaković</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8e34" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5f96" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用被否决的方法。</p><p id="5758" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该对键使用数组索引，因为如果我们重新排列它们，条目的索引可能会改变。</p><h2 id="323b" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="8885" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四种出版物吗？通过<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>找到他们——通过关注我们的出版物和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达爱意吧！</strong></p></div></div>    
</body>
</html>