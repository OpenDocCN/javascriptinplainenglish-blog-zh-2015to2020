<html>
<head>
<title>Node.js Tips — Closing Connections, Templates, and Dates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—关闭连接、模板和日期</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-closing-connections-templates-and-dates-c170e365a6df?source=collection_archive---------9-----------------------#2020-07-31">https://javascript.plainenglish.io/node-js-tips-closing-connections-templates-and-dates-c170e365a6df?source=collection_archive---------9-----------------------#2020-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4d9d4335490f5f4ba414ad51a4478f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BEAZNrQLqz785Q2v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alexrussellsaw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Russell-Saw</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="73cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="054f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Mongoose的2个字段进行自定义验证</h1><p id="19ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在Mongoose中使用2个字段进行自定义验证，我们可以创建一个自定义模式和一个验证函数，并将其作为对象中字段的值传递给<code class="fe me mf mg mh b">Schema</code>构造函数。</p><p id="7caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ec08" class="mq lc iq mh b gy mr ms l mt mu">const dateRangeSchema = {<br/>  startDate: { type: Date },<br/>  endDate: { type: Date }<br/>};</span><span id="30ac" class="mq lc iq mh b gy mv ms l mt mu">const checkDates = (value) =&gt; {<br/>  return value.endDate &lt; value.startDate; <br/>}</span><span id="8a23" class="mq lc iq mh b gy mv ms l mt mu">const schema = new Schema({<br/>  dateRange: { type: dateRangeSchema, validate: checkDates }<br/>});</span></pre><p id="2147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了带有<code class="fe me mf mg mh b">startDate</code>和<code class="fe me mf mg mh b">endDate</code>字段的<code class="fe me mf mg mh b">dateRangeSchema</code>。</p><p id="18b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们创建了w <code class="fe me mf mg mh b">checkDates</code>函数来返回日期范围。</p><p id="27f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将两者都传递给对象来指定字段的数据类型。</p><p id="c806" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过编写以下代码向<code class="fe me mf mg mh b">validate</code>传递回调:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="70e0" class="mq lc iq mh b gy mr ms l mt mu">schema.pre('validate', function(next) {<br/>  if (this.startDate &gt; this.endDate) {<br/>    next(new Error('start date is after the end date'));<br/>  } else {<br/>    next();<br/>  }<br/>});</span></pre><p id="3d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从模型中获取<code class="fe me mf mg mh b">startDate</code>和<code class="fe me mf mg mh b">endDate</code>值，如果开始日期大于结束日期，则调用<code class="fe me mf mg mh b">next</code>时出错。</p><p id="06c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们调用<code class="fe me mf mg mh b">next</code>,什么也不做，照常进行。</p><h1 id="8c5d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">格式化来自MongoDB的日期</h1><p id="ad45" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">toDateString</code>方法格式化来自MongoDB的日期。</p><p id="1c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ed9d" class="mq lc iq mh b gy mr ms l mt mu">Schema<br/>  .virtual('date')<br/>  .get(function() {<br/>    return this._id.generationTime.toDateString();<br/>  });</span></pre><p id="c6bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用moment.js库，让我们的生活变得更加轻松。</p><p id="691c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a8a1" class="mq lc iq mh b gy mr ms l mt mu">Schema<br/>  .virtual('date')<br/>  .get(function() {<br/>    return moment(this._id.generationTime).format("YYYY-MM-DD HH:mm");<br/>  });</span></pre><p id="b907" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用了<code class="fe me mf mg mh b">format</code>方法，将从<code class="fe me mf mg mh b">moment</code>函数创建的moment对象格式化为我们想要的日期格式。</p><p id="996f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它以字符串的形式返回。</p><h1 id="eb54" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Jade/Pug模板中类名的变量</h1><p id="a661" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过编写以下代码将字符串插入到Jade/Pug模板中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="862b" class="mq lc iq mh b gy mr ms l mt mu">div(class="language-#{session.language}")</span></pre><h1 id="a211" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express应用程序中监听所有接口，而不是仅监听本地主机</h1><p id="91b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们通过传入<code class="fe me mf mg mh b">'0.0.0.0'</code>作为<code class="fe me mf mg mh b">listen</code>的第二个参数来监听Express应用程序中的所有接口。</p><p id="dd0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cc6c" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const app = express();<br/>app.listen(3000, '0.0.0.0');</span></pre><h1 id="e9da" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Javascript逻辑中访问EJS变量</h1><p id="171c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个呈现EJS模板的路径，我们可以呈现从<code class="fe me mf mg mh b">render</code>方法传入的变量。</p><p id="2f45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a5a" class="mq lc iq mh b gy mr ms l mt mu">app.get("/post/:title, (req, res) =&gt; {<br/>  //...<br/>  res.render("post", { title, description });<br/>}</span></pre><p id="414e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创造我们的路线，</p><p id="fcba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的EJS模板中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="843b" class="mq lc iq mh b gy mr ms l mt mu">&lt;% if (title) { %&gt;<br/>     &lt;h2&gt;Post&lt;/h2&gt;<br/>     &lt;script&gt;<br/>        const postTitle = &lt;%= title %&gt;            <br/>     &lt;/script&gt;<br/>&lt;% } %&gt;</span></pre><p id="7ef8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从第二个参数中的对象获得<code class="fe me mf mg mh b">title</code>。</p><p id="33ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">title</code>插入到模板中。</p><p id="3ab9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以把它赋给一个变量。</p><h1 id="1cfa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结束Express.js POST响应</h1><p id="584a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">res.end</code>结束响应来结束响应。</p><p id="5eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3102" class="mq lc iq mh b gy mr ms l mt mu">res.end('hello');</span></pre><p id="bf47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以渲染一个模板，然后调用<code class="fe me mf mg mh b">res.end</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e7cc" class="mq lc iq mh b gy mr ms l mt mu">res.render('some.template');<br/>res.end();</span></pre><h1 id="82b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">当进程被终止时，正常关闭Express服务器</h1><p id="e2b7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以监听<code class="fe me mf mg mh b">SIGTERM</code>和<code class="fe me mf mg mh b">SIGINT</code>信号，然后在这些信号的处理程序中运行我们的代码，并在回调中关闭服务器。</p><p id="0938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5bde" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');</span><span id="f1ee" class="mq lc iq mh b gy mv ms l mt mu">const app = express();</span><span id="5322" class="mq lc iq mh b gy mv ms l mt mu">app.get('/', (req, res) =&gt; res.send('hello'});</span><span id="fe70" class="mq lc iq mh b gy mv ms l mt mu">const server = app.listen(3000);</span><span id="4cb4" class="mq lc iq mh b gy mv ms l mt mu">setInterval(() =&gt; server.getConnections((err, connections) =&gt;  {<br/>  console.log(`${connections} connections currently open`)<br/>}), 1000);</span><span id="cfc1" class="mq lc iq mh b gy mv ms l mt mu">process.on('SIGTERM', shutDown);<br/>process.on('SIGINT', shutDown);</span><span id="7c53" class="mq lc iq mh b gy mv ms l mt mu">let connections = [];</span><span id="1cca" class="mq lc iq mh b gy mv ms l mt mu">server.on('connection', connection =&gt; {<br/>  connections.push(connection);<br/>  connection.on('close', () =&gt; {<br/>    connections = connections.filter(curr =&gt; curr !== connection)<br/>  });<br/>});</span><span id="6e2a" class="mq lc iq mh b gy mv ms l mt mu">const shutDown = () =&gt; {<br/>  server.close(() =&gt; {<br/>    process.exit(0);<br/>  });</span><span id="9240" class="mq lc iq mh b gy mv ms l mt mu">  setTimeout(() =&gt; {<br/>    process.exit(1);<br/>  }, 10000);</span><span id="5138" class="mq lc iq mh b gy mv ms l mt mu">  connections.forEach(curr =&gt; curr.end());<br/>  setTimeout(() =&gt; connections.forEach(curr =&gt; curr.destroy()), 5000);<br/>}</span></pre><p id="abeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">process.on</code>方法收听<code class="fe me mf mg mh b">SIGTERM</code>和<code class="fe me mf mg mh b">SIGINT</code>信号。</p><p id="8af9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入<code class="fe me mf mg mh b">shutDown</code>函数，在这里我们调用<code class="fe me mf mg mh b">server.close</code>来关闭连接。</p><p id="98a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果连接没有成功关闭，我们也会在10秒后退出，代码为1。</p><p id="0417" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接存储在<code class="fe me mf mg mh b">connections</code>数组中，并调用<code class="fe me mf mg mh b">end</code>关闭每个连接。</p><p id="155f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也调用<code class="fe me mf mg mh b">destroy</code>在5秒钟后破坏连接。</p><p id="6836" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接来自于<code class="fe me mf mg mh b">connection</code>事件处理程序，在那里我们将新的连接对象推入到<code class="fe me mf mg mh b">connections</code>数组中。</p><p id="a40e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还用<code class="fe me mf mg mh b">filter</code>方法添加了<code class="fe me mf mg mh b">close</code>处理程序。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5bd787244ada98b02b785a4da7703c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2IwSC_gUgHe7-mUT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@koushikc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Koushik Chowdavarapu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a0b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="afa3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Mongoose同时验证多个字段。</p><p id="75b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以优雅地关闭连接。</p><p id="dc60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以格式化来自MongoDB的日期。</p><h2 id="6d10" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="e7ee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>