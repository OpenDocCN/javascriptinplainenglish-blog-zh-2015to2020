<html>
<head>
<title>Understanding Regular Expressions Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解正则表达式第4部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-regular-expressions-c481e5c34df0?source=collection_archive---------14-----------------------#2020-07-13">https://javascript.plainenglish.io/introduction-to-regular-expressions-c481e5c34df0?source=collection_archive---------14-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3f7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写正则表达式引擎</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/5029d80a2310c9844bbcc4d4053784bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*uiQuhdsvifghFD-a-G-BeA.jpeg"/></div></figure><p id="3436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的上一期中，我们重点关注了重复字符以及“match”和“matchAll”的更多用法在本文中，我将稍微绕一下路，研究正则表达式引擎本身是如何工作的。为此，我将简要回顾一些基本的正则表达式概念。然后我会开始编写我们自己的正则表达式引擎。</p><p id="cfb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要回到一些基本的正则表达式概念和术语。正则表达式是一组表示文本模式的符号。这些符号是由正则表达式引擎解释的正式语言，用于匹配、搜索和替换文本。许多编程语言使用正则表达式引擎，包括JavaScript。NET、Python、Ruby、C、C++、Java、PHP和Perl等等。在JavaScript中，正则表达式的符号遵循以下基本格式:</p><pre class="km kn ko kp gt kt ku kv kw aw kx bi"><span id="878b" class="ky kz iq ku b gy la lb l lc ld">/[pattern]/[flag(s)]</span></pre><p id="dc11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面可以看出，两个正斜杠之间是引擎在文本中搜索的正则表达式模式。该模式可以包括文字字符和特殊字符，这些字符提供了关于如何匹配模式的更详细的信息。这些标志规定了发动机运行的模式。例如，“I”表示不区分大小写的模式，在这种模式下，引擎会忽略小写/大写的区别。</p><p id="c563" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经有了一些基础知识，让我们开始创建自己的正则表达式引擎，以了解更多关于正则表达式匹配如何工作的“幕后”机制。对于这个项目，我们的正则表达式引擎的第一次迭代将比真正的正则表达式引擎更简单，但它将阐明基本的正则表达式思想。我将使用node.js来解决这个问题。此外，我将尽量避免使用javascript的内置“助手”方法。如果你想看这个程序的最新版本，这里是GitHub库。</p><pre class="km kn ko kp gt kt ku kv kw aw kx bi"><span id="9e60" class="ky kz iq ku b gy la lb l lc ld">const readline = require('readline')<br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>})<br/>const ask = query =&gt; new Promise((resolve,reject) =&gt; {<br/>  rl.question(query, answer =&gt; resolve(answer))<br/>})</span><span id="71c6" class="ky kz iq ku b gy lf lb l lc ld">let [pattern, text ] = ['','']</span><span id="3707" class="ky kz iq ku b gy lf lb l lc ld">ask("Input Regular Expression Pattern\n")<br/>  .then(result =&gt; { <br/>      pattern = result<br/>      return ask("Input Text to Match Against Pattern\n")<br/>    })<br/>   .then(text =&gt; {<br/>       rl.close()<br/>       console.log(test(pattern, text))<br/>   })<br/>  .catch(error =&gt; console.log(error))</span></pre><p id="6439" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该代码片段对于设置我们的环境是必要的，但对于我们引擎的整体逻辑并不重要。我简单解释一下。我们需要一个“readline”库来设置用户界面。创建接口行设置一个接口对象，它使用标准输入和标准输出来与对象交互。</p><p id="e23f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我设置了一个函数“asks ”,承诺为用户输入和输出功能创建一个异步流。最后一个块的必要步骤如下:请求正则表达式模式，然后请求文本与模式匹配；然后用两个结果创建一个对象；然后关闭界面；然后再解构出两个变量。最后，我们使用测试函数来确定文本是否包含模式。</p><p id="ce30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到这里，让我们来看看测试函数对引擎的影响。该函数接收模式和文本作为输入，同时返回true(如果找到模式)或false(如果没有找到模式)作为输出。查看下面的代码，我们可以看到该函数的主要逻辑由两个循环组成—第一个循环遍历字符串中的每个字符。匹配的第一个字符启动第二个内部循环。</p><pre class="km kn ko kp gt kt ku kv kw aw kx bi"><span id="8f52" class="ky kz iq ku b gy la lb l lc ld">function test(pattern,text){<br/>  let i = 0<br/>  //outer while loop moves from one character to another in the text          //until the end is reached or a match is found<br/>  while(i &lt; text.length) {<br/>    if(text.charAt(i) === pattern[0]){<br/>      let j = 1<br/>      <strong class="ku ir">while(j &lt; pattern.length &amp;&amp; pattern[j] <br/>                  === text.charAt(i + j)){</strong></span><span id="bb10" class="ky kz iq ku b gy lf lb l lc ld"><strong class="ku ir">j += 1<br/>    }</strong><br/>   //all characters are equal to pattern return true<br/>     <strong class="ku ir">if(j === pattern.length){return true}</strong><br/>   }<br/>   i += 1<br/>  }<br/>  //the loop has gone through every character in the text and no <br/>  //pattern is matched  <br/>  <strong class="ku ir">return false</strong><br/>}</span></pre><p id="689f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整体逻辑很简单，说明了正则表达式引擎工作的必要过程。</p><ol class=""><li id="847d" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated">在外部循环中，引擎检查文本中的每个字符。</li><li id="287e" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第一个字符匹配启动第二个内部循环。</li><li id="51a4" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">这个内部循环使用另一个计数器来验证所有的模式是否匹配该部分文本。</li><li id="fc2f" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">当引擎找到一个模式时，它返回true。</li><li id="1c8c" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">否则，引擎放弃在该索引处查找该模式，外部循环继续。</li><li id="8689" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">如果循环遍历整个文本，但没有找到任何模式，则返回false。</li></ol><p id="5b22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个例子来更深入地了解它是如何工作的。在我们的终端中，我们运行程序，输入正则表达式模式和要匹配的文本。结果是真的。让我们按照步骤来看看这是如何发生的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/10c374d1a200ee585cfa336ceb1acd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Z5nZ2nT4CYdeXubcf4hj7A.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">pattern: ‘abc’, input text: ‘abdefgabcgi’</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/f6d2e85e75edb01617d1574412de55ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*IcQxbp3SYFKFyWRyEAGm9w.png"/></div></figure><ol class=""><li id="cf89" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated">引擎从第一个字符开始并检查其值。它发现该字母与模式匹配。</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/6068bd823e1ca5c960e57401f16bb145.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*tAI_PXY6x5jl1kIm8_A8pA.png"/></div></figure><p id="de44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.该引擎检查每个字符，只要它匹配“abc”模式。它发现这种模式不可能完全满足。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/96955c473383d20a1dabdfd9a5fe7c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*M6RXx2aRqvCMBbfhQBgExQ.png"/></div></figure><p id="7fe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.该模式失败，引擎从循环通过每个字符的下一个字母重新开始。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/1697bd04097e8dc903171fc217dd0392.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*-eKF6rJVZqcEhd2zop159A.png"/></div></figure><p id="3a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.在迭代许多字符后，引擎最终找到一个再次匹配的字母。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4607656df27d8012a675a3fb6954831d.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*2QrGGniphcQysUaFfSSbDg.png"/></div></figure><p id="2765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.内部循环遍历每个字符。这一次，所有的字符都与模式匹配。该函数随后返回true。</p><p id="e3b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">匹配一组文字字符是匹配过程如何工作的最简单的例子。让我们添加一些简单的功能，通过添加“通配符”来“增强”引擎通配符表示“任何字符”换句话说，引擎只需验证某个字符是否在该位置就可以通过通配符测试。</p><pre class="km kn ko kp gt kt ku kv kw aw kx bi"><span id="5301" class="ky kz iq ku b gy la lb l lc ld">export default function test(pattern, text) {<br/>  let i = 0;<br/>  while (i &lt; text.length) {<br/>    if (text.charAt(i) === pattern[0] || pattern[0] === '.') {<br/>      let j = 1;<br/>      while (j &lt; pattern.length &amp;&amp; (pattern[j] === text.charAt(i + j) || <strong class="ku ir">pattern[j] === '.'</strong>)) {<br/>        j += 1;<br/>        <strong class="ku ir">if (i + j &gt; text.length) {<br/>          return false;<br/>        }</strong><br/>      }<br/>      if (j === pattern.length) {<br/>        return true;<br/>      }<br/>    }<br/>    i += 1;<br/>  }<br/>  return false;<br/>}</span></pre><p id="c796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看上面的代码，我们可以看到新代码包含对旧代码的两处修改。首先，对于内部循环，如果模式字符是通配符，迭代将继续。其次，添加了一个条件，以确保模式匹配循环不会超过字符串的末尾。</p><p id="488d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是对我们终端新功能的一个快速测试。第一个测试基于字符的数量和类型成功地识别出测试中的正确模式，允许任意的通配符。第二个测试通过拒绝不符合模式的文本来产生预期的结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/dab23c1fda88e11724d62cd12df40256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PC-pvydVCp55YDck0jabeA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk">Testing new wildcard functionality</figcaption></figure><h2 id="e485" class="ky kz iq bd mj mk ml dn mm mn mo dp mp jy mq mr ms kc mt mu mv kg mw mx my mz bi translated">关键要点</h2><ol class=""><li id="5217" class="lg lh iq jp b jq na ju nb jy nc kc nd kg ne kk ll lm ln lo bi translated">正则表达式引擎是用于匹配文本中正则表达式模式的代码。</li><li id="ef60" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">正则表达式引擎不局限于特定的语言，在多种语言中都有相似的规则，包括JavaScript。NET、Python、Ruby、C、C++、Java、PHP和Perl。</li><li id="473d" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">该引擎通过逐个字符地迭代文本来寻找正则表达式模式的匹配。</li><li id="516c" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">如果模式开始但不完整，引擎将回溯，从而防止在引擎继续迭代时丢失模式。</li></ol><p id="3dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的下一部分<a class="ae le" href="https://medium.com/@GreatDeveloper66/introduction-to-regular-expressions-8be3b2271af" rel="noopener">中，我们将构建我们的引擎，并回顾正则表达式中使用的一些更特殊的字符和标志。</a></p><h2 id="c703" class="ky kz iq bd mj mk ml dn mm mn mo dp mp jy mq mr ms kc mt mu mv kg mw mx my mz bi translated">更多资源</h2><p id="1861" class="pw-post-body-paragraph jn jo iq jp b jq na js jt ju nb jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated"><a class="ae le" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank">RegExpr</a>-学习、构建和测试正则表达式的在线工具</p><p id="e769" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank">正则表达式</a>-维基百科文章</p><p id="9665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://www.rexegg.com/regex-quickstart.html" rel="noopener ugc nofollow" target="_blank">正则表达式备忘单</a></p><p id="ae3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://eloquentjavascript.net/09_regexp.html" rel="noopener ugc nofollow" target="_blank">雄辩的JavaScript</a>——著名的JavaScript书《雄辩的JavaScript》有一章专门讨论正则表达式。</p><p id="065c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://github.com/GreatDeveloper66/RegExp-Engine" rel="noopener ugc nofollow" target="_blank">GitHub</a>——GitHub储存库，用于本文中回顾的代码。</p></div></div>    
</body>
</html>