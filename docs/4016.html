<html>
<head>
<title>Implement Lazy Loading In Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中实现延迟加载</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lazy-loading-e96685a4c281?source=collection_archive---------13-----------------------#2020-11-10">https://javascript.plainenglish.io/lazy-loading-e96685a4c281?source=collection_archive---------13-----------------------#2020-11-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8f6801791cb57adc47523c71263faf93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*COPcifQTReyjZSav"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@studio57mm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mike Burke</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a76c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">应用程序的用户体验对于留住用户非常重要。当一个应用程序需要很长时间加载时，用户先生，你有什么感觉？</p><p id="0255" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，它当然不能留住你。</p><p id="b3ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，angular不会让这种情况发生在它的应用上。你以为懒装就是懒？</p><p id="7d7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，Angular适应急切加载策略。快速加载在应用程序呈现的初始阶段加载app模块中声明的所有组件。当组件数量增加时，呈现应用程序所需的加载时间会很长。这会让用户不高兴，远离你的应用程序。解决方法是我们的懒惰装载。通过惰性加载，我们可以快速渲染我们的应用程序，它允许加载所需的组件来渲染页面，使用户体验更好。</p><blockquote class="ky kz la"><p id="9d32" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">可以为angular应用程序中的功能模块实现延迟加载。</p><p id="7562" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">特定的特征模块路线应被分组到单个父模块中。</p><p id="21a8" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">不应在另一个模块中导入功能模块(即使不在应用程序模块中)</p></blockquote><p id="5ea3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要延迟加载功能模块，请在app路由模块中配置其父路由，如下所示。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/6890a55612bc17507bb66551ee66c3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sFN0FTftfwdTkxGBVS68A.png"/></div></div></figure><p id="6f48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">功能模块的导入是一个异步操作，它返回一个承诺。解决承诺后，将加载功能模块。此异步函数被分配给RouterModule的loadChildren属性。该属性负责延迟加载。</p><p id="4cca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当应用程序进行初始呈现时，不会加载productModule。我们可以在浏览器检查器的“网络”选项卡中看到。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/5dbb8d200f2b85aafd659473877cf255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNapwgEA3V0KL6DNfuEioA.png"/></div></div></figure><p id="2d70" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">浏览器只下载主包。当我们仅导航到ProductModule的父路由时，将下载惰性加载的ProductModule。我们可以在下面的网络选项卡中看到。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ll"><img src="../Images/0fa7b4f4d75cb949273ff24820f1f209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfoKfb_JWnw_6xGktbeBLw.png"/></div></div></figure><p id="34a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样我们可以加快装货速度。装载时间减少。</p><p id="64ad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果路由仍然有许多组件要加载，会发生什么呢？它变得和急切装载一样。不是吗？如果我们在加载第一个路由组件时在后台预加载其他模块，会发生什么情况？</p><p id="0cb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，这是个好主意。当其他预加载模块在后台加载时，这些模块将在用户访问它们时可用。因此，用户不需要等待加载其他懒惰加载的模块。</p><p id="a450" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一些预加载策略。默认情况下，应用程序没有预加载。这通常类似于惰性加载。全部预加载，这些选项允许您预加载所有延迟加载的模块。自定义预加载，这将通过配置加载哪个预加载模块以及何时加载来控制预加载。</p><p id="2888" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">预加载策略将在RouterModule中设置为forRoot方法的第二个参数。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/920229d5dc82d7fbc34668169031fa16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZI93XEoPWz8T0tyZHPnpJw.png"/></div></div></figure><p id="fdc0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时我们有意避免预加载模块。示例我们只需要为经过身份验证的用户显示模块内容。要做到这一点，我们可以应用一个CanLoad保护装置来阻止预加载。你可以在<a class="ae jz" href="https://tharmi14t.medium.com/why-i-chose-my-journey-to-angular-7aa7b49769fe" rel="noopener">我之前的教程</a>里看看其他有棱角的守卫。</p><p id="20f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了进行自定义预加载，我们创建了一个预加载策略服务，它实现了PreloadingStrategy接口。在预加载预定义函数中，我们编写代码是否调用加载函数并预加载延迟加载的模块。创建自定义预加载服务后，我们将该服务分配给RootModule的forRoot函数中的preloadingStrategy参数。</p><p id="4098" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想现在你可能对延迟装载有所了解了。下节课再见。</p></div></div>    
</body>
</html>