<html>
<head>
<title>Dynamically generating SQL queries using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js动态生成SQL查询</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dynamically-generating-sql-queries-using-node-js-e89d69930fcb?source=collection_archive---------1-----------------------#2019-08-30">https://javascript.plainenglish.io/dynamically-generating-sql-queries-using-node-js-e89d69930fcb?source=collection_archive---------1-----------------------#2019-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我发布了<a class="ae kl" href="https://github.com/gajus/slonik" rel="noopener ugc nofollow" target="_blank">SLO Nik</a>(node . js的PostgreSQL客户端)并写了一篇有争议的<a class="ae kl" href="https://medium.com/@gajus/stop-using-knex-js-and-earn-30-bf410349856c" rel="noopener">停止使用Knex.js </a>文章(TL；dr；查询生成器被设计成ORM的构造块；当查询的大部分是静态的时，它们不会增加价值。)，我被问了很多—那么我如何生成动态查询呢？我将通过分享几个现实生活中的例子来回答这个问题。</p><p id="c41e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文中的所有查询都是真实业务中使用的真实查询，<a class="ae kl" href="http://applaudience.com/" rel="noopener ugc nofollow" target="_blank">赞成</a>严重依赖PostgreSQL 。</p><p id="7d12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">免责声明:(1)所有例子只讨论SQL注入威胁。授权逻辑(例如，用户有权访问的白名单列)不在本文的讨论范围之内。(2)所有语句都假设Slonik实现中没有bug。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6b2b3fd58d0f8df4ba7cfed8ccf36a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GigUxzijH9F6iWcLhxoIlg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">This article can be also read (with better syntax highlighting) on <a class="ae kl" href="https://dev.to/gajus/dynamically-generating-sql-queries-using-node-js-2c1g" rel="noopener ugc nofollow" target="_blank">dev.to</a>.</figcaption></figure><h1 id="53c0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">具有动态值绑定的静态查询</h1><p id="d0b5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果您的查询逻辑没有根据用户的输入而改变，那么只需使用<code class="fe mf mg mh mi b"><a class="ae kl" href="https://github.com/gajus/slonik#slonik-value-placeholders-tagged-template-literals" rel="noopener ugc nofollow" target="_blank">sql</a></code> <a class="ae kl" href="https://github.com/gajus/slonik#slonik-value-placeholders-tagged-template-literals" rel="noopener ugc nofollow" target="_blank">标记的模板文字</a>构造SQL查询，例如</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="20db" class="mn ld iq mi b gy mo mp l mq mr">sql`<br/>  SELECT c1.country_id<br/>  FROM cinema_movie_name cmn1<br/>  INNER JOIN cinema c1 ON c1.id = cmn1.cinema_id<br/>  WHERE cmn1.id = ${cinemaMovieNameId}<br/>`;</span></pre><p id="381f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用Slonik，将值作为模板文字占位符传递是安全的。<code class="fe mf mg mh mi b">sql</code>将解释所有占位符标记并构造最终的SQL查询。在这种情况下，查询的唯一动态部分是值绑定本身，因此最终查询是:</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="bc35" class="mn ld iq mi b gy mo mp l mq mr">SELECT c1.country_id<br/>FROM cinema_movie_name cmn1<br/>INNER JOIN cinema c1 ON c1.id = cmn1.cinema_id<br/>WHERE cmn1.id = $1</span></pre><p id="481b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查询和绑定值将被分别发送到PostgreSQL:没有SQL注入的风险。</p><h1 id="9f37" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">绑定值列表</h1><p id="d92b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当您的查询输入是一个值列表时(例如，当检索匹配多个标识符的行时)，那么您<em class="ms">可以</em>使用<code class="fe mf mg mh mi b">sql.valueList</code>，例如</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="3ec2" class="mn ld iq mi b gy mo mp l mq mr">sql`<br/>  SELECT m1.*<br/>  FROM movie m1<br/>  WHERE m1.id IN (${sql.valueList(movieIds)})<br/>`;</span></pre><p id="33db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将生成一个带有动态值绑定集的查询，即如果<code class="fe mf mg mh mi b">movieIds</code>是<code class="fe mf mg mh mi b">[1, 2, 3]</code>，发送到PostgreSQL的查询将是:</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="3561" class="mn ld iq mi b gy mo mp l mq mr">SELECT m1.*<br/>FROM movie m1<br/>WHERE m1.id IN ($1, $2, $3)</span></pre><p id="41ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，尽管这是一种常见的模式，我不建议使用这种模式。相反，使用<code class="fe mf mg mh mi b">sql.array</code>，例如</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="a888" class="mn ld iq mi b gy mo mp l mq mr">sql`<br/>  SELECT m1.*<br/>  FROM movie m1<br/>  WHERE m1.id = ANY(${sql.array(movieIds, 'int4')})<br/>`;</span></pre><p id="4aea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将生成固定长度的查询，该查询不会基于其输入而改变，即</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="6a5a" class="mn ld iq mi b gy mo mp l mq mr">SELECT m1.*<br/>FROM movie m1<br/>WHERE m1.id = ANY($1::"int4"[])</span></pre><p id="fa09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续阅读<code class="fe mf mg mh mi b"><a class="ae kl" href="https://github.com/gajus/slonik#sqlarray-vs-sqlvaluelist" rel="noopener ugc nofollow" target="_blank">sql.array</a></code> <a class="ae kl" href="https://github.com/gajus/slonik#sqlarray-vs-sqlvaluelist" rel="noopener ugc nofollow" target="_blank"> vs </a> <code class="fe mf mg mh mi b"><a class="ae kl" href="https://github.com/gajus/slonik#sqlarray-vs-sqlvaluelist" rel="noopener ugc nofollow" target="_blank">sql.valueList</a></code>。</p><h1 id="3504" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用动态列的查询</h1><p id="4712" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果您的查询结果引用了依赖于用户输入的列，那么使用<code class="fe mf mg mh mi b"><a class="ae kl" href="https://github.com/gajus/slonik#slonik-query-building-sql-identifier" rel="noopener ugc nofollow" target="_blank">sql.identifier</a></code>来生成标识这些列的SQL，例如</p><p id="1687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(注意:不是业务中使用的实际查询。见下一段。)</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="f427" class="mn ld iq mi b gy mo mp l mq mr">sql`<br/>  SELECT m1.id, ${sql.identifier(['m1', movieTableColumnName])}<br/>  FROM movie m1<br/>  WHERE<br/>    m1.id = ${moveId}<br/>`;</span></pre><p id="8914" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该查询将生成一个查询，该查询将恰好选择1个动态标识的列。不存在SQL注入的风险，也就是说，即使导致生成<code class="fe mf mg mh mi b">movieTableColumnName</code>的逻辑受到某种损害，最糟糕的情况是查询攻击者将能够返回<code class="fe mf mg mh mi b">m1</code>别名下的任何列，或者使用无效的列标识符值执行查询(这两种情况都有风险；业务逻辑不在本文讨论范围之内)。</p><p id="2407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是因为你能做到这一点，你可能不应该这样做。当您的应用程序需要根据用户的查询返回不同的列时，最好选择业务逻辑范围内的所有列，并选择所需列的值，即如果后一个查询的目的是基于<code class="fe mf mg mh mi b">movieTableColumnName</code>返回不同的电影标识符，那么最好编写一个静态查询:</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="7339" class="mn ld iq mi b gy mo mp l mq mr">sql`<br/>  SELECT<br/>    m1.id,<br/>    m1.foreign_comscore_id,<br/>    m1.foreign_imdb_id,<br/>    m1.foreign_metacritic_id<br/>    m1.foreign_rottentomatoes_id,<br/>    m1.foreign_tmdb_id,<br/>    m1.foreign_webedia_id<br/>  FROM movie m1<br/>  WHERE<br/>    m1.id = ${moveId}<br/>`;</span></pre><p id="aab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后者在每次查询时都会返回一些多余的数据，但是它有几个优点:</p><ol class=""><li id="f835" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">它降低了SQL注入的风险(不管您多么信任代码生成逻辑，静态代码总是比动态代码更安全)。</li><li id="eccc" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">它只生成一个条目<code class="fe mf mg mh mi b">pg_stat_statements</code>。随着应用程序的扩展，您将学会在<code class="fe mf mg mh mi b">pg_stat_statements</code>中尽可能少地使用查询。</li></ol><h1 id="409b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">具有多个动态列的查询</h1><p id="56b2" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">同上，不过<code class="fe mf mg mh mi b"><a class="ae kl" href="https://github.com/gajus/slonik#slonik-query-building-sql-identifierlist" rel="noopener ugc nofollow" target="_blank">sql.identifierList</a></code>。</p><h1 id="9c57" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">嵌套动态SQL查询</h1><p id="8a13" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mf mg mh mi b">sql</code>标记的模板文字可以嵌套，例如</p><p id="b189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(注:业务中使用的实际查询的简化版本。)</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="c503" class="mn ld iq mi b gy mo mp l mq mr">const futureEventEventChangeSqlToken = sql`<br/>  SELECT<br/>    ec1.event_id,<br/>    ec1.seat_count,<br/>    ec1.seat_sold_count<br/>  FROM event_change_future_event_view ec1<br/>`;</span><span id="19ed" class="mn ld iq mi b gy nh mp l mq mr">sql`<br/>  SELECT<br/>    event_id,<br/>    seat_count,<br/>    seat_sold_count<br/>  FROM (<br/>    ${futureEventEventChangeSqlToken}<br/>  ) AS haystack<br/>  WHERE ${paginatedWhereSqlToken}<br/>  ORDER BY ${orderSqlToken}<br/>  LIMIT ${limitSqlToken}<br/>`</span></pre><p id="5cd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许在您的程序中以一等公民的身份传递预先绑定的SQL查询。当目的是隔离SQL生成逻辑以进行测试时，或者当大型SQL片段在查询之间共享时，或者当目的是简单地减少代码复杂性集中在一个地方时，这是很方便的。</p><h1 id="880d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">注入动态SQL片段</h1><p id="f8a1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mf mg mh mi b">sql.raw</code>用于注入动态SQL片段，即</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="3790" class="mn ld iq mi b gy mo mp l mq mr">sql`<br/>  SELECT ${sql.raw('foo bar baz')}<br/>`</span></pre><p id="c977" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转换为(无效)查询:</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="68ab" class="mn ld iq mi b gy mo mp l mq mr">SELECT foo bar baz</span></pre><p id="1027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与前面使用<code class="fe mf mg mh mi b">sql</code>标记模板的例子不同，<code class="fe mf mg mh mi b">sql.raw</code>是不安全的——它允许使用用户输入创建动态SQL。</p><p id="a866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有已知的使用<code class="fe mf mg mh mi b">sql.raw</code>生成查询的用例未被嵌套绑定<code class="fe mf mg mh mi b">sql</code>表达式(在“嵌套动态SQL查询”中描述)或其他现有的<a class="ae kl" href="https://github.com/gajus/slonik#slonik-query-building" rel="noopener ugc nofollow" target="_blank">查询构建方法</a>覆盖。<code class="fe mf mg mh mi b">sql.raw</code>作为一种机制存在，用于执行外部存储的<em class="ms">静态</em>(例如存储在文件中的查询)。</p><h1 id="365b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用动态比较谓词成员或运算符进行查询</h1><p id="00b8" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果查询中出现的比较谓词的操作符是动态的，那么使用<code class="fe mf mg mh mi b"><a class="ae kl" href="https://github.com/gajus/slonik#slonik-query-building-sql-comparisonpredicate" rel="noopener ugc nofollow" target="_blank">sql.comparisonPredicate</a></code>，例如</p><p id="9cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(注意:不是业务中使用的实际查询。)</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="4f1d" class="mn ld iq mi b gy mo mp l mq mr">sql`<br/>  SELECT<br/>    c1.id,<br/>    c1.nid,<br/>    c1.name<br/>  FROM cinema c1<br/>  WHERE<br/>    ${sql.comparisonPredicate(<br/>      sql`c1.name`,<br/>      nameComparisonOperator,<br/>      nameComparisonValue<br/>    )}<br/>`;</span></pre><p id="6949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">nameComparisonOperator</code>可以是<code class="fe mf mg mh mi b">=</code>、<code class="fe mf mg mh mi b">&gt;</code>、<code class="fe mf mg mh mi b">&lt;</code>等值。假设<code class="fe mf mg mh mi b">nameComparisonOperator</code>是“=”，那么结果查询将是:</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="22a0" class="mn ld iq mi b gy mo mp l mq mr">SELECT<br/>  c1.id,<br/>  c1.nid,<br/>  c1.name<br/>FROM cinema c1<br/>WHERE<br/>  c1.name = $1</span></pre><p id="d74c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后者是极其罕见的用例，几乎完全用于构建更高级别的SQL抽象工具(比如ORM)。这可能对“高级搜索”场景有用，但请继续阅读以熟悉替代模式(见<code class="fe mf mg mh mi b">sql.booleanExpression</code>)。</p><h1 id="0b7c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">具有动态WHERE子句成员的查询</h1><p id="190a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果<code class="fe mf mg mh mi b">WHERE</code>子句成员的存在是动态的，那么使用<code class="fe mf mg mh mi b"><a class="ae kl" href="https://github.com/gajus/slonik#sqlbooleanexpression" rel="noopener ugc nofollow" target="_blank">sql.booleanExpression</a></code>。</p><pre class="kn ko kp kq gt mj mi mk ml aw mm bi"><span id="c1c1" class="mn ld iq mi b gy mo mp l mq mr">const findCinemas = (root, parameters, context) =&gt; {<br/>  const booleanExpressions = [<br/>    sql`TRUE`,<br/>  ];</span><span id="744d" class="mn ld iq mi b gy nh mp l mq mr">  if (parameters.input.query) {<br/>    const query = parameters.input.query;</span><span id="b89d" class="mn ld iq mi b gy nh mp l mq mr">    if (query.countryId !== undefined) {<br/>      booleanExpressions.push(<br/>        sql`c2.id = ${query.countryId}`<br/>      );<br/>    }</span><span id="ebd2" class="mn ld iq mi b gy nh mp l mq mr">    if (query.nid !== undefined) {<br/>      booleanExpressions.push(<br/>        sql`c1.nid % ${query.nid}`<br/>      );<br/>    }</span><span id="3692" class="mn ld iq mi b gy nh mp l mq mr">    if (query.name !== undefined) {<br/>      booleanExpressions.push(<br/>        sql`c1.name % ${query.name}`<br/>      );<br/>    }<br/>  }</span><span id="3526" class="mn ld iq mi b gy nh mp l mq mr">  const whereSqlToken = sql.booleanExpression(<br/>    booleanExpressions,<br/>    'AND'<br/>  );</span><span id="d0bf" class="mn ld iq mi b gy nh mp l mq mr">  return context.pool.any(sql`<br/>    SELECT<br/>      c1.id,<br/>      c1.nid,<br/>      c1.name,<br/>      c2.code_alpha_2 country_code,<br/>      c2.name country_name<br/>    FROM cinema c1<br/>    INNER JOIN country c2 ON c2.id = c1.country_id<br/>    WHERE ${whereSqlToken}<br/>  `);<br/>},</span></pre><p id="0923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">findCinemas</code>是一个GraphQL解析器的实现。查询的WHERE子句使用3个可能的布尔表达式的组合来构造。与Slonik中所有其他查询构建方法一样，所有表达式都可以嵌套:您可以将其他布尔表达式作为布尔表达式的成员，甚至可以使用<code class="fe mf mg mh mi b">sql</code>标记的模板文字构建SQL表达式。</p><h1 id="bfab" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="522d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这些例子涵盖了每一个常见的动态SQL构建场景，并提供了足够的Slonik如何工作的知识，使读者能够继续熟悉Slonik 提供的<a class="ae kl" href="https://github.com/gajus/slonik#slonik-query-building" rel="noopener ugc nofollow" target="_blank">其他查询构建方法。本文的主要目的是展示Slonik为构造SQL查询提供了一种安全的抽象，保持了查询的静态部分不变。</a></p><p id="96cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果我错过了您希望我涵盖的用例场景，请在评论中提及，我会很乐意包括它。</p></div></div>    
</body>
</html>