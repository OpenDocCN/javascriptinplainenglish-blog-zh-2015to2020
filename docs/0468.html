<html>
<head>
<title>Routing and Component level code splitting with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React进行路由和组件级代码拆分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/routing-and-component-level-code-splitting-with-react-5f2e4fc86532?source=collection_archive---------1-----------------------#2019-10-21">https://javascript.plainenglish.io/routing-and-component-level-code-splitting-with-react-5f2e4fc86532?source=collection_archive---------1-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/345446b61c8516bcc3f93341eed6cce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*t_NhNxY05FyYg9xUB8wHIw.jpeg"/></div></figure><p id="5f55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在进入React应用程序中对组件进行代码拆分的实际部分之前，让我们首先尝试理解什么是代码拆分，以及为什么我们应该在组件级别对应用程序进行代码拆分。</p><p id="ae74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">代码分割是一种基于事件延迟呈现组件的方法。例如，我们希望显示一个基于按钮点击的地图视图(这是一个组件)，并且每当我们点击按钮时，地图视图应该呈现。一般来说，如果我们不进行代码拆分，那么每当我们渲染父组件时，地图视图也会渲染，如果我们的应用程序增长，而我们没有对组件进行代码拆分，这会导致不必要的延迟。</p><p id="3b91" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了解决这个问题并优化React应用的性能，我们从路由器级别和组件级别对组件进行了代码拆分。</p><h1 id="912c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">1.路由器级代码拆分:</h1><p id="2aff" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">假设我们的应用程序中有一个路由级别:</p><p id="bf6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Home About <strong class="jw ir"> Settings- </strong>其中Settings是最重的路线，我们不应该在每次单击Home或About时渲染设置。设置应该在我们单击该路线时渲染，并在第一次单击时缓存，以便它不会在再次单击时重新渲染。下面的代码将演示我们应该如何在路由器级别进行代码拆分。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Code splitting at the Route Level</figcaption></figure><p id="6c02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是我们应该记住，路由器级别的代码分割是防止应用程序变慢的第一道防线。我们肯定应该遵循这种方法，但最重要的部分是组件级的代码拆分，以便在特定的路由中，需要有条件呈现的组件在路由加载时不会被加载。它应该只在通过点击按钮或任何事件满足条件时加载。因此，让我们看看我们应该如何在组件级别进行代码拆分，以在React应用程序中获得最佳性能。</p><h1 id="561a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">组件级代码拆分:</h1><p id="14ce" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">下面的代码演示了如何有条件地呈现一个模态视图，并在动态导入的帮助下，基于按钮点击来呈现它。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Component Level Code Splitting</figcaption></figure><p id="4cd1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当应用程序加载时，模态组件不会呈现。从下面的network选项卡中可以看到，只生成了一个chunk.js文件。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/9873b0c83838796735195c43eb2c2cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91MJyeeThTbwItr0jrj-wA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">App Component loads without loading the Modal Component</figcaption></figure><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mk"><img src="../Images/dd14153bc2470df5dc946d3ba2924813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8k_TLFssjGrKYqY-7Sjlg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Clicking on button 2.chunk.js i.e Modal component renders</figcaption></figure><blockquote class="ml mm mn"><p id="79e7" class="ju jv mo jw b jx jy jz ka kb kc kd ke mp kg kh ki mq kk kl km mr ko kp kq kr ij bi translated">现在让我们看看如何对模态分量进行代码拆分:</p></blockquote><p id="5f5f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们在初始状态下将模态的状态保持为空。然后，在点击按钮时，我们将进行动态导入(【https://javascript.info/modules-dynamic-imports】T2)，只有当按钮被点击时，我们才会导入Modal.js，而不是在组件渲染上，或者作为普通导入，我们在组件顶部导入所有元素。</p><pre class="lv lw lx ly gt mt mu mv mw aw mx bi"><span id="28b9" class="my kt iq mu b gy mz na l nb nc">showLocation = () =&gt; {    <br/>import('./components/Modal')      <br/>.then((mod) =&gt; this.setState(() =&gt; ({        <br/>  modal: mod.default      <br/>})))}</span></pre><p id="d5f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里，我们导入modal.js文件，该文件返回一个承诺，在响应中，我们更新状态，该状态接受一个回调函数并将Modal值设置为mod.default，因为Modal组件是默认导出。</p><p id="21bf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在JSX，我们将像这样渲染组件:</p><pre class="lv lw lx ly gt mt mu mv mw aw mx bi"><span id="9351" class="my kt iq mu b gy mz na l nb nc">render() {     <br/>const { modal: Modal } = this.state;     <br/>return (      <br/>&lt;&gt;      <br/>&lt;div&gt;Testing Code Splitting or Lazy loading of components&lt;/div&gt;      &lt;br&gt;&lt;/br&gt;        <br/>{Modal !== null ?          <br/>&lt;Modal /&gt;          <br/>:          <br/>&lt;button onClick={this.showLocation}&gt;            <br/>Show Modal          <br/>&lt;/button&gt;        <br/>}      <br/>&lt;/&gt;    <br/>)}</span></pre><p id="9320" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当模态为<strong class="jw ir">不等于null </strong> (initialState)时，当我们单击按钮并更新其状态时，我们应该呈现模态。或者我们应该呈现按钮。</p><p id="8f6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢阅读！如果你有任何问题，请随时联系rajrock38@gmail.com，通过<a class="ae ms" href="https://www.linkedin.com/in/rajdeepcoder/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我，或者通过<a class="ae ms" href="https://medium.com/@rajrock38" rel="noopener"> Medium </a>和<a class="ae ms" href="https://twitter.com/rajrock38" rel="noopener ugc nofollow" target="_blank"> Twitter </a>关注我。</p><p id="5c5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你觉得这篇文章很有帮助，给它一些掌声会很有意义👏并分享出来帮别人找！并欢迎在下方发表评论。</p></div></div>    
</body>
</html>