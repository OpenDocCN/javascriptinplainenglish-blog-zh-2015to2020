<html>
<head>
<title>Node.js Tips — REPL Tips, Socket.io Connections, and Event Listeners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js Tips — REPL技巧、Socket.io连接和事件侦听器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-repl-tips-socket-io-connections-and-event-listenrs-dadeaa2538d2?source=collection_archive---------6-----------------------#2020-07-20">https://javascript.plainenglish.io/node-js-tips-repl-tips-socket-io-connections-and-event-listenrs-dadeaa2538d2?source=collection_archive---------6-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06881de7c280c2b94e990eb907090ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WiHWK9SFb4bCf98d"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@noqas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ana Silva</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究编写节点应用程序时常见问题的一些解决方案。</p><h1 id="1d05" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">删除Node.js事件发射器中的事件侦听器</h1><p id="086c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">removeListener</code>方法移除带有节点事件发射器的侦听器。</p><p id="e48f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9ff4" class="mq lc iq mh b gy mr ms l mt mu">const events = require('events');<br/>const EventEmitter = events.EventEmitter;<br/>const rr = new EventEmitter();<br/>const refreshHandler = () =&gt; {<br/>  console.log('refresh');<br/>}<br/>rr.on("refresh", refreshHandler);<br/>rr.removeListener("refresh", refreshHandler);</span></pre><p id="6dda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了我们的<code class="fe me mf mg mh b">EventEmitter</code>实例。</p><p id="0114" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">refreshHandler</code>事件监听器附加到<code class="fe me mf mg mh b">refresh</code>事件。</p><p id="fab9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不再需要收听<code class="fe me mf mg mh b">refresh</code>事件，那么我们可以调用<code class="fe me mf mg mh b">removeListener</code>将事件收听者从记忆中清除。</p><p id="30cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入事件名称作为<code class="fe me mf mg mh b">removeListener</code>的第一个参数。</p><p id="62c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是我们要移除的事件处理程序。</p><h1 id="4c8c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">node . js . REPL中“_”(下划线)符号的含义</h1><p id="270b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">_</code>符号返回REPL中最后一个记录表达式的结果，</p><p id="3e33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们键入:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6985" class="mq lc iq mh b gy mr ms l mt mu">&gt; 2 * 3<br/>6</span></pre><p id="083d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">_</code>返回6:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0a3" class="mq lc iq mh b gy mr ms l mt mu">&gt; _<br/>6</span></pre><h1 id="2b4e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js中执行回调函数的访问变量</h1><p id="fd1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">exec</code>接受一个回调函数，其结果是运行一个shell命令。</p><p id="7788" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c1e3" class="mq lc iq mh b gy mr ms l mt mu">const execChild = (callback) =&gt; {<br/>  const child = exec(cmd, (error, stdout, stderr) =&gt; {<br/>    callback(stdout);<br/>  });<br/>}</span></pre><p id="e54e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从回调中得到<code class="fe me mf mg mh b">stdout</code>，回调中有我们的<code class="fe me mf mg mh b">cmd</code>命令的结果。</p><p id="0006" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">callback</code>来获得<code class="fe me mf mg mh b">exec</code>回调之外的结果。</p><p id="be2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须这样做，因为<code class="fe me mf mg mh b">exec</code>是异步的，所以我们不知道什么时候会得到结果。</p><p id="00a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以通过书写来使用<code class="fe me mf mg mh b">execChild</code>功能:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0646" class="mq lc iq mh b gy mr ms l mt mu">execChild((result) =&gt; console.log(result));</span></pre><p id="f3ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们进入<code class="fe me mf mg mh b">callback</code>的<code class="fe me mf mg mh b">stdout</code>将是<code class="fe me mf mg mh b">result</code>。</p><h1 id="6dde" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">socket . io—侦听连接事件</h1><p id="f238" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以监听服务器端的连接。</p><p id="d792" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从客户端建立连接。</p><p id="0b90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在服务器端代码中，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4172" class="mq lc iq mh b gy mr ms l mt mu">const io = require('socket.io').listen(8001);<br/>io.sockets.on('connection', (socket) =&gt; {<br/>  console.log('user connected');<br/>});</span></pre><p id="8526" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收听<code class="fe me mf mg mh b">connection</code>事件，如果我们调用<code class="fe me mf mg mh b">io.connect</code>，该事件将从客户端发出。</p><p id="7b3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的客户端代码中，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bb6c" class="mq lc iq mh b gy mr ms l mt mu">const socket = io.connect('http://localhost:8001');</span></pre><p id="8e35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接到我们创建的服务器。</p><h1 id="17f6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取Node.js中的完整文件路径</h1><p id="5eef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过<code class="fe me mf mg mh b">__dirname</code>获取当前目录的完整路径。</p><p id="f873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后w可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2921" class="mq lc iq mh b gy mr ms l mt mu">const path = require("path");<br/>const fileName = "file.txt";<br/>const fullPath = path.join(__dirname, "/uploads/", fileName);</span></pre><p id="fde9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">path.join</code>以平台无关的方式将所有路径段连接在一起。</p><p id="dfef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">path.resolve</code>方法返回文件的完整路径。</p><p id="c83e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ae0a" class="mq lc iq mh b gy mr ms l mt mu">const path = require("path");<br/>const fullPath = path.resolve("./uploads/file.csv");</span></pre><p id="3f2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用相对路径调用<code class="fe me mf mg mh b">resolve</code>来获取文件的完整路径。</p><h1 id="e205" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Express获取客户的IP</h1><p id="3a1c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们正在编写一个Express应用程序，那么我们可以使用<code class="fe me mf mg mh b">req.ip</code>来获取客户端的IP地址。</p><p id="5ed4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过编写以下内容来获得<code class="fe me mf mg mh b">x-forward-for</code>头的值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a189" class="mq lc iq mh b gy mr ms l mt mu">req.headers['x-forwarded-for']</span></pre><p id="b711" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来获取报头的值，其中包含IP地址。</p><p id="c223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以检查<code class="fe me mf mg mh b">req.connection.remoteAddress</code>来做同样的事情。</p><h1 id="a03f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">连接到插座。具有特定路径和名称空间的Io服务器</h1><p id="bb52" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过使用<code class="fe me mf mg mh b">of</code>方法和<code class="fe me mf mg mh b">path</code>属性，我们可以连接到具有特定路径和名称空间的socket.io服务器。</p><p id="553a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d448" class="mq lc iq mh b gy mr ms l mt mu">const io = require('socket.io')(http, {<br/>  path: '/foo/bar'<br/>});</span><span id="531e" class="mq lc iq mh b gy mv ms l mt mu">io<br/>  .of('/namespace')<br/>  .on('connection', (socket) =&gt; {<br/>    socket.on('message', (data) =&gt; {<br/>      io.of('namespace').emit('message', data);<br/>    });<br/>  });</span></pre><p id="f93a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">http</code>服务器实例传递给<code class="fe me mf mg mh b">socket.io</code>函数。</p><p id="3b4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数让我们用<code class="fe me mf mg mh b">path</code>属性指定路径。</p><p id="b7da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">io.of</code>方法中，我们指定名称空间。</p><p id="d996" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">on</code>方法让我们观察来自客户端的连接。</p><p id="b5b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">socket.on</code>监听来自客户端的事件。</p><p id="b7ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是事件名称。</p><p id="c217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是一个回调，它包含随事件发出的数据。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/6069917af20f01d6a4009a6c022c2b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h2aLqWA6I4bmJQbs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@agmakonts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adam Grabek</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a118" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d292" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">removeListener</code>来清除事件监听器。</p><p id="1aaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用socket.io连接到特定的路径和名称空间。</p><p id="0e9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用Node很容易获得各种文件和网络信息。</p><p id="a017" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">_</code>来获取节点REPL中返回的最后一个结果。</p><h1 id="172b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="03de" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>