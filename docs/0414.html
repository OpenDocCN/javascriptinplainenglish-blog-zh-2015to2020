<html>
<head>
<title>How scope chain is determined in JavaScript ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中作用域链是如何确定的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-scope-chain-is-determined-in-javascript-b180eceae002?source=collection_archive---------1-----------------------#2019-10-10">https://javascript.plainenglish.io/how-scope-chain-is-determined-in-javascript-b180eceae002?source=collection_archive---------1-----------------------#2019-10-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d915cc06fdcc45e4a4a04fab7be6b4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COpjkfCCL_lyxK2avuX7cQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Picture credits <a class="ae jz" href="https://unsplash.com/photos/PDxYfXVlK2M" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="ka kb kc"><p id="376c" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">这篇文章是我上一篇文章<a class="ae jz" href="https://medium.com/javascript-in-plain-english/javascript-parsing-and-code-execution-f92a08498ec1" rel="noopener">JavaScript代码执行</a>的续篇。<br/>从上一篇文章中，我们知道执行上下文有两个阶段。创建和执行阶段。创建阶段由三个重要步骤完成。首先是可变对象的形成，其次是作用域链，最后是确定和设置。</p></blockquote><p id="0c02" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">为了理解作用域链，我们应该首先定义什么是作用域？</p><figure class="lf lg lh li gt jo"><div class="bz fp l di"><div class="lj lk l"/></div></figure><blockquote class="ka kb kc"><p id="90b7" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated"><strong class="kg io">范围:</strong> <br/>当前执行的上下文。值和<strong class="kg io">表达式</strong>是“可见的”或者可以被引用的上下文。如果一个<strong class="kg io">变量</strong>或其他表达式不“在当前范围内”，那么它就不可用。作用域也可以在层次结构中分层，以便子作用域可以访问父作用域，但反之则不行。— <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="43c0" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">如果我们试图用简单的话来打破上面的定义，它的意思是，作用域是变量和表达式的访问区域。在ES6之前，我们只有一种方法在JavaScript中创建作用域，那就是创建一个名为functional scope的新函数，另一种是global scope。随着ES6标准的引入，语言中引入了块级范围。我们将简要介绍每一项，然后是示例。这种理解有助于我们进一步理解JavaScript中的作用域链是如何工作的。<br/> <strong class="kg io">全局作用域:<br/> </strong>全局作用域是包含所有其他作用域并在其中可见的作用域。<br/> <strong class="kg io">局部作用域:<br/> </strong>局部作用域是变量的一个特征，使它们成为局部的(即变量名只绑定到它在一个不是<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Glossary/global_scope" rel="noopener ugc nofollow" target="_blank">全局作用域</a>的作用域内的值)。<br/> <strong class="kg io">块范围:</strong> <br/>一个<strong class="kg io">块语句</strong>(或其他语言中的<strong class="kg io">复合语句</strong>)用于分组零个或多个语句。该块由一对花括号分隔，可以选择为<code class="fe ll lm ln lo b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label" rel="noopener ugc nofollow" target="_blank">labelled</a></code> : <br/>让我们看一个解释上述概念的例子。</p><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="80d8" class="lt lu in lo b gy lv lw l lx ly">Using ES5...</span><span id="dcb7" class="lt lu in lo b gy lz lw l lx ly">// Global Scope.<br/><em class="kf">var</em> globalVar = 'Hello';<br/>localFunction1();<br/><em class="kf">function</em> localFunction1() {<br/>  // Local Scope for localFunction1.</span><span id="bd35" class="lt lu in lo b gy lz lw l lx ly"><em class="kf">  var</em> localVarFunction1_1 = 'JavaScript';<br/>  <em class="kf">var</em> localVarFunction1_2 = 'I am new to scope chain';<br/>  localFunction2();<br/>  <em class="kf">function</em> localFunction2() {<br/>  // Local Scope for localFunction2.</span><span id="8034" class="lt lu in lo b gy lz lw l lx ly"><em class="kf">  var</em> localVarFunction2_1 = 'local to function 2';<br/>  localFunction3();<br/>  <em class="kf">function</em> localFunction3() {<br/>   // Local Scope for localFunction2. <br/>  <br/>   <em class="kf">var</em> localVarFunction3_1 = 'local to function 3';<br/>   console.log('Output:')<br/>   console.log(`${globalVar} ${localVarFunction1_1}`); <br/>   console.log(localVarFunction1_2);<br/>   console.log(localVarFunction2_1);<br/>   console.log(localVarFunction3_1);<br/>  }<br/> }<br/>}<br/>Output:<br/>Hello JavaScript<br/>I am new to scope chain<br/>local to function 2<br/>local to function 3</span><span id="a3d3" class="lt lu in lo b gy lz lw l lx ly">Using ES6..</span><span id="b4c1" class="lt lu in lo b gy lz lw l lx ly">// Global Scope.<br/><em class="kf">let</em> globalVar = 'Hello';<br/>localFunction1();<br/><em class="kf">function</em> localFunction1() {<br/>  // Local Scope for localFunction1.</span><span id="c1de" class="lt lu in lo b gy lz lw l lx ly"><em class="kf">  let</em> localVarFunction1_1 = 'JavaScript';<br/>  <em class="kf">const</em> localVarFunction1_2 = 'I am new to scope chain';<br/>  localFunction2();<br/>  <em class="kf">function</em> localFunction2() {<br/>   // Local Scope for localFunction2.</span><span id="2d81" class="lt lu in lo b gy lz lw l lx ly"><em class="kf">   let</em> localVarFunction2_1 = 'local to function 2';<br/>   localFunction3();<br/>   <em class="kf">function</em> localFunction3() {<br/>     // Local Scope for localFunction2. <br/>  <br/>     <em class="kf">var</em> localVarFunction3_1 = 'local to function 3';<br/>     console.log('Output:')<br/>     console.log(`${globalVar} ${localVarFunction1_1}`); <br/>     console.log(localVarFunction1_2);<br/>     console.log(localVarFunction2_1);<br/>     console.log(localVarFunction3_1);<br/>     {<br/>       // Local to the block<br/>       <em class="kf">let</em> blockVarFunction3_1 = 'Local to block';<br/>       console.log(blockVarFunction3_1);<br/>     }<br/>     console.log(blockVarFunction3_1);<br/>   }<br/> }<br/>}</span><span id="762d" class="lt lu in lo b gy lz lw l lx ly">Output:<br/>Hello JavaScript<br/>I am new to scope chain<br/>local to function 2<br/>local to function 3<br/>Local to block<br/>ReferenceError: blockVarFunction3_1 is not defined</span></pre><p id="595b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">现在，这里的问题是"<strong class="kg io"> localFunction3 </strong>"如何能够访问和打印没有在函数作用域中定义的变量的值，因为正如我们在上面的定义中看到的，存在全局作用域和局部作用域，其中前者随处可见，而后者对负责创建它的函数可见。这个问题的答案是“<strong class="kg io">作用域链</strong>，它被定义为当前变量对象(VO) +所有父词法变量对象的集合。运行代码时，JavaScript引擎会尝试在当前范围内查找变量，如果找到变量，就会在变量对象中创建一个条目，并使用该变量对象定义范围链。如果变量没有在当前作用域中定义，它会继续尝试在父函数作用域中查找变量定义。这个过程一直持续到遍历过程到达全局范围，只有当变量不在这个链中的任何位置时，javaScript引擎才会抛出一个错误并停止执行。需要记住的重要一点是，作用域链只能自下而上工作，而不能反过来。下图显示了流向，其中红色箭头表示方向。</p><figure class="lf lg lh li gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/51800e48fe9d3c6b0fc8c00691b6c966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGfmo21OoOTPAg0KAxU5GA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd mb">Scope chain representation.</strong></figcaption></figure><p id="cec5" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这里我们可以看到<strong class="kg io">“local function 3”</strong>的作用域链是[VO _ local _ 2]+[VO _ local _ 1]+[VO _ Global]。<br/> <strong class="kg io">注意:</strong> VO_local#是属于特定函数的变量对象，VO_Global代表全局变量对象。此外，我们在javaScript中有词法作用域，词法意味着代码中写了什么。词法范围被定义为一个函数在词法上位于另一个函数内，并且可以访问父(外部)函数的范围。因此，我们已经看到了范围链是如何确定的，但是有一件重要的事情需要记住，即范围链和执行上下文的不同之处。让我们看一个例子来说明区别在哪里。</p><pre class="lf lg lh li gt lp lo lq lr aw ls bi"><span id="82bc" class="lt lu in lo b gy lv lw l lx ly"><em class="kf">let</em> globalVar = 'Hello';<br/>localFunction1();<br/><em class="kf">function</em> localFunction1() {<br/>  <em class="kf">let</em> localVarFunction1_1 = 'JavaScript';<br/>  <em class="kf">let</em> localVarFunction1_2 = 'I am new to scope chain';<br/>  localFunction2();<br/>  <br/>  <em class="kf">function</em> localFunction2() {<br/>   <em class="kf">let</em> localVarFunction2_1 = 'local to function 2';<br/>   localFunction3();<br/>  }</span><span id="f547" class="lt lu in lo b gy lz lw l lx ly"><em class="kf">  function</em> localFunction3() {<br/>    <em class="kf">let</em> localVarFunction3_1 = 'local to function 3';<br/>    console.log('Output:')<br/>    console.log(`${globalVar} ${localVarFunction1_1}`);<br/>    console.log(localVarFunction1_2);<br/>    console.log(localVarFunction2_1);<br/>    console.log(localVarFunction3_1);</span><span id="6dc7" class="lt lu in lo b gy lz lw l lx ly">  }<br/>}</span><span id="cb80" class="lt lu in lo b gy lz lw l lx ly">Output:<br/>Hello JavaScript<br/>I am new to scope chain<br/>ReferenceError: localVarFunction2_1 is not defined</span></pre><p id="f39e" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">尽管在localFunction2中调用了函数localFunction3，但为什么我们会得到localVarFunction2_1的错误。这是因为上下文堆栈的工作方式不同于作用域链。在上面的示例中，调用了localFunction1，它调用了localFunction2，而localFunction3又调用了localFunction3，对于这些调用中的每一个，新的执行堆栈都放在执行堆栈的顶部，而对于作用域链来说，情况略有不同，全局作用域包含globalVar和localFunction1，然后localFunction1的作用域包含localFunction2和local function 3以及变量定义。执行上下文是函数被调用的顺序，但是作用域链是函数在代码中的编写顺序，也就是它们在代码中的词汇顺序。所以函数被调用的顺序并不决定这些函数中变量的范围。决定变量范围的是函数的编写位置。</p><p id="d446" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">如果你觉得这篇文章很有帮助并且喜欢它，请随意与你的朋友和同事分享。</p><p id="1a5a" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">你有任何问题、建议或想要联系我吗？在LinkedIN 上给我留言或在下面评论。</p><p id="5a1f" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我也可以在推特上通过@zargarmuneer90找到我。</p><div class="mc md gp gr me mf"><a href="http://davidshariff.com/blog/javascript-scope-chain-and-closures/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">JavaScript作用域链中的标识符解析和闭包</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">从我以前的帖子中，我们现在知道每个函数都有一个相关的执行上下文，其中包含一个变量…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">davidshariff.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jt mf"/></div></div></a></div></div></div>    
</body>
</html>