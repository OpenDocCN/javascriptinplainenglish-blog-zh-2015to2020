<html>
<head>
<title>Create a Full Stack Banking Application using React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React创建全栈银行应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-fullstack-banking-application-using-react-e8c96d74cd39?source=collection_archive---------0-----------------------#2020-06-08">https://javascript.plainenglish.io/create-a-fullstack-banking-application-using-react-e8c96d74cd39?source=collection_archive---------0-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:使用PostgreSQL、Express、React和Node.js堆栈创建应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2dd01b3be9fe7813b1077d757ed3bac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vMAPySZ0x7v0qzOJ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@burst?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Burst</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f01e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用PostgreSQL、Express、React和Node.js创建一个银行应用程序。</p><p id="2097" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过构建这个应用程序，您将了解到</p><p id="9b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.如何从Node.js <br/> 2使用PostgreSQL数据库？如何使用JWT认证来保护你的API？如何保持登录会话，直到用户手动注销<br/> 4。如何从Node.js中执行PostgreSQL中的CRUD操作<br/> 5。如何动态生成pdf以获取所选日期范围内的交易列表<br/> 6。如何自动下载任何类型的文件，包括pdf文件。<br/>还有更多。</p><p id="8513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是多部分系列的第一部分。让我们从第一部分开始。</p><h2 id="8837" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">我们开始吧</h2><p id="6909" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">使用<code class="fe mr ms mt mu b">create-react-app</code>创建一个新项目</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="4ef2" class="lt lu iq mu b gy mz na l nb nc">create-react-app fullstack-banking-app</span></pre><p id="a5ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">项目创建完成后，删除<code class="fe mr ms mt mu b">src</code>文件夹中的所有文件，并在<code class="fe mr ms mt mu b">src</code>文件夹中创建<code class="fe mr ms mt mu b">index.js</code>文件。同时在<code class="fe mr ms mt mu b">src</code>文件夹中创建<code class="fe mr ms mt mu b">actions</code>、<code class="fe mr ms mt mu b">components,</code>、<code class="fe mr ms mt mu b">css</code>、<code class="fe mr ms mt mu b">reducers</code>、<code class="fe mr ms mt mu b">router</code>、<code class="fe mr ms mt mu b">store</code>和<code class="fe mr ms mt mu b">utils</code>文件夹。</p><p id="3b32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装必要的依赖项</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="06f9" class="lt lu iq mu b gy mz na l nb nc">yarn add axios@0.19.2 bootstrap@4.4.1 history@4.10.1 jwt-decode@2.2.0 lodash@4.17.15 moment@2.25.3 node-sass@4.14.1 react-bootstrap@1.0.1 react-redux@7.2.0 react-router-dom@5.1.2 redux@4.0.5 redux-thunk@2.3.0</span></pre><p id="4dd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下代码在<code class="fe mr ms mt mu b">components</code>文件夹中创建一个新文件<code class="fe mr ms mt mu b">Login.js</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">utils</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">constants.js</code>，内容如下</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="3caf" class="lt lu iq mu b gy mz na l nb nc">export const SIGN_IN = 'SIGN_IN';<br/>export const SIGN_OUT = 'SIGN_OUT';</span></pre><p id="5c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">reducers</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">auth.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8fe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">store</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">store.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bd79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们已经创建了一个redux存储，目前只有一个身份验证缩减器。我们还为redux dev工具添加了配置，以查看调度的实时操作。要了解如何配置它，请单击此处的<a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-integrate-redux-thunk-into-your-react-application-cd92b87c1629#7120" rel="noopener"/></p><p id="aed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">router</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">AppRouter.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b8d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">css</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">main.scss</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src</code>文件夹中创建一个新文件<code class="fe mr ms mt mu b">index.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9056" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以通过执行<code class="fe mr ms mt mu b">yarn start</code>命令来运行应用程序，并验证是否显示了<code class="fe mr ms mt mu b">Login</code>组件。</p><p id="bdb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">utils</code>文件夹下创建一个新文件<code class="fe mr ms mt mu b">common.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9d6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，用以下内容更新<code class="fe mr ms mt mu b">Login.js</code>组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6d3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">components</code>文件夹中创建一个新文件<code class="fe mr ms mt mu b">Register.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f8ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">Login</code>和<code class="fe mr ms mt mu b">Register</code>组件中，我们只是显示了一个表单，并添加了验证来检查是否输入了所有数据。</p><p id="d0c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您检查应用程序，您会看到显示登录和注册表单，并且当我们不输入任何数据时，还会显示一条错误消息</p><div class="kg kh ki kj gt ab cb"><figure class="nf kk ng nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/e5309772921787a357f7c0c23d3d3cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*WfH4JBk62Imm_xQT5QjxSg.png"/></div></figure><figure class="nf kk ng nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/584ea8330839ea7fb0465ef9de3a6c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-Irwz0cqLSbejrzCU7-H0g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk nl di nm nn">Login and Register Page</figcaption></figure></div><p id="ef64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用Nodejs创建一个后端来处理登录功能。</p><p id="6bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src</code>文件夹旁边创建一个新的<code class="fe mr ms mt mu b">server</code>文件夹。因此您的项目现在将包含四个文件夹，即<code class="fe mr ms mt mu b">node_modules</code>、<code class="fe mr ms mt mu b">public</code>、<code class="fe mr ms mt mu b">server</code>和<code class="fe mr ms mt mu b">src</code>。</p><p id="8dff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从终端的<code class="fe mr ms mt mu b">server</code>文件夹中执行以下命令</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="aa03" class="lt lu iq mu b gy mz na l nb nc">yarn init -y</span></pre><p id="6b0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在<code class="fe mr ms mt mu b">server</code>文件夹中创建一个新的<code class="fe mr ms mt mu b">package.json</code>文件</p><p id="9517" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在<code class="fe mr ms mt mu b">server</code>文件夹中创建<code class="fe mr ms mt mu b">db</code>、<code class="fe mr ms mt mu b">middleware</code>、<code class="fe mr ms mt mu b">routes</code>、<code class="fe mr ms mt mu b">utils</code>和<code class="fe mr ms mt mu b">views</code>文件夹。同样，在<code class="fe mr ms mt mu b">server</code>文件夹中创建<code class="fe mr ms mt mu b">index.js</code></p><p id="fdc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，从<code class="fe mr ms mt mu b">server</code>文件夹中安装npm包</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="41d3" class="lt lu iq mu b gy mz na l nb nc">yarn add axios@0.19.2 bcryptjs@2.4.3 cors@2.8.5 dotenv@8.2.0 express@4.17.1 jsonwebtoken@8.5.1 moment@2.25.3 pg@8.0.3 nodemon@2.0.4</span></pre><p id="075c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">server/db</code>文件夹中，新建一个文件<code class="fe mr ms mt mu b">connect.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="87fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在connect.js文件中提供您的<code class="fe mr ms mt mu b">postgresql</code>数据库连接细节。</p><p id="d127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">server</code>文件夹下创建一个新文件<code class="fe mr ms mt mu b">scripts.sql</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">PostgreSQL Database scripts</figcaption></figure><p id="e145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">连接到PostgreSQL数据库，复制并粘贴来自<code class="fe mr ms mt mu b">scripts.sql</code>的命令，以创建数据库和表。</p><p id="4c52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">utils</code>文件夹中，新建一个文件<code class="fe mr ms mt mu b">common.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">server/middleware</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">auth.js</code>，添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">routes</code>文件夹中，添加<code class="fe mr ms mt mu b">auth.js</code>，代码如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">server</code>文件夹中新建一个<code class="fe mr ms mt mu b">.env</code>文件，内容如下</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="57a1" class="lt lu iq mu b gy mz na l nb nc">secret=ThisIsMySecretKey</span></pre><p id="74c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建一个express服务器。在<code class="fe mr ms mt mu b">server/index.js</code>文件中添加以下代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="585d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">package.json</code>中添加一个新的<code class="fe mr ms mt mu b">start</code>脚本</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="429d" class="lt lu iq mu b gy mz na l nb nc">"scripts": {<br/> "start": "nodemon index.js"<br/>}</span></pre><p id="536c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来理解来自<code class="fe mr ms mt mu b">routes/auth.js</code>的代码</p><p id="7aa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了查询PostgreSQL数据库，我们使用了一个连接池来处理多个查询并提供更快的响应。</p><p id="873e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe mr ms mt mu b">db/connect.js</code>中创建了池对象，我们在<code class="fe mr ms mt mu b">auth.js</code>中将其导入为</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="c321" class="lt lu iq mu b gy mz na l nb nc">const { pool } = require('../db/connect');</span></pre><p id="c9cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，在<code class="fe mr ms mt mu b">auth.js</code>内的<code class="fe mr ms mt mu b">/signup</code>路径中，我们首先检查到达API的数据是否包含使用<code class="fe mr ms mt mu b">common.js</code>中定义的<code class="fe mr ms mt mu b">isInvalidField</code>函数注册所需的字段</p><p id="e54c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从客户端发送的数据将在<code class="fe mr ms mt mu b">req.body</code>对象中可用，我们将它作为JSON获取，因为我们在<code class="fe mr ms mt mu b">index.js</code>中添加了<code class="fe mr ms mt mu b">app.use(express.json())</code></p><p id="33f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们当前和未来的所有路由都将在<code class="fe mr ms mt mu b">req.body</code>对象中以JSON的形式接收数据。</p><p id="2d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看下面来自<code class="fe mr ms mt mu b">utils/common.js</code>的代码</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="e687" class="lt lu iq mu b gy mz na l nb nc">const isInvalidField = (receivedFields, validFieldsToUpdate) =&gt; {<br/>  return receivedFields.some(<br/>    (field) =&gt; validFieldsToUpdate.indexOf(field) === -1<br/>  );<br/>};</span></pre><p id="c21d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将确保在插入时，我们不会试图添加一些导致错误的无效字段。因此，如果有一些无效的字段需要插入，我们会返回一个错误</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="0374" class="lt lu iq mu b gy mz na l nb nc">const isInvalidFieldProvided = isInvalidField(<br/>  receivedFields,<br/>  validFieldsToUpdate<br/>);</span><span id="6004" class="lt lu iq mu b gy no na l nb nc">if (isInvalidFieldProvided) {<br/>  return res.status(400).send({<br/>    signup_error: 'Invalid field.'<br/>  });<br/>}</span></pre><p id="4445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们查询数据库，检查数据库中是否不存在具有相同电子邮件的用户。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="9992" class="lt lu iq mu b gy mz na l nb nc">const result = await pool.query(<br/>  'select count(*) as count from bank_user where email=$1',<br/>  [email]<br/>);</span></pre><p id="365a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用异步await语法，而不是promises语法。因为我们已经为<code class="fe mr ms mt mu b">/signup</code> route函数添加了<code class="fe mr ms mt mu b">async</code>关键字，所以我们使用<code class="fe mr ms mt mu b">await</code>关键字进行查询。</p><p id="fa57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果变量将包含一些额外的数据。我们感兴趣的数据总是来自<code class="fe mr ms mt mu b">result</code>的<code class="fe mr ms mt mu b">rows</code>属性。因为只有一个计数，所以我们将其访问为</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="28a2" class="lt lu iq mu b gy mz na l nb nc">const count = result.rows[0].count;</span></pre><p id="942b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果计数大于零，这意味着已经有另一个用户使用相同的电子邮件，所以我们发回错误</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="0f65" class="lt lu iq mu b gy mz na l nb nc">const count = result.rows[0].count;<br/>if (count &gt; 0) {<br/>  return res.status(400).send({<br/>    signup_error: 'User with this email address already exists.'<br/>  });<br/>}</span></pre><p id="03a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们在这里添加了一个return关键字，所以下面几行代码将不会被执行。由于没有return关键字，即使响应被发送到客户端，接下来的代码行将被执行，从而导致错误。</p><p id="8a8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果计数为零，那么我们可以在表中插入用户详细信息。</p><p id="e897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在将用户详细信息添加到数据库之前，我们首先需要加密密码。我们使用<code class="fe mr ms mt mu b">bcryptjs</code>库创建安全密码。要了解它是如何工作的，请在这里查看我之前的文章<a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-create-a-strong-and-secure-password-in-nodejs-which-cannot-be-decrypted-24d046b24958" rel="noopener"/></p><p id="241a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用下面的代码来生成密码。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="7704" class="lt lu iq mu b gy mz na l nb nc">const hashedPassword = await bcrypt.hash(password, 8);</span></pre><p id="45c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，使用<code class="fe mr ms mt mu b">pg</code> npm包，允许我们在数据库中执行查询时编写查询。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="794e" class="lt lu iq mu b gy mz na l nb nc">await pool.query(<br/>  'insert into bank_user(first_name, last_name, email, password) values($1,$2,$3,$4)',<br/>  [first_name, last_name, email, hashedPassword]<br/>);</span></pre><p id="5912" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们通过分配<code class="fe mr ms mt mu b">$count</code>变量来提供动态值</p><p id="82c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此1美元将被<code class="fe mr ms mt mu b">first_name</code>取代，2美元将被<code class="fe mr ms mt mu b">last_name</code>取代，以此类推。使用$而不是直接使用值将防止SQL注入攻击，所以总是建议使用$进行攻击。</p><p id="9600" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要注意，因为我们已经在try块中添加了整个代码，所以如果在执行查询时发生错误，try块中的下一个代码将被跳过，catch块将被执行，并且我们将错误发送回客户端。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="6e62" class="lt lu iq mu b gy mz na l nb nc">res.status(400).send({<br/>  signup_error: 'Error while signing up..Try again later.'<br/>});</span></pre><p id="7a21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一切顺利，那么我们调用<code class="fe mr ms mt mu b">send</code>响应方法来完成请求，并发回<code class="fe mr ms mt mu b">201</code>状态代码，表示某个东西被创建了。我们可以发送<code class="fe mr ms mt mu b">200</code>状态代码，但是<code class="fe mr ms mt mu b">201</code>在这里更合适。</p><p id="e28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，从<code class="fe mr ms mt mu b">server</code>文件夹运行<code class="fe mr ms mt mu b">yarn start</code>命令，启动<code class="fe mr ms mt mu b">express</code>服务器。</p><p id="e518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以使用邮差测试<code class="fe mr ms mt mu b">/signup</code> API了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/2eb9e01914fe30422f8af06eb1bcbc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1x81-Hm6ODFK8uganCuoww.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Successful signup</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/97415839e6ecefd880a1c2873ed9da83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqPBWp7GNaXSnaRPIZ8jsQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Email already exists error</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/463bac10fed714e2ab6191818efa9cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90gpXKBKUQCx0JIeO2Etcg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Invalid field error</figcaption></figure><p id="6976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们了解一下<code class="fe mr ms mt mu b">/signin</code>路线。</p><p id="b466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们首先从<code class="fe mr ms mt mu b">common.js</code>调用<code class="fe mr ms mt mu b">validateUser</code>功能，检查是否有用户提供了电子邮件地址。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="69b4" class="lt lu iq mu b gy mz na l nb nc">const result = await pool.query(<br/>  'select userid,  email, password from bank_user where email = $1',<br/>  [email]<br/>);</span></pre><p id="a2ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果存在这样的用户，则我们将比较用户提供的密码和存储在数据库中的密码，以检查是否匹配。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="99e1" class="lt lu iq mu b gy mz na l nb nc">const isMatch = await bcrypt.compare(password, user.password);<br/>if (isMatch) {<br/>  delete user.password;<br/>  return user;<br/>} else {<br/>  throw new Error();<br/>}</span></pre><p id="4b30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果密码匹配，则我们会从响应中删除密码，然后将响应发送回客户端，这样响应将不会包含存储在数据库中的加密密码。</p><p id="12f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户不存在于数据库中，那么我们使用抛出新的错误()抛出一个错误；</p><p id="13db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们抛出<code class="fe mr ms mt mu b">validateUser</code>函数的错误，来自<code class="fe mr ms mt mu b">/signin</code>路由的catch block将被执行，我们将错误发送回客户端。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="5e00" class="lt lu iq mu b gy mz na l nb nc">res.status(400).send({<br/>  signin_error: 'Email/password does not match.'<br/>});</span></pre><p id="0612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们从<code class="fe mr ms mt mu b">validateUser</code>函数中获取用户，那么我们调用<code class="fe mr ms mt mu b">generateAuthToken</code>通过传递用户对象来生成jwt令牌。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="63b0" class="lt lu iq mu b gy mz na l nb nc">const generateAuthToken = async (user) =&gt; {<br/>  const { userid, email } = user;<br/>  const secret = process.env.secret;<br/>  const token = await jwt.sign({ userid, email }, secret);<br/>  return token;<br/>};</span></pre><p id="4731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了生成令牌，我们使用了<code class="fe mr ms mt mu b">jsonwebtoken</code> npm库。它提供了一个<code class="fe mr ms mt mu b">sign</code>方法，该方法接受我们提供的数据来生成令牌作为第一个参数，然后将密钥作为第二个参数，在生成和验证令牌时使用这个参数。</p><p id="fcf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦由<code class="fe mr ms mt mu b">generateAuthToken</code>函数生成令牌，我们就将该令牌和用户id一起插入令牌表中。因此，每当用户登录时，我们都会生成一个新令牌并添加到令牌表中。这将确保我们可以从多个设备登录到应用程序，因此令牌仅对该特定设备有效，并且一旦用户从应用程序注销，我们将从令牌表中删除该令牌。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="d27c" class="lt lu iq mu b gy mz na l nb nc">const result = await pool.query(<br/>  'insert into tokens(access_token, userid) values($1,$2) returning *',<br/>  [token, user.userid]<br/>);</span></pre><p id="8641" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦令牌成功添加到<code class="fe mr ms mt mu b">tokens</code>表中，我们将把用户详细信息和令牌一起发送回客户端</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="3a49" class="lt lu iq mu b gy mz na l nb nc">user.token = result.rows[0].access_token;<br/>res.send(user);</span></pre><p id="7a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以使用Postman测试<code class="fe mr ms mt mu b">/signin</code> API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/30551d4f47981a1c7d807a5fa78475bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Epurbol7BeCImnFJfpEt_g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">SignIn Error</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/1054eec904938299608f3dc1fadcd128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4zLTvU5TP1k7cyrNiSlgw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">SignIn successful</figcaption></figure><blockquote class="nt nu nv"><p id="588f" class="kw kx ls ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">现在，我们将在React应用程序中集成这些API。</p></blockquote><p id="f9ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在里面，<code class="fe mr ms mt mu b">src/utils/constants.js</code>添加另一个常数</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="fea2" class="lt lu iq mu b gy mz na l nb nc">export const BASE_API_URL = 'http://localhost:5000';</span></pre><p id="7629" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">actions</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">auth.js</code>，添加以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，在<code class="fe mr ms mt mu b">registerNewUser</code>函数中，我们调用我们的服务器API<a class="ae kv" href="http://localhost:5000/signup" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/sign up</a>，将用户数据作为第二个参数传递给它，并发送回对象<code class="fe mr ms mt mu b">{success: true }</code>作为API成功的结果，发送回<code class="fe mr ms mt mu b">{success: false}</code>作为失败的结果。</p><p id="199b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从带有分派参数的函数返回函数的语法由<code class="fe mr ms mt mu b">redux-thunk</code>库提供。点击这里查看我以前的文章<a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-integrate-redux-thunk-into-your-react-application-cd92b87c1629" rel="noopener">，了解如何使用它。</a></p><p id="5732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mr ms mt mu b">components/register.js</code>并在<code class="fe mr ms mt mu b">this.setState({ isSubmitted: true });</code>语句后的<code class="fe mr ms mt mu b">registerUser</code>函数内添加以下代码</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="5479" class="lt lu iq mu b gy mz na l nb nc">this.props<br/> .dispatch(registerNewUser({ first_name, last_name, email, password }))<br/> .then((response) =&gt; {<br/>  if (response.success) {<br/>    this.setState({<br/>      successMsg: 'User registered successfully.',<br/>      errorMsg: ''<br/>    });<br/>  }<br/>});</span></pre><p id="1b92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，在文件顶部添加一个<code class="fe mr ms mt mu b">registerNewUser</code>的导入。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="1cba" class="lt lu iq mu b gy mz na l nb nc">import { registerNewUser } from '../actions/auth';</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="79f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，通过运行<code class="fe mr ms mt mu b">yarn start</code>命令启动React应用程序，并尝试注册一个新用户。输入所有细节后，当你点击注册按钮时，后端API将被调用，但现在你会在控制台中看到一个错误，即<code class="fe mr ms mt mu b">CORS(Cross-origin resource sharing)</code>错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/4f4d182169d08dd664eb1d251ad07496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I84NpNjGNFyQ6-Pu9m0Lhg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">CORS Error</figcaption></figure><p id="3b22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出现错误是因为我们正在从运行在端口3000上的应用程序向运行在端口5000上的服务器发出API调用，因此浏览器阻止了我们对服务器的请求。这是出于安全原因和跨域策略。</p><p id="7265" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们需要在我们的express应用程序中添加额外的中间件，这样它就可以接受来自任何应用程序的请求。</p><p id="4d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要担心，在本文的后面，我们将看到如何在我们的应用程序中消除对cors的需求。</p><p id="d9d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，打开<code class="fe mr ms mt mu b">server/index.js</code>，为cors添加一个导入，并添加它的用途</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="fcf2" class="lt lu iq mu b gy mz na l nb nc">const express = require('express');<br/>const cors = require('cors');<br/>const authRoute = require('./routes/auth');<br/>require('dotenv').config();</span><span id="01dd" class="lt lu iq mu b gy no na l nb nc">const app = express();<br/>const PORT = process.env.PORT || 5000;</span><span id="edf8" class="lt lu iq mu b gy no na l nb nc">app.use(express.json());<br/>app.use(cors());<br/>app.use(authRoute);</span><span id="c975" class="lt lu iq mu b gy no na l nb nc">app.listen(PORT, () =&gt; {<br/>  console.log(`server started on port ${PORT}`);<br/>});</span></pre><p id="6ddf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，重新启动你的服务器，如果它没有运行，从<code class="fe mr ms mt mu b">server</code>文件夹执行<code class="fe mr ms mt mu b">yarn start</code>，现在，尝试再次注册用户</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/3159a2900ea1c81dd2a70575453e1a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pA5_Fj2Brhiihgm7_XGHyA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Registration successful</figcaption></figure><p id="1b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户也被添加到数据库中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/f8644e400bad9a966855269b5967b173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBlNK7Kk7x_pr6KtO7gJXg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Database Users</figcaption></figure><blockquote class="nt nu nv"><p id="33d2" class="kw kx ls ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">恭喜你，你已经成功整合了注册用户的后端和前端。哇！</p></blockquote><p id="870e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将把登录API集成到React应用程序中。</p><p id="40df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mr ms mt mu b">src/components/Login.js</code>和<code class="fe mr ms mt mu b">handleLogin</code>函数，在else块中添加对<code class="fe mr ms mt mu b">initiateLogin</code>动作的调用。此外，在顶部添加一个导入</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a9ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新启动React应用程序(如果尚未运行),并尝试使用已经注册的用户凭据登录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/2853e8f378733c76c37445c8fe9a2d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJCjt3p8U_OEopwb1BQqmA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login success</figcaption></figure><p id="2d69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，一旦您单击登录按钮，当登录成功时，数据将被添加到redux存储中。</p><p id="c80b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您输入错误的凭证，您将在控制台中看到错误</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/a99752aa6c4bfdd13218554e836e439b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SZ4tDnXOqcOOd1pP-i3WA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login failed</figcaption></figure><p id="ab59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您打开网络面板并检查登录请求-响应，您将看到来自后端的实际响应错误</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/f6260220ab86973532bdb8fdc245f128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8q4vqhERc7NTvlvwuAJMvQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Server error</figcaption></figure><p id="bd29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将在UI上显示登录和注册页面的后端服务器错误。</p><p id="87c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mr ms mt mu b">src/utils/constants.js</code>并添加两个新常量</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="ed98" class="lt lu iq mu b gy mz na l nb nc">export const GET_ERRORS = 'GET_ERRORS';<br/>export const RESET_ERRORS = 'RESET_ERRORS';</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src/reducers</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">errors.js</code>，添加以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8adf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src/actions</code>文件夹中创建一个新文件<code class="fe mr ms mt mu b">errors.js</code>,内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c7e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，打开<code class="fe mr ms mt mu b">actions/auth.js</code>和<code class="fe mr ms mt mu b">initiateLogin</code>和<code class="fe mr ms mt mu b">registerNewUser</code>函数的内部catch块，添加以下代码</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="65fc" class="lt lu iq mu b gy mz na l nb nc">error.response &amp;&amp; dispatch(getErrors(error.response.data));</span></pre><p id="ffc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，从服务器发送的响应将在error.response.data对象中可用，我们在reducer中添加了该对象</p><p id="158f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，在文件顶部为getErrors操作函数添加一个导入</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cba6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了获得缩减器中的错误，将缩减器添加到<code class="fe mr ms mt mu b">store/store.js</code>文件中</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="ceed" class="lt lu iq mu b gy mz na l nb nc">combineReducers({ <br/> auth: authReducer, <br/> errors: errorsReducer <br/>})</span></pre><p id="faf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也为它添加一个导入，在顶部</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="016e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，每当我们调用<code class="fe mr ms mt mu b">getErrors</code>函数从<code class="fe mr ms mt mu b">initiateLogin</code>函数调度<code class="fe mr ms mt mu b">GET_ERRORS</code>动作时，它将调用reducer，错误将被添加到redux存储中</p><p id="805b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，尝试使用无效凭证登录，您将看到redux存储中添加的错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/9895bcb9a2529a9b78be46a90ad172ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bApc2oLdH5NdJ6YKZU4lsg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">server error in the redux store</figcaption></figure><p id="8386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将在UI上显示来自redux存储的错误。</p><p id="9421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mr ms mt mu b">components/Login.js</code>，在文件底部添加<code class="fe mr ms mt mu b">mapStateToProps</code>函数，并将其传递给<code class="fe mr ms mt mu b">connect</code>函数。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="7f15" class="lt lu iq mu b gy mz na l nb nc">const mapStateToProps = (state) =&gt; ({<br/>  errors: state.errors<br/>});</span><span id="bbd7" class="lt lu iq mu b gy no na l nb nc">export default connect(mapStateToProps)(Login);</span></pre><p id="188b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加<code class="fe mr ms mt mu b">componentDidUpdate</code>和<code class="fe mr ms mt mu b">componentWillUnmount</code>生命周期方法，并在文件顶部添加<code class="fe mr ms mt mu b">lodash</code>和<code class="fe mr ms mt mu b">resetErrors</code>的导入</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在，每当redux存储中添加了一个错误时，我们将在<code class="fe mr ms mt mu b">props.errors</code>中获得该错误，因为我们的mapStateToProps函数，并且我们通过实现<code class="fe mr ms mt mu b">componentDidUpdate</code>方法来获取更新后的正确值。</p><p id="0ffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">componentDidUpdate</code>方法中，我们首先使用lodash <code class="fe mr ms mt mu b">isEqual</code>方法检查先前的属性是否不等于当前的属性，然后才在<code class="fe mr ms mt mu b">errorMsg</code>状态中设置错误。这个条件是避免无限循环错误所必需的。要理解lodash方法的重要性，请点击这里查看我以前的文章<a class="ae kv" href="https://levelup.gitconnected.com/extremely-useful-lodash-methods-b38f121fea7e" rel="noopener ugc nofollow" target="_blank"/></p><p id="ba5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您输入无效的登录凭证，您将能够在UI上看到后端错误</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/5682741acfd85fb0f0e73de83e49f4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlOIk_nDOgVecb3IUeC3FA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Server error on UI</figcaption></figure><p id="9a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们在<code class="fe mr ms mt mu b">Register</code>页面上显示来自后端的错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/8c70d7ed6da7c0183492976585f81f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lS9Kq_qNOjSVrHxbRHpF3g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Registration server error</figcaption></figure><p id="7a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们创建一个<code class="fe mr ms mt mu b">Profile</code>组件，以便在用户登录到应用程序后显示个人资料页面</p><p id="ca55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">components</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">Profile.js</code>并添加以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">actions</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">profile.js</code>，添加以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="15fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mr ms mt mu b">utils/constants.js</code>并添加另一个常量</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="393b" class="lt lu iq mu b gy mz na l nb nc">export const UPDATE_PROFILE = 'UPDATE_PROFILE';</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">reducers</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">profile.js</code>，添加以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8eeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加<code class="fe mr ms mt mu b">profileReducer</code>保存在<code class="fe mr ms mt mu b">store/store.js</code>文件中</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="0999" class="lt lu iq mu b gy mz na l nb nc">combineReducers({<br/>  auth: authReducer,<br/>  errors: errorsReducer,<br/>  profile: profileReducer<br/>})</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="48e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，由于我们已经将<code class="fe mr ms mt mu b">profileReducer</code>添加到商店中，我们可以使用<code class="fe mr ms mt mu b">mapStateToProps</code>功能从<code class="fe mr ms mt mu b">store.profile</code>的任何组件中访问商店中的个人资料信息。</p><p id="415a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">router/AppRouter.js</code>文件中增加<code class="fe mr ms mt mu b">Profile</code>组件</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="ca84" class="lt lu iq mu b gy mz na l nb nc">&lt;Route path="/profile" component={Profile} /&gt;</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="98c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还记得，每当我们单击<code class="fe mr ms mt mu b">Login</code>页面上的登录按钮时，我们都会向服务器上的<code class="fe mr ms mt mu b">/signin</code> API发送登录请求，一旦成功，我们就会将响应中的数据添加到redux存储中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/2853e8f378733c76c37445c8fe9a2d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJCjt3p8U_OEopwb1BQqmA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login success</figcaption></figure><p id="93f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，一旦登录成功，我们就不会重定向到任何组件。</p><p id="a315" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们现在就做吧。</p><p id="0782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">actions/auth.js</code>中，在<code class="fe mr ms mt mu b">initiateLogin</code>内部，需要使用<code class="fe mr ms mt mu b">react-router-dom</code>的<code class="fe mr ms mt mu b">props.history.push(‘/profile’)</code>方法成功后重定向到<code class="fe mr ms mt mu b">Profile</code>组件。</p><p id="2493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是<code class="fe mr ms mt mu b">history</code>对象只适用于<code class="fe mr ms mt mu b">AppRouter.js</code>中<code class="fe mr ms mt mu b">Route</code>提到的路线，如<code class="fe mr ms mt mu b">Profile</code>、<code class="fe mr ms mt mu b">Login</code>和<code class="fe mr ms mt mu b">Register</code>组件，所以要访问这些路线之外的历史对象，我们需要使用npm <code class="fe mr ms mt mu b">history</code>库。</p><p id="8205" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经初步安装了它以及其他依赖项。所以打开<code class="fe mr ms mt mu b">AppRouter.js</code>并为历史包添加导入。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="b82e" class="lt lu iq mu b gy mz na l nb nc">import { createBrowserHistory } from 'history';</span></pre><p id="cd0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe mr ms mt mu b">createBrowserHistory</code>函数获取历史对象，我们可以将其导出为名为export的对象</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="9957" class="lt lu iq mu b gy mz na l nb nc">export const history = createBrowserHistory();</span></pre><p id="38f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要将这个历史变量传递给我们的<code class="fe mr ms mt mu b">AppRouter</code>。</p><p id="bab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变化如此之大</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="8362" class="lt lu iq mu b gy mz na l nb nc">&lt;BrowserRouter&gt;</span><span id="38fb" class="lt lu iq mu b gy no na l nb nc">...</span><span id="9ee2" class="lt lu iq mu b gy no na l nb nc">&lt;/BrowserRouter&gt;</span></pre><p id="b73a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="65e1" class="lt lu iq mu b gy mz na l nb nc">&lt;Router history={history}&gt;</span><span id="a19c" class="lt lu iq mu b gy no na l nb nc">...</span><span id="56ef" class="lt lu iq mu b gy no na l nb nc">&lt;/Router&gt;</span></pre><p id="c070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并从<code class="fe mr ms mt mu b">react-router-dom</code>导入<code class="fe mr ms mt mu b">Router</code>。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="6ddb" class="lt lu iq mu b gy mz na l nb nc">import { Router } from 'react-router-dom';</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aa08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们已经导出了历史对象，可以在<code class="fe mr ms mt mu b">actions/auth.js</code>里面导入它</p><p id="1a2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">initiateLogin</code>功能内<code class="fe mr ms mt mu b">dispatch(signIn(user));</code>后增加<code class="fe mr ms mt mu b">history.push(‘/profile’);</code></p><p id="7dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并在文件顶部为<code class="fe mr ms mt mu b">history</code>添加导入</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f3f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，登录应用程序，您将看到我们被重定向到配置文件页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/65ec9bc9f66a2f1697d2fa26d9c2066b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/1*g0L6BdJ4e6HayIuVD9hirg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login redirect demo</figcaption></figure><p id="8f79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是您会注意到，银行应用程序标题没有显示在配置文件页面上。因此，让我们创建一个<code class="fe mr ms mt mu b">Header</code>组件，只为登录用户显示标题。</p><p id="ab36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">components</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">Header.js</code>，添加以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a84a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，打开<code class="fe mr ms mt mu b">AppRouter.js</code>，在<code class="fe mr ms mt mu b">Router</code>内添加<code class="fe mr ms mt mu b">Header</code>组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0d87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，成功登录后，您将看到个人资料页面以及标题</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/78006618f1643600793540df7825be87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OX6ftOSsafKUcZkKm9OHg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Profile page</figcaption></figure><p id="cc52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将了解如何在刷新后维护会话。</p><p id="a52e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src/utils/common.js</code>文件中添加以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="00bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，你的完整的<code class="fe mr ms mt mu b">common.js</code>将看起来像这样</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2b40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来理解代码。</p><p id="8e5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还记得，在<code class="fe mr ms mt mu b">server/routers/auth.js</code>的<code class="fe mr ms mt mu b">/signin</code>路线里面，我们叫<code class="fe mr ms mt mu b">generateAuthToken</code></p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="f4a2" class="lt lu iq mu b gy mz na l nb nc">const token = await generateAuthToken(user);</span></pre><p id="c8f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个函数中，我们通过为第一个参数传递userid和email来调用<code class="fe mr ms mt mu b">jwt.sign</code>方法。所以生成的jwt令牌包含这些值来标识用户。</p><p id="c6dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了从jwt令牌中取出这些值，我们使用了接受令牌并返回这些值的<code class="fe mr ms mt mu b">jwt-decode </code> npm包。</p><p id="eda3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在<code class="fe mr ms mt mu b">maintainSession</code>内部，我们通过传递令牌来使用<code class="fe mr ms mt mu b">json_decode</code>，并且我们将提取的信息传递给<code class="fe mr ms mt mu b">updateStore</code>函数，该函数将调度<code class="fe mr ms mt mu b">signIn</code>动作创建器函数。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="5cdd" class="lt lu iq mu b gy mz na l nb nc">const decoded = jwt_decode(user_token);<br/>updateStore(decoded);</span></pre><p id="2ffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您再次登录，您将会看到，即使在刷新了<code class="fe mr ms mt mu b">profile</code>页面之后，您也会看到，redux store中的数据的auth对象并没有被删除。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/94406d77e18bd3b7e8b59c5a08174f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4xEsMF-goVX2r_4sMYfpw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">redux store data retained even after refresh</figcaption></figure><p id="a167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为，一旦我们成功登录并刷新页面，在<code class="fe mr ms mt mu b">maintainSession</code>函数中，我们将检查本地存储中的令牌，并再次调用<code class="fe mr ms mt mu b">signIn</code> action creator函数，用从jwt令牌解码的值更新redux存储。</p><p id="0ca0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您注意到了，jwt令牌有3个字符串，由两个点分隔。中间的字符串值包含我们在生成令牌时使用的实际值。</p><p id="a1b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到<a class="ae kv" href="https://www.base64decode.org/" rel="noopener ugc nofollow" target="_blank">这个站点</a>，将以下值粘贴到文本区域，然后点击解码</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="f9f6" class="lt lu iq mu b gy mz na l nb nc">eyJ1c2VyaWQiOiIzIiwiZW1haWwiOiJtbEBleGFtcGxlLmNvbSIsImlhdCI6MTU5MDg0NDU5OX0</span></pre><p id="dec0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到jwt令牌中包含的实际数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/847c9774daec4918615cc1028cc7d4f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMvD0UyLUqkT9HOXH0WtLw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Decode jwt token data</figcaption></figure><p id="40fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦用户登录，我们就不应该通过访问这些页面来再次登录或注册。因此，我们需要为当前页面添加一个检查，如果它是<code class="fe mr ms mt mu b">/profile</code>或<code class="fe mr ms mt mu b">/register</code>，那么我们重定向到<code class="fe mr ms mt mu b">/profile</code>页面。</p><p id="094f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，改变</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="8584" class="lt lu iq mu b gy mz na l nb nc">export const maintainSession = () =&gt; {<br/>  const user_token = localStorage.getItem('user_token');<br/>  if (user_token) {<br/>    const decoded = jwt_decode(user_token);<br/>    updateStore(decoded);<br/>  } else {<br/>    history.push('/');<br/>  }<br/>};</span></pre><p id="c2b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="54fc" class="lt lu iq mu b gy mz na l nb nc">export const maintainSession = () =&gt; {<br/>  const user_token = localStorage.getItem('user_token');<br/>  if (user_token) {<br/>    const currentPath = window.location.pathname;<br/>    if (currentPath === '/' || currentPath === '/register') {<br/>      history.push('/profile');<br/>    }<br/>    const decoded = jwt_decode(user_token);<br/>    updateStore(decoded);<br/>  } else {<br/>    history.push('/');<br/>  }<br/>};</span></pre><p id="baec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，一旦我们登录，我们将无法访问注册或登录页面。</p><p id="c3a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们添加代码，以便在组件加载后获得<code class="fe mr ms mt mu b">profile</code>细节。</p><p id="7b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了做到这一点，在<code class="fe mr ms mt mu b">actions/auth.js</code>的<code class="fe mr ms mt mu b">initiateLogin</code>函数中，在<code class="fe mr ms mt mu b">history.push</code>调用之前，添加以下代码</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="7493" class="lt lu iq mu b gy mz na l nb nc">dispatch(initiateGetProfile(user.email));</span></pre><p id="9343" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在redux存储中添加<code class="fe mr ms mt mu b">profile</code>数据。</p><p id="23fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们在服务器端创建一个profile API来获取和更新<code class="fe mr ms mt mu b">profile</code>信息。</p><p id="6177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">server/routes</code>文件夹下新建一个文件<code class="fe mr ms mt mu b">profile.js</code>，添加以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cc9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在<code class="fe mr ms mt mu b">server/index.js</code>内为<code class="fe mr ms mt mu b">app.use</code>添加这条路线</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a28a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来理解代码。</p><p id="79f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">middleware/auth.js</code>中，我们增加了一个中间件功能。</p><blockquote class="nt nu nv"><p id="c97c" class="kw kx ls ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">什么是中间件？</p></blockquote><p id="0f4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">Middleware</code>是一个可以访问请求和响应对象以及额外的next参数的函数。因此，每当我们向后端Express服务器发出API请求时，我们都可以在请求被发送到实际路由之前或之后执行一些代码。所以我们可以做以下事情。</p><p id="cf87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.我们可以执行日志记录，如请求的日志URL、IP地址等</p><p id="7ddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.此外，基于某些条件，我们可以限制对该路线的访问。</p><p id="da11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们将使用中间件来限制对路由的访问。</p><p id="5a8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，每当我们向API路由发出任何请求时，我们将检查身份验证令牌是否由客户端发送并且是否有效，然后将请求转发到私有路由，否则我们将立即发送错误，而不执行私有路由。</p><p id="4640" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您记得，在<code class="fe mr ms mt mu b">src/actions/auth.js</code>中，我们有<code class="fe mr ms mt mu b">initiateLogin</code>动作创建器，我们在其中添加了这条语句</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="e03a" class="lt lu iq mu b gy mz na l nb nc">localStorage.setItem('user_token', user.token);</span></pre><p id="cec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果登录成功，我们会将来自服务器响应的jwt令牌存储到本地存储中。因此，对于任何只有在用户登录时才应该访问的API路由，我们需要将这个令牌和请求一起发送给服务器。让我们看看当我们在发出获取<code class="fe mr ms mt mu b">profile</code>信息的API请求时不发送令牌会发生什么。</p><p id="5d05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经添加了代码来从<code class="fe mr ms mt mu b">componentDidMount</code>和<code class="fe mr ms mt mu b">componentDidUpdate</code>方法内的<code class="fe mr ms mt mu b">components/Profile.js</code>中的redux存储中获取<code class="fe mr ms mt mu b">profile</code>数据。</p><p id="b937" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们不能进入<code class="fe mr ms mt mu b">login</code>或<code class="fe mr ms mt mu b">register</code>页面，因为我们已经登录了，所以现在，要测试get <code class="fe mr ms mt mu b">profile</code> API，只需在浏览器控制台中键入以下代码，然后点击enter</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="4600" class="lt lu iq mu b gy mz na l nb nc">localStorage.removeItem('user_token')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/b8da6d8a6f841b6472afbb811104fd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSUu25I1sX2y7D9jzbG0iA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Deleting localStorage token value</figcaption></figure><p id="2f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在你去<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>的时候会自动重定向到登录页面</p><p id="42e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在再次登录，您可能会失望，因为您将在控制台中看到一个错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/c6015ab4598be55b53770b9d24b93652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbEJ3ScXANBLXNMdNndw2A.png"/></div></div></figure><p id="deaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您看到网络面板，您将看到<code class="fe mr ms mt mu b">Authentication failed</code>服务器错误</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/dcfa562803bcf24926f01fda04d97a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0WeGhsPyzHpqbscIlm7Sg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Authentication failed server error</figcaption></figure><p id="9e8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们在<code class="fe mr ms mt mu b">routes/profile.js</code>文件中添加了<code class="fe mr ms mt mu b">authMiddleware</code>来获取<code class="fe mr ms mt mu b">/profile</code>路线，并且这是一个私有路线，只有登录的用户才能访问该路线。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="389f" class="lt lu iq mu b gy mz na l nb nc">Router.get('/profile', authMiddleware, async (req, res) =&gt; {</span></pre><p id="9c57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们进入<code class="fe mr ms mt mu b">/profile</code>路线时，将执行<code class="fe mr ms mt mu b">authMiddleware</code>。</p><p id="c26f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看到<code class="fe mr ms mt mu b">authMiddleware</code>函数的代码，你会发现它需要一个我们没有提供的<code class="fe mr ms mt mu b">Authentication Header </code>，因此我们得到了<code class="fe mr ms mt mu b">Authentication failed</code>错误。</p><p id="7608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">Authorization</code>请求头中，我们需要以下面的方式将jwt令牌作为<code class="fe mr ms mt mu b">Bearer</code>令牌发送</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="b055" class="lt lu iq mu b gy mz na l nb nc">Header name: header value</span><span id="84e4" class="lt lu iq mu b gy no na l nb nc">For ex. Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiIzIiwiZW1haWwiOiJtbEBleGFtcGxlLmNvbSIsImlhdCI6MTU5MDg1NzMwNH0.uTwti-O79u_8sT-H70WsR4LyQDN3mttR6xYxn2a6VeQ</span></pre><p id="69f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们先通过邮递员来做这件事，这样你会有一个想法。</p><p id="c6b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过postman点击登录API。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/8db843d25d7ea1d0091b8af03d5304c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQmILL-MC6E_CXm7gJLV7g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Login API postman</figcaption></figure><p id="fc44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将使用从登录响应中获得的令牌，并将相同的令牌用于<code class="fe mr ms mt mu b">profile</code>路由</p><p id="96a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在headers选项卡中，我们将添加带有令牌值的<code class="fe mr ms mt mu b">Authorization</code>标头</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/61c9bc558e3ba0575c087c938cb4f448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFMnQMSqJvT4wlUSbZthpg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Adding Authorization header</figcaption></figure><p id="a93c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您单击send按钮发送API请求，我们就会得到<code class="fe mr ms mt mu b">profile</code>信息，而不会出现认证错误</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/f571c744cae6f6789d7032da681b696f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTmQSGu-1QSgIDXlP8IDww.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">profile API response</figcaption></figure><p id="7c08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看如何在代码中使用<code class="fe mr ms mt mu b">Axios</code>发送授权头。</p><p id="a210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src/utils/common.js</code>文件中添加以下两个函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="03fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，我们以如下方式添加了一个标题</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="cb99" class="lt lu iq mu b gy mz na l nb nc">axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;</span></pre><p id="006d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在进行API调用之前，我们将执行这个函数，这个头将被自动添加到默认的请求头中。</p><p id="47a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mr ms mt mu b">src/actions/profile.js</code>，在<code class="fe mr ms mt mu b">initiateGetProfile</code>函数中，在<code class="fe mr ms mt mu b">axios.get</code>调用之前添加一个对<code class="fe mr ms mt mu b">setAuthHeader</code>函数的调用，并从<code class="fe mr ms mt mu b">common.js</code>为其添加一个导入。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aa73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看<code class="fe mr ms mt mu b">profile</code>信息是否显示在页面加载上。在浏览器控制台中键入<code class="fe mr ms mt mu b">localStorage.removeItem(‘user_token’)</code>并转到<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>并再次登录</p><p id="73b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，您将看到自动填充的个人资料信息</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/5b3e8817fa45f8c60946345a0e7e3cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wuh33RXqViusK64JPnM-1A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Profile information populated</figcaption></figure><p id="3d6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以更新<code class="fe mr ms mt mu b">profile</code>信息。</p><p id="88d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">厉害！如果您检查network选项卡，您可以在request headers部分下看到我们的<code class="fe mr ms mt mu b">Authorization</code>标题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/5ebfbe473909e1b788f713fb232757eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFPK8smgbkK-DXeWMDZrew.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Profile API Headers</figcaption></figure><p id="ca35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你知道了如何发送<code class="fe mr ms mt mu b">authorization</code>头，我们可以看看<code class="fe mr ms mt mu b">middleware/auth.js</code>中<code class="fe mr ms mt mu b">authMiddleware</code>的代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f432" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从<code class="fe mr ms mt mu b">req.header</code>我们得到标题为</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="5a1c" class="lt lu iq mu b gy mz na l nb nc">Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiIzIiwiZW1haWwiOiJtbEBleGFtcGxlLmNvbSIsImlhdCI6MTU5MDg1NzMwNH0.uTwti-O79u_8sT-H70WsR4LyQDN3mttR6xYxn2a6VeQ</span></pre><p id="82cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们把它按空间分开，只取代币值</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="9590" class="lt lu iq mu b gy mz na l nb nc">const token = req.header('Authorization').split(' ')[1];</span></pre><p id="ddc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后使用来自<code class="fe mr ms mt mu b">.env</code>文件的相同密钥，我们使用它来创建jwt令牌，我们使用<code class="fe mr ms mt mu b">jwt.verify</code>方法来验证令牌是有效的，并取出存储在该令牌中的用户id和电子邮件，并将其存储为解码变量。</p><p id="820a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们检查令牌表中是否存在令牌，如果找到，我们将返回用户的详细信息以及添加到请求对象中的令牌，并调用下一个函数，该函数将执行预定路由的代码。</p><p id="ca57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在得到<code class="fe mr ms mt mu b">/profile</code>路线时已经<code class="fe mr ms mt mu b">authMiddleware</code></p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="ec5c" class="lt lu iq mu b gy mz na l nb nc">Router.get('/profile', authMiddleware, async (req, res) =&gt; {</span></pre><p id="96e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们调用下一个函数<code class="fe mr ms mt mu b">next()</code>时，来自<code class="fe mr ms mt mu b">/profile</code>路径的代码将被执行。</p><p id="d759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在验证令牌或解码令牌时出现任何错误，来自<code class="fe mr ms mt mu b">authMiddleware</code>的catch块将被执行，我们将把<code class="fe mr ms mt mu b">Authentication failed</code>错误发送回客户端</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="f63e" class="lt lu iq mu b gy mz na l nb nc">res.status(400).send({<br/>  auth_error: 'Authentication failed.'<br/>});</span></pre><blockquote class="nt nu nv"><p id="60d3" class="kw kx ls ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">现在，让我们添加注销功能</p></blockquote><p id="471c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">server/routes/auth.js</code>中添加以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">components</code>文件夹中新建一个文件<code class="fe mr ms mt mu b">Logout.js</code>，内容如下</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9ce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mr ms mt mu b">actions/auth.js</code>并添加以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="263b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的<code class="fe mr ms mt mu b">auth.js</code>代码如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您检查上面的<code class="fe mr ms mt mu b">initiateLogout</code>函数，您将会看到，在进行Axios调用之前，我们正在调用<code class="fe mr ms mt mu b">setAuthHeader</code>函数，因为这也是一个私有路由，因为只有登录的用户才允许注销。调用完成后，我们将移除<code class="fe mr ms mt mu b">Authorization</code>头，从本地存储中删除令牌，并调用<code class="fe mr ms mt mu b">signOut</code>动作创建器函数，这样它将从redux存储中清空auth对象。</p><p id="b39b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们在派遣<code class="fe mr ms mt mu b">signOut</code>之前添加了一个返回关键字。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="7f19" class="lt lu iq mu b gy mz na l nb nc">return dispatch(signOut());</span></pre><p id="e4dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，由于这是在一个异步函数中，我们将在调用这个<code class="fe mr ms mt mu b">initiateLogout</code>函数后得到一个承诺，并且在<code class="fe mr ms mt mu b">Logout.js</code>中我们已经添加了<code class="fe mr ms mt mu b">.then</code>调用，所以一旦我们被注销，我们将被重定向到登录页面</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="7c59" class="lt lu iq mu b gy mz na l nb nc">dispatch(initiateLogout()).then(() =&gt; history.push('/'));</span></pre><p id="6336" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将<code class="fe mr ms mt mu b">/logout</code>路线添加到<code class="fe mr ms mt mu b">AppRouter</code>组件中</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="ffde" class="lt lu iq mu b gy mz na l nb nc">&lt;Route path="/logout" component={Logout} /&gt;</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="05bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以测试注销功能。</p><p id="d050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单击注销按钮，您将被重定向到登录页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/7caa4e1fadc8c5fbe79122f205a24c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/1*4FMQWMB6OrLyHLLu-h96VA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Working application functionality</figcaption></figure><p id="16eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">几个改进:</strong></p><p id="a231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经完成了我们的应用程序的一个流程，但是我们还可以做一个改进。如果您还记得，对于每一个像get或post <code class="fe mr ms mt mu b">/profile</code>这样的私有路由，在进行API调用之前，我们都在调用<code class="fe mr ms mt mu b">setAuthHeader()</code>函数。我们有许多其他的途径，我们将在下一部分中探索，但是每次在进行API调用之前调用该函数是很麻烦的，或者可能会发生这样的情况，我们可能会忘记调用该函数，并且我们会收到<code class="fe mr ms mt mu b">Authentication failed </code>错误。因此，我们可以分离出完成调用该功能的功能，然后进行API调用，这是处理API的正确方式。让我们开始吧</p><p id="7675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src/utils</code>文件夹中创建一个新文件<code class="fe mr ms mt mu b">api.js</code>并添加以下代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="82f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此，我们向每条<code class="fe mr ms mt mu b">get</code>、<code class="fe mr ms mt mu b">post</code>和<code class="fe mr ms mt mu b">patch</code>路线发送以下参数。<br/> 1。API URL作为第一个参数<br/> 2。作为第二个参数发送给API的数据<br/> 3。如果我们需要在进行API调用之前设置<code class="fe mr ms mt mu b">Authorization</code>头，发送<code class="fe mr ms mt mu b">true</code>作为第三个参数<br/> 4。如果我们需要在进行API调用后删除auth头，那么发送<code class="fe mr ms mt mu b">true</code>作为第四个参数</p><p id="b14b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">src/actions/profile.js</code>内部，在<code class="fe mr ms mt mu b">initiateGetProfile</code>函数内部，移除<code class="fe mr ms mt mu b">axios.get</code>，从<code class="fe mr ms mt mu b">api.js</code>调用get函数</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="bab8" class="lt lu iq mu b gy mz na l nb nc">const profile = await get(`${BASE_API_URL}/profile`);</span></pre><p id="0f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mr ms mt mu b">initiateUpdateProfile</code>函数中，删除<code class="fe mr ms mt mu b">axios.post</code>并添加以下代码行</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="d50b" class="lt lu iq mu b gy mz na l nb nc">const profile = await post(`${BASE_API_URL}/profile`, profileData);</span></pre><p id="c85e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样在<code class="fe mr ms mt mu b">src/actions/auth.js</code>内，在<code class="fe mr ms mt mu b">initiateLogout</code>函数内，删除<code class="fe mr ms mt mu b">axios.post</code>并添加以下代码行</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="349f" class="lt lu iq mu b gy mz na l nb nc">await post(`${BASE_API_URL}/logout`, true, true);</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f8a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了...谢谢你忍受了我这么久。</p><p id="f48a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以找到Github源代码，直到现在</p><ul class=""><li id="7eb2" class="ot ou iq ky b kz la lc ld lf ov lj ow ln ox lr oy oz pa pb bi translated">使用类组件<a class="ae kv" href="https://github.com/myogeshchavan97/fullstack_banking_app/tree/section-1-using-class-components" rel="noopener ugc nofollow" target="_blank">这里</a></li><li id="3faf" class="ot ou iq ky b kz pc lc pd lf pe lj pf ln pg lr oy oz pa pb bi translated">在这里使用挂钩<a class="ae kv" href="https://github.com/myogeshchavan97/fullstack_banking_app/tree/section-1-using-hooks" rel="noopener ugc nofollow" target="_blank">和</a></li></ul><p id="4e6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。我希望你学到了新东西。</p><p id="4b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在这里</strong>  <strong class="ky ir">查看这个多部分系列的下一部分</strong> <a class="ae kv" href="https://medium.com/javascript-in-plain-english/create-a-full-stack-banking-application-using-react-part-2-6fb21200613a?source=friends_link&amp;sk=0394e9bb66379594d2ebc7bffdfbfea5" rel="noopener"> <strong class="ky ir">。</strong></a></p><p id="cf2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">别忘了直接在你的收件箱</strong> <a class="ae kv" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">这里订阅我的每周简讯，里面有惊人的技巧、窍门和文章。</strong> </a></p></div><div class="ab cl ph pi hu pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="ij ik il im in"><h2 id="d3d0" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="3e1b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我们的YouTube频道</strong> </a> <strong class="ky ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>