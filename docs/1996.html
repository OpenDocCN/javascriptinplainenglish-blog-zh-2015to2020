<html>
<head>
<title>You don’t know JavaScript until you can beat this game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">直到你能打败这个游戏，你才知道JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-dont-know-javascript-until-you-can-beat-this-game-aa7fd58befb?source=collection_archive---------0-----------------------#2020-05-11">https://javascript.plainenglish.io/you-dont-know-javascript-until-you-can-beat-this-game-aa7fd58befb?source=collection_archive---------0-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3330" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">每次把钱押在获胜的马上，你就可以称自己是真正的JavaScript <strong class="ak"> <em class="kf">鉴赏家</em> </strong></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/09506a1b4ad7781b6a626de06af0e4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ohexNuPOiz0JpEsm"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@pietromattia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pietro Mattia</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4a9b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">前几天，我在对一个中级开发人员职位进行例行电话筛选时，问了以下问题:</p><blockquote class="lt lu lv"><p id="f170" class="kx ky lw kz b la lb jr lc ld le ju lf lx lh li lj ly ll lm ln lz lp lq lr ls ij bi translated">我:JavaScript是同步的还是异步的？</p><p id="21b8" class="kx ky lw kz b la lb jr lc ld le ju lf lx lh li lj ly ll lm ln lz lp lq lr ls ij bi translated">考生:是异步的。</p><p id="5bfe" class="kx ky lw kz b la lb jr lc ld le ju lf lx lh li lj ly ll lm ln lz lp lq lr ls ij bi translated">我:你确定？JavaScript本身？</p><p id="cbff" class="kx ky lw kz b la lb jr lc ld le ju lf lx lh li lj ly ll lm ln lz lp lq lr ls ij bi translated">候选人:100%。</p></blockquote><p id="da60" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个答案让我担心。这让我很担心，因为我知道他有大约3年的编写生产JavaScript代码的经验。他是一个相当有能力的开发人员，并且正确地回答了我的大部分问题。然而，他的回答立即引起了我的怀疑。(<strong class="kz ir">注:</strong>有人在说这是个技巧性的问题。要明确的是，目标不是欺骗候选人。目标是以开放式的方式引发关于该主题的进一步对话，看看他们熟悉什么。我担心的是，如果有人用一个词明确地回答是/否，而不去深究<em class="lw">为什么</em>他们会给出这样的答案。我绝不会仅仅因为候选人在这里的回答就取消他的资格)。</p><p id="6ac6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我认为这不是他的错。如果您只是编写JavaScript代码，而没有先了解它的历史和内部工作原理，您可能会认为它是异步的。我想建议这是<em class="lw">错的。</em>至少，这是一种误导。</p><p id="f16a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我看来，JavaScript是一种同步语言，并且一直如此。当我们想到在某些环境中运行JavaScript时(浏览器或带有节点的服务器端)，就会产生困惑。这是因为这些环境让我们可以访问异步功能，比如经典的<code class="fe ma mb mc md b">setTimeout</code>函数。值得注意的是，<code class="fe ma mb mc md b">setTimeout</code>函数本身是<strong class="kz ir">而不是</strong>原生JavaScript的一部分，而是浏览器API的一部分。(你<em class="lw">可能</em>认为既然承诺现在是ECMAScript的一部分，既然JavaScript是ECMAScript的“方言”,那么它本质上也一定是异步的。这是一个有趣的观点，但在我看来最终没有抓住要点，所以我不会在这里讨论它)。</p><p id="7371" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这种语言看似模棱两可的本质经常会在我们的日常代码(和工作面试)中导致许多意想不到的后果。更糟糕的是，我们并不总是意识到这些误解，所以我们不知不觉地将它们作为绝对真理传递给其他人，放大了手头的问题。</p><p id="3d7e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，我认为设计各种场景来检查和进一步剖析由于将同步JavaScript代码与各种JavaScript环境提供的额外异步功能混合在一起而产生的复杂性将是有趣且有用的。</p><p id="7929" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了让它更有趣一点，我将把各种情况/脚本呈现和游戏化为比赛，把运行的函数呈现和游戏化为马。游戏的目标是正确推断每场比赛中马匹的最终排名。如果你把排名搞错了，或者只是想进一步理解，我还会补充一个解释部分。</p><p id="8eac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">免责声明:</strong>我假设你已经对事件循环有些熟悉了。如果你不是，我建议你去看看这篇演讲，它会比我解释得更好。</p><p id="3988" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，让我们从一个琐碎的热身比赛开始。</p><h1 id="9c3c" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">热身赛</strong></h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="3f81" class="na mf iq md b gy nb nc l nd ne">console.log("Horse A");<br/>console.log("Horse B");<br/>console.log("Horse C");</span></pre><p id="f9d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="0947" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马A</li><li id="9662" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马B</li><li id="d5c8" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马C</li></ol><p id="d949" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解释</strong></p><p id="ec51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">JavaScript是同步的！</p><h1 id="758e" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">第一场比赛</strong></h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="475d" class="na mf iq md b gy nb nc l nd ne">setTimeout(() =&gt; console.log("Horse A"), 1000)<br/>console.log("Horse B")</span></pre><p id="3d88" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="1c62" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马B</li><li id="752e" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li></ol><p id="afc4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解释</strong></p><p id="7777" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">啊，JavaScript的经典入门。这里最常见的错误是认为JavaScript会在进入下一行之前等待<code class="fe ma mb mc md b">setTimeout</code>完成。这是有道理的。毕竟JavaScript是同步的。然而，回想一下,<code class="fe ma mb mc md b">setTimeout</code>本身并不是JavaScript固有的。它是浏览器API的一部分。</p><p id="6a5e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里发生的事情是JavaScript将把<code class="fe ma mb mc md b">setTimeout</code>推到调用堆栈上。然后，它将从堆栈中弹出，并发送到浏览器API，在后台执行其工作。一旦1000毫秒过去，工作就完成了，现在它将被发送到一个称为<strong class="kz ir">作业/任务队列</strong>的数据结构。一旦它在这里，一个简单的(读起来:神奇的)机制称为<strong class="kz ir">事件循环</strong>将检查调用栈是否为空。如果是，那么它将取出任务队列中的第一项，并将其推送到堆栈中，在那里它将最终被执行。否则，它将继续执行调用堆栈中的函数。当然，当马A做所有这些事情的时候，马B被推到调用堆栈上并被执行，因此已经完成了比赛。</p><p id="7307" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你不熟悉这些概念，那么一下子可能会消耗很多。别担心，网上有无数的资源，比我资源丰富得多，可以教你所有关于事件循环的知识。<a class="ae kw" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0" rel="noopener ugc nofollow" target="_blank">这里</a>又是一个关于这个话题的大谈。</p><h1 id="ce46" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">第二场比赛</h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="2322" class="na mf iq md b gy nb nc l nd ne">setTimeout(() =&gt; console.log("Horse A"), 0)<br/>console.log("Horse B")</span></pre><p id="65d7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="77a1" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马B</li><li id="914f" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li></ol><p id="9316" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解释</strong></p><p id="c259" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个经典的面试问题。注意，除了现在<code class="fe ma mb mc md b">setTimeout</code>的持续时间是0毫秒而不是1000毫秒之外，这与比赛1的情况相同。大多数人错误地认为，既然<code class="fe ma mb mc md b">setTimeout</code>现在只需要0毫秒，那么在我们有机会移动到下一行之前，它的回调就会立即执行。他们忽略的事实是，JavaScript处理这些外部异步函数的方式实际上没有任何变化。<code class="fe ma mb mc md b">setTimeout</code>方法仍然被推送到调用堆栈，然后被发送到浏览器API，接着进入任务队列。在任务队列中，事件循环查看我们的调用堆栈，发现<code class="fe ma mb mc md b">console.log("Horse B")</code>已经被压入其中。因此，它不能从任务队列中出列马A(记住，只有当调用栈为空时，事件循环才会从任务队列中出列)，直到<code class="fe ma mb mc md b">console.log("Horse B")</code>已经被执行。</p><h1 id="b1c9" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">比赛3</h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="aaff" class="na mf iq md b gy nb nc l nd ne">setTimeout(() =&gt; console.log("Horse A"), 0);</span><span id="f23e" class="na mf iq md b gy nt nc l nd ne">wait60Seconds(); //some incredibly expensive synchronous computation</span><span id="605c" class="na mf iq md b gy nt nc l nd ne">console.log("Horse B")</span></pre><p id="4897" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="aca6" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马B</li><li id="94f7" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li></ol><p id="ad69" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解释</strong></p><p id="6f85" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可能会错误地认为由于<code class="fe ma mb mc md b">wait60Seconds</code>花费了很长的时间，那么<code class="fe ma mb mc md b">setTimeout</code>会在马B被打印之前完成并被推入堆栈。我希望现在已经很清楚，这种情况永远不会发生。在JavaScript中，同步操作<strong class="kz ir">总是</strong>优先。当有任何类型的同步函数被压入堆栈时，无论花费多长时间，事件循环都不会将异步操作出队。</p><h1 id="5b8c" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">比赛4</h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="5b91" class="na mf iq md b gy nb nc l nd ne">const asyncOperation = fetch('something.com');</span><span id="d3b0" class="na mf iq md b gy nt nc l nd ne">asyncOperation.then((resolvedValue) =&gt; console.log("Horse A"));</span><span id="a3a5" class="na mf iq md b gy nt nc l nd ne">console.log("Horse B")</span></pre><p id="ed8f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="073d" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马B</li><li id="80d2" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li></ol><p id="fc6f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解说</strong></p><p id="3336" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是人们经常犯的错误。一个常见的误解是，对Promise调用<code class="fe ma mb mc md b">.then</code>会导致JavaScript立即调用<code class="fe ma mb mc md b">.then</code>函数内部的函数。毕竟，在调用<code class="fe ma mb mc md b">console.log("Horse B")</code>之前，你显然可以访问<code class="fe ma mb mc md b">resolvedValue</code>，或者至少在我们的脚本中是这样的顺序。它甚至被命名为一旦你有了你的承诺对象，你就可以<em class="lw">然后</em>看到里面是什么。但这是误导。<code class="fe ma mb mc md b">.then</code>方法真的应该改名为<code class="fe ma mb mc md b">.wheneverThisValueGetsResolved</code>(可惜没那么性感)。</p><p id="c758" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">JavaScript真正做的是:当我们调用<code class="fe ma mb mc md b">fetch</code>时，我们得到一个承诺对象。这个承诺对象实际上有两个隐藏属性，<code class="fe ma mb mc md b">value</code>和<code class="fe ma mb mc md b">onFulfilled</code>。当我们将<code class="fe ma mb mc md b">fetch</code>推送到调用堆栈时，它被发送到浏览器API并在后台完成工作，类似于<code class="fe ma mb mc md b">setTimeout</code>方法。当它完成这项工作时，所有后续的同步操作都会像以前一样执行。</p><p id="6502" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是等等，在进入<code class="fe ma mb mc md b">console.log</code>之前，我们明确地调用了我们的承诺<code class="fe ma mb mc md b">.then</code>！嗯…这就是两个隐藏属性<code class="fe ma mb mc md b">value</code>和<code class="fe ma mb mc md b">onFulfilled</code>发挥作用的地方。</p><p id="2751" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们的后台操作完成后，它更新我们的承诺的<code class="fe ma mb mc md b">value</code>属性。发生这种情况时，该值会自动传递到<code class="fe ma mb mc md b">onFulfilled</code>属性中。好吧，但是<code class="fe ma mb mc md b">onFulfilled</code>有什么特别的？答案是，您传递给<code class="fe ma mb mc md b">.then</code>方法的函数实际上被推到了承诺的<code class="fe ma mb mc md b">onFulfilled</code>属性上。换句话说，<code class="fe ma mb mc md b">console.log("Horse A")</code>实际上被推到了我们承诺的<code class="fe ma mb mc md b">onFulfilled</code>属性上。当承诺最终实现时，(即，我们得到我们的值)，那么<code class="fe ma mb mc md b">onFulfilled</code>中的函数将被执行。这就是为什么<code class="fe ma mb mc md b">.then</code>真的应该被命名为<code class="fe ma mb mc md b">.wheneverThisValueGetsResolved</code>。</p><p id="0629" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">TL；DR:您在<code class="fe ma mb mc md b">.then</code>方法中编写的函数只有在承诺本身被解决时才会被执行。不要一接到电话就马上答应<code class="fe ma mb mc md b">.then</code>。</p><h1 id="f2bb" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">比赛5</h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="901a" class="na mf iq md b gy nb nc l nd ne">setTimeout(() =&gt; console.log("Horse A"), 0);</span><span id="a248" class="na mf iq md b gy nt nc l nd ne">const promise = Promise.resolve(); <br/>promise.then(() =&gt; console.log("Horse B"));</span><span id="2cec" class="na mf iq md b gy nt nc l nd ne">console.log("Horse C")</span></pre><p id="666f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="006c" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马C</li><li id="d271" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马B</li><li id="23d3" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li></ol><p id="39b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解释</strong></p><p id="1684" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">等等，什么？马B是怎么在马A之前完成的！？<code class="fe ma mb mc md b">setTimeout</code>明明跑在诺言被叫之前！WTF JavaScript？</p><p id="29b8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">基于我之前对JavaScript工作原理的解释，这些结果肯定是错误的。在引擎盖下，我们知道<code class="fe ma mb mc md b">setTimeout</code>被推到任务队列中，后面是承诺(我们知道队列如何工作),所以结果应该是马C、马A和马b。嗯……这实际上是错误的。</p><p id="40f9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我之前没有提到的是，实际上还有另一个队列叫做<strong class="kz ir">微任务队列</strong>(最初叫做<code class="fe ma mb mc md b">PromiseJobs</code>)专门管理承诺。您猜对了:这个队列优先于常规任务队列(有时通过V8称为宏任务队列)。确切地说，简化的算法看起来像这样:</p><ol class=""><li id="26ef" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">运行首先从任务队列(宏任务队列)中出列的任务</li><li id="a8e8" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">运行微任务队列中的所有任务</li><li id="86db" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">等待另一个宏任务出现在任务队列中</li><li id="9554" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">从步骤1开始重复</li></ol><p id="63d1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意，我们任务队列中的第一个宏任务实际上是整个脚本本身。例如:</p><p id="4727" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">步骤1:运行队列中的第一个宏任务。在这种情况下，脚本本身就是宏任务。这看起来有点像:执行<code class="fe ma mb mc md b">console.log("Horse C")</code>，0毫秒后将<code class="fe ma mb mc md b">setTimeout</code>排入宏任务队列，将<code class="fe ma mb mc md b">promise</code>排入微任务队列。</p><p id="9ffd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第二步:运行微任务队列中的所有内容。在我们的例子中，这是<code class="fe ma mb mc md b">promise</code>的<code class="fe ma mb mc md b">.then</code>方法中的函数，即:<code class="fe ma mb mc md b">() =&gt; console.log("Horse B")</code>。</p><p id="115c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">步骤3:看到宏任务队列中的第一个任务是<code class="fe ma mb mc md b">setTimeout</code>。</p><p id="18ff" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">步骤4:重复步骤1(运行现在从任务队列中出列的<code class="fe ma mb mc md b">setTimeout</code>方法)</p><h1 id="956a" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">第六场</h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="cc52" class="na mf iq md b gy nb nc l nd ne">setTimeout(() =&gt; console.log("Horse A"), 5)</span><span id="3199" class="na mf iq md b gy nt nc l nd ne">const promise = new Promise((resolve) =&gt; {<br/>   setTimeout(() =&gt; resolve(), 10) <br/>})<br/>promise.then(() =&gt; console.log("Horse B"))</span><span id="62bd" class="na mf iq md b gy nt nc l nd ne">console.log("Horse C")</span></pre><p id="a793" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="15cc" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马C</li><li id="4fd1" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li><li id="187f" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马B</li></ol><p id="e65f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解释</strong></p><p id="3779" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您弄错了，可能是因为您记得微任务队列优先于宏任务队列，也就是说，您认为马B将在马A之前完成，因为马B与一个承诺相关联。但是，请注意<code class="fe ma mb mc md b">setTimeout</code>在解决承诺之前5ms结束。这意味着当事件循环去检查微任务队列(步骤2)时，它将一无所获(持续10ms ),并在5ms后转移到宏任务队列，该队列上有<code class="fe ma mb mc md b">setTimeout</code>方法。</p><h1 id="8d1f" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">决赛</h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="f809" class="na mf iq md b gy nb nc l nd ne">setTimeout(() =&gt; console.log("Horse A"), 0);</span><span id="1858" class="na mf iq md b gy nt nc l nd ne">const promise = fetch("someUrl") // takes 100ms<br/>promise.then(x =&gt; console.log("Horse B"));</span><span id="aa1c" class="na mf iq md b gy nt nc l nd ne">waitFor200ms();<br/>console.log("Horse C");</span></pre><p id="2b40" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="4ffc" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马C</li><li id="cf0c" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马B</li><li id="026d" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li></ol><p id="9e6c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解说</strong></p><p id="120f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你答对了，你就是真正的神。这是一个受Will Sentance(CodeSmith的CEO和JavaScript:Hard Parts的讲师)启发的例子，我第一次看到它时就弄错了。</p><p id="2f84" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">乍一看，很像第六场比赛。唯一真正的区别是增加了<code class="fe ma mb mc md b">waitFor200ms</code>函数，理论上它作为同步函数在主线程上运行200毫秒。</p><p id="df43" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这次马B在马A之前完成的原因是，当在调用栈上执行<code class="fe ma mb mc md b">waitFor200ms</code>函数时，我们的<code class="fe ma mb mc md b">fetch</code>调用(花费100毫秒)已经被解析，并因此在当前一轮事件循环中被推到微任务队列上，即，在我们到达上述算法中的步骤2之前。然后，事件循环将执行微任务队列中的所有任务，然后移动到最新的宏任务，得到结果。</p><h1 id="ceec" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">有奖竞赛</h1><pre class="kh ki kj kk gt mw md mx my aw mz bi"><span id="1b46" class="na mf iq md b gy nb nc l nd ne">async function someFn() {<br/>  const promise = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; resolve("Horse A"), 1000)<br/>  });<br/> <br/>  let result = await promise; <br/>  console.log(result); <br/>}</span><span id="6078" class="na mf iq md b gy nt nc l nd ne">setTimeout(console.log("Horse B"), 0)<br/>someFn();<br/>console.log("Horse C");</span></pre><p id="e0cf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">结果</strong></p><ol class=""><li id="705e" class="nf ng iq kz b la lb ld le lg nh lk ni lo nj ls nk nl nm nn bi translated">马B</li><li id="9643" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马C</li><li id="4ab2" class="nf ng iq kz b la no ld np lg nq lk nr lo ns ls nk nl nm nn bi translated">马A</li></ol><p id="f184" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">解释</strong></p><p id="1d21" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">啊，我骗了你！注意，<code class="fe ma mb mc md b">setTimeout</code>方法是直接执行<code class="fe ma mb mc md b">console.log("Horse B")</code>，而不是采用回调函数(即<code class="fe ma mb mc md b">() =&gt; console.log("Horse B")</code>)。我想我会把这个放在这里，因为我经常看到一些开发人员(包括我自己)犯这个小错误。</p><p id="a6e1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，<code class="fe ma mb mc md b">async/await</code>会让事情变得更好。可以理解，你可能会认为我们将在记录马C之前“等待”马A完成，但是同样地，<strong class="kz ir">同步代码将总是获得优先级</strong>。</p><h1 id="dc0f" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="d544" class="pw-post-body-paragraph kx ky iq kz b la nu jr lc ld nv ju lf lg nw li lj lk nx lm ln lo ny lq lr ls ij bi translated">恭喜你，你让我的唠叨结束了！如果你猜对了所有比赛的结果，那么恭喜你，你是一个比我好得多的开发者！</p><p id="efe8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">无论如何，我希望你从这篇文章中学到了一些东西，或者至少练习了你的JavaScript技能。感谢您的阅读！</p><p id="7359" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">订阅我们的YouTube频道</strong> </a> <strong class="kz ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>