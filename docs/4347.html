<html>
<head>
<title>How To Create Your Own Debounce Function in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在反应中创建自己的去抖函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/debounce-in-javascript-7715d4266542?source=collection_archive---------0-----------------------#2020-12-05">https://javascript.plainenglish.io/debounce-in-javascript-7715d4266542?source=collection_archive---------0-----------------------#2020-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e083" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中的去抖</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f38bd0972b8889421dbc7b86313f52a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9h-wdzRAydBaNY7i"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@kevinmueller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Mueller</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e434" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，2020年12月5日，JavaScript庆祝了它的25岁生日，我想解释一下JavaScript开发者应该知道的最重要的话题之一,<strong class="kv io">去抖</strong>函数。</p><h1 id="0f98" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">什么是去抖功能？</h1><p id="41de" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated"><strong class="kv io">去抖</strong>(<strong class="kv io">功能</strong>强制<strong class="kv io">功能</strong>等待一定时间后再运行。<strong class="kv io">函数</strong>的建立是为了限制<strong class="kv io">函数</strong>被调用的次数。</p><h2 id="800f" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">但这有什么帮助呢？</h2><p id="9493" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了理解这一点，让我们举一个自动完成或提前键入的例子。(我们将在本文中构建自己的自动完成)。</p><p id="dbe6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，假设你有一个自动完成功能，现在为了显示下拉选项，你必须在每次击键时启动一个API。因此，如果我需要在自动完成中搜索“<em class="my">中的文章</em>”，我们将触发大约14个API调用。这有效率吗？一点也不。但是接下来如何解决这个问题呢？这时<strong class="kv io">去抖</strong>进入画面。</p><p id="4593" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过使用去抖功能，我们只在用户键入时有时间延迟时触发一个API。如果我们给一个300毫秒的延迟，一个用户花大约相同的时间或更多的时间来输入下一个字母或单词，我们就触发一个API。</p><p id="699c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这大大减少了API调用的数量，并使我们的代码更加高效。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/92edd5a6bc048785bc94e7e18a58debb.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*KIllpT5DNld8VyywjxRO0w.png"/></div></figure><h1 id="024f" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">创建我们的项目。</h1><p id="c906" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">让我们首先构建一个自动完成的项目，在每次击键时调用API，然后使用我们自己的<strong class="kv io">自定义去抖</strong>函数对其进行改进。最后，我们还将了解如何使用由<strong class="kv io"> lodash </strong>提供给我们的内置<strong class="kv io">去抖</strong>功能。</p><h1 id="9e09" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">后端代码</h1><p id="b6f0" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为此，我使用<strong class="kv io">节点</strong>创建了一个简短的后端，根据提供的查询参数(“搜索字符串”)为我们提供单词。您也可以为同样的目的使用一些免费的API。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="7d4e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">反应代码</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e634" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这只是一个简单的代码，我们在每一个按键上调用API，我们的<code class="fe nc nd ne nf b">input</code>的<code class="fe nc nd ne nf b">onChange</code></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/d552084ec39502f1ab01a2ec973a9789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWo1KfZX4AzV9qqP4rW8xg.png"/></div></div></figure><h1 id="3d24" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">创建我们自己的去抖功能</h1><p id="8f23" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在有趣的部分来了。我们将首先构建我们自己的<code class="fe nc nd ne nf b">debounceFunction</code>。<br/> <em class="my">有一点要记住，这个函数应该返回一个函数。</em> <br/>我们的<code class="fe nc nd ne nf b">debounceFunction</code>将接受两个参数，第一个是延迟时需要调用的函数(在我们的例子中是<code class="fe nc nd ne nf b">getDropDown</code>函数)，第二个是调用该函数的延迟量。(两次按键事件之间的延迟)<br/>现在我们不直接调用<code class="fe nc nd ne nf b">getDropDown</code>函数，而是等待延迟时间。这可以通过使用<code class="fe nc nd ne nf b">setTimeout()</code>来实现</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c864" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，为了修复<code class="fe nc nd ne nf b">this</code>的上下文并将参数传递给我们的函数<code class="fe nc nd ne nf b">getDropDown,</code>，我们应该用apply调用<code class="fe nc nd ne nf b">getDropDown</code>函数。</p><p id="54f2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，为了停止一次又一次地调用我们的函数，我们必须清除超时。我们最终的<code class="fe nc nd ne nf b">debounceFunction</code>应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f1b0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以现在在我们的<code class="fe nc nd ne nf b">onInputChangeHandler</code>上我们可以调用我们的<code class="fe nc nd ne nf b">debounceFunction</code>。</p><pre class="kd ke kf kg gt nh nf ni nj aw nk bi"><span id="0d22" class="mm lq in nf b gy nl nm l nn no">const onInputChangeHandler = (e) =&gt; {<br/>    const nextValue = e.target.value<br/>    setSearchString(nextValue);<br/>    const debounceDropdown = debounceFunction(getDropDown , 1000);<br/>    debounceDropdown();<br/>}</span></pre><h2 id="45d7" class="mm lq in bd lr mn mo dn lv mp mq dp lz lc mr ms mb lg mt mu md lk mv mw mf mx bi translated">但是现在这行得通吗？</h2><p id="f02e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">答案是否定的。因为每当我们调用<code class="fe nc nd ne nf b">onInputChangeHandler</code>时，我们都在创建一个新的<code class="fe nc nd ne nf b">debounceFunction</code>，它将在每次击键时被调用，而且因为我们每次都在调用新的<code class="fe nc nd ne nf b">debounceFunction</code>，我们正在丢失对旧的<code class="fe nc nd ne nf b">debounceFunction</code>的引用，这就是为什么它会丢失它的值。</p><p id="6101" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了解决这个问题，我们需要使用<a class="ae ks" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">回调</strong> </a>钩子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0487" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这应该能解决我们的问题。现在，一旦有1秒钟的延迟，我们将调用API。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/c2124a132fe5ea19d8a590d9ddc04725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeHXmRpAz53ol5TK2V2DHQ.png"/></div></div></figure><h1 id="0e0e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">使用lodash去抖</h1><p id="00b3" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在，除了从头开始创建一个去抖功能，还可以直接从<a class="ae ks" href="https://www.npmjs.com/package/lodash.debounce" rel="noopener ugc nofollow" target="_blank"> lodash包</a>中使用它</p><p id="45f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为此，首先使用</p><pre class="kd ke kf kg gt nh nf ni nj aw nk bi"><span id="31b7" class="mm lq in nf b gy nl nm l nn no">npm i --save lodash.debounce</span></pre><p id="eb88" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后我们将它导入到我们的App.js中</p><pre class="kd ke kf kg gt nh nf ni nj aw nk bi"><span id="2fb9" class="mm lq in nf b gy nl nm l nn no">import debounce from 'lodash.debounce';</span></pre><p id="0d0b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，你可以使用<strong class="kv io"> lodash </strong>提供的<strong class="kv io">去抖</strong>，而不是在<strong class="kv io"> useCallback </strong>中添加我们的自定义函数。</p><pre class="kd ke kf kg gt nh nf ni nj aw nk bi"><span id="dac2" class="mm lq in nf b gy nl nm l nn no">const debounceDropDown = useCallback(debounce((nextValue) =&gt; getDropDown(nextValue), 1000), [])</span></pre><p id="d10b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们的App.js应该是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="2397" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="5f52" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们现在已经了解了什么是<strong class="kv io">去抖</strong>功能，以及如何创建自定义去抖功能。还有一个类似的概念叫做<strong class="kv io">油门。在我的下一篇文章中，我将尝试解释Throttle是什么以及如何在一个场景中实现它。</strong></p></div></div>    
</body>
</html>