<html>
<head>
<title>Creating a React app without create-react-app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不使用create-react-app创建React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/to-beginners-moving-away-from-create-react-app-f597413181e?source=collection_archive---------2-----------------------#2020-09-16">https://javascript.plainenglish.io/to-beginners-moving-away-from-create-react-app-f597413181e?source=collection_archive---------2-----------------------#2020-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="66c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将Webpack和React放在一起</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be6a7e600d453e2ec63b10365e5be221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhRQZPTXdq88SSjl2xf4fQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by <a class="ae kv" href="https://www.pexels.com/@antonio-batinic-2573434?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Antonio Batinić</a></figcaption></figure><p id="1e45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将在没有<strong class="ky ir"> create-react-app </strong>库的情况下从头创建一个React应用程序，以便理解它在本质上是如何工作的。我们将使用<strong class="ky ir"> Webpack </strong>作为这个项目的模块捆绑器。当我需要在项目中实现它时，我会解释一切。</p><p id="a9b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，克隆我创建的<a class="ae kv" href="https://github.com/sapinder-pal/React-Webpack-Starter/tree/starter-files" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">资源库</em></strong></a><strong class="ky ir"><em class="ls"/></strong>，其中包含了最少starter文件的<strong class="ky ir"> <em class="ls"> src </em> </strong>文件夹。完成后，在代码编辑器中打开文件夹；还有<strong class="ky ir">确定你在</strong> <code class="fe lt lu lv lw b">starter-files</code> <strong class="ky ir">分支。</strong></p><h1 id="8703" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">1.初始化NPM</h1><p id="2024" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">运行项目根目录下的<strong class="ky ir"> </strong> <code class="fe lt lu lv lw b">npm init -y</code>。它应该创建一个<strong class="ky ir"> <em class="ls"> package.json </em> </strong>文件，如下所示-</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="24ba" class="my ly iq lw b gy mz na l nb nc">C:\Users\sapin\Desktop\react-webpack-starter&gt;npm init -y<br/>Wrote to C:\Users\sapin\Desktop\react-webpack-starter\package.json:</span><span id="7fc9" class="my ly iq lw b gy nd na l nb nc">{<br/> “name”: “react-webpack-starter”,<br/> “version”: “1.0.0”,<br/> “description”: “”,<br/> “main”: “index.js”,<br/> “scripts”: {<br/> “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1"<br/> },<br/> “keywords”: [],<br/> “author”: “”,<br/> “license”: “ISC”<br/>} </span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="b484" class="lx ly iq bd lz ma nl mc md me nm mg mh jw nn jx mj jz no ka ml kc np kd mn mo bi translated">对Webpack的需求</h1><p id="bf42" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们首先需要的是<strong class="ky ir">而不是</strong><strong class="ky ir">react</strong>库，而是一个<strong class="ky ir">模块捆绑器</strong>，它将扫描我们的项目文件并将它们捆绑在一起。但是在将代码捆绑在一起之前，<a class="ae kv" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Webpack </strong> </a>使用我们提供的工具来理解文件中的内容。放心吧！稍后我们将详细讨论它。</p><p id="d09c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Webpack <strong class="ky ir"> </strong>将通过获取<strong class="ky ir"> <em class="ls"> src/index.js </em> </strong>文件来开始它的工作，因为这是我们在配置它时指定的<strong class="ky ir"> <em class="ls">入口点</em> </strong>。所以让我们直接进入主题-</p><p id="9d11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要Webpack中的以下库来处理它-</p><p id="4515" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答:webpack: 它是Webpack bundler的核心库。</p><p id="b280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> b. webpack-cli: </strong>如果你在使用<strong class="ky ir"> create-react-app </strong>的时候看一下<strong class="ky ir"> <em class="ls"> package.json </em> </strong>里面，你会发现下面的脚本-</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="8d4c" class="my ly iq lw b gy mz na l nb nc">"scripts": {    <br/>    "start": "react-scripts start",    <br/>    "build": "react-scripts build"<br/>}</span></pre><p id="1806" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> react-scripts </strong>是一个定制库，它使用webpack的命令行接口来运行任何命令，比如- <code class="fe lt lu lv lw b">npm start</code> <strong class="ky ir">。</strong>在这个设置中，我们将从<em class="ls">raw</em>web pack-CLI运行命令。</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="7329" class="my ly iq lw b gy mz na l nb nc">"scripts": {    <br/>    "start": "webpack-dev-server --mode development",    <br/>    "build": "webpack --mode production",  <br/>}</span></pre><p id="03c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> c. webpack-dev-server: </strong>您已经在上面的<code class="fe lt lu lv lw b"><strong class="ky ir">start</strong></code>脚本中看到了这个库的用法。在<strong class="ky ir"> <em class="ls">开发模式</em> </strong>中使用，在浏览器中提供捆绑文件。[ <em class="ls">例如</em><strong class="ky ir"><em class="ls">localhost:3000</em></strong>]</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="0318" class="lx ly iq bd lz ma nl mc md me nm mg mh jw nn jx mj jz no ka ml kc np kd mn mo bi translated">2.设置Webpack</h1><p id="53ff" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先，在控制台中运行以下命令。<code class="fe lt lu lv lw b">--save-dev</code> <strong class="ky ir"> </strong>或<code class="fe lt lu lv lw b">-D</code> <strong class="ky ir"> </strong>标志用于将它们安装为<strong class="ky ir"> <em class="ls">开发依赖</em> </strong> <em class="ls">。</em></p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="99bc" class="my ly iq lw b gy mz na l nb nc">npm install --save-dev webpack webpack-cli webpack-dev-server</span></pre><p id="a53e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在<strong class="ky ir"> <em class="ls"> package.json </em> </strong>文件内添加上述脚本<em class="ls"> </em>。</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="3509" class="my ly iq lw b gy mz na l nb nc">"scripts": {    <br/>    "start": "webpack-dev-server --mode development <strong class="lw ir">--open --hot</strong>",    <br/>    "build": "webpack --mode production",  <br/>}</span></pre><p id="7f1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新高亮显示的<strong class="ky ir"> <em class="ls">标志</em></strong><em class="ls"/><code class="fe lt lu lv lw b">--open</code><em class="ls"/>和<code class="fe lt lu lv lw b">--hot</code>分别做如下操作:</p><ul class=""><li id="8211" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">服务器启动后，自动在浏览器中打开应用程序</li><li id="8444" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">每当服务器代码发生变化时，自动在浏览器中重新加载应用程序</li></ul><p id="8215" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们的项目文件夹中有以下内容-</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/786966825a5f7dcef019783799971888.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*C5DVOpJlLACZh2WfIZOmMA.png"/></div></figure><p id="7e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们通过在文件夹的根目录下创建一个文件<strong class="ky ir"><em class="ls">webpack . config . js</em></strong>来配置web pack。把下面的东西加进去-</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="8de0" class="my ly iq lw b gy mz na l nb nc">module.exports = {<br/>  entry: {<br/>    index: './src/index.js'<br/>  },<br/>  output: {<br/>    path: __dirname + '/build',<br/>    filename: 'index.bundle.js'<br/>  }<br/>}</span></pre><p id="094e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">module.exports</code>内的所有内容都作为webpack的配置导出。</p><p id="6712" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> a. </strong> <code class="fe lt lu lv lw b"><strong class="ky ir">entry</strong></code> <strong class="ky ir"> : </strong>我们在这里指定webpack应该查找的文件，以启动捆绑过程。</p><p id="82c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> b. </strong> <code class="fe lt lu lv lw b"><strong class="ky ir">output</strong></code> <strong class="ky ir"> : </strong>将放置捆绑文件的目录。在我们的例子中，我们只有一个名为<code class="fe lt lu lv lw b">index</code>的<strong class="ky ir"> <em class="ls">单入口点</em> </strong>，因此输出应该只生成一个<strong class="ky ir"> <em class="ls">单捆绑文件</em></strong>(<strong class="ky ir"><em class="ls">index . bundle . js</em></strong>)。让我们看看它的特性-</p><ul class=""><li id="a5c1" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><code class="fe lt lu lv lw b"><strong class="ky ir">path</strong></code> <strong class="ky ir"> : </strong>输出目录路径。<br/> ( <code class="fe lt lu lv lw b">__dirname</code> <strong class="ky ir"> [ </strong>当前工作路径<em class="ls">，即</em><em class="ls"/><strong class="ky ir"><em class="ls">根目录</em></strong><strong class="ky ir"/><strong class="ky ir">+</strong><code class="fe lt lu lv lw b">/build</code><em class="ls"/>)。</li><li id="ff03" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe lt lu lv lw b"><strong class="ky ir">filename</strong></code> <strong class="ky ir"> : </strong>捆绑文件的名称。(<strong class="ky ir"> <em class="ls"> index.bundle.js </em> </strong></li></ul><p id="7333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在安装<strong class="ky ir"> html-webpack-plugin </strong>，它将拾取<strong class="ky ir"><em class="ls">src/index . html</em></strong>，并在<strong class="ky ir"> <em class="ls"> /build </em> </strong>文件夹中创建一个html <strong class="ky ir"> <em class="ls"> </em> </strong>文件，放置与<strong class="ky ir"><em class="ls">src/index . html</em></strong>相同的内容。</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="3f74" class="my ly iq lw b gy mz na l nb nc">npm install --save-dev html-webpack-plugin</span></pre><p id="2272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<strong class="ky ir"><em class="ls">web pack . config . js</em></strong>更新为以下内容-</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="5101" class="my ly iq lw b gy mz na l nb nc"><strong class="lw ir">const HTMLWebpackPlugin = require('html-webpack-plugin');</strong></span><span id="b2cd" class="my ly iq lw b gy nd na l nb nc">module.exports = {<br/>  entry: {<br/>    index: './src/index.js'<br/>  },<br/>  output: {<br/>    path: __dirname + '/build',<br/>    filename: 'index.bundle.js'<br/>  },<br/>  <strong class="lw ir">plugins: [<br/>    new HTMLWebpackPlugin({<br/>      template: './src/index.html'<br/>    })<br/>  ]</strong><br/>}</span></pre><p id="3a0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">它所做的只是- </strong></p><ol class=""><li id="55ef" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr of nw nx ny bi translated"><strong class="ky ir">要求</strong>把<code class="fe lt lu lv lw b">html-webpack-plugin</code></li><li id="fdc1" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr of nw nx ny bi translated"><strong class="ky ir">将</strong>添加到<code class="fe lt lu lv lw b">plugins</code>数组中，一个名为<code class="fe lt lu lv lw b">HTMLWebpackPlugin</code>的新插件，并向其传递将用作<strong class="ky ir"><em class="ls"/></strong><strong class="ky ir"><em class="ls">模板的源文件，以在构建目录中创建新的html文件。</em>T45】</strong></li></ol><p id="2b17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备好对付<strong class="ky ir">巴贝尔</strong>和<strong class="ky ir">反应/JSX </strong>。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="fe86" class="lx ly iq bd lz ma nl mc md me nm mg mh jw nn jx mj jz no ka ml kc np kd mn mo bi translated">什么是装载机？</h1><p id="1fb6" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">事实是，除了<strong class="ky ir"> html </strong> &amp; <strong class="ky ir"> js </strong>文件类型之外，Webpack实际上对<strong class="ky ir"> <em class="ls"> /src </em> </strong>文件夹中有哪些文件以及这些文件的用途一无所知。</p><p id="97bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">又来了一个<a class="ae kv" href="https://webpack.js.org/loaders/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">装载机</strong> </a>的角色。加载程序充当特定文件类型的<strong class="ky ir"><em class="ls"/></strong><em class="ls"/>预处理器。当Webpack遇到任何新的文件类型时，它会在其配置中查找加载程序，并将文件处理给该加载程序。<br/>为该文件类型配置的加载程序将执行其魔法，并将该代码的传输版本返回给Webpack，web pack随后继续捆绑过程。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="a6b2" class="lx ly iq bd lz ma nl mc md me nm mg mh jw nn jx mj jz no ka ml kc np kd mn mo bi translated">巴别塔的需要</h1><p id="8be3" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Webpack不理解我们用来编写的现代JavaScript代码。它只理解ES2015之前的代码。但是我们可以用巴别塔来做这项工作。<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Babel </strong> </a>是一个JavaScript编译器，将现代JavaScript代码转换成它的向后兼容版本。它也能改变JSX并做出反应。<strong class="ky ir"> <em class="ls">而这正是我们这里实际需要的</em> </strong>！😄</p><p id="baea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是我们实现巴别塔所需的<em class="ls">依赖</em> / <em class="ls">库</em></p><ul class=""><li id="19c1" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><strong class="ky ir"> @babel/core: </strong>是巴别塔的核心库。</li><li id="ae29" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><strong class="ky ir"> @babel/preset-env: </strong>这个预置是一个babel插件的集合，根据我们在配置中指定的环境/目标浏览器来转换现代JavaScript代码。</li><li id="2a84" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><strong class="ky ir"> @babel/preset-react: </strong>这个预置是将<strong class="ky ir"> JSX </strong>语法转换成我们需要的实际JavaScript代码的那个。</li><li id="76a4" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><strong class="ky ir"> babel-loader: </strong>这个应该在上面的依赖项之前提到。如果我们想使用上面的三个东西，我们必须有babel-loader，这样它才能在Webpack进一步工作之前<em class="ls">预处理</em>特定的文件类型(在本例中是<strong class="ky ir"> js/jsx </strong>)。</li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="4924" class="lx ly iq bd lz ma nl mc md me nm mg mh jw nn jx mj jz no ka ml kc np kd mn mo bi translated"><strong class="ak"> 3。建立巴别塔</strong></h1><p id="b044" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">像前面一样运行带有<code class="fe lt lu lv lw b">--save-dev</code>标志的以下命令-</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="7b0d" class="my ly iq lw b gy mz na l nb nc">npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/preset-react</span></pre><p id="2e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir"><em class="ls">web pack . config . js</em></strong>中的“module.exports”对象中添加“module”属性-</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="a218" class="my ly iq lw b gy mz na l nb nc">module: {<br/>  rules: [<br/>    {<br/>      test: /\.js|\.jsx$/,<br/>      exclude: /node_modules/,<br/>      use: 'babel-loader'<br/>    }<br/>  ]<br/>}</span></pre><p id="0750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“规则”数组中的每个对象为不同类型的文件指定规则。让我们检查规则属性-</p><ul class=""><li id="5b1e" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><code class="fe lt lu lv lw b"><strong class="ky ir">test</strong></code> <strong class="ky ir"> : </strong>需要一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">正则表达式</strong> </a>来查找文件类型。</li><li id="b38e" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe lt lu lv lw b"><strong class="ky ir">exclude</strong></code> <strong class="ky ir"> : </strong>正如你所猜测的，它限制<em class="ls">加载器</em>对于相应的文件类型不能进入指定的目录<em class="ls">。</em></li><li id="0b5a" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe lt lu lv lw b"><strong class="ky ir">use</strong></code> <strong class="ky ir"> : </strong>该属性告诉Webpack对上述文件类型<em class="ls">使用<strong class="ky ir"/><em class="ls"/>。</em></li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="b721" class="lx ly iq bd lz ma nl mc md me nm mg mh jw nn jx mj jz no ka ml kc np kd mn mo bi translated">到目前为止你应该明白的是-</h1><ul class=""><li id="77f5" class="nq nr iq ky b kz mp lc mq lf og lj oh ln oi lr nv nw nx ny bi translated">Webpack在我们点击<code class="fe lt lu lv lw b">npm run start</code>(简称<code class="fe lt lu lv lw b">npm start</code>)时寻找入口点(<strong class="ky ir"><em class="ls">/src/index . js</em></strong>)。</li><li id="6faf" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">当遇到扩展名为<strong class="ky ir"> js/jsx </strong>的文件时，它会在其配置中查找任何相应的加载程序。如果找到一个，它就把文件处理给那个加载器<strong class="ky ir">；</strong> else抛出错误。</li></ul><p id="a7d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Webpack将<strong class="ky ir"> <em class="ls"> index.js </em> </strong>交给<em class="ls"> babel-loader </em>之后，加载器会寻找自己的配置。所以我们来一个吧！</p><p id="cef3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新的<strong class="ky ir"> <em class="ls">。根目录下的babelrc </em> </strong>文件，并添加我们用于babel的<code class="fe lt lu lv lw b">presets</code></p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="7914" class="my ly iq lw b gy mz na l nb nc">{<br/>  "presets": ["@babel/preset-env", "@babel/preset-react"]<br/>}</span></pre><blockquote class="oj ok ol"><p id="cc4e" class="kw kx ls ky b kz la jr lb lc ld ju le om lg lh li on lk ll lm oo lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">注意:</em> </strong>任何<code class="fe lt lu lv lw b">loaders</code>数组以及Webpack中的<code class="fe lt lu lv lw b">presets</code>数组总是以相反的顺序工作，即在上面的例子中，<strong class="ky ir"> @babel/preset-react </strong>将首先用于<strong class="ky ir">解释</strong><strong class="ky ir">JSX</strong>代码，然后<strong class="ky ir"> @babel/preset-env </strong>将开始将代码转换成向后兼容的版本。</p></blockquote><p id="8595" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们的Webpack设置能够解释和转换<strong class="ky ir"> JSX </strong> <em class="ls"> </em>代码，让我们实际安装<strong class="ky ir"> react </strong> <em class="ls"> </em>和<em class="ls"/><strong class="ky ir">react-DOM</strong><em class="ls"/>库吧！</p><pre class="kg kh ki kj gt mu lw mv mw aw mx bi"><span id="c3e6" class="my ly iq lw b gy mz na l nb nc">npm install react react-dom</span></pre><p id="2a42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我没有使用<code class="fe lt lu lv lw b">--save-dev</code>，因为这些依赖项在<strong class="ky ir"> <em class="ls">开发</em> </strong>和<strong class="ky ir"> <em class="ls">生产</em> </strong>模式中都有使用。</p><p id="c2ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可以在你的项目文件中<code class="fe lt lu lv lw b">import</code> <strong class="ky ir"> react </strong>和<strong class="ky ir"> react-dom </strong>，并开始使用<strong class="ky ir"> JSX </strong>！<br/>而如果你运行<code class="fe lt lu lv lw b">npm start</code>，它应该会启动<strong class="ky ir"><em class="ls">webpack-dev-server</em></strong>，在web pack完成捆绑过程后自动在你的浏览器中打开app。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="bd7a" class="lx ly iq bd lz ma nl mc md me nm mg mh jw nn jx mj jz no ka ml kc np kd mn mo bi translated"><strong class="ak">宾果！！！但是等等… </strong></h1><p id="02a0" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">尽管我们做了以上所有的事情，我们仍然被限制在我们的项目中不使用js/jsx <em class="ls"> </em>之外的任何文件类型，因为<strong class="ky ir"> <em class="ls">我们必须指定loader</em></strong><em class="ls">【s】</em><strong class="ky ir"><em class="ls">用于</em> </strong> <em class="ls"> </em> <strong class="ky ir"> <em class="ls">每个</em> </strong> <em class="ls"> </em> <strong class="ky ir"/></p><p id="fc22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些常用的加载器有:<strong class="ky ir"> css-loader、sass-loader、url-loader、file-loader等。</strong>你应该知道如何使用这里  列出的<a class="ae kv" href="https://webpack.js.org/loaders/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ls">的一些装载机。</em></strong></a></p><p id="9052" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的库的<code class="fe lt lu lv lw b">complete </code>分支中，我添加了对更多东西的支持，比如<strong class="ky ir"> sass、eslint </strong>、<strong class="ky ir"> image-files </strong>、<strong class="ky ir">postcss-loader</strong>with<strong class="ky ir">autoprefixer</strong>、<strong class="ky ir"> file-loader </strong>、<strong class="ky ir"> url-loader </strong>等等。</p><p id="1d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，您应该对React和Webpack如何协同工作有了很好的理解。</p><p id="1677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢我的写作风格，你可以关注我，永远不要错过我未来的任何帖子。你也可以在<a class="ae kv" href="https://twitter.com/sapinder_dev" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kv" href="https://github.com/sapinder-pal" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae kv" href="https://www.linkedin.com/in/sapinder-singh/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上查看我。</p></div></div>    
</body>
</html>