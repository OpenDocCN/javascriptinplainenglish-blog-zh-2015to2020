<html>
<head>
<title>Best of Modern JavaScript — Catches for Classes and Module Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最佳现代JavaScript——捕捉类和模块基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-catches-for-classes-and-module-basics-8d09153383a6?source=collection_archive---------8-----------------------#2020-10-17">https://javascript.plainenglish.io/best-of-modern-javascript-catches-for-classes-and-module-basics-8d09153383a6?source=collection_archive---------8-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/39dba4590de16d696b6c385c59070c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K_96ibW7K5plZ2KQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">National Cancer Institute</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="94e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用JavaScript定义类。</p><h1 id="40d4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单一遗传</h1><p id="c1e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只能用<code class="fe me mf mg mh b">extends</code>关键字继承一个类。</p><p id="3ef3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以从现有的类中生成一个新的类，并继承它。</p><p id="fb69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为<code class="fe me mf mg mh b">extends</code>接受一个返回构造函数的表达式。</p><h1 id="1d9d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类别锁定</h1><p id="86e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们想实例化一个类，我们被迫在ES6中使用<code class="fe me mf mg mh b">new</code>关键字。</p><p id="64ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着从一个类切换到一个工厂函数将意味着我们必须从现有代码中移除<code class="fe me mf mg mh b">new</code>关键字。</p><p id="2d8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以通过用<code class="fe me mf mg mh b">constructor</code>返回我们自己的对象来覆盖构造函数返回的内容。</p><p id="2074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块系统和类语法也使得重构JavaScript代码比以前容易得多。</p><h1 id="edc1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类不能作为函数调用</h1><p id="6b61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类不能作为函数调用，即使它们是底层的函数。</p><p id="1ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为将来添加用类处理函数调用的方法提供了选择。</p><h1 id="e555" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">给定一个参数数组实例化一个类</h1><p id="4e5b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以让我们的类构造函数用rest语法接受一个参数数组。</p><p id="cefa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de4c" class="mq lc iq mh b gy mr ms l mt mu">class Foo {<br/>  constructor(...args) {<br/>    //...<br/>  }<br/>}</span></pre><p id="2697" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过运行以下命令来实例化它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="386a" class="mq lc iq mh b gy mr ms l mt mu">new Foo(...args);</span></pre><p id="3b4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">args</code>是一个参数数组。</p><p id="9743" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用spread操作符将参数作为参数传播到<code class="fe me mf mg mh b">args</code>数组中。</p><p id="de16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以随心所欲地使用它们。</p><p id="1a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用<code class="fe me mf mg mh b">Reflect.construct</code>方法创建一个带有参数数组的类实例。</p><p id="957b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e552" class="mq lc iq mh b gy mr ms l mt mu">`const foo = Reflect.construct(Foo, ['foo', 'bar']);</span></pre><p id="d7ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将类或构造函数作为第一个参数传入，将构造函数的一组参数作为第二个参数传入。</p><h1 id="8794" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模块</h1><p id="c28c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript在ES6之前没有本机模块系统。</p><p id="334b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，有许多模块系统被实现为库。</p><p id="1f3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6模块可以在浏览器和Node.js中访问。</p><p id="b5de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在浏览器中，我们添加一个类型属性设置为<code class="fe me mf mg mh b">module</code>的脚本标签来导入一个模块。</p><p id="e780" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，模块处于严格模式。</p><p id="1db9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顶层值os <code class="fe me mf mg mh b">this</code>是模块的本地值。</p><p id="0d89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块是异步执行的。</p><p id="2149" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还提供了<code class="fe me mf mg mh b">import</code>关键字来导入模块项目。</p><p id="3249" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序导入也是可用的。</p><p id="8fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">import</code>函数返回一个承诺，该承诺用模块的内容解析为一个对象。</p><p id="adc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块的文件扩展名仍然是<code class="fe me mf mg mh b">.js</code>。</p><p id="e309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与旧式脚本不同。</p><p id="9d68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除非另外指定，否则脚本是同步运行的。</p><p id="c60c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且它们默认为非严格模式。</p><p id="83f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，它们可以异步导入。</p><p id="77a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个模块都是一段代码，一旦加载就会运行。</p><p id="a854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个模块中，可能有各种类型的声明，如函数、类、对象等。</p><p id="8139" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个模块也可以从其他模块导入东西。</p><p id="b31f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以用相对路径如<code class="fe me mf mg mh b">'./foo/bar'</code>或绝对路径如<code class="fe me mf mg mh b">'/foo/bar'</code>导入。</p><p id="6681" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块是单例的，所以模块的所有导入都是相同的。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/382d6627a61fb3b9c5c83a335760b4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UxIR1-uH7ceRmQg_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@raubfisch24de?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">www.raubfisch24.de</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="09f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7bad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类不能作为函数调用。</p><p id="8767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用一组参数来实例化它们。</p><p id="1b0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块有助于将代码分成更小的块。</p><p id="add2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>