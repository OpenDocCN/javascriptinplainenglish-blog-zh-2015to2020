<html>
<head>
<title>JavaScript Data Structures: Option</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数据结构:选项</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-structures-option-965705a903f5?source=collection_archive---------9-----------------------#2020-10-21">https://javascript.plainenglish.io/data-structures-option-965705a903f5?source=collection_archive---------9-----------------------#2020-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e742" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优雅地处理Null和Undefined</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/489b1141314f7750e61e65d24dd8f95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ocgP5zHVOoSMu55E"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Some / None. (Photo by <a class="ae kv" href="https://unsplash.com/@jasmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Jasmund</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a>)</figcaption></figure><p id="915d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在与单子相关的文章中已经写了很多关于期权数据结构的内容。但是根据我关于数据结构的系列文章，除了与Monad的关系之外，Option应该有自己的完整文章。在这篇文章中，我们将放弃所有的单子论，只理解选项是什么。</p><p id="6781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们来讨论一下<code class="fe ls lt lu lv b">null</code>和<code class="fe ls lt lu lv b">undefined</code>值。假设我们正在检查一个对象，这个对象可能是我们从JSON中解析出来的，JSON来自我们正在开发的应用程序的后端。我们接收到的对象由于某种原因有不同的模式，所以有时我们会有意想不到的<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>值给我们的客户端造成严重破坏。选项很可能是这个问题的解决方案！</p><p id="3f3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该选项是一种特殊类型的容器，由两个<em class="lw">变体组成。</em>这意味着一个选项的实例可以存在于两种状态之一(变量)。我们称这两种变体<em class="lw">有</em>和<em class="lw">无</em>。<em class="lw">有的</em>代表容器中的一个当前值的状态，而<em class="lw">无的</em>代表一个空容器。无论您的选项实例处于什么状态，它都不会抛出任何<code class="fe ls lt lu lv b">null</code>或<code class="fe ls lt lu lv b">undefined</code>值。这是选项数据部分的核心:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/c099a600542222b45047bbee2ebbfe3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjvYV_xgAj9-Oje-hfj10w.png"/></div></div></figure><p id="426c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢用符号来隐藏选项的内部值(我写的其他容器也是如此)。我选择了构造函数方法，允许我们使用<code class="fe ls lt lu lv b">new</code>关键字创建一些或没有实例。您可以看到，有些需要一个值，而没有一个不需要。<code class="fe ls lt lu lv b">TAG</code>符号用于快速识别某个或某个实例。我还将一些核心函数打包到Option namespace对象中。最值得注意的，<code class="fe ls lt lu lv b">either</code>和<code class="fe ls lt lu lv b">of</code>。您可以使用<code class="fe ls lt lu lv b">of</code>构造函数通过调用<code class="fe ls lt lu lv b">Option.of</code>来创建一些或没有实例。使用<code class="fe ls lt lu lv b">of</code>有一些好处——它隐藏了普通函数调用后面的<code class="fe ls lt lu lv b">new</code>的使用，并且它足够聪明，可以毫不费力地决定是给你一个some还是None实例。我们可以使用<code class="fe ls lt lu lv b">either</code>函数调用一个函数，这取决于它是一个Some值还是None值。</p><p id="4bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果我们不在我们的选项变体上实现一些操作，这些都不会给我们带来太多好处:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/2217c101a5e43eebe4686bbf5ebc0671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9lgqEQSNxcS6AxF1UQRbQ.png"/></div></div></figure><p id="7ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们用相同的函数集扩展了我们的两个选项变体。你可以说他们服从同样的<em class="lw">界面</em>。这个接口实际上是Monad接口(它也服从Applicative接口)。不过，现在这对我们来说没什么大不了的，因为你可以在本质上不理解单子的情况下理解如何使用选项。</p><p id="91d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们浏览一下我们在选项界面中定义的每个函数。</p><ol class=""><li id="5d2d" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated"><code class="fe ls lt lu lv b">map</code>——这是最容易理解的一个。就像<code class="fe ls lt lu lv b">Array.map</code>。它使用提供的函数转换容器中的值。对于某些变体，我们传入一个函数。有些人知道如何将该功能应用于其内容，同时将其保存在容器中。如果出了问题，我们只得到一个“无”。<code class="fe ls lt lu lv b">map</code>不过在无上的工作方式不同——map不执行任何操作，而是简单地不执行任何操作。映射到无只会产生无。</li><li id="772b" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated"><code class="fe ls lt lu lv b">unwrap</code>-从容器中取出价值(因此有了标题<code class="fe ls lt lu lv b">unwrap</code>)。无变量将返回无。</li><li id="eebf" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated"><code class="fe ls lt lu lv b">chain</code>——这个很难理解。为了理解它，让我们来看看这段代码:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/2f01638f0d4e47376e3f7e6d4d3fc5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBzut2YK5IzGjS5KSnASYA.png"/></div></div></figure><p id="945e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我定义了一些返回选项的函数，以及一些数据来表示我自己和我的爱好。最后两行表示如果使用<code class="fe ls lt lu lv b">map</code>或<code class="fe ls lt lu lv b">chain</code>会发生什么。当我们转到<code class="fe ls lt lu lv b">map</code>返回另一个选项的操作时，我们开始构建容器层。这是因为我们的内在价值被包裹在一个选项中。这就是<code class="fe ls lt lu lv b">chain</code>不同的地方——它执行映射，但是通过“展开”去掉外部的选项层。这样，即使我们的操作功能返回了一个选项，我们也只需要与选项一起工作一层。</p><p id="e893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.<code class="fe ls lt lu lv b">ap</code>——这是另一个奇怪的概念。有时，我们存储在选项的<code class="fe ls lt lu lv b">VALUE</code>符号中的将是一个函数。通常，当您将返回函数的函数映射到您的选项容器时，就会发生这种情况。<code class="fe ls lt lu lv b">ap</code>允许我们利用<em class="lw">另一个</em>选项的<code class="fe ls lt lu lv b">map</code>函数，使用该另一个选项中的值作为当前选项(我们称之为<code class="fe ls lt lu lv b">ap</code>的选项)中存储的函数的参数。这被称为应用程序。你基本上是在说，‘把我在选项A中的函数，应用到选项B中的值上’。如果这听起来很奇怪，请不要担心，您不需要理解Applicative来理解如何从Option中受益。</p><p id="4e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.<code class="fe ls lt lu lv b">expect</code> —该函数“期望”您的选项中有一个值，如果有，则返回该值。但是万一你不这样做，它会抛出一个错误消息。</p><p id="cf50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看更多的这些选项。这里有一些方法可以让你每天写的代码包含null或未定义的into选项:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/4f0aeadb0865a84a8c468147363eaf80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J02CQEvQTTJpnu7zY4WQYQ.png"/></div></div></figure><p id="a44e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些功能都是为了您的方便而设置的。必要时，您可以使用相关参数预加载它们，以制作专门的版本。请看<code class="fe ls lt lu lv b">head</code>来看看这种模式在起作用。它使用<code class="fe ls lt lu lv b">safeAt</code>并预加载0来访问数组的第一个元素，否则返回一个None实例。注意所有这些函数是如何返回选项的。这使得它们的每个返回都非常适合使用<code class="fe ls lt lu lv b">chain</code>操作符。精心设计的函数定义将改善函数的组合方式。使你的函数更加通用将会使你的代码更加可重用，并且最终更容易使用。</p><p id="ba1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们知道了如何操作容器中的值。但它仍然只是一个盒子里的值。为了真正利用价值，我们必须以某种方式提取它。我们可以用<code class="fe ls lt lu lv b">unwrap</code>。但是我们可能一点也拿不回来。<code class="fe ls lt lu lv b">expect</code>会更好。但是对我们选项中的值做一些事情的最好方法是使用<code class="fe ls lt lu lv b">Option.either</code>函数。它需要两个函数和一个Option实例。当传入函数的实例为<em class="lw"> None </em>时，调用<code class="fe ls lt lu lv b">either</code>的第一个函数参数。第二个函数参数是当我们的实例是一个<em class="lw"> Some时要调用的函数。</em></p><p id="aeb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在知道如何<em class="lw">对存储在我们选项中的数据做一些事情</em>。让我们将它应用到一个真实的场景中——想象一个React组件调用一个API，然后等待响应来填充它原本为空的数据字段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/b2287250c292cdf8e1fa8c8c3c5f9a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0gv69dNOaQ04So1NcF31g.png"/></div></div></figure><p id="a020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">onLoad '，' onErr '和' onOk '都是微小的函数组件，代表我们的主组件可能处于的状态。我们的主要组件Greeter使用React钩子来获取和设置它的状态。当err不为None时，这表明我们有一个错误要显示，所以我们使用expect打开err选项。否则我们没有错误，所以我们要么在等待响应(onLoad ),要么得到了响应(onOk)。而且看起来还不错！没有空检查，它很有表现力(这里几乎没有命令性代码)，并且它优雅地处理了三种可能的状态。</p><p id="ac07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望您在期权数据结构中享受了一次相当功能性的冒险。请继续关注我的数据结构系列文章，朋友们！</p></div></div>    
</body>
</html>