<html>
<head>
<title>Using Callbacks and Closures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用回调和闭包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-callbacks-and-closures-in-javascript-2261030cbbf5?source=collection_archive---------0-----------------------#2019-10-28">https://javascript.plainenglish.io/using-callbacks-and-closures-in-javascript-2261030cbbf5?source=collection_archive---------0-----------------------#2019-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a5f74e8f3b30863ad357c550c82244a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e_f_ykRB2d-mMmsQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a604" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript中经常使用回调和闭包。回调是作为参数传递给另一个函数的函数。闭包是嵌套在其他函数中的函数，通常用于避免与JavaScript程序的其他部分发生范围冲突。</p><h1 id="1161" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复试</h1><p id="d242" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript中的函数是对象。像任何其他对象一样，您可以将它们作为参数传入。因此，在JavaScript中，我们可以将函数作为另一个函数的参数传入。这被称为回调函数。函数也可以作为另一个函数的结果返回。回调函数可以用于同步代码和异步代码。</p><p id="c473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将一个函数作为另一个函数的参数传入不同于调用一个函数。当我们调用一个函数时，我们在函数的末尾加上圆括号，里面可能有参数。被调用的函数会立即运行。当函数作为参数传入时，它们不会被立即调用。当您传递回调函数的函数调用它时，它们就会被调用。例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7b0d" class="mn lc iq mj b gy mo mp l mq mr">element.addEventListener('click', handleClick);</span></pre><p id="26a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">handleClick</code>不立即调用。当用户触发一个点击事件时调用它。</p><p id="af9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过添加一个接受函数的参数来编写自己的函数，该函数接受回调函数作为参数。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3790" class="mn lc iq mj b gy mo mp l mq mr">const calculate = (x, y, callbackFn)=&gt;{<br/>  return callbackFn(x, y);<br/>})</span></pre><p id="6c76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe ms mt mu mj b">callbackFn</code>是在<code class="fe ms mt mu mj b">calculate</code>函数内部运行的函数参数。如果我们想用<code class="fe ms mt mu mj b">calculate</code>函数来计算一些东西，那么我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d342" class="mn lc iq mj b gy mo mp l mq mr">const result = calculate(1, 2, (x, y)=&gt;{<br/>  return x + y;<br/>});</span></pre><p id="4979" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从我们在传入的回调函数中添加了2个数<code class="fe ms mt mu mj b">x</code>和<code class="fe ms mt mu mj b">y</code>后，<code class="fe ms mt mu mj b">result</code>将是上面的3。我们还可以将命名函数作为回调函数传入:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d9a6" class="mn lc iq mj b gy mo mp l mq mr">const add = (x, y) =&gt; x + y;<br/>const result = calculate(1, 2, add);</span></pre><p id="8b18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到同样的结果。同样，如果我们的函数接受回调函数，我们可以接受任何其他函数作为参数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e1f0" class="mn lc iq mj b gy mo mp l mq mr">const add = (x, y) =&gt; x + y;<br/>const subtract = (x, y) =&gt; x - y;<br/>const multiply = (x, y) =&gt; x * y;<br/>const divide = (x, y) =&gt; x / y;<br/>const sum = calculate(1, 2, add); // 3<br/>const difference = calculate(1, 2, subtract); // -1<br/>const product = calculate(1, 2, multiply); // 2<br/>const quotient = calculate(1, 2, divide); // 0.5</span></pre><p id="81e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，回调函数使我们的代码更加灵活，因为我们可以将任何我们想要的函数作为回调函数传入。此外，命名函数更容易阅读，因为我们将回调函数与参数分开。它们也可以很容易地在其他地方重用。</p><p id="16f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们没有检查<code class="fe ms mt mu mj b">callbackFn</code>参数实际上是一个函数。如果有人传入不是函数的东西，这将是一个问题。为了检查它实际上是一个函数，我们使用了<code class="fe ms mt mu mj b">typeof</code>操作符，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2158" class="mn lc iq mj b gy mo mp l mq mr">const calculate = (x, y, callbackFn)=&gt;{<br/>  if (typeof callbackFn === 'function'){<br/>    return callbackFn(x, y);<br/>  }<br/>  return 0;<br/>})</span></pre><p id="3ec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在我们的web页面中使用回调函数，我们在<code class="fe ms mt mu mj b">index.html</code>中放置了以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eb51" class="mn lc iq mj b gy mo mp l mq mr">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Calcuate&lt;/title&gt;<br/>    &lt;link href="styles.css" rel="stylesheet" type="text/css" /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;p&gt;<br/>      The sum of 1 and 2 is &lt;span id='sum'&gt;&lt;/span&gt;<br/>    &lt;/p&gt;</span><span id="d524" class="mn lc iq mj b gy mv mp l mq mr">    &lt;p&gt;<br/>      The difference of 1 and 2 is &lt;span id='difference'&gt;&lt;/span&gt;<br/>    &lt;/p&gt;</span><span id="adce" class="mn lc iq mj b gy mv mp l mq mr">    &lt;p&gt;<br/>      The product of 1 and 2 is &lt;span id='product'&gt;&lt;/span&gt;<br/>    &lt;/p&gt;</span><span id="36fa" class="mn lc iq mj b gy mv mp l mq mr">    &lt;p&gt;<br/>     The quotient of 1 and 2 is &lt;span id='quotient'&gt;&lt;/span&gt;<br/>    &lt;/p&gt;</span><span id="36fc" class="mn lc iq mj b gy mv mp l mq mr">    &lt;p&gt;<br/>      The modulus of 1 and 2 is &lt;span id='modulus'&gt;&lt;/span&gt;<br/>    &lt;/p&gt;<br/>    &lt;script src="script.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cfe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe ms mt mu mj b">script.js</code>中我们放入:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ff5d" class="mn lc iq mj b gy mo mp l mq mr">const calculate = (x, y, callbackFn) =&gt; {<br/>  return callbackFn(x, y);<br/>};</span><span id="3be5" class="mn lc iq mj b gy mv mp l mq mr">const add = (x, y) =&gt; {<br/>  return x + y;<br/>}</span><span id="65b6" class="mn lc iq mj b gy mv mp l mq mr">const subtract = (x, y) =&gt; {<br/>  return x - y;<br/>}</span><span id="8130" class="mn lc iq mj b gy mv mp l mq mr">const multiply = (x, y) =&gt; {<br/>  return x * y;<br/>}</span><span id="cfd4" class="mn lc iq mj b gy mv mp l mq mr">const divide = (x, y) =&gt; {<br/>  return x / y;<br/>}</span><span id="f574" class="mn lc iq mj b gy mv mp l mq mr">const mod = (x, y) =&gt; {<br/>  return x % y;<br/>}</span><span id="bbf2" class="mn lc iq mj b gy mv mp l mq mr">window.onload = ()=&gt;{<br/>  const sum = calculate(1, 2, add);<br/>  const difference = calculate(1, 2, subtract);<br/>  const product = calculate(1, 2, multiply);<br/>  const quotient = calculate(1, 2, divide);<br/>  const modulus = calculate(1, 2, mod);<br/>  document.getElementById('sum').innerHTML = sum;<br/>  document.getElementById('difference').innerHTML = difference;<br/>  document.getElementById('product').innerHTML = product;<br/>  document.getElementById('quotient').innerHTML = quotient;<br/>  document.getElementById('modulus').innerHTML = modulus;<br/>}</span></pre><p id="9791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该得到:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c0e6afdf97322519b0ba867163926667.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*6FLiNaev7dC_7-FmA5MaHQ.png"/></div></figure><h1 id="bc71" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭</h1><p id="92f8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">闭包是由另一个函数使用的局部变量或函数，并且对该函数的引用返回给该函数。也就是说，我们在外部函数中返回一个函数，该函数引用外部函数的局部变量。如果我们将函数嵌套在另一个函数中并作为引用返回，这是可能的。在内部函数中，我们可以使用外部函数的变量。由于局部变量的作用域，内部函数可以访问外部函数的变量。当我们在外部函数中返回内部函数时，对外部函数的局部变量的引用仍然在内部函数中被引用。</p><p id="ad0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码从外部函数返回一个函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5dbc" class="mn lc iq mj b gy mo mp l mq mr">const hello = (name)=&gt;{<br/>  const greeting = `Hello ${name}`;<br/>  const greet = () =&gt; alert(greeting);<br/>  return greet;<br/>}<br/>const helloJane = hello('Jane');<br/>helloJane();</span></pre><p id="737c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">helloJane</code>是由<code class="fe ms mt mu mj b">hello</code>返回的函数。注意，我们仍然在<code class="fe ms mt mu mj b">helloJane</code>函数中引用了<code class="fe ms mt mu mj b">greeting</code>变量。我们得到一个警告框，里面写着“你好，简”。局部变量<code class="fe ms mt mu mj b">greeting</code>仍然是可访问的，因为我们将它传递给了<code class="fe ms mt mu mj b">greet</code>函数。因为<code class="fe ms mt mu mj b">greet</code>函数有<code class="fe ms mt mu mj b">greeting</code>函数传入。然而，<code class="fe ms mt mu mj b">name</code>参数不再能被外界访问，因为当我们返回它时，我们没有把它传递给<code class="fe ms mt mu mj b">greet</code>函数。正如我们所看到的，闭包允许我们在代码中拥有私有数据，同时保持对外部公共数据的访问。</p><p id="e4a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以扩展上面的例子，使函数显示任何问候。在<code class="fe ms mt mu mj b">index.html</code>中:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="deb9" class="mn lc iq mj b gy mo mp l mq mr">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Calcuate&lt;/title&gt;<br/>    &lt;link href="styles.css" rel="stylesheet" type="text/css" /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;p id='hello'&gt;&lt;/p&gt;<br/>    &lt;p id='welcome'&gt;&lt;/p&gt;<br/>    &lt;p id='how-are-you'&gt;&lt;/p&gt;<br/>    &lt;p id='goodbye'&gt;&lt;/p&gt;<br/>    &lt;script src="script.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cde4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">script.js</code>中，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b250" class="mn lc iq mj b gy mo mp l mq mr">const createGreetingFn = (message)=&gt;{<br/>  const greeting = message;<br/>  const greet = () =&gt; greeting;<br/>  return greet;<br/>}</span><span id="3888" class="mn lc iq mj b gy mv mp l mq mr">window.onload = ()=&gt;{<br/>  const hello = createGreetingFn('Hello');<br/>  const welcome = createGreetingFn('Welcome');<br/>  const howAreYou = createGreetingFn('How are you?');  <br/>  const goodBye = createGreetingFn('Goodbye');<br/>  document.getElementById('hello').innerHTML = hello();<br/>  document.getElementById('welcome').innerHTML = welcome();<br/>  document.getElementById('how-are-you').innerHTML = howAreYou();<br/>  document.getElementById('goodbye').innerHTML = goodBye();<br/>}</span></pre><p id="28f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，我们可以从做不同事情的同一个函数中创建多个函数。创建新函数的函数称为函数工厂。我们创造了不同于一个函数的函数。这是使我们的JavaScript更灵活并让我们重用代码的另一种方式。在<code class="fe ms mt mu mj b">window.onload</code>函数中，我们调用了由我们调用的<code class="fe ms mt mu mj b">createGreetingFn</code>创建的函数，它返回结果，然后将结果分配给元素的<code class="fe ms mt mu mj b">innerHTML</code>属性。</p><p id="6cbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们得到:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d0007d654b45d4461093de822fa17bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*ZgQvgVFQ7GyCux2Cm9yyYQ.png"/></div></figure></div></div>    
</body>
</html>