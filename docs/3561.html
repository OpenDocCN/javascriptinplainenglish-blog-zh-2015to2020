<html>
<head>
<title>Object-Oriented JavaScript — Prototypes, Call, and Apply</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——原型、调用和应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-prototypes-call-and-apply-af9d96b6df95?source=collection_archive---------11-----------------------#2020-10-08">https://javascript.plainenglish.io/object-oriented-javascript-prototypes-call-and-apply-af9d96b6df95?source=collection_archive---------11-----------------------#2020-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6ecb7ea6ebb1f610be48f1e9fb23e4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JyqYDxNkyt5zFHMI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@moraisr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rita Morais</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="963e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看原型、<code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>。</p><h1 id="7123" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">功能原型</h1><p id="c8d9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">函数有一个特殊的<code class="fe lb lc ld le b">prototype</code>属性，该属性包含在构造函数的所有实例之间共享的项。</p><p id="908d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="354a" class="mq lg iq le b gy mr ms l mt mu">function F() {}</span><span id="5e88" class="mq lg iq le b gy mv ms l mt mu">F.prototype = {<br/>  name: 'james',<br/>  say() {<br/>    return `I am ${this.nam}`;<br/>  }<br/>};</span></pre><p id="616d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果我们创建2个<code class="fe lb lc ld le b">F</code>实例:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1891" class="mq lg iq le b gy mr ms l mt mu">const foo = new F();<br/>const bar = new F();<br/>console.log(foo, bar);</span></pre><p id="d10f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到<code class="fe lb lc ld le b">foo</code>和<code class="fe lb lc ld le b">bar</code>具有相同的属性。</p><p id="5d1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">say</code>方法也做同样的事情。</p><h1 id="61ed" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">函数对象的方法</h1><p id="c707" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">函数对象有自己的方法。</p><p id="64ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，函数使用<code class="fe lb lc ld le b">toString</code>方法返回包含函数代码的字符串。</p><p id="89f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d9e2" class="mq lg iq le b gy mr ms l mt mu">function add(a, b, c) {<br/>  return a + b + c;<br/>}</span><span id="21af" class="mq lg iq le b gy mv ms l mt mu">console.log(add.toString());</span></pre><p id="c489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6d9b" class="mq lg iq le b gy mr ms l mt mu">"function add(a, b, c) {<br/>  return a + b + c;<br/>}"</span></pre><p id="8ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><h1 id="1941" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">打电话申请</h1><p id="167d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">函数有<code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>方法让我们运行函数，设置<code class="fe lb lc ld le b">this</code>的值并传递参数给它。</p><p id="1f17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="87f3" class="mq lg iq le b gy mr ms l mt mu">const obj = {<br/>  name: 'james',<br/>  say(who) {<br/>    return `${this.name} is ${who}`;<br/>  }<br/>};</span></pre><p id="1b15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe lb lc ld le b">call</code>来调用<code class="fe lb lc ld le b">say</code>通过写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d76a" class="mq lg iq le b gy mr ms l mt mu">const a = obj.say.call({<br/>  name: 'mary'<br/>}, 'female');</span></pre><p id="c2be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lb lc ld le b">a</code>就是<code class="fe lb lc ld le b">'mary is female’</code>。</p><p id="6726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lb lc ld le b">this</code>设置为:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7295" class="mq lg iq le b gy mr ms l mt mu">{<br/>  name: 'mary'<br/>}</span></pre><p id="fe48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe lb lc ld le b">this.name</code>就是<code class="fe lb lc ld le b">'mary'</code>。</p><p id="a0e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是用于<code class="fe lb lc ld le b">say</code>的参数，因此<code class="fe lb lc ld le b">who</code>是<code class="fe lb lc ld le b">'female'</code>。</p><p id="a08c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以通过做同样的事情来调用<code class="fe lb lc ld le b">apply</code>，除了函数的参数在数组中。</p><p id="4935" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="011b" class="mq lg iq le b gy mr ms l mt mu">const obj = {<br/>  name: 'james',<br/>  say(who) {<br/>    return `${this.name} is ${who}`;<br/>  }<br/>};</span><span id="7ace" class="mq lg iq le b gy mv ms l mt mu">const a = obj.say.apply({<br/>  name: 'mary'<br/>}, ['female']);</span></pre><p id="1802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了同样的结果。</p><h1 id="e304" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">箭头函数中的词法this</h1><p id="4ae0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">this</code>是根据上下文变化的动态对象。</p><p id="6340" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头函数不绑定到自己的值<code class="fe lb lc ld le b">this</code>。</p><p id="bef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c0c7" class="mq lg iq le b gy mr ms l mt mu">const obj = {<br/>  prefix: "Hello",<br/>  greet(names) {<br/>    names.forEach(function(name) {<br/>      console.log(`${this.prefix} ${name}`);<br/>    })<br/>  }<br/>}</span></pre><p id="bc26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe lb lc ld le b">this</code>是回调函数，所以它没有<code class="fe lb lc ld le b">prefix</code>属性，所以我们会得到一个关于<code class="fe lb lc ld le b">greet</code>方法的错误。</p><p id="3655" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们使用一个箭头函数:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d5cb" class="mq lg iq le b gy mr ms l mt mu">const obj = {<br/>  prefix: "Hello",<br/>  greet(names) {<br/>    names.forEach((name) =&gt; {<br/>      console.log(`${this.prefix} ${name}`);<br/>    })<br/>  }<br/>}</span></pre><p id="5038" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，该函数正常工作，因为它没有绑定到自己的值<code class="fe lb lc ld le b">this</code>。</p><h1 id="889f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">推断对象类型</h1><p id="b8db" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">Object.prototype</code>的<code class="fe lb lc ld le b">toString</code>方法给了我们用来创建对象的类名。</p><p id="beec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1366" class="mq lg iq le b gy mr ms l mt mu">Object.prototype.toString.call({});</span></pre><p id="ee77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并获得:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f558" class="mq lg iq le b gy mr ms l mt mu">"[object Object]"</span></pre><p id="c67c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写下:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ea03" class="mq lg iq le b gy mr ms l mt mu">Object.prototype.toString.call([]);</span></pre><p id="0b1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="22ea" class="mq lg iq le b gy mr ms l mt mu">"[object Array]"</span></pre><p id="10b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码将<code class="fe lb lc ld le b">call</code>与<code class="fe lb lc ld le b">toString</code>方法一起使用:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ce7e" class="mq lg iq le b gy mr ms l mt mu">Array.prototype.toString.call([1, 2, 3]);</span></pre><p id="02d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3e4e" class="mq lg iq le b gy mr ms l mt mu">"1,2,3"</span></pre><p id="cdf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a695" class="mq lg iq le b gy mr ms l mt mu">[1, 2, 3].toString()</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5e198f12d6383f623dc5150f714eb1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*An1xAJ9SxGVKwohT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@julianhochgesang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julian Hochgesang</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="956f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="d1cc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">call</code>和<code class="fe lb lc ld le b">apply</code>方法让我们用不同的<code class="fe lb lc ld le b">this</code>值和参数调用函数。</p><p id="0185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<code class="fe lb lc ld le b">prototype</code>拥有所有构造函数实例共享的属性。</p><p id="192c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>