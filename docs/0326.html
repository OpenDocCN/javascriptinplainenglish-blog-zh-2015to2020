<html>
<head>
<title>Preventing Memory Leaks in Angular Observables with ngOnDestroy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ngOnDestroy防止角度可观测量中的内存泄漏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/preventing-memory-leaks-in-angular-observables-with-ngondestroy-b41b8f293714?source=collection_archive---------2-----------------------#2019-09-19">https://javascript.plainenglish.io/preventing-memory-leaks-in-angular-observables-with-ngondestroy-b41b8f293714?source=collection_archive---------2-----------------------#2019-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7705c4eb0b0d4005a4e3fc817ec7c051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uAB2uaCh5qVNJ7bH.jpg"/></div></div></figure><p id="64d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">内存泄漏是最糟糕的问题之一。很难发现，很难调试，往往也很难解决。不幸的是，这个问题出现在每一种编程语言或框架中，包括Angular。可观性是令人敬畏的，因为数据流源源不断，但这种好处会导致严重的内存泄漏问题。今天我们将仔细看看<code class="fe kw kx ky kz b">ngOnDestroy</code> Angular hook，并回答这个问题:“我应该什么时候取消订阅一个可观测的？用什么样的模式最好？”</p><p id="1012" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将:</p><ul class=""><li id="444e" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated">创建一个产生随机数的应用程序。</li><li id="daa9" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated">在其中重现内存泄漏。</li><li id="5f6c" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated">用<code class="fe kw kx ky kz b">takeUntil</code> + <code class="fe kw kx ky kz b">ngOnDestroy</code>模式修复内存泄漏。</li></ul><p id="5ec6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要完成这些任务，请确保您:</p><ul class=""><li id="0021" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated">安装Node.js和npm(在撰写本文时，我使用的是Node.js v8.11.1和npm 5.8.0)。</li><li id="7c5a" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated">安装@angular/cli(在这个帖子里我用的是6.0.0版)。</li><li id="fd84" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated">对棱角有中级知识。</li></ul><h1 id="22eb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">让我们创建应用程序</h1><p id="d22f" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们需要从初始化一个新的角度项目开始。为此，请在终端中输入以下命令:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="e1b6" class="mz lp iq kz b gy na nb l nc nd">ng new memoryLeakApp<br/>cd memoryLeakApp</span></pre><p id="4dd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">ng new</code>命令将初始化一个新的Git存储库，并为您提交项目。</p><p id="911c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在<strong class="ka ir"> memoryLeakApp </strong>目录下创建以下目录和文件。我们稍后会编辑它们:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="1bcf" class="mz lp iq kz b gy na nb l nc nd">mkdir src/app/lucky<br/>touch src/app/lucky/lucky.component.ts<br/>touch src/app/lucky/lucky.service.ts<br/>mkdir src/app/really<br/>touch src/app/really/really.component.ts</span></pre><p id="316a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，是时候开始编码了。从创建<code class="fe kw kx ky kz b">LuckyService</code>开始，它将生成随机数并将它们推送到由<code class="fe kw kx ky kz b">getLuckyNumber</code>方法返回的可观察值。出于调试目的，我们还将实现<code class="fe kw kx ky kz b">getSubscribersCount</code>方法，该方法将返回订阅可观察对象的客户端数量。将该代码放入<code class="fe kw kx ky kz b">src/app/lucky/lucky.service.ts</code>:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="81f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了可以在组件中消费的东西。将以下代码放入<code class="fe kw kx ky kz b">src/app/lucky/lucky.component.ts</code>:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="518a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将创建另一个组件。这是在我们的应用程序中重现内存泄漏所必需的。将该代码放入<code class="fe kw kx ky kz b">src/app/really/really.component.ts</code>:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新<code class="fe kw kx ky kz b">src/app/app.module.ts</code>中的<code class="fe kw kx ky kz b">NgModule</code>声明:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5a11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为最后一步，我们需要修改<code class="fe kw kx ky kz b">src/app/app.component.html</code>并用我们的路由替换CLI生成的代码:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="253b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在GitHub存储库中找到到目前为止的所有代码，您可以克隆它:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="0da3" class="mz lp iq kz b gy na nb l nc nd">git clone -b angular_memory_leak_step1 https://github.com/maciejtreder/angular-memory-leak.git memoryLeakApp<br/>cd memoryLeakApp/<br/>npm install</span></pre><h1 id="f238" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">内存泄漏的时间到了</h1><p id="013e" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">让我们运行应用程序，看看它是如何工作的:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="bb61" class="mz lp iq kz b gy na nb l nc nd">ng serve</span></pre><p id="fa89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用浏览器导航到<a class="ae ng" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200 </a>，您应该会看到:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b3aafc4f51a1fe065a91bda88af98922.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*7B2bmEHGfdxhmqMc"/></div></figure><p id="0cee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，这个应用程序起作用了。每秒钟后显示随机数。但是……当您导航到第二个组件时，看看那里发生了什么:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3d118480c6a3e3408ba8194f7548290e.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*Gulx2l0ntL4Z6K3p"/></div></figure><p id="27eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在控制台中看到的，在<code class="fe kw kx ky kz b">LuckyComponent</code>中进行的订阅仍然有效，并且仍在执行代码。如果我们再次导航到<code class="fe kw kx ky kz b">LuckyComponent</code>会发生什么？或者如果我们来回导航多次呢？我们将面临一个严重的问题:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/cfa9a23c9edeab63951386d86e8821ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*59B2HoonoRVy0OC5"/></div></figure><h1 id="0589" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><a class="ae ng" href="https://www.twilio.com/blog/prevent-memory-leaks-angular-observable-ngondestroy#unsubscribe-using-ngondestroy" rel="noopener ugc nofollow" target="_blank">使用ngOnDestroy取消订阅</a></h1><p id="f635" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们能做什么？<code class="fe kw kx ky kz b">ngOnDestroy</code>生命周期挂钩看起来像是解决我们问题的自然选择。来实现吧，退订里面看得见的。相应地改变<code class="fe kw kx ky kz b">src/app/lucky/lucky.component.ts</code>:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="007f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，这看起来是合法的。我们在这里做的是取消订阅我们在<code class="fe kw kx ky kz b">ngOnDestroy</code>生命周期钩子中的可观察对象，每当组件被破坏时，就会被执行，当访问者离开页面时就会发生这种情况。让我们重新运行应用程序，检查内存泄漏是否已经消除:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="564b" class="mz lp iq kz b gy na nb l nc nd">ng serve</span></pre><p id="2a1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">离开“LuckyComponent”后，您应该会看到订阅中的代码不再被执行。可观察对象已在“ngOnDestroy”挂钩内取消订阅。太好了！让我们在组件之间导航多次，确保一切都按预期运行，并且我们每次都取消订阅。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b225288b906e1d4bdf8c7ea140dd83d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/0*-ta4z-Lpeg2Mer4U"/></div></figure><p id="51c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在这个GitHub库中找到到目前为止的所有代码，您可以克隆它:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="7408" class="mz lp iq kz b gy na nb l nc nd">git clone -b angular_memory_leak_step2 https://github.com/maciejtreder/angular-memory-leak.git memoryLeakApp<br/>cd memoryLeakApp/<br/>npm install</span></pre><h1 id="91aa" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">直到模式</h1><p id="5462" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这对于一个可观测量来说很好，但是如果我们有多个可观测量，我们需要手动取消订阅呢？我们需要添加多个<code class="fe kw kx ky kz b">Subscription</code>变量，只是为了在<code class="fe kw kx ky kz b">ngOnDestroy</code>中取消订阅吗？我们的代码需要看起来像这样吗:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0c08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然不是。我们可以用更干净的方式来做。这就是<code class="fe kw kx ky kz b">takeUntil</code>发挥作用的地方。以下是文档中关于<code class="fe kw kx ky kz b">takeUntil</code>方法的描述:</p><blockquote class="nj nk nl"><p id="660c" class="jy jz nm ka b kb kc kd ke kf kg kh ki nn kk kl km no ko kp kq np ks kt ku kv ij bi translated">从源可观察序列返回值，直到另一个可观察序列或承诺产生值。</p></blockquote><p id="8b83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个定义最重要的部分是:<strong class="ka ir">直到另一个可观察的…产生一个值</strong>。</p><p id="a102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好，所以我们需要“其他可观察的”。将这段代码复制到<code class="fe kw kx ky kz b">src/app/lucky/lucky.component.ts</code>:</p><figure class="mr ms mt mu gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b781" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们实际上所做的是宣布一个新的可观测性:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="044a" class="mz lp iq kz b gy na nb l nc nd">private onDestroy$: Subject&lt;void&gt; = new Subject&lt;void&gt;();</span></pre><p id="bf3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，通过使用带有<code class="fe kw kx ky kz b">takeUntil</code>的<code class="fe kw kx ky kz b">pipe</code>方法，我们通知编译器，当<code class="fe kw kx ky kz b">onDestroy$</code>中出现任何值时，我们想要取消订阅可观察值:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="212f" class="mz lp iq kz b gy na nb l nc nd">this.luckyService.getLuckyNumber()<br/>   .pipe(takeUntil(this.onDestroy$))<br/>   .subscribe((luckyNumber: number) =&gt; {<br/>      this.number1 = luckyNumber;<br/>      console.log('Retrieved lucky number ${this.number1}, for subscriber ${subscriberCount1}');<br/>});</span></pre><p id="ca90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将value推送到<code class="fe kw kx ky kz b">ngOnDestroy</code>钩子内的<code class="fe kw kx ky kz b">onDestroy$</code>:</p><pre class="mr ms mt mu gt mv kz mw mx aw my bi"><span id="2328" class="mz lp iq kz b gy na nb l nc nd">public ngOnDestroy(): void {<br/>   this.onDestroy$.next();<br/>}</span></pre><p id="263a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再次运行应用程序，并在组件之间导航多次。</p><p id="78cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！可观测量被取消订阅，没有内存泄漏，我们只用了几行代码就完成了所有这些。</p><h1 id="7e8b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">摘要</h1><p id="6a94" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">今天我们学习了如何在Angular中意外地遇到内存泄漏。然后我们应用了两种可能的解决方案。(我绝对推荐<code class="fe kw kx ky kz b">takeUntil</code>。)</p><p id="de44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章对你有所帮助，你将开始在你的百万分之一的应用程序中使用你的新知识。</p><p id="1469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看第三步的<a class="ae ng" href="https://github.com/maciejtreder/angular-memory-leak/tree/angular_memory_leak_step3" rel="noopener ugc nofollow" target="_blank"> GitHub资源库，并查看</a><a class="ae ng" href="https://github.com/maciejtreder/ng-toolkit" rel="noopener ugc nofollow" target="_blank"> ng-toolkit </a>以了解更多Angular和SPA特性。</p><p id="8d9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我是Maciej Treder，你可以在contact@maciejtreder.com、<a class="ae ng" href="https://www.maciejtreder.com/" rel="noopener ugc nofollow" target="_blank">https://www.maciejtreder.com</a>和@maciejtreder ( <a class="ae ng" href="https://github.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae ng" href="https://twitter.com/MaciejTreder" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ng" href="https://www.linkedin.com/in/maciej-treder/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>)联系到我。</p><p id="5041" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">本帖原载于</em> <a class="ae ng" href="https://www.twilio.com/blog/prevent-memory-leaks-angular-observable-ngondestroy" rel="noopener ugc nofollow" target="_blank"> <em class="nm">朱婷博客</em> </a> <em class="nm">。</em></p></div></div>    
</body>
</html>