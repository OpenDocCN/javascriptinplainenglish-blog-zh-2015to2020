<html>
<head>
<title>5 Practical Applications of ‘this’ in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中“this”的5个实际应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-practical-applications-of-this-49b0c4880e61?source=collection_archive---------15-----------------------#2020-11-04">https://javascript.plainenglish.io/5-practical-applications-of-this-49b0c4880e61?source=collection_archive---------15-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="79ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">掌握绑定规则，编写高级代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/230cd2ac410904eaa6376bb6a8ec9e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZnZ55WezknXOn6A0"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@tamarcusbrown?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tamarcus Brown</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dbd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编程中，一切都有一个结构和一套规则。声明变量有一种特定的方式，运行循环有一种完全不同的方式。</p><p id="760a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你对这些语法规则了解得越多，你就是越好的程序员。</p><p id="e947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript中臭名昭著的“this”关键字和绑定也有这样的规则。</p><p id="18f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用JS已经有一段时间了，你一定注意到了‘this’关键字的使用。</p><p id="1902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是这门语言最难的方面之一，主要是因为要完全理解它，你需要掌握许多底层细节。</p><p id="76b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要开始学习“this ”,你需要先了解什么是词法环境和执行上下文。</p><p id="f524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会脱口而出那些虽然技术上正确，但最终会让读者困惑的行话。</p><h2 id="54c4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">词汇环境</h2><p id="5c8d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">每当JavaScript引擎执行(运行)一段代码时，它会将这段代码中声明和使用的变量存储在一个名为词法环境的特殊存储中。</p><p id="7f9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论是运行函数还是运行整个。但是如果你正在运行一个使用如下所示的全局变量的函数呢？</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e689" class="ls lt iq mr b gy mv mw l mx my">var age=10;<br/>function printAge(){<br/>  console.log(age);<br/> }<br/>printAge()</span></pre><p id="9793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里“年龄”是一个全局变量，我们在函数<code class="fe mz na nb mr b">printAge()</code>中打印它。那么，如果我们只想执行函数，而不想执行其余的代码，该怎么办呢？词汇环境将如何知道变量‘年龄’的值？</p><p id="da02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">词汇环境有两个部分。</p><ol class=""><li id="5e17" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><strong class="ky ir">环境记录- </strong>存储变量和函数声明的地方。</li><li id="2fdc" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><strong class="ky ir">对外部(父)环境的引用- </strong>这是存储全局变量引用的地方。</li></ol><p id="27b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">执行上下文</strong></p><p id="935f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顾名思义，执行上下文是代码执行时创建的环境。它引用了所有有助于代码运行的东西，包括分配内存。</p><p id="c0f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它甚至引用了包含所有变量值的词法环境。</p><p id="4bae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，它包含代码的当前评估状态。</p><p id="6000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行上下文是在堆栈中管理的，也就是说，可以有许多这样的环境独立运行。</p><p id="0d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nq">你可以在这里</em> <a class="ae kv" href="https://stackoverflow.com/questions/35759544/what-is-the-difference-and-relationship-between-execution-context-and-lexical-en" rel="noopener ugc nofollow" target="_blank"> <em class="nq">找到更详细的解释</em> </a> <em class="nq">但是上面说的知识已经足够我们理解‘这个’了。</em></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="bdf3" class="ny lt iq bd lu nz oa ob lx oc od oe ma jw of jx md jz og ka mg kc oh kd mj oi bi translated">那么，“这”是什么？</h1><p id="8640" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">关键字“this”指的是函数所属的对象。我知道这可能会令人困惑，因此我们将再次使用例子来理解。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="16e5" class="ls lt iq mr b gy mv mw l mx my">var age = 12;<br/>var bodyProps = {<br/>  age: 10,<br/>  logAge: function () {<br/>    console.log('Inside nested function:', age);<br/>    console.log('Inside nested function using this:', this.age);<br/>  },<br/>  statement: console.log('Inside statement function:', this.age),<br/>};<br/>bodyProps.logAge();<br/>console.log('Outside function:', age);</span></pre><p id="2a63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="aaca" class="ls lt iq mr b gy mv mw l mx my">Inside statement function:12</span><span id="ab89" class="ls lt iq mr b gy oj mw l mx my">Inside nested function:12</span><span id="77e0" class="ls lt iq mr b gy oj mw l mx my">Inside nested function using this:10</span><span id="5bbb" class="ls lt iq mr b gy oj mw l mx my">Outside function:12</span></pre><p id="caaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，通过上面的代码片段,“this”的定义将变得更加清晰。</p><p id="18bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们使用“this”时，我们就获得了对该函数所属对象的引用。</p><p id="c777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，对象是全局范围，它有一个值为12的“年龄”变量。</p><p id="31fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变量<code class="fe mz na nb mr b">bodyProps</code>的词法环境包含‘age’变量值‘10 ’,然而当我们写<code class="fe mz na nb mr b">this.age</code>时，它引用函数所属的对象(在我们的例子中),并使用‘age’变量值(即值10)。</p><p id="74cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，关键字“this”指的是函数所属的对象。</p><p id="d092" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个使用“This”的非常简单的例子。但是，掌握这个概念可以让您:</p><ol class=""><li id="9c95" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">重用代码(变量、对象、函数等)</li><li id="47ca" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">关注正确的方法</li></ol><p id="7f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以应用相同的“this”原则来重用复杂的函数。这允许我们遵循D.R.Y规则(不要重复自己)来编写更干净、有组织的代码。</p><p id="41d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，我们使用了一种叫做绑定的东西。绑定帮助我们将一个对象(包含“this”关键字)关联到一个函数，以获得不同的结果。当我解释5个绑定规则时，这将变得更加清楚。</p><p id="fc10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">绑定是一个高级主题，正确使用“this”可以实现。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="20b5" class="ny lt iq bd lu nz oa ob lx oc od oe ma jw of jx md jz og ka mg kc oh kd mj oi bi translated">1.隐式结合</h1><p id="bf47" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">隐式绑定涵盖了“this”关键字最常见的用例，也相当简单。</p><p id="b4ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，我之前使用的代码片段完美地封装了隐式绑定。</p><p id="679b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，为了简单起见，我将使用不同的代码片段来解释隐式绑定。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d9f1" class="ls lt iq mr b gy mv mw l mx my">function someFunc(obj) {<br/>  obj.printName = function () {<br/>    console.log(this.name)<br/>  }<br/>}<br/>var user = {<br/>  name: 'foo',<br/>  getName: function () {<br/>    console.log(this.name);<br/>  }<br/>};<br/>var user1 = {<br/>  name: 'bar',<br/>  getName: function () {<br/>    console.log(this.name);<br/>  }<br/>};</span><span id="3856" class="ls lt iq mr b gy oj mw l mx my">user.getName(); //=&gt; foo<br/>user1.getName();//=&gt; bar<br/>someFunc(user);<br/>someFunc(user1);<br/>user.printName();//=&gt; foo<br/>user1.printName();//=&gt; bar</span></pre><p id="b67a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的“this”绑定到用户对象。因此，它提供了对“用户”变量中声明的变量的引用。</p><p id="5aa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但有趣的是，我们给我们的“用户”附加了一个功能<code class="fe mz na nb mr b">printName</code>。</p><p id="300e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这同样适用于我们的“user1”变量。</p><p id="4910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以有把握地说，当我们执行<code class="fe mz na nb mr b">user.printName()</code>时，函数<code class="fe mz na nb mr b">printName()</code>会绑定到‘用户’变量。这同样适用于“用户1”。</p><p id="84a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">换句话说，“this”绑定到点的左边。)运算符，在执行时与函数相邻。</strong></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="3f97" class="ny lt iq bd lu nz oa ob lx oc od oe ma jw of jx md jz og ka mg kc oh kd mj oi bi translated">2.显式绑定</h1><p id="4219" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">显式绑定对于调用对象范围之外的函数很有用。</p><p id="ffd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解这个概念，我们需要知道我上面解释过的执行上下文。每个执行上下文独立运行，每个程序可以有几个类似堆栈的上下文。</p><p id="afaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们想从不同的执行上下文中访问一些东西呢？“这个”怎么会知道呢？</p><p id="e083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是显式绑定发挥作用的地方。</p><p id="b194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在隐式绑定中，我们可以访问执行上下文内部的函数，但是在显式绑定中，我们可以访问执行上下文外部的函数。</strong></p><p id="b13d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于显式绑定，JavaScript为我们提供了三个函数:<code class="fe mz na nb mr b">call()</code>、<code class="fe mz na nb mr b">apply()</code>和<code class="fe mz na nb mr b">bind()</code>。</p><h2 id="08e6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">“call()”方法:</h2><p id="7a76" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在<code class="fe mz na nb mr b">call()</code>方法中，函数必须作为参数传递的上下文。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bf89" class="ls lt iq mr b gy mv mw l mx my">let getBrand = function() {<br/>     console.log(this.brand);<!-- --> //=&gt; Samsung<br/> }<br/> <br/>let phone = {<br/>   name: 'Galaxy S20',<br/>   brand: 'Samsung'  <br/> };<br/><em class="nq"><br/></em>getBrand.call(phone);</span></pre><p id="0d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，<code class="fe mz na nb mr b">this</code>捕捉对在<code class="fe mz na nb mr b">call()</code>方法中作为参数传递的任何内容的引用。</p><p id="21f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们引用了“phone”变量的“name”和“brand”属性，并通过使用<code class="fe mz na nb mr b">call()</code>方法成功关联了<code class="fe mz na nb mr b">getBrand()</code>函数。</p><h2 id="2b81" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">“apply()”方法:</h2><p id="b761" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe mz na nb mr b">apply()</code>方法弥补了<code class="fe mz na nb mr b">call()</code>方法的不足。</p><p id="3235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，call()方法接受参数，但是如果我们尝试将数组作为参数传递，我们需要手动将数组的每个索引作为参数传递，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d4bf" class="ls lt iq mr b gy mv mw l mx my">let getBrand = function(name1,name2) {<br/>     console.log(this.brand);  //=&gt; Samsung<br/>     console.log(name1); //=&gt; S10<br/>     console.log(name2); //=&gt; Note 9<br/> }<br/> <br/>let phone = {<br/>   name: 'Galaxy S20',<br/>   brand: 'Samsung'  <br/> };<br/>var nameList=['S10','Note 9'];<br/>getBrand.call(phone,nameList[0],nameList[1]);</span></pre><p id="3d36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb mr b">apply()</code>方法的行为与<code class="fe mz na nb mr b">call()</code>方法完全相同，除了它可以接受一个数组作为参数。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5edd" class="ls lt iq mr b gy mv mw l mx my">let getBrand = function(name1,name2) {<br/>     console.log(this.brand);  //=&gt; Samsung<br/>     console.log(name1); //=&gt; S10<br/>     console.log(name2); //=&gt; Note 9<br/> }<br/> <br/>let phone = {<br/>   name: 'Galaxy S20',<br/>   brand: 'Samsung'  <br/> };<br/>var nameList=['S10','Note 9'];<br/>getBrand.apply(phone,nameList);</span></pre><h2 id="0694" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">“bind()”方法:</h2><p id="2481" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">和上面的函数一样，<code class="fe mz na nb mr b">bind()</code>的行为也是一样的，但是有一个关键的不同——它返回一个我们可以调用的新函数。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2c03" class="ls lt iq mr b gy mv mw l mx my">let getBrand = function(name1,name2) {<br/>     console.log(this.brand);  //=&gt; Samsung<br/>     console.log(name1); //=&gt; S10<br/>     console.log(name2); //=&gt; Note 9<br/> }<br/> <br/>let phone = {<br/>   name: 'Galaxy S20',<br/>   brand: 'Samsung'  <br/> };<br/>var nameList=['S10','Note 9'];<br/>var myFun = getBrand.bind(phone,nameList[0],nameList[1]);<br/>myFun();</span></pre><p id="75f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，它返回了一个函数，我们将该函数存储在“myFun”变量中，并在以后调用。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="fc7e" class="ny lt iq bd lu nz oa ob lx oc od oe ma jw of jx md jz og ka mg kc oh kd mj oi bi translated">3.默认全局窗口绑定</h1><p id="3e61" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">默认情况下，如果“this”没有绑定到任何绑定技术，它默认为全局对象绑定。</p><p id="069e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过下面的例子，这一点将变得更加清楚:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a412" class="ls lt iq mr b gy mv mw l mx my">let getArticle = function(title) {<br/>    console.log(this.title);<br/>};<br/><br/>var title = 'JavaScript tutorial';<br/>getArticle();</span></pre><p id="408d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们在调用函数<code class="fe mz na nb mr b">getArticle()</code>之前声明了全局变量‘title ’,这是非常关键的，否则你将得到‘undefined’作为输出。</p><p id="866b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">由于没有应用绑定,“this”关键字引用全局范围，因此它将在函数中记录全局变量“title”的值。</strong></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="42eb" class="ny lt iq bd lu nz oa ob lx oc od oe ma jw of jx md jz og ka mg kc oh kd mj oi bi translated">4.“新”关键字</h1><p id="7966" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们已经讨论了显式和隐式绑定方式，但是还有另一种绑定方式。</p><p id="3986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“new”关键字也可以用于绑定。这是一个相当常见的问题，在大多数语言中都有使用。</p><p id="44b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键字可用于创建如下所示的对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e1a9" class="ls lt iq mr b gy mv mw l mx my">let phone= function(price, brand) {<br/>     this.price = price;<br/>     this.brand = brand;<br/>     this.log = function() {<br/>         console.log(this.price +  ' is price of ' + this.brand);<br/>     }<br/> };<br/>let iphone = new phone('Apple', '$1000');<br/>let galaxy = new phone('Samsung', '$800');</span><span id="7078" class="ls lt iq mr b gy oj mw l mx my">iphone.log(); // Apple is price of $1000<br/>galaxy.log(); //Samsung is price of $800</span></pre><p id="d095" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">可以看到，使用</strong> <code class="fe mz na nb mr b"><strong class="ky ir">new </strong></code> <strong class="ky ir">关键字提供了同一个对象的新实例。</strong></p><p id="2db5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这形成了面向对象编程的结构。</p><p id="a8b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，函数<code class="fe mz na nb mr b">phone()</code>使用“new”关键字创建了两次，并绑定到两个不同的变量“iphone”和“galaxy ”,这两个变量具有不同的属性。</p><p id="eb2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通俗地说，函数<code class="fe mz na nb mr b">phone()</code>是用new关键字调用的，将绑定到新创建的对象“iphone”，然后同样的情况也会发生在“galaxy”上。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="8ea3" class="ny lt iq bd lu nz oa ob lx oc od oe ma jw of jx md jz og ka mg kc oh kd mj oi bi translated">5.HTML事件绑定</h1><p id="1f5c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您有使用普通JavaScript构建网站的经验，那么您可能已经看到了这一点。</p><p id="b2e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用“this ”,我们可以绑定具有某种类型的事件侦听器的HTML事件，例如单击事件。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="90c5" class="ls lt iq mr b gy mv mw l mx my">&lt;div onmouseover="this.style.color='teal'"&gt;Change color!&lt;/div&gt;</span></pre><p id="6d21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们有一个带有事件监听器的HTML元素。</p><p id="cbd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当事件监听器捕捉或监听预期的事件(在我们的例子中，鼠标指针在元素上移动)时，它将执行需要“this”关键字的函数来获取对HTML元素的引用。</p><p id="e7aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">通过“This”关键字将HTML元素绑定到代码，整个点击事件功能成为可能。</strong></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="6668" class="ny lt iq bd lu nz oa ob lx oc od oe ma jw of jx md jz og ka mg kc oh kd mj oi bi translated">结论</h1><p id="991d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">JavaScript应用比以往任何时候都更加普及，因此了解这种语言的高级概念是明智的。</p><p id="3461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到详细的文档<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">，在这里你可以找到关于<code class="fe mz na nb mr b">super()</code>和箭头功能的‘this’用法。</a></p><p id="10c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">掌握“这”的概念对任何涉及JavaScript的项目都是有益的，无论是服务器端还是客户端。此外，它在编写面试代码时也是至关重要的。</p><p id="3d39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重用复杂的函数和关注被调用的特定方法可以为你的代码提供一个全新的维度。</p></div></div>    
</body>
</html>