<html>
<head>
<title>An Intro to React Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React测试库简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/quick-intro-to-react-testing-library-4e1fdd3e1103?source=collection_archive---------5-----------------------#2020-06-24">https://javascript.plainenglish.io/quick-intro-to-react-testing-library-4e1fdd3e1103?source=collection_archive---------5-----------------------#2020-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="17b6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">随着web应用程序的规模和复杂性的增加，为web应用程序编写测试变得至关重要</h2></div><p id="1e64" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank"> React测试库(RTL) </a>作为Airbnb的酵素替代品发布。与酶不同，React测试库后退一步，询问我们“如何测试React组件以获得对React组件的完全信任”。React测试库不是测试组件的实现细节，而是将开发人员置于React应用程序最终用户的角度。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/391e95656e6ff412def38ffb2c24d8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WofaHbGqkWFuuNm3"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fotis Fotopoulos</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="5da1" class="lw lx in bd ly lz ma dn mb mc md dp me kl mf mg mh kp mi mj mk kt ml mm mn mo bi translated">Jest Vs React测试库</h2><p id="0305" class="pw-post-body-paragraph kc kd in ke b kf mp jo kh ki mq jr kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">Jest和React测试库都是在测试React组件时使用的，但大多数人都将RTL混淆为Jest的替代品。这是完全不正确的，因为他们需要对方，他们都有自己的具体任务。<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>是一个JavaScript测试运行器和JavaScript库，用于创建、<strong class="ke io">运行</strong>和<strong class="ke io">结构化测试</strong>。</p><p id="d51c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，create-react-app附带Jest和react测试库设置。如果您使用定制的React设置，您将不得不自己设置Jest和React测试库。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="d2d8" class="lw lx in mv b gy mz na l nb nc">describe('check truthy and falsy values', () =&gt; {<br/>  test('true is truthy', () =&gt; {<br/>    expect(true).toBe(true);<br/> });</span><span id="591e" class="lw lx in mv b gy nd na l nb nc">  test('false is falsy', () =&gt; {<br/>    expect(false).toBe(false);<br/> });<br/>});</span></pre><p id="4b7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编写Jest测试非常简单。如果我们看上面的例子，描述块是<strong class="ke io">测试套件。</strong>该试块(也可命名为<code class="fe ne nf ng mv b">it</code>而非<code class="fe ne nf ng mv b">test</code>)为<strong class="ke io">测试用例</strong>。一个测试套件可以有多个测试用例，一个测试用例不一定总是在一个测试套件中。我们编写<strong class="ke io">断言</strong>(例如<code class="fe ne nf ng mv b">expect</code>开玩笑)来验证输出是否与我们的异常匹配，异常要么是成功的(绿色)，要么是错误的(红色)。</p><p id="4038" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，Jest是一个测试运行程序，它让您能够从命令行运行测试。框架提供的远不止这些(例如，间谍、模拟、存根等。);但本质上，这就是现在理解我们为什么首先需要Jest所需要的一切。目前还没有关于React组件的任何信息。</p><p id="47e1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，React测试库专门用于测试React组件。如上所述，它是酶的替代品，而不是Jest。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="fe6e" class="lw lx in bd ly lz ma dn mb mc md dp me kl mf mg mh kp mi mj mk kt ml mm mn mo bi translated">使用React测试库渲染组件</h2><p id="61ca" class="pw-post-body-paragraph kc kd in ke b kf mp jo kh ki mq jr kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">让我们看看如何在测试中使用RTL渲染react组件。让我们尝试在下面的应用程序组件上使用RTL。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="f7db" class="lw lx in mv b gy mz na l nb nc">import React from 'react';</span><span id="a470" class="lw lx in mv b gy nd na l nb nc">const title = 'Hello React';</span><span id="8165" class="lw lx in mv b gy nd na l nb nc">function App() {</span><span id="9b34" class="lw lx in mv b gy nd na l nb nc">    return &lt;div&gt;{title}&lt;/div&gt;;<br/>}</span><span id="55ec" class="lw lx in mv b gy nd na l nb nc">export default App;</span></pre><p id="5168" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并在<em class="nh"> App.test.js </em>文件中进行测试</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="fb76" class="lw lx in mv b gy mz na l nb nc">import React from 'react';<br/>import { render } from '@testing-library/react';<br/>import App from './App';</span><span id="87fb" class="lw lx in mv b gy nd na l nb nc">describe('App', () =&gt; {<br/>    test('renders App component', () =&gt; {<br/>    render(&lt;App /&gt;);<br/>  });<br/>});</span></pre><p id="9c19" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">RTL有自己的渲染函数，可以用来渲染你的组件，渲染组件的最终输出，这是你可以用来测试的。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="f24b" class="lw lx in mv b gy mz na l nb nc">import React from 'react';<br/>import { render, screen } from '@testing-library/react';</span><span id="b66d" class="lw lx in mv b gy nd na l nb nc">import App from './App';</span><span id="7463" class="lw lx in mv b gy nd na l nb nc">describe('App', () =&gt; {<br/>    test('renders App component', () =&gt; {<br/>    render(&lt;App /&gt;);<br/>    screen.debug();<br/>  });<br/>});</span></pre><p id="74fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用npm test命令运行测试后，您应该会看到应用程序的HTML输出。<code class="fe ne nf ng mv b">screen.debug() </code>方法本质上是<code class="fe ne nf ng mv b">console.log(prettyDOM())</code>的捷径。它支持调试文档、单个元素或元素数组。每当您使用React测试库为组件编写测试时，您可以首先呈现组件，然后在测试中调试RTL渲染器的可见内容。这样，您可以更自信地编写测试。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="98dc" class="lw lx in mv b gy mz na l nb nc">&lt;body&gt;<br/>  &lt;div&gt;<br/>    &lt;div&gt;<br/>      Hello React<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="d22c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React测试库的伟大之处在于它不太关心实际的组件。由于它只关心使用不同React特性(<a class="ae ky" href="https://www.robinwieruch.de/react-usestate-hook" rel="noopener ugc nofollow" target="_blank"> useState </a>、<a class="ae ky" href="https://www.robinwieruch.de/react-event-handler" rel="noopener ugc nofollow" target="_blank">事件处理程序</a>、<a class="ae ky" href="https://www.robinwieruch.de/react-pass-props-to-component" rel="noopener ugc nofollow" target="_blank"> props </a>)和概念(<a class="ae ky" href="https://www.robinwieruch.de/react-controlled-components" rel="noopener ugc nofollow" target="_blank">受控组件</a>)的渲染组件的输出，所以在渲染最终输出时没有区别。</p><p id="9845" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React测试库用于像人一样与React组件进行交互。人们看到的只是React组件呈现的HTML，所以这就是为什么您将这个HTML结构视为输出，而不是两个单独的React组件。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="6ff9" class="lw lx in bd ly lz ma dn mb mc md dp me kl mf mg mh kp mi mj mk kt ml mm mn mo bi translated">选择元素</h2><p id="1c35" class="pw-post-body-paragraph kc kd in ke b kf mp jo kh ki mq jr kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">在你渲染了你的React组件之后，RTL为你提供了不同的搜索功能来抓取元素。然后，这些元素被用于断言或用户交互。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="a2a3" class="lw lx in mv b gy mz na l nb nc">import React from 'react';<br/>import { render, screen } from '@testing-library/react';<br/>import App from './App';</span><span id="0125" class="lw lx in mv b gy nd na l nb nc">describe('App', () =&gt; {<br/>    test('renders App component', () =&gt; {<br/>    render(&lt;App /&gt;);<br/>    screen.getByText('Search:');<br/>  });<br/>});</span></pre><p id="3a5c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用screen.debug()函数，我们可以清楚地看到最终输出中出现了哪些元素。在你知道了HTML的结构之后，你可以开始使用RTL的screen object函数来选择元素。然后，所选元素可以用于用户交互或断言。我们将做一个断言来检查元素是否在DOM中。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="91c8" class="lw lx in mv b gy mz na l nb nc">import React from 'react';<br/>import { render, screen } from '@testing-library/react';<br/>import App from './App';</span><span id="3ff2" class="lw lx in mv b gy nd na l nb nc">describe('App', () =&gt; {<br/>    test('renders App component', () =&gt; {<br/>    render(&lt;App /&gt;);<br/>    expect(screen.getByText('Search:')).toBeInTheDocument();<br/>  });<br/>});</span></pre><p id="4c5c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ne nf ng mv b">getByText</code>函数接受一个字符串作为输入，就像我们现在使用的一样，但也接受一个正则表达式。字符串参数用于精确匹配，而正则表达式可用于部分匹配，这通常更方便。</p><p id="25a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类似于<code class="fe ne nf ng mv b">getByText</code>函数，React测试库提供了以下函数来选择最终HTML中的元素:</p><ul class=""><li id="50da" class="ni nj in ke b kf kg ki kj kl nk kp nl kt nm kx nn no np nq bi translated">getByText</li><li id="207b" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">getByRole</li><li id="83b1" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">getByLabelText</li><li id="7608" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">getByPlaceholderText</li><li id="12fe" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">getByAltText</li><li id="070e" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">getByDisplayValue</li></ul><p id="8a63" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nh">查询方式</em>变体:</p><ul class=""><li id="7053" class="ni nj in ke b kf kg ki kj kl nk kp nl kt nm kx nn no np nq bi translated">queryByText</li><li id="3fd7" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">queryByRole</li><li id="6777" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">queryByLabelText</li><li id="df64" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">queryByPlaceholderText</li><li id="0676" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">queryByAltText</li><li id="5a0e" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">queryByDisplayValue</li></ul><p id="61e9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按变量查找:</p><ul class=""><li id="c781" class="ni nj in ke b kf kg ki kj kl nk kp nl kt nm kx nn no np nq bi translated">findByText</li><li id="2b33" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">findByRole</li><li id="b32a" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">findByLabelText</li><li id="03e2" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">findByPlaceholderText</li><li id="22da" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">findByAltText</li><li id="31c1" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">findByDisplayValue</li></ul></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="08b7" class="lw lx in bd ly lz ma dn mb mc md dp me kl mf mg mh kp mi mj mk kt ml mm mn mo bi translated">React测试库:触发事件</h2><p id="93e7" class="pw-post-body-paragraph kc kd in ke b kf mp jo kh ki mq jr kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">我们已经看到了如何使用React测试库来渲染和搜索元素，以检查它是否已经被渲染。但是用户交互呢？React用于构建面向大量用户交互的动态web应用程序，因此基于用户交互事件测试React组件是必要的。</p><p id="fe50" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有两种方法可以使用RTL在渲染组件上激发事件。第一种方法是使用fireEvent()函数来模拟最终用户的交互。让我们看看这对于我们的输入字段是如何工作的:</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="eb76" class="lw lx in mv b gy mz na l nb nc">import React from 'react';<br/>import { render, screen, fireEvent } from '@testing-library/react';<br/>import App from './App';</span><span id="da95" class="lw lx in mv b gy nd na l nb nc">describe('App', () =&gt; {<br/>    test('renders App component', () =&gt; {<br/>    render(&lt;App /&gt;);<br/>    screen.debug();<br/>    <br/>    fireEvent.change(screen.getByRole('textbox'), {<br/>    target: { value: 'JavaScript' },<br/>  });</span><span id="c822" class="lw lx in mv b gy nd na l nb nc">  screen.debug();<br/> });<br/>});</span></pre><p id="3d6e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">fireEvent()函数有两个参数，一个元素(这里是文本框角色的输入字段)和一个事件(这里是值为“JavaScript”的事件)。</p><p id="44f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">测试组件上用户交互的第二种方法是使用扩展的用户事件库，它构建在React测试库本身附带的fireEvent之上。userEvent API比fireEvent API更能模拟实际的浏览器行为。例如，<code class="fe ne nf ng mv b">fireEvent.change()</code>仅触发一个<code class="fe ne nf ng mv b">change</code>事件，而<code class="fe ne nf ng mv b">userEvent.type</code>触发一个<code class="fe ne nf ng mv b">change</code>事件，还会触发<code class="fe ne nf ng mv b">keyDown</code>、<code class="fe ne nf ng mv b">keyPress</code>和<code class="fe ne nf ng mv b">keyUp</code>事件。</p><pre class="la lb lc ld gt mu mv mw mx aw my bi"><span id="6fdb" class="lw lx in mv b gy mz na l nb nc">import React from 'react';<br/>import { render, screen } from '@testing-library/react';<br/>import userEvent from '@testing-library/user-event';<br/>import App from './App';</span><span id="a6db" class="lw lx in mv b gy nd na l nb nc">describe('App', () =&gt; {<br/>    test('renders App component', async () =&gt; {<br/>    render(&lt;App /&gt;);<em class="nh"><br/>    </em>await screen.findByText(/Signed in as/);</span><span id="2753" class="lw lx in mv b gy nd na l nb nc">    expect(screen.queryByText(/Searches for JavaScript/)).toBeNull();</span><span id="1b3d" class="lw lx in mv b gy nd na l nb nc">    await userEvent.type(screen.getByRole('textbox'), 'JavaScript');</span><span id="ce2d" class="lw lx in mv b gy nd na l nb nc">    expect( screen.getByText(/Searches for    JavaScript/)).toBeInTheDocument();<br/>  });<br/>});</span></pre><h2 id="be49" class="lw lx in bd ly lz ma dn mb mc md dp me kl mf mg mh kp mi mj mk kt ml mm mn mo bi translated">结论</h2><p id="6d66" class="pw-post-body-paragraph kc kd in ke b kf mp jo kh ki mq jr kk kl mr kn ko kp ms kr ks kt mt kv kw kx ig bi translated">React测试库通过测试最终的输出行为而不是组件的内部逻辑来简化测试过程。通过触发事件，您不仅可以测试呈现的输出，还可以测试组件的变化。</p></div></div>    
</body>
</html>