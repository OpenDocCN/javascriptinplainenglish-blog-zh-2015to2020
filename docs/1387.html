<html>
<head>
<title>Currying vs Partial Application in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的curry vs部分应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/currying-vs-partial-application-in-javascript-9c8f3bd9b17e?source=collection_archive---------5-----------------------#2020-03-09">https://javascript.plainenglish.io/currying-vs-partial-application-in-javascript-9c8f3bd9b17e?source=collection_archive---------5-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ad391c5a95dbe0b41c3858b620551e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miRMRL354cOf_5rRE0CGTQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@shubhamsharan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Shubham Sharan</a> on <a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9981" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Currying</h1><p id="4717" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> Currying </strong>与印度菜没有联系——它来源于数学家哈斯克尔·库里(Haskell Curry)的名字(哈斯克尔编程语言也是以他的名字命名的)。Currying是一个转换过程——我们转换一个函数。奉承的另一个名字是<strong class="ld ir">schnfinkelization</strong>，以另一位数学家摩西·施芬克尔的名字命名。</p><h2 id="6e89" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">那么什么是currying？</h2><blockquote class="ml mm mn"><p id="26fe" class="lb lc mo ld b le mp lg lh li mq lk ll mr ms lo lp mt mu ls lt mv mw lw lx ly ij bi translated"><strong class="ld ir"> Currying </strong> — <strong class="ld ir"> </strong>它是将一个有多个参数的函数转换成一组有一个参数的嵌套函数。</p></blockquote></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="ea9e" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">currying是如何工作的？</h2><p id="0a71" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当调用一个传递了一个参数的curried函数时，它将返回一个新函数，该函数将期待下一个参数的到来。然后调用传递了第二个参数的第二个函数，并等待下一个参数。依此类推，直到函数收到它需要的所有参数。现在，函数获得了执行计算所需的一切—此时它返回计算结果。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5758" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">让我们看看这个简单的例子中“currying”是如何工作的。</p><p id="b1fe" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">假设我们有一个函数，它总结了两个论点:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a7bc" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">但是如果我们有5个参数呢？</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="126c" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">不太漂亮，你同意吗？</p><p id="3d95" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">我们来咖喱吧！</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4040" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">很好！看一下变量<strong class="ld ir"> curry1 </strong>。但是如果我们想让<strong class="ld ir">去掉空括号</strong>呢？让我们一起来做吧:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bc48" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated"><strong class="ld ir">注意看“f.toString”！</strong></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="ee62" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">与图书馆打交道</h2><p id="36bb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以自己编写函数或者从库中使用它，例如从<strong class="ld ir"> lodash的_中。curry </strong> (func，[arity=func.length]) —我将把它的链接留在Links块中。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="235d" class="lz ke iq bd kf ma mb dn kj mc md dp kn lm me mf kr lq mg mh kv lu mi mj kz mk bi translated">当我们使用currying时。</h2><ul class=""><li id="03a9" class="nk nl iq ld b le lf li lj lm nm lq nn lu no ly np nq nr ns bi translated">当我们多次调用同一个函数时，第一个参数保持不变。</li><li id="29db" class="nk nl iq ld b le nt li nu lm nv lq nw lu nx ly np nq nr ns bi translated">在部分应用的情况下(在“部分应用”块中阅读)。</li></ul><h1 id="9738" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">部分应用</h1><blockquote class="ml mm mn"><p id="b488" class="lb lc mo ld b le mp lg lh li mq lk ll mr ms lo lp mt mu ls lt mv mw lw lx ly ij bi translated"><strong class="ld ir">部分应用</strong> —指将多个自变量固定到一个函数上，产生另一个更小arity的函数的过程。</p></blockquote><p id="8385" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">正如我们前面注意到的，对于部分应用程序，我们需要首先处理该函数。</p><p id="bd43" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">让我们用函数<strong class="ld ir">sumcuried 2</strong>做一个局部应用。假设我们只知道函数的第一个自变量，并想调用它。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e76e" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">我们不能用以前的代码这样做:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="84ac" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">但是我们可以这样做:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e98b" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">注意变量库里的 —它存储了我们的值‘0’，我们将使用它。</p><p id="66c7" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">好，假设我们现在知道了第二个论点:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f30a" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">在这里我们用新的论证称之为库里‘1’。因此，我们从上一步获得了“0”，并在当前步骤中添加了“1”。</p><p id="8c9f" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi">0 + 1 =&gt; 1</p><p id="9e7d" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">我希望它对你来说变得更加透明。</p><p id="9ba2" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">现在，另一个论点是:</p><p id="a4e3" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm ms lo lp lq mu ls lt lu mw lw lx ly ij bi translated">最终结果保持不变10。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="eb4d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">链接</h1><ol class=""><li id="2ab9" class="nk nl iq ld b le lf li lj lm nm lq nn lu no ly ny nq nr ns bi translated">斯托扬·斯特凡诺夫<a class="ae kc" href="http://shop.oreilly.com/product/9780596806767.do" rel="noopener ugc nofollow" target="_blank">http://shop.oreilly.com/product/9780596806767.do</a>的奥莱利《JavaScript模式》一书</li><li id="b8b8" class="nk nl iq ld b le nt li nu lm nv lq nw lu nx ly ny nq nr ns bi translated">Lodash，_。咖喱()<a class="ae kc" href="https://lodash.com/docs/4.17.15#curry" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/4.17.15#curry</a></li></ol></div></div>    
</body>
</html>