<html>
<head>
<title>How to Keep Your Code Tidy By Avoiding Nested Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过避免嵌套闭包来保持代码整洁</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tws-020-how-to-keep-your-code-tidy-by-avoiding-nested-closures-7d9ecd881484?source=collection_archive---------3-----------------------#2019-11-12">https://javascript.plainenglish.io/tws-020-how-to-keep-your-code-tidy-by-avoiding-nested-closures-7d9ecd881484?source=collection_archive---------3-----------------------#2019-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6bd4ef9da1c69344924e19d8aa6bdfc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjW4Oq-M3-E9YYrvM-GerA.png"/></div></div></figure><div class=""/><div class=""><h2 id="18fe" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">JavaScript使用“绑定”进行干净回调的模式</h2></div><p id="e627" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于初学者来说，JavaScript的“this”可能是个问题，闭包也带来了自己的一系列问题。ES2015中引入的“绑定”功能解决了这些问题，并使您的代码更加清晰。在这一集里，Antoní分享了一个被遗忘的处理ECMAScript的“这个”的模式。</p><p id="84aa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Ivana刚刚修复了一个在<code class="fe ln lo lp lq b">rwserve</code>库中发现的模糊错误。而且时间也创下了记录—从结账到拉取请求只需两个小时。她自己也很惊讶。在所有的测试用例中，没有任何问题发生，代码评审也没有任何评论就通过了。</p><p id="3530" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">诚然，当吉拉问题被分配给她时，她有点紧张。代码库很大，其中有许多她从未使用过的特性。此外，这将是她第一次实际处理代码。</p><p id="06ad" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">她像往常一样开始了。重现bug。。。找到可能是它来源的模块。。。将调试器设置为在进入模块时中断。。。逐句通过输入失败的代码。。。检查可能的变量。。。注意意外的状态变化。所有标准故障排除步骤。</p><p id="6b9e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">就在那里。几分钟之内她就知道了问题所在，并且在不到一个小时的时间里就想出了纠正的方法。</p><p id="cdc6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">测试。提交。拉取请求。代码审查。准备部署。</p><p id="b486" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当她四处闲逛时，她注意到几乎每个模块都是由安东尼创作的。因为她之前发现他很平易近人，所以她去了他的办公室聊天。</p><p id="fea0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">她试探性地说，“所以我第一次承诺了一个<code class="fe ln lo lp lq b">rwserve</code>安全模块，”然后在门口等着看他是否会参与进来。</p><p id="e7f8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">安东尼抬起头，“嘿，伊万娜。太酷了。我不知道你被分配了维护问题。你需要我帮忙吗？”</p><p id="78c4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“没有。我已经完成了，它将在周四部署。”</p><p id="6a4d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“恭喜你！”</p><p id="6d17" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“谢谢。所以我想提一下，我发现弄清楚发生了什么真的很容易。你的代码一点也不像迪文或肯的。关于它有一些东西让它清楚地知道发生了什么。我不确定这是什么，但我能够在不迷路的情况下读懂它。</p><p id="2581" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“哦，这一定是我的普利策奖获奖评论，”他开玩笑说。</p><p id="cbb4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“嗯，<em class="lm">是这样的，</em>”她配合道，“但是我想我很惊讶你是如何能够在没有嵌套回调的情况下构建这么大的库，并且从来没有对<code class="fe ln lo lp lq b">this</code>感到困惑。我讨厌<code class="fe ln lo lp lq b">this</code>，并试图避免它，因为它似乎是给我带来这么多麻烦的根本原因。”</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lr"><img src="../Images/a81f429409404d6466376a53e26e5a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yf0sPq9UMmkjVvlTKI54ew.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">onConnect, onStream, onTimeout</figcaption></figure><p id="951a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“哦，那个，”他回答道，“我想你可能没有领会到秘制酱料。这是我使用<code class="fe ln lo lp lq b">bind</code>的方式。</p><p id="d6b4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">他走到白板前，擦掉白板上红色和黑色的涂鸦。“让我向您展示如何设置SessionMonitor模块。它做什么并不重要，重要的是它如何做。”</p><p id="9c7d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“这就是我要说的。模块定义了一个类，所有的东西都在它的构造函数中初始化，就像这样——“</p><pre class="ls lt lu lv gt ma lq mb mc aw md bi"><span id="d78b" class="me mf jb lq b gy mg mh l mi mj">constructor(session, sessionId) {<br/>    this.session       = session;<br/>    this.sessionId     = sessionId;<br/>    this.streamId      = 0;<br/>    this.remoteAddress = null;</span><span id="327c" class="me mf jb lq b gy mk mh l mi mj">    this.boundConnect  = this.onConnect.bind(this);<br/>    this.boundStream   = this.onStream.bind(this);<br/>    this.boundTimeout  = this.onTimeout.bind(this);<br/>    this.boundUncaught = this.onUncaughtException.bind(this);</span><span id="6ace" class="me mf jb lq b gy mk mh l mi mj">    session.on('connect',           this.boundConnect);<br/>    session.on('stream',            this.boundStream);<br/>    session.on('timeout',           this.boundTimeout);<br/>    session.on('uncaughtException', this.boundUncaught);<br/>}</span></pre><p id="8f4c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“这种模式很容易发现。首先，任何将在<em class="lm">回调</em>角色中被触发的函数都被绑定到类实例。然后，将捕获这些回调的每个侦听器都使用这些绑定的函数名进行注册。</p><p id="7c1c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这样，当回调发生时，绑定函数的<code class="fe ln lo lp lq b">this</code>总是SessionMonitor的类实例。</p><p id="4824" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是类方法的快照。不完全是，但足以抓住要点。</p><pre class="ls lt lu lv gt ma lq mb mc aw md bi"><span id="c4f4" class="me mf jb lq b gy mg mh l mi mj">onConnect(serverHttp2Session, tlsSocket) {<br/>    this.remoteAddress = tlsSocket.remoteAddress;<br/>    serverHttp2Session.setTimeout(30*1000);<br/>}</span><span id="c61a" class="me mf jb lq b gy mk mh l mi mj">onStream(stream, incomingRequestHeaders) {<br/>    log.trace(`SID=${this.sessionId}`);<br/>    this.streamId++;<br/>    ...<br/>}</span><span id="6cf2" class="me mf jb lq b gy mk mh l mi mj">onTimeout() {<br/>    this.session.close();<br/>}</span><span id="3e4f" class="me mf jb lq b gy mk mh l mi mj">onUncaughtException(error) {<br/>    log.trace(`RA=${this.remoteAddress}`);<br/>    log.trace(`SID=${this.sessionId}`);<br/>    log.trace(`STRM=${this.streamId}`);<br/>    log.trace(`ERR=${error.message}`);<br/>}</span></pre><p id="1482" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“看一下<code class="fe ln lo lp lq b">onConnect()</code>哪个是收到的第一个回调。它在建立会话超时之前将套接字的远程地址保存到类实例中。稍后，任何需要它的方法都可以访问这个远程地址。</p><p id="985b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当<code class="fe ln lo lp lq b">onStream()</code>被触发时，它可以访问当前会话的<code class="fe ln lo lp lq b">sessionId</code>，因为它是类的一个属性，并且在构造函数中被初始化。它还可以访问并递增下一个可用的<code class="fe ln lo lp lq b">streamId</code>，因为它也是在构造函数中初始化的。</p><p id="cc2f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">类似地，当<code class="fe ln lo lp lq b">onTimeout()</code>被触发时，它可以访问服务器<code class="fe ln lo lp lq b">session</code>，并适当地关闭它。</p><p id="c941" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">"如果有什么疯狂的事情发生，<code class="fe ln lo lp lq b">onUncaughtException()</code>回调将使所有实例属性随时可用于诊断目的."</p><p id="9317" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“这不是什么新花样。它已经存在很久了。”</p><p id="9f2c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“我猜是因为缺少闭包，所以可读性很强，”Ivana评论道。</p><p id="9959" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“没错，”Antoní笑着说，“闭包在Node.js社区中不知何故被提升为一种规范模式——但是没有明显的原因。考虑一下:闭包<em class="lm">拓宽了函数</em>的范围，允许函数访问其包含范围的变量。这与我们都宣称的政策背道而驰——我们应该将变量本地化，而不是全球化。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lr"><img src="../Images/0c5bd3a42a46ac1ce5c101fee074f240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zr3ruLN0531AvRZmvKv7g.png"/></div></div></figure><p id="a08d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“定位范围是<code class="fe ln lo lp lq b">strict</code>、<code class="fe ln lo lp lq b">var</code>、<code class="fe ln lo lp lq b">let</code>、<code class="fe ln lo lp lq b">export</code>和<code class="fe ln lo lp lq b">import</code>等事物背后的全部目的。我们希望避免污染外部名称空间，这样本地名称空间就不会发生意外冲突。</p><p id="e277" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当你给一个类添加属性时，你明确地告诉编译器那些属性只能被实例化的对象访问。对于该类的方法，这意味着，例如，类似于<code class="fe ln lo lp lq b">this.remoteAddress</code>的东西。对于类外的函数，其中<code class="fe ln lo lp lq b">sm</code>是SessionMonitor的一个实例，这意味着<code class="fe ln lo lp lq b">sm.remoteAddress</code>或<code class="fe ln lo lp lq b">sm[remoteAddress]</code>。</p><p id="df48" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“回调<em class="lm">本身</em>并不新鲜。后端的Node.js和前端的DOM都是事件驱动的，遵循的是已经存在了几十年的架构模式。认为JavaScript是单线程的，以及认为<em class="lm">和</em>在某种程度上使其独一无二的观点是目光短浅的。</p><p id="07b5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“我记得Windows刚推出的时候。当时它是一个运行在DOS操作系统中的单线程16位图形用户界面。事实上，它使用消息，这意味着我们必须找出一种方法来构造我们的代码，以发送和接收这些消息。我刚才展示的模式是基于微软多年前开发的模式。</p><p id="404b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“DOS！?"Ivana对此表示怀疑，“那时JavaScript还没有出现呢！”</p><p id="b697" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“图案，我说。记住，模式超越语言。所以不管是C、C++还是JavaScript都无关紧要”</p><p id="d20f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">伊万娜几乎脸红了。她知道的。稍微转移一下话题，她问道，“为什么我在这么多其他代码库中看到习语<code class="fe ln lo lp lq b">var that = this</code></p><p id="bc7a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是ECMAScript 2015中添加<code class="fe ln lo lp lq b">bind</code>之前的遗留问题。当使用闭包时，这是一种保存外部作用域对<code class="fe ln lo lp lq b">this </code>的引用的方法，这样内部函数就可以访问它。这是必要的，因为内部函数有自己的<code class="fe ln lo lp lq b">this</code>指向完全不同的东西。当内部函数需要访问外部作用域上的属性时(让我们再次使用<code class="fe ln lo lp lq b">remoteAddress</code>，它使用语法<code class="fe ln lo lp lq b">that.remoteAddress</code>。</p><p id="e124" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“所以如果你使用<code class="fe ln lo lp lq b">bind(this)</code>，这是一种反模式，”Ivana总结道。</p><p id="f9f8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“没错，”安东尼笑了笑——他已经明白了。</p><p id="47d5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">“很好，”她咕哝着，主要是自言自语，想着如何将他教她的东西应用到自己的代码中。</p><p id="13fd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Ivana不完全确定她能记住所有的东西，所以她给白板拍了一张快照作为提醒。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="7100" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Antoní回到了brotli压缩的工作中。但是他走神了。他已经忘了当一名新工程师时，情况在不断变化是什么感觉。新人应该如何识别好的模式和过时的习语之间的区别呢？如何阻止他们简单地模仿他们在其他人的代码中看到的东西？他们怎么会知道有更干净的方法来做事呢？</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6590b063061023d370a57d1bc5ffd813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*9EGMAfdSiVeSzhr5YjFfcA.png"/></div></figure><p id="f0c2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">没有</em> <a class="ae mt" href="https://readwritetools.com/meet-the-team.blue" rel="noopener ugc nofollow" target="_blank"> <em class="lm">迷你图人物</em> </a> <em class="lm">在制作这一段纠结的网络服务插曲中受到伤害。</em></p></div></div>    
</body>
</html>