<html>
<head>
<title>Custom React Hook to Share State Between Browser’s Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义React挂钩以在浏览器窗口间共享状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-react-hook-to-share-state-between-browser-windows-a672470f66ff?source=collection_archive---------0-----------------------#2020-11-20">https://javascript.plainenglish.io/a-react-hook-to-share-state-between-browser-windows-a672470f66ff?source=collection_archive---------0-----------------------#2020-11-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7b8902d04bbf4a749cdb5636bf45e0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsscvGkyVfIZvHs4de3uIg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@juanster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Juan Davila</a> on <a class="ae ja" href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="4d89" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时在一个前端应用程序中，我们需要在浏览器上打开的同一个域的多个标签之间进行通信。这个用例的一个很好的例子是一个电子商务网站。假设您打开多个选项卡来查看不同的产品，并且在查看时将这些产品添加到购物车中。你所期望的用途是看到你的购物车在任何标签页上更新！</p><p id="1a4a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我创建的一个简单的演示示例。在两个选项卡上打开这个<a class="ae ja" href="https://mostafa-drz.github.io/react-cross-windows-state/" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>,并将商品添加到您的购物车中！正如你所看到的，应用程序的状态是在浏览器的选项卡之间共享的，但是我们如何做到这一点呢？</p><h2 id="b942" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">一点背景:跨窗口交流</h2><p id="237c" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果你想在同一个域的多个窗口之间进行通信，有不同的方法。进行这种通信的一些常见方式是<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" rel="noopener ugc nofollow" target="_blank">窗口PostMessage API </a>、<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API" rel="noopener ugc nofollow" target="_blank">广播通道API </a>以及通过本地存储进行通信。我不会在这篇文章中讨论前两种交流方式，但是你可以在网上和文档中找到这两种方式的很多例子。我将重点介绍使用Localstorage进行通信，因为我们也希望保持我们的状态，这样下次访问页面时，我们仍然可以访问状态。</p><h2 id="fb76" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">局部存储器</h2><p id="0bbf" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated"><a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">本地存储</a>是浏览器上可用的存储之一。通过使用它提供的一个非常简单的API，您可以简单地添加项目和读取存储。这里有一个简单的例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="28ab" class="ky kz jd mb b gy mf mg l mh mi">localStorage.setItem('name','mostafa')</span><span id="4a2e" class="ky kz jd mb b gy mj mg l mh mi">console.log(localStorage.getItem('name'))<br/>// mostafa</span></pre><p id="9d8a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你所看到的，这个API非常容易使用，你可以传递一个键/值给<code class="fe mk ml mm mb b">localStorage.setItem</code>，然后用这个键调用<code class="fe mk ml mm mb b">localStorage.getItem</code>来获取这个值。<br/>但是，关于本地存储，还有一点我们将在我们的使用案例中使用。您可以监听localStorage中的所有更改:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9a36" class="ky kz jd mb b gy mf mg l mh mi">window.addEventListner('storage',(e)=&gt;{</span><span id="f8dd" class="ky kz jd mb b gy mj mg l mh mi">// Something has changed on localStorage <br/>})</span></pre><p id="cd9a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mk ml mm mb b">storage</code>上收到的事件有几个属性，其中两个是我们需要的:<code class="fe mk ml mm mb b">key</code>和<code class="fe mk ml mm mb b">newValue</code>。基本上，我们想要做的是在每个选项卡上设置React状态，我们也将它保存在<code class="fe mk ml mm mb b">localStorag</code>中，这样其他选项卡就可以监听这个变化并更新它们自己的状态。</p><h2 id="c1bf" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">最终解决方案之前的一个小例子</h2><p id="6085" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">这是一个小的React组件，我们希望在这个应用程序的不同选项卡之间共享状态:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="545a" class="ky kz jd mb b gy mf mg l mh mi">import React, { useState, useEffect } from "react";</span><span id="3b8e" class="ky kz jd mb b gy mj mg l mh mi">function HelloStorage() {<br/>  const [name, setName] = useState("");</span><span id="fc01" class="ky kz jd mb b gy mj mg l mh mi">  useEffect(() =&gt; {<br/>    localStorage.setItem("name", name);<br/>  }, [name]);</span><span id="0665" class="ky kz jd mb b gy mj mg l mh mi">  useEffect(() =&gt; {<br/>    const onReceiveMessage = (e) =&gt; {<br/>      const { key, newValue } = e;<br/>      if (key === "name") {<br/>        setName(newValue);<br/>      }<br/>    };<br/>    window.addEventListener("storage", onReceiveMessage);<br/>    return () =&gt; {<br/>      window.removeEventListener("storage", onReceiveMessage);<br/>    };<br/>  }, []);</span><span id="8eaa" class="ky kz jd mb b gy mj mg l mh mi">const handleChange = (e) =&gt; {<br/>    setName(e.target.value);<br/>  };<br/>  return &lt;input value={name} onChange={handleChange} /&gt;;<br/>}</span></pre><p id="7c71" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，您可以看到有两个<code class="fe mk ml mm mb b">useEffect</code>，第一个监听我们状态的变化，如果有变化，它在localStorage上设置状态。<br/>还有第二个<code class="fe mk ml mm mb b">useEfffect</code>，它为<code class="fe mk ml mm mb b">storage</code>添加了一个事件监听器，每次存储上有变化时，它检查变化的键，如果是我们的状态，那么它更新组件内部的状态。(基本上，这意味着另一个选项卡更新了此状态)</p><p id="535e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出现的第一个问题是我们会陷入一个循环吗？🤔如果我们随着每个本地存储的改变而更新状态，那么对于改变状态的选项卡来说，这似乎是一个无限循环(更新状态—&gt;更新本地存储—&gt;更新状态)！答案是否定的！我们不会陷入循环。因为<code class="fe mk ml mm mb b">storage</code>事件不会在事件的原点激发事件。换句话说，改变状态的选项卡没有得到<code class="fe mk ml mm mb b">storage</code>事件，所以唷👏</p><p id="a47d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您照原样运行这段代码，您会看到一个问题，因为每次您打开一个新的选项卡时，新的状态都是空的，您猜怎么着！它将状态设置为跨选项卡的空字符串。我们不会在这个小样本代码中解决这个问题，但是在我们的最终解决方案中，我们会解决这个问题。</p><h2 id="384e" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">自定义的React挂钩，用于在浏览器选项卡之间共享状态</h2><p id="ec33" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在本节中，我假设您熟悉React挂钩以及如何构建定制的React挂钩。如果你想了解更多，我推荐你看看React文档上的<a class="ae ja" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子部分。</a></p><p id="052d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我把最终版本放在这里，然后我们一起看一下:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ddc7" class="ky kz jd mb b gy mf mg l mh mi">function useCrossTabState(stateKey,defaultValue){<br/>  const [state,setState] = useState(defaultValue)<br/>  const isNewSession = useRef(true)</span><span id="90af" class="ky kz jd mb b gy mj mg l mh mi">useEffect(()=&gt;{<br/>    if(isNewSession.current){<br/>      const currentState = localStorage.getItem(stateKey)<br/>      if(currentState){<br/>        setState(JSON.parse(currentState))<br/>      }else{<br/>         setState(defaultValue)<br/>      }<br/>      isNewSession.current=false<br/>      return<br/>    }<br/>    try{<br/>      localStorage.setItem(stateKey,JSON.stringify(state))<br/>    }catch(error){}<br/>  },[state,stateKey,defaultValue])</span><span id="c144" class="ky kz jd mb b gy mj mg l mh mi">useEffect(()=&gt;{<br/>    const onReceieveMessage = (e) =&gt; {<br/>     const {key,newValue} = e<br/>    if(key===stateKey){<br/>       setState(JSON.parse(newValue))<br/>    } <br/>    }<br/>    window.addEventListener('storage',onReceieveMessage)<br/>    return () =&gt; window.removeEventListener('storage',onReceieveMessage)<br/>  },[stateKey,setState])</span><span id="4097" class="ky kz jd mb b gy mj mg l mh mi">return [state,setState]<br/>}</span></pre><p id="43df" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我喜欢React hooks的一点是，你可以很容易地构建一些定制的钩子，在你的应用程序中使用，以获得更模块化和更干净的代码。</p><p id="c659" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个定制钩子接受两个输入:<code class="fe mk ml mm mb b">stateKey</code>和一个<code class="fe mk ml mm mb b">defaultValue</code>。基本上，<code class="fe mk ml mm mb b">stateKey</code>是我们调用<code class="fe mk ml mm mb b">localStorage.setItem</code>时想要使用的键，如果<code class="fe mk ml mm mb b">localStorage</code>上还没有设置值，那么<code class="fe mk ml mm mb b">defaultValue</code>是状态的默认值。</p><p id="694a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在跳过<code class="fe mk ml mm mb b">isNewSession</code>模块，先来看看<code class="fe mk ml mm mb b">useEffect</code>:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1caa" class="ky kz jd mb b gy mf mg l mh mi">useEffect(()=&gt;{<br/>    try{<br/>      localStorage.setItem(stateKey,JSON.stringify(state))<br/>    }catch(error){}<br/>  },[state,stateKey])</span></pre><p id="1db4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一部分中，与上一个示例相同，我们在每次状态改变时都在localStorage上设置状态。<br/>现在我们需要监听<code class="fe mk ml mm mb b">storage</code>变化，如果变化与我们的状态有关，我们需要更新我们的状态:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3ba5" class="ky kz jd mb b gy mf mg l mh mi">useEffect(()=&gt;{<br/>    const onReceieveMessage = (e) =&gt; {<br/>     const {key,newValue} = e<br/>    if(key===stateKey){<br/>       setState(JSON.parse(newValue))<br/>    } <br/>    }<br/>    window.addEventListener('storage',onReceieveMessage)<br/>    return () =&gt; window.removeEventListener('storage',onReceieveMessage)<br/>  },[stateKey,setState])</span></pre><p id="7f0d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，这类似于我们在第一个例子中所做的，除了它更灵活，我们可以在应用程序的不同状态下使用它。</p><p id="62cd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在来说说<code class="fe mk ml mm mb b">isNewSession</code> block是做什么的？如果你还记得我提到的第一个例子，这种方法的问题是，如果你打开一个新标签，新标签有默认状态(在我们的例子中是一个空字符串)，它用默认状态更新存储，它会覆盖标签共享的状态。<br/>为了解决这个问题，我们需要检查这是否是一个新的会话，组件是否正在被渲染，如果是这样，我们就跳过设置<code class="fe mk ml mm mb b">localStorage</code>的状态。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="58c2" class="ky kz jd mb b gy mf mg l mh mi">if(isNewSession.current){<br/>      const currentState = localStorage.getItem(stateKey)<br/>      if(currentState){<br/>        setState(JSON.parse(currentState))<br/>      }else{<br/>         setState(defaultValue)<br/>      }<br/>      isNewSession.current=false<br/>      return<br/>    }</span></pre><p id="07cb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以使用我们的自定义钩子重写我们的第一个例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9b25" class="ky kz jd mb b gy mf mg l mh mi">import React from "react";<br/>import { useCrossTabState } from "./hooks";</span><span id="2df6" class="ky kz jd mb b gy mj mg l mh mi">function App() {<br/>  const [name, setName] = useCrossTabState("name", "");<br/>  const handleChange = (e) =&gt; {<br/>    setName(e.target.value);<br/>  };<br/>  return &lt;input value={name} onChange={handleChange} /&gt;;<br/>}</span><span id="d68c" class="ky kz jd mb b gy mj mg l mh mi">export default App;</span></pre><p id="26f0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，状态键在域中应该是唯一的，以避免任何覆盖。</p><figure class="lw lx ly lz gt ip"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7af0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在我的GitHub上看到使用这个钩子的另一个例子:<a class="ae ja" href="https://github.com/mostafa-drz/react-cross-windows-state" rel="noopener ugc nofollow" target="_blank">https://github.com/mostafa-drz/react-cross-windows-state</a></p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="a6a7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这个定制钩子能帮助你的项目，并且你喜欢这篇文章。请不要犹豫，与我分享你的意见，你会如何改善这个自定义挂钩，或者如果你有任何想法。🍻</p><p id="d76e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://www.linkedin.com/in/mostafa-darehzereshki/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc je"> <em class="mw">莫斯塔法</em> </strong> </a></p></div></div>    
</body>
</html>