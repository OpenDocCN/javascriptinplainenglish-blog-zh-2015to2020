<html>
<head>
<title>React Infinite Scrolling and Lazy Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应对无限滚动和延迟加载</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-infinite-scrolling-and-lazy-loading-171909f92b54?source=collection_archive---------1-----------------------#2020-05-17">https://javascript.plainenglish.io/react-infinite-scrolling-and-lazy-loading-171909f92b54?source=collection_archive---------1-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无限滚动是许多网站用来增强用户体验和性能的概念。在无限滚动中，站点加载一些数据，随着用户继续滚动，越来越多的数据被加载。这一概念节省了时间，因为数据是分部分加载的，并且提高了性能，因为不需要一次渲染所有组件。</p><p id="274a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"/>—惰性加载是一种针对在线内容的优化技术，<br/>惰性加载的概念不是像批量加载那样一次性加载整个网页并呈现给用户，而是帮助只加载所需的部分，并延迟剩余部分，直到用户需要它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c3ca6b079a99cfde2872acdd29abd510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojXsSo-T9EFhdH__NNTqVg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://www.pexels.com/@edwardutra?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Eduardo Dutra</a> from <a class="ae lb" href="https://www.pexels.com/photo/person-in-front-of-laptop-on-brown-wooden-table-2115217/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="7557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">无限滚动</strong>和<strong class="jp ir">惰性加载</strong>的帮助下，我们可以提高React应用的性能和体验。想象一下，您有大约10，000个数据对象，每个数据对象必须有一个单独的组件。如果您同时渲染所有组件，React应用程序一次渲染所有组件将花费大量时间，并且会产生性能问题和对用户体验的负面影响。</p><p id="e216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是无限滚动和延迟加载派上用场的地方。使用无限滚动，我们可以限制最初要呈现的组件，随着我们继续滚动，其余的组件可以逐渐呈现。现在，我们可以做一些事情来进一步提高我们的性能和用户体验。例如，该组件还显示带有动态URL的图像。从URL呈现图像的每个组件都需要时间。与此同时，我们可以显示所有组件的静态图像，而延迟加载在后台加载图像。为此，我们将创建两个组件——列表和图像。列表将实现<strong class="jp ir">无限滚动</strong>，图像将<strong class="jp ir">延迟加载</strong>到我们的列表组件中，以增强我们的应用程序。下面提供了实现的要点示例。</p><p id="a26b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始在应用程序中实现无限滚动和延迟加载。我们将创建一个调用开源API的React应用程序。API有一个查询参数页面。每个页面都有一个整数值，并返回一个包含30个对象的数组。每个对象都有一个名称和一个图像字段。该应用程序将显示每个人的姓名和图像，以及建筑师和工程师的硬编码值。实现如下所示。</p><p id="43ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现<strong class="jp ir">无限滚动</strong>，我们将使用<strong class="jp ir">滚动事件监听器</strong>。Scroll Event Listener使我们能够访问窗口和文档高度，即足以计算页面结尾的滚动的当前位置。现在，应用程序将从初始化为值1的<strong class="jp ir">页面</strong>开始，当用户到达页面的末尾时，每次<strong class="jp ir">页面</strong>的值将增加+1。现在，一旦页面加载完毕，就会使用<strong class="jp ir"> UseEffect(与componentDidMount相同)</strong>进行API调用，并为页面1提取数据。当用户到达页面末尾时，滚动事件监听器将允许我们使用函数<strong class="jp ir"> handleScroll </strong>来了解滚动的位置，页面值将递增，数据将被提取用于<strong class="jp ir">后续页面</strong>并显示给用户。</p><blockquote class="lc"><p id="44f4" class="ld le iq bd lf lg lh li lj lk ll kk dk translated">无限滚动将为我们节省大量时间，让API一次调用整个页面并一次呈现所有数据，从而提高我们的性能和用户体验。</p></blockquote></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><p id="ecee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，为了实现延迟加载，我们将使用悬念和延迟，这是React的新增功能。所以，让我们多了解一下悬疑和懒惰。数据获取的暂停是一个新特性，它允许你使用<code class="fe lt lu lv lw b">&lt;Suspense&gt;</code>到<strong class="jp ir">声明性地“等待”其他任何东西，包括数据。</strong>本页主要关注数据获取用例，但也可以等待图像、脚本或其他异步工作。悬念让你的组件在渲染之前“等待”一些东西。在我们的应用程序中，我们将使用悬念来等待图像被呈现，同时，我们将使用fallback属性向用户显示所有组件的静态通用图像，并且一旦图像被加载，我们的fallback组件将被卸载，图像组件将被装载。</p><blockquote class="lc"><p id="c8a7" class="ld le iq bd lf lg lh li lj lk ll kk dk translated">延迟加载将会提升我们的用户体验。我们将显示一个普通的图像，而不是什么都不显示，直到图像加载完毕，一旦图像加载完毕，它将显示给用户，而不需要在UI端做任何改变。</p></blockquote></div><div class="ab cl lm ln hu lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="06ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像组件看起来像这样-</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="89d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们破解密码-</p><ul class=""><li id="4b5f" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">因为我们使用了钩子，所以我们使用了useState和useEffect组件。悬疑是React最新加入的创造懒加载的功能。你可以在这里了解更多相关信息——https://reactjs.org/docs/code-splitting.html</li><li id="e095" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">现在，我们正在创建一个简单的图像组件，它将使用React.lazy进行延迟加载</li><li id="e69b" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">现在，我们将使用3种状态— <br/> <strong class="jp ir">列表项</strong> —从服务器获取的数据数组<br/> <strong class="jp ir"> isfetching </strong> —当我们到达页面末尾时将被设置为true <br/> <strong class="jp ir"> page </strong>布尔型—当isfetching为true并且最初被设置为1时，从服务器获取数据的页码增加+1。</li><li id="29cf" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> useEffect() </strong> —就像componentDidMount将运行一次，从服务器获取页面1的数据，并添加事件监听器scroll，将其绑定到函数handleScroll。</li><li id="bce4" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> handleScroll() </strong> —在handleScroll中，我们使用一个简单的公式<strong class="jp ir">math . ceil</strong>(window . inner height…..)来确定用户何时进入滚动或页面的结尾。当用户在现代浏览器中使用缩放功能并将isFetching设置为true时，Math.ceil非常方便。</li><li id="a1a7" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">现在，我们使用useEffect来确定<strong class="jp ir"> isFetching </strong>中的任何变化，一旦isFetching发生变化并且为真，我们就调用函数fetchMoreData。</li><li id="575c" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">并且<strong class="jp ir"> fetchMoreData </strong>调用具有setTimeOut函数的fetchData，仅仅显示过渡，仅此而已。fetchData将页面增加+1，然后相应地调用API并将数据推入listItems数组。</li><li id="b09d" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">除了悬念之外，返回方法很简单。暂停中的回退将被初始渲染，并且一旦ImageComponent被加载，回退将被卸载并且<strong class="jp ir"> ImageComponent </strong>将被渲染。</li></ul><p id="b674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的Github代码—<a class="ae lb" href="https://github.com/ANUPAMCHAUDHARY1117/React-Infinte-Scroll-And-lazy-Loading" rel="noopener ugc nofollow" target="_blank">https://Github . com/anupamchaudhary 1117/React-infint-Scroll-And-lazy-Loading</a></p><h1 id="95ca" class="mn mo iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="deee" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击此处 查看我们，并确保订阅该频道😎</p></div></div>    
</body>
</html>