<html>
<head>
<title>Basic JavaScript Patterns — Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本JavaScript模式—事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basic-javascript-patterns-events-b1795db01f26?source=collection_archive---------11-----------------------#2020-05-16">https://javascript.plainenglish.io/basic-javascript-patterns-events-b1795db01f26?source=collection_archive---------11-----------------------#2020-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3a1e58161cb14da460c0b4cfaee53e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19asYAON5iqX1Rk1qhfP9w.jpeg"/></div></div></figure><p id="55a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="8a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了组织我们的代码，我们应该使用一些基本的设计模式。在本文中，我们将研究事件、HTTP请求和后台任务。</p><h1 id="72f5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">事件</h1><p id="11e5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">处理用户事件对于开发者来说也是一个问题。</p><p id="b05f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们处理事件的方式有很多不一致的地方。</p><p id="ec20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">监听事件必须以干净的方式进行。</p><p id="9f49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不应该违反关注点的分离。</p><p id="4b83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们应该编写如下所示的HTML:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d6a2" class="mi kx iq me b gy mj mk l ml mm">&lt;button id="clickme"&gt;click me&lt;/button&gt;</span></pre><p id="e116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不希望HTML标记中有<code class="fe mn mo mp me b">clickme </code>处理程序。</p><p id="4950" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这违反了关注点的分离，当我们以后不得不改变它时会有问题。</p><p id="c123" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们应该写:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9a14" class="mi kx iq me b gy mj mk l ml mm">const clickMe = document.querySelector('#clickme');<br/>clickMe.onclick = () =&gt; {<br/>  //...<br/>}</span></pre><p id="bb5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得我们未来的生活更加容易，因为所有的点击处理代码都是JavaScript。</p><p id="e015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须做一些事情来处理事件。</p><p id="8a0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须获得对事件对象的访问权。</p><p id="6507" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们必须给它附加一个事件监听器函数。</p><p id="ac66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在处理程序中，我们必须更新任何我们想要改变的东西。</p><p id="0a1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那我们必须阻止事件的传播。</p><p id="aacb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们不需要事件冒泡，那么我们就不应该让它冒泡。</p><p id="bd16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标准的方式是在事件对象上调用<code class="fe mn mo mp me b">stopPropagation</code>。</p><p id="b18d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以写:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="fd15" class="mi kx iq me b gy mj mk l ml mm">const clickMe = document.querySelector('#clickme');<br/>clickMe.onclick = (e) =&gt; {<br/>  //...<br/>  e.stopPropagation();<br/>}</span></pre><p id="6fee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可能还需要阻止默认操作的发生。</p><p id="d64f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果我们通过JavaScript提交表单，我们可能希望停止默认的表单提交行为。</p><p id="5222" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们调用事件对象上的<code class="fe mn mo mp me b">preventDefault</code>方法来实现。</p><h1 id="6109" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">事件委托</h1><p id="0072" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们可以使用事件委托来减少附加到不同节点的事件处理程序的数量。</p><p id="9a4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以写:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2993" class="mi kx iq me b gy mj mk l ml mm">document.onclick = (e) =&gt; {<br/>  src = e.target || e.srcElement;<br/>  if (src.nodeName.toLowerCase() !== "button") {<br/>    return;<br/>  }<br/>  //...<br/>}</span></pre><p id="2f98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码取<code class="fe mn mo mp me b">e</code>对象，即事件对象，检查节点名是否等于<code class="fe mn mo mp me b">'button'</code>。</p><p id="9bbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果不是，我们就结束事件处理函数。</p><p id="e8ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">否则，我们继续运行剩余的代码。</p><p id="f568" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这比什么都附加事件处理程序要好得多。</p><p id="14a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得监听动态元素的tp事件变得更加容易。</p><p id="cca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需要监听我们想要附加侦听器的父元素，然后在事件处理程序中运行我们想要的东西。</p><h1 id="5b24" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">长时间运行的脚本</h1><p id="fe6a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果我们有长时间运行的脚本，那么我们必须异步运行它们。</p><p id="af38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们可以使用<code class="fe mn mo mp me b">setTimeout</code>函数。</p><p id="3475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会在指定的时间后运行代码。</p><p id="1b14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过书写来使用它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="74cc" class="mi kx iq me b gy mj mk l ml mm">setTimeout(() =&gt;{<br/>  //...<br/>}, 1000)</span></pre><p id="6d81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中1000是我们运行回调之前的时间，以毫秒为单位。</p><p id="587c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回调函数有我们想要运行的代码。</p><h1 id="2479" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">网络工作者</h1><p id="7cdf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于长期运行的后台任务，我们也可以使用web workers来运行它们，</p><p id="eafd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以这样写:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4349" class="mi kx iq me b gy mj mk l ml mm">const ww = new Worker('webWorker.js');<br/>ww.onmessage = (event) =&gt; {<br/>  console.log(event.data);<br/>};</span></pre><p id="2bab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过调用<code class="fe mn mo mp me b">postMessage</code>方法来填充<code class="fe mn mo mp me b">event</code>对象。</p><p id="2ed6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，在<code class="fe mn mo mp me b">webWorker.js</code>中，我们写道:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4de7" class="mi kx iq me b gy mj mk l ml mm">postMessage('hello there');</span></pre><p id="8474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe mn mo mp me b">event.data</code>将是<code class="fe mn mo mp me b">'hello there'</code>。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/64d0484da081c697307cca4f6a5b633c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FqZyw3eUCXX3UNZc"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">Photo by <a class="ae mv" href="https://unsplash.com/@mendokusai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Srdjan Popovic</a> on <a class="ae mv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="55ad" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">HTTP请求</h1><p id="11ac" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们可以用Fetch API发出HTTP请求。</p><p id="ebfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以在大多数现代浏览器中使用。API是基于承诺的，所以我们不会有回调地狱。</p><p id="092e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以写:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ce60" class="mi kx iq me b gy mj mk l ml mm">(async () =&gt; {<br/>  const res = await fetch('https://api.agify.io/?name=michael');<br/>  const data = await  res.json();<br/>  console.log(data);<br/>})()</span></pre><p id="8a87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在一个异步函数中调用<code class="fe mn mo mp me b">fetch</code>,这样我们就可以得到数据。</p><p id="119a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们不必使用繁琐的<code class="fe mn mo mp me b">XMLHttpRequest</code>构造函数或第三方HTTP客户端来发出请求，</p><p id="60e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这让我们的生活变得更加轻松。</p><h1 id="23f0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="5b44" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们应该总是在JavaScript代码中有一个事件处理代码，而不是HTML。</p><p id="94c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们可以将我们的关注点分开，而不用担心以后当我们不得不改变它们时会弄坏它们。</p><p id="aeda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使事件处理更容易，我们可以使用事件委托来避免将侦听器附加到所有节点。</p><p id="7a82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它对于动态添加的元素也非常有效。</p><p id="68a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要运行后台任务，我们可以使用web workers。</p><p id="2ce2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了发出HTTP请求，我们可以使用Fetch API。</p><h2 id="a2a1" class="mi kx iq bd ky mw mx dn lc my mz dp lg kj na nb lk kn nc nd lo kr ne nf ls ng bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="0d3c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae mv" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="ka ir">JavaScript in Plain English</strong></a><a class="ae mv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka ir">AI in Plain English</strong></a><a class="ae mv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka ir">UX in Plain English</strong></a><a class="ae mv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka ir">Python in Plain English</strong></a><strong class="ka ir"/>—谢谢，继续学习！</p><p id="61f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还推出了一个YouTube，希望你能通过<a class="ae mv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅我们的英语频道</strong> </a>来支持我们</p><p id="9ee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae mv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">submissions @ plain English . io</strong></a><strong class="ka ir"/>并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>