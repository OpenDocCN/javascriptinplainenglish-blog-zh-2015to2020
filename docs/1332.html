<html>
<head>
<title>An Introduction to GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-graphql-50a7caa78a5d?source=collection_archive---------4-----------------------#2020-03-02">https://javascript.plainenglish.io/introduction-to-graphql-50a7caa78a5d?source=collection_archive---------4-----------------------#2020-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9fb7d5c36a56a65a00af4712400cf8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QwWh3LGczHEzIH4P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lukechesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luke Chesser</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bcad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL是我们的API的一种查询语言，也是一个服务器端运行时，通过使用数据的类型系统来运行查询。</p><p id="cf32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何对GraphQL API进行基本查询。</p><h1 id="c440" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">定义API</h1><p id="9c0b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们通过定义类型和这些类型的字段来定义API，并为每个类型上的每个字段提供函数。</p><p id="ee3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1413" class="mn lc iq mj b gy mo mp l mq mr">type Query {<br/>  person: Person<br/>}</span></pre><p id="a5cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们必须为相应的类型创建一个函数来返回数据:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9592" class="mn lc iq mj b gy mo mp l mq mr">function Query_person(request) {<br/>  return request.person;<br/>}</span></pre><h1 id="1fde" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进行查询</h1><p id="9c9d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一旦我们运行了GraphQL服务，我们就可以发送GraphQL查询来验证并在服务器上执行。</p><p id="36db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以进行如下查询:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2107" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  person {<br/>    firstName<br/>  }<br/>}</span></pre><p id="04e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可能会得到如下的JSON:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3720" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "person": {<br/>    "firstName": "Joe"<br/>  }<br/>}</span></pre><h1 id="ab91" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">查询和突变</h1><p id="7f44" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">查询用于从GraphQL服务器获取数据，而变异用于操作存储在服务器上的数据。</p><p id="9afd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下是获取人名的查询:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fa09" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  person {<br/>    name<br/>  }<br/>}</span></pre><p id="d1d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可能会从服务器获得以下JSON:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="629e" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "person": {<br/>      "name": "Joe"<br/>    }<br/>  }<br/>}</span></pre><p id="c47b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字段<code class="fe ms mt mu mj b">name</code>返回一个<code class="fe ms mt mu mj b">String</code>类型。</p><p id="a134" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想获得更多的数据，我们可以随意更改查询。例如，如果我们编写以下查询:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="66bb" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  person {<br/>    name<br/>    friends {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="c170" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可能会得到如下的响应:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ef7d" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "person": {<br/>      "name": "Joe",<br/>      "friends": [<br/>        {<br/>          "name": "Jane"<br/>        },<br/>        {<br/>          "name": "John"<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="2c8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子中的<code class="fe ms mt mu mj b">friends</code>是一个数组。从查询的角度来看，它们看起来是一样的，但是服务器知道根据指定的类型返回什么。</p><h1 id="4d2f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">争论</h1><p id="6ae7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以向查询和变异传递参数。如果我们向查询传递参数，我们可以做更多的事情。</p><p id="18c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下传入一个参数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="644a" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  person(id: "1000") {<br/>    name    <br/>  }<br/>}</span></pre><p id="5070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到这样的结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="473f" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "person": {<br/>      "name": "Luke"<br/>    }<br/>  }<br/>}</span></pre><p id="ae89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从服务器上。</p><p id="7818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用GraphQL，我们可以向嵌套对象传递参数。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e171" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  person(id: "1000") {<br/>    name<br/>    height(unit: METER)<br/>  }<br/>}</span></pre><p id="86b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可能会得到以下响应:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c54b" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "person": {<br/>      "name": "Luke",<br/>      "height": 1.9<br/>    }<br/>  }<br/>}</span></pre><p id="f9f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，<code class="fe ms mt mu mj b">height</code>字段有一个<code class="fe ms mt mu mj b">unit</code>，它是一个枚举类型，代表一组有限的值。</p><p id="75f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">unit</code>可能是米也可能是英尺。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/b7a32c546a59a5d9f02274b45a7e7286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nc2U4Hsu7r9Kr9-g"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@gtomassetti?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Giorgio Tomassetti</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="04ff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">碎片</h1><p id="2274" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以定义片段来重用复杂的查询。</p><p id="1b01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以定义一个片段并按如下方式使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e00c" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  leftComparison: person(episode: FOO) {<br/>    ...comparisonFields<br/>  }<br/>  rightComparison: person(episode: BAR) {<br/>    ...comparisonFields<br/>  }<br/>}<br/>​<br/>fragment comparisonFields on Character {<br/>  name<br/>  appearsIn<br/>  friends {<br/>    name<br/>  }<br/>}</span></pre><p id="a91b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们定义了<code class="fe ms mt mu mj b">comparisonFields</code>片段，它包含了我们希望包含在每个查询中的字段列表。</p><p id="bd03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有了<code class="fe ms mt mu mj b">leftComparison</code>和<code class="fe ms mt mu mj b">rightComparison</code>查询，它们通过使用<code class="fe ms mt mu mj b">...</code>操作符包含了<code class="fe ms mt mu mj b">comparisonFields</code>片段的字段。</p><p id="8092" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到这样的结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7b07" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "leftComparison": {<br/>      "name": "Luke",<br/>      "appearsIn": [<br/>        "FOO",<br/>        "BAR"<br/>      ],<br/>      "friends": [<br/>        {<br/>          "name": "Jane"<br/>        },<br/>        {<br/>          "name": "John"<br/>        }<br/>      ]<br/>    },<br/>    "rightComparison": {<br/>      "name": "Mary",<br/>      "appearsIn": [<br/>        "FOO",<br/>        "BAR"<br/>      ],<br/>      "friends": [<br/>        {<br/>          "name": "Mary"<br/>        },<br/>        {<br/>          "name": "Alex"<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><h1 id="2336" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在片段中使用变量</h1><p id="d940" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将变量传入片段，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c332" class="mn lc iq mj b gy mo mp l mq mr">query PersonComparison($first: Int = 3){<br/>  leftComparison: person(episode: FOO) {<br/>    ...comparisonFields<br/>  }<br/>  rightComparison: person(episode: BAR) {<br/>    ...comparisonFields<br/>  }<br/>}<br/>​<br/>fragment comparisonFields on Character {<br/>  name<br/>  appearsIn<br/>  friends(first: $first) {<br/>    name<br/>  }<br/>}</span></pre><p id="bd6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可能会得到这样的结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5247" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "leftComparison": {<br/>      "name": "Luke",<br/>      "appearsIn": [<br/>        "FOO",<br/>        "BAR"<br/>      ],<br/>      "friends": [<br/>        {<br/>          "name": "Jane"<br/>        },<br/>        {<br/>          "name": "John"<br/>        }<br/>      ]<br/>    },<br/>    "rightComparison": {<br/>      "name": "Mary",<br/>      "appearsIn": [<br/>        "FOO",<br/>        "BAR"<br/>      ],<br/>      "friends": [<br/>        {<br/>          "name": "Mary"<br/>        },<br/>        {<br/>          "name": "Alex"<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="cefa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为回应。</p><p id="ecf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">操作类型可以是查询、变异或订阅，并描述我们打算做什么操作。除非我们使用查询速记语法，否则它是必需的。在这种情况下，我们不能为操作提供名称或变量定义。</p><p id="c845" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的操作来说，操作名是一个有意义且明确的名称。多工序单据中需要。但是鼓励使用它，因为它有助于调试和服务器端日志记录。</p><p id="47b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用名字很容易识别操作。</p><h1 id="ea5f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4828" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">GraphQL是一种查询语言，它让我们能够以一种清晰的方式向服务器发送请求。它的工作方式是将带有操作类型和名称的嵌套对象以及任何变量发送到服务器。</p><p id="9519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后服务器会返回我们想要的响应。</p><p id="b9de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">操作类型包括获取数据的查询和对服务器上的数据进行更改的突变。</p></div></div>    
</body>
</html>