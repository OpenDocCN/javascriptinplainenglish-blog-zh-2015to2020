<html>
<head>
<title>What’s the difference between a Thenable and a Promise?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可有可无和承诺有什么区别？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-the-difference-between-a-thenable-and-a-promise-74d697bc9c79?source=collection_archive---------4-----------------------#2020-09-17">https://javascript.plainenglish.io/whats-the-difference-between-a-thenable-and-a-promise-74d697bc9c79?source=collection_archive---------4-----------------------#2020-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3213" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">又名“假”承诺与“真”承诺——在猫鼬查询的上下文中解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b144d8de0f3559eabad08497db5e155c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rAeKvIpfw9Wbxh9c"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@veverkolog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dušan Smetana</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0dfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我很高兴地做了一些后端编码，在我必须编写一个mongoose查询来返回一个项目列表的部分，我搞不清楚是应该在<code class="fe ls lt lu lv b">myModel.find()</code>方法后面链接<code class="fe ls lt lu lv b">.exec()</code>还是<code class="fe ls lt lu lv b">.then()</code>。所以我最终搜索了他们的文档，试图找出我应该使用哪一个。这是他们文件中的一段:</p><blockquote class="lw lx ly"><p id="d0fe" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated"><a class="ae kv" href="http://mongoosejs.com/docs/queries.html" rel="noopener ugc nofollow" target="_blank">猫鼬的询问</a>是<strong class="ky ir">不是</strong>的承诺。为了方便起见，它们具有用于<a class="ae kv" href="https://www.npmjs.com/package/co" rel="noopener ugc nofollow" target="_blank"> co </a>和异步/等待的<code class="fe ls lt lu lv b">.then()</code>功能。如果你需要一个完整的承诺，使用<code class="fe ls lt lu lv b">.exec()</code>功能。</p></blockquote><p id="eb4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那一刻，我就像…什么是“成熟的承诺”？在这种情况下这意味着什么？</p><p id="0599" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试图弄清楚这个短语的意思的旅程让我找到了这个<a class="ae kv" href="https://promisesaplus.com/" rel="noopener ugc nofollow" target="_blank">链接</a>，我发现他们的意思是猫鼬的查询是可有可无的，而不是承诺。根据该链接，</p><blockquote class="md"><p id="9255" class="me mf iq bd mg mh mi mj mk ml mm lr dk translated">“promise”是一个具有<code class="fe ls lt lu lv b">then</code>方法的对象或函数，其行为符合该规范。</p><p id="4de6" class="me mf iq bd mg mh mi mj mk ml mm lr dk translated">“thenable”是定义一个<code class="fe ls lt lu lv b">then</code>方法的对象或函数。</p></blockquote><p id="65a9" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">很自然，现在的问题是“<em class="lz">谁的行为符合本规范</em>”是什么意思？为了回答这个问题，让我们仔细看看“真正的”又称“完全成熟的承诺”是什么意思(然后我们再看看为什么它与后面的那些不同)。</p><p id="1f69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传统上，<code class="fe ls lt lu lv b">then()</code>方法返回一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>。它需要两个参数:回调函数用于<code class="fe ls lt lu lv b">Promise</code>的成功(onFulfilled)和失败(onRejected)情况。一个承诺可以有三种状态——待定、完成或拒绝。然而，标签并不是这样工作的。我们不能像对待“成熟的承诺”那样传递两个回调函数。用一些代码来说明这一点:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="66f5" class="mw mx iq lv b gy my mz l na nb">UserModel.find().exec((err, users) =&gt; {</span><span id="b1e2" class="mw mx iq lv b gy nc mz l na nb">  if (err) return res.status(400).send(err);</span><span id="3dce" class="mw mx iq lv b gy nc mz l na nb">  res.status(200).json({</span><span id="9818" class="mw mx iq lv b gy nc mz l na nb">    success: true,</span><span id="26a2" class="mw mx iq lv b gy nc mz l na nb">    users,</span><span id="0b29" class="mw mx iq lv b gy nc mz l na nb">  });</span><span id="ffb9" class="mw mx iq lv b gy nc mz l na nb">});</span></pre><p id="c574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做很好，因为我们为成功和失败案例传递的两个回调函数被称为err(失败案例),成功/结果案例被称为users。</p><p id="c65e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，Mongoose中的所有回调都使用模式:<code class="fe ls lt lu lv b">callback(error, result)</code> —这不同于<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank"> MDN web文档</a>中指定的回调函数的顺序。现在，如果我们运行同样的代码，但是像这样用<code class="fe ls lt lu lv b">then()</code>代替<code class="fe ls lt lu lv b">exec()</code>:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="7efd" class="mw mx iq lv b gy my mz l na nb">UserModel.find().then((err, users) =&gt; {</span><span id="f2c9" class="mw mx iq lv b gy nc mz l na nb">  if (err) return res.status(400).send(err);</span><span id="d79c" class="mw mx iq lv b gy nc mz l na nb">  res.status(200).json({</span><span id="f9d6" class="mw mx iq lv b gy nc mz l na nb">    success: true,</span><span id="325a" class="mw mx iq lv b gy nc mz l na nb">    users,</span><span id="0af1" class="mw mx iq lv b gy nc mz l na nb">  });</span><span id="abf5" class="mw mx iq lv b gy nc mz l na nb">});</span></pre><p id="3a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将返回400错误请求状态。这是因为Mongoose查询不是“完全成熟的承诺”,所以我们不能在查询后面加上一个<code class="fe ls lt lu lv b">.then()</code>,然后期望它表现得像一个真正的承诺。然而，如果我们真的想使用<code class="fe ls lt lu lv b">.then()</code>而不是<code class="fe ls lt lu lv b">.exec()</code>，我们仍然可以在<code class="fe ls lt lu lv b">.then()</code>之后链接一个<code class="fe ls lt lu lv b">.catch()</code>用于错误处理:</p><pre class="kg kh ki kj gt ms lv mt mu aw mv bi"><span id="d68e" class="mw mx iq lv b gy my mz l na nb">// {_id:1} is included to make this fail<br/>UserModel.find({ _id: 1 })</span><span id="c9c3" class="mw mx iq lv b gy nc mz l na nb">  .then((users) =&gt; {</span><span id="a9b1" class="mw mx iq lv b gy nc mz l na nb">    res.status(200).json({</span><span id="4204" class="mw mx iq lv b gy nc mz l na nb">      success: true,</span><span id="42ac" class="mw mx iq lv b gy nc mz l na nb">      users,</span><span id="a416" class="mw mx iq lv b gy nc mz l na nb">    });</span><span id="9ddc" class="mw mx iq lv b gy nc mz l na nb">  })</span><span id="232b" class="mw mx iq lv b gy nc mz l na nb">  .catch((err) =&gt; {</span><span id="cc8f" class="mw mx iq lv b gy nc mz l na nb">    res.status(400).send(err);</span><span id="d41a" class="mw mx iq lv b gy nc mz l na nb">  });</span></pre><p id="6540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含{_id:1}将强制它返回一个400错误请求。如果我删除它，用户会得到很好的回报。</p><p id="ce6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，记住所有的承诺都是可有可无的，但并不是所有的可有可无的都是承诺。</p><p id="cbdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">真心希望这能帮到某个人！感谢您阅读本文:)</p></div></div>    
</body>
</html>