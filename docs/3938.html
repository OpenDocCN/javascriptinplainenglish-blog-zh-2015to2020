<html>
<head>
<title>Editing Images with Convolution Matrices using Node.js and JIMP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js和JIMP编辑带有卷积矩阵的图像</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/editing-images-with-convolution-matrices-using-node-js-and-jimp-fa54f1e9a8b7?source=collection_archive---------13-----------------------#2020-11-04">https://javascript.plainenglish.io/editing-images-with-convolution-matrices-using-node-js-and-jimp-fa54f1e9a8b7?source=collection_archive---------13-----------------------#2020-11-04</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="ac81" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">一种简单而强大的图像处理技术</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/9c1dac7300b8037d6bf35e4bef45c84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*EnZvUtfhG62WjuZSnlL11w.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">Photo: Chris Webb</figcaption></figure><p id="1753" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">“卷积矩阵”这个短语听起来有点吓人，如果你不熟悉这个话题，但它实际上是一个非常简单的概念，理解起来非常强大。这个过程最好用图表来解释。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gi gj lo"><img src="../Images/d185d7f0c744220c17ca45b98a9c5aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivADI5DF6XHKrh-seFMSOw.png"/></div></div></figure><p id="a44a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">左边是代表数字图像一部分的像素网格，右边是中心像素的新值，两个中心网格显示了新值是如何计算的。</p><p id="c02c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为了获得中心像素的新值，当前是128，我们将网格中的每个值乘以其在核矩阵中的对应值。结果显示在产品矩阵中。然后将这九个值相加得到最终值，并对图像中的每个像素重复该过程。如果结果超出0–255范围，则使用0或255。</p><p id="2190" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为了简单起见，我使用了灰度，但是RGB图像以同样的方式工作，只是值多了三倍。</p><p id="6a31" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">每个内核对图像都有一定的影响，例如锐化或模糊。我将在代码中展示几个众所周知的。</p><h2 id="542b" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">该项目</h2><p id="ecec" class="pw-post-body-paragraph ks kt ir ku b kv mm js kx ky mn jv la lb mo ld le lf mp lh li lj mq ll lm ln ik bi translated">这个项目使用JIMP npm软件包，它提供了一种将卷积矩阵应用于图像的方法。在https://www.npmjs.com/package/jimp<a class="ae mr" href="https://www.npmjs.com/package/jimp" rel="noopener ugc nofollow" target="_blank">可以找到JIMP的完整文档，你可以安装它:</a></p><p id="b91c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe ms mt mu mv b">npm install --save jimp</code></p><p id="d0c3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">卷积矩阵的JIMP实现非常简单，我正在为一个项目开发一个更加灵活的实现。但是，您仍然可以使用JIMP版本进行一些有用的增强，它也是学习该主题的理想工具。</p><p id="5d1b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">该项目的源代码由一个简短的JavaScript文件组成，您可以从<a class="ae mr" href="https://github.com/CodeDrome/convolution-matrix-jimp" rel="noopener ugc nofollow" target="_blank"> Github库</a>中克隆或下载该文件。上面我用于测试的图片包含在资源库中；如果你想使用自己的照片，只需在第19行编辑文件名。</p><p id="ebbc" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这是清单。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="4af7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">首先，我创建了一个对象数组，每个对象都有一个<code class="fe ms mt mu mv b">name</code>和一个<code class="fe ms mt mu mv b">kernel</code>。这些名字暗示了每个特定内核对图像的影响。然后，这个数组在一个for/of循环中迭代，在这个循环中，我们打开原始图像，记录特定的内核细节，用<code class="fe ms mt mu mv b">convolute</code>方法应用它，最后保存结果图像。</p><p id="143c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你可能会像我一样认为convolute方法会返回一个副本。它没有！它实际上编辑现有的图像，这就是为什么我每次都重新打开它。</p><p id="aa59" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在让我们运行代码。</p><p id="327e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe ms mt mu mv b">node convolutionmatrix.js</code></p><p id="5a85" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">生成的图像如下所示。您可能已经注意到，文件名是原始文件名加上卷积矩阵名称的后缀。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/225bf38f737d43143d126c2a8225c80b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*NQa5-l5gI6s1VKmIuQgGgg.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">Emboss</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/ee9d7da2c739f088eeba06bf454e1478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*l_pkL03ttHX6OWRv0X_xFw.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">Edge detect. Check out the <a class="ae mr" href="https://en.wikipedia.org/wiki/Edge_detection" rel="noopener ugc nofollow" target="_blank">Wikipedia article</a> on the topic</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/758ea67752c8d91b58cb773a4c02eac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*Ewp6mgKBhYn96N09leu99w.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">Edge enhance. Again check out the <a class="ae mr" href="https://en.wikipedia.org/wiki/Edge_enhancement" rel="noopener ugc nofollow" target="_blank">Wikipedia article</a>.</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/9e1cda760ae8f1103132715889a9071c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*littcBtvVPE9ccvfoyre-w.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">Blur. You don’t need Wikipedia to understand this one!</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/b2a039b6a857b42d14b985884bc4a1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*sWhTt9R72IgQVstcihcrbg.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">Sharpen. The effect is a bit excessive so you might like to experiment with other similar values.</figcaption></figure><p id="e4f1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我已经展示了一些众所周知的有用的卷积矩阵，当然还有无数可能的卷积矩阵。</p><p id="e76c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">范围很有趣。有没有任何尚未发现的矩阵具有有用的、奇异的或壮观的效果？</p></div></div>    
</body>
</html>