<html>
<head>
<title>Uber coding interview questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优步编码面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/these-coding-problems-were-asked-by-uber-4cf366d9ef9b?source=collection_archive---------1-----------------------#2020-03-12">https://javascript.plainenglish.io/these-coding-problems-were-asked-by-uber-4cf366d9ef9b?source=collection_archive---------1-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e438" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过每天解决一个问题，变得非常擅长编写面试代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/442cf12ac30ebe93fc054e1622219927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtQXZaOWz6yxZd6GWSBMMw.png"/></div></div></figure><p id="2869" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">(2020年4月7日更新)</em></p><h1 id="c73c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">日常编码问题</h1><p id="a3cb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">它们是受真实编程面试启发的各种各样的问题，带有深入的解决方案，清晰地带您了解每个核心概念。</p><blockquote class="ml"><p id="a290" class="mm mn iq bd mo mp mq mr ms mt mu lm dk translated">通过每天解决一个问题，变得格外擅长编写面试代码。</p></blockquote><p id="3601" class="pw-post-body-paragraph kr ks iq kt b ku mw jr kw kx mx ju kz la my lc ld le mz lg lh li na lk ll lm ij bi translated">我们将一起使用JavaScript解决这些问题。</p><h1 id="89fb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#1</h1><h2 id="e2d9" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">问题</h2><p id="fd9b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">不用除法，在O(n)时间内求解。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="af6f" class="nb lp iq no b gy ns nt l nu nv">Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. </span></pre><p id="9070" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们的输入是[1，2，3，4，5]，那么预期的输出将是[120，60，40，30，24]。如果我们的输入是[3，2，1]，那么预期的输出将是[2，3，6]。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="8e54" class="nb lp iq no b gy ns nt l nu nv">input = [3,2,1]<br/>output = [2x1,3x1, 3x2] <br/>&lt;&lt; [ 2, 3, 6]</span><span id="1e43" class="nb lp iq no b gy nw nt l nu nv">input = [1,2,3,4,5]<br/>output = [2x3x4x5,1x3x4x5,1x2x4x5,1x2x3x5,1x2x3x4] <br/>&lt;&lt; [ 120, 60, 40, 30, 24]</span></pre><h2 id="43b2" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">解决办法</h2><p id="4d8e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">有人能想到的最简单的方法是，对于索引I处的任何数组元素，取数组中除当前索引之外的所有其他元素的乘积，并存储当前索引的乘积。这种方式的时间复杂度是O(n)+O(n*(n-1)) —一个不好的解。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="e2f9" class="nb lp iq no b gy ns nt l nu nv">// bad solution</span><span id="b0d1" class="nb lp iq no b gy nw nt l nu nv">function solution(list_of_numbers) {<br/>    var cache = new Array()<br/>    for (let i = 0; i &lt; list_of_numbers.length; i++) {<br/>        var item = 1<br/>        for (let j = 0; j &lt;  list_of_numbers.length ; j++) {<br/>            if (j != i) {<br/>                item = item * list_of_numbers[j]<br/>            } else {<br/>            }<br/>        }<br/>        cache.push(item)<br/>    }<br/>    return cache<br/>}<br/><br/>var test_list = [3,2,1]<br/><br/>console.log(solution(test_list))<br/>&lt;&lt; [ 2, 3, 6 ]</span></pre><p id="ced6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要在O(n)时间内想出一个不使用除法的更好的方法。</p><p id="c919" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在不使用除法的情况下，你必须创建一个(k，v)字典来存储索引和我们在第一次扫描中看到的每个num左边的乘法结果。然后在第二次运行时从右向左创建新列表。同时，需要存储向右的乘法运算。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="d0df" class="nb lp iq no b gy ns nt l nu nv">function solution(list_of_nums) {<br/><br/>    var retval = []<br/>    var mul_left = {}<br/>    var mul_right = {}<br/><br/>    mul_left[-1] = 1<br/><br/>    for (let i=0; i &lt; (list_of_nums.length - 1); i++) {<br/>        mul_left[i] = list_of_nums[i] * mul_left[i-1]<br/>    }<br/><br/>    mul_right[list_of_nums.length] = 1<br/>    <br/>    for (let j=list_of_nums.length - 1; j &gt; 0 ; j--) {<br/>        mul_right[j] = list_of_nums[j] * mul_right[j+1]<br/>    }<br/><br/>    for (let k = 0; k &lt; list_of_nums.length; k++) {<br/>        retval[k] = mul_left[k-1]*mul_right[k+1]<br/>    }<br/>    return retval<br/><br/>}<br/><br/>var test_list = [1,2,3,4,5]<br/><br/>console.log(solution(test_list))<br/>&lt;&lt; [ 120, 60, 40, 30, 24 ]</span></pre><h1 id="cd4b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#2</h1><h2 id="3e04" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">问题</h2><p id="e531" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一个规则看起来像这样:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="a2b8" class="nb lp iq no b gy ns nt l nu nv">A NE B</span></pre><p id="49ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着A点位于b点的东北方向。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="b6c0" class="nb lp iq no b gy ns nt l nu nv">A SW C</span></pre><p id="73c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">意味着A点在c的西南方。</p><p id="c005" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定一个规则列表，检查规则的总和是否有效。例如:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="0f98" class="nb lp iq no b gy ns nt l nu nv">A N B<br/>B NE C<br/>C N A</span></pre><p id="e1f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不验证，因为A不能同时在c的北面和南面。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="a912" class="nb lp iq no b gy ns nt l nu nv">A NW B<br/>A N B</span></pre><p id="971a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">被视为有效。</p><h2 id="864b" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">解决办法</h2><p id="a08c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">首先我们需要定义一个<code class="fe nx ny nz no b">delta</code>数组(key:方向，value:位置)。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="ec73" class="nb lp iq no b gy ns nt l nu nv">const delta = {<br/>    "N": [0, 1], <br/>    "NE": [1, 1], <br/>    "E": [1, 0],<br/>    "SE": [1, -1], <br/>    "S": [0, -1], <br/>    "SW": [-1, -1],<br/>    "W": [-1, 0], <br/>    "NW": [-1, 1]<br/>}</span></pre><p id="14a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，这就是我们的解决方案。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="2428" class="nb lp iq no b gy ns nt l nu nv">const isValid = function(rules) {<br/><br/>    var retval = true<br/>    // point_name = [x_coord, y_coord]<br/>    var points = {}<br/><br/>    // go through all rules<br/>    for (let index = 0; index &lt; rules.length; index++) {<br/>        <br/>        const rule = rules[index]<br/><br/>        let ruleAnalyzer = rule.split(" ")<br/><br/>        // destination "d", location "loc", source "s" from current rule<br/>        let d = ruleAnalyzer[0]<br/>        let loc = ruleAnalyzer[1]<br/>        let s = ruleAnalyzer[2]   <br/><br/>        // new souces<br/>        if (!Object.keys(points).includes(s)) {<br/>            points[s] = [0, 0]<br/>        } <br/><br/>        // get coords of source<br/>        let x_s = points[s][0]<br/>        let y_s = points[s][1]<br/><br/>        // locate the distance of destination from source by direction<br/>        let delta_x = delta[loc][0]<br/>        let delta_y = delta[loc][1]<br/><br/>        // calculate destination coords from rule<br/>        x_d = x_s + delta_x <br/>        y_d = y_s + delta_y<br/><br/>        // check valid<br/><br/>        // new destination<br/>        if (!Object.keys(points).includes(d)) {<br/>            points[d] = [x_d, y_d]<br/>            continue<br/>        } <br/><br/>        // this destination appeared before <br/><br/>        // get destination coords calculated from previous rules<br/>        let real_x_d = points[d][0]<br/>        let real_y_d = points[d][1] <br/><br/>        // coords from previous rule are different from calculation of current rule <br/>        if ((real_x_d !== x_d) &amp;&amp; (real_y_d !== y_d)) {<br/>            retval = false<br/>        }<br/><br/>    }<br/><br/>    return retval<br/>}</span></pre><p id="20d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们测试这个解决方案。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="fe07" class="nb lp iq no b gy ns nt l nu nv">isValid([“A N B”, “B NE C”, “C N A”])<br/><strong class="no ir">&lt;&lt; false</strong></span><span id="f474" class="nb lp iq no b gy nw nt l nu nv">isValid([“A NW B”, “A N B”])<br/><strong class="no ir">&lt;&lt; true</strong></span></pre><h1 id="d4bd" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#3</h1><h2 id="184d" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">问题</h2><p id="946d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">给定一个排序后的数组<code class="fe nx ny nz no b">arr[]</code>和一个数字<code class="fe nx ny nz no b">x</code>，写一个函数计算<code class="fe nx ny nz no b">arr[]</code>中<code class="fe nx ny nz no b">x</code>的出现次数。</p><p id="c4a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">预期时间复杂度为<code class="fe nx ny nz no b">O(Logn)</code>。</p><p id="4e95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果arr[] = {1，1，2，2，2，2，3}且x = 2，则输出为4。</p><h2 id="1096" class="nb lp iq bd lq nc nd dn lu ne nf dp ly la ng nh ma le ni nj mc li nk nl me nm bi translated">解决办法</h2><p id="67c3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">线性搜索x，计算x的出现次数并返回结果。</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="2ef3" class="nb lp iq no b gy ns nt l nu nv">var count_occurrences = function(arr, x) {<br/>    var n = arr.length<br/>    var res = 0; <br/>    for (let i=0; i&lt;n; i++) <br/>        if (x == arr[i]) <br/>          res++; <br/>    return res; <br/>}</span></pre><p id="0140" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很简单，对吧？</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt oh"><a href="https://medium.com/javascript-in-plain-english/coding-interview-questions-6b539371a028" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">科技巨头的面试问题编码</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">通过每天解决一个问题，变得非常擅长编写面试代码</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div><p id="b1e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我会更新优步周刊在这篇文章中提出的新问题🔖它重新阅读并获得最新的问题和解决方案。</p><p id="bc05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读😘，再见👋，别忘了👏最多50次并跟随！</p></div></div>    
</body>
</html>