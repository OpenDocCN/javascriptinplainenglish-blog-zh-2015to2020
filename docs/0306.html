<html>
<head>
<title>Understanding Objects and Arrays in JavaScript (and avoid hours of debugging)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的对象和数组(避免数小时的调试)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-objects-and-arrays-in-javascript-and-avoid-hours-of-debugging-1e66dfa710db?source=collection_archive---------7-----------------------#2019-09-15">https://javascript.plainenglish.io/understanding-objects-and-arrays-in-javascript-and-avoid-hours-of-debugging-1e66dfa710db?source=collection_archive---------7-----------------------#2019-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3a932cf376e6e12972ae3dcedd0f6660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jvlNFToLUmaVTn13c8e0_Q.png"/></div></div></figure><div class=""/><p id="6142" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像任何JavaScript开发人员一样，您必须广泛使用对象和数组来保存数据。在几乎所有的情况下，你必须复制、更新、删除数据，而不完全理解对象和数组在JavaScript中是如何工作的(以及它在JavaScript中是如何不同的),这通常工作得很好，直到你遇到一些问题。所以让我们开始吧。</p><h2 id="35de" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak"> 1。变量存储参考</strong></h2><p id="800e" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">当你用object初始化一个变量时，它会保存这个变量的引用。</p><h2 id="ad34" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">2.复制对象会复制引用</h2><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/3b870a3a8ec8208713c6f970ec8d01a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iPEeXdZYJGQUTNKgtLILg.png"/></div></div></figure><p id="5c32" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建了一个对象，并将其复制到另一个对象。然后更改新对象的“名称”。现在，如果对象的值被复制，原始值应该保持不变。但这里确实发生了变化。因此，它不是复制值，而是复制引用。</p><h2 id="5f25" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">2.比较对象</h2><p id="29f1" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">比较对象变得非常棘手。不是比较对象的值，而是比较它的引用。</p><p id="13a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从比较两个空对象开始。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/2f41a85cd91b588c360e7b72f433831f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXGlTkUWO41O8LbfzP1Rgg.png"/></div></div></figure><p id="6531" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太令人惊讶了！这里发生的事情是创建了两个空对象并比较了它们的引用。由于创建一个新的对象总是在不同的地方，这两个对象的引用将是不同的，因此不相等。为了更好地理解这一点，这里有另一个等价的代码。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/37d44bccd9227d2547bf947dee5893ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFMf0yRsDV_pCLz_Eohtjw.png"/></div></div></figure><p id="9e42" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以当我们分配<strong class="ka jc"> <em class="lz"> firstEmpty，</em> </strong>一个对象被创建，它的引用被分配给它。现在同样的事情发生在<strong class="ka jc"> <em class="lz"> secondEmpty </em> </strong>上，因此不同的引用不匹配。</p><h2 id="4005" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">3.多级对象</h2><p id="083b" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">当处理JavaScript对象时，你必须明白的一件事是，被赋值的是引用，而不是值。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/2186a503b45e5e42ba1c97b9769d67cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2sQKBOhd1TRKulgwUWa1g.png"/></div></div></figure><p id="bb8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里<strong class="ka jc"><em class="lz">car . dimensions</em></strong>是一个对象，所以它没有值，只有对象的引用。所以当我们将<strong class="ka jc"><em class="lz">car . dimensions</em></strong>复制到<strong class="ka jc"> <em class="lz"> carSpecs </em> </strong>时，它的引用也被复制，所以对<strong class="ka jc"> <em class="lz"> carSpecs </em> </strong>的任何更改也会更改<strong class="ka jc"><em class="lz">car . dimensions</em></strong>。</p><p id="e75f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，任何存储对象的键实际上都存储了引用。</p><h2 id="2619" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">3.制作副本(像实际副本一样)</h2><p id="bf22" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">那么我们如何实际复制一个对象，改变它却不会改变它的原始版本呢？有多种方法可以做到这一点。</p><h2 id="b05f" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">对象.分配</h2><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/9f081ad3800c16c393294a464e89cc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ8Qk8x_irwDVDKgcomw1g.png"/></div></div></figure><p id="7612" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建了一个新的空对象，这当然是一个新的引用。我们使用<strong class="ka jc"><em class="lz">object . assign</em></strong>复制<strong class="ka jc"> <em class="lz"> car </em> </strong>到<strong class="ka jc"> <em class="lz"> newCar的所有密钥及其值。</em>T41】</strong></p><h2 id="9fa8" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">扩展运算符(…)</h2><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/0c3ce02039671f7887b384b611293a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELfEvMNDhbmmcISLJQG_4g.png"/></div></div></figure><p id="6b44" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们使用扩展算子来扩展对象，然后使用对象来组成新的对象。它的工作方式非常类似于Object.assign</p><p id="991a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再举一个例子:</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/aca011eaafad8eec917b5965cebf4544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3Aq6BexsbZtgbuiw2s01w.png"/></div></div></figure><p id="5313" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了什么？即使我们复制了使用<strong class="ka jc"> <em class="lz">展开的运算符</em> </strong>和<strong class="ka jc"> <em class="lz"> Object.assign </em> </strong>在new中改变也改变了原来的值。为了理解我们先试着理解一下这些<strong class="ka jc"> <em class="lz">传播运算符</em> </strong>和<strong class="ka jc"><em class="lz">object . assign</em></strong>实际上是如何工作的？所以这两个方法都不是直接给新对象赋值引用，而是一个接一个地复制它的键。下面是一个等价的代码:</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/25014fbdf5ec334471e0c079ed8c38f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uu2krkLqWWNfztJ2voUtLw.png"/></div></div></figure><p id="593b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，由于我们一个接一个地复制键，对汽车<strong class="ka jc"><em class="lz"/></strong>的引用没有通过其每个键的值复制到新汽车。所以改变<strong class="ka jc"> <em class="lz">中的【new car . name】</em></strong>不会改变<strong class="ka jc"> <em class="lz">中的</em> </strong>。</p><p id="4d80" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<strong class="ka jc"> <em class="lz"> car.owner </em> </strong>本身就是一个对象，所以它的引用被复制到了<strong class="ka jc"> <em class="lz"> newCar.owner </em> </strong>中，这样任何一个的链接和改变都会改变另一个。</p><p id="1041" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这些克隆对象的方法只适用于单级对象，而不适用于嵌套的多级对象，这对于你的大多数用例来说已经足够了。</p><p id="a0ee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们如何创建一个没有引用原始对象的副本呢？这种方法的问题是，如果一个keys存储了另一个对象，而我们复制了它。如果我们不直接复制嵌套的对象，而是像遍历原始对象一样逐个遍历它的键，会怎么样呢？如果它有任何嵌套对象，也是如此。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/ccae442d5fe1455fc547921b1d2d1955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uSbF3zZMuOmjIDQJVUSsQ.png"/></div></div></figure><p id="02a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们复制了所有嵌套对象，所以没有复制引用，只有值被复制。注意:我们只检查嵌套对象。可能有嵌套数组，它们也作为引用存储。</p><p id="f877" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，使用递归进行深度复制几乎是不需要的，而且在处理大量数据时效率很低。</p><h1 id="b735" class="mb kx jb bd ky mc md me lb mf mg mh le mi mj mk lh ml mm mn lk mo mp mq ln mr bi translated">数组</h1><p id="e3b3" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">数组也是如此。看看这个例子:</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/48fb7e40753f54e1b977122ed7906ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CYf2AT_OfajT2XG0c1GsQ.png"/></div></div></figure><p id="38bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该会让您对数组有一个大致的了解。我们可以用同样的方式处理嵌套对象，递归地复制任何嵌套数组。</p><p id="7e6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这能为您节省一些时间来识别和避免应用程序数据中的意外变化。</p><h2 id="57b6" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="f77e" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ms" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka jc">AI in Plain English</strong></a><a class="ae ms" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka jc">UX in Plain English</strong></a><a class="ae ms" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka jc">Python in Plain English</strong></a><strong class="ka jc"/>——谢谢，继续学习！</p><p id="2d54" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ms" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">submissions @ plain English . io</strong></a><strong class="ka jc"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>