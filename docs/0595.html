<html>
<head>
<title>Why I always prefer async/await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我总是喜欢异步/等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-i-always-prefer-async-await-72fd325792f2?source=collection_archive---------0-----------------------#2019-11-14">https://javascript.plainenglish.io/why-i-always-prefer-async-await-72fd325792f2?source=collection_archive---------0-----------------------#2019-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e065" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何处理JavaScript中的异步性？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8dbc3ec972b26a4828e88a336b7d8aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1xL5LZs_-h-v3WsN"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clément H</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3790" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">这是什么？</h1><p id="ab5d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是用Javascript编写异步代码的一种方式。语言本身是单线程的，本质上是阻塞的，这意味着在任何给定的时刻都只有一件事情发生。</p><p id="31b9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">环境在事件循环的帮助下创造了异步的本质。这个循环由每个标签中的浏览器提供，由每个进程中的NodeJS提供，并且是Javascript的一个核心概念，我们不会详细讨论它是如何工作的，但是会研究如何将它用于异步代码。</p><h1 id="b55d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">有多少选择？</h1><p id="036f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如今，如何处理<code class="fe mp mq mr ms b">asynchronous</code>手术有多种选择:</p><ul class=""><li id="8eaa" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated">使用<code class="fe mp mq mr ms b">callbacks</code></li><li id="a093" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">使用<code class="fe mp mq mr ms b">Promises</code></li><li id="913c" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">使用<code class="fe mp mq mr ms b">async/await</code></li></ul><p id="ea0a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那么，为什么我更喜欢后者呢？让我们把它们都检查出来。</p><h1 id="b06d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">复试</h1><p id="0b89" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以传入一个函数，这个函数将在以后执行。让我们看一个REST API调用的例子。我们有不同路由的API对象和一个API调用。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="0aee" class="nl kx iq ms b gy nm nn l no np">const catApi = {<br/>   listCats: (callback) =&gt; {<br/>     // fetching cats, filtering out the dogs<br/>     callback(null, result);<br/>   }<br/>}</span><span id="c8a2" class="nl kx iq ms b gy nq nn l no np">catApi.listCats((err, result) =&gt; {<br/>   console.log(result);<br/>});</span></pre><p id="730b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在看起来没那么糟了，是吗？如果只有一件事要做，它就不会，在某些场景中，它可能是一个有用的设计模式。</p><p id="e121" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是如果我们必须做一连串的动作呢？然后它迅速分裂，我们受到回调地狱的欢迎。这甚至没有任何错误处理！</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="64b6" class="nl kx iq ms b gy nm nn l no np">catApi.listCats((err, result) =&gt; {<br/>   result.forEach((cat) =&gt; {<br/>      creditService.isRich(cat, (err, result) =&gt; {<br/>          presentService.giveExtraAttention(cat);<br/>      });<br/>   });<br/>});</span></pre><p id="9a99" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">根据需求的不同，这可能会变得非常难看和难以阅读，从而导致更多的错误，在添加新的逻辑和维护整个事物时花费更多的时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/e0c66272b4ea762894fd185393f8a4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDCQHyzL75_itr5GUZKHHw.png"/></div></div></figure><h1 id="7a31" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">承诺</h1><p id="7438" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">令人欣慰的是，回调情况被视为一个问题，一种补救措施被创造出来，称为承诺。它们有点难以理解，但是如果你想写干净漂亮的代码，理解它们是必须的。在这里可以找到对它们的很好的解释<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">。对于我们正在进行的cat API示例，让我们使用承诺来代替回调:</a></p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="7aff" class="nl kx iq ms b gy nm nn l no np">const catApi = {<br/>    listCats: () =&gt; {<br/>        return new Promise((resolve, reject) =&gt; {<br/>            // fetching cats, filtering out the dogs  <br/>            resolve(result);<br/>        });<br/>    }<br/>}</span><span id="8904" class="nl kx iq ms b gy nq nn l no np">catApi.listCats()<br/>.then((result) =&gt; {<br/>    console.log(result);<br/>})<br/>.catch((err) =&gt; {<br/>    console.error("There is a dog!");<br/>});</span></pre><p id="cb35" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看起来不同，但感觉相似，因为我们仍在传递函数，一个传递成功，一个传递错误。</p><p id="bef9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">承诺的袖子里有一张王牌——它们是可以用链子拴住的，不再需要我们去无限远的地方然后回来(尽管，如果你愿意，你仍然可以这么做，你这个怪物)。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="1f60" class="nl kx iq ms b gy nm nn l no np">catApi.listCats()<br/>.then((cats) =&gt; {<br/>    console.log(cats);<br/>    return cats;<br/>})<br/>.then((cats) =&gt; {<br/>    return cats.map((cat) =&gt; {return `${cat}_1`});<br/>})<br/>.then((cats) =&gt; {<br/>    console.log(cats);<br/>})</span></pre><p id="c91a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">获取我们的猫，注销它们，混淆它们的名字，并再次输出它们。这看起来和感觉现在都很好，虽然有一个更好的方法，甚至更直接。</p><h1 id="6bf5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">异步/等待</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/45fc2370457dbfbda1a216b351ddb0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*LndC4E1jsQwPsFxau_F1KA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This feels really good</figcaption></figure><p id="e64e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有了这两个关键词，我们就可以顾名思义，<code class="fe mp mq mr ms b">await </code>就一诺千金了。有一个问题，这个函数必须声明为<code class="fe mp mq mr ms b">async</code>才能工作，尽管我认为这是为了极度清晰而付出的小小代价。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="9b97" class="nl kx iq ms b gy nm nn l no np">const cats = await catApi.listCats();<br/>console.log(cats);</span></pre><p id="f271" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们想连续做多个操作呢？</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="63a1" class="nl kx iq ms b gy nm nn l no np">const cats = await catApi.listCats();<br/>console.log(cats);</span><span id="f045" class="nl kx iq ms b gy nq nn l no np">const fedCats = await catApi.feedCats(cats);<br/>console.log(fedCats);</span></pre><p id="caf3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">等等，你不是在检查错误。如果一个承诺被拒绝，错误就会被抛出，我们所要做的就是在某个地方捕捉它。</p><pre class="kg kh ki kj gt nh ms ni nj aw nk bi"><span id="1794" class="nl kx iq ms b gy nm nn l no np">try {<br/>    const cats = await catApi.listCats();<br/>    console.log(cats);</span><span id="4005" class="nl kx iq ms b gy nq nn l no np">    const fedCats = await catApi.feedCats(cats);<br/>    console.log(fedCats);<br/>} catch(e) {<br/>    console.log(e);<br/>}</span></pre><p id="4a9e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我发现这种类型的代码在阅读时产生的认知负荷最少，因为几乎没有嵌套，没有回调，也很少出现混乱。</p></div></div>    
</body>
</html>