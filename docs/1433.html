<html>
<head>
<title>The right way to make API calls in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中进行API调用的正确方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-right-way-to-make-api-calls-in-angular-5cc03a62bf43?source=collection_archive---------0-----------------------#2020-03-16">https://javascript.plainenglish.io/the-right-way-to-make-api-calls-in-angular-5cc03a62bf43?source=collection_archive---------0-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0a1fb78774653fa9af9a52bb8fcd246d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9-MJ19yipPbWqIab.png"/></div></div></figure><div class=""/><div class=""><h2 id="b5ad" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">如何使用<strong class="ak"> HTTPClient </strong>库做到这一点？</h2></div><p id="b14f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在，几乎所有的前端应用程序都使用HTTP协议与后端服务进行通信。现代浏览器可以通过两种方式发出HTTP请求— <strong class="ks jc"> <em class="lm"> XMLHttpRequest </em> </strong>接口和<strong class="ks jc"> <em class="lm"> fetch() </em> </strong> API。</p><p id="191a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> Angular </strong>提供了HttpClient模块，允许开发者发送HTTP <strong class="ks jc">请求</strong>并对远程HTTP服务器进行<strong class="ks jc"> API调用</strong>。</p><blockquote class="ln"><p id="3c6d" class="lo lp jb bd lq lr ls lt lu lv lw ll dk translated">HttpClient是一个可注入的类，带有执行HTTP请求的方法。每个请求方法都有多个签名，返回类型根据被调用的签名而变化(主要是observe和responseType的值)。”—棱角分明。超正析象管(Image Orthicon)</p></blockquote><p id="144f" class="pw-post-body-paragraph kq kr jb ks b kt lx kc kv kw ly kf ky kz lz lb lc ld ma lf lg lh mb lj lk ll ij bi translated">它在<strong class="ks jc"><em class="lm">@ angular/common/HTTP</em></strong>模块中提供，提供了基于浏览器公开的<strong class="ks jc"><em class="lm">XMLHttpRequest</em></strong>接口的简化客户端<strong class="ks jc"> HTTP API </strong>。</p><p id="6276" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">使用这个api有很多好处，值得一提的有— </em></p><ul class=""><li id="f188" class="mc md jb ks b kt ku kw kx kz me ld mf lh mg ll mh mi mj mk bi translated"><em class="lm">简单测试</em></li><li id="7df7" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated"><em class="lm">键入请求&amp;响应对象</em></li><li id="a5cf" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated"><em class="lm">请求和响应拦截</em></li><li id="bd05" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated"><em class="lm">API可观察支持</em></li><li id="3bc4" class="mc md jb ks b kt ml kw mm kz mn ld mo lh mp ll mh mi mj mk bi translated"><em class="lm">简单的错误处理</em></li></ul><h1 id="c34a" class="mq mr jb bd ms mt mu mv mw mx my mz na kh nb ki nc kk nd kl ne kn nf ko ng nh bi translated">使用</h1><p id="ba4b" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">在app.module.ts文件中:</p><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="7548" class="nw mr jb ns b gy nx ny l nz oa">import { HttpClientModule } from '<a class="ae ob" href="http://twitter.com/angular/common" rel="noopener ugc nofollow" target="_blank">@angular/common</a>/http';</span><span id="ebab" class="nw mr jb ns b gy oc ny l nz oa">@NgModule({<br/>  declarations: [<br/>    ////....<br/>  ],<br/>  imports: [<br/>    // Other Modules...,<br/>    HttpClientModule    <br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})</span><span id="2fd8" class="nw mr jb ns b gy oc ny l nz oa">export class AppModule { }</span></pre><p id="5d46" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦<strong class="ks jc"><em class="lm">http client module</em></strong>被导入到<strong class="ks jc"> AppModule </strong>中，我们就可以很容易地将<strong class="ks jc"> HTTPClient </strong>注入到data.service.ts文件中如下所示的应用程序类中。</p><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="1dcc" class="nw mr jb ns b gy nx ny l nz oa">import { Injectable } from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';</span><span id="df96" class="nw mr jb ns b gy oc ny l nz oa">@Injectable()<br/>export class DataService {<br/>  constructor(private httpClient: HttpClient) { }</span><span id="2401" class="nw mr jb ns b gy oc ny l nz oa">getPosts() {<br/>    return this.httpClient<br/>    .get('https://jsonplaceholder.typicode.com/posts')<br/>  }<br/>}</span></pre><h1 id="4278" class="mq mr jb bd ms mt mu mv mw mx my mz na kh nb ki nc kk nd kl ne kn nf ko ng nh bi translated">键入的响应</h1><p id="74da" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">我们还可以配置<strong class="ks jc"> HTTPClient </strong>请求来期望类型化的响应对象。这将使用户更容易、更明显地消费输出。</p><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="4940" class="nw mr jb ns b gy nx ny l nz oa">getEntities(): Observable&lt;Entity[]&gt; {<br/>    return this.httpClient.get&lt;Entity[]&gt;(this.apiUrl)     <br/>}</span></pre><h2 id="0707" class="nw mr jb bd ms od oe dn mw of og dp na kz oh oi nc ld oj ok ne lh ol om ng on bi translated">不支持CORS时进行服务器调用:</h2><p id="ce0a" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">当服务器不支持<strong class="ks jc"> CORS </strong>时，我们也可以使用HttpClient模块进行Http调用。</p><p id="d9e1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在Angular中，<strong class="ks jc"> <em class="lm"> JSONP </em> </strong>请求返回一个可观察值。这里，我们可以首先订阅observables，然后使用<strong class="ks jc"> RxJS </strong> map操作符来转换响应。一旦完成，我们就可以使用异步管道来管理响应结果。</p><p id="57c0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">要使用<strong class="ks jc"> <em class="lm"> JSONP </em> </strong>，我们必须先将<strong class="ks jc"><em class="lm">HttpClientJsonpModule</em></strong>包含在NgModule导入中。</p><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="b318" class="nw mr jb ns b gy nx ny l nz oa">getPosts() : Observable {<br/>    return this.httpClient.jsonp('apiURL', 'callback').pipe(<br/>      catchError(this.handleError('searchHeroes', [])) <br/>      // then handle the errorResponse<br/>   );<br/>}</span></pre><h1 id="9f9b" class="mq mr jb bd ms mt mu mv mw mx my mz na kh nb ki nc kk nd kl ne kn nf ko ng nh bi translated">HttpClient中的错误处理</h1><figure class="nn no np nq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/c9e51c73bd2898c4d5c3e42093ba8b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0iU_x6E2cxPWnSIcWBdDQ.png"/></div></div></figure><p id="74a7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在任何应用程序中，我们都需要处理两种类型的错误——服务器端和客户端。</p><p id="c977" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">服务器后端</strong>可能会拒绝这个请求，返回一个带有状态代码的HTTP响应，比如404或500。</p><p id="61e8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">客户端</strong>错误可以像网络错误一样导致请求未成功完成，或者在<strong class="ks jc"> <em class="lm"> RxJS </em> </strong>操作符中抛出任何异常。这些异常或错误的结果将是JavaScript<strong class="ks jc"><em class="lm">error event</em></strong>对象。</p><p id="9778" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">HttpClient api的一个好处是，它可以捕获其<strong class="ks jc"><em class="lm">HttpErrorResponse</em></strong>中的两种错误，我们可以使用响应来找出问题的真正原因。</p><ul class=""><li id="5fb5" class="mc md jb ks b kt ku kw kx kz me ld mf lh mg ll mh mi mj mk bi translated"><strong class="ks jc">创建错误处理程序</strong></li></ul><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="8ea5" class="nw mr jb ns b gy nx ny l nz oa">/**<br/> * Handle Http operation that failed.<br/> * Let the app continue.<br/> * @param operation - name of the operation that failed<br/> * @param result - optional value to return as the observable result<br/> */</span><span id="abdc" class="nw mr jb ns b gy oc ny l nz oa"><strong class="ns jc">private handleError(errorResponse: HttpErrorResponse)</strong> {<br/>    if (errorResponse.error instanceof ErrorEvent) {<br/>      // A client-side or network error occurred. Handle it   accordingly.<br/>      console.error('An error occurred:',   errorResponse.error.message);<br/>    } <br/>   else {<br/>      // The backend returned an unsuccessful response code.<br/>      // The response body may contain clues as to what went wrong,<br/>      console.error(<br/>        'Backend returned code ${errorResponse.status}, '+<br/>        'body was: ${errorResponse.error}');<br/>    }</span><span id="6558" class="nw mr jb ns b gy oc ny l nz oa">    // return an observable with a user-facing error message<br/>    return throwError(<br/>      'Error Occurred; please try again later.');<br/>  };</span></pre><p id="1c87" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的例子中，我们返回了<strong class="ks jc"><em class="lm">RxJS</em></strong><strong class="ks jc"><em class="lm">error observable</em></strong>，这样服务消费者就可以很容易地处理它。</p><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="fc57" class="nw mr jb ns b gy nx ny l nz oa">getEntities(): Observable&lt;Entity[]&gt; {<br/>    return this.httpClient.get&lt;Entity[]&gt;(this.apiUrl)<br/>     .pipe(<br/>      catchError(this.<strong class="ns jc">handleError</strong>)<br/>     ); <br/>  }</span></pre><ul class=""><li id="5980" class="mc md jb ks b kt ku kw kx kz me ld mf lh mg ll mh mi mj mk bi translated"><strong class="ks jc">更通用的方法</strong></li></ul><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="a151" class="nw mr jb ns b gy nx ny l nz oa">/**<br/> * Handle Http operation that failed.<br/> * Let the app continue.<br/> * @param operation - name of the operation that failed<br/> * @param result - optional value to return as the observable result<br/> */<br/>  <strong class="ns jc">private handleError&lt;T&gt;(operation = 'operation', result?: T) </strong>{<br/>    return (error: any): Observable&lt;T&gt; =&gt; {</span><span id="ed4c" class="nw mr jb ns b gy oc ny l nz oa">// TODO: send the error to remote logging infrastructure<br/>      console.error(error); // log to console instead</span><span id="595e" class="nw mr jb ns b gy oc ny l nz oa">// TODO: better job of transforming error for user consumption<br/>      this.log(`${operation} failed: ${error.message}`);</span><span id="5138" class="nw mr jb ns b gy oc ny l nz oa">// Let the app keep running by returning an empty result.<br/>      return of(result as T);<br/>    };<br/>  }</span></pre><p id="1d85" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在使用上面的方法如下-</p><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="3ad7" class="nw mr jb ns b gy nx ny l nz oa">getEntities(): Observable&lt;Entity[]&gt; {<br/>    return this.httpClient.get&lt;Entity[]&gt;(this.apiUrl)<br/>     .pipe(      <br/>   catchError(this.<strong class="ns jc">handleError</strong>&lt;Entity&gt;('getEntities'))<br/>     ); <br/>  }</span></pre><ul class=""><li id="39c8" class="mc md jb ks b kt ku kw kx kz me ld mf lh mg ll mh mi mj mk bi translated"><strong class="ks jc">我们也可以使用</strong><a class="ae ob" href="https://angular.io/api/common/http/HttpInterceptor#description" rel="noopener ugc nofollow" target="_blank"><strong class="ks jc"><em class="lm">http interceptor</em></strong></a><strong class="ks jc">来处理错误。</strong>使用这个，我们还可以检查并转换从应用程序到服务器的HTTP请求。</li></ul><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="5f77" class="nw mr jb ns b gy nx ny l nz oa">import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';</span></pre><p id="3a61" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">拦截器还可以在一个例程中为每个HTTP请求/响应执行多个<em class="lm">隐式</em>任务，从认证到日志。在这篇文章中，我不会详细讨论它的实现，我会试着写另一篇文章。</p><h1 id="7fb8" class="mq mr jb bd ms mt mu mv mw mx my mz na kh nb ki nc kk nd kl ne kn nf ko ng nh bi translated">重试请求</h1><p id="cfde" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">有些情况下，重试<strong class="ks jc"> HttpRequest </strong>会导致成功完成，就像大多数网络错误一样。</p><p id="15c0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">RxJS库提供了几个我们可以使用的重试操作符。最简单的是<strong class="ks jc"> <em class="lm"> retry() </em> </strong>我们可以用它来自动重新订阅一个失败的可观察对象，指定次数。</p><p id="ab3d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦我们重新订阅了一个<strong class="ks jc"> HttpClient </strong>方法的结果，它将自动重新发出HTTP请求。</p><pre class="nn no np nq gt nr ns nt nu aw nv bi"><span id="5afb" class="nw mr jb ns b gy nx ny l nz oa">getEntities(): Observable&lt;Entity[]&gt; {<br/>    return this.httpClient.get&lt;Entity[]&gt;(this.apiUrl)<br/>     .pipe(<br/> <strong class="ns jc">     retry(2), // retry a failed request up to 2 times</strong><br/>      catchError(this.handleError&lt;Entity&gt;('getEntities'))<br/>     ); <br/>  }</span></pre></div></div>    
</body>
</html>