<html>
<head>
<title>5 Advanced JavaScript Techniques You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的5种高级JavaScript技术</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-advanced-javascript-techniques-you-should-know-4362e26f2ca8?source=collection_archive---------0-----------------------#2020-12-15">https://javascript.plainenglish.io/5-advanced-javascript-techniques-you-should-know-4362e26f2ca8?source=collection_archive---------0-----------------------#2020-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7467" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们节省时间，用这些技术提高工作效率和专业水平</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca9c664e03a801b4c12449b526c29520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KxQ8EaXyBOX7rwVb"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kvncnls?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Canlas</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="56d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你在寻找更多的JavaScript技术吗？</p><p id="c7ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是这样，你来对地方了。</p><p id="7067" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示我用来提高代码库质量的5种高级JavaScript技术。</p><p id="a675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。</p><h1 id="829e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.关闭</h1><p id="18ae" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">闭包是Javascript中的一项重要技术。这意味着内部函数总是可以访问外部函数的变量和参数，即使外部函数已经返回。</p><p id="ffc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用闭包来保护不想暴露给外部范围的数据。</p><p id="49a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您想在每次点击按钮时将一个<code class="fe mp mq mr ms b">counter</code>变量增加一个单位。类似于:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="65c1" class="mx lt iq ms b gy my mz l na nb">&lt;button onclick=”increaseCounter()”&gt;Increase Counter&lt;/button&gt;</span></pre><p id="0505" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，我们可以用一个全局来完成这个任务:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="30ec" class="mx lt iq ms b gy my mz l na nb">let counter = 0;</span><span id="ae9a" class="mx lt iq ms b gy nc mz l na nb">function increaseCounter() {<br/>  counter++;<br/>}</span></pre><p id="ff35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是不需要调用<code class="fe mp mq mr ms b">increaseCounter()</code>函数就可以直接改变<code class="fe mp mq mr ms b">counter</code>变量。</p><p id="17c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们将<code class="fe mp mq mr ms b">counter</code>变量移到函数中:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6e99" class="mx lt iq ms b gy my mz l na nb">function increaseCounter() {<br/>  let counter = 0;<br/>  counter++;<br/>}</span></pre><p id="76c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不，每次函数被调用时，<code class="fe mp mq mr ms b">counter</code>变量将被重置为<code class="fe mp mq mr ms b">0</code>。</p><p id="00cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是终结发挥作用的时候:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="b169" class="mx lt iq ms b gy my mz l na nb">const increaseCounter = (function() {<br/>  let counter = 0;<br/> <br/>  return function() {<br/>    counter = counter + 1;<br/>    console.log(counter);<br/>  };<br/>})();</span></pre><p id="6fff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">IIFE只运行一次，用<code class="fe mp mq mr ms b">0</code>初始化<code class="fe mp mq mr ms b">counter</code>变量，然后返回一个可以访问<code class="fe mp mq mr ms b">counter</code>变量的函数。所以，当你调用<code class="fe mp mq mr ms b">increaseCounter()</code>时，它会按预期更新<code class="fe mp mq mr ms b">counter</code>。</p><h1 id="589f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.功能连接</h1><p id="b822" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我敢打赌，你曾经面临过这样的问题:一个<code class="fe mp mq mr ms b">this</code>并不是你所期望的<code class="fe mp mq mr ms b">this</code>。具体来说，当您将对象方法作为回调传递时，<code class="fe mp mq mr ms b">this</code>会丢失。请参见下面的示例:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="061e" class="mx lt iq ms b gy my mz l na nb">let book = {<br/>  title: ‘Learn JavaScript’,<br/>  printTitle() {<br/>    console.log(`Book’s title: ${this.title}`);<br/>  }<br/>}</span><span id="68f5" class="mx lt iq ms b gy nc mz l na nb">setTimeout(book.printTitle, 1000); // Book’s title: undefined</span></pre><p id="abc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们期望的打印文本是<code class="fe mp mq mr ms b">Book’s title: Learn JavaScript</code>，但我们得到的是<code class="fe mp mq mr ms b">Book’s title: undefined</code>。是因为程序已经不知道<code class="fe mp mq mr ms b">this</code>了。现在上下文丢失了。</p><p id="bfbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们可以使用函数绑定技术。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d0c1" class="mx lt iq ms b gy my mz l na nb">let book = {<br/>  title: ‘Learn JavaScript’,<br/>  printTitle() {<br/>    console.log(`Book’s title: ${this.title}`);<br/>  }<br/>}</span><span id="d726" class="mx lt iq ms b gy nc mz l na nb">let printTitle = book.printTitle.bind(book);</span><span id="f52d" class="mx lt iq ms b gy nc mz l na nb">setTimeout(printTitle, 1000); // Book’s title: JavaScript</span></pre><p id="a774" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写过一篇关于函数绑定的详细文章。如果您想了解更多关于这种技术的知识，您应该查看这篇文章:</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/javascript-in-plain-english/how-to-control-this-better-in-javascript-dcacd54bcf97" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">如何在JavaScript中更好地控制“this”</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">使用call()、apply()和bind()方法</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div><h1 id="ae5b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.任务调度</h1><p id="9b5d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JavaScript提供了两种简单的方法来调度任务的执行:</p><p id="0309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">setInterval()</code>以一定的时间间隔重复运行任务:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="b3c5" class="mx lt iq ms b gy my mz l na nb">function sayHello() {<br/>  console.log(‘Hello from the other side!’);<br/>}</span><span id="02dc" class="mx lt iq ms b gy nc mz l na nb">setInterval(sayHello, 1000);</span></pre><p id="6dcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，每隔1000毫秒就会重复执行<code class="fe mp mq mr ms b">sayHello()</code>功能。</p><p id="686f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">setTimeout()</code>每隔一段时间运行一次任务<em class="nv"/>:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6f55" class="mx lt iq ms b gy my mz l na nb">function sayHello() {<br/>  console.log(‘Hello from the other side!’);<br/>}</span><span id="3014" class="mx lt iq ms b gy nc mz l na nb">setTimeout(sayHello, 1000);</span></pre><p id="9108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe mp mq mr ms b">sayHello()</code>功能将在1000毫秒后只运行一次。</p><h1 id="9d3e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.递归</h1><p id="c889" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">编程中的一些任务用传统方法很难解决。它们需要大量的逻辑和思考。然而，如果您应用递归技术，事情会简单得多。这是一种将一个大任务分解成几个更小更简单的同类任务的技术，你不用想太多就能理解。</p><p id="5f2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你看到一个函数调用它自己时，你就会知道递归技术在使用。</p><p id="ecd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们将编写一个以<code class="fe mp mq mr ms b">x</code>和<code class="fe mp mq mr ms b">n</code>为参数的函数，并返回<code class="fe mp mq mr ms b">x</code>乘以自身<code class="fe mp mq mr ms b">n</code>的值。</p><p id="2403" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于传统方法，我们将使用循环语句:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="696c" class="mx lt iq ms b gy my mz l na nb">function pow(x, n) {<br/>  let result = 1;</span><span id="9983" class="mx lt iq ms b gy nc mz l na nb">  for (let i = 0; i &lt; n; i++) {<br/>    result = result * x;<br/>  }</span><span id="ad67" class="mx lt iq ms b gy nc mz l na nb">  return result;<br/>}</span><span id="8752" class="mx lt iq ms b gy nc mz l na nb">console.log(pow(3, 5)); // 243</span></pre><p id="40b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们应用递归方法时，它会是这样的:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="fd35" class="mx lt iq ms b gy my mz l na nb">function pow(x, n) {<br/>  if (n === 1) {<br/>    return x;<br/>  } else {<br/>    return x * pow(x, n — 1);<br/>  }<br/>}</span><span id="f1b5" class="mx lt iq ms b gy nc mz l na nb">console.log(pow(3, 5)); // 243</span></pre><p id="90e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe mp mq mr ms b">n === 1</code>的时候，结果是如此的明显。这里没什么好讲的，因为<code class="fe mp mq mr ms b">pow(x, 1)</code>会返回<code class="fe mp mq mr ms b">x</code>。</p><p id="869c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mp mq mr ms b">n</code>大于<code class="fe mp mq mr ms b">1</code>，那么我们用数学常识将<code class="fe mp mq mr ms b">pow(x, n)</code>表示为<code class="fe mp mq mr ms b">x * pow(x, n — 1)</code>(例:x⁷ = x * x⁶).我们一直这样后退一步，直到<code class="fe mp mq mr ms b">n === 1</code>。</p><p id="1bef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上只是一个简单的递归例子，你也可以用传统的方法轻松实现。然而，在您的编程生涯中，您会遇到为了简单起见而更愿意使用递归来解决的任务。</p><p id="591b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，您可以将递归实现转换为迭代实现。但在某些情况下，这需要付出很多努力。更不用说你的代码会很难看，很难读懂。</p><p id="b7f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，如果您不小心使用递归，它可能会损害性能。所以，明智地使用它。</p><h1 id="ca49" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.定义名称空间</h1><p id="ad7d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">添加到项目中的代码越多，发生冲突的可能性就越大。</p><p id="6193" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">避免冲突的最好方法之一是使用名称空间。这是一种允许您将代码的一部分包装在唯一名称下的技术。</p><p id="e3f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能知道但没有意识到的命名空间的最简单的例子是对象:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="71b4" class="mx lt iq ms b gy my mz l na nb">let animal = {<br/>  move: () =&gt; {<br/>    console.log(‘Move!’);<br/>  },<br/>  jump: () =&gt; {<br/>    consle.log(‘Jump!’);<br/>  }<br/>};</span></pre><p id="76a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，<code class="fe mp mq mr ms b">move()</code>和<code class="fe mp mq mr ms b">jump()</code>函数的命名空间在<code class="fe mp mq mr ms b">animal</code>下。我们用<code class="fe mp mq mr ms b">animal.move()</code>和<code class="fe mp mq mr ms b">animal.jump()</code>来称呼它们。</p><p id="b939" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在有大量源代码文件的真实项目中，我们使用名称空间的方式如下:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c722" class="mx lt iq ms b gy my mz l na nb">if (typeof APP === “undefined”) {<br/>  APP = {};<br/>  APP.ANIMAL = {};<br/>}</span><span id="16e0" class="mx lt iq ms b gy nc mz l na nb">APP.ANIMAL.move = () =&gt; {<br/>  console.log(‘Move’);<br/>};</span><span id="6427" class="mx lt iq ms b gy nc mz l na nb">APP.ANIMAL.jump = () =&gt; {<br/>  console.log(‘Jump’);<br/>};</span><span id="19df" class="mx lt iq ms b gy nc mz l na nb">APP.ANIMAL.move(); // Move<br/>APP.ANIMAL.jump(); // Jump</span></pre><p id="1e63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过创建这样一个独特的名称空间，您可以避免所有恼人的冲突。</p><h1 id="73a9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="f95f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">以上是我想向你介绍的5种提高代码质量的JavaScript技术。如果你能把它们应用到你的实际项目中，那就太好了。</p><p id="0f57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你知道其他很酷的技术吗？请在下面的评论中告诉我。</p><p id="6c07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你喜欢这篇文章。</p><p id="e05c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://bracketshack.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="nv">和我一起分享更多关于编程的有益见解。</em> </strong> </a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="8d36" class="mx lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated">进一步阅读</h2><div class="nd ne gp gr nf ng"><a href="https://medium.com/javascript-in-plain-english/9-tips-for-writing-scalable-javascript-code-e6bcfc791882" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">编写可伸缩JavaScript代码的9个技巧</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">您应该从一开始就准备好扩展您的项目</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="oo l nr ns nt np nu kp ng"/></div></div></a></div></div></div>    
</body>
</html>