<html>
<head>
<title>Caching made easy with React Query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Query让缓存变得简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-query-fbefc608ed95?source=collection_archive---------1-----------------------#2020-05-08">https://javascript.plainenglish.io/react-query-fbefc608ed95?source=collection_archive---------1-----------------------#2020-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d82a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">管理服务器状态就是这么简单。</h2></div><p id="4f96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗨，大家好，我写这篇文章是想和大家分享一个库，它让管理React应用程序上的服务器状态变得简单而有趣——React Query。</p><p id="6e3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博文中，我将做一个简单的介绍，解释是什么导致了它的产生，然后介绍一下<code class="fe lb lc ld le b">useQuery</code>钩子是如何工作的。在这篇文章的最后，我将展示一些我们可以进行的定制配置，以及我们如何进行缓存失效、数据重取和乐观更新。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/75c1ce258cdd50c861caeee8d97b7cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zHLTRMGX6SRuT-Lq"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Photo by <a class="ae lv" href="https://unsplash.com/@fachymarin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fachy Marín</a> on <a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7a59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，许多React应用程序一直依赖全局状态作为在组件之间共享数据和避免正确钻探方法。</p><p id="5bb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管有这个明显的优势，但是全局数据经常被不恰当地使用，并且经常不考虑我们在应用程序中添加的内容是否应该是全局的。另一件经常发生的事情是混合服务器状态和客户端状态。那么客户端状态和服务器状态有什么区别呢？</p><h2 id="801c" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">附庸国</h2><p id="a5a0" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">这是我们的应用程序所拥有的状态类型。这种状态是临时的、局部的，并且通常在会话之间是不持久的。它是通过没有任何延迟的同步API来访问的。这种状态更可靠，因为它通常总是最新的。</p><h2 id="3c2d" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">服务器状态</h2><p id="01cc" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">这种状态是远程持久化的，这意味着我们可以与其他应用程序共享它的所有权。它是异步的，所以这意味着我们需要使用异步API来访问它。由于这些情况，这意味着我们不能保证这个状态在我们的应用程序上是最新的。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="e8c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将我们的全局状态混合在服务器和客户端状态中，我们可能最终会做出权衡，当与另一种状态相比时，更倾向于一种类型的状态。</p><p id="d1f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务器状态有着非常特殊的挑战，这是客户端状态所没有的。这些挑战包括缓存、后台更新、重复数据删除请求、处理过时请求等。</p><p id="64bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了应对这些挑战并把我们的服务器状态从我们的客户机状态中分离出来，React Query应运而生。</p><h1 id="f4cb" class="nb lx iq bd ly nc nd ne mb nf ng nh me jw ni jx mh jz nj ka mk kc nk kd mn nl bi translated">什么是React查询？</h1><p id="3b40" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">React Query是React中用于获取、缓存和更新异步状态的钩子的集合。这是一个简单而小巧的API，无需配置即可开箱即用。</p><p id="abc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是协议不可知的，所以这意味着我们可以使用REST、GraphQL或任何用例，并且它支持自动缓存和开箱即用的重新提取。</p><h1 id="9461" class="nb lx iq bd ly nc nd ne mb nf ng nh me jw ni jx mh jz nj ka mk kc nk kd mn nl bi translated">贮藏</h1><p id="a389" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">React Query的伟大之处在于，缓存是在“幕后”完成的，我们几乎不需要担心它。</p><p id="04fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看<code class="fe lb lc ld le b">useQuery</code>钩。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk"><code class="fe lb lc ld le b">useQuery</code> usage</figcaption></figure><p id="e54b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对<code class="fe lb lc ld le b">useQuery</code>的每个调用都必须使用<strong class="kh ir">唯一键</strong>和用于解析数据的函数来完成。</p><p id="8db4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">密钥必须符合以下类型:</p><p id="dbdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">String | [String, Variables: Object] | falsy | Function =&gt; queryKey</code></p><p id="87cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此查询关键字有一些注意事项:</p><ul class=""><li id="0e15" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">它应该是唯一的，因为它将在内部用于重新提取、缓存和重复数据消除相关的查询。</li><li id="332b" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">在内部，它将被转换成一个数组。因此，如果你只提供一个字符串，它将在内部被转换成['key']。</li><li id="07ac" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">它们是确定性序列化的。这意味着在我们使用['key '，{page，status}]作为键的情况下，顺序是无关紧要的。</li><li id="fd1a" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">键按照它们在键数组中出现的顺序作为参数传递给查询函数。</li><li id="75c2" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">如果falsy值作为查询键的一部分被传递，那么查询函数将不会被调用。这在我们希望进行串行查询的情况下非常有用(当我们需要来自一个查询的数据来执行下一个查询时)。</li></ul><p id="e5ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询功能必须考虑以下几点:</p><p id="f16e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Function(variables) =&gt; Promise(data/error)</code></p><p id="9066" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这最后一部分令人兴奋，因为这意味着你可以使用<em class="oc"> fetch </em>、<em class="oc"> axios </em>，或者你应用程序上的任何东西，只要它能解析你需要的数据。</p><h2 id="1b93" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">一些缓存注意事项</h2><ul class=""><li id="b5e4" class="no np iq kh b ki mp kl mq ko od ks oe kw of la nt nu nv nw bi translated">解析后，呈现的查询结果将变得陈旧。这意味着，如果refetchOnWindowFocus属性处于活动状态，它们将在每次新的装载或页面焦点时自动重新提取。为了避免这种情况，我们应该指定<em class="oc"> staleTime </em>属性。</li><li id="9891" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">当用户重新聚焦浏览器窗口时，过时的查询将被重新提取。为了避免这种情况，我们应该改变<em class="oc"> refetchOnWindowFocus </em>属性。</li></ul><h1 id="810d" class="nb lx iq bd ly nc nd ne mb nf ng nh me jw ni jx mh jz nj ka mk kc nk kd mn nl bi translated">缓存失效、数据重新提取和乐观更新</h1><p id="d7c0" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如果我们需要执行服务器副作用，比如创建/更新/删除数据，我们有一个<code class="fe lb lc ld le b">useMutation</code>钩子。这个钩子真的很有用，如果我们因为一些POST而需要数据重取的话。</p><p id="e468" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以利用它的onSuccess选项来访问<code class="fe lb lc ld le b">queryCache</code>对象，并执行一些查询重取和当前缓存失效。这可以从下面的例子中看出</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">on addBlogPost mutation success refetch all queries that have “posts” as key.</figcaption></figure><p id="cfd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们愿意，我们还可以利用<code class="fe lb lc ld le b">onMutate</code>选项并执行乐观更新。这将允许我们在服务器端发生突变之前更新我们的UI，因此必须小心使用，如果突变失败，我们可能最终向用户显示不同步的数据。为了避免这最后一个用例，我们可以回滚我们的更改。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">When an optimistic update is performed, a reference to the previousPosts is returned in case we have to rollback onError.</figcaption></figure><h1 id="0d4b" class="nb lx iq bd ly nc nd ne mb nf ng nh me jw ni jx mh jz nj ka mk kc nk kd mn nl bi translated">配置</h1><p id="5b3b" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如果您经常定义staleTime属性或任何其他属性，您可以利用ReactQueryConfigProvider来包装您的应用程序，并设置React查询挂钩将使用的默认值。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Setting some defaults using the ReactQueryConfigProvider</figcaption></figure><h1 id="5024" class="nb lx iq bd ly nc nd ne mb nf ng nh me jw ni jx mh jz nj ka mk kc nk kd mn nl bi translated">结论</h1><p id="f458" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如您所见，使用React Query管理服务器状态要简单得多。</p><p id="ffa1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想了解更多，我邀请您阅读<a class="ae lv" href="https://github.com/tannerlinsley/react-query" rel="noopener ugc nofollow" target="_blank">官方文档</a>并观看<a class="ae lv" href="https://www.youtube.com/watch?v=Wyk01ySxg0A&amp;feature=youtu.be&amp;t=12192" rel="noopener ugc nofollow" target="_blank"> Tanner Linsley在React峰会</a>上的演讲，他在演讲中介绍了React Query并展示了一个更实用的示例。</p><p id="c4d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢，并期待下一集。</p><p id="bf7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你周末愉快，下次再见！</p><h2 id="965a" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="da6e" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意吧:<a class="ae lv" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kh ir">JavaScript in Plain English</strong></a>，<a class="ae lv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kh ir">AI in Plain English</strong></a>，<a class="ae lv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kh ir">UX in Plain English</strong></a>，<a class="ae lv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kh ir">Python in Plain English</strong></a><strong class="kh ir"/>—谢谢，继续学习！</p><p id="f6f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae lv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">submissions @ plain English . io</strong></a><strong class="kh ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>