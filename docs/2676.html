<html>
<head>
<title>JavaScript Best Practices — Spacing, Lines, and Callback Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—间距、行和回调错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-spacing-lines-and-call-be6ab9f63eeb?source=collection_archive---------16-----------------------#2020-07-13">https://javascript.plainenglish.io/javascript-best-practices-spacing-lines-and-call-be6ab9f63eeb?source=collection_archive---------16-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6123fa23d0c103304fd805b17b92dc86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pJU2PyXCXHRgBE3C"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@theamazingdjw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Wayman</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2fc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="2a38" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">命名F <code class="fe lz ma mb mc b">unction</code>表达式</h1><p id="53af" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">函数表达式中的名字不是很有用。</p><p id="244f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将函数设置为一个变量，我们就不能用那个名字来使用它。</p><p id="edfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在生活中也不太需要它。</p><p id="4b93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6ce7" class="mq lc iq mc b gy mr ms l mt mu">Foo.prototype.bar = function() {};</span></pre><p id="7815" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c9ba" class="mq lc iq mc b gy mr ms l mt mu">Foo.prototype.bar = function bar() {};</span></pre><p id="eebc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ed91" class="mq lc iq mc b gy mr ms l mt mu">(function() {<br/>    // ...<br/>}())</span></pre><p id="e818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1f8a" class="mq lc iq mc b gy mr ms l mt mu">(function bar() {<br/>    // ...<br/>}())</span></pre><p id="2ad5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除非我们需要函数内部的名字，否则它没那么有用。</p><h1 id="594d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">F <code class="fe lz ma mb mc b">unction</code>声明或表达式的一致使用</h1><p id="744b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了保持一致性，我们可以保持一种函数风格。</p><p id="2473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以要么我们坚持:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fcd7" class="mq lc iq mc b gy mr ms l mt mu">function doWork() {<br/>  // ...<br/>}</span></pre><p id="c9ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f80c" class="mq lc iq mc b gy mr ms l mt mu">const doWork = function() {<br/>  // ...<br/>};</span></pre><p id="4c9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头函数只能使用第二种样式。</p><h1 id="cbd8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数调用的参数之间换行</h1><p id="9832" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们只需要参数换行符，函数调用只需要长表达式或参数列表。</p><p id="b558" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4220" class="mq lc iq mc b gy mr ms l mt mu">foo(<br/>  "foo",<br/>  "bar",<br/>  "three"<br/>);</span></pre><p id="0b1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="184f" class="mq lc iq mc b gy mr ms l mt mu">foo("one")</span></pre><p id="4716" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是将行长度保持在100个字符左右或更少。</p><h1 id="843d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数括号内的一致换行符</h1><p id="da9b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该在函数括号内有一致的换行符。</p><p id="5311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="110d" class="mq lc iq mc b gy mr ms l mt mu">function foo(<br/>  bar,<br/>  baz<br/>) {}</span></pre><p id="adb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ec8a" class="mq lc iq mc b gy mr ms l mt mu">const foo = function(<br/>  bar, baz<br/>) {};</span></pre><p id="e161" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于短函数，我们可以将签名放在一行中。</p><p id="c510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，我们把它分成多行。</p><h1 id="a3fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生成器函数中*周围的间距</h1><p id="6c65" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该在发生器函数中保持<code class="fe lz ma mb mc b">*</code>周围的间距。</p><p id="448e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9236" class="mq lc iq mc b gy mr ms l mt mu">function* generator() {<br/>  yield "foo";<br/>  yield "bar";<br/>}</span></pre><p id="c2c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4860" class="mq lc iq mc b gy mr ms l mt mu">function * generator() {<br/>  yield "foo";<br/>  yield "bar";<br/>}</span></pre><p id="9d61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1f1d" class="mq lc iq mc b gy mr ms l mt mu">function *generator() {<br/>  yield "foo";<br/>  yield "bar";<br/>}</span></pre><p id="b474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要坚持一个。</p><h1 id="f9a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Return语句应该出现在属性Getters中</h1><p id="a578" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">getters的全部目的是返回一些东西。</p><p id="c389" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该确保这是在getters中完成的。</p><p id="574b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9cb0" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  get name() {<br/>    return "james";<br/>  }<br/>};</span></pre><p id="67b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c679" class="mq lc iq mc b gy mr ms l mt mu">Object.defineProperty(obj, "age", {<br/>   get() {<br/>     return 100;<br/>   }<br/> });</span></pre><p id="2ea4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2de0" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  get name() {<br/>    return;<br/>  }<br/>};</span></pre><p id="7b81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8447" class="mq lc iq mc b gy mr ms l mt mu">Object.defineProperty(obj, "age", {<br/>   get() {<br/><br/>   }<br/> });</span></pre><p id="0092" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fd15" class="mq lc iq mc b gy mr ms l mt mu">class P {<br/>  get name() {<br/>   <br/>  }<br/>}</span></pre><h1 id="57fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将require()放在顶级模块范围内</h1><p id="f1a1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该把我们的<code class="fe lz ma mb mc b">require</code>调用放在模块作用域的顶层。</p><p id="62eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="be73" class="mq lc iq mc b gy mr ms l mt mu">const fs = require("fs");</span></pre><p id="7084" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fa69" class="mq lc iq mc b gy mr ms l mt mu">function foo() {<br/>  if (condition) {<br/>    const fs = require("fs");<br/>  }<br/>}</span></pre><p id="6770" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动态需求令人困惑，</p><p id="ad7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该这么做。</p><h1 id="cda6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在对象文字和类中需要成组的访问器对</h1><p id="b810" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">拥有没有getters的setters并没有多大用处，因为我们无法获得被设置的值。</p><p id="79bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该为任何setters设置getters。</p><p id="5791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="84a9" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  get a() {<br/>    return this.val;<br/>  },<br/>  set a(value) {<br/>    this.val = value;<br/>  },<br/>  b: 1<br/>};</span></pre><p id="cc57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f938" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  set a(value) {<br/>    this.val = value;<br/>  },<br/>  b: 1<br/>};</span></pre><p id="3d6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用getter得到<code class="fe lz ma mb mc b">obj</code>中<code class="fe lz ma mb mc b">a</code>的值。</p><h1 id="6418" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">保护for-in</h1><p id="b0b0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果用for-in循环，我们应该检查继承的属性，因为它枚举继承的属性。</p><p id="50db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9970" class="mq lc iq mc b gy mr ms l mt mu">for (key in foo) {<br/>  doWork(key);<br/>}</span></pre><p id="246e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="27a6" class="mq lc iq mc b gy mr ms l mt mu">for (key in foo) {<br/>  if (Object.prototype.hasOwnProperty.call(foo, key)) {<br/>    doWork(key);<br/>  }<br/>}</span></pre><p id="df75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d54d" class="mq lc iq mc b gy mr ms l mt mu">for (key in foo) {<br/>  if ({}.hasOwnProperty.call(foo, key)) {<br/>    doSomething(key);<br/>  }<br/>}</span></pre><p id="6f6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe lz ma mb mc b">Object.prototype.hasOwnProperty.call</code>或<code class="fe lz ma mb mc b">{}.hasOwnProperty.call</code>代替<code class="fe lz ma mb mc b">foo.hasOwnProperty</code>，这样即使<code class="fe lz ma mb mc b">hasOwnProperty</code>被覆盖，它仍然可以工作。</p><p id="e2f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">hasOwnProperty</code>检查属性是否为非继承属性。</p><h1 id="f5f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">回调错误处理</h1><p id="af56" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果回调中存在错误，我们应该检查它们。</p><p id="1c12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9845" class="mq lc iq mc b gy mr ms l mt mu">function foo(err, data) {<br/>  if (err) {<br/>    console.log(err.stack);<br/>  }<br/>  doWork();<br/>}</span></pre><p id="8249" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这是一个节点样式的回调，<code class="fe lz ma mb mc b">err</code>将被错误填充，我们应该在它被抛出的情况下处理它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/da2d6919e5b1a0a6b29aaa5ab12ebe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c1ou6-MEgzswarUN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mandymonday?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">mandy zhu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1734" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c87f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该在回调中处理错误。</p><p id="eaa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命名函数表达式是多余的。</p><p id="c84d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换行符和间距应该一致。</p><h2 id="dc00" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">简单英语的JavaScript</h2><p id="e835" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>