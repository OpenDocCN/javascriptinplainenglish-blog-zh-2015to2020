<html>
<head>
<title>I’m now versioning my app secrets in Git, here is why you should do the same.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我现在在Git中对我的应用程序秘密进行版本控制，这就是为什么你应该做同样的事情。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/im-now-versioning-my-app-secrets-in-git-here-is-why-you-should-do-the-same-2a72c1a49039?source=collection_archive---------2-----------------------#2020-03-23">https://javascript.plainenglish.io/im-now-versioning-my-app-secrets-in-git-here-is-why-you-should-do-the-same-2a72c1a49039?source=collection_archive---------2-----------------------#2020-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="8b5b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">发展提示</h2><div class=""/><div class=""><h2 id="9a71" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">这被认为是一个不好的实践，但是当你有很多配置并且管理秘密变得复杂时，你可能需要它。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4e38a9e786a368a5233266bb49fc9f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLisihUmSFRNbYvFHWvV-Q.png"/></div></div></figure><p id="98a4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我知道你可能会想:“<strong class="lc ja">这是一个糟糕的做法……”</strong>和“<strong class="lc ja">可能是世界上最糟糕的想法</strong>”。</p><p id="10dc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">我承认我完全同意你的观点。</strong></p><p id="b3a4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">然而，</strong>为了给出一些背景，让我们从一个关于<strong class="lc ja">我为什么开始做这件事的简短故事开始，最重要的是以何种方式。</strong></p><h1 id="f3e0" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">为什么我从environments secrets切换到了带有secrets的版本化JSON配置？</h1><p id="8253" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">一切从两年前我开始学习云计算开始。我的一个朋友在一家发布开源软件的公司工作，他被委派做一些演示和展示软件的概念验证。</p><p id="11de" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">开发的时候，我朋友在用公司银行卡给一些<a class="ae mt" href="https://aws.amazon.com/ec2" rel="noopener ugc nofollow" target="_blank"> AWS EC2 </a>沙箱供电。对于那些不知道这一点的人来说，这是一种可以按需填充的VPS机器，只要你保持开机，你就可以根据每小时的使用情况支付一定的费用。这真的很酷，因为你可以根据服务器负载来调整网络基础设施。</p><p id="7824" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是一个周五，在漫长的一周之后的周末之前，我的朋友无意中在一个公共GitHub存储库中提交了私有API密钥，该密钥允许任何拥有它的人控制AWS帐户并填充EC2或其他服务。这是一种上帝模式。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="e77f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">周一，该公司收到了几封电子邮件，提到<strong class="lc ja">账单被点燃</strong>并且在两天内达到了<strong class="lc ja">15000€</strong>。对于像这样的小失误来说，这并不酷… <strong class="lc ja">事实是，这每年都会发生在很多人身上。</strong></p><p id="9a48" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你必须知道<strong class="lc ja">那些键有一个特定的模式</strong>和<strong class="lc ja">有一群机器人正在网络上爬行搜索那个模式</strong>。</p><p id="f697" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">发生的事情是，有人已经填充了几个最大的CPU优化虚拟机，以加密挖掘一些比特币(BTC)。</p><p id="cf6a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这个故事的寓意是:永远不要在任何地方提交任何敏感数据，以防止任何意外泄漏，即使是在你可能认为永远不会公开的小型存储库上。</p><p id="678e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为此，大多数云提供商服务允许以安全的方式管理秘密，这些秘密将在运行时通过环境变量直接注入云功能或虚拟机。这真的是一件很酷的事情，从那天开始，我在任何地方都应用它，甚至在我自己的私人存储库中，以防万一…</p><p id="264f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">…直到上周，我还想在已经不那么小的秘密集合中增加一个Firebase Service帐户的序列化版本，这是一个JSON文件，其中包含完整的rs a字符串密钥。</p><h1 id="68c5" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">关于秘密管理，对某些提供者有一些限制</h1><p id="be9f" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">尽管使用环境变量<em class="nb">(例如:RSA密钥对、JSON配置……)</em>管理复杂的秘密很困难，但还有一些其他限制……</p><ul class=""><li id="83ae" class="nc nd iq lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated"><a class="ae mt" href="https://zeit.co/docs/v2/serverless-functions/env-and-secrets?query=secrets#reserved-variables" rel="noopener ugc nofollow" target="_blank">保留变量名称</a></li><li id="d5a1" class="nc nd iq lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated"><a class="ae mt" href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_limits.html" rel="noopener ugc nofollow" target="_blank">秘密限制</a>(AWS示例)</li></ul><p id="fddd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">就像包裹在AWS 外面的<a class="ae mt" href="https://zeit.co/" rel="noopener ugc nofollow" target="_blank">Zeit Now</a><em class="nb">而言，秘密的规模是有上游限制的……</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/a68d751e03a325423f1fdece55df7afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3GHX1aMhnSqVDjTW0zUlg.png"/></div></div></figure><p id="d90e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这意味着，对于那些拥有Firebase/ Google凭据和服务帐户等“综合体”秘密的人来说，你很可能会突破这个限制。这发生在我和其他许多人身上。</p><p id="4fa4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">以上种种让我想到了另一种加密技术。</strong></p><h1 id="9990" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">使用版本化加密JSON配置从99个机密更改为1个机密</h1><p id="5071" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">而不是将各种环境变量定义为秘密来存储我的私有配置并达到极限。我使用<strong class="lc ja">对称加密</strong>来存储一个完整的JSON文件<strong class="lc ja">，其中包含我的安全配置</strong>。</p><p id="8b56" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在cloud secrets存储中，唯一剩下的就是加密密钥，可能还有用于加密此配置对象的初始化向量(IV)。</p><p id="4bf0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">这种做法有如下一些好处:</strong></p><ul class=""><li id="b79e" class="nc nd iq lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">所有的配置站在一个地方。</li><li id="3af8" class="nc nd iq lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">您可以轻松地正确存储JSON结构和配置参数的命名空间。</li><li id="ef61" class="nc nd iq lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">很安全。</li><li id="975b" class="nc nd iq lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">它的IDE和开发人员友好，与静态类型和自动完成。</li></ul><p id="fbd8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一般来说，如果你不是一个新手并且应用了安全的基础知识，那么成功地突破了你的安全并且窃取了你的代码库<strong class="lc ja">而没有通知你</strong>的机会并不是很多。</p><p id="6393" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但即使发生在这里，使用下面的策略，您也是安全的，因为，像您的数据库密码一样，您的整个配置是加密的。</p><p id="fac1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这样，您就有了足够的时间来为任何服务无效化并生成新的访问密钥，并再次保护存储库的安全。</p><blockquote class="nv nw nx"><p id="5fa9" class="la lb nb lc b ld le ka lf lg lh kd li ny lk ll lm nz lo lp lq oa ls lt lu lv ij bi translated">但等等……什么是对称加密？</p></blockquote><p id="0dcd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">关于对称加密的快速提示</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/0a754398135970d5779534e488eef183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mvQsLJz8G6qPDcs4.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Symmetric Encryption in a nutshell —<strong class="bd og"> Wikipedia</strong></figcaption></figure><blockquote class="nv nw nx"><p id="0b26" class="la lb nb lc b ld le ka lf lg lh kd li ny lk ll lm nz lo lp lq oa ls lt lu lv ij bi translated"><strong class="lc ja">对称加密</strong>是使用随机生成的密钥对文本<em class="iq">(这里是一个字符串化的JSON) </em>进行编码的动作。使用同一个密钥，程序能够稍后解密这一大块数据并恢复它。</p></blockquote><p id="dd50" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">除了密钥之外，每次我们加密字符串化的配置对象时，我们都会使用一个随机的数据块，称为<strong class="lc ja">初始化向量(IV)。这防止了在对同一文档进行多次加密时产生相同的加密结果。<strong class="lc ja">增加安全性。</strong></strong></p><p id="f819" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所有这些都是通过一种叫做<strong class="lc ja">密码块链接(CBC) </strong>的技术来完成的，如果你想了解更多，请随意在谷歌上搜索或者在维基百科上搜索。</p><p id="eb56" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好消息是，在NodeJS中使用CBC密码非常容易。它使用OpenSSL上的<code class="fe nr ns nt nu b">crypto</code>模块来支持开箱即用。</p><h1 id="cd5e" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">使用Cipher IV CBC加密云项目的JSON配置</h1><p id="3ab8" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">以下示例分为两部分:</p><ol class=""><li id="38b8" class="nc nd iq lc b ld le lg lh lj ne ln nf lr ng lv oh ni nj nk bi translated"><strong class="lc ja">第一:加密。</strong>我们将在开发人员的计算机上加密所需的JSON配置对象。我们可以在一些网站上这样做，比如这个网站，但是我不同意这种做法。您不应冒任何风险，将您的配置暴露在外部网站上和/或让他人生成您的加密密钥。否则加密什么都没用。一旦我们有了加密的字符串，我们只需将它添加到我们的存储库中，并与我们的源代码一起提交它。</li><li id="c9f5" class="nc nd iq lc b ld nl lg nm lj nn ln no lr np lv oh ni nj nk bi translated"><strong class="lc ja">第二:解密。</strong>当代码引导时，我们将使用由secrets provider在我们的环境变量中注入的加密密钥对配置进行解密，并使其在我们的应用程序中可用。</li></ol><p id="902b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">准备好了吗？我们来编码吧！</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="2448" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是我们将在本文中学习的演示的代码，请随意在另一个屏幕上打开它，并继续阅读解释。示例中提供的所有加密值都是存根，没有安全目的。由您自己来复制和指定与您的项目相匹配的加密数据，而不是给定的存根。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Code samples</figcaption></figure><h2 id="8f19" class="ok lx iq bd ly ol om dn mc on oo dp mg lj op oq mi ln or os mk lr ot ou mm iw bi translated">NodeJS中的JSON配置加密</h2><p id="eb89" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated"><strong class="lc ja"> <em class="nb">本章指的是上面片段</em> </strong>中的  <code class="fe nr ns nt nu b"><strong class="lc ja"><em class="nb">encrypt.js</em></strong></code> <strong class="lc ja"> <em class="nb">文件</em></strong></p><p id="6949" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了加密配置，我做了一个快速的shell脚本<em class="nb">(你可以改进它，或者有一天我也可以)</em>，它只有一个参数:用于加密配置的加密密钥。</p><p id="a42c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面的例子是使用<code class="fe nr ns nt nu b">aes-256-cbc</code>算法，它需要<strong class="lc ja">一个256位的加密密钥</strong> <em class="nb">(即32个字符)</em>和一个<strong class="lc ja"> 16字节的IV </strong>。</p><ul class=""><li id="e6c2" class="nc nd iq lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated"><strong class="lc ja">要得到一个加密密钥</strong>，你需要一个真随机数。我个人一般使用<a class="ae mt" href="https://www.random.org/strings/" rel="noopener ugc nofollow" target="_blank">这个基于大气噪声</a>的网站。要求4串8个字母数字组成的字符，按照你想要的顺序连接起来，得到一个32个字符的随机字符串。</li><li id="52d3" class="nc nd iq lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">JSON配置的加密版本将是一个十六进制字符串。</li></ul><p id="eded" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">代码是自我解释的，所以只需使用您的加密密钥通过<code class="fe nr ns nt nu b">node encrypt.js &lt;encryption_key&gt;</code>来加密您的<code class="fe nr ns nt nu b">config.json</code>文件。并将加密的内容粘贴到<code class="fe nr ns nt nu b">config.ts</code>片段中定义的占位符中。</p><h2 id="c2b9" class="ok lx iq bd ly ol om dn mc on oo dp mg lj op oq mi ln or os mk lr ot ou mm iw bi translated">NodeJS中的JSON配置解密</h2><p id="c85d" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated"><strong class="lc ja"> <em class="nb">本章所指的是</em> </strong> <code class="fe nr ns nt nu b"><strong class="lc ja"><em class="nb">config.ts</em></strong></code> <strong class="lc ja"> <em class="nb">文件中上面的片段</em> </strong></p><p id="ad4a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这里我使用的是<strong class="lc ja"> Typescript </strong>，它是一个著名的Javascript超集，为Javascript文件带来了静态类型和接口。这样，我就可以输入我的配置来利用IDE中的自动完成功能。</p><p id="5aa1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这里没有什么复杂的:在我的应用程序启动时，将需要<code class="fe nr ns nt nu b">config.ts</code>文件，代码将被解释为解密我们的配置。</p><p id="2894" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">由于我的云提供商的secrets功能，用于加密上述数据的加密密钥被注入到使用环境变量的应用程序中。<strong class="lc ja">加密的JSON配置以纯文本的形式出现在代码中。</strong></p><p id="3440" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">根据<code class="fe nr ns nt nu b">NODE_ENV</code>变量，生产或暂存配置被延迟加载并作为<code class="fe nr ns nt nu b">APP_CONFIG</code>常量公开，常量<code class="fe nr ns nt nu b">Object.freeze</code>用于防止程序执行过程中的意外变化。如果使用错误的加密密钥，您将无法解密配置，潜在的黑客也无法解密。</p><p id="b85f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">保管好加密密钥，避免共享它，因为它可以访问您的整个配置。另一方面，IV不需要保密，而是在加密字符串中公开共享。</strong></p><p id="4c24" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">请随意修改上面的例子及其行为以满足您的需求。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="dc45" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就是我们，我们只是用两个变量替换了旧的99环境变量:<code class="fe nr ns nt nu b">NODE_ENV</code>和<code class="fe nr ns nt nu b">ENCRYPT_KEY</code>，所有这些都是以安全的方式进行的。</p><h1 id="4dcb" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">额外收获:内嵌一个RSA / PEM密钥，使其嵌入到JSON文件中</h1><p id="8719" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">在某些情况下，您可能需要在JSON密钥中存储大量内容，当您使用<strong class="lc ja"> RSA密钥</strong>(pem)进行JWT加密/解密。</p><p id="250e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">放一个RSA。pem在一个JSON字符串中，你需要把它放在一行并转换隐藏的换行符，换成转义的换行符<code class="fe nr ns nt nu b">\n</code>。</p><p id="aac1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">要实现该行为，您可以使用以下命令:</p><pre class="kp kq kr ks gt ov nu ow ox aw oy bi"><span id="794e" class="ok lx iq nu b gy oz pa l pb pc">awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' &lt;your_key_file.pem&gt;</span></pre><p id="d0c7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于那些懒惰的人来说，这里有一个版本可以在Mac/Linux上使用<code class="fe nr ns nt nu b">pbcopy</code>直接将它放入剪贴板。基于<code class="fe nr ns nt nu b">rsa_priv.pem</code>是我们的文件名和当前目录。</p><pre class="kp kq kr ks gt ov nu ow ox aw oy bi"><span id="00f4" class="ok lx iq nu b gy oz pa l pb pc">awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' rsa_priv.pem | pbcopy</span></pre><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pd oj l"/></div></figure><p id="3749" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae mt" href="https://codingspark.io" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja"> 🇫🇷STOP！你是法国人吗🥖？您也可以访问ici网站，接收法国的私人通讯🙂</strong></a></p></div></div>    
</body>
</html>