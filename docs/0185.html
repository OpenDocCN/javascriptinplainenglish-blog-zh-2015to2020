<html>
<head>
<title>Top 10 JavaScript Patterns Every Developer Like</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都喜欢的10大JavaScript模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-10-javascript-patterns-every-developers-like-fa79b5400cc1?source=collection_archive---------1-----------------------#2019-07-23">https://javascript.plainenglish.io/top-10-javascript-patterns-every-developers-like-fa79b5400cc1?source=collection_archive---------1-----------------------#2019-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f90698c3c7a7d201e3b72cffe898e0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRGsWS0u668WY5zo_vfG-A.png"/></div></div></figure><h1 id="a541" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.构造器模式</h1><p id="4846" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在经典的面向对象编程语言中，构造函数是一种特殊的方法，用于在为新创建的对象分配内存后初始化该对象。在JavaScript中，几乎所有东西都是对象，我们最感兴趣的是对象构造函数。因为对象构造函数习惯于创建特定类型的对象，例如，在第一次创建对象时，既准备对象以供使用，又接受构造函数可以用来设置成员属性和方法的值的参数。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/11e219c5765b4bc6e58a6c075c86269e.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/0*Xg6SzEZOMTat30R5"/></div></figure><p id="ab16" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">正如我们所知，JavaScript不支持类的概念，因此在构造函数中，关键字this引用了正在创建的新对象重新查看对象创建，一个基本的构造函数可能如下所示:</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="8ff9" class="mj jz iq mf b gy mk ml l mm mn">function Car(model, year, miles) {<br/>  this.model = model;<br/>  this.year = year;<br/>  this.miles = miles;<br/>}</span><span id="d7d7" class="mj jz iq mf b gy mo ml l mm mn">// Usage:<br/>var bmw = new Car('M4', '2019', '1000');</span></pre><h1 id="ccaa" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.桃木鸟</h1><p id="4296" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">模块是任何健壮的应用程序架构不可或缺的一部分，通常有助于保持项目的代码单元清晰地分离和组织。其中包括:</p><ul class=""><li id="e720" class="mp mq iq ky b kz lz ld ma lh mr ll ms lp mt lt mu mv mw mx bi translated">目标文字符号</li><li id="ccf9" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">模块模式</li><li id="2beb" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">AMD模块</li><li id="b9fd" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">CommonJS模块</li><li id="5698" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">ECMAScript和声模块</li></ul><p id="fd7a" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">对象文字:</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="102b" class="mj jz iq mf b gy mk ml l mm mn">var newObject = {<br/>  variableKey: variableValue,<br/>  functionKey: function() {<br/>    //…<br/>  }<br/>};</span></pre><p id="9323" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">模块模式:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/dc0aa4148308b60a651bfbb8dffe7715.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/0*6Ucx3xpl6pUZGSTO"/></div></figure><p id="b2bd" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">让我们通过创建一个自包含的模块来开始研究模块模式的实现。</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="7e18" class="mj jz iq mf b gy mk ml l mm mn">var testModule = (function() {<br/>  var counter = 0;<br/>  return {<br/>    incrementCounter: function() {<br/>      return ++counter;<br/>    },<br/>    resetCounter: function() {<br/>      counter = 0;<br/>    }<br/>  };<br/>})();</span><span id="1e75" class="mj jz iq mf b gy mo ml l mm mn">// Usage:<br/>testModule.incrementCounter();<br/>testModule.resetCounter();</span></pre><h1 id="5672" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.启示模块模式</h1><p id="aa64" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">揭示模块可以做的一件事是，当我们想从一个公共方法调用另一个公共方法或访问公共变量时，避免重复主对象的名称。</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="5e9a" class="mj jz iq mf b gy mk ml l mm mn">var myRevealingModule = (function() {<br/>  var privateVariable = 'not okay',<br/>    publicVariable = 'okay';<br/>  function privateFun() {<br/>    return privateVariable;<br/>  }</span><span id="e324" class="mj jz iq mf b gy mo ml l mm mn">function publicSetName(strName) {<br/>    privateVariable = strName;<br/>  }</span><span id="ec9b" class="mj jz iq mf b gy mo ml l mm mn">function publicGetName() {<br/>    privateFun();<br/>  }</span><span id="db92" class="mj jz iq mf b gy mo ml l mm mn">return {<br/>    setName: publicSetName,<br/>    message: publicVariable,<br/>    getName: publicGetName<br/>  };<br/>})();</span><span id="59bf" class="mj jz iq mf b gy mo ml l mm mn">//Usage:</span><span id="bd39" class="mj jz iq mf b gy mo ml l mm mn">myRevealingModule.setName('Marvin King');</span></pre><h1 id="6080" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.单一模式</h1><p id="9519" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">单例模式之所以为人所知，是因为它将一个类的实例化限制为一个对象。单例不同于静态类，因为我们可以延迟它们的初始化。通常，因为它们需要一些在初始化时可能不可用的信息。对于不知道以前对它们的引用的代码，它们不提供容易检索的方法。让我们来看看singleton的结构:</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="5620" class="mj jz iq mf b gy mk ml l mm mn">var singletonPattern = (function() {<br/>  var instance;<br/>  function init() {<br/>    // Singleton<br/>    function privateMethod() {<br/>      console.log('privateMethod');<br/>    }<br/>    var privateVariable = 'this is private variable';<br/>    var privateRandomNumber = Math.random();<br/>    return {<br/>      publicMethod: function() {<br/>        console.log('publicMethod');<br/>      },<br/>      publicProperty: 'this is public property',<br/>      getRandomNumber: function() {<br/>        return privateRandomNumber;<br/>      }<br/>    };<br/>  }</span><span id="2c35" class="mj jz iq mf b gy mo ml l mm mn">return {<br/>    // Get the singleton instance if one exists<br/>    // or create if it doesn't<br/>    getInstance: function() {<br/>      if (!instance) {<br/>        instance = init();<br/>      }<br/>      return instance;<br/>    }<br/>  };<br/>})();</span><span id="e75a" class="mj jz iq mf b gy mo ml l mm mn">// Usage:<br/>var single = singletonPattern.getInstance();</span></pre><h1 id="94bb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.观察者模式</h1><p id="ca88" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">观察者是一种设计模式，在这种模式中，一个对象维护一个依赖于它的观察者的对象列表，自动通知他们状态的任何变化。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/35fc626dcf4ea66835081521a5cb7a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/0*jN3qOIVZ9D04iq4z"/></div></figure><ul class=""><li id="e184" class="mp mq iq ky b kz lz ld ma lh mr ll ms lp mt lt mu mv mw mx bi translated">科目</li><li id="f6bf" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">维护观察员列表，添加或删除观察员的工具</li><li id="853e" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">观察者</li><li id="06e5" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">为需要被通知主题状态更改的对象提供更新的接口</li><li id="343b" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">具体主体</li><li id="f083" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">向观察者广播状态变化的通知存储具体观察者的状态</li><li id="ffe7" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">具体观察者</li><li id="9e76" class="mp mq iq ky b kz my ld mz lh na ll nb lp nc lt mu mv mw mx bi translated">存储对ConcreteSubject的引用，为观察者实现更新的接口，以确保状态与主题一致</li></ul><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="7f86" class="mj jz iq mf b gy mk ml l mm mn">function ObserverList() {<br/>  this.observerList = [];<br/>}</span><span id="eb0e" class="mj jz iq mf b gy mo ml l mm mn">ObserverList.prototype.Add = function(obj) {<br/>  return this.observerList.push(obj);<br/>};</span><span id="b663" class="mj jz iq mf b gy mo ml l mm mn">ObserverList.prototype.Empty = function() {<br/>  this.observerList = [];<br/>};</span><span id="36fe" class="mj jz iq mf b gy mo ml l mm mn">ObserverList.prototype.Count = function() {<br/>  return this.observerList.length;<br/>};</span><span id="a4cd" class="mj jz iq mf b gy mo ml l mm mn">ObserverList.prototype.Get = function(index) {<br/>  if (index &gt; -1 &amp;&amp; index &lt; this.observerList.length) {<br/>    return this.observerList[index];<br/>  }<br/>};</span><span id="938e" class="mj jz iq mf b gy mo ml l mm mn">//...</span></pre><p id="b6b4" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">当一个主题需要通知观察者一些有趣的事情发生时，它向观察者广播一个通知(包括与通知主题相关的特定数据)</p><p id="784e" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">当我们不再希望某个特定的观察者被其注册的主体通知变化时，该主体可以将其从观察者列表中删除。将来，我会更多地讨论如何在JavaScript中广泛使用observer的特性。</p><h1 id="eb65" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">6.中介模式</h1><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/bcf54fe95fec5888f45589dcd855d7f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/0*JJxjQWDB7S0OAKDl"/></div></figure><p id="9bd0" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">如果一个系统的组件之间有太多的直接关系。现在可能是时候建立一个控制中心点来代替组件之间的通信了。中介模式通过确保组件不显式地相互引用来促进松散耦合。</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="2a68" class="mj jz iq mf b gy mk ml l mm mn">var mediator = (function() {<br/>  var topics = {};<br/>  var subscribe = function(topic, fn) {<br/>    if (!topics[topic]) {<br/>      topics[topic] = [];<br/>    }<br/>    topics[topic].push({ context: this, callback: fn });<br/>    return this;<br/>  };</span><span id="6b36" class="mj jz iq mf b gy mo ml l mm mn">// publish/broadcast an event to the rest of the application<br/>  var publish = function(topic) {<br/>    var args;<br/>    if (!topics[topic]) {<br/>      return false;<br/>    }<br/>    args = Array.prototype.slice.call(arguments, 1);<br/>    for (var i = 0, l = topics[topic].length; i &lt; l; i++) {<br/>      var subscription = topics[topic][i];<br/>      subscription.callback.apply(subscription.content, args);<br/>    }<br/>    return this;<br/>  };<br/>  return {<br/>    publish: publish,<br/>    subscribe: subscribe,<br/>    installTo: function(obj) {<br/>      obj.subscribe = subscribe;<br/>      obj.publish = publish;<br/>    }<br/>  };<br/>})();</span></pre><h1 id="3b0e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">7.原型模式</h1><p id="a0df" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用原型模式的一个好处是，我们利用了JavaScript固有的原型优势，而不是试图模仿其他语言的特性。让我们看看模式示例。</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="2695" class="mj jz iq mf b gy mk ml l mm mn">var myCar = {<br/>  name: 'bmw',<br/>  drive: function() {<br/>    console.log('I am driving!');<br/>  },<br/>  panic: function() {<br/>    console.log('wait, how do you stop this thing?');<br/>  }<br/>};</span><span id="5c52" class="mj jz iq mf b gy mo ml l mm mn">//Usages:</span><span id="0f9e" class="mj jz iq mf b gy mo ml l mm mn">var yourCar = Object.create(myCar);</span><span id="d9dd" class="mj jz iq mf b gy mo ml l mm mn">console.log(yourCar.name); //'bmw'</span></pre><h1 id="5279" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">8.工厂模式</h1><p id="d978" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">工厂可以为创建对象提供一个通用接口，在这里我们可以指定我们想要创建的工厂对象的类型。见下图。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/13669a95a2eabd787901254096b7c660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/0*TbNLk2jRhjX5WjSI"/></div></figure><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="a259" class="mj jz iq mf b gy mk ml l mm mn">function Car(options) {<br/>  this.doors = options.doors || 4;<br/>  this.state = options.state || 'brand new';<br/>  this.color = options.color || 'silver';<br/>}</span></pre><h1 id="08b8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">9.混合模式</h1><p id="e516" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Mixins是提供功能的类，这些功能很容易被一个子类或一组子类继承，以实现功能重用。</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="7636" class="mj jz iq mf b gy mk ml l mm mn">var Person = function(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>  this.gender = 'male';<br/>};</span><span id="1946" class="mj jz iq mf b gy mo ml l mm mn">var clark = new Person('Clark', 'kent');</span><span id="25d8" class="mj jz iq mf b gy mo ml l mm mn">var Superhero = function(firstName, lastName, powers) {<br/>  Person.call(this.firstName, this.lastName);<br/>  this.powers = powers;<br/>};</span><span id="7ead" class="mj jz iq mf b gy mo ml l mm mn">SuperHero.prototype = Object.create(Person.prototype);<br/>var superman = new Superhero('Clark', 'Kent', ['flight', 'heat-vision']);</span><span id="1ec2" class="mj jz iq mf b gy mo ml l mm mn">console.log(superman); //output personal attributes as well as power</span></pre><p id="19e5" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">在这种情况下，超级英雄能够用特定于其对象的值来覆盖任何继承的值。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/1f8728e03e1c3003fb8c0960a280664a.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*e_PSBsTOyLp7AxfW"/></div></figure><h1 id="b777" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">10.装饰图案</h1><p id="44f5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">装饰者是一种旨在促进代码重用的结构化设计模式。类似于Mixins，它们可以被认为是对象子类化的另一种可行的替代方案。传统上，Decorators提供了向系统中的现有类动态添加行为的能力。这个想法是装饰本身对于类的基本功能并不重要。让我们看看装饰器是如何在JavaScript中工作的</p><pre class="lv lw lx ly gt me mf mg mh aw mi bi"><span id="f2a3" class="mj jz iq mf b gy mk ml l mm mn">function MacBook() {<br/>  this.cost = function() {<br/>    return 997;<br/>  };<br/>  this.screenSize = function() {<br/>    return 11.6;<br/>  };<br/>}</span><span id="aa8e" class="mj jz iq mf b gy mo ml l mm mn">// Decorator 1</span><span id="0665" class="mj jz iq mf b gy mo ml l mm mn">function Memory(macbook) {<br/>  var v = macbook.cost();<br/>  macbook.cost = function() {<br/>    return v + 75;<br/>  };<br/>}</span><span id="8b8b" class="mj jz iq mf b gy mo ml l mm mn">// Decorator 2</span><span id="74bf" class="mj jz iq mf b gy mo ml l mm mn">function Engraving(macbook) {<br/>  var v = macbook.cost();<br/>  macbook.cost = function() {<br/>    return v + 200;<br/>  };<br/>}</span><span id="e459" class="mj jz iq mf b gy mo ml l mm mn">// Decorator 3</span><span id="72b5" class="mj jz iq mf b gy mo ml l mm mn">function Insurance(macbook) {<br/>  var v = macbook.cost();<br/>  macbook.cost = function() {<br/>    return v + 250;<br/>  };<br/>}</span><span id="902b" class="mj jz iq mf b gy mo ml l mm mn">var mb = new MacBook();</span><span id="8dd8" class="mj jz iq mf b gy mo ml l mm mn">Memory(mb);<br/>Engraving(mb);<br/>Insurance(mb);</span><span id="4708" class="mj jz iq mf b gy mo ml l mm mn">mb.cost(); // 1522</span></pre><p id="6169" class="pw-post-body-paragraph kw kx iq ky b kz lz lb lc ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt ij bi translated">并非所有的模式都适用于一个项目，有些项目可能会受益于观察者模式提供的解耦优势。也就是说，一旦我们牢牢掌握了设计模式和它们最适合的特定问题。因此，集成到我们的应用程序架构中变得更加容易。</p></div></div>    
</body>
</html>