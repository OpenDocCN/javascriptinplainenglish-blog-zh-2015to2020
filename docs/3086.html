<html>
<head>
<title>Chat Applications System Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聊天应用系统设计</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/chat-applications-system-design-6a070c60c8cd?source=collection_archive---------4-----------------------#2020-08-27">https://javascript.plainenglish.io/chat-applications-system-design-6a070c60c8cd?source=collection_archive---------4-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="308b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">几乎每个聊天应用都使用的现代聊天应用系统数据库架构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a73e8a4b7636b05db5b51fee4e5e3c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9Nfg6GWSQXssxR_Zz71og.png"/></div></div></figure><h2 id="1c22" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">我们的应用程序基本特性:</strong></h2><blockquote class="ln lo lp"><p id="0fff" class="lq lr ls lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated"><strong class="lt ir"> <em class="iq">发送消息</em> </strong></p><p id="867e" class="lq lr ls lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated"><strong class="lt ir"> <em class="iq">通知用户发送消息</em> </strong></p><p id="97ae" class="lq lr ls lt b lu lv jr lw lx ly ju lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated"><strong class="lt ir"> <em class="iq">通知用户看到的消息</em> </strong></p></blockquote><blockquote class="mn"><p id="f5ee" class="mo mp iq bd mq mr ms mt mu mv mw mm dk translated"><em class="mx">注意:我们现在不打算在这里讨论群发消息</em></p></blockquote><h1 id="63aa" class="my ks iq bd kt mz na nb kw nc nd ne kz jw nf jx ld jz ng ka lh kc nh kd ll ni bi translated">在两个用户之间发送消息</h1><p id="00e3" class="pw-post-body-paragraph lq lr iq lt b lu nj jr lw lx nk ju lz la nl mc md le nm mg mh li nn mk ml mm ij bi translated">因此，假设<strong class="lt ir"> A </strong>向<strong class="lt ir"> B </strong>发送一条消息，我们将使用网关来连接用户，以处理自身的安全性。因此，一旦你连接到网关，<strong class="lt ir"> A </strong>向<strong class="lt ir"> B </strong>，<strong class="lt ir"> <em class="ls">发送消息，但这里我们必须存储哪个用户连接到哪个网关，以使服务更快。</em> </strong></p><p id="ecd0" class="pw-post-body-paragraph lq lr iq lt b lu lv jr lw lx ly ju lz la mb mc md le mf mg mh li mj mk ml mm ij bi translated">一旦网关知道用户<strong class="lt ir"> B </strong>连接到<strong class="lt ir">网关2 </strong>，它将连接到该网关并提前发送消息，但为此，我们需要将该信息发送到某个地方，为此，我们将使用<strong class="lt ir">会话微服务</strong>，因为在网关中存储该数据本身将是一件昂贵的事情，因为网关已经忙于处理用户请求，这需要大量内存，因此我们需要会话微服务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7f5bd8185b0e107d908464aa2b187010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipp1PNK1Q1v0O6_wENq5Iw.png"/></div></div></figure><p id="3560" class="pw-post-body-paragraph lq lr iq lt b lu lv jr lw lx ly ju lz la mb mc md le mf mg mh li mj mk ml mm ij bi translated">所以现在<strong class="lt ir"> A </strong>用<strong class="lt ir"> B </strong>的用户id将消息发送到<strong class="lt ir">网关1 </strong>并且会话微服务将做什么，它找出这个用户连接到哪里，然后将消息路由到连接的网关，消息到达<strong class="lt ir"> B </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ccbf2e7cfb7bf35ee60e69187b08c6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLoQfQRv6KfreH9RjYJjMQ.png"/></div></div></figure><p id="fdbe" class="pw-post-body-paragraph lq lr iq lt b lu lv jr lw lx ly ju lz la mb mc md le mf mg mh li mj mk ml mm ij bi translated">在这里，你可以看到服务器能够向客户端发送请求，而使用<strong class="lt ir"> HTTP </strong>绝对不可能，使用Websockets (WSS)也是如此，它让我们可以自由地在用户之间建立对等连接，这样A可以向be发送消息，反之亦然，这里没有客户端或服务器问题。</p><p id="901f" class="pw-post-body-paragraph lq lr iq lt b lu lv jr lw lx ly ju lz la mb mc md le mf mg mh li mj mk ml mm ij bi translated">因此，现在我们的服务器可以轻松地向客户端发送消息，现在它将更加实时。</p><p id="5473" class="pw-post-body-paragraph lq lr iq lt b lu lv jr lw lx ly ju lz la mb mc md le mf mg mh li mj mk ml mm ij bi translated">所以B从A那里得到了消息，现在我们交付的部分完成了。T47】</p><blockquote class="mn"><p id="d90e" class="mo mp iq bd mq mr no np nq nr ns mm dk translated">我们发送消息的第一个功能现在工作正常！</p></blockquote><p id="d898" class="pw-post-body-paragraph lq lr iq lt b lu nt jr lw lx nu ju lz la nv mc md le nw mg mh li nx mk ml mm ij bi translated">现在，发送消息部分已经完成，现在我们还必须通知我们的发送者发送消息，如果用户已经阅读了消息(<strong class="lt ir">我们在这些天的每个消息应用中看到)</strong>，对于其他用户也是如此。</p><p id="d14c" class="pw-post-body-paragraph lq lr iq lt b lu lv jr lw lx ly ju lz la mb mc md le mf mg mh li mj mk ml mm ij bi translated">因此，现在我们将使用相同的<strong class="lt ir"> TCP </strong>确认来通知我们的用户</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e71678cd760c6d4bc77f91b7002fc6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8CPdcEJtlRJWgPAtYuCMA.png"/></div></div></figure><p id="7267" class="pw-post-body-paragraph lq lr iq lt b lu lv jr lw lx ly ju lz la mb mc md le mf mg mh li mj mk ml mm ij bi translated">因此，现在当<strong class="lt ir"> B </strong>收到消息时，它将再次联系网关，然后会话微服务将进行一个会话(<strong class="lt ir"> to: from字段)，其中to- B和from- A，然后</strong>会话微服务将找到用户<strong class="lt ir"> A </strong>连接的是哪个门，然后通知用户收到了消息，这同样适用于查看消息功能，每当用户打开应用程序时，我们都会以相同的方式向其他用户发送请求，并且它以良好的方式工作。</p><blockquote class="mn"><p id="00cb" class="mo mp iq bd mq mr no np nq nr ns mm dk translated"><strong class="ak">现在我们完成了:发送、接收和查看通知</strong></p></blockquote><h1 id="078c" class="my ks iq bd kt mz na nb kw nc nd ne kz jw nf jx ld jz ng ka lh kc nh kd ll ni bi translated"><strong class="ak">通知活动用户</strong></h1><p id="2839" class="pw-post-body-paragraph lq lr iq lt b lu nj jr lw lx nk ju lz la nl mc md le nm mg mh li nn mk ml mm ij bi translated">因此，现在无论何时<strong class="lt ir"> B </strong>或<strong class="lt ir"> A </strong>读取一条消息，都会有一个用户活动记录在服务器中，该活动每秒存储一次，阈值为4秒，但我们不会显示4秒前的<strong class="lt ir">在线，</strong>我们将只显示在线，阈值完全由您决定，您需要考虑多少时间，但通常20秒听起来不错。因此，现在每当用户登录到服务器，我们的服务器会检查用户日志，如果用户最近登录，那么它会显示在线或在特定时间最后一次看到。</p><h2 id="14b1" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">进一步阅读</h2><div class="ny nz gp gr oa ob"><a rel="noopener  ugc nofollow" target="_blank" href="/i-built-a-serverless-live-chat-app-with-next-js-fauna-and-wundergraph-for-graphql-live-queries-b671d9646f6"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">我用Next.js、Fauna和WunderGraph为GraphQL实时查询构建了一个无服务器的实时聊天应用程序</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">使用无服务器技术创建可扩展的实时聊天应用程序的分步指南，来自…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ok l"><div class="ol l om on oo ok op kp ob"/></div></div></a></div></div></div>    
</body>
</html>