<html>
<head>
<title>Creating and Using Union Types with Express Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express Apollo创建和使用联合类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-and-using-union-types-with-express-apollo-68c5be1f008a?source=collection_archive---------9-----------------------#2020-04-01">https://javascript.plainenglish.io/creating-and-using-union-types-with-express-apollo-68c5be1f008a?source=collection_archive---------9-----------------------#2020-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6a9b223c05faccfd35ca5204dd76b488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7DoA8z7El7wXDxaG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@micheile?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Micheile Henderson @micheile010 // Visual Stories [nl]</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3c47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apollo服务器作为节点包提供。我们可以用它来创建一个接受GraphQL请求的服务器。</p><p id="5725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何创建联合类型并在Apollo Server和Express中使用它们。</p><h1 id="69c3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">联合类型</h1><p id="38ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">联合类型表示一个字段可以返回多个对象类型，但它本身并不指定特定的字段。</p><p id="1b24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于从单个字段返回不相交的数据类型很有用。</p><p id="873c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以定义一个联合类型并按如下方式使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="322f" class="mn lc iq mj b gy mo mp l mq mr">const express = require('express');<br/>const { ApolloServer, gql } = require('apollo-server-express');</span><span id="189d" class="mn lc iq mj b gy ms mp l mq mr">const data = {<br/>  '1': { title: 'JavaScript for Dummies' },<br/>  '2': { name: 'Jane Smith' },<br/>}</span><span id="4d69" class="mn lc iq mj b gy ms mp l mq mr">const typeDefs = gql`<br/>  union Result = Book | Author</span><span id="d7d3" class="mn lc iq mj b gy ms mp l mq mr">  type Book {<br/>    title: String<br/>  }</span><span id="6071" class="mn lc iq mj b gy ms mp l mq mr">  type Author {<br/>    name: String<br/>  }</span><span id="fd2a" class="mn lc iq mj b gy ms mp l mq mr">  type Query {<br/>    search(id: Int!): Result<br/>  }<br/>`;</span><span id="3fa2" class="mn lc iq mj b gy ms mp l mq mr">const resolvers = {<br/>  Result: {<br/>    __resolveType(obj, context, info) {<br/>      if (obj.name) {<br/>        return 'Author';<br/>      }</span><span id="ae62" class="mn lc iq mj b gy ms mp l mq mr">      if (obj.title) {<br/>        return 'Book';<br/>      }</span><span id="1f01" class="mn lc iq mj b gy ms mp l mq mr">      return null;<br/>    },<br/>  },<br/>  Query: {<br/>    search: (_, { id }) =&gt; data[id]<br/>  },<br/>};</span><span id="8de6" class="mn lc iq mj b gy ms mp l mq mr">const app = express();<br/>const server = new ApolloServer({ typeDefs, resolvers });<br/>server.applyMiddleware({ app });</span><span id="4d15" class="mn lc iq mj b gy ms mp l mq mr">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="8692" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用我们将在解析器中返回的数据定义了如下的<code class="fe mt mu mv mj b">data</code>常量:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f020" class="mn lc iq mj b gy mo mp l mq mr">const data = {<br/>  '1': { title: 'JavaScript for Dummies' },<br/>  '2': { name: 'Jane Smith' },<br/>}</span></pre><p id="bfa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义我们的类型定义如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fb85" class="mn lc iq mj b gy mo mp l mq mr">const typeDefs = gql`<br/>  union Result = Book | Author</span><span id="59be" class="mn lc iq mj b gy ms mp l mq mr">  type Book {<br/>    title: String<br/>  }</span><span id="d4fb" class="mn lc iq mj b gy ms mp l mq mr">  type Author {<br/>    name: String<br/>  }</span><span id="bf7c" class="mn lc iq mj b gy ms mp l mq mr">  type Query {<br/>    search(id: Int!): Result<br/>  }<br/>`;</span></pre><p id="5b4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用了<code class="fe mt mu mv mj b">union</code>关键字来表示联合类型。它被定义为与<code class="fe mt mu mv mj b">Author</code>型结合的<code class="fe mt mu mv mj b">Book</code>型。</p><p id="5299" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们像往常一样定义了<code class="fe mt mu mv mj b">Book</code>和<code class="fe mt mu mv mj b">Author</code>类型。</p><p id="aaf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们用<code class="fe mt mu mv mj b">search</code>查询定义了我们的<code class="fe mt mu mv mj b">Query</code>类型，它接受一个<code class="fe mt mu mv mj b">id</code>整数并返回我们上面指定的<code class="fe mt mu mv mj b">Result</code>类型。</p><p id="8957" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的<code class="fe mt mu mv mj b">resolvers</code>对象中，我们定义了如何将<code class="fe mt mu mv mj b">Result</code>类型解析为如下类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e7a3" class="mn lc iq mj b gy mo mp l mq mr">const resolvers = {<br/>  Result: {<br/>    __resolveType(obj, context, info) {<br/>      if (obj.name) {<br/>        return 'Author';<br/>      }</span><span id="b0be" class="mn lc iq mj b gy ms mp l mq mr">      if (obj.title) {<br/>        return 'Book';<br/>      }</span><span id="0023" class="mn lc iq mj b gy ms mp l mq mr">      return null;<br/>    },<br/>  },<br/>  Query: {<br/>    search: (_, { id }) =&gt; data[id]<br/>  },<br/>};</span></pre><p id="4d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">Result</code>中，我们有<code class="fe mt mu mv mj b">__resolveType</code>方法，该方法有<code class="fe mt mu mv mj b">obj</code>对象，该对象有我们返回给用户的对象。</p><p id="d1e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那里，我们可以像以前一样检查属性，并相应地返回类型名。</p><p id="e19b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe mt mu mv mj b">Query</code>对象中，我们有<code class="fe mt mu mv mj b">search</code>方法来返回数据。</p><p id="e131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要对联合类型进行查询，我们必须使用内联片段，如下所示，方法是转到<code class="fe mt mu mv mj b">/graphql</code>页面并键入以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0d15" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  search(id: 1) {<br/>    __typename<br/>    ...on Book {<br/>      title<br/>    }<br/>    ...on Author {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="6fd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">...on</code>表示我们有一个内联片段。我们可以使用它根据返回的内容对字段进行查询。<code class="fe mt mu mv mj b">__typename</code>字段返回对象的类型名。</p><p id="728b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该得到以下响应:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1694" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "search": {<br/>      "__typename": "Book",<br/>      "title": "JavaScript for Dummies"<br/>    }<br/>  }<br/>}</span></pre><p id="788f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们定义的<code class="fe mt mu mv mj b">data</code>对象中的内容。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/411d6b715747cd3148df7017ac868bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P9UGIBgZkBcjJMap"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@meric?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Meriç Dağlı</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e53a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9a97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以定义一个联合类型来创建一个不相交的数据类型。</p><p id="0ca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">|</code>符号和<code class="fe mt mu mv mj b">union</code>关键字表明一个类型是联合类型。</p><p id="e6f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在联合中结合在一起的类型是普通对象和标量类型。</p><p id="8f2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在resolvers对象中，我们用<code class="fe mt mu mv mj b">__resolveType</code>方法返回给定对象结构的类型名。</p><p id="1603" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要进行返回联合类型的查询，我们必须使用内联片段。我们可以使用<code class="fe mt mu mv mj b">__typename</code>操作符来获取返回对象的类型名。</p><p id="237d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【JavaScript用简单英语写的一句话:我们总是乐于帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>