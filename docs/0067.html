<html>
<head>
<title>A Comprehensive Guide to Understanding Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解记忆的综合指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-comprehensive-guide-to-understanding-memoization-e142e60edd76?source=collection_archive---------9-----------------------#2019-01-24">https://javascript.plainenglish.io/a-comprehensive-guide-to-understanding-memoization-e142e60edd76?source=collection_archive---------9-----------------------#2019-01-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fd2d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">让我们从基础开始，从概念上定义记忆化到底是什么。</h2></div><p id="88a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据维基百科，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/6597a2c9d2b52cbfb4f9eaf682c48eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7dyRpnNXOB_lD4aW.jpeg"/></div></div></figure><p id="3d78" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单地说，记忆化是使长递归/迭代函数运行得更快的编程实践。</p><p id="c0c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我将解释我们如何使用JavaScript实现这一点，并通过一个非常耗时的算法让它快速运行来给你一个例子。真的很快！</p><p id="e98a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从一个非常基本的例子开始:</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="59f7" class="lp lq in ll b gy lr ls l lt lu">const add = (a, b) =&gt; a + b;</span><span id="c45e" class="lp lq in ll b gy lv ls l lt lu">console.log(add(2,3));   // =&gt; returns 5</span></pre><p id="fdc8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次我们调用这个函数时，都会执行一次计算并返回一个值。如果我们多次调用同一个函数，计算也要进行多次。</p><p id="a2bc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，这是一个非常简单的计算，但想象一下，如果你有复杂的东西在那里。这需要一些时间来执行。这就是记忆可以帮助的地方。</p><p id="d0f3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们想一想。如果我们用相同的参数反复运行同一个函数，并且这个函数没有副作用，那么我们已经知道结果了，对吗？因此，我们可以简单地缓存第一次运行的结果，并在随后的调用中使用相同的参数立即返回它，而不是一次又一次地运行计算。</p><p id="34ed" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那是记忆化！现在，让我们创建一个简单的通用memoize函数，它接受另一个函数并修改它来memoize调用。</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="5b6a" class="lp lq in ll b gy lr ls l lt lu">const memoize = (fn) =&gt; { <br/>  let cache = {}; <br/>  return (...args) =&gt; { <br/>    let n = JSON.stringify(args); <br/>    if (n in cache) { <br/>      console.log('Fetching from cache', n); <br/>      return cache[n]; <br/>    } else { <br/>      console.log('Calculating result', n); <br/>      let result = fn(...args); <br/>      cache[n] = result; <br/>      return result; <br/>    } <br/>  } <br/>}</span></pre><p id="f5b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以很容易地记忆任何纯函数，比如我们的<em class="lw"> add </em>函数。由于<em class="lw"> memoize </em>是一个高阶函数，我们有两种方法来实现。一个是创建一个新的记忆函数，如下所示。</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="285c" class="lp lq in ll b gy lr ls l lt lu">const add = (a, b) =&gt; a + b; <br/>const memoAdd = memoize(add); </span><span id="cf3e" class="lp lq in ll b gy lv ls l lt lu">console.log(memoAdd(2,3));  // =&gt; Calculating result 5 console.log(memoAdd(2,3));  // =&gt; Fetching from cache 5</span></pre><p id="d0eb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者我们可以改变<em class="lw">增加</em>这个功能:</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="9c4b" class="lp lq in ll b gy lr ls l lt lu">const add = memoize((a, b) =&gt; a + b); </span><span id="af4d" class="lp lq in ll b gy lv ls l lt lu">console.log(add(2,3));  // =&gt; Calculating result 5 console.log(add(2,3));  // =&gt; Fetching from cache 5</span></pre><p id="ee9d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您想看看性能提升的效果吗？看看下面这个例子。</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="04fe" class="lp lq in ll b gy lr ls l lt lu"><em class="lw">// recursive fibonacci function</em><br/>const fibonacci = (n) =&gt; {<br/>  if (n === 0 || n === 1) {<br/>    return n;<br/>  }<br/>  return fibonacci(n - 1) + fibonacci(n - 2);<br/>}</span></pre><p id="e1e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个<em class="lw"> fibonacci </em>函数接受一个表示fibonacci序列位置的数字，并计算相应的值。因为它是递归的，当你设置的位置越高，它就越慢。</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="d1c2" class="lp lq in ll b gy lr ls l lt lu">console.log(<!-- -->fibonacci(3));  // =&gt; super fast.<br/>console.log(fibonacci(6));  // =&gt; super fast.<br/>console.log(fibonacci(9));  // =&gt; super fast.</span></pre><p id="5c63" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们疯狂一下，用序列中的第50个元素来测试它，好吗？</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="44d7" class="lp lq in ll b gy lr ls l lt lu">console.log(fibonacci(50)); // Call the function and go for a walk!</span></pre><p id="71fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的电脑上，这段代码运行了将近4分钟。递归函数必须调用400亿次以上(具体是40730022147次)！这太疯狂了。</p><p id="813b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们记住它。由于斐波那契是一个递归函数，我们不能通过创建一个新的记忆函数来实现这一点，比如下面的代码。</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="373e" class="lp lq in ll b gy lr ls l lt lu">const memoFibonacci = memoize(fibonacci);</span><span id="b004" class="lp lq in ll b gy lv ls l lt lu">console.log(memoFibonacci(50)); // insane amount of time</span></pre><p id="0d94" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为我们只记住了第一个调用。对fibonacci的所有后续递归调用都不会被记忆。记忆递归函数的唯一方法是用我们的memoize fn包装main函数。</p><pre class="kz la lb lc gt lk ll lm ln aw lo bi"><span id="cea4" class="lp lq in ll b gy lr ls l lt lu"><em class="lw">// recursive and memoized fibonacci function</em><br/>const fibonacci = memoize((n) =&gt; {<br/>  if (n === 0 || n === 1) {<br/>    return n;<br/>  }<br/>  return fibonacci(n - 1) + fibonacci(n - 2);<br/>})</span><span id="3d0a" class="lp lq in ll b gy lv ls l lt lu">console.log(fibonacci(50)); // runs fast!</span></pre><p id="6440" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，它运行不到一秒钟，结果完全相同。太神奇了！正如您在控制台中看到的，许多调用都被缓存，防止了数十亿次递归调用。</p><h1 id="9fbe" class="lx lq in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">记忆化和缓存一样吗？</h1><p id="622c" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">是的，有点。记忆化实际上是一种特定类型的缓存。虽然高速缓存通常指的是将来使用的任何存储技术，但是记忆化特别涉及到<em class="lw">高速缓存</em>函数的返回值。</p><h1 id="1b6e" class="lx lq in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">仔细的</h1><p id="5fd8" class="pw-post-body-paragraph kc kd in ke b kf mo jo kh ki mp jr kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">请记住，记忆化并不是对所有的函数调用都有意义。对于不纯的函数，也就是有副作用的函数，这种方法效果不好。Memoizing只允许我们缓存一个结果，所以任何其他副作用都会在后续调用中丢失。也就是说，您可以通过返回一个包含副作用的函数来绕过这个约束，您需要在获得结果后执行这个函数。</p><p id="0871" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，内存开销更大，因为我们必须存储缓存的结果，以便以后可以调用它们，并且使用内存化增加了复杂性，因此它只对计算量大的函数有意义。</p><p id="9329" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！感谢您的阅读和愉快的回忆！</p><p id="1def" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lw">更多内容尽在</em><a class="ae mt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="lw">plain English . io</em></strong></a></p></div></div>    
</body>
</html>