<html>
<head>
<title>The Redux Shortcut; One Action, One Reducer, No Dispatch!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux快捷方式；一个动作，一个减速器，不调度！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-redux-shortcut-654a5c6157ff?source=collection_archive---------6-----------------------#2020-02-01">https://javascript.plainenglish.io/the-redux-shortcut-654a5c6157ff?source=collection_archive---------6-----------------------#2020-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="fa8c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">开始</h1><p id="795f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当我第一次使用redux时，它看起来是这样的</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/afffa14d4bc02ed44e347710c44fd542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-ygeava_oPj190cYhOteg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">The near infinite setup; Over 60 types, dispatch after dispatch and an AI’s worth of state cases</figcaption></figure><p id="4606" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">天哪，这是一个麻烦！在十几个文件之间切换来创建新的动作、设置新的类型和向reducer添加新的案例，仅仅是为了管理一个新的redux状态！然后是调度！当你用一个动作处理一个异步函数时，像路由到应用程序的一个新的部分这样简单的事情就会变得非常复杂。但如果有更简单的方法来处理这一切，我可能只是偶然发现了它。那么我们如何从上面的蜘蛛网到下面的这个呢</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/d558fc686a61e57ba48dd1d746b8bccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*QhGJB7X2mndVMEK8rbZeXQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">The finite setup; One action, one reducer, no dispatch</figcaption></figure><p id="8a46" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated"><em class="mc">*这不是一个真正的redux教程，所以我将继续下去，并假设你已经知道如何设置* </em></p><h1 id="e9be" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">设置织机。</h1><p id="88a3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，这个“loom”设置的思想是使用单个动作来接受数据对象，并在组件和减速器之间建立联系。一个动作，一种类型。会是这个样子；</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="20a9" class="mi jl in me b gy mj mk l ml mm">//types.js<br/>export const SET_APP_STATE = 'set_app_state';</span><span id="6167" class="mi jl in me b gy mn mk l ml mm">//action.js</span><span id="6c46" class="mi jl in me b gy mn mk l ml mm">import {SET_APP_STATE} from './types';</span><span id="016a" class="mi jl in me b gy mn mk l ml mm">export const setAppState = object =&gt; {</span><span id="adea" class="mi jl in me b gy mn mk l ml mm">return {</span><span id="a3d6" class="mi jl in me b gy mn mk l ml mm">type: SET_APP_STATE,</span><span id="ae8a" class="mi jl in me b gy mn mk l ml mm">payload: object,</span><span id="e975" class="mi jl in me b gy mn mk l ml mm">};</span><span id="445c" class="mi jl in me b gy mn mk l ml mm">};</span></pre><p id="0999" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">就这样，我们完成了我们的行动和类型。很好很容易。</p><p id="6ac9" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">现在是我们心爱的减速器。</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="05de" class="mi jl in me b gy mj mk l ml mm">//Reducer.js</span><span id="d3a4" class="mi jl in me b gy mn mk l ml mm">import {SET_APP_STATE} from '../actions/types';</span><span id="2bf4" class="mi jl in me b gy mn mk l ml mm">const INITIAL_STATE = {</span><span id="f289" class="mi jl in me b gy mn mk l ml mm">* some initial state *</span><span id="9af4" class="mi jl in me b gy mn mk l ml mm">};</span><span id="6852" class="mi jl in me b gy mn mk l ml mm">export default (state = INITIAL_STATE, action) =&gt; {</span><span id="3728" class="mi jl in me b gy mn mk l ml mm">switch (action.type) {</span><span id="73ff" class="mi jl in me b gy mn mk l ml mm">case SET_APP_STATE:</span><span id="9386" class="mi jl in me b gy mn mk l ml mm">return {...state,  ...action.payload};</span><span id="0f99" class="mi jl in me b gy mn mk l ml mm">default:</span><span id="849a" class="mi jl in me b gy mn mk l ml mm">return state;</span><span id="9746" class="mi jl in me b gy mn mk l ml mm">}</span><span id="28e4" class="mi jl in me b gy mn mk l ml mm">};</span><span id="61e8" class="mi jl in me b gy mn mk l ml mm">//You can choose to get rid of the switch case since its only one action and one type but i'll maintain it for familiarity's sake.</span></pre><p id="ad7d" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">我们的减速器怎么样了？每当我们的setAppState操作被调用时，我们展开redux状态的当前内容，然后展开action.payload的新内容——替换冲突的旧状态内容，并适当地添加任何新值。老样子老样子。</p><p id="7e08" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">现在让我们来看看这是如何与一个示例组件结合在一起的。</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="66c6" class="mi jl in me b gy mj mk l ml mm">//Login.js</span><span id="e8b3" class="mi jl in me b gy mn mk l ml mm">//import action</span><span id="eaff" class="mi jl in me b gy mn mk l ml mm">//export with connect</span><span id="7cbf" class="mi jl in me b gy mn mk l ml mm">//mapStateToProps</span><span id="d314" class="mi jl in me b gy mn mk l ml mm">&lt;TextInput</span><span id="bbb0" class="mi jl in me b gy mn mk l ml mm">value={this.props.appState.displayName} //access 'displayName' value in redux state</span><span id="5fc2" class="mi jl in me b gy mn mk l ml mm">placeholder="User name"</span><span id="8315" class="mi jl in me b gy mn mk l ml mm">onChangeText={ userName =&gt; {</span><span id="ed85" class="mi jl in me b gy mn mk l ml mm">this.props.setAppState({ //action creator to modify redux state</span><span id="3589" class="mi jl in me b gy mn mk l ml mm">displayName: userName //set new 'displayName' value in redux state</span><span id="5fe4" class="mi jl in me b gy mn mk l ml mm">});</span><span id="bc57" class="mi jl in me b gy mn mk l ml mm">}}</span><span id="6c9e" class="mi jl in me b gy mn mk l ml mm">/&gt;</span></pre><p id="aadb" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">眼熟吗？setState？setAppState？明白了吗？因此，对于这样一个简单的文本输入，我们用</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="e0e3" class="mi jl in me b gy mj mk l ml mm">this.props.setAppState({stateKey: stateValue})</span></pre><p id="c375" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">并从我们的redux状态中读取它的值</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="b9ce" class="mi jl in me b gy mj mk l ml mm">this.props.appState.stateKey</span></pre><p id="0955" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">应用程序中的所有组件。看起来不错吧？就像使用react组件级setState()和this.state命令一样。</p><h1 id="8989" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">再见调度！</h1><p id="d74a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">但这还不是全部。除了这是一个更简单和相对更<em class="mc">有限的</em>类型的设置，我最喜欢的部分是它完全消除了调度，同时让我们更好地控制我们的状态。例如，考虑这个用户认证功能</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="ffe3" class="mi jl in me b gy mj mk l ml mm">//Login.js</span><span id="ec7f" class="mi jl in me b gy mn mk l ml mm">loginUser() {</span><span id="26ba" class="mi jl in me b gy mn mk l ml mm">this.props.setAppState({loading: true}); //use action creator to set loading flag to true and start any activity indicators</span><span id="d4b6" class="mi jl in me b gy mn mk l ml mm">const {email, password} = this.props.appState; //get email and password values from redux state bucket</span><span id="5b23" class="mi jl in me b gy mn mk l ml mm">firebase</span><span id="a780" class="mi jl in me b gy mn mk l ml mm">.auth()</span><span id="df28" class="mi jl in me b gy mn mk l ml mm">.signInWithEmailAndPassword(email, password)</span><span id="345a" class="mi jl in me b gy mn mk l ml mm">.then((user)=&gt;{</span><span id="c79a" class="mi jl in me b gy mn mk l ml mm">this.props.setAppState({// disable loader and set currentUser.displayName to redux state</span><span id="ba0a" class="mi jl in me b gy mn mk l ml mm">loading: false,</span><span id="a16e" class="mi jl in me b gy mn mk l ml mm">displayName: user.displayName,</span><span id="231c" class="mi jl in me b gy mn mk l ml mm">});</span><span id="1802" class="mi jl in me b gy mn mk l ml mm">this.props.navigation.navigate('Splash')</span><span id="5238" class="mi jl in me b gy mn mk l ml mm">}</span><span id="4fe0" class="mi jl in me b gy mn mk l ml mm">.catch(error =&gt;</span><span id="bfdc" class="mi jl in me b gy mn mk l ml mm">this.props.setAppState({</span><span id="c436" class="mi jl in me b gy mn mk l ml mm">errorMessage: error.message,// set error messages to redux state</span><span id="b9af" class="mi jl in me b gy mn mk l ml mm">loading: false,// stop loading/ disable activityIndicator</span><span id="2e24" class="mi jl in me b gy mn mk l ml mm">}),</span><span id="cc3d" class="mi jl in me b gy mn mk l ml mm">);</span><span id="eca6" class="mi jl in me b gy mn mk l ml mm">}</span></pre><p id="aae8" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">通常，像这样的函数会涉及到大量的分派，将类型和有效负载发送到我们的reducer，以便在代码块的不同级别修改我们的状态。然而，以这种方式设置redux意味着像这样的函数不再需要独特的动作创建者、分派和redux cases来管理它们自己的状态，而是可以在我们的组件中编写成普通的帮助器方法。</p><h1 id="c95c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题是。</h1><p id="8866" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">尽管这一切听起来很可怕，但有一个小问题。与React的组件状态管理能够递归处理嵌套对象和数组不同，我还没有完全弄清楚如何类似地分散每个嵌套对象或数组，但我想现在这是社区的问题。然而，目前我通常用两种方法中的一种来回避这个问题。</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="8a6e" class="mi jl in me b gy mj mk l ml mm">//option 1</span><span id="e77d" class="mi jl in me b gy mn mk l ml mm">this.props.setAppState({</span><span id="fe62" class="mi jl in me b gy mn mk l ml mm">object: {</span><span id="fe7c" class="mi jl in me b gy mn mk l ml mm">...this.props.appState.object,</span><span id="2684" class="mi jl in me b gy mn mk l ml mm">modifiedKey: modifiedValue,</span><span id="8930" class="mi jl in me b gy mn mk l ml mm">newKey: newValue</span><span id="aa7a" class="mi jl in me b gy mn mk l ml mm">}</span><span id="3d35" class="mi jl in me b gy mn mk l ml mm">})</span></pre><p id="73b1" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">一种方法是在向嵌套元素添加任何新的或修改的值之前，将嵌套元素的当前内容扩展到新的对象/数组中。这对于一个浅窝来说很好，但是如果你不得不去更深的地方，下一个选项会做得更好。</p><pre class="lh li lj lk gt md me mf mg aw mh bi"><span id="b0f7" class="mi jl in me b gy mj mk l ml mm">//option 2</span><span id="8c55" class="mi jl in me b gy mn mk l ml mm">//new type</span><span id="6079" class="mi jl in me b gy mn mk l ml mm">//new action</span><span id="d5c8" class="mi jl in me b gy mn mk l ml mm">//new case</span></pre><p id="5d00" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">这是我决定保持减速器开关箱格式的另一个原因。对于深度嵌套的元素，我们可以选择多创建一个动作、类型和案例来管理它们的状态，如果我们需要在它们内部执行大量操作，这是最理想的。</p><p id="5556" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">我希望能够像react本地组件级状态管理一样进行设置，这允许嵌套而没有这些额外的复杂性，但我可能只是一个新手，无法独自解决所有问题。</p><p id="6e33" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">就我个人而言，我认为我要么一开始使用redux是完全错误的，要么这是我们在使用React Native进行redux状态管理时可以用来缓解一些压力的东西。无论哪种方式，我期待收到redux专家/资深人士对这种设置的利弊的回应。</p><p id="260a" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">黑客快乐！</p><p id="a554" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated">演示项目GitHub</p><p id="d331" class="pw-post-body-paragraph ki kj in kk b kl lw kn ko kp lx kr ks kt ly kv kw kx lz kz la lb ma ld le lf ig bi translated"><a class="ae mo" href="https://github.com/Bimpong/reduxShortcut" rel="noopener ugc nofollow" target="_blank">https://github.com/Bimpong/reduxShortcut</a></p></div></div>    
</body>
</html>