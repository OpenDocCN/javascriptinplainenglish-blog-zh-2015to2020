<html>
<head>
<title>3 React concepts which can be forgotten 🤯</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3对可能被遗忘的概念做出反应🤯</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-react-concepts-which-can-be-forgotten-6e2c974cd7bb?source=collection_archive---------3-----------------------#2019-09-09">https://javascript.plainenglish.io/3-react-concepts-which-can-be-forgotten-6e2c974cd7bb?source=collection_archive---------3-----------------------#2019-09-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="db45" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">React经过多年的发展，一些概念被更好的概念所取代</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5b824d003e01dfffbe0a1f9ee8409c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_v9x1clwGUibaVzAnItAQ.jpeg"/></div></div></figure><h1 id="a31c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1.使用类📜</h1><p id="1fdb" class="pw-post-body-paragraph jn jo in jq b jr lw jt ju jv lx jx jy ly lz kb kc ma mb kf kg mc md kj kk kl ig bi translated">每当我们想使用状态或利用生命周期方法时，我们都必须编写一个<em class="jp"> Javascript </em>类来创建一个<em class="jp"> React </em>组件。即使我们不需要使用这些特性，我们也提前选择了一个类，因为你永远不知道你的组件什么时候会需要一个状态或者副作用。</p><p id="7e8d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">幸运的是，2019年初<em class="jp"> React </em> 16.8发布了钩子的功能。<em class="jp"> React hooks </em>为我们提供了用<em class="jp"> useState </em> hook替换状态的能力，这比之前的状态概念要方便得多。</p><p id="d0a2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">生命周期方法也被<em class="jp"> React </em>钩子所取代。<em class="jp"/><a class="ae me" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"><em class="jp">use effect</em></a><em class="jp"/>运行在每一个渲染上，并给予完全摆脱生命周期方法的机会。</p><h1 id="8859" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2.使用生命周期方法🔄</h1><p id="6c41" class="pw-post-body-paragraph jn jo in jq b jr lw jt ju jv lx jx jy ly lz kb kc ma mb kf kg mc md kj kk kl ig bi translated">老实说，当我第一次读到关于<a class="ae me" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"><em class="jp">use effect</em></a><em class="jp"/>的时候，我并不知道一个单一的方法如何能够取代几个:<code class="fe mf mg mh mi b">componentDidMount</code>、<code class="fe mf mg mh mi b">componentDidUpdate</code>和<code class="fe mf mg mh mi b">componentWillUnmount</code>🙄</p><p id="6d70" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">事情是这样的,<em class="jp"> React </em>团队认为生命周期方法是有害的，并决定放弃它们，原来副作用概念也可以达到同样的功能。</p><p id="633a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">您可以定义<a class="ae me" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> useEffect </em> </a>函数来描述每次渲染后需要做什么，在所描述的函数中，您可以返回另一个函数，该函数将在每次新的渲染之前或组件卸载阶段被调用。</p><p id="7270" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">你可能会说，从性能的角度来看这是不明智的，或者说“你不应该在每个rerender上都使用API”，你可能是对的。显然，React团队已经涵盖了这一点，有一些方法可以改变您的<a class="ae me" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"><em class="jp">use effect</em></a><em class="jp"/>函数，使其按照您想要的和需要的方式工作。如果你想知道如何做到这一点，<em class="jp"> React </em>文档已经为你准备好了<a class="ae me" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">📖</a></p><h1 id="61b3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.将返回内容包装到div/array🌯</h1><p id="e67c" class="pw-post-body-paragraph jn jo in jq b jr lw jt ju jv lx jx jy ly lz kb kc ma mb kf kg mc md kj kk kl ig bi translated">如果你曾经使用<em class="jp"> React </em>超过一周，你肯定会面临<code class="fe mf mg mh mi b">Adjacent JSX elements must be wrapped in an enclosing tag.</code>错误。这仅仅意味着您不能从<code class="fe mf mg mh mi b">render</code>方法中返回多个批处理。</p><p id="e24c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">以前的解决方案是将元素包装到“div”中，但是这样一来，我们最终会在<em class="jp"> HTML </em>中有很多多余的“div”。后来的<em class="jp"> React </em> <em class="jp"> 16.0 </em>为我们提供了通过将元素放入数组然后返回来消除冗余<code class="fe mf mg mh mi b">divs</code>的能力。</p><p id="a0aa" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">随着<em class="jp">的释放</em>产生反应<em class="jp"> 16.2 </em>片段被引入。现在，如果你想从<code class="fe mf mg mh mi b">render</code>方法中返回多个元素，你只需简单地将它们包装在<code class="fe mf mg mh mi b">&lt;&gt;&lt;/&gt;</code>中，问题就解决了。现在，您可以忘记使用div/array包装器来解决这个问题了🤯</p><h1 id="45c9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">还有一个例外💥</h1><p id="42bf" class="pw-post-body-paragraph jn jo in jq b jr lw jt ju jv lx jx jy ly lz kb kc ma mb kf kg mc md kj kk kl ig bi translated">当您创建错误边界时，您将无法避免使用类和生命周期方法。长话短说，错误边界是为了捕捉子组件中发生的异常而创建的组件。边界需要使用生命周期方法— <code class="fe mf mg mh mi b">getDerivedStateFromError</code>或<code class="fe mf mg mh mi b">componentDidCatch</code>。</p><p id="ac8b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">然而，这不是我们在日常开发中使用的，错误边界为项目设置了一次，并留下来做他们的工作。此外，<em class="jp"> React </em>团队已经在文档中标记了替换这些生命周期方法<a class="ae me" href="https://reactjs.org/docs/hooks-faq.html#how-do-lifecycle-methods-correspond-to-hooks" rel="noopener ugc nofollow" target="_blank">的钩子将很快被创建</a>🔨</p><h1 id="b9e1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我不是鼓励你忘记这些❌</h1><p id="9439" class="pw-post-body-paragraph jn jo in jq b jr lw jt ju jv lx jx jy ly lz kb kc ma mb kf kg mc md kj kk kl ig bi translated">不要误会我的意思，我并不是想把这些想法从你的脑海中抹去。记住这些真的很有用，尤其是当你开始一个旧的项目的时候。</p><p id="4f29" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">通过这篇文章，我想展示React是如何发展的，以及在从头开始开发时可以抛弃哪些概念。</p><p id="3069" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ly ka kb kc ma ke kf kg mc ki kj kk kl ig bi translated">你对转向框架中的新概念有什么看法？你是一个创新的爱好者，还是更喜欢坚持时间考验的经典？让我在评论中知道💬</p></div></div>    
</body>
</html>