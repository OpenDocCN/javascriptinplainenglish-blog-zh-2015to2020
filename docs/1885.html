<html>
<head>
<title>Understanding immutability in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的不变性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-immutability-in-javascript-b10b0345086e?source=collection_archive---------11-----------------------#2020-05-01">https://javascript.plainenglish.io/understanding-immutability-in-javascript-b10b0345086e?source=collection_archive---------11-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2ccd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">现代框架和函数式编程的核心</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3d243b735edd816b74503d5b8e3e5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36MVMwXluHtErNF8RdZ1wA.jpeg"/></div></div></figure><p id="b652" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不变性是函数式编程的核心原则，现在被现代框架和面向对象程序所使用。</p><p id="fc2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">突变隐藏了变化，并产生意想不到的副作用，这可能会导致错误。另一方面，不可变对象一旦创建就不能更改。不过，这种变化在新版本中有所体现，这有助于我们简化软件开发，避免错误，使您的应用程序架构和金属模型保持简单。</p><p id="731a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，使用不变性，尽管所有更新都返回新值，但内部结构是共享的，以减少内存使用，从而显著提高整体性能。</p><p id="1946" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一些例子:</p><p id="2b81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中，原始值(数字、字符串、未定义值、空值、布尔值和符号值)本身不能变异。包含基元类型的变量总是指向原始值。如果你把它传递给一个不同的变量，另一个变量会得到这个值的新副本。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="c08f" class="ls lt iq lo b gy lu lv l lw lx">const value= 'Hello world!';<br/>value[0] = 'P';        <br/>console.log(value);    <br/>//Hello worl", not Pello world!</span></pre><p id="9d61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一方面，对象或数组是通过引用传递的。如果您将一个对象传递给另一个变量，它们将引用同一个对象，如果您随后从一个变量修改该对象，它们都将显示更改。</p><p id="f5ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑这个例子:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="e252" class="ls lt iq lo b gy lu lv l lw lx">const car1 = {<br/>  brand: 'Ford',<br/>  model: 'Mustang W-Code'<br/>}</span><span id="e509" class="ls lt iq lo b gy ly lv l lw lx"><strong class="lo ir">const car2 = car1;</strong></span><span id="71d6" class="ls lt iq lo b gy ly lv l lw lx">car2.model= 'Thunderbird';</span><span id="77e2" class="ls lt iq lo b gy ly lv l lw lx">console.log(car1 === car2); <br/>//true</span><span id="fcaf" class="ls lt iq lo b gy ly lv l lw lx">console.log(car1);<br/>//{brand: 'Ford', model: 'Thunderbird'}</span></pre><p id="e8fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们修改“car2”对象的属性时，我们会自动修改旧的“car1”对象，因为它们引用同一个对象。在大多数情况下，我们使用关键字“const”，但这并不能阻止我们改变我们的对象。一般来说，这是不受欢迎的行为，不建议这样做。</p><p id="003b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了避免这种情况，与其将对象传递给新变量，不如创建一个新对象。这里我使用ES6 spread运算符来实现这一点:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="95e6" class="ls lt iq lo b gy lu lv l lw lx">const car1 = {<br/>  brand: 'Ford',<br/>  model: 'Mustang W-Code'<br/>}</span><span id="8c7f" class="ls lt iq lo b gy ly lv l lw lx"><strong class="lo ir">const car2 = {...car1};</strong></span><span id="c015" class="ls lt iq lo b gy ly lv l lw lx">car2.model= 'Thunderbird';</span><span id="bf60" class="ls lt iq lo b gy ly lv l lw lx">console.log(car1 === car2); <br/>//false</span><span id="3af9" class="ls lt iq lo b gy ly lv l lw lx">console.log(car1);<br/>//{ brand: 'Ford', model: 'Mustang W-Code'}</span><span id="ee53" class="ls lt iq lo b gy ly lv l lw lx">...</span><span id="6abc" class="ls lt iq lo b gy ly lv l lw lx">const car3 = {<br/>  brand: 'Ford',<br/>  model: 'Mustang W-Code'<br/>}</span><span id="bdc5" class="ls lt iq lo b gy ly lv l lw lx">const car4 = {<strong class="lo ir">...car3, </strong>brand:'BMW'};<br/>console.log(car3 === car4);<br/>//false</span><span id="4cd6" class="ls lt iq lo b gy ly lv l lw lx">console.log(car4);<br/>//{brand: "<strong class="lo ir">BMW</strong>", model: "Mustang W-Code"}</span></pre><p id="d4ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用ES6对象实现相同的结果。assing运算符:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="e6b0" class="ls lt iq lo b gy lu lv l lw lx">const car2 = <strong class="lo ir">Object.assing</strong>({}, car1);</span></pre><p id="b33c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这两种情况下，您都在创建一个新对象，并避免改变原始对象。</p><p id="3902" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用数组，您可以用同样的方式避免变异:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="7676" class="ls lt iq lo b gy lu lv l lw lx">const aTeam = ['Murdock', 'B.A Baracus', 'Hannibal', 'Templeton'];</span></pre><p id="66f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">改变原始aTeam对象:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="3ebb" class="ls lt iq lo b gy lu lv l lw lx">const bTeam = aTeam;<br/>bTeam.push("Me");</span><span id="5eaa" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam === bTeam;)<br/>//true</span><span id="22eb" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam);<br/>//["Murdock", "B.A Baracus", "Hannibal", "Templeton", "Me"]</span><span id="aa1f" class="ls lt iq lo b gy ly lv l lw lx">console.log(bTeam)<br/>//["Murdock", "B.A Baracus", "Hannibal", "Templeton", "Me"]</span></pre><p id="eb33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不出所料，只复制了项目的引用(而不是值)。我们可以快速解决这个问题，而不用使用spread操作符改变原始数组:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="fbc1" class="ls lt iq lo b gy lu lv l lw lx">const aTeam = ['Murdock', 'B.A Baracus', 'Hannibal', 'Templeton'];<br/>const bTeam = [<strong class="lo ir">...aTeam</strong>];</span><span id="b908" class="ls lt iq lo b gy ly lv l lw lx">bTeam.push("Me");</span><span id="0a87" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam === bTeam);<br/>//false</span><span id="0d59" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam);<br/>//["Murdock", "B.A Baracus", "Hannibal", "Templeton"]</span><span id="4d52" class="ls lt iq lo b gy ly lv l lw lx">console.log(bTeam)<br/>//["Murdock", "B.A Baracus", "Hannibal", "Templeton", "Me"]</span></pre><p id="d2ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，在数组上，“过滤”、“映射”或切片操作不会改变原始对象并创建新对象。</p><p id="b72f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">过滤器:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="a9b5" class="ls lt iq lo b gy lu lv l lw lx">const bTeam = ['Murdock', 'B.A Baracus', 'Hannibal', 'Templeton', "Me"];</span><span id="4b51" class="ls lt iq lo b gy ly lv l lw lx">const aTeam = <strong class="lo ir">bTeam.filter</strong>( e =&gt; e !== 'Me');</span><span id="c298" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam === bTeam);<br/>//false</span><span id="dddd" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam);<br/>//["Murdock", "B.A Baracus", "Hannibal", "Templeton"]</span></pre><p id="b3f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">展开运算符+切片:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="f82f" class="ls lt iq lo b gy lu lv l lw lx">const bTeam = ['Murdock', 'B.A Baracus', 'Hannibal', 'Templeton', "Me"];</span><span id="4296" class="ls lt iq lo b gy ly lv l lw lx">const aTeam = [...<strong class="lo ir">bteam.slice</strong>(0,4)];</span><span id="5640" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam === bTeam);<br/>//false</span><span id="46ee" class="ls lt iq lo b gy ly lv l lw lx">console.log(aTeam);<br/>//["Murdock", "B.A Baracus", "Hannibal", "Templeton"]</span></pre><p id="97da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于集合，另一种方法是使用<a class="ae lz" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>库，它提供了许多持久不变的数据结构，包括List、Stack、Map、OrderedMap、Set、OrderedSet和Record。</p><h2 id="3dbf" class="ls lt iq bd ma mb mc dn md me mf dp mg la mh mi mj le mk ml mm li mn mo mp mq bi translated">结论</h2><p id="5180" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我希望这篇小文章已经让您了解了不变性是如何帮助您改进代码的，并且所提供的例子对您是有用的。</p><p id="98ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您花时间阅读这篇文章！</p><h2 id="f623" class="ls lt iq bd ma mb mc dn md me mf dp mg la mh mi mj le mk ml mm li mn mo mp mq bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="851c" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae lz" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kt ir">AI in Plain English</strong></a><a class="ae lz" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kt ir">UX in Plain English</strong></a><a class="ae lz" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kt ir">Python in Plain English</strong></a><strong class="kt ir"/>——谢谢，继续学习！</p><p id="8eb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae lz" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">submissions @ plain English . io</strong></a><strong class="kt ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>