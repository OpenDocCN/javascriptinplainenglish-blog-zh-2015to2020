<html>
<head>
<title>React Native — Cool things you can do with React Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native —使用React导航可以做的很酷的事情</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/playing-around-with-react-navigation-3cd9d94e98b1?source=collection_archive---------9-----------------------#2020-05-13">https://javascript.plainenglish.io/playing-around-with-react-navigation-3cd9d94e98b1?source=collection_archive---------9-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5345e7bdea4dabc9a28dc96896e9396f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCToHl9BKyW4OsVLFVhxzA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Playing around with React Navigation</figcaption></figure><div class=""/><p id="eee0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">React导航是在React本地应用中实现导航的最常见方式。我将使用这个库，并给出一些可以用它做的很酷的东西的例子。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="987b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我将讨论以下主题:</p><ol class=""><li id="54dd" class="li lj jf ke b kf kg kj kk kn lk kr ll kv lm kz ln lo lp lq bi translated"><strong class="ke jg">安装</strong></li><li id="c79e" class="li lj jf ke b kf lr kj ls kn lt kr lu kv lv kz ln lo lp lq bi translated"><strong class="ke jg">基础</strong>(默认堆栈导航和底部标签导航)</li><li id="edc8" class="li lj jf ke b kf lr kj ls kn lt kr lu kv lv kz ln lo lp lq bi translated"><strong class="ke jg">组合导航</strong></li><li id="3bf1" class="li lj jf ke b kf lr kj ls kn lt kr lu kv lv kz ln lo lp lq bi translated"><strong class="ke jg">导航&amp;认证</strong></li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c888" class="lw lx jf bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">1.装置</h1><p id="255c" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated"><em class="la">初始化React本地项目:</em></p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f3ea" class="ni lx jf ne b gy nj nk l nl nm">npx react-native init AwesomeProject</span></pre><p id="cbd0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">安装React导航</strong></p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0415" class="ni lx jf ne b gy nj nk l nl nm">npm install @react-navigation/native</span></pre><p id="e5ba" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">安装依赖关系</strong></p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="06e0" class="ni lx jf ne b gy nj nk l nl nm">npm install react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view</span><span id="acef" class="ni lx jf ne b gy nn nk l nl nm">npm install</span></pre><h1 id="c270" class="lw lx jf bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">2.基础知识</h1><p id="4cb0" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">让我们用两个非常简单的导航器的例子来热身。<strong class="ke jg">堆栈导航</strong>和<strong class="ke jg">底部标签导航。</strong></p><h2 id="8dc4" class="ni lx jf bd ly nt nu dn mc nv nw dp mg kn nx ny mk kr nz oa mo kv ob oc ms od bi translated">标准堆栈导航</h2><p id="2af3" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">堆栈导航是最默认的导航类型。顾名思义，屏幕是根据导航的顺序相互堆叠的。</p><p id="358d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们安装所需的依赖项:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ddf9" class="ni lx jf ne b gy nj nk l nl nm">npm install @react-navigation/stack --save</span></pre><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/a9220ec117a2877a072ae446408bc6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*Fy2a4utEaJSqkKDjaD_kxg.png"/></div></figure><p id="9de6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> App.js:导航容器</strong></p><p id="b1b5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">NavigationContainer将处理导航的树和状态。我们希望整个应用程序能够导航，并执行一些基本功能，如导航回前一个屏幕。这就是为什么我们希望将NavigationContainer放置在尽可能靠近应用程序根目录的位置。于是，在App.js中。</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Apps.js with DefaultStackNavigation</figcaption></figure><p id="b41c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">defaultstacknavigation . js<br/></strong>我们将创建一个带有主屏幕和详细屏幕的堆栈导航。</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="cb0a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Home.js </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="92dc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Detail1.js </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="06fe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，结果应该是这样的:</p><div class="mz na nb nc gt ab cb"><figure class="oh is oi oj ok ol om paragraph-image"><img src="../Images/a442d39b3ebb74575c215f469fac3d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*GPPtHGKP1lKx_j04_wE3EA.png"/></figure><figure class="oh is oi oj ok ol om paragraph-image"><img src="../Images/1ad98c5b64507187f8b6774882346ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*v1Hc2YQIgMu0-KHQxb5VOg.png"/></figure></div><p id="f025" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，现在还没什么疯狂的事。</p><h2 id="2722" class="ni lx jf bd ly nt nu dn mc nv nw dp mg kn nx ny mk kr nz oa mo kv ob oc ms od bi translated">底部选项卡导航</h2><p id="85eb" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">通过底部选项卡导航，我们的不同路线将显示在屏幕底部的选项卡中。</p><p id="7600" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们安装依赖项:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="9689" class="ni lx jf ne b gy nj nk l nl nm">npm install <a class="ae on" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-navigation/bottom-tabs --save</span></pre><p id="399c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们正在回收我们的主页和默认屏幕，但我们将改变导航的类型。</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/db184f439045c4390e932380817f50a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*5BDP3VJKZRyxS1xWM2R_rw.png"/></div></figure><p id="bf4e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">src/navigation/bottom tab navigation . js:</strong></p><p id="a24a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们为底部选项卡导航创建另一个文件。</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8153" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> App.js: <br/> </strong>我们将渲染BottomTabNavigation，而不是渲染DefaultStackNavigation</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Apps.js with BottomTabNavigation</figcaption></figure><div class="mz na nb nc gt ab cb"><figure class="oh is oi oj ok ol om paragraph-image"><img src="../Images/ca1e880e59babb8fb8a38e1997322439.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*KiyGF-KrFROR-vS6OhWGBA.png"/></figure><figure class="oh is oi oj ok ol om paragraph-image"><img src="../Images/2fb7309654d21a07d14c1fd8f5705a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*lbIHmvRkAEzJ6c3ZX3E5-g.png"/></figure></div><p id="2ac9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">与上一个示例相同的设置，但是使用底部的选项卡在不同的页面之间导航。</p><h1 id="1444" class="lw lx jf bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">3.组合底部标签和堆栈导航</h1><p id="9352" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">在我们的DefaultStackNavigation中，我们将使用底部的导航，而不是屏幕。这样我们就可以打开另一个导航。当按下主屏幕上的第二个按钮时，导航选项卡将打开，并显示该导航的第一个屏幕。</p><p id="a046" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> App.js: </strong></p><p id="af18" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用StackNavigation示例中的App.js</p><p id="deaf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Home.js: </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="dd9c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">defaultstacknavigation . js:</strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="af6d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> BottomTabNavigation.js </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4bf3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Tab1.js: </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8101" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Tab2.js: </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><div class="mz na nb nc gt ab cb"><figure class="oh is op oj ok ol om paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/1390c550cd6f5d21faf92f0897a49a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*HUCwzGgJvFLJPcrtYixCog.png"/></div></figure><figure class="oh is op oj ok ol om paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/07ad79f160c7e4a9be0d6f9915b3bb6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*mEIXyquCB7h30fK3PwEGkw.png"/></div></figure><figure class="oh is op oj ok ol om paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/9d32676eb5c989c35acd12519072acf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*dJtywCKMKCwmtbGgFfcflg.png"/></div></figure></div><h1 id="804f" class="lw lx jf bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">4.导航和身份验证</h1><p id="a4db" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">在开发应用程序时，我们希望为未登录的用户隐藏一些内容。</p><p id="156f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有两种简单的方法可以实现这一点:</p><ul class=""><li id="ba2b" class="li lj jf ke b kf kg kj kk kn lk kr ll kv lm kz oq lo lp lq bi translated">使用导航器并根据身份验证状态隐藏路由</li><li id="89f5" class="li lj jf ke b kf lr kj ls kn lt kr lu kv lv kz oq lo lp lq bi translated">根据身份验证状态使用不同的导航器</li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="7d04" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">设置:</strong></p><p id="bc7a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们用反应上下文来伪造身份验证。我们将添加一个包含身份验证上下文的文件。然后，我们将对现有文件进行一些小的更改，以便它们可以使用authenticationContext。</p><p id="aa97" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">我将authenticationContext文件建立在一个博客上，该博客解释了如何使用React Context。如果您想了解更多关于这个主题的信息，请点击下面的链接。</em></p><p id="52dd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">src/state/authentication context . js:</strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Based on: <a class="ae on" href="https://kentcdodds.com/blog/how-to-use-react-context-effectively" rel="noopener ugc nofollow" target="_blank">https://kentcdodds.com/blog/how-to-use-react-context-effectively</a></figcaption></figure><p id="05d8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> App.js </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="379a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> Home.js </strong></p><p id="083f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将添加一个按钮来切换我们的认证。我们的认证上下文包含一个经过认证的布尔值，我们将使用它来伪造我们的认证。因此，基本上，我们通过切换身份验证按钮登录和退出。</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/5c1458296636abbce11def8e50bd58d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*dpFOQhd0IkTRwA2X7toCfg.png"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="dfbf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然我们已经实现了虚拟认证，我们就可以开始编辑我们的导航了。</p><h2 id="cfef" class="ni lx jf bd ly nt nu dn mc nv nw dp mg kn nx ny mk kr nz oa mo kv ob oc ms od bi translated"><strong class="ak">使用导航器，根据认证状态隐藏路由</strong></h2><p id="2608" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">我们将使用身份验证状态来定义哪些路由可以访问，只需添加以下代码:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="9e0e" class="ni lx jf ne b gy nj nk l nl nm">{state.authenticated ? (<br/>&lt;Tab.Screen name="Tab2" component={TabScreen2} /&gt;<br/>) : (<br/>&lt;&gt;&lt;/&gt;<br/>)}</span></pre><p id="438f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，Tab2只有在经过身份验证时才可见。</p><p id="43ab" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> BottomTabNavigation.js </strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="30ab" class="ni lx jf bd ly nt nu dn mc nv nw dp mg kn nx ny mk kr nz oa mo kv ob oc ms od bi translated">根据身份验证状态使用不同的导航器</h2><p id="9697" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">根据身份验证状态，我们将使用两个完全不同的导航器。通过这种方法，我们可以区分日志导航和访客导航。</p><p id="5dfb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们创建了一个新的导航文件src/navigation/authentication navigation . js .<br/>在这个文件中，我们将使用AuthenticationContext，就像前面的组件一样。</p><p id="e335" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当用户通过身份验证时，我们返回一个BottomTabNavigator。当用户不在时，将返回一个StackNavigator。</p><p id="ef0b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">authentication navigation . js</strong></p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4025" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">未通过身份验证时，将出现此屏幕:</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/2b8c7ea085e419ce92cf860782132f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*svoK7ghY8bnr1JwxQh7xVA.png"/></div></figure><p id="4c62" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如您所注意到的，目前有两个标题是可见的。我们可以简单地通过将代码添加到DefaultStachNavigation.js:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="a8df" class="ni lx jf ne b gy nj nk l nl nm">&lt;Stack.Screen<br/>name="Authentication"<br/>component={AuthenticationNavigation}<br/>options={{<br/>   headerShown: false,<br/>}}<br/>/&gt;</span></pre><p id="17ad" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">切换身份验证时，将出现此屏幕:</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/75a6e705c610444e48cda19639771a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*9oSTll8LX1sJ6atCTtclBw.png"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="d9b0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这总结了一些你可以用反应导航库做的很酷的事情。<br/>如果你喜欢我创作的内容，不要忘记鼓掌，也不要忘记在Medium上跟着我。</p><p id="f170" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">——托马斯</p><h2 id="f228" class="ni lx jf bd ly nt nu dn mc nv nw dp mg kn nx ny mk kr nz oa mo kv ob oc ms od bi translated"><strong class="ak">简单英语团队的声明</strong></h2><p id="c610" class="pw-post-body-paragraph kc kd jf ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae on" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="ke jg">JavaScript in Plain English</strong></a><a class="ae on" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ke jg">AI in Plain English</strong></a><a class="ae on" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ke jg">UX in Plain English</strong></a><a class="ae on" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ke jg">Python in Plain English</strong></a><strong class="ke jg"/>—谢谢，继续学习！我们还推出了一个YouTube，希望你能通过<a class="ae on" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ke jg">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="4f19" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae on" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke jg">submissions @ plain English . io</strong></a><strong class="ke jg"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>