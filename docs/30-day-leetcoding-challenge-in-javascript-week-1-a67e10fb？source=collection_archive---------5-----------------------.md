# 30 天的 JavaScript leet coding 挑战:第 1 周

> 原文：<https://javascript.plainenglish.io/30-day-leetcoding-challenge-in-javascript-week-1-a67e10fb?source=collection_archive---------5----------------------->

![](img/8c1f705cb6226118225897e071ee4bc3.png)

整个四月，LeetCode 决定举办一项名为 30 天 leet code 挑战赛的活动。在活动期间，他们将每 24 小时发布一个问题，每个问题都要在其发布的 24 小时内解决。

我决定分享我对这些问题的解决方案，并提供这些问题背后的直觉。问题将按照发布的顺序列出。

# 单号(4 月 1 日)

> 给定一个**非空的**整数数组，每个元素出现*两次*，只有一个除外。找到那个单身的。
> 
> **注:**
> 
> 你的算法应该有一个线性的运行时间复杂度。你能不使用额外的内存来实现它吗？
> 
> **例 1:**
> 
> **输入:**【2，2，1】
> **输出:** 1
> 
> **例 2:**
> 
> **输入:**【4，1，2，1，2】
> **输出:** 4

## 最初的直觉

我们首先应该注意到没有空间方面的限制。这意味着最初的解决方案可能是使用一个`Map`来构造一个计数器，其中每个唯一值都是一个键，并且该值将是该键值在数组中出现的次数。

一旦初始化了这个计数器，我们就可以遍历它的元素，寻找值为 1 的键。

我们上面描述的解决方案将给我们`O(n)`时间复杂度和`O(n)`空间复杂度。

然而，注释建议我们尝试在没有额外内存的情况下实现这个问题的解决方案。

## 最优解的解释

我们应该考虑到，除了一个数字之外，每个元素都有一个对，并且如果数组非空，总会有一个答案。

为此，我们可以利用位操作。使用 XOR 运算符，我们知道`a ^ a = 0`。我们还知道，对于任意值`a`的`a ^ 0 = a`，使得`a > 0`。此外，我们链接这些运算的顺序并不重要，因为可以证明 XOR 是可交换的和结合的。所以像`a ^ b ^ a`这样的语句，总会给我们`b`。因此，对于像`[2, 2, 1]`这样的测试用例，如果我们要在整个数组中执行 XOR 运算，这样我们就有了`2 ^ 2 ^ 1`，我们可以看到我们获得了所需的值`1`，这是唯一没有重复的元素。

然后，我们可以对传递给函数的整数数组执行归约操作，并对运行值和当前值执行异或操作。

Optimal Solution using Bit Manipulation

# 快乐数字(4 月 2 日)

> 写一个算法，判断一个数字`n`是否“快乐”。
> 
> 快乐数字是由以下过程定义的数字:从任何正整数开始，用其数字的平方和替换该数字，并重复该过程，直到该数字等于 1(它将停留在该位置)，或者它**在不包括 1 的周期**中无限循环。这个过程**以 1** 结束的那些数字是快乐数字。
> 
> 如果`n`是一个快乐的数字，则返回 True，否则返回 False。

## 说明

这个问题本身很简单。给定某个整数`n`，我们对每个数字的平方求和，如果结果是 1，我们返回 true。否则我们会无休止地循环下去(或者我是这样认为的)。

这个问题最让人困惑的是，是否可以假设总有答案。事实是这不是真的。我最初实现一个解决方案是基于这样的假设，即总会有一个解决方案，并且我遇到了超过*时间限制的*错误。

为了弥补我们不被允许实际上无限循环的事实，我使用了一个`Set`来跟踪我们已经看到的数字。如果算法遇到一个它已经见过的数字，那么我们就跳出循环，确定我们已经见过的数字是 1 还是其他数字。当然，如果数字为 1，我们返回 true，否则返回 false。

Solution for Happy Number

# 最大子阵列(4 月 3 日)

> 给定一个整数数组`nums`，找出具有最大和的连续子数组(至少包含一个数)并返回其和。
> 
> **示例:**
> 
> **输入:** [-2，1，-3，4，-1，2，1，-5，4]，
> **输出:** 6
> **解释:**【4，-1，2，1】求和最大= 6。
> 
> **跟进:**
> 
> 如果你已经找到了 O( *n* )的解决方案，试着用分而治之的方法编写另一个解决方案，这更微妙。

## 说明

这是一个我已经解决过无数次的问题，因为它在编码面试中经常出现。我所知道的这个问题的`O(n)`解决方案叫做*卡丹算法。*

该算法的基本思想是跟踪两个最大值:局部最大值和全局最大值。局部最大值的思想是，在数组的每次迭代中，最大值要么是我们正在累加的当前运行总和加上我们已经迭代过的当前元素，要么是当前元素本身。全局最大值只是初始全局最大值或局部最大值之间的最大值。

为了对此有所了解，让我们假设我们有以下数组:`[-1, -2, 1]`

> **迭代前，假设局部最大值和全局最大值是数组的第一个元素，** `**-1**`
> 
> **然后在迭代 1(值为-2):**
> 
> 局部最大值=最大值(-2，-1±2)=-2
> 
> 全局最大值=最大值(-1，-2) = -1
> 
> **迭代 2 时(值为 1):**
> 
> 局部最大值=最大值(1，-2 + 1) = 1
> 
> 全局最大值=最大值(-1，1) = 1
> 
> **然后我们返回 1 作为我们的最大值**

# 移动零(4 月 4 日)

> 给定一个数组`nums`，写一个函数将所有的`0`移动到它的末尾，同时保持非零元素的相对顺序。
> 
> **例:**
> 
> **输入:**T4
> **输出:**
> 
> **注**:
> 
> 您必须在不复制数组的情况下就地执行**。**
> 
> **最小化操作总数。**

## **说明**

**这个问题的关键是要有一个指针，只有当你遇到非零值时，这个指针才会递增。**

**假设我们称这个指针为`j`。当我们迭代数组时，每当我们遇到非零值时，我们设置`nums[j] = nums[i]`然后递增`j`。否则，我们什么也不做。**

**一旦我们完成了初始迭代，我们就从`j`迭代到数组的末尾，并将每个值设置为 0。**

# **买卖股票 II 的最佳时间(4 月 5 日)**

> **假设您有一个数组`prices`，对于该数组 *i* 元素是给定股票在第 *i* 天的价格。**
> 
> **设计一个算法来寻找最大利润。您可以完成任意多的交易(即多次买入并卖出一股股票)。**
> 
> ****注意:**您不得同时进行多项交易(即必须先卖出后再买入)。**

## **说明**

**对于这个问题，在计算最大利润方面，我采用了贪婪策略。每当我们达到某个指数`i`的某个价格`prices[i]`时，我们会检查之前的指数，看它是否低于当前指数的价格，然后我们将它们的差额添加到我们的利润中。**

# **分组字谜(4 月 6 日)**

> **给定一个字符串数组，将变位组合在一起。**
> 
> ****示例:****
> 
> ****输入:** `["eat", "tea", "tan", "ate", "nat", "bat"]`，
> **输出:**
> `[
> ["ate","eat","tea"],
> ["nat","tan"],
> ["bat"]
> ]`**
> 
> ****注:****
> 
> **所有输入都将是小写。**
> 
> **输出的顺序并不重要。**

## **说明**

**这个问题没有太大的难度。解决这个问题需要一种强力的方法。为了将这些值组合在一起，我们可以使用一个映射，其中键是数组中唯一排序的字符串，值是一个字符串数组，其中每个字符串都是键的变位词。**

**对于数组中的每个字符串，我们都制作了一个排序后的副本。然后，我们检查排序后的副本是否已经在地图中。如果是，那么我们将原始字符串放入数组中的那个键。否则，我们必须将包含原始字符串的数组插入到映射中，并将排序后的字符串作为键。**

**然后，我们将创建的地图的值作为数组返回。**

# **计数元素(4 月 7 日)**

> **给定一个整数数组`arr`，计算元素`x`，使得`x + 1`也在`arr`中。**
> 
> **`arr`中如有重复，单独统计。**

## **说明**

**这个问题依赖于对`arr`中的值进行跟踪。一旦我们初始化了我们的集合，我们再次迭代数组，检查集合中是否存在`x+1`。如果值确实存在，我们增加一些计数器。**

## ****用简单英语写的 JavaScript 笔记****

**我们已经推出了三种新的出版物！请关注我们的新出版物:[**AI in Plain English**](https://medium.com/ai-in-plain-english)，[**UX in Plain English**](https://medium.com/ux-in-plain-english)，[**Python in Plain English**](https://medium.com/python-in-plain-english)**——谢谢，继续学习！****

****我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至[**submissions @ plain English . io**](mailto:submissions@plainenglish.io)**，使用您的 Medium 用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。******