<html>
<head>
<title>A Quick Guide To Stacks In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript堆栈快速指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-quick-guide-to-stacks-in-javascript-ecbf78515dc1?source=collection_archive---------5-----------------------#2019-11-03">https://javascript.plainenglish.io/a-quick-guide-to-stacks-in-javascript-ecbf78515dc1?source=collection_archive---------5-----------------------#2019-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f30" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解和实现堆栈</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/53b10efba3245dd9204c39cb4dbe9072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJiUvL0fQRudhjn_awWa-w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Stacks — image by Gabriela Rivera Mejias © 2019</figcaption></figure><h2 id="d23f" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是堆栈？</h2><p id="3e9a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">堆栈是一种结构化数据的方式。它们基于后进先出的概念。它们可以通过各种方式实现(稍后将会介绍)，但是有两种方式可以与数据交互:将一个元素放入栈顶或者从栈顶移除一个元素。</p><h2 id="ac22" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么使用堆栈？</h2><p id="6561" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">为了处理后进先出逻辑，堆栈有一个大的O:</p><ol class=""><li id="0c9a" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">插入O(1)</li><li id="451f" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">移除O(1)</li><li id="f506" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">查找元素O(n)</li><li id="fbe2" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">存取元素O(n)</li></ol><p id="babc" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">使用它们是因为它们几乎可以即时插入和移除元素。在其他一些数据结构中，处理插入需要O(n ),因为你首先要找到插入的位置(看看你的二分搜索法树！).在其他情况下，要删除，您必须先找到要删除的元素，或者像在数组中一样，您必须重新定位内部的每个元素。</p><h2 id="8568" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">栈用在哪里？你可能认识其中一些。</h2><ul class=""><li id="cdb9" class="mk ml iq lt b lu lv lx ly le nd li ne lm nf mj ng ms mt mu bi translated">JavaScript <a class="ae nh" href="https://www.freecodecamp.org/news/understanding-the-javascript-call-stack-861e41ae61d4/" rel="noopener ugc nofollow" target="_blank">调用堆栈</a></li><li id="b63a" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj ng ms mt mu bi translated">实现撤消/重做的应用程序</li><li id="28ed" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj ng ms mt mu bi translated">包括最近使用的应用程序</li><li id="216f" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj ng ms mt mu bi translated">任何需要用后进先出逻辑处理的数据</li><li id="fdac" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj ng ms mt mu bi translated">编程面试——所以记笔记吧👀</li></ul><h2 id="9fc6" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">作为堆栈的JavaScript数组</h2><p id="792e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">您可以使用JavaScript数组处理堆栈。尽管它们比其他替代方法慢一点，但已经用JavaScript实现了。它完全开箱即用。<strong class="lt ir">记住</strong>，一叠叠需要实现两件事；他们必须能够删除添加到列表中的最后一个元素，并且能够将一个元素添加到列表的末尾。</p><p id="0976" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这里有两种使用数组处理堆栈的方法:</p><ol class=""><li id="0ff5" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">您可以使用Array的push和pop方法(添加到末尾，从末尾删除)</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Arrays as stacks example with push and pop</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/23453f6e291f84f0e47d666aaeb563ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*1LbYsEHdn-9cGCfk6cOOIA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Arrays as stacks example with push and pop — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="1e4a" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">2.您可以使用Array的unshift和shift方法(添加到开头，从开头删除)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Arrays as stacks example with unshift and shift</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/baa5aa244a9f5ed9e58fa11055d79521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ZKYvc1MYvVBhyT3q7piQOg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Arrays as stacks example with unshift and shift — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><h1 id="32e3" class="nl kw iq bd kx nm nn no la np nq nr ld jw ns jx lh jz nt ka ll kc nu kd lp nv bi translated">用链表创建你自己的栈</h1><p id="d342" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">如果你想提高速度，使用链表堆栈是一个不错的方法。它们不是用JavaScript实现的，但是它们比数组快。这是因为当你从数组中移除一个元素时，你必须重新定位数组的索引。当你从链表中移除一个元素时，几乎是即时的。如果链接列表听起来令人困惑，看看这个用图片和gif解释的<a class="ae nh" href="https://medium.com/javascript-in-plain-english/a-quick-guide-to-linked-lists-in-javascript-27ea7046bc56" rel="noopener">指南</a>。</p><h2 id="6866" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现节点类</h2><p id="55ac" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">节点有两个属性:数据和下一个。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Node class example</figcaption></figure><p id="49d0" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">实现堆栈类</p><p id="cf61" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">一个栈有三个属性:栈的第一个节点<strong class="lt ir">，最后一个</strong>节点<strong class="lt ir">和栈的长度<strong class="lt ir"/>。看起来是这样的:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Stacks constructor example</figcaption></figure><h1 id="0ed0" class="nl kw iq bd kx nm nn no la np nq nr ld jw ns jx lh jz nt ka ll kc nu kd lp nv bi translated">堆栈推送和弹出方法</h1><p id="573d" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">有两种处理push和pop的方法。类似于数组，我们可以在链表的末尾，或者在链表的开头插入和删除。</p><p id="21ef" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">他们之间有巨大的差异。他们在这里:</p><ol class=""><li id="c467" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">在链表的末尾插入和移除(想想数组的push和pop方法)</li></ol><ul class=""><li id="699c" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj ng ms mt mu bi translated">插入O(1)</li><li id="1be7" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj ng ms mt mu bi translated">去除O(n)</li></ul><p id="d9ec" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">2.在链表的开头插入和移除(想想数组的unshift和shift方法)</p><ul class=""><li id="ceba" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj ng ms mt mu bi translated">插入O(1)</li><li id="704c" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj ng ms mt mu bi translated">移除O(1)</li></ul><p id="d477" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">虽然它通常被称为push和pop，但我们将把它当作unshift和shift来实现。这是因为如果你在链表的<strong class="lt ir">端</strong>插入和移除，移除最后一个节点需要遍历整个栈。这是因为您必须将堆栈的最后一个<strong class="lt ir">元素</strong>更改为其之前的元素。由于我们不能访问previous with链表，所以你必须遍历整个栈才能得到它。</p><p id="f528" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在链表的<strong class="lt ir">开始</strong>处插入和移除不涉及使用前面的元素，只涉及后面的元素，我们在链表中可以访问这些元素。这使得插入和移除在恒定的时间内发生，实现了我们的O(1)的目标。</p><h2 id="7c1f" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现堆栈推送(非移位)方法</h2><p id="18ae" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">向堆栈添加元素时，有两种不同的情况需要处理:</p><ol class=""><li id="0f6b" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">堆栈是空的。</li><li id="4a7a" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">堆栈中有个元素。</li></ol><p id="89ac" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在这两种情况下，都必须用给定的数据创建一个新节点，并将长度增加一。</p><p id="a5c3" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在代码中，push (unshift)看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Stacks push method example</figcaption></figure><p id="2ff3" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">情况1:当堆栈为空时</p><p id="88c1" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">使堆栈的第<strong class="lt ir">个</strong>和最后<strong class="lt ir">个</strong>属性成为新节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/54825e0238975e1670c5d4520c393a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*AKFa112WpA1KNoSAAMzbbg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 1: push with no elements in the Stack — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="c946" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">情况2:当堆栈有元素时</p><p id="a250" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">使新节点指向堆栈的第<strong class="lt ir">个</strong>属性，然后将第<strong class="lt ir">个</strong>更改为新节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d412c98ec5748dc963e06e275202c864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*sLXEseVdgdzRXaptGev7lw.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 2: push with elements in the Stack — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><h2 id="862f" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现堆栈弹出(移位)方法</h2><p id="0fd1" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">从堆栈中移除元素有三种不同的情况:</p><ol class=""><li id="2b2f" class="mk ml iq lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">堆栈中没有元素。</li><li id="198a" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">堆栈中只有一个元素。</li><li id="c345" class="mk ml iq lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">堆栈中有多个元素。</li></ol><p id="cee8" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在代码中，pop (shift)看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Stacks pop example</figcaption></figure><p id="5d1c" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">情况1:当堆栈中没有项目时</p><p id="89dc" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">什么都不做，返回null。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ee1f26283e3fc727f6dd5d769d457a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vrtH4O-AkW8Ml-lcrHDzkQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 1: pop with no elements in the Stack — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="345d" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">情况2:当堆栈中只有一个元素时</p><p id="56e5" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">通过将第<strong class="lt ir">个</strong>和最后<strong class="lt ir">个</strong>都设置为空，删除包含该元素的节点。将堆栈的<strong class="lt ir">长度</strong>减一，并返回被移除节点中的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/70c43115cf35dd69fc6842976297c644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8ZWDNSCLQ6FybwJMJTI7RA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 2: pop with one element in the Stack — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="86a2" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">情况3:当堆栈中有多个元素时</p><p id="60cb" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">通过将堆栈的第一个<strong class="lt ir">元素设置为列表中的下一个元素来删除第一个节点。将堆栈的<strong class="lt ir">长度</strong>减一，并返回被移除节点中的数据。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3dcfcdbbe0c8a709260f6ffe8a8501f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*hA-X07Qmgq3zMBklDetekw.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 3: pop with multiple elements in the Stack — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><h2 id="0615" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">完整的堆栈代码</h2><p id="a22e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">总之，用链表实现的堆栈看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Stack class example</figcaption></figure></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="78a6" class="pw-post-body-paragraph lr ls iq lt b lu mm jr lw lx mn ju lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">谢谢你能走到这一步！这是JavaScript堆栈的快速指南。如果你觉得这很有帮助，请鼓掌。如果您对未来的主题或问题有任何想法，请在下面回复！</p></div></div>    
</body>
</html>