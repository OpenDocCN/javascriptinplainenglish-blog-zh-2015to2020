<html>
<head>
<title>Traditional versus Arrow functions in JavaScript Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript类中的传统函数与箭头函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/traditional-versus-arrow-functions-in-javascript-classes-35f958b1a492?source=collection_archive---------1-----------------------#2020-11-04">https://javascript.plainenglish.io/traditional-versus-arrow-functions-in-javascript-classes-35f958b1a492?source=collection_archive---------1-----------------------#2020-11-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c8ce" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">怎么了？哦，没什么，只是做这做那。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/645cb673e5c147a14a8e532b2fc2d39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-IeFjTYIltNhNfNW4hE5YA.jpeg"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Source: <a class="ae ko" href="https://programmerhumour.tumblr.com/image/633387776634732544" rel="noopener ugc nofollow" target="_blank">Programmer Humor</a></figcaption></figure></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><p id="cdc9" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这是<a class="ae ko" href="https://suhanwijaya.medium.com/a-method-destructured-from-an-object-loses-its-original-context-21e73cf1451f" rel="noopener">这篇文章</a>的精神续篇。</p><p id="3f1c" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">使用传统函数创建一个类，如下所示。让我们称这种<strong class="ky io">方法为</strong>。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="8ed1" class="lx ly in lt b gy lz ma l mb mc">// APPROACH A</span><span id="ffee" class="lx ly in lt b gy md ma l mb mc">class SomeClass {<br/>    constructor() {<br/>        this.someProp = 'someValue';<br/>    }</span><span id="7eee" class="lx ly in lt b gy md ma l mb mc">    someMethod() { // Traditional function<br/>        console.log(this.someProp);<br/>    }<br/>}</span></pre><p id="4b0c" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">创建该类的一个实例。在实例上调用方法时，<code class="fe me mf mg lt b">this</code>指的是实例。到目前为止，它的行为符合预期。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="17c1" class="lx ly in lt b gy lz ma l mb mc">let instance = new SomeClass();</span><span id="4ed7" class="lx ly in lt b gy md ma l mb mc">instance.someMethod(); // logs 'someValue'</span></pre><p id="1b42" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">但是，一旦我们将方法赋给一个变量，并调用这个函数变量，这个方法就失去了它的上下文，你就得到了<code class="fe me mf mg lt b">Uncaught TypeError: Cannot read property ‘someProp’ of undefined.</code></p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="36b3" class="lx ly in lt b gy lz ma l mb mc">let instance = new SomeClass();</span><span id="ccde" class="lx ly in lt b gy md ma l mb mc">let funcVariable = instance.someMethod;<br/>funcVariable(); // logs error</span></pre><p id="e46e" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">好的。</p><p id="37d4" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">现在，让我们用一个使用箭头函数的方法来创建这个类，如下所示。让我们称之为<strong class="ky io">方法b。</strong></p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="4174" class="lx ly in lt b gy lz ma l mb mc">// APPROACH B</span><span id="1437" class="lx ly in lt b gy md ma l mb mc">class SomeClass {<br/>    constructor() {<br/>        this.someProp = 'someValue';<br/>    }</span><span id="4e71" class="lx ly in lt b gy md ma l mb mc">    someMethod = () =&gt; { // Arrow function<br/>        console.log(this.someProp);<br/>    }<br/>}</span></pre><p id="5bde" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">这现在起作用了。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="d692" class="lx ly in lt b gy lz ma l mb mc">let instance = new SomeClass();<br/></span><span id="0f8a" class="lx ly in lt b gy md ma l mb mc">let funcVariable = instance.someMethod;<br/>funcVariable(); // logs 'someValue'</span><span id="10cf" class="lx ly in lt b gy md ma l mb mc"><br/>const { someMethod } = instance; // destructuring also works!<br/>someMethod(); // logs 'someValue'</span></pre><h1 id="38a8" class="mh ly in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">为什么，JavaScript，为什么？</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/5dbba6db845d1fb7d391d8954b0370b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DT47G1odneXeJWZw4lirww.jpeg"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Source: <a class="ae ko" href="https://programmerhumour.tumblr.com/image/633251914676600832" rel="noopener ugc nofollow" target="_blank">Programmer Humor</a></figcaption></figure><p id="4aef" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">根据<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>，<em class="nd">“</em><code class="fe me mf mg lt b"><em class="nd">class</em></code><em class="nd">关键字是ES2015中引入的，但在语法上是糖，JavaScript仍然是基于原型的。”</em>所以如果我们用ES6之前的语法来写，<strong class="ky io">方法和</strong>看起来是这样的。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="7eb5" class="lx ly in lt b gy lz ma l mb mc">// Equivalent to APPROACH A</span><span id="4d86" class="lx ly in lt b gy md ma l mb mc">'use strict';</span><span id="0e53" class="lx ly in lt b gy md ma l mb mc">var SomeClass = function() {<br/>    this.someProp = 'someValue';<br/>}</span><span id="4c88" class="lx ly in lt b gy md ma l mb mc">SomeClass.prototype.someMethod = function() {<br/>    console.log(this.someProp);<br/>}</span><span id="4472" class="lx ly in lt b gy md ma l mb mc">var instance = new SomeClass();</span></pre><p id="8dee" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">属性<code class="fe me mf mg lt b">someMethod</code>定义在构造函数的<code class="fe me mf mg lt b">prototype</code>上。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/19f9c1956cd58c35ecd2c00968b6bb89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*dCPPZGSH9Qf_c7RdTFa2Ag.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Chrome Dev Console</figcaption></figure><p id="ba6d" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">但不是在<code class="fe me mf mg lt b">instance</code>上。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1d50d5aab969d54442df21312c7333b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*I9XIUW-edxdWn_Y8I-8qRQ.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Chrome Dev Console</figcaption></figure><p id="1f37" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">您可以通过<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank">原型继承</a>访问<code class="fe me mf mg lt b">instance.someMethod</code>。</p><p id="53be" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="ky io">但是当你把</strong> <code class="fe me mf mg lt b"><strong class="ky io">instance.someMethod</strong></code> <strong class="ky io">赋给另一个变量的时候，函数变量就失去了上下文。</strong></p><p id="1e2d" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">此外，由于<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions" rel="noopener ugc nofollow" target="_blank"><em class="nd"/></a><code class="fe me mf mg lt b"><a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions" rel="noopener ugc nofollow" target="_blank"><em class="nd">class</em></a></code><a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions" rel="noopener ugc nofollow" target="_blank"><em class="nd">主体的语法边界内的代码总是以严格模式执行</em> </a>，<code class="fe me mf mg lt b">this</code>将是未定义的，而不是默认为<code class="fe me mf mg lt b">window</code>或<code class="fe me mf mg lt b">global</code>。</p><p id="cda9" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">好的。</p><p id="913c" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">现在，<strong class="ky io">方法B </strong>在ES6之前看起来是这样的:</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="aedf" class="lx ly in lt b gy lz ma l mb mc">// Equivalent to APPROACH B</span><span id="b7d6" class="lx ly in lt b gy md ma l mb mc">'use strict';</span><span id="042e" class="lx ly in lt b gy md ma l mb mc">var SomeClass = function() {<br/>    this.someProp = 'someValue';</span><span id="f0e4" class="lx ly in lt b gy md ma l mb mc">    var _that = this;</span><span id="c6d3" class="lx ly in lt b gy md ma l mb mc">    this.someMethod = function() {<br/>        console.log(_that.someProp);<br/>    }<br/>}</span><span id="944d" class="lx ly in lt b gy md ma l mb mc">var instance = new SomeClass();</span></pre><p id="e164" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">属性<code class="fe me mf mg lt b">someMethod</code>是在构造函数的<code class="fe me mf mg lt b">prototype</code>上定义的<em class="nd">而不是</em>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3148c0d6474f9408bad487e0973d6ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*Axs8fo1y575ZiMwsy5P02Q.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Chrome Dev Console</figcaption></figure><p id="92dd" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">而是在<code class="fe me mf mg lt b">instance</code>上定义。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nh"><img src="../Images/29abc27604b6bd7a687e896638a457a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUkx782Yo1M1fBe8np9mDg.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk">Chrome Dev Console</figcaption></figure><p id="74bc" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">此外，默认情况下，Arrow函数<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Description" rel="noopener ugc nofollow" target="_blank">绑定到其周围的词法上下文</a>(它实际上位于代码中)，这似乎相当于传统函数可以访问指向<code class="fe me mf mg lt b">this</code>的外部函数变量(即<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>)。</p><p id="611d" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="ky io">因此，即使你将</strong> <code class="fe me mf mg lt b"><strong class="ky io">instance.someMethod</strong></code> <strong class="ky io">赋值给另一个变量，该函数变量仍然绑定到</strong> <code class="fe me mf mg lt b"><strong class="ky io">instance</strong></code> <strong class="ky io">上下文。</strong></p><p id="c9e9" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">注意:我不是100%确定箭头函数派生出<code class="fe me mf mg lt b">this</code>的实际“幕后”机制，所以如果你知道，请随意评论。</p><p id="5174" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">无论如何，我进入了这个兔子洞，因为我一直使用箭头函数来编写经典React组件中的方法，而不是在<code class="fe me mf mg lt b">constructor</code>中绑定传统函数(即<code class="fe me mf mg lt b">this.someMethod.bind(this)</code>)或将其作为prop传递。</p><pre class="kd ke kf kg gt ls lt lu lv aw lw bi"><span id="22a3" class="lx ly in lt b gy lz ma l mb mc">import React from 'react';</span><span id="d06b" class="lx ly in lt b gy md ma l mb mc">class SomeComponent extends React.Component {<br/>    constructor(props) {<br/>        super(props);</span><span id="3e43" class="lx ly in lt b gy md ma l mb mc">        this.state = { /* some state */ };<br/>    }</span><span id="987c" class="lx ly in lt b gy md ma l mb mc">    someMethod = () =&gt; { // Arrow function<br/>        // will have access to `this.state`<br/>    }</span><span id="6737" class="lx ly in lt b gy md ma l mb mc">    render() {<br/>        // may attach `this.someMethod` as an event handler or <br/>        // pass it down as a prop to child components<br/>    }<br/>}</span></pre><p id="fd47" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">不认可一种或另一种方法，只是描述不同之处。哦，猜猜<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">哪个浏览器</a>与整个讨论完全无关。</p><p id="96c1" class="pw-post-body-paragraph kw kx in ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">📫<em class="nd">点击</em><a class="ae ko" href="https://www.linkedin.com/in/suhanwijaya/" rel="noopener ugc nofollow" target="_blank">T5】领英 </a> <em class="nd">或</em> <a class="ae ko" href="mailto:suhanw@gmail.com" rel="noopener ugc nofollow" target="_blank"> <em class="nd">发邮件</em> </a> <em class="nd">！</em></p></div></div>    
</body>
</html>