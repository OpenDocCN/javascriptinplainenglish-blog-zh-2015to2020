<html>
<head>
<title>Event Handling with React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React组件处理事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/event-handling-with-react-components-cacda737c120?source=collection_archive---------6-----------------------#2020-03-05">https://javascript.plainenglish.io/event-handling-with-react-components-cacda737c120?source=collection_archive---------6-----------------------#2020-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/854666d4a6b892c42154434eebc8b3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ELNDj9kZ2K2dY0OF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alelmes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alasdair Elmes</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0b21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="82ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何在React组件中处理事件。</p><h1 id="f5b9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理事件</h1><p id="7bdc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在React元素中处理事件与在DOM元素中处理事件非常相似。</p><p id="4d31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同之处在于事件侦听器名称是camelCase而不是小写，并且我们传入一个函数作为事件处理程序，而不是一个字符串。</p><p id="e972" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以添加一个按钮来显示警告框，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8c3c" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="74d5" class="mn lc iq mj b gy ms mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>  }</span><span id="4ff2" class="mn lc iq mj b gy ms mp l mq mr">  showAlert() {<br/>    alert("hello");<br/>  }</span><span id="bd54" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button onClick={this.showAlert}&gt;Click Me&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3e4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个<code class="fe mt mu mv mj b">showAlert</code>方法show runs <code class="fe mt mu mv mj b">alert(“hello”);</code>来显示一个带有hello的警告。</p><p id="153b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">render</code>方法中，我们有一个<code class="fe mt mu mv mj b">button</code> React元素，它有一个采用<code class="fe mt mu mv mj b">this.showAlert</code>方法的<code class="fe mt mu mv mj b">onClick</code>属性。</p><p id="fbef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们传入了对该方法的引用，因为我们不会立即调用它。只有当我们点击“点击我”按钮时，它才会被调用。</p><p id="cc73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能返回<code class="fe mt mu mv mj b">false</code>来防止React中的默认行为。我们必须显式调用<code class="fe mt mu mv mj b">preventDefault</code>。</p><p id="4ba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在React中调用它，我们编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cc03" class="mn lc iq mj b gy mo mp l mq mr">showAlert(e) {<br/>  e.preventDefault();<br/>  alert("hello");<br/>}</span></pre><p id="a724" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe mt mu mv mj b">e</code>是根据<a class="ae kc" href="https://www.w3.org/TR/DOM-Level-3-Events/" rel="noopener ugc nofollow" target="_blank"> W3C规范</a>定义的合成事件对象。</p><p id="4f8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建DOM元素后，我们通常不需要调用<code class="fe mt mu mv mj b">addEventListener</code>来添加侦听器。我们只是像上面一样在组件中提供侦听器。</p><p id="d71d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，我们创建了<code class="fe mt mu mv mj b">showAlert</code>方法作为按钮的事件处理程序。这是在React基于类的组件中创建事件处理程序的一种普遍接受的模式。</p><p id="a5a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建一个带有按钮的组件，该组件可以切换按钮中的文本，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="120e" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { on: true };<br/>  }</span><span id="3205" class="mn lc iq mj b gy ms mp l mq mr">  handleClick() {<br/>    this.setState({<br/>      on: !this.state.on<br/>    });<br/>  }</span><span id="9ef0" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;button onClick={this.handleClick.bind(this)}&gt;<br/>        {this.state.on ? "ON" : "OFF"}<br/>      &lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="23d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe mt mu mv mj b">this.handleClick.bind(this)</code>传递给<code class="fe mt mu mv mj b">onClick</code>属性，再传递给<code class="fe mt mu mv mj b">button</code>元素。</p><p id="95af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要<code class="fe mt mu mv mj b">bind(this)</code>，这样<code class="fe mt mu mv mj b">this</code>值将成为<code class="fe mt mu mv mj b">this.setState</code>方法调用中的外部组件。</p><p id="de34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们点击按钮时，<code class="fe mt mu mv mj b">handleClick</code>被调用，它通过<code class="fe mt mu mv mj b">this.setState</code>调用用相反的值更新<code class="fe mt mu mv mj b">this.state.on</code>。</p><p id="2555" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，我们可以这样写<code class="fe mt mu mv mj b">handleClick</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="094f" class="mn lc iq mj b gy mo mp l mq mr">handleClick() {<br/>  this.setState(state =&gt; ({<br/>    on: !state.on<br/>  }));<br/>}</span></pre><p id="316b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用<code class="fe mt mu mv mj b">this</code>时，为了避免调用<code class="fe mt mu mv mj b">bind</code>，我们可以使用一个箭头函数来代替，因此我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1d79" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { on: true };<br/>  }</span><span id="783f" class="mn lc iq mj b gy ms mp l mq mr">  handleClick = () =&gt; {<br/>    this.setState({<br/>      on: !this.state.on<br/>    });<br/>  };</span><span id="4793" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;button onClick={this.handleClick}&gt;{this.state.on ? "ON" : "OFF"}&lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="a7b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做是因为arrow函数没有自己的<code class="fe mt mu mv mj b">this</code>，所以我们不必将<code class="fe mt mu mv mj b">handleClick</code>函数内的<code class="fe mt mu mv mj b">this</code>改为带有<code class="fe mt mu mv mj b">bind(this)</code>的<code class="fe mt mu mv mj b">App</code>类。</p><p id="b924" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以传入一个调用事件监听器的函数。</p><p id="8047" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以这样修改它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7cb2" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { on: true };<br/>  }</span><span id="9683" class="mn lc iq mj b gy ms mp l mq mr">  handleClick = () =&gt; {<br/>    this.setState({<br/>      on: !this.state.on<br/>    });<br/>  };</span><span id="a263" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;button onClick={e =&gt; this.handleClick(e)}&gt;<br/>        {this.state.on ? "ON" : "OFF"}<br/>      &lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="f8a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">e =&gt; this.handleClick(e)</code>是一个调用<code class="fe mt mu mv mj b">this.handleClick</code>方法的函数，传递了<code class="fe mt mu mv mj b">e</code>事件对象。</p><p id="8762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也避免了调用<code class="fe mt mu mv mj b">bind(this)</code>的需要。然而，它的效率较低，因为我们每次运行<code class="fe mt mu mv mj b">render</code>时都返回一个新的事件处理函数。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/82c9bcb58d9e3d860bdff1816d2e224d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LbOM-WrUlesfLiXr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brittanyg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">britt gaiser</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e485" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将参数传递给事件处理程序</h1><p id="edf8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将参数作为<code class="fe mt mu mv mj b">bind</code>的第二个参数传入来将参数传入事件处理程序，或者我们可以使用传入的参数返回一个事件处理程序函数。</p><p id="df74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b255" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { val: 0 };<br/>  }</span><span id="f289" class="mn lc iq mj b gy ms mp l mq mr">  handleClick(val) {<br/>    this.setState({<br/>      val<br/>    });<br/>  }</span><span id="d1b0" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;button onClick={this.handleClick.bind(this, Math.random())}&gt;<br/>        {this.state.val}<br/>      &lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="a1be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在代码中，我们将<code class="fe mt mu mv mj b">Math.random()</code>作为<code class="fe mt mu mv mj b">handleClick</code>方法的<code class="fe mt mu mv mj b">val</code>参数的值传入。</p><p id="b931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8d31" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { val: 0 };<br/>  }</span><span id="5b5b" class="mn lc iq mj b gy ms mp l mq mr">  handleClick(val, e) {<br/>    e.preventDefault();<br/>    this.setState({<br/>      val<br/>    });<br/>  }</span><span id="587f" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;button onClick={e =&gt; this.handleClick(Math.random(), e)}&gt;<br/>        {this.state.val}<br/>      &lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="71bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe mt mu mv mj b">Math.random()</code>在第一个参数中，而<code class="fe mt mu mv mj b">e</code>在第二个参数中，但是反过来也可以，因为我们可以返回我们喜欢的任何函数。</p><h1 id="3018" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="03e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将事件侦听器附加到React元素，就像我们为HTML DOM元素设置事件侦听器一样。</p><p id="22dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事件名称是大写字母，而不是小写字母。如果我们的事件处理器不是一个箭头函数，我们必须调用<code class="fe mt mu mv mj b">bind</code>来改变<code class="fe mt mu mv mj b">this</code>的值到我们自己的组件类。</p><p id="27e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以传入一个调用另一个函数作为事件处理程序的函数。</p><p id="7e91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将参数传入事件处理程序，我们可以将它作为第二个和后续的参数传入<code class="fe mt mu mv mj b">bind</code>。</p><p id="aabf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们传入一个调用另一个函数作为事件处理程序的函数，那么我们可以传入任何我们喜欢的函数，因为我们自己定义了这个函数。</p></div></div>    
</body>
</html>