<html>
<head>
<title>Handling Asynchrony with Vue Composition API and vue-concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用vue组合API和Vue并发处理异步</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handling-asynchrony-with-vue-composition-api-and-vue-concurrency-part-2-canceling-throttling-4e0305c82367?source=collection_archive---------7-----------------------#2020-08-08">https://javascript.plainenglish.io/handling-asynchrony-with-vue-composition-api-and-vue-concurrency-part-2-canceling-throttling-4e0305c82367?source=collection_archive---------7-----------------------#2020-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6881" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分—取消、节流、去抖动、轮询</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/48372c36c4ecedf4158bb8bed724e997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czp56gN67isf3G_E_35jOg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Visualization of a restartable task in vue-concurrency</figcaption></figure><p id="9250" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在上一篇文章中，我谈到了承诺和处理异步状态。这篇文章将指出承诺的另一个弱点:缺乏取消。</p><p id="3dc1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">很容易认为你没有取消的必要。矛盾的是，由于目前JavaScript中的默认工具很难取消，所以不经常讨论和推荐。但是确实有一些用例，取消是一个强大的工具，不仅仅是对于一些高级的用例，在一些常见的特性中也是如此，比如去抖动和轮询，或者只是为了使异步逻辑总体上更加安全。你只需要合适的工具。</p><p id="e090" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">承诺是不可取消的，因此你也不能取消一个异步函数。解决这个问题的一个方法是利用发电机。与异步函数一样，生成器函数也有特殊的语法。</p><pre class="kd ke kf kg gt lo lp lq lr aw ls bi"><span id="c9c4" class="lt lu in lp b gy lv lw l lx ly">function myFun * () {<br/>  yield foo();<br/>  return 'bar';</span><span id="f300" class="lt lu in lp b gy lz lw l lx ly">}</span></pre><p id="0f68" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们用<code class="fe ma mb mc lp b">*</code>代替<code class="fe ma mb mc lp b">async</code>来标记函数，用<code class="fe ma mb mc lp b">yield</code>代替<code class="fe ma mb mc lp b">await</code>。但是生成器函数更加灵活——它们的行为在很大程度上是由传递给它们的消费者定义的。你可以创建自己的生成器函数处理程序，但通常你只能依赖第三方库。例如<a class="ae md" href="https://github.com/getify/CAF" rel="noopener ugc nofollow" target="_blank"> CAF —可取消的异步流</a>。传递给CAF的生成器函数开始表现得像异步函数一样——产生对承诺解析的等待。但是最重要的是，有可能<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/cancellation/#cancelation" rel="noopener ugc nofollow" target="_blank">cancel</a>()</code>并提前中止执行。</p><p id="3e04" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae md" href="https://github.com/MartinMalinda/vue-concurrency" rel="noopener ugc nofollow" target="_blank"> vue-concurrency </a>利用CAF，将整个逻辑包装成一个方便的反应对象:<a class="ae md" href="https://vue-concurrency.netlify.app/task-state/" rel="noopener ugc nofollow" target="_blank"> Task </a>。</p><h1 id="ddb6" class="me lu in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">投票</h1><p id="3437" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">取消非常方便的一个典型用例:轮询。当你轮询时，你在一个指定的时间间隔内做一个特定的操作，或者直到一个特定的动作。最直接的方法是使用<code class="fe ma mb mc lp b">setInterval</code>，但是你需要确保在正确的时间使用<code class="fe ma mb mc lp b">clearInterval</code>。毕竟，你的Vue应用程序可能表现得像一个单页面应用程序，你不希望当用户导航到一个不同的页面时，你的轮询继续。所以，是的，你可以做一些防御检查，然后清除<code class="fe ma mb mc lp b"><a class="ae md" href="https://v3.vuejs.org/api/composition-api.html#lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">onBeforeUnmount</a></code>组合API挂钩中的间隔。但是有了vue并发，事情就简单多了:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="59b0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe ma mb mc lp b">while (true)</code>在JavaScript中很少见。但随着取消它变得可行。轮询任务等待新数据，然后反复等待5秒钟。当使用该任务的组件被卸载时，该任务会自动取消。所以这段代码做起来很安全，不需要处理setInterval。</p><p id="0f21" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这个任务中，还有<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#drop" rel="noopener ugc nofollow" target="_blank">drop</a>()</code>修改器。它使事情变得更加可靠，确保任务不能同时运行多个实例。在这种情况下，这意味着轮询只能运行一次。如果任务可能需要重新开始，但是使用不同的参数，也许检查不同的端点，它可以改为设置为<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#restartable" rel="noopener ugc nofollow" target="_blank">restartable</a>()</code>。一个可重新启动的任务将取消以前的任务实例，并启动一个新的任务实例。</p><p id="fe4e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">就是这样！如果需要，我们还可以进一步更新我们的代码，以允许手动取消和恢复:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5177" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">当我们将任务传递给模板时，我们得到了通常的好处。在模板中，我们可以检查<code class="fe ma mb mc lp b">task.isRunning</code>是否有效，并且我们可以弹性地显示<code class="fe ma mb mc lp b">lastSuccessful</code>值(假设一些API调用可能失败):</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="81cd" class="me lu in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">去抖动</h1><p id="0dd7" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">当用户完成输入时显示搜索结果是当今的一个普遍特征，并且提供了一个很好的UX。直接的方法是在按键后触发计时器，如果计时器已经在运行，就重置计时器。如果你自己不写这个逻辑，你通常会把你的函数包装在一些现有的<a class="ae md" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">去抖</a>工具中，例如来自<a class="ae md" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank"> lodash </a>的工具。</p><p id="3e8d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了vue并发和任务，操作又变得更加简单和安全。</p><p id="2c34" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们可以创建一个类似于上一个任务的任务:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7716" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里不同的是<code class="fe ma mb mc lp b">timeout()</code>在任务调用的开始。我们等待700毫秒，然后执行一个AJAX请求。如果再次执行该任务(每次按键都会执行)，则取消之前的任务调用，并创建一个新的任务实例，因为该任务是<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#restartable" rel="noopener ugc nofollow" target="_blank">restartable</a>()</code>。这有效地让我们去抖。这使得事情没有使用神秘的去抖功能那么神奇，也给了你更多的灵活性。如有必要，等待时间可以是动态的(也许不等待某些键！…或者等待更长时间)。</p><h1 id="8fca" class="me lu in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">节流</h1><p id="d33e" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">如果我们想在用户输入时显示搜索结果<em class="nc">，而不是之后，该怎么办？在这种情况下，对每一次按键执行搜索可能仍然是不可行的。我们希望以某种方式限制搜索API调用。这就是节流发挥作用的地方。假设我们想在用户输入时进行搜索，但是每隔200毫秒才进行一次。我们可以利用第一个(轮询)例子中的<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#drop" rel="noopener ugc nofollow" target="_blank">drop</a>()</code>修改器，但这并不理想。<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#keeplatest" rel="noopener ugc nofollow" target="_blank">keepLatest</a>()</code>比较好，适合。就像<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#drop" rel="noopener ugc nofollow" target="_blank">drop</a>()</code>一样，它也防止任务并行运行多个实例，但它确保最后一个实例最终被执行。这是节流的理想选择。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e0ac" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">是的，这里唯一的区别是传递给<code class="fe ma mb mc lp b">timeout</code>的数字不同，并且使用了<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#keeplatest" rel="noopener ugc nofollow" target="_blank">keepLatest</a>()</code>而不是<code class="fe ma mb mc lp b"><a class="ae md" href="https://vue-concurrency.netlify.app/managing-concurrency/#restartable" rel="noopener ugc nofollow" target="_blank">restartable</a>()</code>！</p><h1 id="a27e" class="me lu in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">下一个</h1><p id="898e" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">虽然不是本系列的一部分，但我还有一篇文章适合这个领域:构建基本数据层:</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/@martinmalinda/building-a-data-layer-with-vue-and-composition-api-547cc9761b4c" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">用Vue和组合API构建数据层</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">当你在学习一个新的前端库时，比如Vue或者React，你可以在best……</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div></div></a></div><h2 id="11b9" class="lt lu in bd mf np nq dn mj nr ns dp mn lb nt nu mp lf nv nw mr lj nx ny mt nz bi translated">在herohero上订阅每周编码示例、技巧和提示</h2><p id="3cae" class="pw-post-body-paragraph ks kt in ku b kv mv jo kx ky mw jr la lb mx ld le lf my lh li lj mz ll lm ln ig bi translated">嘿👋如果你觉得这些内容有帮助，<a class="ae md" href="https://herohero.co/martin" rel="noopener ugc nofollow" target="_blank">在herohero </a>上订阅我吧，在那里我经常分享我日常使用JavaScript和Vue的经验中简洁而有用的编码技巧。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://herohero.co/martin"><div class="gh gi oa"><img src="../Images/19339e390e1513a8a73f83e1ec1036a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29xXbBkTMAe_w-dkMYfI4Q.png"/></div></a></figure></div></div>    
</body>
</html>