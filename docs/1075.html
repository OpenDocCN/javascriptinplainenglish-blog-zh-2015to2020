<html>
<head>
<title>V-outside-click: Writing Vue Directives For Seamless Interactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外部点击:为无缝交互编写Vue指令</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/v-outside-click-writing-vue-directives-for-seamless-interactions-99abdb362813?source=collection_archive---------0-----------------------#2020-01-26">https://javascript.plainenglish.io/v-outside-click-writing-vue-directives-for-seamless-interactions-99abdb362813?source=collection_archive---------0-----------------------#2020-01-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f930" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Vue的流行的自定义指令新实施，并介绍了这一关键的Vue掌握。[已更新]</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b58e327764faa2d2626a55bb81224911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQMi2QgfGG3Be3aUQRAtxA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Directing: Photo by <a class="ae ks" href="https://unsplash.com/@imkirk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Iewek Gnos</a> on <a class="ae ks" href="https://unsplash.com/s/photos/direct?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="ea6a" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">TL；博士:</h2><p id="877c" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">+自定义指令允许<strong class="lr io">可重用的交互</strong>与<strong class="lr io">元素</strong><br/>+注册指令与<strong class="lr io">vue . directive</strong>(' directive-name '，directive object)<br/>+使用指令与<strong class="lr io">v-directive-name</strong>:arg . modifier . modifier 2 = " value "<br/>+参数<strong class="lr io">、修饰符、</strong> &amp; <strong class="lr io">值</strong>都提供了传递指令数据的方法<br/>+指令由 b…g . value&amp;b…g . modifiers<br/>+用<strong class="lr io"> el </strong> &amp;访问绑定元素，用<strong class="lr io"> vnode </strong> <br/>访问Vue实例+利用<strong class="lr io">事件监听器</strong> &amp;其他技巧充分利用指令<br/>—<br/>+<strong class="lr io">V-外部点击</strong>如果在<br/>之外点击元素，则触发事件+这也很重要 使用<strong class="lr io">虚拟类名</strong>来表示被排除的元素<br/>+参见本文底部<strong class="lr io">的完整<strong class="lr io">源代码</strong></strong></p><h1 id="5cd0" class="mi ku in bd kv mj mk ml ky mm mn mo lb jt mp ju lf jw mq jx lj jz mr ka ln ms bi translated">介绍</h1><p id="cf50" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">{Vue Masters: Nuts &amp; bolts开始于<a class="ae ks" href="#77f1" rel="noopener ugc nofollow"> <strong class="lr io">实现外部点击检测</strong> </a>源代码在最末尾} <br/>和我的大多数文章一样，这篇文章开始于我花费额外的时间试图实现一些我在互联网上找不到好文档的东西。然而，这一次我实际上有了一个不错的基础，但它不足以满足我的需求。因为我相信这个新的实现比我最初发现的要好得多，所以我认为有必要分享一下我对常用的“外部点击”指令的实现，同时介绍一下自定义指令。这个例子需要对<a class="ae ks" href="https://vuejs.org/v2/guide/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>有适度的理解。</p><h1 id="a252" class="mi ku in bd kv mj mk ml ky mm mn mo lb jt mp ju lf jw mq jx lj jz mr ka ln ms bi translated">关于自定义指令</h1><h2 id="c70d" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是自定义指令:</h2><p id="2a24" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">Vue实现了<a class="ae ks" href="https://vuejs.org/v2/guide/custom-directive.html" rel="noopener ugc nofollow" target="_blank">自定义指令</a>,作为开发人员在元素级别构建重用的一种方式。这使得开发人员可以为默认的元素交互创建自定义的反应，比如v-click。任何DOM交互都可以很容易地写入自定义指令，并附加到元素上，而不管组件是什么。</p><h2 id="da4d" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">注册指令:</h2><p id="7e7a" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">指令可以全局注册，也可以本地注册(我在这里显示的是全局)。就像组件或插件一样，有一个函数可以将指令附加到根Vue实例。因此，新的应用程序实现可能如下所示:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="f848" class="kt ku in mu b gy my mz l na nb">import Vue from 'vue'<br/>import App from './views/App'<br/>import <strong class="mu io">OutsideClick </strong>from '<strong class="mu io">./directives/OutsideClick</strong>'<br/>...</span><span id="7b77" class="kt ku in mu b gy nc mz l na nb">Vue.component(...)</span><span id="cfb1" class="kt ku in mu b gy nc mz l na nb">Vue.use(...)</span><span id="40ef" class="kt ku in mu b gy nc mz l na nb"><strong class="mu io">Vue.directive('outside-click', OutsideClick)</strong></span><span id="94ac" class="kt ku in mu b gy nc mz l na nb">const app = new Vue({<br/>...App<br/>})</span><span id="9ae7" class="kt ku in mu b gy nc mz l na nb">export { app }</span></pre><p id="f7a0" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">该指令附有一个名称“outside-click”{将被称为v-outside-click}和一个定义该指令的对象OutsideClick {从单独的文件导入}。</p><h2 id="8d0b" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">使用您的自定义指令:</h2><p id="b016" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">显然，您希望实现一个自定义指令，以便可以使用它。幸运的是，这个最重要的部分是最容易的。一旦指令附加到父实例或组件，就可以像元素中的任何其他Vue指令一样引用它:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="2929" class="kt ku in mu b gy my mz l na nb">&lt;div <strong class="mu io">v-custom-directive</strong>:arg.modifier.modifier2="value"&gt;<br/>...<br/>&lt;/div&gt;</span></pre><p id="65de" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">指令捕获它所附加的元素，并将不同的参数传递给指令的绑定参数。第一个参数是“arg”，它可以是一个原始值，也可以是动态的(访问组件属性)，方法是将其包装在[]中，如:v-directive:[arg]…接下来是修饰符，它们充当真标志。可以有多个修饰符，如果存在，它将被添加到一个对象中，如{modifierName:true}。最后是价值论证。这是动态的，可以返回计算、方法、对象或原始字符串的组合。我的建议是将值做成一个对象，这样就可以清楚地知道传递的是什么参数:{handler:handlerMethod，excludeList: ["list "，" of "，" things"]}。自定义指令不一定需要向其传递任何参数，但是这些参数允许您将特定于组件的值和逻辑绑定到响应指令中。在这个具体的例子中，我同时传入了值和方法。该指令能够提取排除列表，并且只对不在列表中的元素做出反应。它还能够调用handler方法，允许元素基于handler方法中的特定执行逻辑来影响组件中的更改。通过这种方式，我可以让一个元素在外部注册单击时收缩，但让另一个元素使用完全相同的指令隐藏该元素。</p><p id="55a0" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">现在我们只需要知道如何构造指令，使其真正有用。</p><h2 id="b435" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">自定义指令的剖析:</h2><p id="8c3d" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">最简单地说，指令定义只是一个对象(就像Vue中的其他东西一样),附加到指令名上。属性表示元素生命周期中与“挂钩”相关的功能。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="4660" class="kt ku in mu b gy my mz l na nb">//a directive definition object with bind hook<br/>const CoolDirective = {<br/>   <strong class="mu io">bind</strong>: function(){<br/>      //do stuff here<br/>   }<br/>}</span><span id="662a" class="kt ku in mu b gy nc mz l na nb">export default CoolDirective</span></pre><p id="7c79" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">因此，一个指令定义可能看起来像这样，你可以导出它，然后导入到你的应用程序中。您也可以将整个对象包含在您的指令包含中，而不是在一个单独的文件中定义它，但是这样会更难看。</p><p id="2036" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated"><strong class="lr io">生命周期挂钩</strong>包括<strong class="lr io">绑定、插入、更新、组件更新</strong>和<strong class="lr io">解除绑定</strong>。通过向对象添加具有这些名称之一的属性，将在生命周期触发时调用该函数。例如，bind属性上的函数只有在DOM将指令附加到元素时才会被触发。而inserted将在子元素插入父元素时触发。如果将对父节点的引用传递到指令中，这种差异可能很重要。当这些生命周期挂钩被触发时，函数被调用并被传递参数。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="ed58" class="kt ku in mu b gy my mz l na nb">{<br/>   bind: function(<strong class="mu io">el, binding, vnode</strong>){<br/>      //you can now access the hook arguments here<br/>   }<br/>}</span></pre><p id="f396" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated"><strong class="lr io">这些指令钩子参数</strong>包括el、binding、vnode和oldVnode。它们取决于该函数附加到哪个钩子上。例如，unbind只能访问el参数。el参数就是指令的威力所在:el允许您修改绑定所附加到的元素。因此，钩子函数有一个非常干净简洁的元素访问，以及从组件内定义接收逻辑和变量的方法。这是通过绑定(.值，。arg，还有。修饰语)前面提到过。所有这些都可以在“绑定”钩子参数中找到。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="3eab" class="kt ku in mu b gy my mz l na nb">//instantiation:<br/>&lt;div v-custom-directive<strong class="mu io">:ARG.MODIFIER</strong>="<strong class="mu io">VALUE</strong>"&gt;&lt;/div&gt;</span><span id="341c" class="kt ku in mu b gy nc mz l na nb">//directive definition<br/>{<br/>   bind: function(<strong class="mu io">el, binding, vnode</strong>){<br/>      value = binding.value //equals the component value of VALUE<br/>      modifierVal=binding.modifiers["<strong class="mu io">MODIFIER</strong>"] //true if exists<br/>      arg= binding.arg //will be literal "ARG" unless made dynamic<br/>   }<br/>}</span></pre><p id="f6e3" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">vnodes提供了对Vue实例的访问。整个绑定参数和vnodes都是只读的。</p><p id="c1e7" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">那么，我们如何利用所有这些论点呢？就像<a class="ae ks" href="https://vuejs.org/v2/guide/mixins.html" rel="noopener ugc nofollow" target="_blank"> mixins </a>指令允许我们制作可重用的函数来与组件交互。但是现在我们也可以访问特定的元素。<br/> <strong class="lr io">函数</strong>允许我们执行由这些元素生命周期钩子触发的逻辑。因为您可以访问元素，所以可以更改可见性或颜色等值。因此，您可以在插入元素时将元素的颜色设置为给定值，如下所示:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="6460" class="kt ku in mu b gy my mz l na nb">{<br/>   inserted: function(el, binding, vnode){<br/>       el.style.color=binding.value<br/>   }<br/>}<br/>//directive instantiation =&gt; &lt;div v-custom-color="#ffffff"&gt;&lt;/div&gt;</span></pre><p id="3c7e" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">当然，这可以通过使用Vue <a class="ae ks" href="https://vuejs.org/v2/guide/class-and-style.html#Binding-Inline-Styles" rel="noopener ugc nofollow" target="_blank">风格绑定</a>来实现。那么，你能用给定的工具做什么更有用的事情呢？vnode让我们可以访问我们正在处理的Vue实例，通过使用上下文，我们可以访问拥有该元素的组件。考虑到这一点，我们可以从这个指令中访问组件中的方法和数据。因此，也许我们有一个特殊的方法，我们想运行基于元素生命周期。例如，我们可以在每次更新组件时对元素运行更新方法(在binding参数中命名):</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="fe4c" class="kt ku in mu b gy my mz l na nb">{<br/>     componentUpdated: function(el, binding, vnode){<br/>       //get the component method with the given name<br/>       vnode.context[binding.value](el)//send the element for edit<br/>     }<br/>}<br/>//there is a simpler way of passing the method through binding.value<br/>//instead of just the name, vnode usage is for example sake</span></pre><p id="26cb" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">这样，我们可以在组件中定义自定义方法，但在特定元素上执行它，而不会出现难看的文档查询或代码重复。但是这仍然在元素生命周期的有限范围内。我们如何打破这种局面。<br/>在我看来，指令最强大的用途是初始化一个事件监听器，并赋予它在特定事件上运行的特殊方法。这提供了一个复杂的关系，当一个元素被绑定时，一个事件监听器被创建来调用组件方法，该组件方法被传递要被修改的元素。它看起来像这样:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="0eb6" class="kt ku in mu b gy my mz l na nb">{<br/>   bind: function(el, binding, vnode){<br/>    handleEvent = e =&gt; {<br/>        e.stopPropagation()<br/>        if(el.contains(e.target)){<br/>            binding.value(el)// value is the method we execute<br/>        }<br/>    }<br/>      document.addEventListener('click', handleEvent)<br/>   }<br/>}</span></pre><p id="deb6" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">这是我的外部点击指令和其他指令(如滚动指令)的基础。请注意，这个示例并不完整，因为当元素未绑定时，我们没有正确地解除事件侦听器的绑定。您可以在下面的完整示例中看到这一点。</p><p id="ccaf" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">这是自定义指令的基础，你可以在这里找到完整的文档<a class="ae ks" href="https://vuejs.org/v2/guide/custom-directive.html" rel="noopener ugc nofollow" target="_blank">。但是现在，让我们更深入地看看具体的外部单击实现，以获得这些简单指令如何如此强大的第一手资料。</a></p><h1 id="34ae" class="mi ku in bd kv mj mk ml ky mm mn mo lb jt mp ju lf jw mq jx lj jz mr ka ln ms bi translated">V-外部单击指令</h1><p id="37d4" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">这个特定的定制指令似乎很受欢迎，是现代UX设计的关键部分。你会发现它有很多不同的名字，比如v-closed，v-click-outside，v-click way等等。但是它们都试图完成相同的目标:当用户在附加指令的元素之外单击时，执行一个动作。</p><h2 id="a679" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">外部点击检测背后:</h2><p id="40bb" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">外部点击检测允许当你点击它的外部时关闭一个下拉菜单或弹出菜单，当你点击离开它时调整一个元素的大小或改变它的内容。要捕获点击，您必须注册click的事件侦听器(可能还会触发事件，您将会看到)。在事件处理程序中，您需要检查事件侦听器元素(被单击的元素)是否与指令绑定元素匹配。允许忽略被点击的元素也是有利的，即使它们不是指令元素。</p><p id="47de" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">当一些其他元素打开您的指令元素时，这是特别必要的。否则，该指令会将另一个元素注册为外部单击，并触发您的处理程序(这可能是关闭，导致该指令元素无用)。我在这里遇到了现有实现的问题。所有建议的用于定义排除元素的方法都使用了组件引用，但是这有一个限制，即只能排除一个组件中的元素。它看起来会像下面这样:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="5d34" class="kt ku in mu b gy my mz l na nb">let clickedOnExcludedEl = false<br/>        exclude.forEach(refName =&gt; {<br/>          // We only run this code if we haven't detected<br/>          // any excluded element yet<br/>          if (!clickedOnExcludedEl) {<br/>            // Get the element using the reference name<br/>            let excludedEl = vnode.context.$refs[refName]<br/>            // Get the actual element if it is a Vue component<br/>            excludedEl = (excludedEl instanceof Vue)<br/>              ? excludedEl.$el<br/>              : excludedEl<br/>            if (excludedEl) {<br/>              // See if this excluded element<br/>              // is the same element the user just clicked on<br/>              clickedOnExcludedEl = excludedEl.contains(e.target)<br/>            }<br/>          }<br/>        })</span></pre><p id="176c" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">这看起来非常复杂，最终只允许一个级别的元素被排除在触发关闭之外。为什么？因为它只检查元素所在的组件上下文中的引用。然而，我使用深度组件树，通常需要两个元素(即一个在组件中，一个在几层之上的标题中)来打开组件，而不是触发立即关闭。因此，经过大量思考后，我开发了自己的解决方案，其关键要素是公开目标元素类。</p><h2 id="77f1" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">实施外部点击检测:</h2><p id="4953" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">使用一个定义良好的对象通过指令绑定值传递我的参数，我从发送一个exclude元素列表和handler方法开始。我还在元素上定义了一个id，它应该是惟一的，以后会用到。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="85fe" class="kt ku in mu b gy my mz l na nb">&lt;cardElement <br/>  <strong class="mu io">:id="someUniqueId"</strong></span><span id="d976" class="kt ku in mu b gy nc mz l na nb">  v-if="showCard" <br/>  <strong class="mu io">v-outside-click="{<br/>    exclude: ['outside-click-exclude'],<br/>    handler: exitCard<br/>  }"<br/></strong>&gt;<br/>&lt;/cardElement&gt;</span></pre><p id="2999" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">我还为打开卡片的按钮添加了一个虚拟类“外部点击排除”。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="8e41" class="kt ku in mu b gy my mz l na nb">&lt;button class="<strong class="mu io">outside-click-exclude</strong>' @click="openCard"&gt;...</span></pre><p id="feec" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">您还希望在组件中有一个处理程序方法，当正确的点击被触发时执行该方法。大概是这样的:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="dd3d" class="kt ku in mu b gy my mz l na nb">...<br/>methods:{<br/>...<br/>  <strong class="mu io">exitCard</strong>(){<br/>    this.showCard = false<br/>  },<br/>  openCard(){<br/>    this.showCard = true<br/>  }<br/>...<br/>}<br/>...</span></pre><p id="2037" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">现在我们可以看实际的指令定义了。我们将使用两个钩子，bind &amp; unbind，并且我们需要定义一个共享变量，该变量将包含要传递给事件侦听器的处理程序。</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="870f" class="kt ku in mu b gy my mz l na nb">// create variable for our handler to be shared between the bind &amp; unbind hooks<br/>var <strong class="mu io">handleOutsideClick </strong>= {} //an object to hold named functions</span><span id="d103" class="kt ku in mu b gy nc mz l na nb">const OutsideClick = {<br/>  // this directive is run on the bind and unbind hooks<br/>  <strong class="mu io">bind </strong>(el, binding) {<br/>   ...<br/>  },<br/>  <strong class="mu io">unbind </strong>(el) {<br/>   ...<br/>}  <br/>export default OutsideClick</span></pre><p id="8575" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">当然，要让我们的处理程序操作点击动作，我们需要将它附加到点击监听器。在绑定时，我们希望将处理程序附加到侦听器上，而在解除绑定时，我们希望移除侦听器。请注意，这是事情变得有点棘手的地方。<a class="ae ks" href="https://www.w3schools.com/js/js_htmldom_eventlistener.asp" rel="noopener ugc nofollow" target="_blank">事件监听器</a>接受任何函数，但是要正确移除处理函数，它必须是一个命名函数。<strong class="lr io">如果同一个文档中的多个元素使用这个指令</strong>，它们必须有不同命名的函数，这样移除才能正常工作。为此，我使用了存储在对象中的函数，以便可以根据元素id动态设置名称，如下所示:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="dfeb" class="kt ku in mu b gy my mz l na nb">...<br/>bind (el, binding) {<br/>   ...<br/>   // Register our outsideClick handler on the click/touchstart <br/>       listeners<br/>   <strong class="mu io">document.addEventListener('click', handleOutsideClick[el.id])</strong><br/>   <strong class="mu io">document.addEventListener('touchstart',handleOutsideClick[el.id])</strong><br/>},<br/>unbind (el) {<br/>    // If the element that has v-outside-click is removed, unbind <br/>      it from listeners<br/>    <strong class="mu io">document.removeEventListener('click', handleOutsideClick[el.id]</strong>)<br/>    <strong class="mu io">document.removeEventListener(<br/>      'touchstart',<br/>      handleOutsideClick[el.id]<br/>    </strong>)<br/>}<br/>...</span></pre><p id="404e" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">现在我们还需要定义这个处理程序在点击事件上要做什么。这将在bind钩子内部完成，在那里我们可以访问el和binding:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="a294" class="kt ku in mu b gy my mz l na nb">...<br/>bind(el, binding){<br/>      <strong class="mu io">handleOutsideClick[el.id]</strong>= e =&gt; {<br/>      e.stopPropagation()<br/>      // extract the handler and exclude from the binding value<br/>      const { handler, exclude } = <strong class="mu io">binding</strong>.value<br/>      // set variable to keep track of if the clicked element is in <br/>         the exclude list<br/>      let clickedOnExcludedEl = false<br/>      // if the target element has no classes, it won't be in the <br/>         exclude list: skip the check<br/>      if (e.target._prevClass !== undefined) {<br/>        // for each exclude name check if it matches any of the <br/>           target element's classes<br/>        for (const className of exclude) {<br/>          clickedOnExcludedEl =<br/>            e.target._prevClass.includes(className)<br/>          if (clickedOnExcludedEl) {<br/>            break // once we have found one match, stop looking<br/>          }<br/>        }<br/>      }<br/>      // don't call the handler if our directive element contains <br/>         the target element<br/>      // or if the element was in the exclude list<br/>      if (!(clickedOnExcludedEl || <strong class="mu io">el</strong>.contains(e.target))) {<br/>        handler()<br/>      }<br/>    }<br/>    ...<br/>}</span></pre><p id="33d6" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">我们在这里和这个负责人做什么？<br/>因为我们不只是想将我们的原始组件方法直接传递给点击监听器(否则任何点击都会尝试调用您的方法),所以我们首先需要过滤掉我们不想触发它的任何点击。<br/>这从遍历由排除列表给出的所有类名开始，并检查目标元素(由监听器传递)是否有这些类中的任何一个。使用<code class="fe ni nj nk mu b">e.target._prevClass</code>访问元素类。一旦我们找到一个，我们继续前进。<br/> <strong class="lr io">注意</strong>:要认识到，既然我们使用的是类名，那么你整个app中的任何元素都可以被过滤掉。这是我需要让外部点击为我自己工作的技巧，我相信这是一个更干净的实现。</p><p id="bb2e" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">在获得元素是否被排除的真值后，我们接着查看指令元素(我们想要触发外部点击的元素)是否包含目标元素。如果是，这意味着我们在指令元素内部单击，并且不想调用处理程序。如果这两种情况都不成立，则调用绑定传入的处理程序方法。我的示例方法将元素的条件值设置为false，将其从页面中取出。</p><p id="4e8c" class="pw-post-body-paragraph lp lq in lr b ls nd jo lu lv ne jr lx lc nf lz ma lg ng mc md lk nh mf mg mh ig bi translated">这就是实现外部单击指令所需的全部内容。如果你觉得我错过了什么，请告诉我。否则，掌声是受欢迎的。如果你有其他你想了解的话题，请告诉我，我会考虑如何解决。指令定义的完整源代码如下。谢谢，继续编码；马库斯</p><h1 id="9d5c" class="mi ku in bd kv mj mk ml ky mm mn mo lb jt mp ju lf jw mq jx lj jz mr ka ln ms bi translated">完整源代码:</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nm l"/></div></figure></div></div>    
</body>
</html>