<html>
<head>
<title>How To Merge Two Binary Trees In JavaScript🌳</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中合并两个二叉树🌳</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-solution-to-c9de621e0cc3?source=collection_archive---------11-----------------------#2020-10-28">https://javascript.plainenglish.io/javascript-solution-to-c9de621e0cc3?source=collection_archive---------11-----------------------#2020-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4a2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://medium.com/javascript-in-plain-english/tree-traversal-in-javascript-9b1e92e15abb" rel="noopener"> <strong class="jm io"> <em class="kj">先决条件:JavaScript中的树遍历</em> </strong> </a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/97143ed7fa1cc81f25459e5b1edbfd6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sbiNOxLuN4qgzjN3"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@allahetman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alla Hetman</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="105c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题</strong></p><pre class="kl km kn ko gt lh li lj lk aw ll bi"><span id="5d13" class="lm ln in li b gy lo lp l lq lr">Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</span><span id="ea71" class="lm ln in li b gy ls lp l lq lr">You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</span></pre><p id="e50f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">示例输入:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lt"><img src="../Images/b046d4b50fd508b9b82c6ea90816198f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5slk4iBDS6pVhFuVTevMqw.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Example input</figcaption></figure><p id="b99e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">示例输出合并树:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/090b5b65b4f9a90cc7d595ed07bc28c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*o-dfZoK-bZy9kjprJ-CJ7g.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Example output</figcaption></figure><p id="da01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>合并过程必须从两棵树的根节点开始。</p><p id="e4a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">树的节点如下所示:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk"><a class="ae ki" href="https://gist.github.com/GAierken/f1ab81562b141052ce18ca003da0e6b1" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/f1ab81562b141052ce18ca003da0e6b1</a></figcaption></figure></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="b57c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">深度优先搜索解决方案</strong></p><p id="e360" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先我们需要确定输入，函数的给定参数，是两个二叉树。并且输出是合并的树。根据这个例子，当在同一层的两棵树都有节点时，我们需要对节点值求和来生成一个新节点，如果其中一个有节点，另一个节点为空，我们需要保留非空节点。要转换一棵合并的树，需要我们遍历这两棵树。</p><p id="0142" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们考虑解决方案之前，我们需要考虑边缘情况。没有约束，它们中的一个或两个可能都为空。当给定的一棵树为空时，我们可以立即返回另一棵树，不管它是否为空。为了变换一棵树，我们可以将另一棵树合并到它上面，当两棵树都不为空时，我们对节点值求和。并遍历两棵树的左右路径。最后，返回合并后的树。</p><p id="f766" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终的解决方案应该是这样的:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk"><a class="ae ki" href="https://gist.github.com/GAierken/a31d1e5596d336b73298c4dca5d4707e" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/a31d1e5596d336b73298c4dca5d4707e</a></figcaption></figure><p id="cb8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">DFS的时间复杂度为O(n)。考虑到我们只访问每个节点一次，我们得到了这种复杂性。</p><p id="12ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这个解决方案能让你了解如何解决类似的问题。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="0064" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">T15】资源:T17】</strong></p><div class="lx ly gp gr lz ma"><a href="https://leetcode.com/problems/merge-two-binary-trees/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd io gy z fp mf fr fs mg fu fw im bi translated">合并两个二叉树- LeetCode</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">给定两个二叉树，想象当你用其中一个覆盖另一个时，这两棵树的一些节点是…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">leetcode.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ku ma"/></div></div></a></div><div class="lx ly gp gr lz ma"><a href="https://medium.com/javascript-in-plain-english/tree-traversal-in-javascript-9b1e92e15abb" rel="noopener follow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd io gy z fp mf fr fs mg fu fw im bi translated">JavaScript中的树遍历</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">呼吸优先搜索vs深度优先搜索</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">medium.com</p></div></div><div class="mj l"><div class="mp l ml mm mn mj mo ku ma"/></div></div></a></div></div></div>    
</body>
</html>