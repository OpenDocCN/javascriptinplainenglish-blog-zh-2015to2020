<html>
<head>
<title>Algorithms 101: Rotate Array in JavaScript — three solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:在JavaScript中旋转数组——三种解决方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-rotate-array-in-javascript-three-solutions-260fbc923b64?source=collection_archive---------1-----------------------#2019-11-18">https://javascript.plainenglish.io/algorithms-101-rotate-array-in-javascript-three-solutions-260fbc923b64?source=collection_archive---------1-----------------------#2019-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉算法#22，玩。pop()，。unshift()和。拼接()</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/37d9d5b1aa89a55a21d26a167cd46afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*lCDsmMbpI75XxT96-TsHDw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">rotate right!</figcaption></figure><p id="00b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">浏览LeetCode中的顶级面试问题，其中一个比较难的简单问题是<a class="ae ln" href="https://leetcode.com/problems/rotate-array/" rel="noopener ugc nofollow" target="_blank">这个:</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/6b39e8eaf1438b10ccb48bd6b4d357ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRo0sslX0VoCrxuIQrWGyQ.png"/></div></div></figure><h1 id="4722" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">第一种解决方案:while循环使用。pop()和。未移位()</h1><p id="d1f5" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">最简单的解决方案是使用JavaScript的<strong class="kt ir">。pop() </strong>，结合<strong class="kt ir">，破坏性地移除并返回数组的最后一个元素(<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank"> MDN文档此处为</a>)。unshift() </strong>，破坏性地将元素添加到数组的开头(<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" rel="noopener ugc nofollow" target="_blank"> MDN文档此处</a>)。</p><p id="9d83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是如何工作的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mq"><img src="../Images/60646f13d1bfca984e88cf532f7240ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nB2W_0F_rbHhuEldoLfdfw.png"/></div></div></figure><p id="5ecd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个挑战中，我们要执行<code class="fe mr ms mt mu b">k</code>次操作。我们可以通过设置一个<strong class="kt ir"> while循环</strong>来实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mv"><img src="../Images/a2cffe9b435410467f04361f9f28067f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GRG5aUaPdPyp5cQCQysvg.png"/></div></div></figure><p id="2ada" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们打开它。</p><p id="ff7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第2行，我们设置了一个初始值为零的计数器。在每个循环结束时(第5行)，我们将计数器加1。</p><p id="74b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第3行，我们说:“当我们的计数器小于我们应该执行循环的次数时，继续循环”。</p><p id="eac4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mw">注意:</em>是的，我是从零开始计数的，而不是从一。如果你想从1开始，那么在第3行写<code class="fe mr ms mt mu b">while i &lt;= k</code>而不是<code class="fe mr ms mt mu b">while i &lt; k</code>。</p><p id="a6b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是可行的，但是没有那么快:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mx"><img src="../Images/9e97741ca984f2e1011e6525cbfd67ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZdhcbrbvZQ0-j4hlnad0g.png"/></div></div></figure><p id="d7d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们怎样才能加快速度呢？我决定试试<strong class="kt ir">。拼接()</strong>而不是<strong class="kt ir">。流行()</strong> …</p><h1 id="a01d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">第二个解决方案:。拼接()而不是。流行()</h1><p id="7d85" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">LeetCode性能时间不是很一致。当我第一次尝试这个解决方案时，<strong class="kt ir">。拼接()</strong>跑得比<strong class="kt ir">快。pop()</strong>；后来好像也是这样。</p><p id="1498" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你从一个数组中删除一个元素时，后面的元素必须向前移动以取代内存中丢失的元素。根据数组的大小，这可能会降低运行时间。(因为数组的所有元素都必须在内存中“坐在一起”，所以每次数组改变时，元素都必须重新索引)。</p><p id="6f12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果总是删除数组中的最后一项，则没有后面的项，因此可以跳过重新索引。根据定义<strong class="kt ir">。pop() </strong>总是只删除最后一项。所以它的速度很快。</p><p id="8f14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">。splice() </strong>可以将目标项放在数组的任意位置；因此，当它瞄准除了最后一个项目以外的任何项目时，它会更慢。</p><p id="dfe0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">。splice() </strong>需要两个参数。</p><ul class=""><li id="af29" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">要开始移除项目的索引。(使用-1、-2表示最后、倒数第二等等。数组的索引。)</li><li id="bf5b" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">要移除的项目数。如果没有提供第二个参数，slice将删除从提供的索引开始直到数组末尾的所有元素。</li></ul><p id="f75b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一种破坏性的方法，会改变原始数组。(如果想要无损的方法，试试<strong class="kt ir">。slice() </strong>，它采用不同的参数。这里是关于<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">的MDN文档。拼接()</strong> </a>和<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">。片()</strong> </a> ) <strong class="kt ir">。</strong></p><p id="c51b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面介绍<strong class="kt ir">。</strong>作品拼接():</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nm"><img src="../Images/b9c9c5e7d496cb8b9b9ae916fe654626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZxJnPj-aoprzgKw4t8dAA.png"/></div></div></figure><p id="5d7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的挑战中，我们可以这样使用它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nn"><img src="../Images/39b35ddfa0a049b26428ca06e4c4791c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFXLcOsbPuAGTIAmaHij3g.png"/></div></div></figure><p id="a207" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是……(叹气)……并没有更快:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi no"><img src="../Images/872607a27cfb7e3a8fed3c7c41e3d36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMPIvnSg4_Xr6nu414EVSw.png"/></div></div></figure><h1 id="bbf4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">第三种解决方案:针对不同场景进行优化。</h1><p id="2240" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">到目前为止，我们的代码是通过一次弹出一个元素并将其附加到数组的前面来实现的。不管是短数组还是长数组，都是一样的。以及我们应该弹出1个项目还是100万个项目。</p><p id="9e45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过针对不同场景进行优化来加快速度。如果我们有一个100个元素的数组，而<code class="fe mr ms mt mu b">k</code>是90会怎么样？如果我们弹出最后一项并将其追加到数组的前面90次，我们必须重新索引数组…90次。那太多了。</p><p id="464d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们只是从末尾<strong class="kt ir">拼接()</strong>掉最后的<code class="fe mr ms mt mu b">k</code>项，并将它们作为一个块添加到数组的前面，怎么样？</p><p id="5125" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以这样做:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi np"><img src="../Images/9a6fa5947da4f582e1fb71326332aabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rU3b1bPjOGOYCghYc-l0kA.png"/></div></div></figure><p id="ed16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:</p><ul class=""><li id="600d" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">我们用<code class="fe mr ms mt mu b">-k</code>来。<strong class="kt ir"> splice() </strong>关闭数组的最后一个<code class="fe mr ms mt mu b">k</code>项。</li><li id="917f" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">nums.splice(-k)返回一个数组。为了将数组的元素添加到nums的开头(而不是数组本身)，我们使用了扩展操作符:<code class="fe mr ms mt mu b">...nums.splice(-k)</code></li></ul><p id="ac89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按原样运行代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nq"><img src="../Images/fd13d41eb15ffb3142ed98d8da21fc43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WvczZXOvFa_rhvXdIB4Kzg.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">whoops ….</figcaption></figure><p id="e397" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不工作…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nr"><img src="../Images/48500d5f4c5ba8c1b317b26d7b20ca84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwOMnFfYgcsF-vdbX49Vhg.png"/></div></div></figure><p id="e8e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为它错过了我们需要旋转的次数<code class="fe mr ms mt mu b">k</code>大于数组长度的边缘情况。</p><p id="d75d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了处理边缘情况，我们可以添加一个if /else语句:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ns"><img src="../Images/8855a13289f3ad1dab03e1c2399958f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1gv3RhFCKT2Sgq6iq9AWA.png"/></div></div></figure><p id="b5a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，else语句使用了我们第二个解决方案中的代码！</p><p id="15e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们的代码运行得更快了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nt"><img src="../Images/1035cbfb5a0132251040f6eba4e922e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WELdWFt_x97ye4UgDxifpw.png"/></div></div></figure><p id="142d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在PythonTutor.com上看到现场执行的代码</p><p id="a704" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在repl.it上玩它:</p><p id="b2b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://repl.it/@Joan_IndianaInd/rotate-arrays-leetcode" rel="noopener ugc nofollow" target="_blank">https://repl.it/@Joan_IndianaInd/rotate-arrays-leetcode</a></p><p id="230b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">版权所有琼·印第安纳·琳斯2019 </strong></p><p id="93c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mw">接下来:</em> <a class="ae ln" href="https://medium.com/@joanrigdon/algorithms-101-find-the-difference-between-two-arrays-in-javascript-c19f12dee103" rel="noopener"> <em class="mw">算法101 #22、JavaScript中两个数组的区别</em> </a></p><p id="075c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mw">万一你错过了:</em> <a class="ae ln" href="https://medium.com/@joanrigdon/algorithms-101-includes-vs-indexof-in-javascript-7f1b4af04127" rel="noopener"> <em class="mw">算法101、#20、。JavaScript </em> </a>中的includes()与indexOf()</p></div></div>    
</body>
</html>