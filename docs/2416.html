<html>
<head>
<title>Data Driven Form building in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的数据驱动表单构建</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-driven-form-building-in-react-30768b49e625?source=collection_archive---------0-----------------------#2020-06-22">https://javascript.plainenglish.io/data-driven-form-building-in-react-30768b49e625?source=collection_archive---------0-----------------------#2020-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9a41803a6edeef90825b2d0803c48d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*4gADCnyaRqlC_5FfyMlfHw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Data Driven Forms is open source React library for rendering and managing forms. Multiple design system bindings are provided.</figcaption></figure><p id="4124" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="kx">设计系统</em>是当今应用程序开发的一个非常强大的术语。每家科技公司都试图通过将其中一个整合到他们所有的应用程序中来实现一致性和简单的开发者体验。</p><p id="0268" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，它们中的许多都是开源的，可以公开获得。为了说明这一点，我们可以提到IBM的<a class="ae ky" href="https://www.carbondesignsystem.com/" rel="noopener ugc nofollow" target="_blank"> Carbon </a>，Google的<a class="ae ky" href="https://material.io/design" rel="noopener ugc nofollow" target="_blank"> Material </a>，或者Red Hat的<a class="ae ky" href="https://www.patternfly.org/v4/" rel="noopener ugc nofollow" target="_blank"> PatternFly </a>。这些库是可定制的，易于与许多预定义的组件一起使用，因此即使是小项目也可以使用它们来使自己的开发更容易、更便宜、更快，而不会牺牲定制身份。</p><p id="874e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，选择一个正确的是特别困难的，当他们有这么多的时候。正因为如此，从一个简单的原型开始是一个很好的主意，但是这样做不应该花太多时间。一个有帮助的工具是<a class="ae ky" href="https://data-driven-forms.org/" rel="noopener ugc nofollow" target="_blank">数据驱动表单</a> ( <em class="kx"> DDF </em>)，一个使用<a class="ae ky" href="https://medium.com/javascript-in-plain-english/data-driven-approach-to-forms-with-react-c69fd4ea7923" rel="noopener">数据驱动方法</a>呈现和管理表单的React库。这种方法获取JSON数据，并将它们转换成功能齐全的形式。无需任何实际的代码知识，复杂的表单可以在几分钟内“编码”。</p><h1 id="f541" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">用例—创建表单模式</h1><p id="8c04" class="pw-post-body-paragraph jz ka in kb b kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw ig bi translated">让我们想象一个简单的案例来实现:<strong class="kb io">一个注册表单</strong>。根据我们<em class="kx">虚构的</em>产品管理，表单由用户必须输入的几个元素组成:</p><ul class=""><li id="92e7" class="mc md in kb b kc kd kg kh kk me ko mf ks mg kw mh mi mj mk bi translated">绰号</li><li id="dc13" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated">电子邮件</li><li id="2754" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated">密码</li><li id="4565" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated">确认口令</li><li id="de27" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated">条款确认</li></ul><p id="52f6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以根据其<a class="ae ky" href="https://data-driven-forms.org/renderer/renderer-api#schema" rel="noopener ugc nofollow" target="_blank">定义</a>直接开始定义数据驱动表单模式。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="89f3" class="mz la in mv b gy na nb l nc nd">const schema = {<br/>  fields: [] <br/>}</span></pre><p id="9a11" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">模式是一个包含一个必需属性的对象:<strong class="kb io">字段</strong>。表单域的数组。每一个都是由只有<a class="ae ky" href="https://data-driven-forms.org/renderer/component-api#commonpropsforallformfields" rel="noopener ugc nofollow" target="_blank">两个必需属性</a> : <strong class="kb io">名称</strong>和<strong class="kb io">组件</strong>的对象定义的。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="959f" class="mz la in mv b gy na nb l nc nd"><strong class="mv io">const field = {<br/>  name: ...,<br/>  component: ...,</strong><br/>  ...additionalAttributes<br/><strong class="mv io">}</strong></span></pre><p id="57b4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它们都是字符串值，定义了它们的名字的确切含义。<strong class="kb io">组件</strong>依赖于一组使用的组件，但是在数据驱动表单提供的库中，我们可以在<code class="fe ne nf ng mv b">text-field, select, checkbox, radio, textarea, ...</code>等关键字下找到<a class="ae ky" href="https://data-driven-forms.org/renderer/component-api" rel="noopener ugc nofollow" target="_blank">所有的基本表单组件</a>。然后这些组件实现它们的自定义属性，大部分都是共享的:<code class="fe ne nf ng mv b">label, helperText, options, ...</code>。在React中，属性对应于组件属性。</p><p id="7141" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，让我们将元素转换为字段定义:</p><ul class=""><li id="1102" class="mc md in kb b kc kd kg kh kk me ko mf ks mg kw mh mi mj mk bi translated"><strong class="kb io">昵称</strong></li></ul><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7254" class="mz la in mv b gy na nb l nc nd">{<br/>  name: 'nickname',<br/>  component: 'text-field'<br/>}</span></pre><p id="dda7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，这显然不足以满足(<em class="kx">也是虚构的</em> ) UX的要求。没有标签和验证——使用这样的配置，它只是一个HTML输入元素。幸运的是，在数据驱动的表单中，修复非常简单:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="31c4" class="mz la in mv b gy na nb l nc nd">{<br/>  name: 'nickname',<br/>  component: 'text-field'<br/><strong class="mv io">  label: 'Nick name',<br/>  validate: [{type: 'required'}],<br/></strong>}</span></pre><p id="8036" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">引入了两个新属性:<strong class="kb io">标签</strong>和<strong class="kb io">验证</strong>。<a class="ae ky" href="https://data-driven-forms.org/renderer/validators" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> Validate </strong> </a>是一组验证器——对象或函数。数据驱动表单提供了覆盖大多数情况(长度、模式)的基本验证，但也可以通过提供<a class="ae ky" href="https://data-driven-forms.org/renderer/validators#customfunction" rel="noopener ugc nofollow" target="_blank">函数</a>来定制(也支持<a class="ae ky" href="https://data-driven-forms.org/renderer/validators#asyncvalidator" rel="noopener ugc nofollow" target="_blank">异步函数</a>))或者使用<code class="fe ne nf ng mv b"><a class="ae ky" href="https://data-driven-forms.org/renderer/validators#customvalidatormapper" rel="noopener ugc nofollow" target="_blank">validatorMapper</a></code>来定义自定义类型。然后，可以在基于字符串的对象中使用这些自定义类型。</p><p id="b961" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe ne nf ng mv b"><a class="ae ky" href="https://data-driven-forms.org/renderer/validators#requiredvalidator" rel="noopener ugc nofollow" target="_blank"><strong class="kb io">required</strong></a></code> <a class="ae ky" href="https://data-driven-forms.org/renderer/validators#requiredvalidator" rel="noopener ugc nofollow" target="_blank">验证器</a>是库实现的验证器之一，我们可以马上使用。(我们可以向字段添加另一个属性:<strong class="kb io"> isRequired，</strong>一个布尔值，它向字段追加一个必需的标记。然而，在我们的表单中，所有的输入都是必需的，所以最好在表单的开头加上一条注释。我们以后再做。)</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/685a340353c162e460a7a8ce692dfa0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*GuiFh7SMmIOv3aVBpSsrPA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The difference between <strong class="bd ni">isRequired</strong>. (Material UI design)</figcaption></figure><ul class=""><li id="10a0" class="mc md in kb b kc kd kg kh kk me ko mf ks mg kw mh mi mj mk bi translated"><strong class="kb io">邮件</strong></li></ul><p id="0445" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以使用前一段中获得的知识为电子邮件编写相同的对象，但电子邮件有一个额外的格式限制。我们将使用<code class="fe ne nf ng mv b"><a class="ae ky" href="https://data-driven-forms.org/renderer/validators#patternvalidators" rel="noopener ugc nofollow" target="_blank"><strong class="kb io">pattern</strong></a></code> <a class="ae ky" href="https://data-driven-forms.org/renderer/validators#patternvalidators" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> </strong> v </a>验证类型来执行它。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a570" class="mz la in mv b gy na nb l nc nd">{<br/>  name: 'email',<br/>  component: 'text-field',<br/>  label: 'Email',<br/>  validate: [{ <br/>    type: 'required' <br/>  } ,<strong class="mv io">{<br/>    type: 'pattern',<br/>    pattern: '[a-z0-9._%+-]+@[a-z0-9.-]+.[a-z]{2,}$',<br/>    message: 'Not valid email'<br/>  }</strong>],<br/>}</span></pre><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/985e2e15b7f6fd4808c4b6b289b5766d.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*jYPuUZ6rJs0E8VBlMODwqA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd ni">Validation</strong> triggered on the email field. (Semantic UI design)</figcaption></figure><ul class=""><li id="dd20" class="mc md in kb b kc kd kg kh kk me ko mf ks mg kw mh mi mj mk bi translated"><strong class="kb io">密码</strong></li></ul><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c2bb" class="mz la in mv b gy na nb l nc nd">{<br/>  name: 'password',<br/>  component: 'text-field',<br/>  label: 'Password',<br/>  validate: [{<br/>    type: 'required'<br/>   }, <strong class="mv io">{<br/>    type: 'min-length',<br/>    threshold: 6,<br/>   }],<br/>  type: 'password',<br/>  helperText: 'Password has to be at least 6 chars long'<br/></strong>}</span></pre><p id="42a2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用了一个新的验证器类型:<code class="fe ne nf ng mv b">min-length</code>确保值的长度为6或更长。<code class="fe ne nf ng mv b">type: ‘password'</code>是标准的HTML输入元素类型，将值显示为点。<code class="fe ne nf ng mv b">helperText</code>向字段呈现附加信息，其位置和外观取决于所使用的设计库。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0845e8d5e533f5251118c05ede145c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*m7nK78EVMkRqOhE5RnglOg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The password field with <strong class="bd ni">helperText</strong> and <strong class="bd ni">password</strong> <strong class="bd ni">type</strong>. (BlueprintJS design)</figcaption></figure><ul class=""><li id="dce7" class="mc md in kb b kc kd kg kh kk me ko mf ks mg kw mh mi mj mk bi translated"><strong class="kb io">确认密码</strong></li></ul><p id="1a64" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们在这里做一个扭曲:有一个要求，只有当用户在上面的字段中输入一些密码时，密码确认字段才会出现。从UX的角度来看，这没有多大意义，但是它很好地展示了数据驱动表单的另一个特性:<a class="ae ky" href="https://data-driven-forms.org/renderer/condition" rel="noopener ugc nofollow" target="_blank">条件字段</a>。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="79e3" class="mz la in mv b gy na nb l nc nd">{<br/>  name: 'confirm-password',<br/>  component: 'text-field',<br/>  type: 'password',<br/>  validate: [{type: 'required'}],<br/>  label: 'Confirm your password',<br/>  <strong class="mv io">condition: {when: 'password', isNotEmpty: true}</strong><br/>}</span></pre><p id="5826" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">数据驱动表单提供了几种类型的条件——其中之一是<code class="fe ne nf ng mv b"><a class="ae ky" href="https://data-driven-forms.org/renderer/condition#isnotempty" rel="noopener ugc nofollow" target="_blank">isNotEmpty</a></code>。使用这种类型，我们可以确保用户必须首先输入密码。DDF还允许嵌套条件(<em class="kx"> AND，OR，NOT </em>)，因此所有的组合都是可能的。</p><p id="df98" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，我们仍然缺少检查确认是否与密码相同。如前所述，我们可以通过在validate数组中提供一个函数或者在<code class="fe ne nf ng mv b">validatorMapper</code>中添加一个自定义类型来实现。我们将使用第二个选项，因为我们需要访问所有值:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="38ac" class="mz la in mv b gy na nb l nc nd"><strong class="mv io">const validatorMapper = { <br/>   'same-password': () =&gt; (value, allValues) =&gt; value !== allValues.password ? 'Password do not match' : undefined<br/>}</strong></span></pre><p id="c2a9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意，验证器是一个返回函数的函数(<em class="kx">高阶函数</em>)。)这个构造允许缓存结果或传递来自模式的附加参数。我们稍后将使用这个对象作为道具。现在，我们可以在验证数组中使用这种类型:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7834" class="mz la in mv b gy na nb l nc nd">...<br/>validate: [<strong class="mv io">{type: 'same-password'}</strong>]<br/>...</span></pre><p id="3ef6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，我们可以删除必需的验证器，因为它已经在初始密码字段中被选中。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/569e04c32bb8a7d7a79b339d85b01187.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/1*w7D9vLQlgzU_ia7siU0nfQ.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd ni">Cross-field validation</strong> and <strong class="bd ni">conditional field</strong>. (PatternFly 4 design)</figcaption></figure><ul class=""><li id="1597" class="mc md in kb b kc kd kg kh kk me ko mf ks mg kw mh mi mj mk bi translated"><strong class="kb io">条款确认</strong></li></ul><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a40b" class="mz la in mv b gy na nb l nc nd">{<br/>  name: 'terms',<br/>  <strong class="mv io">component: 'checkbox',</strong><br/>  label: 'I agree with our business terms',<br/>  validate: [{type: 'required'}]<br/>}</span></pre><p id="4ae4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">更换组件很简单——只需更换组件字符串<strong class="kb io">。其他的都一样。</strong></p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/6005ff827436c6c301441a6efdfc1b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*rz5ftX8KVaH3s02dYgah-w.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd ni">Checkbox</strong> component. (PatternFly 3 design)</figcaption></figure><h1 id="ce4f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">最终模式</strong></h1><p id="5482" class="pw-post-body-paragraph jz ka in kb b kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw ig bi translated">现在，我们可以通过添加标题和描述将所有字段放在最终模式中:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="52e3" class="mz la in mv b gy na nb l nc nd">const schema = {<br/><strong class="mv io">    title: 'Registration form',<br/>    description: 'All fields are required',</strong><br/>    fields: [{<br/>            name: 'nickname',<br/>            component: 'text-field',<br/>            label: 'Nick name',<br/>            validate: [{<br/>                type: 'required'<br/>            }]<br/>        },<br/>        {<br/>            name: 'email',<br/>            component: 'text-field',<br/>            label: 'Email',<br/>            validate: [{<br/>                    type: 'required'<br/>                },<br/>                {<br/>                    type: 'pattern',<br/>                    pattern: '[a-z0-9._%+-]+@[a-z0-9.-]+.[a-z]{2,}$',<br/>                    message: 'Not valid email'<br/>                }<br/>            ]<br/>        },<br/>        {<br/>            name: 'password',<br/>            component: 'text-field',<br/>            label: 'Password',<br/>            validate: [{<br/>                    type: 'required'<br/>                },<br/>                {<br/>                    type: 'min-length',<br/>                    threshold: 6<br/>                }<br/>            ],<br/>            type: 'password',<br/>            helperText: 'Password has to be at least 6 chars long'<br/>        },<br/>        {<br/>            name: 'confirm-password',<br/>            component: 'text-field',<br/>            type: 'password',<br/>            validate: [{type: 'same-password'}],<br/>            label: 'Confirm your password',<br/>            condition: {<br/>                when: 'password',<br/>                isNotEmpty: true<br/>            }<br/>        },<br/>        {<br/>            name: 'terms',<br/>            component: 'checkbox',<br/>            label: 'I agree with our business terms',<br/>            validate: [{<br/>                type: 'required'<br/>            }]<br/>        }<br/>    ]<br/>};</span></pre><blockquote class="nm nn no"><p id="d931" class="jz ka kx kb b kc kd ke kf kg kh ki kj np kl km kn nq kp kq kr nr kt ku kv kw ig bi translated"><strong class="kb io">在短短的几分钟内，我们已经编写了一个具有许多高级特性的全功能、人类可读的表单。</strong></p></blockquote><p id="b60d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，让我们在React项目中实现它。</p><h1 id="cadb" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">数据驱动表单的使用</h1><p id="ee6c" class="pw-post-body-paragraph jz ka in kb b kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw ig bi translated">我们要做的第一件事就是安装<a class="ae ky" href="https://www.npmjs.com/package/@data-driven-forms/react-form-renderer" rel="noopener ugc nofollow" target="_blank"><strong class="kb io">r</strong></a><strong class="kb io">eact-form-renderer:</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="034f" class="mz la in mv b gy na nb l nc nd">npm install --save @data-driven-forms/react-form-renderer</span></pre><p id="70b7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">或者</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3cd3" class="mz la in mv b gy na nb l nc nd">yarn add @data-driven-forms/react-form-renderer</span></pre><p id="29f4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是数据驱动表单库的核心。渲染器是负责将模式转换成React组件的组件，它提供了我们在本文中提到的所有特性。</p><p id="72e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">安装后，我们可以将它导入到我们的项目中:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="edfa" class="mz la in mv b gy na nb l nc nd">import React from 'react';<br/><strong class="mv io">import FormRenderer from '@data-driven-forms/react-form-renderer';</strong></span><span id="6a72" class="mz la in mv b gy ns nb l nc nd"><em class="kx">// if you want to treeshake the component<br/>// import FormRenderer from '@data-driven-forms/react-form-renderer/dist/cjs/form-renderer';</em></span><span id="ab50" class="mz la in mv b gy ns nb l nc nd">const schema = { ... }; <em class="kx">// defined earlier<br/></em>const validatorMapper = { ... }; <em class="kx">// defined earlier, not required</em> </span><span id="5458" class="mz la in mv b gy ns nb l nc nd">const App = () =&gt; {<br/> return(<br/><strong class="mv io">    &lt;FormRenderer <br/>      schema={schema}<br/>      onSubmit={(values, formApi) =&gt; console.log(values)}<br/>      FormTemplate={FormTemplate}<br/>      componentMapper={componentMapper}<br/>      </strong>validatorMapper={validatorMapper} <em class="kx">// not required</em><strong class="mv io"><br/>   /&gt;</strong><br/> )<br/>};</span></pre><p id="36c8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> onSubmit </strong>是一个提交函数。通常，它是一个向API端点发出请求的函数。<strong class="kb io">模式</strong>是我们在前一章中创建的对象。但是仍然缺少两个道具:<strong class="kb io"> FormTemplate </strong>和<strong class="kb io"> componentMapper </strong>。这就是本文的要点:这两个属性定义了表单使用的组件。<a class="ae ky" href="https://data-driven-forms.org/renderer/component-mapping" rel="noopener ugc nofollow" target="_blank"><strong class="kb io">component mapper</strong></a><strong class="kb io"/>包括我们在模式中使用的组件:<em class="kx">文本字段</em>、<em class="kx">复选框</em>等。<a class="ae ky" href="https://data-driven-forms.org/renderer/form-template" rel="noopener ugc nofollow" target="_blank"><strong class="kb io">form template</strong></a><strong class="kb io"/>包装表单，呈现按钮，显示标题。</p><p id="a3dc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以实现自己的组件和模板，但数据驱动表单提供了多个准备好的库:</p><ul class=""><li id="d8f3" class="mc md in kb b kc kd kg kh kk me ko mf ks mg kw mh mi mj mk bi translated"><a class="ae ky" href="https://data-driven-forms.org/mappers/mui-component-mapper" rel="noopener ugc nofollow" target="_blank">物料UI </a></li><li id="88f9" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated"><a class="ae ky" href="https://data-driven-forms.org/mappers/blueprint-component-mapper" rel="noopener ugc nofollow" target="_blank">蓝图</a></li><li id="43e1" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated"><a class="ae ky" href="https://data-driven-forms.org/mappers/suir-component-mapper" rel="noopener ugc nofollow" target="_blank">语义UI反应</a></li><li id="944b" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated"><a class="ae ky" href="https://data-driven-forms.org/mappers/pf3-component-mapper" rel="noopener ugc nofollow" target="_blank">模式3 </a></li><li id="dd04" class="mc md in kb b kc ml kg mm kk mn ko mo ks mp kw mh mi mj mk bi translated"><a class="ae ky" href="https://data-driven-forms.org/mappers/pf4-component-mapper" rel="noopener ugc nofollow" target="_blank"> PatternFly 4 </a></li></ul><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/d8008bdbf7aac89ac120e83cf85bed53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0Z0pkKN906OnA1GAsgXnA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Available Data Driven Forms mappers libraries.</figcaption></figure><p id="4db4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们称这些库为“<strong class="kb io">映射器</strong>”，因为它们<strong class="kb io">将</strong>数据驱动表单属性和特征映射到库的道具。例如，模式中的<code class="fe ne nf ng mv b">label</code>属性被映射到<code class="fe ne nf ng mv b">FormLabel</code>材质UI组件。</p><p id="3ced" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些地图绘制器的使用非常简单。安装它们，导入它们并在渲染器组件中使用它们。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1fee" class="mz la in mv b gy na nb l nc nd">import React from 'react';<br/>import FormRenderer from '@data-driven-forms/react-form-renderer';</span><span id="b953" class="mz la in mv b gy ns nb l nc nd"><strong class="mv io">import { FormTemplate, componentMapper } from '@data-driven-forms/mui-component-mapper';</strong></span><span id="f729" class="mz la in mv b gy ns nb l nc nd"><em class="kx">// you can also treeshake whatever component you need<br/>// import FormTemplate from '@data-driven-forms/mui-component-mapper/dist/cjs/form-template';<br/>// import TextField from '@data-driven-forms/mui-component-mapper/dist/cjs/text-field';<br/>// import Checkbox from '@data-driven-forms/mui-component-mapper/dist/cjs/checkbox';<br/>// const componentMapper = { 'text-field': TextField, checkbox: Checkbox }</em></span><span id="fe6f" class="mz la in mv b gy ns nb l nc nd">const schema = { ... }; <em class="kx">// defined earlier<br/></em>const validatorMapper = { ... }; <em class="kx">// defined earlier</em></span><span id="8e7b" class="mz la in mv b gy ns nb l nc nd">const App = () =&gt; {<br/> return(<br/>    &lt;FormRenderer <br/>      schema={schema}<br/>      onSubmit={(values, formApi) =&gt; console.log(values)}<br/><strong class="mv io">      FormTemplate={FormTemplate}<br/>      componentMapper={componentMapper}<br/></strong>      validatorMapper={validatorMapper}<strong class="mv io"><br/></strong>    /&gt;<br/> )<br/>};</span></pre><blockquote class="nm nn no"><p id="9744" class="jz ka kx kb b kc kd ke kf kg kh ki kj np kl km kn nq kp kq kr nr kt ku kv kw ig bi translated"><strong class="kb io">因为所有mappers的API都是一样的，所以我们可以在它们之间快速切换，选择一个我们最喜欢的。</strong></p></blockquote><p id="2199" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，<strong class="kb io">我们仍然必须单独安装组件库和它们的样式</strong>。数据驱动表单文档页面提供了指向每个库的安装指南的链接，或者您可以使用下面的示例作为起点。请注意，有些库会覆盖全局样式，因此请确保一次只包含其中一个样式。</p><h2 id="8af5" class="mz la in bd lb nu nv dn lf nw nx dp lj kk ny nz ln ko oa ob lr ks oc od lv oe bi translated">材料用户界面表单</h2><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b65d2ab7eafcf1bef2d52481ecc5aa18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*c7Z2bGAFI1jESirWRSwy1A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Material UI form.</figcaption></figure><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="752e" class="mz la in bd lb nu nv dn lf nw nx dp lj kk ny nz ln ko oa ob lr ks oc od lv oe bi translated">蓝图表单</h2><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c63de1610d5664407b5cb4b41bedb216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*E5m9vjxAR3AtP9SQM3CsYw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">BlueprintJS form.</figcaption></figure><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="4dc1" class="mz la in bd lb nu nv dn lf nw nx dp lj kk ny nz ln ko oa ob lr ks oc od lv oe bi translated">语义用户界面表单</h2><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/481cde082c9c4b61026bbeb998a8d7a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*eV1lH0CjKLwNMnbZR_xkIg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Semantic UI form.</figcaption></figure><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="407b" class="mz la in bd lb nu nv dn lf nw nx dp lj kk ny nz ln ko oa ob lr ks oc od lv oe bi translated">模式4表格</h2><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/db9e6a1d09211e32f377195ac0404dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*S7msByYdcgMq23TVn0x16A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">PatternFly 4 form.</figcaption></figure><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="eb2b" class="mz la in bd lb nu nv dn lf nw nx dp lj kk ny nz ln ko oa ob lr ks oc od lv oe bi translated">模式3表单</h2><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/41c98584ff9e326153d45173c4baf5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Bjxklo5C-ZMUrH_Z1nNvQQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">PatternFly 3 form.</figcaption></figure><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="og oh l"/></div></figure><h1 id="43e3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="ab7e" class="pw-post-body-paragraph jz ka in kb b kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw ig bi translated">使用数据驱动表单，我们编写了定义表单模式的公共代码，其他一切都由库提供。我们可以运行所有这些项目，看看这些库之间有什么不同。所有这些表单都是功能齐全的，所以在原型制作期间，我们可以对整个表单进行编码，并在需要时随时切换设计库。</p><p id="bc86" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，定制表单的每个部分也很简单——如果您不喜欢标题或按钮，只需在FormTemplate中切换它们。或者您可以替换整个组件，添加您自定义的组件，等等。</p><p id="b9ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">此外，还有更复杂的组件，如<a class="ae ky" href="https://data-driven-forms.org/component-example/wizard" rel="noopener ugc nofollow" target="_blank">向导</a>或<a class="ae ky" href="https://data-driven-forms.org/component-example/select" rel="noopener ugc nofollow" target="_blank">选择</a>——从头编写它们可能需要几个小时，在数据驱动表单中使用它们就像使用<em class="kx">文本字段</em>一样简单。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi om"><img src="../Images/387ff19730fb752ce54b2860ad24eee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LXCEAwj7QKKNPXgAAlI2SQ.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A <a class="ae ky" href="https://data-driven-forms.org/component-example/dual-list-select" rel="noopener ugc nofollow" target="_blank">dual list select</a> component provided by Data Driven Forms. (Material UI design)</figcaption></figure><p id="3548" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你想使用不同的或定制的组件/设计库，数据驱动表单提供了一个简单的命令行<a class="ae ky" href="https://data-driven-forms.org/renderer/development-setup#generatingamappertemplate" rel="noopener ugc nofollow" target="_blank">来生成整个包的结构，它甚至可以添加TypeScript定义。只需在</a><a class="ae ky" href="https://github.com/data-driven-forms/react-forms" rel="noopener ugc nofollow" target="_blank"> DDF库</a>的根文件夹中运行<code class="fe ne nf ng mv b">yarn generate-template</code>，交互式CLI将会引导您。下一次，我们将看看这个命令，并作出自定义映射。</p><p id="73d2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"><em class="kx"/></strong><a class="ae ky" href="https://data-driven-forms.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="kx">数据驱动表单</em> </strong> </a> <strong class="kb io"> <em class="kx">项目完全基于</em></strong><a class="ae ky" href="https://github.com/data-driven-forms/react-forms" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="kx">git hub</em></strong></a><strong class="kb io"><em class="kx">。如果你觉得这个项目有趣，请加入我们的社区。我们对所有的贡献都持开放态度，我们深深感激我们得到的每一颗星星。还有一个官方推特账号</em></strong><a class="ae ky" href="https://twitter.com/DataDrivenForms" rel="noopener ugc nofollow" target="_blank"><strong class="kb io"><em class="kx">@ data drive infoms</em></strong></a><strong class="kb io"><em class="kx">你可以跟着得到所有的最新消息。</em> </strong></p><h2 id="756d" class="mz la in bd lb nu nv dn lf nw nx dp lj kk ny nz ln ko oa ob lr ks oc od lv oe bi translated">简单英语中的JavaScript</h2><p id="7550" class="pw-post-body-paragraph jz ka in kb b kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw ig bi translated">你知道我们有四种出版物吗？通过<a class="ae ky" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">找到它们吧。简单来说</strong></a>——关注我们的出版物并订阅我们的YouTube频道  <strong class="kb io">来表达爱意吧！</strong></p></div></div>    
</body>
</html>