<html>
<head>
<title>Refactoring React-Native UI using styled-components and pure component patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用样式化组件和纯组件模式重构React-Native UI</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/refactoring-react-native-ui-using-styled-components-and-pure-component-patterns-144b93476eb6?source=collection_archive---------0-----------------------#2019-06-11">https://javascript.plainenglish.io/refactoring-react-native-ui-using-styled-components-and-pure-component-patterns-144b93476eb6?source=collection_archive---------0-----------------------#2019-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/89ab83d752ce3b27437b533e352f8dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*QUMD86ogcdS4UO3dO0CSPg.jpeg"/></div></figure><p id="2257" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最近，我发现styled-components是一个令人兴奋的附加物，它有助于将显示逻辑从业务逻辑中分离出来，同时改进每个组件中的整体声明性组合</p><figure class="kq kr ks kt gt jo"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="bcc9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kw">*作为一组声明而非一组详细说明出现，如本文所述</em></p><h2 id="56a4" class="kx ky in bd kz la lb dn lc ld le dp lf kc lg lh li kg lj lk ll kk lm ln lo lp bi translated">重构前:</h2><p id="cc56" class="pw-post-body-paragraph jr js in jt b ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko ig bi translated">让我们看一个react-native组件的例子，它是使用可用的react-native组件(如视图、文本和样式定义的样式表)定义的。</p><p id="25f5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在重新分类之前，我们注意到组件1。使用React类定义PageIntro组件。2.混合业务逻辑、显示逻辑(额外的样式推送)和3 . react-native组件集的返回，并向其传递样式引用(<em class="kw"> style={style.container} </em>)。4.样式引用是在组件外部使用react-native样式表定义的，但是在同一个文件中。总而言之，一个大文件要做几件事:</p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lv"><img src="../Images/472a42de5108e16d15a9091eda0da433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lsxRq1x6QnIjXyak4lWMQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Before refactoring the react-native component</figcaption></figure><h2 id="9a90" class="kx ky in bd kz la lb dn lc ld le dp lf kc lg lh li kg lj lk ll kk lm ln lo lp bi translated">将砾岩分为两部分:</h2><p id="746e" class="pw-post-body-paragraph jr js in jt b ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko ig bi translated">每个react-native组件都可以拆分并定义为两个部分的组件:</p><p id="db83" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">第一部分是类似jsx的— <em class="kw">纯组件</em>(或功能组件)，第二部分是类似css的— <em class="kw">样式化组件(类似CSS)</em></p><p id="45eb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这个例子中，我们将样式化组件和纯组件放在不同的目录中。我们将“UI”目录设置为保存所有的表示(纯)组件，将“Styled”目录设置为包含Styled-components——前缀为Styled <compname>。js。</compname></p><p id="2bbc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于UI目录中的<strong class="jt io"> PageIntro.js </strong>组件，它在样式化目录中有对应的<strong class="jt io"> StyledIntro.js </strong>:</p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi me"><img src="../Images/75d02c402e22039204e6a08c239a462b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PgKZMmpDy86Odj421_x__A.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">project directory holds presentational components in<strong class="bd mf"> UI</strong> directory and styled components in<strong class="bd mf"> Styled</strong> directory</figcaption></figure><p id="5b59" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先让我们安装样式组件:</p><p id="f084" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kw"> npm安装样式化组件</em></p><p id="940e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">或者</p><p id="6e06" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kw">纱线添加样式-组件</em></p><p id="e92b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">接下来，我们<a class="ae kp" href="https://medium.com/swlh/using-styled-components-with-react-native-de645fcf4787" rel="noopener">为react-native组件定义styled-comp</a>:</p><p id="05f9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">StyledIntro.js将保存样式化组件的定义</p><p id="6f45" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">—在StyledIntro.js中，我们导入“样式组件”模块，并</p><p id="83f1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">—使用<em class="kw">样式。视图，风格化。Text </em>定义react-native视图和文本组件的外观。</p><p id="3b31" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">—为任何css属性和显示逻辑的处理设置常数(见下面的两张图片)</p><p id="a8e5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在下面的例子中，你会看到<em class="kw">容器</em>、<em class="kw">样式布局*、</em>、【样式标题*】和其他<em class="kw">页面介绍. js </em>需要显示的视图和文本的定义。</p><p id="b9df" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="kw">*为便于阅读，习惯在样式化组件前加上“styled”前缀</em></p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mg"><img src="../Images/3d4a34b0fee70e9993bfb1f60c527915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rl3outPDpHcZlQcxPHlHg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">styled-components inside StyledIntro for later import into PageIntro.js component</figcaption></figure><h2 id="de5c" class="kx ky in bd kz la lb dn lc ld le dp lf kc lg lh li kg lj lk ll kk lm ln lo lp bi translated"><strong class="ak">显示完全在样式化组件内处理的逻辑:</strong></h2><p id="fd17" class="pw-post-body-paragraph jr js in jt b ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko ig bi translated">所有由props通知的显示逻辑(例如本例中的type)都可以在styled-components内部进行本地评估:评估基于type prop的按钮角的圆度，并将其设置为<em class="kw"> StyledIntro.js、</em>容器<em class="kw">styled-comp内部的border-radius。</em></p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mh"><img src="../Images/306003f6bfe8899cae8c6bf8a82c4615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IIVwhUaGKqccaTvgJZmzQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">moving all the display-related logic to styled-component definition</figcaption></figure><h2 id="aa6b" class="kx ky in bd kz la lb dn lc ld le dp lf kc lg lh li kg lj lk ll kk lm ln lo lp bi translated">重构后:</h2><p id="762a" class="pw-post-body-paragraph jr js in jt b ju lq jw jx jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko ig bi translated">迄今为止，我们已经:</p><ol class=""><li id="9654" class="mi mj in jt b ju jv jy jz kc mk kg ml kk mm ko mn mo mp mq bi translated">切换到纯组件模式，而不是React类模式</li><li id="3b1b" class="mi mj in jt b ju mr jy ms kc mt kg mu kk mv ko mn mo mp mq bi translated">单独定义显示逻辑(在styled-comp文件中),而不是在pure comp中本地定义。</li><li id="e1d7" class="mi mj in jt b ju mr jy ms kc mt kg mu kk mv ko mn mo mp mq bi translated">我们定义了导入的样式组合，而不是反应原生的</li><li id="ef17" class="mi mj in jt b ju mr jy ms kc mt kg mu kk mv ko mn mo mp mq bi translated">保持组件组合主要是声明性的，而不是命令性的</li></ol><p id="3430" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">且看结果！🤩</p><figure class="kq kr ks kt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mw"><img src="../Images/943d099317defc31f78edded8da8a0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UH_9nG2jGVisjVJIvXASIA.png"/></div></div></figure><p id="36a4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">比较同一个comp的前后效果会更加明显:</p><div class="kq kr ks kt gt ab cb"><figure class="mx jo my mz na nb nc paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/78df2fb0d7f8f78d31b73ba356996551.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*6lsxRq1x6QnIjXyak4lWMQ.png"/></div></figure><figure class="mx jo nd mz na nb nc paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><img src="../Images/b9aa6d7a89fbef9a422827007f2a0829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*UH_9nG2jGVisjVJIvXASIA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk ne di nf ng">BEFORE and AFTER</figcaption></figure></div><p id="196c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我现在爱读组件。这是简洁和舒适的大小。可读性强，易于扩展。希望是有用的！</p></div></div>    
</body>
</html>