<html>
<head>
<title>Asynchronous JavaScript and the Execution Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript和执行堆栈</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-synchronous-async-single-threaded-execution-context-browser-apis-256d906b186d?source=collection_archive---------5-----------------------#2020-10-09">https://javascript.plainenglish.io/what-is-synchronous-async-single-threaded-execution-context-browser-apis-256d906b186d?source=collection_archive---------5-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b2df63ec84608d236adc9817cf92a0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvWUyiaOF-TGPjObNz7jOA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nateggrant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nate Grant</a> on <a class="ae kc" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="da46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> JavaScript是单线程同步语言</em>。这意味着运行时间长的函数会导致页面没有响应。</p><p id="d503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开您的开发工具，跟随我的步骤，我们将演示这一点。让我们写一个名为‘hang’的函数。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="4562" class="ll lm iq lh b gy ln lo l lp lq">function hang(secs){<br/>const doneAt = Date.now() + (secs * 1000)<br/>while( doneAt &gt; Date.now ) {// just do nothing }}</span><span id="4098" class="ll lm iq lh b gy lr lo l lp lq">hang(50)</span></pre><p id="0aa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们调用挂起函数时，我们将被阻塞50秒。<strong class="kf ir">趁着这50秒；</strong>它只是通过while循环，并锁定整个页面。</p><p id="4140" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为JavaScript是单线程和同步的。<strong class="kf ir">然而，JavaScript有异步运行的函数。</strong></p><p id="a83e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们来解释一下JavaScript的一般结构。</p><h2 id="bd8b" class="ll lm iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">执行堆栈</h2><p id="7d7f" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">所以让我们用一种简单的方式来思考这个问题。<strong class="kf ir">执行栈是</strong>你把你的程序一个接一个的放上去，然后从下往上运行。当你完成这些作品时，从上到下把它们擦掉。</p><p id="1612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是一个盘子，你把饼干一个接一个地放在上面。然后当你吃这些的时候，你从最上面开始吃饼干，然后一个接一个地往下吃(JavaScript也不能同时吃两个饼干)。这正是单线程和同步的含义。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/48a4ecd888261999b9c15d2bb950caa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAOZPL-D6lmzAlq5hqJPbQ.jpeg"/></div></div></figure><h2 id="1898" class="ll lm iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">执行上下文</h2><blockquote class="mp mq mr"><p id="d071" class="kd ke lb kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated"><em class="iq">形象化单词</em> <code class="fe mv mw mx lh b"><em class="iq">Context</em></code> <em class="iq">的最佳方式是，想象一个围绕你感兴趣的主题(或我们正在讨论的“上下文”)的圆圈(或包装)。语境是围绕特定事件、情况等的一系列环境或事实。(此段摘自</em><a class="ae kc" href="http://blog.greenroots.info/" rel="noopener ugc nofollow" target="_blank">blog . greenroots . info</a>)</p></blockquote><p id="4df6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">执行上下文</strong>是JavaScript放在执行堆栈上的部分，帮助JavaScript引擎运行我们的代码。</p><p id="506d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">就像函数/模块允许我们将代码分割成小块，降低实现代码的复杂度一样，</em> <strong class="kf ir"> <em class="lb">执行上下文</em> </strong> <em class="lb">允许JavaScript引擎降低运行代码的复杂度。</em></p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/e212e1269a4f33a32f92f3187eb12c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yq1HXddIdVd0P1JJhl6VyQ.png"/></div></div></figure><p id="5f07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个执行上下文是<strong class="kf ir">“全局执行上下文”</strong>。即使您在一个<code class="fe mv mw mx lh b">.js</code>文件中没有一行代码并运行它，您也会创建全局执行上下文。</p><p id="05dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个全局执行上下文包括两件事:</p><ul class=""><li id="5c7c" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la ne nf ng nh bi translated">一个全局对象(如果在浏览器中运行JavaScript，则为<code class="fe mv mw mx lh b">window</code>，如果在节点环境中运行，则为<code class="fe mv mw mx lh b">global</code>)</li><li id="0aba" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated">引用全局对象的名为<code class="fe mv mw mx lh b">this </code>的变量</li></ul><blockquote class="mp mq mr"><p id="047d" class="kd ke lb kf b kg kh ki kj kk kl km kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated"><em class="iq">在JavaScript中，</em><strong class="kf ir">T5】一个函数之外的一切都是全局的。 </strong></p></blockquote><h2 id="46cd" class="ll lm iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">全局对象</h2><p id="3316" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">所有的变量，所有的函数实际上都是全局对象上的键，参数或者方法。在您的控制台上实际尝试一下，调用窗口对象，并查看其中的全局参数。</p><p id="0d14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果你试图声明一个变量；</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="067c" class="ll lm iq lh b gy ln lo l lp lq">var x = 8;</span><span id="47e6" class="ll lm iq lh b gy lr lo l lp lq">x  // outputs 8</span><span id="8871" class="ll lm iq lh b gy lr lo l lp lq">window.x // outputs 8 // same thing</span></pre><p id="fe73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当你声明一个变量时，它会自动进入窗口对象。所以你声明的每个变量都是窗口对象的一部分。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="de7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍后，如上图所示，函数执行上下文从代码的顶部添加到堆栈中。函数执行上下文与global非常相似，但是很明显，它不创建全局对象，而是创建作为参数传递给函数的变量。</p><p id="5a83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以使用可视化工具有助于更好地理解这个过程。我不会详细说明这一点，但认为它是；</p><p id="47a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">全局执行上下文</strong> → <em class="lb">你把你的函数放在堆栈里(像cookies一样)</em>—<strong class="kf ir">first function _ you _ invoked _ in _ the _ code()</strong>—<em class="lb">当这个fnc返回某个东西时，它从堆栈里被清除</em>→<strong class="kf ir">middle function _ invoked()</strong>—<em class="lb">当这个fnc返回某个东西时，它从堆栈里被清除→</em><strong class="kf ir">last function _ invoked()</strong></p><p id="b777" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们第一次运行代码时会发生什么呢？</p><ol class=""><li id="4e11" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la nu nf ng nh bi translated">将创建一个全局对象。</li><li id="4b00" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la nu nf ng nh bi translated">一个变量称这个引用为那个对象。</li><li id="597d" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la nu nf ng nh bi translated">JavaScript引擎将为该代码中的所有变量和函数保留内存。函数声明将完全放在内存中。</li><li id="edc9" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la nu nf ng nh bi translated">对于每个变量，引擎将设置<code class="fe mv mw mx lh b">undefined</code>的值</li></ol><p id="3832" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四步实际上叫做<strong class="kf ir">吊装</strong>，你可能听说过。这没什么好困惑的。JavaScript实际执行我们的代码之前的第一件事，发生了4个步骤。我们所有的变量都赋给了undefined。如果你想看到一个名为' a '的变量，并且在声明a之前做了<code class="fe mv mw mx lh b">console.log('a: ', a)</code>，你将会因为这个原因得到undefined，(如果你做了let或const你将会得到一个错误)。</p><p id="a39d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了执行堆栈的概念，让我们继续讨论异步JavaScript</p><h2 id="98f6" class="ll lm iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">异步JavaScript</h2><p id="7a1f" class="pw-post-body-paragraph kd ke iq kf b kg mj ki kj kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">问题是:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ebad" class="ll lm iq lh b gy ln lo l lp lq">function printOne() {<br/>  console.log(1)<br/>}</span><span id="0d5d" class="ll lm iq lh b gy lr lo l lp lq">function printTwo() {<br/>  console.log(2)<br/>}</span><span id="e283" class="ll lm iq lh b gy lr lo l lp lq">function printThree() {<br/>  console.log(3)<br/>}</span><span id="64fd" class="ll lm iq lh b gy lr lo l lp lq">setTimeout(printOne, 1000)<br/>setTimeout(printTwo, 0)<br/>printThree()</span></pre><p id="943e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你将以什么样的顺序得到输出？</p><p id="3827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是学习这个概念时很常见的问题。通常，人们可能会回答为2，3，1。但是，输出将是3，2，1。</p><p id="69e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道JavaScript可以一次执行一件事，但是还有三个概念可以理解为什么会这样。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/593ab290700b75e7c804b56333be4e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50_GAoQUeVmZrglZMix3jw.jpeg"/></div></div></figure><ol class=""><li id="5f73" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la nu nf ng nh bi translated"><strong class="kf ir">浏览器API</strong></li></ol><p id="09ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，这些函数不是直接内置在Javascript中，而是可以在浏览器中运行。浏览器有自己的API集，如<strong class="kf ir"> setTimeout </strong>和<strong class="kf ir"> XMLHttpRequests </strong>，这些API在Javascript运行时中没有指定。</p><p id="d1bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> setTimeout </strong>是由浏览器处理的异步函数之一。(因此它不是单线程的，可以一次处理两个或更多的函数), browser负责跟踪秒数，直到函数被执行。</p><p id="cfb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么上面的代码中发生了什么呢？setTimeout(printone)和setTimeout(printtwo)被用于浏览器API，因为浏览器会处理它们。<strong class="kf ir">函数printthree </strong>立即放入堆栈，JavaScript引擎执行它。</p><p id="f7a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以“3”被打印出来。并从堆栈中移除。</p><p id="445f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当堆栈为空时，JavaScript引擎就可以寻找一个<strong class="kf ir">函数队列</strong>，如果有一个要运行的话。</p><ol class=""><li id="9a0b" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la nu nf ng nh bi translated"><strong class="kf ir">功能队列</strong></li></ol><p id="4fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在浏览器会说，已经过了0秒了，是时候把printtwo函数放入函数队列了。我会记录printone函数的秒数。当它准备好了，我也会把它放到函数队列中。所以我们看到，函数队列只是一行，<em class="lb">为API函数队列</em>。</p><p id="8fa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当堆栈清空后，JavaScript引擎会进入函数队列，说，好的，给我队列中的第一个函数，我会把它放入堆栈并执行它。</p><p id="e0bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以“2”被打印出来，从堆栈中移除。1秒钟后,“1”被打印出来，并从堆栈中删除。</p><p id="aca6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您不需要担心这个过程，因为<strong class="kf ir">事件循环</strong>会处理它。</p><p id="4ee7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3。事件循环</strong></p><p id="8625" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">事件循环</strong>在不断检查，如果栈上有东西，就先执行。</p><p id="c610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦堆栈清空，事件循环将队列中的第一个函数放入堆栈(如果有的话)。并将其从队列中删除。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="8860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，理解JavaScript是<strong class="kf ir">同步的</strong>是非常重要的，它会一个接一个地执行堆栈，除非它是空的。当它为空时，事件循环将查找函数队列并逐个执行它们。我这样说是因为当你在学习回调，承诺，这个JavaScript中的关键词时，你会理解它背后的结构，会容易很多。</p><p id="aa41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，这个关键词有一个定义，希望在这篇文章<strong class="kf ir">之后它会有意义。<em class="lb">这个</em> </strong> <em class="lb">关键字指的是在创建新的执行上下文时设置的对象。(函数调用)在全局执行上下文中，这是指全局对象。如果函数作为对象的方法调用，“this”将绑定到调用该方法的对象。</em></p><p id="b557" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>