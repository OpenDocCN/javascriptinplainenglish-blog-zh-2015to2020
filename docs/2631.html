<html>
<head>
<title>The world's most gentle introduction into Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">世界上最温和的函数式编程介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-worlds-most-gentle-introduction-into-functional-programming-930395a00b6f?source=collection_archive---------10-----------------------#2020-07-10">https://javascript.plainenglish.io/the-worlds-most-gentle-introduction-into-functional-programming-930395a00b6f?source=collection_archive---------10-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="io ip gp gr iq ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/6f7905d057b244befd47ffdebf74a7d0.png" data-original-src="https://miro.medium.com/v2/0*lyd-gqjc1CDa93fY"/></div></figure><div class=""/><p id="96a0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您第一次涉足函数式编程可能会让人感到<strong class="jw iy">谦卑</strong>。如果您熟悉面向对象编程或任何类似的衍生工具，那么研究不同的范例需要重新思考，并放松到基础概念。</p><p id="8c86" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">挑战是意料之中的。我们从事的行业需要坚持学习的艺术。</p><p id="4907" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在今天的帖子中，我将尝试通过实现两个常见的实用函数<strong class="jw iy"> pipe </strong>和<strong class="jw iy"> compose </strong>来<em class="ks">让你</em>慢慢了解一些核心的函数式编程概念。</p><p id="6cae" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章除了理解JavaScript和基本算术之外没有其他要求，但是建议你理解<code class="fe kt ku kv kw b">reduce</code>是如何工作的。</p><h2 id="9556" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">单子还是不单子</h2><p id="151f" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这就是问题所在。</p><p id="7f93" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在是时候提及因道格拉斯·克洛克福特而声名狼藉的莫纳德格林夫人的诅咒了:</p><blockquote class="lv lw lx"><p id="d163" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated"><em class="ix">“一旦你理解了单子，你马上就无法向任何人解释它们了”</em></p></blockquote><p id="4a42" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可能知道也可能不知道单子。我将留意诅咒的话语，并在开始之前声明我们不会在这篇文章中谈论单子。</p><p id="217a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是另一个时间的帖子，但是我要说的关于它们(以及所有其他古怪的函数式编程术语)是这样的:它们被恰当地命名是因为它们源于数学和<a class="ae mb" href="https://plato.stanford.edu/entries/set-theory/" rel="noopener ugc nofollow" target="_blank">集合论</a>，并且通过构建核心基础，你会自然地理解它们。</p><p id="1d9e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那里。我说了。没有疯狂的概念。没有单子，没有贝塔归约，没有阿尔法等价。就目前而言，它们都是流行语。让我们开始讨论基本问题。</p><h2 id="f6da" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">我们的初恋</h2><p id="1f3c" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">让我们回到小学数学，讲讲<strong class="jw iy">加法的故事。</strong></p><p id="af4b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们知道<code class="fe kt ku kv kw b">1 + 2 + 3 = 1 + 2 + 3</code>的左侧和右侧是等价的。</p><p id="f74e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，我们可以进一步简化右侧，通过添加右侧的<code class="fe kt ku kv kw b">1 + 2</code>来表示<code class="fe kt ku kv kw b">1 + 2 + 3 = 3 + 3</code>。</p><p id="822e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们不需要添加<code class="fe kt ku kv kw b">1 + 2</code>，我们也可以从右边添加<code class="fe kt ku kv kw b">2 + 3</code>来代替<code class="fe kt ku kv kw b">1 + 2 + 3 = 1 + 5</code>。我们可以把这个简化为<code class="fe kt ku kv kw b">1 + 2 + 3 = 6</code>。</p><p id="9c60" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">到目前为止，我们还没有任何新的突破。这些都是常识，事实上，我们可能会跳过我提到的中间阶段，直接简化为答案6。你有没有停止思考<em class="ks">为什么</em>会是这样？</p><h2 id="2cde" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">浅谈函数式编程的性质</h2><p id="509c" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">加法是对函数式编程的一些核心属性的精彩介绍，因为它以一种易于理解的方式展示了它们。</p><p id="f0ea" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">函数式编程有四个重要的特性:</p><ol class=""><li id="831b" class="mc md ix jw b jx jy kb kc kf me kj mf kn mg kr mh mi mj mk bi translated">函数必须是<strong class="jw iy">关联的</strong></li><li id="21b3" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">函数必须是<strong class="jw iy">可交换的</strong></li><li id="fd9e" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">一个函数必须有一个<strong class="jw iy">标识</strong></li><li id="8c6a" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">功能必须是<strong class="jw iy">分布式的</strong></li></ol><p id="24dd" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们用加法示例和语言的<strong class="jw iy">力量来探究这些属性。</strong></p><h2 id="986b" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">联合的</h2><p id="3d4b" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">“去交往”。快速搜索一下“associate”的起源，我们会发现:</p><blockquote class="lv lw lx"><p id="c20a" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated">“……作为动词在‘为了共同的目的而联合’的意义上”</p></blockquote><p id="ae5d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用单词背后的历史和含义可以帮助我们理解它在编程和数学中的应用。令我惊讶的是，这些领域的命名是如此的贴切，我们应该感谢那些在我们之前对细节如此关注的人。</p><p id="79e1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们谈到加法是<strong class="jw iy">关联</strong>时，我们的意思是我们可以用加法运算将变量“分组”和“关联”。</p><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/7296fbd3c080072eb8c40eb802f10449.png" data-original-src="https://miro.medium.com/v2/0*VPot5IVU7Xdho0oQ"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">1a. The Associative Property</figcaption></figure><p id="5de4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们陈述<code class="fe kt ku kv kw b">(x + y) + z = x + (y + z)</code>定律。对于表现出关联属性的函数，这意味着运算的顺序不会改变结果。</p><p id="30f0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看代数可能是认知负荷，但是我们已经在我们进入加法记忆通道的过程中看到了这一点，当时我们这样陈述:</p><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/dd08bdc31ea8dddf5dd23d54941ae14f.png" data-original-src="https://miro.medium.com/v2/0*-0dlTiW1br_ER8UI"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">1b. The Associative Property with integers</figcaption></figure><p id="747b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据我们对数学的了解，我们可以编写一个关联的加法函数:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e76a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">乍一看这个等式，可能会觉得奇怪，但是在左边，我们可以看到<code class="fe kt ku kv kw b">add(add(1, 2), 3)</code>的值等于<code class="fe kt ku kv kw b">add(3, 3)</code>，最后我们得到6。</p><p id="f138" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以在另一边运行类似的逻辑，将我们的答案减少到6。</p><p id="1084" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就算你不熟悉听到<strong class="jw iy">【结合律】</strong>这个名词，你也已经轻车熟路大半辈子了！</p><h2 id="f247" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">交换的</h2><p id="1b1f" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">回到我们术语的起源，<strong class="jw iy">可交换的</strong>来源于“通勤”或“四处走动”。</p><p id="43b2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">源自中世纪晚期英语:</p><blockquote class="lv lw lx"><p id="2f20" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated">"从‘互换’(两件事)的意义上说. "</p></blockquote><p id="94b2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了理解它，我们可以把<code class="fe kt ku kv kw b">1 + 2</code>换成<code class="fe kt ku kv kw b">2 + 1</code>。</p><p id="a3ad" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由此，我们可以推导出<strong class="jw iy">交换律</strong>:</p><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/50152700d08688dcfe995e31dc738ff1.png" data-original-src="https://miro.medium.com/v2/0*ySWawBz8f-mJr8Tk"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">2a. The Commutative Property</figcaption></figure><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/0a3b83f6e12a0b4bb4f43256bb839869.png" data-original-src="https://miro.medium.com/v2/0*17fUZv2fWlffKm2v"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">2b. The Commutative Property with integers</figcaption></figure><p id="b4b8" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用我们前面的<code class="fe kt ku kv kw b">add</code>函数的例子来看看这个结果:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7f15" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简单的像馅饼！当事物是可交换的时，次序对运算来说并不重要。</p><blockquote class="lv lw lx"><p id="f0ca" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated">作者注:我不会做馅饼，所以我不明白这句话。</p></blockquote><p id="783b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">举个<strong class="jw iy">不可交换</strong>的例子，拿<strong class="jw iy">除法</strong>来说。<code class="fe kt ku kv kw b">1 / 2 != 2 / 1</code>。除法是许多函数定律的一个很好的反例。</p><h2 id="1bfb" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">身份</h2><p id="07a0" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">当我们谈到<strong class="jw iy">身份属性</strong>时，我记得那是我们希望某些东西“保持其身份”。</p><p id="cacd" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，你能想出你能给另一个数加上什么使它保持不变吗？如果你说零，那么我称你为算术奇才！</p><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/3d2c1f93500c70d2ab662c2e3891a2d7.png" data-original-src="https://miro.medium.com/v2/0*5Fbr6HDyMrQEi1-e"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">3a. The Identity Property</figcaption></figure><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/58e41f75deb6e8762c55c6b1cf99b094.png" data-original-src="https://miro.medium.com/v2/0*ZwbLE4hYRTGs2FeZ"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">3b. The Identity Property with integers</figcaption></figure><p id="c973" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们知道数学中的任何东西加到零都会产生结果。我们设法“保持”了身份。</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bdd4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">乘法中的恒等性质是什么？了解这一点可以帮助你真正了解这个属性。提示:它不能为零。</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="180c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你说“一”，那么你是一个真正的奇迹制造者！不过，严肃地说，这些琐碎的例子是<strong class="jw iy">奇妙的例子</strong>，可以帮助你记住这些定律，而无需借助谷歌和Stack Overflow(或等价的数学交换工具)。<em class="ks">从了解中知道这一切的感觉真好。</em></p><h2 id="139b" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">分布的</h2><p id="b8f3" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">诚然，<strong class="jw iy">分配属性</strong>比其他属性稍微需要更多的脑力，但是你会完全理解它的作用。</p><p id="c7aa" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">至于定义:</p><blockquote class="lv lw lx"><p id="31e5" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated">(指运算)满足这样一个条件，即当对已经由另一个运算合并的两个或多个量进行运算时，其结果与对每个量分别进行运算，然后将乘积合并时的结果相同</p></blockquote><p id="ed4c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那句话不只是几句话，所以让我们用一种我们能理解的方式来简化它:</p><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/f4682bccdeaa9e957a9ffc902d96c2b2.png" data-original-src="https://miro.medium.com/v2/0*O89v7PjQ6RRjWM4R"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">4a. The Distributive Property</figcaption></figure><p id="813c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">左手边和右手边是等价的，我们把<code class="fe kt ku kv kw b">x</code>抽象出来，然后把<code class="fe kt ku kv kw b">y</code>和<code class="fe kt ku kv kw b">z</code>相乘。</p><figure class="mq mr ms mt gt ir gh gi paragraph-image"><div class="ab gu cl is"><img src="../Images/d880f875db3e38d4500243b943a8004a.png" data-original-src="https://miro.medium.com/v2/0*lzu2PdF8LEOgN-8z"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">4b. The Distributive Property with integers</figcaption></figure><p id="f47f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是根据我们通过运算顺序理解的代数原理得出的。这个属性在函数式编程中变得非常重要，因为它能够重新安排函数。</p><blockquote class="lv lw lx"><p id="81e5" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated">在这篇文章中，我们不会深入探究分配属性的含义。让我们把它留到我们有更多工具的时候。</p></blockquote><p id="e0df" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经了解了四个基本属性，让我们换个话题，开始讨论到目前为止我们一直在使用的<code class="fe kt ku kv kw b">add</code>函数。</p><h2 id="29cb" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">卷曲和不卷曲</h2><p id="5d83" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在编程中，我们从我们的朋友<a class="ae mb" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">维基百科</a>那里得到了以下关于阿谀奉承的定义:</p><blockquote class="lv lw lx"><p id="ce80" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated">“…currying是一种将接受多个参数的函数转换为一系列接受单个参数的函数的技术。”</p></blockquote><p id="94fe" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们之前的<code class="fe kt ku kv kw b">add</code>函数接受了多个参数。目标是让用户将它转换成“一系列函数，每个函数都有一个参数”。</p><p id="855d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这看起来像下面这样:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><blockquote class="lv lw lx"><p id="c619" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated">为了完整起见，反过来把一个函数从<code class="fe kt ku kv kw b">curriedAdd</code>取回到上面<code class="fe kt ku kv kw b">add</code>的形式，就是<strong class="jw iy">解卷积</strong>的过程。</p></blockquote><p id="687c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的样子怪怪的？为什么我们会想写<code class="fe kt ku kv kw b">add(x)(y)</code>？像这样运行curried函数相当于用非curried版本运行<code class="fe kt ku kv kw b">add(x, y)</code>,但是它给了我们强大的能力将<strong class="jw iy">值部分应用于函数，并给了我们一些确定性的强大工具。</strong></p><p id="03cf" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们进入部分应用的力量之前，我认为是时候开始准备我们朝着本教程的目标的最后一次航行了。</p><h2 id="913c" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">设置项目</h2><p id="df42" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">让我们开始一个新项目，开始摆弄这些数字。从项目根目录中，运行:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b5c1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">纱线/NPM <code class="fe kt ku kv kw b">init</code>将生成<code class="fe kt ku kv kw b">package.json</code>文件，所以让我们用一个<code class="fe kt ku kv kw b">test</code>脚本来更新它，以运行Jest测试套件。</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6308" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，在<code class="fe kt ku kv kw b">index.js</code>内部，让我们导出一个<code class="fe kt ku kv kw b">add</code>函数。基于之前对add函数的理解，我们将使用我们的curried版本:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ff28" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，在<code class="fe kt ku kv kw b">index.test.js</code>中，让我们导入那个函数并编写一个简单的测试来检查math仍然是math:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2d8c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从命令行运行<code class="fe kt ku kv kw b">yarn test --watchAll</code>，我们应该进入观察模式进行测试。如果数学仍然是数学，你应该看到类似下面这样的东西:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4def" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">太好了！数学还是数学！</p><p id="8902" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们理解部分应用程序是如何工作的。</p><h2 id="0a26" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">部分应用</h2><p id="d766" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">Currying函数给了我们一次应用一个参数的能力。这给了我们创建确定性的、灵活的函数的能力，这些函数易于测试并且非常有用。</p><p id="55e9" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们创建一些部分应用的函数的小例子，看看它们是如何工作的。</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4b1c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们用的是部分应用的思路，分别应用200万，1000万，1000万。这锁定了一个事实，即如果我们使用<code class="fe kt ku kv kw b">addTwo</code>函数名来添加剩余的参数，那么<strong class="jw iy">总是确定性地将2添加到参数中。</strong></p><p id="8b29" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我再说一遍。</p><p id="e24a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们使用<code class="fe kt ku kv kw b">addTwo</code>函数名来添加剩余的参数，那么<strong class="jw iy">总是确定性地将2添加到参数中。</strong>这是部分应用概念的<strong class="jw iy">关键要点</strong>。</p><p id="c1b1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们再次更新我们在<code class="fe kt ku kv kw b">index.test.js</code>中的测试套件:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="240a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在新的三个测试中，我们设置了一些任意的数字来检查这些函数是否按预期运行。</p><p id="d5a5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">酷！<em class="ks">我们已经设法将参数部分应用于返回确定性函数的定制函数，然后我们可以将另一个数应用于该函数。</em> <strong class="jw iy">好拗口。</strong></p><p id="1c5e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这一点上，我不能强调部分应用程序概念对函数式编程的重要性。它可能看起来还不怎么样，但希望我能让你相信它有多棒！</p><p id="9257" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">跟着我，我们在最后冲刺阶段！让我们利用我们所应用的东西，看看事情的力量汇集在一起。</p><h2 id="867c" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">编写自己的管道和合成函数</h2><p id="828c" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">既然我们已经处理了我们的<code class="fe kt ku kv kw b">add</code>函数并部分应用了值，我们就到了测试是确定性的时候了，我们的函数非常清楚它们做什么，并且很难被误用(队列事实是没有类型安全)。</p><p id="9e01" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设我们现在想写一个可以将12相加的函数。我们现在要干嘛？嗯，我们可以做的一件事是像以前运行<code class="fe kt ku kv kw b">const addTwelve = add(12)</code>一样遵循我们的过程，或者我们可以开始看看函数编程的力量，并开始应用我们在开始时学到的规律来创建新的、已经测试过的函数，这些函数可以有力地给我们信心！</p><p id="4793" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设我们有一个<code class="fe kt ku kv kw b">addTwo</code>和<code class="fe kt ku kv kw b">addTen</code>函数，如果数学仍然是数学的话，我们通过定律知道<code class="fe kt ku kv kw b">addTwo(addTen(5))</code>会运行<code class="fe kt ku kv kw b">2 + 10 + 5</code>得到17，但是如果我们不想每次都写垃圾，会发生什么呢？</p><p id="9e2e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">进来的是“管”和“缀”。</em></p><p id="6f01" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Pipe和compose为我们提供了一种方法，使用部分应用程序的能力获取一组函数并在一种数据类型上运行它们。唯一的区别是pipe从左到右操作，而compose从右到左操作。</p><p id="aea4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦我们为pipe编写了一些代码，这可能会更有意义。更新我们的<strong class="jw iy"> index.js </strong>文件，现在取这个:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f159" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">重要的部分是我们的<code class="fe kt ku kv kw b">pipe</code>功能。现在看起来很疯狂！让我们来看看它在做什么:</p><ol class=""><li id="35a8" class="mc md ix jw b jx jy kb kc kf me kj mf kn mg kr mh mi mj mk bi translated">声明作为函数的变量<code class="fe kt ku kv kw b">pipe</code></li><li id="4985" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">当您调用<code class="fe kt ku kv kw b">pipe</code>时，它接受任意数量的函数参数。这里的<code class="fe kt ku kv kw b">...fns</code>使用操作符<code class="fe kt ku kv kw b">...</code>使我们能够接受不确定数量的参数<strong class="jw iy"/>。我们可以调用<code class="fe kt ku kv kw b">pipe(addTwo)</code>、<code class="fe kt ku kv kw b">pipe(addTwo, addTen)</code>或<code class="fe kt ku kv kw b">pipe(addTwo, addTen, addTenMillion)</code>，当它接受每个参数并将其添加到数组<code class="fe kt ku kv kw b">fn</code>时，所有这些都将有效。对于那些给定的例子，它将分别设置<code class="fe kt ku kv kw b">fn</code>到<code class="fe kt ku kv kw b">[addTwo]</code>、<code class="fe kt ku kv kw b">[addTwo, addTen]</code>和<code class="fe kt ku kv kw b">[addTwo, addTen, addTenMillion]</code>。由于<code class="fe kt ku kv kw b">pipe</code>是一个curried函数，它返回另一个函数。</li><li id="dcbd" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">从管道返回的这个函数可以用参数<code class="fe kt ku kv kw b">data</code>调用。这个实例中的数据将是我们通过管道传递的基数值。</li><li id="0cf4" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">最后，在完成我们的部分应用程序后，它将运行函数数组<code class="fe kt ku kv kw b">fns</code>并调用<strong class="jw iy">累积值</strong> <code class="fe kt ku kv kw b">acc</code>上的函数，从<code class="fe kt ku kv kw b">data</code>的值开始。</li></ol><p id="8ca1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是大量的信息。但是不要害怕，我们使用下面的函数可以向您展示这一点。</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a946" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">哇哦。你刚才看到了吗？我们现在能够获得一个像2这样的数，并通过一个管道传递它，这个管道将应用我们赋予它的所有函数！</p><p id="3931" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们逐步完成<code class="fe kt ku kv kw b">addTwelve</code>功能。这将使我们在上面走过的步骤有意义！</p><ol class=""><li id="dc3e" class="mc md ix jw b jx jy kb kc kf me kj mf kn mg kr mh mi mj mk bi translated">首先，我们调用<code class="fe kt ku kv kw b">pipe(addTwo, addTen)</code>并将其分配给<code class="fe kt ku kv kw b">addTwelve</code>。通过<code class="fe kt ku kv kw b">addTwo</code>和<code class="fe kt ku kv kw b">addTen</code>，pipe将把参数<code class="fe kt ku kv kw b">fns</code>赋值为<code class="fe kt ku kv kw b">[addTwo, addTen]</code>。</li><li id="c1ab" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">我们调用<code class="fe kt ku kv kw b">addTwelve(2)</code>，然后将2分配给<code class="fe kt ku kv kw b">data</code>。</li><li id="948e" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">减速器以基值为2运行。然后，它从左到右应用函数，并将<code class="fe kt ku kv kw b">acc</code>分配给响应。这意味着我们运行<code class="fe kt ku kv kw b">addTwo(2)</code>，返回4。4被分配给<code class="fe kt ku kv kw b">acc</code>，然后将该值传递给<code class="fe kt ku kv kw b">addTwelve(4)</code>以得到16。</li></ol><p id="8779" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然这个例子很琐碎，但是我们所能做的非常惊人。但是真正的问题是:<strong class="jw iy">由于我们在开始时提到的那些定律，我们可以将管道函数的结果通过管道传输回其他管道函数。</strong></p><p id="121b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">说什么？</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4c89" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以通过向<code class="fe kt ku kv kw b">index.test.js</code>添加一个测试来验证这一点:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ab03" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">那个。是。难以置信。到目前为止，我们一直在使用简单的算法，试着想象在特定数据类型上应用函数的可能性，并开始制作这些令人难以置信的强大管道！</strong></p><p id="f817" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">那么我们如何构建自己的合成函数呢？</em>记得我说过<code class="fe kt ku kv kw b">pipe</code>是从左到右，而<code class="fe kt ku kv kw b">compose</code>是从右到左吗？良好的...</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8ab8" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">没错！我们简单地使用数组的<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" rel="noopener ugc nofollow" target="_blank"> reduceRight </a>原型方法。就是这样！</p><p id="1603" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以以相同的顺序将相同的参数传递给<code class="fe kt ku kv kw b">pipe</code>和<code class="fe kt ku kv kw b">compose</code>，并得到相同的答案，这要感谢我们在开始时提到的函数式编程的四个属性！</p><h2 id="5af5" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">用字符串演示应用程序</h2><p id="29cf" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">你厌倦谈论算术了吗？我确实是。我想通过创建小的确定性函数并在现实世界中应用它们，开始向您展示函数的强大功能。</p><p id="065c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">字符串是一个很好的地方，因为我们一直都在操作它们，但是你应该注意到这些概念也可以应用到其他类型(这是你开始钻研函数类型的地方，比如你的单子等等)。</p><p id="fa78" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们给我们的<code class="fe kt ku kv kw b">index.js</code>文件添加一些函数。我不打算解释太多关于这些函数的内容，只需要知道我们期望获取一个字符串，运行某种形式的操作并返回一个字符串。</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="af71" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这一次，我们不打算写一个测试。只需运行<code class="fe kt ku kv kw b">node index.js</code>，您将获得以下输出:</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6a55" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简单地从左到右或者从右到左，我们得到了完全不同的答案！</p><p id="983f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然上面的例子可能很琐碎，但我一直在使用组合来做一些事情，比如对相似的正则表达式替换函数进行分组，以使它们具有难以置信的可读性。</p><p id="b856" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，本周我用它们来帮助我们将代码库中的300多个文件转换成Sass！</p><figure class="mq mr ms mt gt ir"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="a7a1" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">结论</h2><p id="ffc7" class="pw-post-body-paragraph ju jv ix jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">我们已经讲述了函数式编程的四个核心原则，然后沿着理解curry、局部应用的轨迹，最后创建了我们自己的简单示例<code class="fe kt ku kv kw b">pipe</code>和<code class="fe kt ku kv kw b">compose</code>来看看它们的实际应用！</p><p id="d3a5" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">这是一个巨大的努力！</strong></p><p id="365a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">功能编程是工具带上可供选择的另一种工具。这只是表面现象，但它为那些有兴趣了解它的人奠定了良好的基础。</p><p id="7e90" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们今天讨论的概念在分解函数式编程所需的范式转换方面走了很长一段路，理解它们将是征服下一步的基础。</p><p id="ac1b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们再次回头看看<strong class="jw iy">蒙纳格林夫人的诅咒</strong>作为结束。</p><blockquote class="lv lw lx"><p id="b8dc" class="ju jv ks jw b jx jy jz ka kb kc kd ke ly kg kh ki lz kk kl km ma ko kp kq kr ij bi translated"><em class="ix">“一旦你理解了单子，你就立刻变得无法向任何人解释它们”</em></p></blockquote><p id="d75c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一次，我们将把这个诅咒头拿出来，胜利地出来！</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="8418" class="kx ky ix bd kz la lb dn lc ld le dp lf kf lg lh li kj lj lk ll kn lm ln lo lp bi translated">资源和进一步阅读</h2><ol class=""><li id="917e" class="mc md ix jw b jx lq kb lr kf nh kj ni kn nj kr mh mi mj mk bi translated"><a class="ae mb" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> Currying </a></li><li id="5d52" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated"><a class="ae mb" href="https://plato.stanford.edu/entries/set-theory/" rel="noopener ugc nofollow" target="_blank">集合论</a></li><li id="c170" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated"><a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" rel="noopener ugc nofollow" target="_blank">array . prototype . reduce right</a></li><li id="f332" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated"><a class="ae mb" href="https://github.com/okeeffed/build-your-own-pipe-compose" rel="noopener ugc nofollow" target="_blank">已完成项目</a></li><li id="7ee7" class="mc md ix jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated"><a class="ae mb" href="https://docs.dennisokeeffe.com/manual-functional-programming-hardcore-fp-in-java-script-v2#properties-of-fp" rel="noopener ugc nofollow" target="_blank"> 4功能程序设计的属性</a></li></ol><p id="d754" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">形象信用:</em> <a class="ae mb" href="https://unsplash.com/@errior" rel="noopener ugc nofollow" target="_blank"> <em class="ks">费边·荣格</em> </a></p><p id="1a1b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">最初发布在我的</em> <a class="ae mb" href="https://blog.dennisokeeffe.com/blog/2020-07-10-understand-pipe-and-compose-by-implementing-them/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">博客</em> </a> <em class="ks">上。</em></p></div></div>    
</body>
</html>