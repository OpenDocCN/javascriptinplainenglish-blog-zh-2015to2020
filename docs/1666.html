<html>
<head>
<title>A Deep Dive into Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Web组件的深入研究</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-deep-dive-into-web-components-3f7d6713da9e?source=collection_archive---------5-----------------------#2020-04-12">https://javascript.plainenglish.io/a-deep-dive-into-web-components-3f7d6713da9e?source=collection_archive---------5-----------------------#2020-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b366f542445e5d9e763b6815829869c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLVXV8OjIkch-Nh3UyV0AQ.jpeg"/></div></div></figure><p id="7bb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将深入研究<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Web组件</strong> </a>，看看为什么前端开发人员使用它非常必要。</p><h1 id="4bc6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">简介</strong></h1><p id="b1e0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">web components.org将其定义为:</p><blockquote class="ma mb mc"><p id="9756" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">Web组件是一组web平台API，允许您创建新的自定义的、可重用的、封装的HTML标记，以便在网页和web应用程序中使用。</p></blockquote><p id="dd3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，web组件就像一个提供一些功能的盒子，有封装的数据，这意味着应用于Web组件的任何css和js代码都与其他元素完全隔离，因此任何更改/样式都不会影响其他元素。</p><p id="68ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Web组件似乎解决了程序员在构建前端应用程序时不得不面对的最大问题之一，那就是<strong class="ka ir"> DRY原则</strong>。DRY代表<strong class="ka ir">‘不要重复你自己’</strong>是软件开发的一个基本原则<strong class="ka ir"> </strong>，旨在通过封装和抽象减少重复，有了web组件，我们有能力让我们的标记遵循这个原则。现在我们可以创建我们自己的定制标记元素，这些元素以前编写起来很复杂。</p><p id="6af9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也有各种UI框架可用，如React、Angular和Vue，但自定义Web组件为许多可能性打开了大门。已经开发了一堆库，它们帮助我们很容易地构建Web组件，但是我们一会儿就要进入这个领域。</p><p id="c610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我们回顾一下Web组件的架构。</p><h1 id="1078" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak"> Web组件架构</strong></h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/1262a95d3c61e32fe6b35bd8a28c6314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28AzRm3aCKzbMem2iGZ-Tg.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">The Pillars of Olympus or so it seem like!</figcaption></figure><p id="ed4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Web组件由四个支柱组成。</p><p id="bfbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1-自定义元素</p><p id="1498" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">双阴影DOM</p><p id="977b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3- HTML元素</p><p id="33d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4-进口</p><p id="969f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一种叫做decorator，但是decorator目前并没有真正的规范，这导致了web组件范例只有四个支柱。</p><h1 id="3164" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建Web组件的步骤</h1><p id="e973" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">实现web组件的基本方法应该如下所示:</p><p id="989d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1 -创建一个类或函数来指定Web组件的功能。</p><p id="7fb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2 -注册新的自定义元素。</p><p id="5835" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3 -如果需要，使用Element.attachShadow()方法将阴影DOM附加到自定义元素。添加子元素、事件侦听器等。，使用常规DOM方法添加到影子DOM。</p><p id="c976" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4 -如果需要，使用<template>和<slot>定义一个HTML模板。再次使用常规的DOM方法克隆模板并将其附加到影子DOM。</slot></template></p><p id="8909" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经讨论了Web组件中包含的主要细节，那么让我们使用4个支柱来深入研究代码。</p><h2 id="dd18" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">1-自定义元素</h2><p id="3f84" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">创建自定义元素是Web组件的关键特性之一，因为它帮助我们将自定义功能封装到一个元素中，而不是键入很长的嵌套html元素。</p><p id="0b6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建自定义元素的主要原因是从开发人员的角度来看代码更少，创建更具语义的标签库，减少<code class="fe nc nd ne nf b">div</code>标签的数量，等等。web组件一旦开发出来，就可以被任何应用程序使用。</p><p id="94db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有两种类型的自定义元素:</p><p id="45de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自主定制元素。</p><p id="e6cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定制的内置元素。</p><p id="76e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们一个一个地检查一下。</p><h2 id="74eb" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">i -自主定制元素</h2><p id="bd98" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这些元素只是<em class="md">独立的</em>元素，不需要被标准Html <em class="md">元素</em>继承。要使用它们，我们只需像编写普通html元素一样编写它们。</p><p id="95bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nc nd ne nf b">&lt;user-info&gt;</code>，或者说<code class="fe nc nd ne nf b">document.createElement("user-info")</code>。</p><p id="e003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看这个工作，以获得它的要点。</p><p id="40cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们已经为我们的自定义组件定义了一个名为<em class="md"> HelloComponent </em>的类，并用<em class="md">html element</em><strong class="ka ir"><em class="md">s .</em></strong>扩展了它，自治的自定义元素将总是扩展<em class="md"> HTMLElements </em>。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面截取的代码中，我们扩展了html元素，但是为什么呢？</p><h2 id="1c52" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">html元素</h2><p id="784b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">HTMLElements基本上是DOM树的一个元素，如主体、表格和表单等。它包含所有的属性，属性，事件处理程序等。它提供了HTML特有的功能，这些功能在基本元素接口中是没有的。</p><p id="a233" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当每个主体被创建时，它被附加到HTMLElements。</p><h2 id="7543" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">构造器</h2><p id="75ca" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">接下来，我们在类中提供了一个构造函数，它也调用super方法。将总是首先调用super()方法，以便建立正确的原型链。在构造函数的下面，我们定义了所有被实例化的函数。</p><p id="1660" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在最后一行中，我们调用了CustomElement。</p><h2 id="cb91" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">客户元素</h2><p id="0f87" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">CustomElement是HTML元素的控制器，它是一个对象。它用于将定制元素注册到DOM中。要注册一个元素，只需调用CustomElement.define()。它需要参数:</p><ul class=""><li id="d0d9" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated"><strong class="ka ir"><em class="md">Name:</em></strong>Name param取新定制元素的名称。自定义元素名称必须包含连字符(-)。</li><li id="e713" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> <em class="md">构造函数:</em> </strong>新的自定义元素的构造函数将被插入到这里。</li><li id="f4e7" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> <em class="md">选项:</em> </strong>可选参数，取自定义元素要扩展的内置元素的字符串名称。这用于创建<strong class="ka ir">定制内置元素</strong>。</li></ul><h2 id="66c3" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">ii —定制的内置元素。</h2><p id="ac3a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这些元素继承自内置的html元素。为了编写它们，我们必须提供它们所扩展的元素的名称，并将它们编写为普通的html元素，但在“is”属性中使用自定义元素的名称。</p><p id="56f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nc nd ne nf b">&lt;p is="word-count"&gt;</code>或<code class="fe nc nd ne nf b">document.createElement("p",{ is: "word-count" })</code></p><p id="50c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个元素和这个元素的唯一区别是它扩展了一个不同的接口，而不是<em class="md"> HTMLElements。</em></p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Customized Build-in Elements</figcaption></figure><p id="79f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面截取的代码中，你可以看到我们现在扩展了<em class="md"> HTMLUListElement而不是HTMLElements </em>，这使得它具有内置属性<em class="md">。</em>接下来，我们用create element创建它，但是这一次，我们使用一个options对象，它包含了它必须扩展的ul元素。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="c4ef" class="kx ky iq bd kz la od lc ld le oe lg lh li of lk ll lm og lo lp lq oh ls lt lu bi translated">什么是生命周期挂钩？</h1><p id="ad40" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">从一个元素被创建到被销毁，发生了很多事情，同样，当我们谈论html元素时:</p><ul class=""><li id="acae" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated">它们被创建并插入到DOM中</li><li id="5108" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">当事件被激发时，它们被触发。</li><li id="8a1b" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">它们被移走或销毁。</li></ul><p id="1563" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些被称为生命周期事件，几乎每种编程语言都有生命周期。我们可以使用名为<strong class="ka ir"> <em class="md">的回调函数来挂钩这些自定义元素反应。</em>T11】</strong></p><p id="dee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样做的一个很大的好处是Web组件有本地浏览器支持，这让我们不用写很长的代码。我们可以使用生命周期挂钩让事情在某个时间点发生。</p><h1 id="2d5b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可用的生命周期挂钩</h1><p id="b810" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">以下是可供使用的生命周期挂钩:</p><ul class=""><li id="d203" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated">构造函数()</li><li id="0c99" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">connectedCallback()</li><li id="db5b" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">disconnectedCallback()</li><li id="b49a" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">attributeChangedCallback(名称，旧值，新值)</li><li id="23c5" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">已采用回调()</li></ul><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/29576e54b549f596f2296a486119084e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGFElAOgiQ-Ck7qaQVpqng.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">All lifecycle hooks available</figcaption></figure><ul class=""><li id="7d45" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated"><strong class="ka ir">构造函数</strong>:构造函数是创建自定义元素时第一个被调用的函数。</li><li id="7417" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> connectedCallback: </strong>一旦我们的定制元素被创建并追加到DOM中，这个回调就被调用。</li><li id="85f2" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> disconnectedCallback: </strong>每当我们的元素从DOM树断开时，这个回调被调用，这个事件被触发。当元素被移除时，我们也可以使用这个回调来清理代码并释放一些资源。这包括取消订阅DOM事件。释放未被自动垃圾收集的资源是至关重要的，就好像我们不释放未使用的资源(应用程序不再需要的内存)，它可能会导致内存泄漏。</li><li id="2972" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir">attributeChangedCallback:</strong>每次在DOM中添加、更改或删除自定义元素属性时，都会调用这个回调函数。例如，删除输入字段和设置属性名称等。</li><li id="37c5" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> adoptedCallback: </strong>每当我们的定制元素被移动到一个新文档中时，这个回调就会被调用。</li></ul><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Lifecycle hooks example</figcaption></figure><p id="900b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面截取的代码中，我们为所有生命周期挂钩设置了事件。您可以在控制台中观察到，当我们添加、删除和更改属性时，不同的生命周期挂钩被触发。我们也对它进行了一些样式化，但是这里所有的样式都是全局的，并不仅仅封装到自定义元素中。这就是暗影DOM的用武之地。</p><h1 id="174a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">双阴影DOM</h1><p id="21bd" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Web组件的主要部分是封装。我们希望将我们的html标记结构、代码和样式与文件中的其他代码分开，避免它们相互冲突。目前，我们已经简单地创建了我们的自定义元素，它的css是全局的，这意味着它们也适用于其他元素。所以我们需要的是在元素内部封装所有的样式和功能，这样我们添加的每个样式都不会影响元素内部，外部元素也不会影响内部。这可以通过<strong class="ka ir">影子DOM API </strong>实现。</p><blockquote class="ma mb mc"><p id="bace" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq"> Shadow </em> DOM允许将隐藏的DOM树附加到常规DOM树中的元素上——这个shadow DOM树从一个Shadow根开始，在它下面可以附加任何你想要的元素，就像常规DOM一样。</p></blockquote><p id="8ea1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意一些影子DOM术语:</p><ul class=""><li id="1c62" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated"><strong class="ka ir">影子主机</strong>:影子DOM附加的常规DOM节点。</li><li id="5ce5" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir">阴影树</strong>:阴影DOM里面的DOM树。</li><li id="7f7c" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir">阴影边界</strong>:阴影DOM结束的地方，常规DOM开始。</li><li id="4f6c" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir">影子根</strong>:影子树的根节点。</li></ul><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/cff42664bbc8ebb3f85eb6e7aa1977d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSOpITlAqbyYC_UYYW7zMg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Shadow DOM tree structure</figcaption></figure><p id="f19f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们实现影子DOM。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="741b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们创建了一个小进度条。首先，我们用attachShadow方法创建了阴影DOM。attachShadow方法的作用是将shadow DOM附加到调用它的元素上，该方法接受一个输入参数对象，该对象的键是mode，值可以是open或close。</p><p id="e854" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您选择输入close，那么shadow DOM将无法从整个页面外部的javascript访问，而如果您输入open，则可以在整个页面访问它。</p><p id="6df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们编写自己的自定义元素属性“complete ”,它将跟踪进度条。我们还为此属性制作了getter和setter。</p><pre class="mi mj mk ml gt ok nf ol om aw on bi"><span id="613f" class="mq ky iq nf b gy oo op l oq or">get complete() {<br/>   return this._complete;<br/>}<br/>  <br/>set complete(val) {<br/>   this.setAttribute('complete', val);<br/>}</span></pre><p id="a827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个属性将作为我们自定义元素的属性，所以要在自定义元素中设置属性，只需调用<code class="fe nc nd ne nf b">setAttribute()</code>方法，该方法在第二个参数中接受属性名和值。</p><pre class="mi mj mk ml gt ok nf ol om aw on bi"><span id="7e96" class="mq ky iq nf b gy oo op l oq or">this.setAttribute('complete', val);</span></pre><p id="d14b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，我们也可以使用<code class="fe nc nd ne nf b">getAttribute()</code>来获取属性值。</p><p id="3922" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以定义我们的内联样式并将它们附加到shadow DOM中。最后，我们注册了自定义元素，如下所示。</p><pre class="mi mj mk ml gt ok nf ol om aw on bi"><span id="a30a" class="mq ky iq nf b gy oo op l oq or">window.customElements.define('progress-bar', MyProgressBar);</span></pre><p id="19a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且在html文件中，添加了一些脚本来实时显示它。这里的样式是内部的，但是我们完全可以创建一个外部样式表，并简单地将链接附加到shadow DOM。</p><p id="79d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这只是web组件的一个小演示，我们仅仅触及了表面，还有更多的事情可以做。</p><h1 id="9e36" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">3- HTML元素</h1><p id="4624" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">有几个内置的Html元素可以用来减少HTML的重复结构。模板就是其中之一。这是一个可以使用的内置模板。</p><pre class="mi mj mk ml gt ok nf ol om aw on bi"><span id="c38b" class="mq ky iq nf b gy oo op l oq or">&lt;template id="my-paragraph"&gt;<br/>  &lt;p&gt;My paragraph&lt;/p&gt;<br/>&lt;/template&gt;</span></pre><h1 id="ee7e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">4-进口</h1><p id="d2f2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">导入允许您将包与Web组件一起使用。没有Web组件也可以使用。你可以加载任何类型的资源，从样式表，脚本和网页字体等。若要导入，请使用带有rel属性的link标记，并使其等于import，这样您的href将包含您的资源的路径。</p><pre class="mi mj mk ml gt ok nf ol om aw on bi"><span id="4c66" class="mq ky iq nf b gy oo op l oq or">&lt;link rel="import" href="myfile.html"&gt;</span></pre><p id="66cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这基本上概括了Web组件的所有内容。现在也有一些库可以帮助我们创建自己的Web组件。</p><h1 id="93b3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用Web组件的库:</h1><p id="d159" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">使用的顶级Web组件库:</p><ul class=""><li id="b087" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated"><strong class="ka ir">智能HTML元素:</strong> jQWidgets Ltd .在2018年发布了智能HTML元素。智能HTML元素是一个现代的香草JS和ES6库和下一代前端框架。企业级Web组件包括可访问性特性，可以很容易地与Angular、ReactJS、Vue.js、Bootstrap、Meteor和任何其他框架集成。</li><li id="98e2" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> Hybrids: </strong>这是一个用于创建Web组件的UI库，它使用普通的对象和函数，并且不包括类和语法。它不支持属性的全局生命周期，但支持基于继承的合成。它支持强大的声明式和函数式方法。</li><li id="8f91" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> LitElements: </strong>这是一个简单的基类，用于使用lit-html创建快速、轻量级的Web组件。它使用lit-html将元素渲染到shadow DOM中，并通过添加API来管理属性。</li><li id="b329" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated"><strong class="ka ir"> Polymer: </strong>被谷歌服务和网站使用。它有一个创建自定义元素的简化方法，总是以手势事件为特征的单向和双向数据绑定。</li></ul></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="6bb7" class="kx ky iq bd kz la od lc ld le oe lg lh li of lk ll lm og lo lp lq oh ls lt lu bi translated"><strong class="ak">结论</strong></h1><p id="b7d1" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这篇文章中，我们深入探讨了Web组件的根源，并详细讨论了每一个概念，这将使您能够在瞬间开始构建自己的Web组件，并一定会帮助您迈向更高的境界。再见了，朋友们！</p><h2 id="8c39" class="mq ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="daba" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们已经推出了三种新的出版物！为我们的新出版物献上一点爱心吧，请跟随他们:<a class="ae kw" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka ir">AI in Plain English</strong></a>，<a class="ae kw" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka ir">UX in Plain English</strong></a>，<a class="ae kw" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka ir">Python in Plain English</strong></a><strong class="ka ir"/>——谢谢，继续学习！</p><p id="d430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kw" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">submissions @ plain English . io</strong></a><strong class="ka ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>