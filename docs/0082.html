<html>
<head>
<title>Comparing Vuex and Redux by developing an application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过开发应用程序比较Vuex和Redux</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/similarities-and-differences-between-vuex-and-redux-by-developing-an-application-be3df0164b22?source=collection_archive---------0-----------------------#2019-02-17">https://javascript.plainenglish.io/similarities-and-differences-between-vuex-and-redux-by-developing-an-application-be3df0164b22?source=collection_archive---------0-----------------------#2019-02-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4416666a1a30775df3e911fbc3bfa1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBFilG_cJHl8Q83nVUr7xg.jpeg"/></div></div></figure><h2 id="0bfa" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我使用Vue和React已经有一段时间了。</h2><p id="8405" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">作为JavaScript开发人员，我们有机会在多个框架和各种状态管理系统上工作。因为我是一名自由职业的web开发人员，所以我根据项目需求同时使用React和Vue。在这个故事中，我将比较两个非常流行的状态管理系统Vuex和Redux的工作方式。虽然两者都受到Flux架构的启发，但它们遵循不同的方式来实现结果。</p><p id="dfe5" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">在学习新框架时，将一个框架的特性与以前学习的框架或库进行比较是一种自然的趋势。这提供了一个容易理解和记忆的方法，因为我们知道它在另一个世界是如何运作的。</p><h1 id="b0c0" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">所以这里有一篇文章是关于比较Vuex和Redux是如何用不同的方式做同样的事情的。</h1><p id="34fe" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated"><em class="mi">注意:我不是在比较核心框架，也不是试图告诉你哪一个更好，我只是专注于</em> <strong class="kt io"> <em class="mi"> Vuex </em> </strong> <em class="mi">和</em><strong class="kt io"><em class="mi">Redux</em></strong><em class="mi">的特性，以及它们如何以不同的方式实现结果。</em></p><figure class="mk ml mm mn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/cbffeccc51084d1df80d36b579b5c686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cx9tDPOisMAYE5-t2VrnLA.png"/></div></div></figure><h1 id="5153" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">HTML</h1><p id="2521" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">两个应用程序的标记现在完全相同，稍后我们将使用Vue中的指令和React中的渲染函数来修改它们。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="09ee" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">入门指南</h1><p id="5083" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">让我们首先向您展示如何开始使用这些状态管理库和它们的基本样板代码。</p><h2 id="d512" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> Vuex </strong></h2><p id="27bc" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Vuex与VueJS紧密耦合，因此Vuex开始使用的样板代码较少。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="dfa6" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> Redux </strong></h2><p id="5dbc" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Redux是框架不可知的，它不特定于React。因此，我们需要导入一些其他的库来让它工作。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="0133" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">存储和状态</h1><p id="cdf4" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Vuex和Redux都有一个维护所有应用程序状态变量的store对象，让我们看看如何在store中创建状态变量。</p><h2 id="d98e" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Vuex是如何做到的</strong></h2><p id="80e1" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Vuex状态是可变的，因此我们可以直接创建状态变量并给它们赋值。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b4e4" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><strong class="kt io">它是如何还原的</strong></p><p id="6b80" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">Redux使用<strong class="kt io">减速器、</strong>减速器，其中<strong class="kt io"> </strong>是取前一个状态和动作并返回下一个状态的纯函数。我们将在下面详细讨论这一点。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Redux uses Reducers to create and manage a set of states.</figcaption></figure><h1 id="dff8" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">在我们的应用中使用这些状态</h1><p id="4343" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">现在我们已经能够创建一个带有一个硬编码TODO项的状态，让我们看看如何在我们的应用程序中使用它。</p><h2 id="08ac" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Vuex是怎么做到的</strong></h2><p id="eaef" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Vue有一个<code class="fe mu mv mw mx b">mapState()</code>助手函数，用于将状态从Vuex存储映射到组件。这些映射的变量可以像正常的状态变量一样被直接访问，尽管我们不能直接修改这些变量。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2ecc" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果我们需要对我们的状态变量执行一些操作，并获得计算出的值以在各种组件中使用，我们可以在模板中使用Vuex的<code class="fe mu mv mw mx b">getters</code>:</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="cf19" class="jv jw in mx b gy nc nd l ne nf">&lt;li v-for="(item, index) in <strong class="mx io">todoList</strong>" <br/>  :key="item.id" <br/>  :class="{ completed: item.completed}"<br/>&gt;</span></pre><h2 id="4416" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">【Redux是怎么做到的</h2><p id="86d8" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Redux有<code class="fe mu mv mw mx b">mapStateToProps()</code>方法，该方法被传递给由<code class="fe mu mv mw mx b">react-redux</code>库提供的更高阶组件<code class="fe mu mv mw mx b">connect</code>。这些状态现在可以作为我们组件中的道具来访问。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="4300" class="jv jw in mx b gy nc nd l ne nf">//component<br/>import { <strong class="mx io">connect </strong>} from 'react-redux';</span><span id="0291" class="jv jw in mx b gy ng nd l ne nf">const <strong class="mx io">mapStateToProps </strong>= (state) =&gt; {<br/>  return { todos: state };<br/>}</span><span id="5d2f" class="jv jw in mx b gy ng nd l ne nf">export default connect(<strong class="mx io">mapStateToProps</strong>)(App);</span></pre><p id="94c7" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">Redux没有提供任何与<code class="fe mu mv mw mx b">getters</code>相似的特性，我们可以在一个单独的文件中编写我们自己的实用方法，并通过在模板中使用它在任何需要的地方导入它们:</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="4cdb" class="jv jw in mx b gy nc nd l ne nf">renderList() {<br/>return <strong class="mx io">this.props.todos</strong>.map(item =&gt; {<br/>  return (<br/>    &lt;li key={item.id}<br/>      className={"todo " + (item.completed ? "completed" : "")}<br/>      onClick={() =&gt; this.props.<strong class="mx io">toggleCompletion</strong>(item.id)}&gt;<br/>    &lt;/li&gt;<br/>  )<br/>})<br/>}</span></pre><h1 id="3efb" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">修改状态</h1><p id="9a0f" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">不应直接修改状态变量。我们使用特殊的方法来修改/更新它们，以便可以正确地跟踪它们。</p><h2 id="7950" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Vuex是如何做到的</strong></h2><p id="dba0" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">真正改变Vuex存储状态的唯一方法是提交一个<strong class="kt io">突变</strong>。Vuex突变与事件非常相似；每个突变都有一个字符串类型和一个处理程序。处理函数是我们执行实际状态修改的地方，它将接收状态作为第一个参数。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="5fa0" class="jv jw in mx b gy nc nd l ne nf"><strong class="mx io"><br/></strong>//store.js<strong class="mx io"><br/>mutations</strong>: {<br/>    <strong class="mx io">addItem</strong>(state, payload) {<br/>      state.todos.push({id:GLOBAL_ID++, title: payload, completed:   false});<br/>    },<br/>    <strong class="mx io">togglecompletion</strong>(state, id) {<br/>      state.todos.forEach( item =&gt; {<br/>        if(item.id === id) <br/>          item.completed = !item.completed;<br/>      })<br/>    },<br/>    <strong class="mx io">removeItem</strong>(state, index) {<br/>      state.todos.splice(index, 1);<br/>    }<br/>  }</span></pre><p id="7148" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">突变也把有效载荷作为可选的第二个参数，如果我们必须传递更多的数据，那么我们可以在有效载荷中发送数组或对象。</p><h2 id="8a4c" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Redux是怎么做到的</strong></h2><p id="5b33" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">在Redux中，状态修改方法也是用reducers编写的。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="6dfd" class="jv jw in mx b gy nc nd l ne nf">//reducer/index.js</span><span id="c38a" class="jv jw in mx b gy ng nd l ne nf">const todos = (state = initialState, action) =&gt; {<br/>  switch (action.type) {<br/>    case "<strong class="mx io">ADD_ITEM</strong>":<br/>      return [<br/>        ...state,<br/>        {<br/>          id: GLOBAL_ID++,<br/>          title: action.title,<br/>          completed: false<br/>        }<br/>      ];<br/>    case "<strong class="mx io">TOGGLE_COMPLETION</strong>":<br/>      console.log('action', action);<br/>      return state.map(todo =&gt;<br/>        todo.id === action.id ? { ...todo, completed: !todo.completed } : todo<br/>      );<br/>    case "<strong class="mx io">REMOVE_ITEM</strong>":<br/>      return state.filter(todo =&gt; todo.id !== action.id);<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="68b2" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">减速器维护状态及其修改方法，这些方法由<strong class="kt io">调度动作</strong>调用。这些动作还需要有效负载将数据从我们的应用程序发送到我们的Redux存储。<strong class="kt io">(记住，在Redux状态下是不可变的)</strong></p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="09e2" class="jv jw in mx b gy nc nd l ne nf">//actions/index.js</span><span id="04b1" class="jv jw in mx b gy ng nd l ne nf">let nextTodoId = 0;</span><span id="2611" class="jv jw in mx b gy ng nd l ne nf">export const <strong class="mx io">addItem </strong>= title =&gt; {<br/>  return {<br/>    type: "<strong class="mx io">ADD_ITEM</strong>",<br/>    id: nextTodoId++,<br/>    title<br/>  };<br/>};</span><span id="7039" class="jv jw in mx b gy ng nd l ne nf">export const <strong class="mx io">toggleCompletion </strong>= id =&gt; {<br/>  return {<br/>    type: "<strong class="mx io">TOGGLE_COMPLETION</strong>",<br/>    id<br/>  };<br/>};</span><span id="f0fa" class="jv jw in mx b gy ng nd l ne nf">export const <strong class="mx io">removeItem </strong>= id =&gt; {<br/>  return {<br/>    type: "<strong class="mx io">REMOVE_ITEM</strong>",<br/>    id<br/>  }<br/>};</span></pre><p id="8a15" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我们还创建了一个新的文件来存储我们所有的动作，这并不是强制性的，但是它让我们的代码看起来更有条理。与其在代码的后半部分做，不如现在就做。</p><h1 id="76fe" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated"><strong class="ak">从我们的组件修改状态</strong></h1><h2 id="509c" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Vuex是如何做到的</strong></h2><p id="ac8a" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Vuex提供了一个助手方法<code class="fe mu mv mw mx b">mapMutations()</code>来访问组件中的突变。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="69c3" class="jv jw in mx b gy nc nd l ne nf">methods: {<br/> ...mapMutations([<br/>  'addItem', <br/>  'togglecompletion',<br/>  'removeItem',<br/> ])<br/>}</span></pre><p id="48ea" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">在映射之后，这些方法可以像普通的组件方法一样被访问，方法是在我们的组件中使用这些突变:</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="6a8d" class="jv jw in mx b gy nc nd l ne nf">&lt;button class="destroy" @click.stop="removeTodo(index)"&gt;&lt;/button&gt;</span><span id="d939" class="jv jw in mx b gy ng nd l ne nf">removeTodo: function(index) {<br/>  this.<strong class="mx io">removeItem</strong>(index);<br/>}</span></pre><h2 id="16d9" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Redux是怎么做到的</strong></h2><p id="fbd9" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">类似于<code class="fe mu mv mw mx b">mapStateToProps()</code> Redux为我们提供了另一个名为<code class="fe mu mv mw mx b">mapDispatchToProps()</code>的助手传递给我们的HOC。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="1360" class="jv jw in mx b gy nc nd l ne nf">const <strong class="mx io">mapDispatcherstoProps </strong>= dispatch =&gt;  {<br/>  return {<br/>    toggleCompletion: (id) =&gt; dispatch(<strong class="mx io">toggleCompletion</strong>(id)),<br/>    removeItem: (id) =&gt; dispatch(<strong class="mx io">removeItem</strong>(id)),<br/>    addItem: (title)=&gt; dispatch(<strong class="mx io">addItem</strong>(title)),<br/>    addItemFromWeb: ()=&gt; dispatch(<strong class="mx io">addItemFromWeb</strong>())   <br/>  }<br/>}</span><span id="718c" class="jv jw in mx b gy ng nd l ne nf">export default connect(mapStateToProps, <strong class="mx io">mapDispatcherstoProps</strong>)(App);</span></pre><p id="71a1" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这个方法将<code class="fe mu mv mw mx b">dispatch</code>作为一个参数，这个调度方法用于提交我们的动作。这些动作现在被映射到通过props可用的本地方法，如下所示:</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="20dd" class="jv jw in mx b gy nc nd l ne nf">&lt;button className="destroy" <br/>    onClick={() =&gt; <strong class="mx io">this.props.removeItem</strong>(item.id)}<br/>/&gt;</span></pre><p id="0f2d" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">现在，我们的待办事项应用程序功能齐全，我们可以添加项目，检查已完成的项目和删除项目。</p><h1 id="0015" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">进行异步呼叫</h1><p id="daa9" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">扩展我们的待办事项列表应用程序，假设我们想要加载存储在服务器中的用户列表，我们不能直接从我们的Vuex突变或Redux操作调用服务器，因为它们是同步方法。我们需要特殊的方法来实现这一点。</p><h2 id="d2af" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Vuex是如何做到的</strong></h2><p id="286e" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">突变是纯粹的同步功能，我们不能在突变中引起副作用。要进行异步调用，Vuex有<code class="fe mu mv mw mx b">actions</code>。动作类似于突变，但是动作<code class="fe mu mv mw mx b">commit</code>突变而不是状态突变。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="ae0a" class="jv jw in mx b gy nc nd l ne nf">//store.js<br/>actions: {<br/>    addItemFromWeb(context) {<br/>      axios.get('<a class="ae nh" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>)<br/>      .then((response) =&gt; {<br/>        console.log(response);<br/>        <strong class="mx io">context.commit</strong>('<strong class="mx io">addItem</strong>', response.data.title)<br/>      })<br/>      .catch((error) =&gt; console.log(error));<br/>    }<br/>  }</span></pre><p id="47bc" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">在上面的例子中，我们利用<code class="fe mu mv mw mx b">axios </code>库进行HTTP调用。</p><p id="35c7" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">为了在我们的组件中使用这些动作，Vuex为我们提供了<code class="fe mu mv mw mx b">mapActions()</code> helper方法。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="7cea" class="jv jw in mx b gy nc nd l ne nf">&lt;button @click="addItemFromWeb"&gt; Async Add &lt;/button&gt;</span><span id="0c68" class="jv jw in mx b gy ng nd l ne nf">methods: {<br/>    ...mapActions([<br/>      'addItemFromWeb'<br/>    ])<br/>}</span></pre><h2 id="6439" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Redux是怎么做到的</strong></h2><p id="4e17" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Redux不像Vuex那样提供任何开箱即用的解决方案，因此我们需要<strong class="kt io">中间件</strong>来进行异步调用。</p><p id="f8fc" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">为了实现这一点，我们使用了一个叫做<code class="fe mu mv mw mx b">redux-thunk.</code>的中间件，这个中间件非常简单，它检查动作是否是一个函数。如果是，则使用<code class="fe mu mv mw mx b">dispatch.</code>调用该函数；如果不是，则直接调用缩减器。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="44a4" class="jv jw in mx b gy nc nd l ne nf">import { <strong class="mx io">applyMiddleware </strong>} from 'redux';<br/>import thunk from '<strong class="mx io">redux-thunk</strong>';</span><span id="cddb" class="jv jw in mx b gy ng nd l ne nf">const store = createStore(<br/>   reducer,<br/>   <strong class="mx io">applyMiddleware(thunk)</strong>,<br/>);</span></pre><p id="c536" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">现在在<code class="fe mu mv mw mx b">actions.js</code>中，我们创建了我们的异步函数:</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="c17e" class="jv jw in mx b gy nc nd l ne nf">export const <strong class="mx io">addItemFromWeb </strong>= () =&gt; {<br/>    return <strong class="mx io">dispatch </strong>=&gt; {<br/>        axios.get('<a class="ae nh" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>)<br/>        .then((response) =&gt;{<br/>            console.log(response);<br/>            <strong class="mx io">dispatch</strong>(<strong class="mx io">addItem</strong>(response.data.title));<br/>        })<br/>        .catch((error) =&gt; {<br/>            console.log(error);<br/>        })<br/>    }<br/>}</span></pre><h1 id="7969" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">应用管理和扩展</h1><p id="386e" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">随着应用程序的增长，我们需要管理更多的状态，我们不能只为Vuex准备一个<code class="fe mu mv mw mx b"> store.js</code>文件或为Redux准备一个<code class="fe mu mv mw mx b">reducer.js</code>文件，我们需要模块化我们的应用程序。</p><h2 id="fbf7" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Vuex是如何做到的</strong></h2><p id="83cb" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">Vuex允许我们把店铺分成<code class="fe mu mv mw mx b">modules</code>。每个模块可以包含自己的状态、突变、动作、getters，甚至嵌套模块。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="2ad0" class="jv jw in mx b gy nc nd l ne nf">const <strong class="mx io">moduleA </strong>= {<br/>  state: { ... },<br/>  mutations: { ... },<br/>  actions: { ... },<br/>  getters: { ... }<br/>}<br/><br/>const <strong class="mx io">moduleB </strong>= {<br/>  state: { ... },<br/>  mutations: { ... },<br/>  actions: { ... }<br/>}<br/><br/>const store = new Vuex.Store({<br/>  modules: {<br/>    a: <strong class="mx io">moduleA</strong>,<br/>    b: <strong class="mx io">moduleB</strong><br/>  }<br/>})<br/><br/>store.state.a // -&gt; `moduleA`'s state<br/>store.state.b // -&gt; `moduleB`'s state</span></pre><p id="9763" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">在模块的变异和获取器中，收到的第一个参数将是模块的<strong class="kt io">本地状态</strong>。</p><p id="f19d" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">每个<code class="fe mu mv mw mx b">module</code>可以写入单独的文件，这些文件可以导入到<code class="fe mu mv mw mx b">store.js</code>中</p><h2 id="b60e" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">Redux是怎么做到的</strong></h2><p id="f87e" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们可以将root reducer拆分成多个reducer，然后将它们组合在一起。每个缩减器将负责管理其中的状态。</p><pre class="mk ml mm mn gt my mx mz na aw nb bi"><span id="1735" class="jv jw in mx b gy nc nd l ne nf"><strong class="mx io">import</strong> { combineReducers } <strong class="mx io">from</strong> 'redux' <br/><strong class="mx io">import</strong> todos <strong class="mx io">from</strong> './todos' <br/><strong class="mx io">import</strong> counter <strong class="mx io">from</strong> './counter'<br/>  <br/><strong class="mx io">let reducers =</strong> <strong class="mx io">combineReducers</strong>({<br/>todo: <strong class="mx io">todos</strong>,<br/>ctr: <strong class="mx io">counter</strong><br/>})</span><span id="f6dd" class="jv jw in mx b gy ng nd l ne nf">const store = createStore(reducer);</span><span id="bed6" class="jv jw in mx b gy ng nd l ne nf">ReactDOM.render(&lt;Provider store={store}&gt;&lt;App /&gt;&lt;/Provider&gt;, document.getElementById('root'));</span></pre><p id="d7ac" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">Redux库为我们提供了一个名为<code class="fe mu mv mw mx b">combineReducers</code>的特性，将我们所有的减速器组合成一个单独的减速器。<strong class="kt io">(注意，我们不能直接访问一个reducer中的状态)</strong>reducer所需的数据应该由组件通过动作传递。</p><h1 id="4c8d" class="lr jw in bd jx ls lt lu ka lv lw lx kd ly lz ma kh mb mc md kl me mf mg kp mh bi translated">结论</h1><p id="53e7" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们比较了两个非常流行的状态管理库，它们都受Flux架构的启发，都有相同的最终目标，但采用了不同的途径来实现它。</p><p id="8ffe" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我希望您发现这很有用。如果是这样，一定要留下很多掌声！👏</p><p id="4d7a" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><em class="mi">如果你对比较</em> <strong class="kt io"> <em class="mi"> Vue </em> </strong> <em class="mi">和</em> <strong class="kt io"> <em class="mi"> React </em> </strong> <em class="mi">感兴趣，我推荐你查一下</em> <a class="ae nh" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd" rel="noopener"> <em class="mi">这篇</em> </a> <em class="mi">由</em> <a class="ni nj ep" href="https://medium.com/u/a7b125868703?source=post_page-----be3df0164b22--------------------------------" rel="noopener" target="_blank"> <em class="mi">苏尼尔【桑德胡】</em> </a> <em class="mi">。</em></p><h2 id="ff2b" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">现场演示</strong></h2><p id="7ff6" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated"><a class="ae nh" href="https://vuex-todo-preetish.netlify.com" rel="noopener ugc nofollow" target="_blank"> Vue + Vuex </a></p><p id="2923" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><a class="ae nh" href="https://redux-todo-preetish.netlify.com" rel="noopener ugc nofollow" target="_blank"> React + Redux </a></p><h2 id="dd02" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">演示App源代码</strong></h2><p id="7c62" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated"><a class="ae nh" href="https://github.com/preetishhs/vuex-todos" rel="noopener ugc nofollow" target="_blank"> Vuex TODO Github </a></p><p id="c23a" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><a class="ae nh" href="https://github.com/preetishhs/redux-todos" rel="noopener ugc nofollow" target="_blank"> Redux TODO Github </a></p><h2 id="87fb" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">我目前也可以从事自由网页开发工作。有什么项目给我吗？请务必在</strong>给我发一封电子邮件，地址是contact@preetish😃</h2></div></div>    
</body>
</html>