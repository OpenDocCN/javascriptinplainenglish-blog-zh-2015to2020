<html>
<head>
<title>Object-Oriented JavaScript — Parts of a Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——类的一部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-parts-of-a-class-37eceab91f4e?source=collection_archive---------7-----------------------#2020-11-14">https://javascript.plainenglish.io/object-oriented-javascript-parts-of-a-class-37eceab91f4e?source=collection_archive---------7-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/be432946f0de6294de876e80e1c550f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KmKPgSK5mrNJydFS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@george_tse?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">George Tseganis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b28f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看JavaScript类的各个部分。</p><h1 id="dd09" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造器</h1><p id="f83a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">constructor</code>是一个特殊的方法，用来创建和初始化我们用类创建的对象。</p><p id="430d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类构造函数可以用<code class="fe me mf mg mh b">super</code>方法调用它的父类构造函数。</p><p id="775a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">super</code>用于创建子类。</p><h1 id="de83" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型方法</h1><p id="5c02" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">原型方法是类的原型属性。</p><p id="784b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们由一个类的实例继承。</p><p id="fae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6e20" class="mq lc iq mh b gy mr ms l mt mu">class Car {<br/>  constructor(model, year) {<br/>    this.model = model;<br/>    this.year = year;<br/>  }<br/>  <br/>  get modelName() {<br/>    return this.model<br/>  }<br/>  <br/>  calcValue() {<br/>    return "2000"<br/>  }<br/>}</span></pre><p id="cb20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe me mf mg mh b">Car</code>类中有2个原型方法。</p><p id="ea2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种是<code class="fe me mf mg mh b">modelName</code>消气法。</p><p id="bc01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种是<code class="fe me mf mg mh b">calValue</code>方法。</p><p id="2cbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦实例化了类，我们就可以使用它们:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="71ae" class="mq lc iq mh b gy mr ms l mt mu">const corolla = new Car('Corolla', '2020');<br/>console.log(corolla.modelName);<br/>console.log(corolla.calcValue());</span></pre><p id="1c14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe me mf mg mh b">Car</code>实例。</p><p id="9027" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到getter作为属性。</p><p id="b476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">calcValue</code>来获取值。</p><p id="13a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建具有动态名称的类方法。</p><p id="aa3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8f90" class="mq lc iq mh b gy mr ms l mt mu">const methodName = 'start';</span><span id="35c4" class="mq lc iq mh b gy mv ms l mt mu">class Car {<br/>  constructor(model, year) {<br/>    this.model = model;<br/>    this.year = year;<br/>  }</span><span id="43f6" class="mq lc iq mh b gy mv ms l mt mu">  get modelName() {<br/>    return this.model;<br/>  }</span><span id="6b72" class="mq lc iq mh b gy mv ms l mt mu">  calcValue() {<br/>    return "2000"<br/>  }</span><span id="7439" class="mq lc iq mh b gy mv ms l mt mu">  [methodName]() {<br/>    //...<br/>  }<br/>}</span></pre><p id="445d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将变量<code class="fe me mf mg mh b">methodName</code>传递给方括号，使<code class="fe me mf mg mh b">start</code>成为方法的名称。</p><h1 id="2bbe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">静态方法</h1><p id="0eaa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以添加可以直接从类中运行的静态方法。</p><p id="ff25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8b35" class="mq lc iq mh b gy mr ms l mt mu">class Plane {<br/>  static fly(level) {<br/>    console.log(level)<br/>  }<br/>}</span></pre><p id="0731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有了<code class="fe me mf mg mh b">fly</code>静态方法。</p><p id="eb45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要运行静态方法，我们可以编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="986e" class="mq lc iq mh b gy mr ms l mt mu">Plane.fly(10000)</span></pre><h1 id="531b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">静态属性</h1><p id="6344" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">没有办法在类体内定义静态属性。</p><p id="fb29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会添加到JavaScript的未来版本中。</p><h1 id="3115" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生成器方法</h1><p id="66e7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在类中添加生成器方法。</p><p id="da8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建一个实例是可迭代对象的类。</p><p id="2276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="375c" class="mq lc iq mh b gy mr ms l mt mu">class Iterable {<br/>  constructor(...args) {<br/>    this.args = args;<br/>  }</span><span id="965f" class="mq lc iq mh b gy mv ms l mt mu">  *[Symbol.iterator]() {<br/>    for (const arg of this.args) {<br/>      yield arg;<br/>    }<br/>  }<br/>}</span></pre><p id="9c9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建接受可变数量参数的<code class="fe me mf mg mh b">Iterable</code>类。</p><p id="72c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">Symbol.iterator</code>方法迭代<code class="fe me mf mg mh b">this.args</code>并返回参数。</p><p id="8ef3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">*</code>表示该方法是一种生成器方法。</p><p id="304b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以通过编写来使用该类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9003" class="mq lc iq mh b gy mr ms l mt mu">const iterable = new Iterable(1, 2, 3, 4, 5);<br/>for (const i of iterable) {<br/>  console.log(i);<br/>}</span></pre><p id="b7ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e28" class="mq lc iq mh b gy mr ms l mt mu">1<br/>2<br/>3<br/>4<br/>5</span></pre><p id="4203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经创建了一个<code class="fe me mf mg mh b">Iterable</code>类的实例。</p><p id="c3aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们循环遍历迭代器项并记录值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d84d0446976f47c6be6a1dd7e84a0705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KMbqeD43JhreItp_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@george_tse?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">George Tseganis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="df88" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d25b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个类可以有一个构造函数、实例变量、getters、实例方法、静态方法和生成器方法。</p><p id="b181" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>