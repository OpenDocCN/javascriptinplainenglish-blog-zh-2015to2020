<html>
<head>
<title>Forcing change detection on third-party Angular components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对第三方角度组件进行强制更改检测</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/forcing-change-detection-on-a-third-party-angular-component-e6008beab6ef?source=collection_archive---------1-----------------------#2020-07-17">https://javascript.plainenglish.io/forcing-change-detection-on-a-third-party-angular-component-e6008beab6ef?source=collection_archive---------1-----------------------#2020-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5ca2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一种方法可以解决第三方角度组件的变化检测问题。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f4e2e599951eea1761e8f19d76ad4704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ax1qDobLjBpH9DxX6Ww4OA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Picture courtesy of <a class="ae lb" href="https://unsplash.com/@35mm" rel="noopener ugc nofollow" target="_blank">35mm</a></figcaption></figure><p id="3eb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的应用程序中，我们应该尽最大努力继续使用<a class="ae lb" href="https://blog.angular-university.io/onpush-change-detection-how-it-works/" rel="noopener ugc nofollow" target="_blank"> OnPush变化检测策略</a>。不幸的是，有时我们会被无法正确检测变化的第三方组件所困扰。</p><p id="233d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我经常遇到变化检测和灌注组件的问题，它们(在这一点上)仍然没有使用OnPush策略。</p><p id="6a3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，变更检测问题通常是由潜伏在周围的bug引起的，但是我们并不总是有等待修复的奢侈。</p><p id="eeba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将分享一个由<a class="ae lb" href="https://twitter.com/nthonymiller/status/1283218988923682816" rel="noopener ugc nofollow" target="_blank">安东尼·米勒</a>给出的技巧，来强制检测任何组件的变化；不管是你的还是第三方的。</p><h1 id="7b5e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">强制变化检测</h1><p id="8d42" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">您可能知道，在角度应用中，我们可以使用<a class="ae lb" href="https://angular.io/api/core/ChangeDetectorRef" rel="noopener ugc nofollow" target="_blank">changededetorref</a>来强制检测变化，我们可以简单地将它注入我们的组件中。</p><p id="0c69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ChangeDetectorRef有多种方法，如<code class="fe mf mg mh mi b">markForCheck</code>和<code class="fe mf mg mh mi b">detectChanges</code>，可以做我们想做的事情。</p><p id="e080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我在我的书中所解释的，有一个与组件树平行的变更检测器树，所以每个组件实际上都有它自己的变更检测器。</p><p id="c260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是，取决于我们使用哪一个，我们或多或少地引起工作。例如，当应用程序组件使用它的ChangeDetectorRef强制执行更改检测时，它会在一棵大树上强制执行更改检测。</p><p id="491b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，建议只在您需要的特定组件上强制进行更改检测(理想情况下，没有，但现实生活中会发生)。</p><p id="dc96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果某个特定的组件存在变更检测问题，那么我们实际上希望通过该特定组件的变更检测器来强制进行变更检测，以便它只为该组件(及其子组件)触发变更检测。</p><h1 id="8e0f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">访问其他组件的注射器</h1><p id="6101" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">要访问组件的ChangeDetectorRef实例，我们只需通过构造函数注入它:</p><pre class="km kn ko kp gt mj mi mk ml aw mm bi"><span id="9a51" class="mn ld iq mi b gy mo mp l mq mr">constructor(private changeDetectorRef: ChangeDetectorRef) { ... }</span></pre><p id="7f06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦注射，我们可以简单地使用它。当然有一个陷阱:一个组件只能使用它自己的<a class="ae lb" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank">注入器</a> …或者你会这么想！</p><p id="890e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上有一种方法可以将另一个组件的注入器访问到目标组件的<a class="ae lb" href="https://angular.io/api/core/ViewContainerRef" rel="noopener ugc nofollow" target="_blank"> ViewContainerRef </a>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="19da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，<code class="fe mf mg mh mi b">CoolComponent</code>使用了<code class="fe mf mg mh mi b">Whatever</code>组件。为了访问<code class="fe mf mg mh mi b">Whatever</code>组件的变更检测器实例，我们首先在模板中创建一个<a class="ae lb" href="https://angular.io/guide/template-syntax" rel="noopener ugc nofollow" target="_blank">模板引用变量</a>，然后我们使用<a class="ae lb" href="https://angular.io/api/core/ViewChild" rel="noopener ugc nofollow" target="_blank"> ViewChild </a> decorator来获取该组件的<code class="fe mf mg mh mi b">ViewContainerRef</code>。</p><p id="ceb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在我们组件的<code class="fe mf mg mh mi b">ngAfterViewInit</code>方法中，我们简单地使用了组件的注入器，我们可以通过<code class="fe mf mg mh mi b">ViewContainerRef</code>访问它来检索组件的<code class="fe mf mg mh mi b">ChangeDetectorRef</code>。整洁！</p><h1 id="3c85" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="6b4c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">感谢<a class="ae lb" href="https://twitter.com/nthonymiller" rel="noopener ugc nofollow" target="_blank">安东尼·米勒</a>，现在我们的工具箱里又多了一个工具来帮助我们解决讨厌的变更检测错误，而不用求助于丑陋的黑客。</p><p id="2833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我在本文中所解释的，我们可以通过任何组件的<code class="fe mf mg mh mi b">ViewContainerRef</code>来访问它的注入器，并使用它来检索它的<code class="fe mf mg mh mi b">ChangeDetectorRef</code>(或者其他任何东西)。这样，我们可以非常精确地触发变更检测，并避免在不需要时导致大量的变更检测周期。</p><p id="066c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p><h1 id="ccfc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">喜欢这篇文章吗？</h1><p id="2ab9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果你想了解关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的大量其他很酷的东西，那么不要犹豫<a class="ae lb" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae lb" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的时事通讯</a>！</p></div></div>    
</body>
</html>