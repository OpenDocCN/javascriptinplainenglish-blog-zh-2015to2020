<html>
<head>
<title>Use body-parser Express Middleware to Parse JSON and Raw Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用body-parser Express中间件来解析JSON和原始请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-body-parser-express-middleware-to-parse-json-and-raw-requests-8da2f737dac8?source=collection_archive---------5-----------------------#2020-03-16">https://javascript.plainenglish.io/using-the-body-parser-express-middleware-to-parse-json-and-raw-requests-8da2f737dac8?source=collection_archive---------5-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/001b77352e450cbbca59fdf20edab100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*raCGL29EnnskONNG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fabuchao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fabian Burghardt</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，Express 4.x或更高版本没有提供任何解析请求体的功能。因此，我们需要添加一些东西来做到这一点。</p><p id="36d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何使用<code class="fe lb lc ld le b">body-parser</code>中间件来处理JSON和原始体。</p><h1 id="0585" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加主体解析器包</h1><p id="a4f1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">body-parser</code>是一个节点包，我们可以将它添加到我们的Express应用程序中来解析请求体。</p><p id="0ad3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不支持多部分主体，所以我们必须使用其他中间件包来解析它们。</p><p id="5eb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，它可以解析JSON主体、原始请求主体、文本和URL编码的主体。</p><p id="29e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了安装这个包，我们运行:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7666" class="mq lg iq le b gy mr ms l mt mu">npm install body-parser</span></pre><p id="c5b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以添加以下内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7176" class="mq lg iq le b gy mr ms l mt mu">const bodyParser = require('body-parser');</span></pre><h1 id="cb61" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解析JSON主体</h1><p id="ac4e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以通过调用JSON方法来解析JSON主体。它接受一个带有一些属性的可选对象。</p><p id="9f0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些选项包括:</p><ul class=""><li id="96d3" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe lb lc ld le b">inflate</code> —当设置为<code class="fe lb lc ld le b">true</code>时，压缩的请求体将膨胀。否则，他们会被拒绝。</li><li id="df1f" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">limit</code> —控制最大请求正文大小。如果是数字，那就用字节来衡量。如果它是一个字符串，那么它可以被解析成多个字节。</li><li id="ecbf" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">reviver</code> —这是作为第二个参数传递给<code class="fe lb lc ld le b">JSON.parse</code>的函数，用于将值映射到我们想要的值</li><li id="78ee" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">strict</code> —仅在设置为<code class="fe lb lc ld le b">true</code>时接受对象和数组。否则，它会接受<code class="fe lb lc ld le b">JSON.parse</code>接受的任何东西。默认为<code class="fe lb lc ld le b">true</code>。</li><li id="ece3" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">type</code> —这用于确定它将解析什么媒体类型。它可以是字符串、字符串数组或函数。如果不是函数，那么就直接传入<code class="fe lb lc ld le b">type-is</code>库。否则，如果调用函数的数据类型返回真值，则解析请求</li><li id="02b2" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">verify</code> —这是一个带有签名<code class="fe lb lc ld le b">(req, res, buf, encoding)</code>的函数，其中<code class="fe lb lc ld le b">buf</code>是原始请求体的缓冲对象。解析可以通过在函数中抛出一个错误来中止。</li></ul><p id="bdcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="80b6" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const options = {<br/>  inflate: true,<br/>  limit: 1000,<br/>  reviver: (key, value) =&gt; {<br/>    if (key === 'age') {<br/>      if (value &lt; 50) {<br/>        return 'young'<br/>      }<br/>      else {<br/>        return 'old';<br/>      }<br/>    }<br/>    else {<br/>      return value;<br/>    }<br/>  }<br/>};<br/>app.use(bodyParser.json(options));</span><span id="ade8" class="mq lg iq le b gy nj ms l mt mu">app.post('/', (req, res) =&gt; {<br/>  res.send(req.body);<br/>});</span><span id="9bc4" class="mq lg iq le b gy nj ms l mt mu">app.listen(3000);</span></pre><p id="8dec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们向<code class="fe lb lc ld le b">/</code>发出POST请求时，我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3614" class="mq lg iq le b gy mr ms l mt mu">{<br/>    "name": "foo",<br/>    "age": "young"<br/>}</span></pre><p id="2866" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为响应，因为我们检查了reviver函数中的<code class="fe lb lc ld le b">age</code>字段，并根据<code class="fe lb lc ld le b">value</code>返回<code class="fe lb lc ld le b">'young'</code>或<code class="fe lb lc ld le b">'old'</code>。否则，我们就把<code class="fe lb lc ld le b">value</code>原样归还。</p><p id="b014" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请求体被解析并设置为<code class="fe lb lc ld le b">req.body</code>的值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/49ab7fb51cfaac8a191ed096e82d181a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pFUvVWA9O_9OnCoS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@laura_college?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Laura College</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b736" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解析原始几何体</h1><p id="3587" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以将原始体解析为缓冲区。支持<code class="fe lb lc ld le b">gzip</code>和<code class="fe lb lc ld le b">deflate</code>编码的自动膨胀。</p><p id="52b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">包含解析数据的解析后的<code class="fe lb lc ld le b">body</code>被填充到<code class="fe lb lc ld le b">request</code>对象上，即它将被设置为<code class="fe lb lc ld le b">req.body</code>的值。</p><p id="6ea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它采用一个可选的<code class="fe lb lc ld le b">option</code>对象，该对象具有以下属性:</p><ul class=""><li id="ea8c" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe lb lc ld le b">inflate</code> —当设置为<code class="fe lb lc ld le b">true</code>时，压缩的请求体将膨胀。否则，他们会被拒绝。</li><li id="1ee7" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">limit</code> —控制最大请求正文大小。如果是数字，那就用字节来衡量。如果它是一个字符串，那么它可以被解析成多个字节。</li><li id="ae21" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">type</code> —这用于确定它将解析什么媒体类型。它可以是字符串、字符串数组或函数。如果不是函数，那么就直接传入<code class="fe lb lc ld le b">type-is</code>库。否则，如果调用函数的数据类型返回真值，则解析请求</li><li id="40bd" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">verify</code> —这是一个带有签名<code class="fe lb lc ld le b">(req, res, buf, encoding)</code>的函数，其中<code class="fe lb lc ld le b">buf</code>是原始请求体的缓冲对象。解析可以通过在函数中抛出一个错误来中止。</li></ul><p id="a767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="be1c" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const options = {<br/>  inflate: true,<br/>  limit: 1000,<br/>  type: 'text/plain'<br/>};<br/>app.use(bodyParser.raw(options));</span><span id="b6ab" class="mq lg iq le b gy nj ms l mt mu">app.post('/', (req, res) =&gt; {<br/>  res.send(req.body);<br/>});</span><span id="de9a" class="mq lg iq le b gy nj ms l mt mu">app.listen(3000);</span></pre><p id="7a32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们用主体<code class="fe lb lc ld le b">foo</code>向<code class="fe lb lc ld le b">/</code>发送一个POST请求时，我们得到回复<code class="fe lb lc ld le b">foo</code>。</p><p id="9d64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们指定了<code class="fe lb lc ld le b">text/plain</code>作为解析原始数据的类型。</p><p id="8702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还足够智能，可以解析多种身体类型。我们可以通过传入一组<code class="fe lb lc ld le b">type</code>字符串来实现，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6ba0" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const options = {<br/>  inflate: true,<br/>  limit: 1000,<br/>  type: ['text/plain', 'text/html']<br/>};<br/>app.use(bodyParser.raw(options));</span><span id="1a0b" class="mq lg iq le b gy nj ms l mt mu">app.post('/', (req, res) =&gt; {<br/>  res.send(req.body);<br/>});</span><span id="2213" class="mq lg iq le b gy nj ms l mt mu">app.listen(3000);</span></pre><p id="ef15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们用主体<code class="fe lb lc ld le b">&lt;b&gt;foo&lt;/b&gt;</code>向<code class="fe lb lc ld le b">/</code>发出POST请求时。然后我们回到<code class="fe lb lc ld le b">&lt;b&gt;foo&lt;/b&gt;</code>。</p><h1 id="cf77" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="8ec9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">body-parser</code>中间件来解析JSON和原始文本体。</p><p id="c4f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还采用了各种选项来让我们控制是否膨胀压缩的请求体、将JSON值映射到其他内容、限制请求体的大小等等。</p><p id="0804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于原始请求体，我们可以使用<code class="fe lb lc ld le b">body-parser</code>来指定数据的类型，这样我们就可以将其解析为该类型的对象，并将其设置为<code class="fe lb lc ld le b">req.body</code>。</p></div></div>    
</body>
</html>