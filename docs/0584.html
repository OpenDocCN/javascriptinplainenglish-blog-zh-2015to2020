<html>
<head>
<title>Easily Iterate Over JavaScript Collections with the For-Of Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用For-Of循环轻松迭代JavaScript集合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/easily-iterate-over-javascript-collections-with-the-for-of-loop-dbc24ea6a894?source=collection_archive---------1-----------------------#2019-11-12">https://javascript.plainenglish.io/easily-iterate-over-javascript-collections-with-the-for-of-loop-dbc24ea6a894?source=collection_archive---------1-----------------------#2019-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8cbd74b86807f54c93864855d14c98a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1zSSjQgxMBjOc8lc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine Ivanič</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="da51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从ES2015开始，我们有了一种新的循环来循环遍历可迭代对象。新的<code class="fe lb lc ld le b">for...of</code>循环是一种新的循环，它允许我们循环遍历任何可迭代的对象，而不使用常规的<code class="fe lb lc ld le b">for</code>循环、<code class="fe lb lc ld le b">while</code>循环，或者在数组的情况下使用<code class="fe lb lc ld le b">forEach</code>函数。它可以直接用于迭代任何可迭代对象，包括内置对象如字符串、数组、类似数组的对象如<code class="fe lb lc ld le b">arguments</code>、<code class="fe lb lc ld le b">NodeList</code>、<code class="fe lb lc ld le b">TypedArray</code>、<code class="fe lb lc ld le b">Map</code>、<code class="fe lb lc ld le b">Set</code>以及任何用户定义的可迭代对象。用户定义的可迭代对象包括像生成器和迭代器这样的实体。</p><p id="ac67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想使用<code class="fe lb lc ld le b">for...of</code>循环来迭代一个iterable对象，我们可以用下面的语法来写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="afe3" class="ln lo iq le b gy lp lq l lr ls">for (variable of iterable){<br/>  // run code<br/>}</span></pre><p id="f9ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面代码中的<code class="fe lb lc ld le b">variable </code>是代表被迭代的iterable对象的每个条目的变量。可以用<code class="fe lb lc ld le b">const</code>、<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">var</code>声明。<code class="fe lb lc ld le b">iterable</code>是属性被迭代的对象。</p><p id="2d2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用它来迭代数组，如下面的代码所示:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9770" class="ln lo iq le b gy lp lq l lr ls">const arr = [1,2,3];<br/><br/>for (const num of arr) {<br/>  console.log(num);<br/>}</span></pre><p id="fb59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码中，<code class="fe lb lc ld le b">console.log</code>语句将记录1、2和3。如果我们想在<code class="fe lb lc ld le b">for...of</code>循环中分配用于迭代的变量，我们可以用<code class="fe lb lc ld le b">let</code>代替<code class="fe lb lc ld le b">const</code>。例如，我们可以写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1bef" class="ln lo iq le b gy lp lq l lr ls">const arr = [1,2,3];<br/><br/>for (let num of arr) {<br/>  num *= 2 ; <br/>  console.log(num);<br/>}</span></pre><p id="0695" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码中，<code class="fe lb lc ld le b">console.log</code>语句将记录2、4和6，因为我们使用了<code class="fe lb lc ld le b">let</code>关键字来声明<code class="fe lb lc ld le b">num</code>，所以我们可以通过将每个条目乘以2来修改<code class="fe lb lc ld le b">num</code>。我们不能用<code class="fe lb lc ld le b">const</code>重新赋值，所以我们必须使用<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">var</code>来声明我们想要在每次迭代中修改的变量。</p><p id="db74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以迭代字符串。如果我们这样做，在每次迭代中，我们都会得到字符串中的每个字符。例如，如果我们有下面的代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1cfd" class="ln lo iq le b gy lp lq l lr ls">const str = 'string';<br/><br/>for (const char of str) {<br/>  console.log(char);<br/>}</span></pre><p id="55f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到每一行中记录的<code class="fe lb lc ld le b">'string'</code>的单个字符。</p><p id="2ce7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以迭代TypedArrays，它包含由一系列十六进制格式的数字表示的二进制数据。例如，我们可以编写以下代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4edd" class="ln lo iq le b gy lp lq l lr ls">const arr = new Uint8Array([0x00, 0x2f]);<br/><br/>for (const num of arr) {<br/>  console.log(num);<br/>}</span></pre><p id="2476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，<code class="fe lb lc ld le b">console.log</code>将记录0和47。请注意，记录的值是十进制格式，但输入的值是十六进制格式。</p><p id="2e89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在地图上迭代，那么我们得到地图的每个条目。例如，我们可以编写以下代码来迭代地图:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f69d" class="ln lo iq le b gy lp lq l lr ls">const map = new Map([['a', 2], ['b', 4], ['c', 6]]);<br/><br/>for (const entry of map) {<br/>  console.log(entry);<br/>}</span></pre><p id="a141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们记录条目，我们得到<code class="fe lb lc ld le b">['a', 2]</code>、<code class="fe lb lc ld le b">['b', 4]</code>和<code class="fe lb lc ld le b">['c', 6]</code>。映射由键值对作为它们的条目组成。当我们在一个Map上迭代时，每个条目的第一个元素是键，第二个元素是值。要将每个条目的键和值放入它自己的变量中，我们可以使用析构运算符，如下面的代码所示:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a901" class="ln lo iq le b gy lp lq l lr ls">const map = new Map([['a', 2], ['b', 4], ['c', 6]]);<br/><br/>for (const [key, value] of map) {<br/>  console.log(key, value);<br/>}</span></pre><p id="f3dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们记录条目时，我们得到<code class="fe lb lc ld le b">'a' 2</code>、<code class="fe lb lc ld le b">'b' 4</code>和<code class="fe lb lc ld le b">'c' 6</code>。</p><p id="af01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以对集合使用<code class="fe lb lc ld le b">for...of</code>循环。例如，我们可以通过执行以下操作来循环一个集合:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d350" class="ln lo iq le b gy lp lq l lr ls">const set = new Set([1, 1, 2, 3, 3, 4, 5, 5, 6]);<br/><br/>for (const value of set) {<br/>  console.log(value);<br/>}</span></pre><p id="f6a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设置记录1、2、3、4、5和6，因为集合构造函数通过保留集合中第一个出现的值并丢弃后面出现的相同值来自动消除重复条目。</p><p id="d654" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">for...of</code>循环还用于迭代<code class="fe lb lc ld le b">arguments</code>对象，这是一个全局对象，当函数被调用时，它具有传递给函数的参数。例如，如果我们编写以下代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c845" class="ln lo iq le b gy lp lq l lr ls">(function() {<br/>  for (const argument of arguments) {<br/>    console.log(argument);<br/>  }<br/>})(1, 2, 3, 4, 5, 6);</span></pre><p id="e994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到记录了1、2、3、4、5和6，因为这是我们调用函数时传入的。注意，这只适用于常规函数，因为<code class="fe lb lc ld le b">this</code>的上下文必须改为被调用的函数，而不是<code class="fe lb lc ld le b">window</code>。箭头函数不会改变<code class="fe lb lc ld le b">this</code>的内容，所以当我们在箭头函数中运行相同的循环时，我们不会得到正确的参数。</p><p id="9c06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以迭代一系列DOM节点对象，称为<code class="fe lb lc ld le b">NodeList</code>。例如，一个浏览器实现了<code class="fe lb lc ld le b">NodeList.prototype[Symbol.iterator]</code>，那么我们可以像在下面的代码中一样使用<code class="fe lb lc ld le b">for...of</code>循环:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5669" class="ln lo iq le b gy lp lq l lr ls">const divs = document.querySelectorAll('div');<br/><br/>for (const div of divs) {<br/>  console.log(div);<br/>}</span></pre><p id="4b2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们记录了文档中所有的<code class="fe lb lc ld le b">div</code>元素。</p><p id="89f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe lb lc ld le b">for...of</code>循环，我们可以通过使用<code class="fe lb lc ld le b">break</code>、<code class="fe lb lc ld le b">throw</code>或<code class="fe lb lc ld le b">return</code>语句来结束循环。在这种情况下，迭代器将关闭，但执行将在循环之外继续。例如，如果我们写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="ea0d" class="ln lo iq le b gy lp lq l lr ls">function* foo(){ <br/>  yield 'a'; <br/>  yield 'b'; <br/>  yield 'c'; <br/>}; <br/><br/>for (const o of foo()) { <br/>  console.log(o); <br/>  break;<br/>}</span><span id="d2c8" class="ln lo iq le b gy lt lq l lr ls">console.log('finished');</span></pre><p id="e15c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们只记录了' a ',因为我们在<code class="fe lb lc ld le b">for...of</code>循环的末尾有一个break语句，所以在第一次迭代后，迭代器将关闭，循环结束。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/28a22facd094707db34d4b261560dad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z2bXlIvL2ByMPjYP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@she_sees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Charlotte Coneybeer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a5d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在生成器上循环，生成器是返回一个生成器函数的特殊函数。generator函数返回iterable对象的下一个值。它用于让我们通过在一个<code class="fe lb lc ld le b">for...of</code>循环中使用generator函数来遍历一个对象集合。</p><p id="d043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以对一个生成无限值的生成器进行循环。我们可以在生成器内部建立一个无限循环来不断返回新值。因为<code class="fe lb lc ld le b">yield</code>语句直到请求下一个值时才运行，所以我们可以保持无限循环运行，而不会使浏览器崩溃。例如，我们可以写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2f2c" class="ln lo iq le b gy lp lq l lr ls">function* genNum() {<br/>  let index = 0;<br/>  while (true) {<br/>    yield index += 2;<br/>  }<br/>}</span><span id="3576" class="ln lo iq le b gy lt lq l lr ls">const gen = genNum();<br/>for (const num of gen) {<br/>  console.log(num);<br/>  if (num &gt;= 1000) {<br/>    break;<br/>  }<br/>}</span></pre><p id="000b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，我们会看到记录了从2到1000的数字。然后<code class="fe lb lc ld le b">num</code>大于1000，这样<code class="fe lb lc ld le b">break</code>语句就是ran。我们不能在生成器关闭后重用它，所以如果我们编写如下代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0902" class="ln lo iq le b gy lp lq l lr ls">function* genNum() {<br/>  let index = 0;<br/>  while (true) {<br/>    yield index += 2;<br/>  }<br/>}</span><span id="ddb3" class="ln lo iq le b gy lt lq l lr ls">const gen = genNum();<br/>for (const num of gen) {<br/>  console.log(num);<br/>  if (num &gt;= 1000) {<br/>    break;<br/>  }<br/>}</span><span id="59c8" class="ln lo iq le b gy lt lq l lr ls">for (const num of gen) {<br/>  console.log(num);<br/>  if (num &gt;= 2000) {<br/>    break;<br/>  }<br/>}</span></pre><p id="27d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个循环不会运行，因为生成器生成的迭代器已经被第一个循环用<code class="fe lb lc ld le b">break</code>语句关闭了。</p><p id="7f4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以迭代其他定义了用符号<code class="fe lb lc ld le b">Symbol.iterator</code>表示的方法的可迭代对象。例如，如果我们定义了以下iterable对象:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="71d4" class="ln lo iq le b gy lp lq l lr ls">const numsIterable = {<br/>  [Symbol.iterator]() {<br/>    return {<br/>      index: 0,<br/>      next() {<br/>        if (this.index &lt; 10) {<br/>          return {<br/>            value: this.index++,<br/>            done: false<br/>          };<br/>        }<br/>        return {<br/>          value: undefined,<br/>          done: true<br/>        };<br/>      }<br/>    };<br/>  }<br/>};</span></pre><p id="bbff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以运行下面的循环来显示日志生成的结果:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="b212" class="ln lo iq le b gy lp lq l lr ls">for (const value of numsIterable) {<br/>  console.log(value);<br/>}</span></pre><p id="7ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们运行它时，当<code class="fe lb lc ld le b">console.log</code>在上面的循环中运行时，应该会看到记录的0到9。</p><p id="a105" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是我们不要混淆<code class="fe lb lc ld le b">for...of</code>循环和<code class="fe lb lc ld le b">for...in</code>循环。<code class="fe lb lc ld le b">for...in</code>循环用于遍历对象的顶级键，包括原型链上的任何对象，而<code class="fe lb lc ld le b">for...of</code>循环可以遍历任何可迭代对象，如数组、集合、映射、<code class="fe lb lc ld le b">arguments</code>对象、<code class="fe lb lc ld le b">NodeList</code>对象和任何用户定义的可迭代对象。</p><p id="9bd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有这样的东西:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8e06" class="ln lo iq le b gy lp lq l lr ls">Object.prototype.objProp = function() {};<br/>Array.prototype.arrProp = function() {};</span><span id="6ed5" class="ln lo iq le b gy lt lq l lr ls">const arr = [1, 2, 3];<br/>arr.foo = 'abc';</span><span id="41b0" class="ln lo iq le b gy lt lq l lr ls">for (const x in arr) {<br/>  console.log(x);<br/>}</span></pre><p id="4caa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们记录0，1，2，' foo '，' arrProp '和' objProp '，它们是为<code class="fe lb lc ld le b">arr</code>对象定义的对象和方法的键。它包含了原型链上的所有属性和方法。它从对象和数组继承了所有添加到对象和数组原型的属性和方法，所以我们在<code class="fe lb lc ld le b">for...in</code>循环中获得了链继承中的所有东西。只有可枚举的属性以任意顺序记录在<code class="fe lb lc ld le b">arr</code>对象中。它记录我们在<code class="fe lb lc ld le b">Object </code>和<code class="fe lb lc ld le b">Array </code>中定义的索引和属性，如<code class="fe lb lc ld le b">objProp </code>和<code class="fe lb lc ld le b">arrProp</code>。</p><p id="7c70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了只遍历不是从对象原型继承的属性，我们可以使用<code class="fe lb lc ld le b">hasOwnPropetty</code>来检查属性是否定义在自己的对象上:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="068e" class="ln lo iq le b gy lp lq l lr ls">Object.prototype.objProp = function() {};<br/>Array.prototype.arrProp = function() {};</span><span id="4a35" class="ln lo iq le b gy lt lq l lr ls">const arr = [1, 2, 3];<br/>arr.foo = 'abc';</span><span id="f707" class="ln lo iq le b gy lt lq l lr ls">for (const x in arr) {<br/>  if (arr.hasOwnProperty(x)){<br/>    console.log(x);<br/>  }<br/>}</span></pre><p id="846f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">objProp</code>和<code class="fe lb lc ld le b">arrProp</code>被省略，因为它们分别继承自<code class="fe lb lc ld le b">Object</code>和<code class="fe lb lc ld le b">Array</code>对象。</p><p id="8f7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">for...of</code>循环是一种新的循环，它允许我们在不使用常规的<code class="fe lb lc ld le b">for</code>循环、<code class="fe lb lc ld le b">while</code>循环或者在使用数组的情况下不使用<code class="fe lb lc ld le b">forEach</code>函数的情况下遍历任何可迭代的对象。它可以直接用于迭代任何可迭代对象，包括内置对象，如字符串、数组、类似数组的对象，如<code class="fe lb lc ld le b">arguments</code>和<code class="fe lb lc ld le b">NodeList</code>、<code class="fe lb lc ld le b">TypedArray</code>、<code class="fe lb lc ld le b">Map</code>、<code class="fe lb lc ld le b">Set</code>以及任何用户定义的可迭代对象。用户定义的可迭代对象包括像生成器和迭代器这样的实体。这是一个方便的循环，因为它允许我们遍历任何可迭代的对象，而不仅仅是数组。现在我们有了一个处理iterable对象的循环语句。</p></div></div>    
</body>
</html>