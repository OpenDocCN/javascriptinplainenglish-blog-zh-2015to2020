<html>
<head>
<title>JavaScript Classes. An In-Depth look. Part 4.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript类。深入的观察。第四部分。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-classes-an-in-depth-look-part-4-8db6df2d16cf?source=collection_archive---------2-----------------------#2019-10-11">https://javascript.plainenglish.io/javascript-classes-an-in-depth-look-part-4-8db6df2d16cf?source=collection_archive---------2-----------------------#2019-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e867" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您现在是一名优秀的JavaScript开发人员</h2></div><p id="67f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎回到这个系列。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><ul class=""><li id="4078" class="li lj iq kh b ki kj kl km ko lk ks ll kw lm la ln lo lp lq bi translated"><a class="ae lr" href="https://link.medium.com/USs9sPFoyZ" rel="noopener">第1部分</a>重点介绍了类的核心结构、重要概念和术语。<strong class="kh ir">通过属性添加数据。</strong></li><li id="71e9" class="li lj iq kh b ki ls kl lt ko lu ks lv kw lw la ln lo lp lq bi translated"><a class="ae lr" href="https://link.medium.com/5tVIHlNvyZ" rel="noopener">第2部分</a>重点介绍了特殊的<em class="lx"> set() </em>和<em class="lx"> get() </em>方法以及添加的功能。<strong class="kh ir">通过类方法添加行为。</strong></li><li id="dfd9" class="li lj iq kh b ki ls kl lt ko lu ks lv kw lw la ln lo lp lq bi translated"><a class="ae lr" href="https://medium.com/p/ecadd02addbc" rel="noopener">第3部分</a>更详细地聚焦类<em class="lx">方法</em>，内部和外部，并添加额外的代码逻辑。</li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="e2db" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">第四部分</h1><blockquote class="mq"><p id="e3bb" class="mr ms iq bd mt mu mv mw mx my mz la dk translated">是时候扩展我们的课程了</p></blockquote><blockquote class="na nb nc"><p id="a7b3" class="kf kg lx kh b ki nd jr kk kl ne ju kn nf ng kq kr nh ni ku kv nj nk ky kz la ij bi translated">是的。<br/>最后，<a class="ae lr" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">继承</strong> </a>。在我看来，面向对象编程最重要的特性之一。</p></blockquote><h2 id="b829" class="nl lz iq bd ma nm nn dn me no np dp mi ko nq nr mk ks ns nt mm kw nu nv mo nw bi translated">遗产</h2><p id="d6fa" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">有了<a class="ae lr" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank"/>的继承，我们从一个<a class="ae lr" href="https://www.techopedia.com/definition/26896/base-class" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lx">基类</em></strong></a><strong class="kh ir"><em class="lx"/></strong>和<strong class="kh ir"> <em class="lx">扩展</em> </strong>它来创建一个或多个<a class="ae lr" href="https://www.techopedia.com/definition/3780/derived-class" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lx"/></strong></a>或子类。</p><p id="3793" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果是一个<strong class="kh ir">父</strong>或<strong class="kh ir">超</strong>类和一个或多个子类。</p><p id="9e5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之所以称之为继承，是因为您的子类<em class="lx">继承了</em>超类的所有属性和方法，同时允许我们向子类添加额外的属性和方法。<em class="lx">这些附加的属性和方法只属于子类，不属于超类。继承是一种方式。</em></p><blockquote class="mq"><p id="132d" class="mr ms iq bd mt mu mv mw mx my mz la dk translated">在JavaScript中，继承是通过关键字extends实现的。</p></blockquote><h1 id="6a91" class="ly lz iq bd ma mb oc md me mf od mh mi jw oe jx mk jz of ka mm kc og kd mo mp bi translated">我们开始吧！</h1><p id="55c9" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">我们将创建一个基类Person，然后将其扩展为两个子类Employee和Customer。</p><p id="aa53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的时间是宝贵的，所以我们将保持这些课程的简单性，只关注继承的话题。</p><h2 id="3640" class="nl lz iq bd ma nm nn dn me no np dp mi ko nq nr mk ks ns nt mm kw nu nv mo nw bi translated">示例1</h2><p id="2e66" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">首先，我们将创建我们的Person类并测试它。</p><figure class="oi oj ok ol gt om gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/909f59a0a32fefd3fb9f10174bf81462.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*8XvwrAODHgBQJRqk0rtF2g.jpeg"/></div><figcaption class="op oq gj gh gi or os bd b be z dk">Base class, Person</figcaption></figure><p id="5541" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将把它扩展到Employee子类。当我们这样做时，它创造了一种“是-是”的关系。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="9428" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">员工<strong class="kh ir">就是</strong>人。</p><blockquote class="na nb nc"><p id="3485" class="kf kg lx kh b ki kj jr kk kl km ju kn nf kp kq kr nh kt ku kv nj kx ky kz la ij bi translated">之前没有提到的是HAS-A关系。这基本上是一个类的属性。</p></blockquote><p id="cc57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">人物<strong class="kh ir">有一个</strong>的名字。因为雇员是一个人的延伸，所以雇员也有名字。</p><figure class="oi oj ok ol gt om gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/69083ad9d4b5fda5f7eb817d1a7a9b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*ESmxwifYlPLrx4uxoZs3TA.jpeg"/></div><figcaption class="op oq gj gh gi or os bd b be z dk">IS-A, HAS-A relationships</figcaption></figure><p id="e83b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将Person视为<strong class="kh ir">的超类</strong>，将Employee视为<strong class="kh ir">的子类</strong>。</p><p id="e873" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加下面的类Employee，并测试它。</p><figure class="oi oj ok ol gt om gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/6e66e2b7f71b74d8ee639015ce4a0e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*IqKMsmzIb9e0YFKUTqodsQ.jpeg"/></div><figcaption class="op oq gj gh gi or os bd b be z dk">Pretty Cool!</figcaption></figure><h2 id="4305" class="nl lz iq bd ma nm nn dn me no np dp mi ko nq nr mk ks ns nt mm kw nu nv mo nw bi translated"><strong class="ak">观察结果</strong></h2><ol class=""><li id="6658" class="li lj iq kh b ki nx kl ny ko ov ks ow kw ox la oy lo lp lq bi translated">雇员是人的延伸。</li></ol><p id="6614" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.我们继承了Person的属性和方法(在这个例子中是get和set)。</p><p id="52d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.要设置继承属性的值，我们可以使用super的set()方法。注意第25行和第34行中super的set()的使用。(还有其他方式比如调用super(n)，在构造函数中。)</p><p id="613b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.要获得继承属性的值，我们可以使用super的get()方法。注意第30行和第36行中super的get()的使用。</p><p id="d90d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 4。关键</strong>。在构造函数中，super()；必须在设置本地属性或继承属性之前调用。换句话说，必须在构造函数中首先调用<em class="lx"> super。它可能是构造函数中唯一的项。</em></p><p id="5305" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.我们仍然可以实例化person类来获得Person对象，但是它们只有name属性。</p><h2 id="020d" class="nl lz iq bd ma nm nn dn me no np dp mi ko nq nr mk ks ns nt mm kw nu nv mo nw bi translated">建议</h2><p id="ff9e" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated"><em class="lx">如果您已经阅读了我的其他部分(尤其是</em> <a class="ae lr" href="https://medium.com/p/ecadd02addbc" rel="noopener"> <em class="lx">第3部分</em> </a> <em class="lx">)，您会记得我推荐使用set和get方法来设置和获取属性值，因为我们可以添加验证和其他代码来确保我们得到我们想要的。</em></p><p id="43ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在示例中看到的，您仍然可以让类的使用者能够在构造函数中设置属性值。更多信息参见零件的<a class="ae lr" href="https://link.medium.com/5tVIHlNvyZ" rel="noopener"> 2 </a>和<a class="ae lr" href="https://medium.com/p/ecadd02addbc" rel="noopener"> 3 </a>。</p><blockquote class="na nb nc"><p id="d3c5" class="kf kg lx kh b ki kj jr kk kl km ju kn nf kp kq kr nh kt ku kv nj kx ky kz la ij bi translated">但是，请注意，上述第4条适用于所有情况。</p></blockquote><h2 id="0676" class="nl lz iq bd ma nm nn dn me no np dp mi ko nq nr mk ks ns nt mm kw nu nv mo nw bi translated">可重用性</h2><p id="d0dd" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">使用继承的一个主要原因是重用基类。我们将在下一个例子中这样做。我们将创建一个扩展Person的客户类。这样，我们的客户就可以通过继承获得一个名字以及一个本地定义的头衔。。我们还将在person类中添加一个方法来返回问候。这将被任何子类继承。</p><p id="efc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">例2 </strong></p><figure class="oi oj ok ol gt om gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/97e01979262237e6bec5bef470510423.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*Nv_nGokRUADtoEoe068bBw.jpeg"/></div><figcaption class="op oq gj gh gi or os bd b be z dk">re-use of our base-class and inherited method, greet()</figcaption></figure><p id="52db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们修改了Person以包含greet()方法，所以我们的雇员也继承了它。</p><h1 id="a921" class="ly lz iq bd ma mb oc md me mf od mh mi jw pa jx mk jz pb ka mm kc pc kd mo mp bi translated">结论</h1><p id="97c5" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">我们已经学习了JavaScript类的一个非常强大的能力的基础，继承。有了它，我们可以创建一个基类，并根据需要扩展它(并且仍然使用基类本身。)</p><p id="658e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以扩展任何类，例如，我们也可以扩展Employee。如果我们为全职员工和承包商提供不同的房产，我们可以建造，</p><p id="74af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类公司雇员扩展雇员</p><p id="5152" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和</p><p id="3684" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类合同雇员扩展雇员</p><h2 id="9de9" class="nl lz iq bd ma nm nn dn me no np dp mi ko nq nr mk ks ns nt mm kw nu nv mo nw bi translated">下一步是什么</h2><p id="177c" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">在下一部分也是最后一部分，我们将探索更多关于<strong class="kh ir">超级</strong>和<strong class="kh ir">覆盖</strong>的概念。</p><p id="55e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将关注真正私有的属性和方法。这将为我们提供真正的<a class="ae lr" href="https://en.wikipedia.org/wiki/Object-oriented_programming#Encapsulation" rel="noopener ugc nofollow" target="_blank">面向对象编程规范</a>，数据隐藏。遗憾的是，这仍处于提议阶段。我们将探索一个部分解决方法。然而。</p><p id="5622" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时，感谢阅读！</p></div></div>    
</body>
</html>