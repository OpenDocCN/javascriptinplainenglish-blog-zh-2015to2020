<html>
<head>
<title>Master regular expressions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript中的正则表达式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/master-regular-expressions-in-javascript-7a3810b25ed7?source=collection_archive---------3-----------------------#2020-11-21">https://javascript.plainenglish.io/master-regular-expressions-in-javascript-7a3810b25ed7?source=collection_archive---------3-----------------------#2020-11-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个指南是为了提升你的JavaScript正则表达式游戏。如果你是正则表达式的新手，可以从Mozilla的指南开始。</p><p id="7f96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请从头到尾阅读本指南，因为我的一些示例是相互构建的，假设您已经掌握了前面提到的方法和正则表达式语法。</p><h2 id="b575" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">使用字符串方法replace清理多余的空间</h2><p id="9fb9" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">我们可以用一个简单的正则表达式来清除字符串中的空白。下面的例子使用了<code class="fe lh li lj lk b">\s</code>和<code class="fe lh li lj lk b">+</code>，T0是用于空格的正则表达式，T1是用于匹配1个或更多前一组的正则表达式。我们使用JavaScript字符串方法<code class="fe lh li lj lk b">replace</code>找到所有1个或更多空格的空格匹配，并用1个空格替换它们。</p><p id="6b8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">replace方法非常通用，但最基本的形式是传递一个匹配参数和一个字符串来替换匹配。</p><p id="1bfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，这个例子也使用<code class="fe lh li lj lk b">trim()</code>来清理前导和尾随空白。通过在正则表达式中使用全局标记，它将替换所有匹配。您也可以使用<code class="fe lh li lj lk b">replaceAll</code>，但是它还没有得到普遍支持，并且在Node.js中无法工作(截至11/20/20)。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="d765" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">实现您自己的修剪方法</h2><p id="49a0" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">我们也可以实现我们自己的<code class="fe lh li lj lk b">Customtrim</code>方法来清除文本中间的空白，而不仅仅是开始/结尾的空白。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="b813" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者我们可以更进一步，编写我们自己的前导/尾随正则表达式来清理用于清理内部多空格段的行的开始/结尾。(注意:有一个有用的字符串方法<code class="fe lh li lj lk b">trimEnd</code>和<code class="fe lh li lj lk b">trimStart</code>，所以这只是为了展示更多的正则表达式😉).</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="fde1" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">使用RegExp + String.prototype.match</h2><p id="8b88" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated"><code class="fe lh li lj lk b"><strong class="jm io">match()</strong></code>方法检索将<em class="ls">字符串</em>与<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">正则表达式</a>进行匹配的结果。— MDN</p><p id="b2e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据MDN，<code class="fe lh li lj lk b"><strong class="jm io">RegExp</strong></code>对象用于匹配文本和模式。创建RegExp对象有两种方法，要么用文字符号，要么用构造函数。让我们来看看如何使用构造函数:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="4ef8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个非常人为的例子，但是假设您需要计算这个字符串中的字母数，并且想要使用regex。您可以编写一个for循环，使用RegExp构造函数生成所有适用的RegExp对象。<code class="fe lh li lj lk b">gi</code>部分是标志<code class="fe lh li lj lk b">g</code>和<code class="fe lh li lj lk b">i</code>，它们被添加到表达式中，用于全局和不区分大小写的匹配。然后，<code class="fe lh li lj lk b">match</code>方法找到所有的匹配，我们可以使用<code class="fe lh li lj lk b">length</code>方法检查有多少匹配。利用“或空数组”，<code class="fe lh li lj lk b">|| []</code>，以防没有匹配，所以你没有在<code class="fe lh li lj lk b">undefined</code>的东西上调用<code class="fe lh li lj lk b">length</code>方法。</p><p id="d02b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是字母a的<code class="fe lh li lj lk b">string.match</code>结果之一，所以我们只是在匹配数组上调用<code class="fe lh li lj lk b">length</code>方法。</p><pre class="ll lm ln lo gt lt lk lu lv aw lw bi"><span id="758b" class="kj kk in lk b gy lx ly l lz ma">&gt; [ 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'A', 'a', 'a' ]</span></pre><p id="e584" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是你的正则表达式的样子:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="68e8" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">使用带有转义字符+负lookback的RegExp</h2><p id="161d" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">您可以使您的正则表达式更复杂，以寻找更具体的东西。在这个例子中，我们将看到在JavaScript中需要对正则表达式序列中的字符进行转义的例子。</p><p id="2a14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的代码中，<code class="fe lh li lj lk b">RegExp</code>的目标是找到不在句子开头的所有大写字母。(为了简单起见，请忽略第一个字母，它不在我们的正则表达式中。)</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/3009757e5061cd9360224472328b7f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U21aHQw8EpWAM7PTgyPbug.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Testing on <a class="ae ki" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank">https://regexr.com/</a></figcaption></figure><p id="c972" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正则表达式使用了“负向后视”。消极的后视/前视查看字符串前后的文本(取决于您使用的是哪一个)。对于否定的look back，它会在匹配之前查看与传递的表达式相匹配的文本。如果匹配，那么这最终不是正则表达式匹配，因为我们<em class="ls">不想要那个匹配</em>。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mm"><img src="../Images/a4ad62cf289e4736a5ee890f2deef8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7YlNZTILHuOysCBn2A8Dw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk">Table from Rexegg.com <a class="ae ki" href="https://www.rexegg.com/regex-lookarounds.html" rel="noopener ugc nofollow" target="_blank">https://www.rexegg.com/regex-lookarounds.html</a></figcaption></figure><p id="484f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的代码中，正则表达式可能看起来很奇怪。如果你对照我们在上面的<a class="ae ki" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank">https://regexr.com/</a>图片上写的表达式，你会发现字符串中有一些额外的反斜杠。这是因为当我们在JavaScript字符串中输入字符时，我们必须对它们进行转义，通常我们必须对正则表达式中的字符进行转义，因为它是一个特殊的字符，所以我们有了<code class="fe lh li lj lk b">\\</code>。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/079dfb841b73dedbbd1238a8fd76c409.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*3of89NrbheWG2NrydnwNIw.png"/></div></figure><p id="7b3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这个测试是针对大写字母的，所以从表达式中删除了<code class="fe lh li lj lk b">i</code>标志，因为它测试的是不区分大小写。下面是我们的表情会是什么样子(左图)。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="f42c" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">替换为函数参数</h2><blockquote class="mo mp mq"><p id="f9ab" class="jk jl ls jm b jn jo jp jq jr js jt ju mr jw jx jy ms ka kb kc mt ke kf kg kh ig bi translated">您可以指定一个函数作为第二个参数。在这种情况下，将在执行匹配后调用该函数。请注意，如果第一个参数中的正则表达式是全局的，那么对于要替换的每个完全匹配，该函数将被调用多次。— <a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter" rel="noopener ugc nofollow" target="_blank"> MDN </a></p></blockquote><p id="555a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">语法:</p><p id="9c9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lh li lj lk b">const newStr = str.replace(regexp|substr, newSubstr|function)</code></p><p id="9864" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文前面，我们使用了replace的一个基本用法，我们只是传递一个正则表达式并用一个给定的字符串替换匹配项。</p><p id="d2d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用函数选项，我们可以在执行匹配后调用函数来转换字符串。下面，我们有一个我们想要转换的文件名数组。我们想保持IMG大写，但小写的生日聚会和万圣节部分的文件名。</p><p id="50df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用regex从字符串中提取匹配项，然后在replace中使用一个函数参数来小写字母。我们传递给replace方法的函数是一个简单的函数，它将传递给它的字符串小写。</p><p id="4d07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们想让IMG大写，所以我们可以使用regex提取文件名中在IMG-后面开始的部分，在-001.jpeg部分之前结束匹配。正则表达式匹配使用正向后视和正向前视来将我们的匹配包含到字符串的适用部分。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="fa69" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">使用RegExp.prototype.test()</h2><p id="9ee7" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated"><code class="fe lh li lj lk b"><strong class="jm io">test()</strong></code>方法搜索正则表达式和指定字符串之间的匹配，并返回<code class="fe lh li lj lk b">true</code>或<code class="fe lh li lj lk b">false</code>。</p><p id="8c57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设您需要验证一个pin码，它可以是4位或6位数字。我们可以使用一个简单的正则表达式，它使用匹配数字的<code class="fe lh li lj lk b">\d</code>和匹配精确数字的量词<code class="fe lh li lj lk b">{#}</code>。</p><p id="ea3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在正则表达式本身上调用<code class="fe lh li lj lk b">test</code>方法，而不是在字符串上，并且字符串作为参数传递给<code class="fe lh li lj lk b">test</code>方法。</p><p id="5109" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的例子中，我们测试了一组有效和无效的字符串，并记录它们是否有效。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="5889" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">使用String.prototype.search()</h2><p id="b093" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated"><em class="ls">"</em><code class="fe lh li lj lk b"><strong class="jm io"><em class="ls">search()</em></strong></code><em class="ls">方法执行对正则表达式和</em> <code class="fe lh li lj lk b"><a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank"><em class="ls">String</em></a></code> <em class="ls">对象之间匹配的搜索。当你想知道一个模式是否被找到，并且知道它在一个字符串中的索引时，使用</em> <code class="fe lh li lj lk b"><em class="ls">search()</em></code> <em class="ls">。(如果你只想知道它是否存在，在</em> <code class="fe lh li lj lk b"><em class="ls">RegExp</em></code> <em class="ls">原型上使用类似的</em> <code class="fe lh li lj lk b"><a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" rel="noopener ugc nofollow" target="_blank"><em class="ls">test()</em></a></code> <em class="ls">方法，返回一个布尔值。)"— MDN </em></p><p id="f899" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的代码中，假设您想要验证用户是否提交了评论，并且评论必须包含“是”或“否”。我们可以在if块中使用search方法来验证用户提交了有效的响应。(你可以直接用<code class="fe lh li lj lk b">test()</code>，但是我现场想不出一个现实的例子。😅)</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h1 id="1f07" class="mu kk in bd kl mv mw mx ko my mz na kr nb nc nd ku ne nf ng kx nh ni nj la nk bi translated">String.prototype.split()</h1><p id="d52f" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">在这个例子中，我们有一个各种格式的电话号码数组，我们希望返回一个数组，其中所有的电话号码都被清除了。这个例子非常简单。正则表达式使用字符集来匹配任何一个-、)、(、。、或空格一次或多次。它使用<code class="fe lh li lj lk b">split</code>方法将每个数字分割成一个数字数组，然后用一个连字符连接起来。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h2 id="1ed8" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">比赛</h2><p id="6a2e" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated"><code class="fe lh li lj lk b"><strong class="jm io">match()</strong></code>方法检索将<em class="ls">字符串</em>与<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">正则表达式</a>进行匹配的结果。— MDN</p><p id="ec8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们之前讨论过这个问题，但这里有另一个来自代码战挑战的例子。任务就是简单地计算一个字符串中小写字母的总数。全局标记告诉match查找所有匹配项，字符集[a-z]匹配任何小写字母。如前所述，我们添加了<code class="fe lh li lj lk b">|| []</code>，因为如果没有匹配，结果将是<code class="fe lh li lj lk b">undefined</code>，并且使用<code class="fe lh li lj lk b">length</code>方法将在<code class="fe lh li lj lk b">undefined</code>上抛出一个错误。</p><p id="01dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lh li lj lk b">const lowercaseCount = str =&gt; (str.match(/[a-z]/g) || []).length;</code></p><p id="0c29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://www.codewars.com/kata/56a946cd7bd95ccab2000055/javascript" rel="noopener ugc nofollow" target="_blank">https://www . codewars . com/kata/56 a 946 CD 7 BD 95 ccab 2000055/JavaScript</a></p><h2 id="7146" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">火柴人</h2><p id="5b62" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated"><code class="fe lh li lj lk b"><strong class="jm io">matchAll()</strong></code>方法根据<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank"> <em class="ls">正则表达式</em> </a>返回匹配一个字符串的所有结果的迭代器，包括<a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges" rel="noopener ugc nofollow" target="_blank">捕获组</a>。-MDN</p><p id="4d4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请耐心听我讲最后一个例子。假设您正在键入一个杂货提货订单(Covid times ),并且需要将该订单作为一个对象输入到一个支付软件中。下面的正则表达式查找字符串中所有匹配“# foodItem”格式的条目，并返回包含这些条目的迭代器。然后我们可以在迭代器上使用<code class="fe lh li lj lk b">for…of</code>来构建我们的对象。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="3779" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这些对您在使用这些正则表达式和字符串方法时遇到的更实际的情况有用。如果还有什么不明白的地方，或者如果你想了解更多关于JavaScript的不同主题，请在下面留下你的评论！</p></div></div>    
</body>
</html>