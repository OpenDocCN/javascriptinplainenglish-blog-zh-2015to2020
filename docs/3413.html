<html>
<head>
<title>Health Checks in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的健康检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/health-checks-in-nodejs-37fb2b1cdc65?source=collection_archive---------4-----------------------#2020-09-27">https://javascript.plainenglish.io/health-checks-in-nodejs-37fb2b1cdc65?source=collection_archive---------4-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/94f0f193d95d6f2f2ef1115f794c9997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNOc-gsW6aVQaPgKTNKYeQ.jpeg"/></div></div></figure><div class=""/><p id="42fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">微服务</strong>中最重要的模式之一是健康检查，它有助于检测无法处理请求的正在运行的服务实例，强制向管理员发送警报，并可能以重启服务等操作结束。</p><p id="4bc3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在这篇文章中谈以下几点:</p><ul class=""><li id="ad71" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">“健康检查”概念介绍</li><li id="20d4" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在NodeJS项目中实现健康检查</li><li id="f84b" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">这是一个简单的例子，说明了如何使用社区库，并根据自己的需要对其进行定制</li></ul></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h2 id="49a7" class="lr ls jb bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">为什么我们需要健康检查</h2><p id="6812" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">虽然软件架构已经将其应用向微服务架构和容器化发展，<strong class="ka jc">健康检查的需求开始成为强制性的</strong>。</p><p id="509b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该架构基于将业务单元划分为多个服务，并将每个服务划分为多个实例(横向扩展)，不同部分之间的通信通过网络进行<strong class="ka jc">，这增加了这些服务之一出现故障的可能性</strong>。</p><p id="4527" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，解决方案是实施描述每个微服务运行状况的端点，自动化作业可以从集群外部调用这些端点，并相应地通知管理员，此外，一些流程编排工具可以使用这些端点来重启服务。</p><p id="a37a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如今，大多数云提供商都支持这类易于配置的作业，当出现问题时，其中一些会在您的移动设备上通知您。</p><p id="c19a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想要深入了解健康检查，您可以查看下一篇文章:</p><div class="ip iq gp gr ir mp"><a href="https://dzone.com/articles/an-overview-of-health-check-patterns" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jc gy z fp mu fr fs mv fu fw ja bi translated">健康检查模式概述- DZone微服务</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">许多开发人员已经实现了一些现有的健康检查机制，尤其是现在，在“微服务时代”…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">dzone.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ix mp"/></div></div></a></div><h2 id="008d" class="lr ls jb bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">在健康检查中我们到底应该检查什么</h2><p id="a018" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">有些人只从健康检查端点返回HTTP 200成功响应，以确保微服务启动，<strong class="ka jc">但我认为检查微服务正在使用的资源和依赖性会更安全</strong>，如连接到数据库、缓存服务器、其他HTTP服务等。</p><p id="b3f6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，运行状况检查应该返回一个成功响应，其主体描述了每个依赖项的状态。</p><p id="601b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些框架已经支持这样的端点，你只需要像在Spring Boot那样进行配置。</p><p id="6282" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些运行状况检查超出了这一范围，如<strong class="ka jc">端到端运行状况检查</strong>，它就像检查外部依赖关系，但更进一步，因此它不是进行一次调用来检查服务是否可用，而是进行真正的业务流程，如插入数据，然后检查数据是否可用。</p><p id="3878" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，这些检查验证系统的整体行为是否正常，但这并不总是我们应该做的事情，它取决于系统的类型和业务逻辑。</p><h2 id="89bf" class="lr ls jb bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">在NodeJS中快速实现健康检查</h2><p id="30d8" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我发现了一个非常有趣的库，它已经有了大量的内置检查并支持NodeJS Express框架，您可以在这里找到它:</p><div class="ip iq gp gr ir mp"><a href="https://github.com/Bauer-Xcel-Media/node-healthchecks-api" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jc gy z fp mu fr fs mv fu fw ja bi translated">鲍尔-Xcel-媒体/节点-健康检查-api</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">Hootsuite提供的健康检查API的Node.js实现。npm安装-保存健康检查-api启用…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="ne l na nb nc my nd ix mp"/></div></div></a></div><p id="8727" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以检查MySql DB连接、Mongo DB连接、Redis连接、Elasticsearch、任何其他Http服务、<strong class="ka jc">并轻松添加适合您需求的自定义检查</strong>。</p><p id="1402" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该库中唯一的缺点是健康检查路由是静态的，所以我需要派生该库并添加使用config对象定义基本路由的功能。接下来您可以找到分叉的路径(我在自述文件中做了修改，这样您就可以知道在哪里定义基本路径):</p><div class="ip iq gp gr ir mp"><a href="https://github.com/AMhaish/node-healthchecks-api" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jc gy z fp mu fr fs mv fu fw ja bi translated">AMhaish/节点健康检查-api</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">Hootsuite提供的健康检查API的Node.js实现。npm安装-保存健康检查-api启用…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="nf l na nb nc my nd ix mp"/></div></div></a></div><p id="0ff0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用下一个npm包来安装它:</p><div class="ip iq gp gr ir mp"><a href="https://www.npmjs.com/package/healthchecks-apis" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jc gy z fp mu fr fs mv fu fw ja bi translated">运行状况检查-API</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">Hootsuite提供的健康检查API的Node.js实现。实现应用程序/服务组合健康…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="ng l na nb nc my nd ix mp"/></div></div></a></div><p id="d072" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">促使我添加该功能的主要原因是需要根据微服务提供不同的健康检查路线，对于购物微服务，我需要类似/购物/健康的路线，而对于产品微服务，我需要不同的类似/产品/健康的路线。</p><p id="2cf1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但仍然是最后一部分的路线定义为静态的现在，也许我会使它动态的未来，但不觉得这是非常重要的现在。</p><p id="928e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">我计划很快在这个分叉的支票上添加更多的支票。</strong></p><p id="41d0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢通过一个中间件来使用这个库，这个中间件将在启动微服务时被初始化:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/08cd5b9756dd5a37f04b7dc076a65c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ghcfp6FgJISPLJNNq2ZlWA.png"/></div></div></figure><p id="581f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在这里看到的，我正在检查到MySQL数据库的连接和到Redis缓存的连接。我正在从环境变量中获取参数，<strong class="ka jc">请不要忘记等待健康检查功能，否则它根本不会工作</strong>，因为没有等待健康检查完成，服务器就直接开始忽略库内定义的健康检查路径。</p><p id="104d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在定义我的服务器时，我需要如下初始化这个中间件:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/34ed70848fc32da320819c405637937b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kN-TgLsTrNxTpXxT44W-vg.png"/></div></div></figure><p id="88cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个简单的文件，肯定你会有更多的中间件和初始化的东西。我更喜欢总是实现服务器启动和停止功能，其中启动将返回相同的服务器，这将有助于控制器的单元和集成测试。</p><p id="5b51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用一个IoC容器来初始化中间件和服务，如果你感兴趣，可以看看下一个库:</p><div class="ip iq gp gr ir mp"><a href="https://www.npmjs.com/package/addict-ioc" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jc gy z fp mu fr fs mv fu fw ja bi translated">瘾君子-国际奥委会</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">Addict IoC是一个轻量级的IoC容器，具有流畅的声明语法，方便您的开发，并简化…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.npmjs.com</p></div></div><div class="my l"><div class="nn l na nb nc my nd ix mp"/></div></div></a></div><p id="3c59" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，我在中间件文件夹内的一个文件中定义所有中间件的名称，导出一个只包含中间件的键值对的对象(就像OOP语言中的enum)。所以IoC从中间件的名字就能理解它应该初始化的实例的类型。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="50ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章能够帮助您快速地在服务网格或应用程序中使用健康检查。</p><p id="a3bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我需要这一点时，我需要花费大量时间来研究如何在NodeJS中做到这一点，我尝试了不同的库，发现其中一个对我来说是最好的选择。所以我希望这会节省你的时间。</p></div></div>    
</body>
</html>