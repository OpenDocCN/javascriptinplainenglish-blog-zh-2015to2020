<html>
<head>
<title>Smooth Operator: Concurrent Mode in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">平滑运算符:React中的并发模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/smooth-operator-concurrent-mode-in-react-bf303de4c161?source=collection_archive---------13-----------------------#2020-04-27">https://javascript.plainenglish.io/smooth-operator-concurrent-mode-in-react-bf303de4c161?source=collection_archive---------13-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a87a76f6b7db77488ca5f25b59055c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PPkLZHj34kBI1WEhPi6AA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@cbyoung?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Clark Young</a> on <a class="ae jd" href="https://unsplash.com/s/photos/two-rivers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="f313" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">警告:在撰写本文时，并发模式是<em class="kv">而不是</em>尚未稳定，不应用于生产。</h2></div><p id="b86c" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并发模式是今年2月发布的一个实验性特性，随着React 16.13.0的发布。在深入研究该特性修复的问题之前，我们先来讨论一下React目前是如何工作的。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ls"><img src="../Images/cfdbc32d38db890760c243ad1c4fa5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kd3DqyFhtV1EZAG2IOElw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://burst.shopify.com/@ndekhors?utm_campaign=photo_credit&amp;utm_content=Free+Stock+Photo+of+Pedestrian+Stop+Light+%E2%80%94+HD+Images&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">Nicole De Khors</a> from <a class="ae jd" href="https://burst.shopify.com/light?utm_campaign=photo_credit&amp;utm_content=Free+Stock+Photo+of+Pedestrian+Stop+Light+%E2%80%94+HD+Images&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">Burst</a></figcaption></figure><h1 id="af75" class="lx ly jg bd lz ma mb mc md me mf mg mh km mi kn mj kp mk kq ml ks mm kt mn mo bi translated">分块渲染</h1><p id="53f9" class="pw-post-body-paragraph kw kx jg ky b kz mp kh lb lc mq kk le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">正如您可能知道的，如果您在React中花过时间进行开发，任何状态更改都会触发DOM和虚拟DOM之间的比较，如果发现两者之间有任何差异，就会触发组件的重新呈现。</p><p id="1a04" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个功能很棒，也很有帮助……大多数时候都是如此。通常，如果状态中的某些内容已经更新，并且状态中的数据显示在UI中，我们也会希望更新UI。</p><p id="b9a8" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当这些变化发生得如此之快，以至于一个重新渲染无法在另一个被触发之前完成时，会发生什么呢？或者，当用户的网络或设备刚刚过时，而且速度有点慢时，情况又会如何呢？你为你的用户得到了一个次优的体验——这就是所发生的。</p><p id="a596" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React使用了一种叫做“阻塞渲染”的东西，这简单地意味着，在渲染过程完成之前，所有其他渲染都被阻塞。在上面提到的快速连续和过时的设备场景中，阻止渲染会造成某种视觉上的断续。这种视觉上的停顿是DOM试图跟上用户正在做的事情。</p><p id="c1a6" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑这样一个场景，您的用户正在筛选数千条记录，使用的输入随着用户键入内容进行筛选。对于每封打出的信，这是一个过程:</p><ol class=""><li id="05b6" class="mu mv jg ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">调用更改处理程序时</li><li id="c17a" class="mu mv jg ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">输入在状态中更新</li><li id="8a84" class="mu mv jg ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">已过滤项目的列表在状态中更新</li><li id="2fbb" class="mu mv jg ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">用新的过滤项目列表更新虚拟DOM</li><li id="89a8" class="mu mv jg ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">比较虚拟DOM和DOM，找出差异，重新呈现组件</li></ol><p id="34e2" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，通常在用户键入另一封信之前，这些都无法完成。随着用户不断键入，每个后续的重新渲染都被阻止，直到当前的渲染完成。</p><h1 id="e483" class="lx ly jg bd lz ma mb mc md me mf mg mh km mi kn mj kp mk kq ml ks mm kt mn mo bi translated">并发模式下的可中断渲染</h1><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/2247443eac27fecfd48977aa9264d58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcrBLFD8CJ4DtVTeAktb0g.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://www.pexels.com/@brennan-tolman-250017?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Brennan Tolman</a> from <a class="ae jd" href="https://www.pexels.com/photo/aerial-photo-of-four-cars-on-round-about-at-daytime-771925/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="8426" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并发模式是React对这种复杂性的回答。正如React文档所述:</p><blockquote class="nj nk nl"><p id="26e5" class="kw kx nm ky b kz la kh lb lc ld kk le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">并发模式是一组新功能，有助于React应用程序保持响应，并根据用户的设备功能和网络速度进行适当调整。</p></blockquote><p id="5560" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它通过引入可中断呈现来做到这一点。有了可中断呈现，浏览器不再被阻止可视地进行更新(例如，更新文本输入)<em class="nm">，因为它发生了</em>。它不再需要等待更改处理程序和输入状态更新以及过滤项状态更新和重新呈现的过程，只需进行显示一个附加字母的更改。尽管应用程序继续运行它的进程，但是只有当呈现完成时，DOM才会为用户更新。</p><p id="4fed" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，应用程序以同样的方式运行，但是用户体验得到了显著的改善。</p><h1 id="ac56" class="lx ly jg bd lz ma mb mc md me mf mg mh km mi kn mj kp mk kq ml ks mm kt mn mo bi translated">有意装载顺序</h1><p id="9126" class="pw-post-body-paragraph kw kx jg ky b kz mp kh lb lc mq kk le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">与可中断呈现一样，并发模式也引入了有意加载序列。有意加载序列是一个内置工具，允许应用程序在导航到不同页面时，停留在当前页面上，直到下一个页面“就绪”，即，直到页面被加载和数据被获取。在并发模式之外，这在技术上是可能实现的，但这并不容易。在并发模式下，它是内置的。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/0a0637daa18927716540fa3ac0d109a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spmB9ZQCwF83Vsn2hJtdbA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jd" href="https://unsplash.com/s/photos/caution?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4165" class="lx ly jg bd lz ma mb mc md me mf mg mh km mi kn mj kp mk kq ml ks mm kt mn mo bi translated">小心行事</h1><p id="1a32" class="pw-post-body-paragraph kw kx jg ky b kz mp kh lb lc mq kk le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我想重申的是，并发模式在撰写本文时(2020年4月)是纯实验性的，在它稳定之前不应用于生产。现在，你可以用<a class="ae jd" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a>更深入地研究它，并开始在开发中测试它。您还可以检查同一个链接，看看它何时变得稳定，可以投入生产。</p><h2 id="066f" class="nr ly jg bd lz ns nt dn md nu nv dp mh lf nw nx mj lj ny nz ml ln oa ob mn oc bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="ac54" class="pw-post-body-paragraph kw kx jg ky b kz mp kh lb lc mq kk le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae jd" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="ky jh"> AI in Plain English </strong> </a>，<a class="ae jd" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ky jh">UX in Plain English</strong></a>，<a class="ae jd" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ky jh">Python in Plain English</strong></a><strong class="ky jh"/>——谢谢，继续学习！</p><p id="0c2e" class="pw-post-body-paragraph kw kx jg ky b kz la kh lb lc ld kk le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jd" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky jh">submissions @ plain English . io</strong></a><strong class="ky jh"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>