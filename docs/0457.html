<html>
<head>
<title>Algorithms 101: Happy Number in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:JavaScript中的快乐数字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-happy-number-in-javascript-bddeb3d17035?source=collection_archive---------2-----------------------#2019-10-18">https://javascript.plainenglish.io/algorithms-101-happy-number-in-javascript-bddeb3d17035?source=collection_archive---------2-----------------------#2019-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="53fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉算法#14，使用。reduce()，递归和缺省参数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b266d95644e05e19fcbf243372ff0e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_7p2WimePj6nxzV3.jpg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">from wikimedia commons</figcaption></figure><p id="9b1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你曾经发现幸福难以捉摸，你会很高兴知道有一种叫做<a class="ae lr" href="https://en.wikipedia.org/wiki/Happy_number" rel="noopener ugc nofollow" target="_blank">幸福数字</a>的东西。LeetCode是这样描述的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/105a3fabbd83289968ecac613519ade3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TePQV68UA73IRAoMMPc3w.png"/></div></div></figure><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="7bf1" class="ly lz iq lu b gy ma mb l mc md">var isHappy = function(n){</span><span id="f030" class="ly lz iq lu b gy me mb l mc md">//write code here</span><span id="a71d" class="ly lz iq lu b gy me mb l mc md">}</span></pre><p id="7b1a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://leetcode.com/problems/happy-number/" rel="noopener ugc nofollow" target="_blank">这是LeetCode上挑战的链接。</a></p><h2 id="17ab" class="ly lz iq bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">那么，如果一个数字‘n’是快乐的，我们该如何编写返回<em class="mw"> true </em>的代码呢？</h2><p id="79b2" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">使用上面的示例，我们将遵循以下步骤:</p><ol class=""><li id="4283" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">把数字19分解成1和9。</li><li id="e917" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">平方每个数字</li><li id="e3d4" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">对平方求和</li><li id="ef5d" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">检查总和是否等于1</li><li id="c5fa" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">如果总和为1，则返回true</li><li id="5a69" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">否则，返回步骤1并重复。</li></ol><h2 id="ce5f" class="ly lz iq bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">第1步和第2步:将数字分解成几个数字，并对每个数字求平方</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a9f4250878b10db60e10aea18181cf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVld6XV-1gnwxSRousyJPA.png"/></div></div></figure><p id="c680" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设n是19。下面是上面的代码如何一步一步地工作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/49188d62409c2b95b6acb13f0815f044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goQWMvz9o13M8kSPH-g1pA.png"/></div></div></figure><h2 id="77fc" class="ly lz iq bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">第三步:求和，使用。减少()</h2><p id="4ad3" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">在JavaScript中，任何时候想要将数组简化为单个值，都可以使用reduce函数，该函数将一个函数作为参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/50dcda9f7d4632d36b1768d557bf37ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISK-sSAkpHZimlLLgtnNFw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">writing this out longhand to make it easier to understand!</figcaption></figure><p id="4c0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，array.reduce()接受一个回调函数。这个回调将总和设置为零的初始值。然后遍历数组中的每一项，</p><p id="b8bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一个循环中，它将<em class="nt"> currentItem </em>加到初始值0上。它将总和存储在<em class="nt">累加器中。</em>在后续循环中，将<em class="nt"> currentItem </em>加到<em class="nt">累加器</em>中。完成后，<em class="nt"> sum </em>等于数组中所有元素的总和。</p><h2 id="88fe" class="ly lz iq bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">图片帮忙！关于这是如何工作的优秀gif，<a class="ae lr" href="http://reduce.surge.sh/" rel="noopener ugc nofollow" target="_blank">请看这里。</a></h2><p id="6ffd" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">一旦你理解了这个概念，你就可以缩短你的。将()代码简化为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/56b86b1034f6d5ec3b6f169f460577d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxHd5VNsGpRvuHw1KJf7iA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">shorthand</figcaption></figure><h2 id="f77c" class="ly lz iq bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">步骤4和5:检查总和:如果总和等于1，则返回true。</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/3753e3f9b58a4a4e9573d741bff1f9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJAljev2Aq-7hQu5cyIJag.png"/></div></div></figure><h2 id="1c9f" class="ly lz iq bd mf mg mh dn mi mj mk dp ml le mm mn mo li mp mq mr lm ms mt mu mv bi translated">第六步，最难的部分:你到底如何重新开始？</h2><p id="b8a3" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">我想编写一个递归的解决方案，就像这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/80ad9e23a4ebf9c0669e7ab6f2ce8bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mT7DKSPgBfGLP8kANVyDg.png"/></div></div></figure><p id="f05f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果sum永远不等于1，这个函数将会无限循环下去。不不。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">obligatory infinite loop giphy</figcaption></figure><p id="28ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了阻止这种情况发生，我们需要一个基本案例。换句话说，我们希望这个函数什么时候停止调用自己？</p><p id="8b66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一个数字是快乐的，<em class="nt"> sum </em>最终解析为1。但如果它不快乐，我不确定会发生什么(我不太懂数论)。所以我决定这个函数应该调用自己有限的次数。</p><p id="ab0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我想添加一个计数器。</p><p id="94ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这在递归函数中很难做到。我习惯在函数顶部附近给计数器设置一个初始值，即:<code class="fe nz oa ob lu b">let counter = 0</code>。但是如果你在一个递归函数中这样做，你的计数器在每次递归中被重置为零。</p><p id="352c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决这个问题，您可以将计数器作为默认值为零的参数传递给函数。</p><p id="8a66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果<em class="nt">计数器</em>传入一个值，该函数将使用该值；但是如果<em class="nt">计数器</em>传入时没有值，该函数会将<em class="nt">计数器</em>读取为0。(这里是关于默认参数的<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="noopener ugc nofollow" target="_blank"> MDN文档。)</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/0995c0a0122b81ae8686fd27b0405f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQaaseJBbCKjK68e6ddDKQ.png"/></div></div></figure><p id="328d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们打开它。</p><p id="e7cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将在函数结束时返回“result”。我们给结果一个假的初始值。</p><p id="1c98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，从第5行开始，只要我们尝试的次数少于8次，我们就将<code class="fe nz oa ob lu b">n</code>分解成它的数字，对它们求平方，对平方求和，并检查总和是否为1。如果是，我们设置<em class="nt">结果</em>等于<em class="nt">真</em>并且<em class="nt"> </em>退出循环。否则，我们递增计数器并重新开始。</p><p id="ead6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nt">注意:</em>首先我尝试了5作为最大循环次数；它没有通过LeetCode测试，所以我把数字增加到8，这确实有效。</p><p id="4c2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而且，效果很好！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/72b1c8b053de36fb1ca25673133bb47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5xAEBd5Ng8v1kU9rwlq_g.png"/></div></div></figure><p id="b335" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在repl.it上玩这个代码:<a class="ae lr" href="https://repl.it/@Joan_IndianaInd/Happy-Number" rel="noopener ugc nofollow" target="_blank">https://repl.it/@Joan_IndianaInd/Happy-Number</a></p><p id="555e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">版权所有琼·印第安纳·琳斯2019</p><p id="6e1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来:<a class="ae lr" href="https://medium.com/@joanrigdon/algorithms-101-can-place-flowers-in-javascript-b87c6cb1dc24" rel="noopener"> <em class="nt">算法101 #15，可以在JavaScript </em>中放置花朵</a></p><p id="645e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">万一你错过了:<a class="ae lr" href="https://medium.com/javascript-in-plain-english/algorithms-101-pascals-triangle-in-javascript-9fbd9032871" rel="noopener"> <em class="nt">算法101，# 13:JavaScript中的帕斯卡三角</em> </a></p></div></div>    
</body>
</html>