<html>
<head>
<title>NgOnInit vs Constructor in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NgOnInit与Angular中的构造函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/ngoninit-vs-constructor-in-angular-75db8cfa0e17?source=collection_archive---------2-----------------------#2020-04-29">https://javascript.plainenglish.io/ngoninit-vs-constructor-in-angular-75db8cfa0e17?source=collection_archive---------2-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0057afa3c84e3d8105eec1957414f663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wz3xbcmOQS1tOvb_6mTf8g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by Uriel Soberanes on Unsplash</figcaption></figure><p id="f548" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每当我们在Angular应用程序中使用组件时，在某一点上，我们会发现，我们编写的一些东西可以合理地放在<code class="fe la lb lc ld b">ngOnInit</code>阶段或构造器阶段。这提出了以下问题:</p><ul class=""><li id="9c70" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz lj lk ll lm bi translated">什么时候用<code class="fe la lb lc ld b">ngOninit</code>什么时候用构造函数？</li><li id="4551" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">它们之间有什么区别？</li></ul><p id="7a2e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我解释一下什么是构造函数和<code class="fe la lb lc ld b">ngOnInit </code>方法</p><h1 id="b0b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">构造器</h1><p id="678c" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">构造函数是一个函数，每当创建一个类的实例时都会被调用。它不需要任何角度代码。它内置于Typescript中。</p><p id="610f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以如果我们有类用户</p><pre class="mv mw mx my gt mz ld na nb aw nc bi"><span id="bf5d" class="nd lt iq ld b gy ne nf l ng nh">class User{<br/>    username:string;<br/>    password:string;<br/>    <br/>    constructor(){<br/>       console.log("I've been called");<br/>    }<br/>}</span></pre><p id="d49b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每当我们创建一个类实例时</p><pre class="mv mw mx my gt mz ld na nb aw nc bi"><span id="c1bd" class="nd lt iq ld b gy ne nf l ng nh">const user1 = new User();</span></pre><p id="7ecf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的构造函数将被调用</p><h2 id="2e94" class="nd lt iq bd lu ni nj dn ly nk nl dp mc kn nm nn mg kr no np mk kv nq nr mo ns bi translated">如果我们跳过一个构造函数呢？</h2><p id="1432" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">什么都不会发生。将调用默认的构造函数，如下所示</p><pre class="mv mw mx my gt mz ld na nb aw nc bi"><span id="2d0f" class="nd lt iq ld b gy ne nf l ng nh">constructor(){}</span></pre><h2 id="b169" class="nd lt iq bd lu ni nj dn ly nk nl dp mc kn nm nn mg kr no np mk kv nq nr mo ns bi translated">组件作为类</h2><p id="0ce9" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">Angular中的组件只不过是一个typescript类。所以Angular必须创建它，就像我们在用户类上做的那样(可能是更复杂的方式)。</p><p id="bb98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们深入研究Angular源代码，以检验我们的假设。</p><p id="e022" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在angular应用程序中添加子组件</p><pre class="mv mw mx my gt mz ld na nb aw nc bi"><span id="2aa4" class="nd lt iq ld b gy ne nf l ng nh"><a class="ae nt" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  selector: "app-child",<br/>  template: `&lt;h1&gt;I am child&lt;/h1&gt;`,<br/>  styleUrls: ["./child.component.scss"],<br/>})<br/>export class ChildComponent implements OnInit {<br/>  constructor() {<br/>    debugger;<br/>  }<br/>}</span></pre><p id="f3d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将它添加到视图中的某个位置，运行到浏览器中，并打开开发人员工具。如果我们上一步调用堆栈，我们将看到一个名为<code class="fe la lb lc ld b">createClass</code>的方法，其实现如下</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="12f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Angular所做的是，它以最简单的方式启动了我们的课程。它只是调用我们的构造函数，如果我们有一些注入，它会尝试解析它们并为我们注入。</p><p id="aecd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以现在，我们的组件只有注入和我们定义的字段。组件没有任何视图或数据绑定值。只是简单的类及其字段。</p><p id="7eb2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们看看<code class="fe la lb lc ld b">ngOnInit </code>是如何工作的</p><h1 id="e99a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">ngOnInit在行动</h1><p id="0c57" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated"><code class="fe la lb lc ld b">ngOnInit </code>无非是我们对一个类的自定义方法。对于Typescript来说，这并不意味着什么，对于Javascript来说，这也不是什么基本概念。它只是你的应用程序和Angular框架之间的一个契约。根据合同，您的应用程序和Angular同意，无论Angular何时调用<code class="fe la lb lc ld b">ngOnInit </code>方法，您的组件都将被完全初始化。我在组件初始化中的意思是什么？</p><p id="0ade" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae nt" href="https://angular.io/api/core/OnInit#methods" rel="noopener ugc nofollow" target="_blank"> <em class="nw">在默认变更检测器第一次检查了指令的数据绑定属性之后，并且在检查任何视图或内容子元素之前，立即调用的回调方法。它只在指令实例化时调用一次。</em> </a></p><p id="4a70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简单来说，这意味着在输入属性被评估之后，组件视图被初始化之前，<code class="fe la lb lc ld b">ngOnInit </code>被调用</p><p id="b135" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，如果我们向组件添加一些输入属性</p><pre class="mv mw mx my gt mz ld na nb aw nc bi"><span id="3095" class="nd lt iq ld b gy ne nf l ng nh">...</span><span id="6d97" class="nd lt iq ld b gy nx nf l ng nh"><a class="ae nt" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>()<br/>name:string;</span><span id="b2d0" class="nd lt iq ld b gy nx nf l ng nh">...</span></pre><p id="8364" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">并从父组件传递值</p><pre class="mv mw mx my gt mz ld na nb aw nc bi"><span id="0ed7" class="nd lt iq ld b gy ne nf l ng nh">&lt;app-child name="John Doe"&gt; &lt;/app-child&gt;</span></pre><p id="7494" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个值将被评估，我们可以在这个字段上工作，在我们的<code class="fe la lb lc ld b">ngOnInit </code>方法中。</p><p id="a70f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了让Angular实现这一点，它调用了所有组件的变化检测。如果是第一次检查一个组件，它调用<code class="fe la lb lc ld b">ngOnInit</code>方法。</p><p id="2b02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">记住<code class="fe la lb lc ld b">ngOnInit</code>只是一个想象的方法，它可以不叫<code class="fe la lb lc ld b">ngOnInit</code>，而叫<code class="fe la lb lc ld b">ngIamAlive</code>。</p><h1 id="3111" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">NgOnInit与构造函数的区别</h1><p id="bff1" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">总而言之，构造函数是:</p><ul class=""><li id="5615" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz lj lk ll lm bi translated">本机类型脚本/javascript功能</li><li id="97df" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">它在组件的任何事件侦听器之前被调用</li><li id="c8ca" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">到那时，一个组件只有注入和定义的字段</li></ul><p id="5e56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个<code class="fe la lb lc ld b">ngOnInit</code>是:</p><ul class=""><li id="01f5" class="le lf iq ke b kf kg kj kk kn lg kr lh kv li kz lj lk ll lm bi translated">一个假想的方法，Angular和用户应用程序都同意。</li><li id="38f7" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">它是在构造函数方法之后调用的</li><li id="64ac" class="le lf iq ke b kf ln kj lo kn lp kr lq kv lr kz lj lk ll lm bi translated">当组件初始化完所有数据绑定字段时</li></ul><h1 id="487a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">什么时候使用NgOnInit，什么时候使用构造函数？</h1><p id="e3db" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">就我个人而言，我每次都使用<code class="fe la lb lc ld b">ngOnInit</code>，因为我在一个方法中看到了整个初始化过程。</p><p id="2b04" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在执行速度或性能上没有区别，两者具有完全相同的指标</p><p id="2383" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以使用一个构造函数，例如，使用<code class="fe la lb lc ld b">FormBuilder</code>类构建你的表单组。</p><p id="4a1d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但无论如何，在我的整个职业生涯中，我从来没有更喜欢使用构造函数而不是<code class="fe la lb lc ld b">ngOnInit</code></p><p id="aa62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以我建议你坚持使用ngOnInit :P</p></div></div>    
</body>
</html>