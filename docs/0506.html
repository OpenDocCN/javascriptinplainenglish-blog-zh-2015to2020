<html>
<head>
<title>React in 7 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7分钟后做出反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-in-7-minutes-a4fe81eb13ef?source=collection_archive---------3-----------------------#2019-10-30">https://javascript.plainenglish.io/react-in-7-minutes-a4fe81eb13ef?source=collection_archive---------3-----------------------#2019-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="00fa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React.js的简明介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fd839b89f2e2d5fa5553745133831a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lgogxu6VrBsgsPDkjQTf_Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Watch How Fast</figcaption></figure><p id="e222" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React是最重要的前端开发框架是有原因的。</p><p id="d919" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">乍一看这似乎很复杂，但实际上很容易理解。本指南将为您一一解析。</p><p id="46ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是我们将要介绍的React要点。</p><ul class=""><li id="1da3" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">基于组件的</li><li id="5b74" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数据DOM绑定</li><li id="6ecf" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">组件定义</li><li id="3937" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">组件嵌套</li><li id="f175" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">组件交互</li><li id="06a8" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">重复</li><li id="0f44" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">事件处理</li><li id="2d5e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">状态更新</li><li id="8c92" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">JSX</li></ul><p id="69ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看我们能多快报道这件事。</p><blockquote class="mf"><p id="c6c4" class="mg mh iq bd mi mj mk ml mm mn mo lq dk translated">前面没有废话。</p></blockquote><h1 id="1ec1" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">基于组件的</h1><p id="77db" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">React是一个基于组件的UI框架。基于组件的UI的本质是视图由多个代表其部分的组件组成。</p><p id="fa0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本质上，React维护了一个组件树，然后这些组件被表示为在屏幕上看到的内容。如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6c643db689dc24204f0150965187aa0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*R4EQWqWND0-IeMKS"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4e1a637ec8e90ed627371c0a258aa362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/0*i_GBpBe_xqe02R0M.png"/></div></figure><p id="8c44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看这在代码中是如何工作的。</p><p id="e618" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码在JSFiddle <a class="ae no" href="https://jsfiddle.net/mtyson/bcnyrfum/9/" rel="noopener ugc nofollow" target="_blank">这里</a>是活的。</p><p id="50ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们正在创建的(到目前为止):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">First Version End Result</figcaption></figure><p id="7f9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简单:显示一个父div和一个子div。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="3bb1" class="mp mq iq bd mr ms ny mu mv mw nz my mz jw oa jx nb jz ob ka nd kc oc kd nf ng bi translated">单根容器元素</h1><p id="bc46" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">首先要记住的是，有一个<em class="od">根元素。因此，我们的HTML页面中的标记如下所示:</em></p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="d3fb" class="oj mq iq of b gy ok ol l om on">&lt;div id=”container”&gt;<br/>&lt;/div&gt;</span></pre><p id="6758" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们告诉React我们想对这个标记做什么。(请注意，JSFiddle中已经包含了React minified发行版。)</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="966a" class="oj mq iq of b gy ok ol l om on">class Parent extends React.Component {<br/> render() {<br/> return &lt;div class=”parent”&gt;Parent<br/>   &lt;Child&gt;&lt;/Child&gt;<br/> &lt;/div&gt;;<br/> }<br/>}class Child extends React.Component {<br/> render() {<br/> return &lt;div class=”child”&gt;child&lt;/div&gt;;<br/> }<br/>}ReactDOM.render(<br/> &lt;Parent /&gt;,<br/> document.getElementById(‘container’)<br/>);</span></pre><p id="34c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">别担心，这个其实很简单。</p><p id="d31a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，跳到最后一条语句，在那里它调用了<code class="fe oo op oq of b">ReactDOM.render(...)</code>这是React get与你的HTML DOM关联的地方。</p><ul class=""><li id="7226" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">第一个参数(<code class="fe oo op oq of b">&lt;Parent/&gt;</code>)告诉React“这些是您将绘制的组件”</li><li id="705a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">第二个论点<code class="fe oo op oq of b">document.getElementById('container')</code>说:“这是画他们的地方。”</li></ul><p id="746f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oo op oq of b">&lt;Parent /&gt;</code>元素是一个JSX元素，类似于一个定制的HTML元素。</p><h1 id="1f66" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">JSX</h1><p id="937c" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">不要太担心前面的JSX，它实际上是一个相当不令人惊讶的技术。它允许类似HTML的标记和JavaScript一起使用。最后变成JS代码输出你的组件。</p><p id="8f33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一般来说，你可以把JSX想象成拥有JS超能力的HTML(或者如果你愿意，也可以把JS想象成拥有HTML超能力的HTML)。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="758f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，让我们看看JSX是如何知道为<code class="fe oo op oq of b">&lt;Parent /&gt;</code>标签放置什么的。</p><p id="fcae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这项工作直接在上面的JS中完成，我们在那里定义父组件:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="f57d" class="oj mq iq of b gy ok ol l om on">class Parent extends React.Component {<br/> render() {<br/>   return &lt;div class=”parent”&gt;Parent<br/>     &lt;Child&gt;&lt;/Child&gt;<br/>   &lt;/div&gt;;<br/> }<br/>}</span></pre><p id="96eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还有一个渲染方法。这一次，render方法返回一个简单的div，其中包含一个类、一些文本内容和另一个名为Child的组件。</p><h1 id="dd43" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">组件嵌套</h1><p id="17cf" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated"><code class="fe oo op oq of b">&lt;Child&gt;</code>引用是组件嵌套的一个例子。</p><p id="a8e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就在父组件定义的下面，是子组件，也很简单。</p><p id="a877" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以看到这些组件(用一点CSS)如何变成我们看到的输出。到目前为止，它看起来只是一种迂回的HTML输出方式。</p><p id="2578" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是组件的强大之处在于，正如我们所看到的，它们不仅仅包含视图。它们还包含行为和状态。</p><h1 id="d7c8" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">数据DOM绑定</h1><p id="93cc" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">我所说的数据bom绑定是指框架负责将应用程序中的数据绑定到浏览器DOM中的表达式或表现形式。这与jQuery不同，在jQuery中，大部分框架和开发人员都在维护这种一致性。</p><p id="91bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实证明，这是一个非常强大且能提高生产力的想法。它支撑着React、Vue和Angular的快速提升。</p><p id="92c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React组件中基本上有两种数据:</p><ul class=""><li id="f24c" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">属性(或<em class="od">道具</em>)</li><li id="4085" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">状态</li></ul><h1 id="e322" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">性能</h1><p id="c581" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">首先:属性。</p><p id="7e3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Props是通过元素属性从外部设置的组件数据(因此得名props)。本质上，标记属性允许组件中的数据通信。</p><p id="849d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是更新的小提琴:<a class="ae no" href="https://jsfiddle.net/fy0rpvtm/1/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/fy0rpvtm/1/</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result with Data Binding</figcaption></figure><p id="cdd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，请注意父构件的视图样板已更改，以包含一个属性:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="a892" class="oj mq iq of b gy ok ol l om on">Parent, called {this.props.name}</span></pre><p id="4499" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们可以从JSX模板引用<code class="fe oo op oq of b">this</code>并引用组件，就像它是一个对象一样——它就是这样。</p><p id="c032" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe oo op oq of b">this.props</code>指组件对象上的属性集。这是组件状态的一部分；它是从外部传入组件的部分。</p><p id="4dbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你怎么告诉组件这个道具会是什么？</p><p id="9013" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一种方法是在这里完成:当使用组件时，在组件上显式设置它:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="af80" class="oj mq iq of b gy ok ol l om on">&lt;Parent name=”John Lennon”/&gt;</span></pre><p id="568a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想在这里真正地强调一点，我们正在做的是将状态的可用性分离到组件中，并在该组件的<em class="od"> use </em>中指定该状态的内容。</p><p id="75a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，组件定义与其属性的规范完全分离。</p><h1 id="7779" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">状态</h1><p id="0689" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">现在，以类似的方式，组件展示了一个<em class="od">状态</em>成员属性。组件的内部状态。</p><p id="dfc2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">状态只是把变量放在组件内部，只有它自己看得见。状态不是直接从外部设置的。</p><p id="1ad0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是更新后的提琴使用状态:<a class="ae no" href="https://jsfiddle.net/89k1zcdp/4/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/89k1zcdp/</a></p><p id="613b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，我们将以编程方式在构造函数中设置父状态:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="3887" class="oj mq iq of b gy ok ol l om on">constructor(props) {<br/> super(props); // Normal JS call to super, req'd for react<br/> this.state = { // Set the state<br/> children: [<br/>     {name: “Julien Lennon”},<br/>     {name: “Sean Lennon”}<br/>   ]<br/> }<br/>}</span></pre><p id="0b48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">侧边栏:<code class="fe oo op oq of b">constructor</code>是对象上的一个方法，在创建对象时被调用。</p><p id="231a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有其他设置状态的方法。状态可以与props菊花链连接，以便prop初始化状态(这不是直接完成的，但是，它通过JS代码将两者联系在一起)。或者，可以通过调用后端来设置状态。</p><p id="f4bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本质上，我们获取内置的state成员属性，并赋予它一个“children”属性，然后直接在JSON中设置它。同样，这可能来自后端或任何地方的用户输入。</p><h1 id="78b4" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">重复</h1><p id="3485" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">现在让我们看看如何以迭代的方式输出它:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="4c91" class="oj mq iq of b gy ok ol l om on">&lt;ul&gt;<br/> {this.state.children.map(function(child, index){<br/>   return &lt;li key={ index }&gt;{child.name}&lt;/li&gt;;<br/> })}<br/> &lt;/ul&gt;</span></pre><p id="1273" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用JSX的能力来交错标记和JS，我们使用前面初始化的<code class="fe oo op oq of b">this.state.children</code>对象，并使用JS <code class="fe oo op oq of b">.map</code>函数来输出一个列表项。</p><p id="ae05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们想使用我们的子组件。我们可以像这样更新父视图模板:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="0468" class="oj mq iq of b gy ok ol l om on">return &lt;div class=”parent”&gt;Parent, called {this.props.name}<br/> {this.state.children.map((child, index) =&gt; {<br/> return (<br/> &lt;Child name={child.name} /&gt;<br/> );<br/> })}</span></pre><p id="12e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们没有使用HTML的和LI元素，而是使用了之前看到的子组件，并将迭代数据作为道具传递给子组件。</p><p id="8275" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以子组件可以反映这个道具，我们给它添加视图标记:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="3038" class="oj mq iq of b gy ok ol l om on">class Child extends React.Component {<br/>  render() {<br/>    return &lt;div class=”child”&gt;Child named {this.props.name}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="b86b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新提琴:<a class="ae no" href="https://jsfiddle.net/89k1zcdp/10/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/89k1zcdp/10/</a></p><p id="3f9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样给你迭代感和亲子沟通感。</p><p id="f43f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以你已经看到了组件、道具、状态、迭代和从父母到孩子的交流。这些是用React构建UI的核心元素。</p><p id="96b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们看看如何处理一个事件并删除一个子事件。</p><p id="654b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新提琴:<a class="ae no" href="https://jsfiddle.net/dybzphLw/12/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/89k1zcdp/12/</a></p><p id="11f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，我们在父列表中添加一个按钮:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="284e" class="oj mq iq of b gy ok ol l om on">&lt;div&gt;<br/>   &lt;Child name={child.name} /&gt;<br/>   &lt;button onClick={(e) =&gt; this.removeChild(index, e)}&gt;Remove&lt;/button&gt;<br/> &lt;/div&gt;</span></pre><p id="03b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们添加了带有<code class="fe oo op oq of b">onClick</code>处理程序的按钮元素。当按钮被点击时，它将执行指定的JS。</p><p id="6e1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们再次使用粗箭头符号来确保<code class="fe oo op oq of b">this</code>解析为组件对象，并使用它简单地重新路由对<code class="fe oo op oq of b">this.removeChild()</code>的调用，传入所单击的列表元素的索引。</p><p id="1187" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在真正的应用程序中，我们最有可能使用驱动列表的数据中的主键。对于这个介绍，我们将只使用数组索引(由于JS不保证数组的排序，这并不安全)。</p><p id="b808" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们看看这个事件是如何处理的:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="b3b6" class="oj mq iq of b gy ok ol l om on">removeChild(index){<br/>  var array = […this.state.children]; <br/>  if (index !== -1) {<br/>    array.splice(index, 1);<br/>    this.setState({children: array});<br/>   }<br/> }</span></pre><p id="86d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将<code class="fe oo op oq of b">removeChild(index)</code>方法添加到与组件上的构造函数和<code class="fe oo op oq of b">render()</code>方法相同的级别。</p><h1 id="fcca" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">状态的“不变性”</h1><p id="62fd" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">当您查看这段代码时，要认识到的重要事情是:在ReactJS中，状态是不可直接修改的。通过<code class="fe oo op oq of b">setState()</code>只能<em class="od">修改</em>。考虑到这一点，<code class="fe oo op oq of b">removeChild()</code>方法变得非常不言自明:从状态中复制我们想要的数组，删除有问题的元素，然后用<code class="fe oo op oq of b">setState()</code>将新的、修改过的数组设置到对象状态中。</p><p id="48b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是最终的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Final Result</figcaption></figure><h1 id="910f" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw or jx nb jz os ka nd kc ot kd nf ng bi translated">包裹</h1><p id="12f6" class="pw-post-body-paragraph kv kw iq kx b ky nh jr la lb ni ju ld le nj lg lh li nk lk ll lm nl lo lp lq ij bi translated">这是一个快速，没有废话介绍反应的基本原则。</p><p id="d0a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这些技术，你就可以开始构建一套技能来构建高级的、设计良好的应用程序UI。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="3b28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">马特·泰森是<a class="ae no" href="http://www.darkhorse.tech/" rel="noopener ugc nofollow" target="_blank">黑马集团公司</a>的首席技术官</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/dffcdf76b2c8ceaba00ec449c233505e.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/0*-lOqtgy-iwch8oW1.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Dark Horse Group, Inc.</figcaption></figure><div class="ov ow gp gr ox oy"><a href="https://twitter.com/matttyson" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">马特·泰森</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">马特·泰森的最新推文(@matttyson):“来自寒冷的非常棒的版本！鲍勃马利和…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">twitter.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kp oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://www.linkedin.com/in/matt444/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">Matt Tyson -软件架构师-公司机密| LinkedIn</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">查看马特·泰森在全球最大的职业社区LinkedIn上的个人资料。马特有13项工作列在他们的…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.linkedin.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm kp oy"/></div></div></a></div></div></div>    
</body>
</html>