<html>
<head>
<title>Guide for Mastering Modern JavaScript skills</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握现代JavaScript技能指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/guide-for-mastering-modern-javascript-skills-7d4ee42bf009?source=collection_archive---------1-----------------------#2020-12-09">https://javascript.plainenglish.io/guide-for-mastering-modern-javascript-skills-7d4ee42bf009?source=collection_archive---------1-----------------------#2020-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3037" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">成为现代JavaScript专家，更擅长React、Angular、Vue</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/afd9be8aab6dff4f0c3217dfbf13caae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aHn0Xy3LHZF0TdDc"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3d3e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在当今不断变化的世界中，JavaScript出现了许多新内容和更新，这对提高代码质量非常有用。</p><p id="3787" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无论是为了获得一份高薪工作，还是为了跟上最新趋势、提高代码质量，或者是为了维持你目前的工作，了解这些事情都非常重要。</p><p id="9e5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">JavaScript中有许多最新的添加，如<strong class="kv io"> Nullish合并运算符</strong>、<strong class="kv io">可选链接</strong>、<strong class="kv io">承诺</strong>、<strong class="kv io">异步/等待</strong>、<strong class="kv io"> ES6析构</strong>，以及许多其他非常有用的特性。</p><p id="56ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们探索一些你应该知道的现代JavaScript技巧。</p><h1 id="2762" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">让和const</h1><p id="5327" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在ES6出现之前，JavaScript使用的是<code class="fe mm mn mo mp b">var</code>关键字，所以JavaScript只有一个函数和全局范围。没有块级范围。</p><p id="0d1f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">随着<code class="fe mm mn mo mp b">let</code>和<code class="fe mm mn mo mp b">const</code>的加入，JavaScript增加了块范围。</p><p id="dfe7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用let: </strong></p><p id="44c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们使用<code class="fe mm mn mo mp b">let</code>关键字声明一个变量时，我们<strong class="kv io">可以稍后给</strong>分配一个新值，但是我们<strong class="kv io">不能用相同的名字重新声明</strong>。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="413a" class="mu lq in mp b gy mv mw l mx my">// ES5 Code<br/>var value = 10;<br/>console.log(value); // 10</span><span id="5afb" class="mu lq in mp b gy mz mw l mx my">var value = "hello";<br/>console.log(value); // hello</span><span id="59b2" class="mu lq in mp b gy mz mw l mx my">var value = 30;<br/>console.log(value); // 30</span></pre><p id="babc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从上面可以看出，我们已经多次使用关键字<code class="fe mm mn mo mp b">var</code>重新声明了变量<code class="fe mm mn mo mp b">value</code>。</p><p id="8161" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在ES6之前，我们能够重新声明一个之前已经声明过的变量，这个变量没有任何有意义的用途，反而会引起混乱。</p><p id="a77a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们已经在其他地方声明了一个同名的变量，而我们在不知道我们已经有了这个变量的情况下重新声明了它，那么我们可能会覆盖变量值，导致一些难以调试的问题。</p><p id="3e22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以当使用<code class="fe mm mn mo mp b">let</code>关键字时，当你试图用相同的名字重新声明变量时，你会得到一个错误，这是一件好事。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="b6fd" class="mu lq in mp b gy mv mw l mx my">// ES6 Code<br/>let value = 10;<br/>console.log(value); // 10</span><span id="6a54" class="mu lq in mp b gy mz mw l mx my">let value = "hello"; // Uncaught SyntaxError: Identifier 'value' has already been declared</span></pre><p id="e97c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，下面的代码是有效的</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="a8f2" class="mu lq in mp b gy mv mw l mx my">// ES6 Code<br/>let value = 10;<br/>console.log(value); // 10</span><span id="b5e7" class="mu lq in mp b gy mz mw l mx my">value = "hello";<br/>console.log(value); // hello</span></pre><p id="618a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们在上面的代码中没有得到错误，因为我们<strong class="kv io">给<code class="fe mm mn mo mp b">value</code>变量</strong>重新赋值，但是<strong class="kv io">没有再次声明</strong> <code class="fe mm mn mo mp b">value</code>。</p><p id="1a6b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，看一下下面的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="9641" class="mu lq in mp b gy mv mw l mx my">// ES5 Code<br/>var isValid = true;<br/>if(isValid) {<br/>  var number = 10;<br/>  console.log('inside:', number); // inside: 10<br/>}<br/>console.log('outside:', number); // outside: 10</span></pre><p id="2239" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你在上面的代码中看到的，当我们用<code class="fe mm mn mo mp b">var</code>关键字声明一个变量时，它在<code class="fe mm mn mo mp b">if</code>块之外也是可用的。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="b6c0" class="mu lq in mp b gy mv mw l mx my">// ES6 Code<br/>let isValid = true;<br/>if(isValid) {<br/>  let number = 10;<br/>  console.log('inside:', number); // inside: 10<br/>}</span><span id="706e" class="mu lq in mp b gy mz mw l mx my">console.log('outside:', number); // Uncaught ReferenceError: number is not defined</span></pre><p id="ceab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你在上面的代码中看到的，使用<code class="fe mm mn mo mp b">let</code>关键字声明的<code class="fe mm mn mo mp b">number</code>变量只能在if块内部访问，而在块外部是不可用的，所以当我们试图在if块外部访问它时，我们得到了一个引用错误。</p><p id="17c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是如果在if块之外有一个<code class="fe mm mn mo mp b">number</code>变量，那么它将如下所示工作:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="5f66" class="mu lq in mp b gy mv mw l mx my">// ES6 Code<br/>let isValid = true;<br/>let number = 20;</span><span id="fbee" class="mu lq in mp b gy mz mw l mx my">if(isValid) {<br/>  let number = 10;<br/>  console.log('inside:', number); // inside: 10<br/>}</span><span id="c343" class="mu lq in mp b gy mz mw l mx my">console.log('outside:', number); // outside: 20</span></pre><p id="f2d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我们在一个单独的范围内有两个<code class="fe mm mn mo mp b">number</code>变量。所以在if块之外，<code class="fe mm mn mo mp b">number</code>的值将是20。</p><p id="5600" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看看下面的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="721e" class="mu lq in mp b gy mv mw l mx my">// ES5 Code<br/>for(var i = 0; i &lt; 10; i++){<br/> console.log(i);<br/>}<br/>console.log('outside:', i); // 10</span></pre><p id="3094" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当使用<code class="fe mm mn mo mp b">var</code>关键字时，<code class="fe mm mn mo mp b">i</code>甚至在<code class="fe mm mn mo mp b">for</code>循环之外也是可用的。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="7f92" class="mu lq in mp b gy mv mw l mx my">// ES6 Code<br/>for(let i = 0; i &lt; 10; i++){<br/> console.log(i);<br/>}</span><span id="7e10" class="mu lq in mp b gy mz mw l mx my">console.log('outside:', i); // Uncaught ReferenceError: i is not defined</span></pre><p id="1bbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是当使用<code class="fe mm mn mo mp b">let</code>关键字时，在循环之外是不可用的。</p><p id="cbcb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，从上面的代码示例中可以看出，使用<code class="fe mm mn mo mp b">let</code>关键字使得变量只能在该块内部使用，而在块外部是不可访问的。</p><p id="9c40" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也可以通过一对像这样的花括号创建一个块:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="99c1" class="mu lq in mp b gy mv mw l mx my">let i = 10;<br/>{<br/> let i = 20;<br/> console.log('inside:', i); // inside: 20<br/> i = 30;<br/> console.log('i again:', i); // i again: 30<br/>}</span><span id="12fb" class="mu lq in mp b gy mz mw l mx my">console.log('outside:', i); // outside: 10</span></pre><p id="56e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你还记得，我说过我们不能在同一个块中重新声明一个基于<code class="fe mm mn mo mp b">let</code>的变量，但是我们可以在另一个块中重新声明它。从上面的代码中可以看出，我们已经重新声明了<code class="fe mm mn mo mp b">i</code>，并在块中为<code class="fe mm mn mo mp b">20</code>分配了一个新值，一旦声明，该变量值将只在该块中可用。</p><p id="64db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在块外，当我们打印该变量时，我们得到的是<code class="fe mm mn mo mp b">10</code>而不是之前分配的值<code class="fe mm mn mo mp b">30</code>，因为在块外，内部的<code class="fe mm mn mo mp b">i</code>变量不存在。</p><p id="c618" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们没有在外面声明变量<code class="fe mm mn mo mp b">i</code>，那么我们将得到一个错误，如下面的代码所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="3078" class="mu lq in mp b gy mv mw l mx my">{<br/> let i = 20;<br/> console.log('inside:', i); // inside: 20<br/> i = 30;<br/> console.log('i again:', i); // i again: 30<br/>}</span><span id="a1f4" class="mu lq in mp b gy mz mw l mx my">console.log('outside:', i); // Uncaught ReferenceError: i is not defined</span></pre><p id="3be4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用常量:</strong></p><p id="4b44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe mm mn mo mp b">const</code>关键字与块范围功能中的<code class="fe mm mn mo mp b">let</code>关键字完全相同。所以让我们来看看它们之间有什么不同。</p><p id="7ab2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们声明一个变量为<code class="fe mm mn mo mp b">const</code>时，它被认为是一个常量变量，其值永远不会改变。</p><p id="89eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe mm mn mo mp b">let</code>的例子中，我们可以像这样给这个变量赋值:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="588a" class="mu lq in mp b gy mv mw l mx my">let number = 10;<br/>number = 20;</span><span id="72ac" class="mu lq in mp b gy mz mw l mx my">console.log(number); // 20</span></pre><p id="119a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是我们不能这样做，以防<code class="fe mm mn mo mp b">const</code></p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="2034" class="mu lq in mp b gy mv mw l mx my">const number = 10;<br/>number = 20; // Uncaught TypeError: Assignment to constant variable.</span></pre><p id="75fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们甚至不能将重新声明为<code class="fe mm mn mo mp b">const</code>变量。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="c97f" class="mu lq in mp b gy mv mw l mx my">const number = 20;<br/>console.log(number); // 20</span><span id="0cbc" class="mu lq in mp b gy mz mw l mx my">const number = 10; // Uncaught SyntaxError: Identifier 'number' has already been declared</span></pre><p id="9020" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，看一下下面的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="dd35" class="mu lq in mp b gy mv mw l mx my">const arr = [1, 2, 3, 4];</span><span id="ac74" class="mu lq in mp b gy mz mw l mx my">arr.push(5);</span><span id="16f0" class="mu lq in mp b gy mz mw l mx my">console.log(arr); // [1, 2, 3, 4, 5]</span></pre><p id="4177" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们说过<code class="fe mm mn mo mp b">const</code>变量是常量，其值永远不会改变，但我们已经改变了上面的常量数组。那么这难道不矛盾吗？</p><blockquote class="na nb nc"><p id="3890" class="kt ku nd kv b kw kx jo ky kz la jr lb ne ld le lf nf lh li lj ng ll lm ln lo ig bi translated"><em class="in">不是。在JavaScript中数组是引用类型而不是原始类型</em></p></blockquote><p id="4146" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以实际存储在<code class="fe mm mn mo mp b">arr</code>中的不是实际的数组，而是实际数组存储的内存位置的引用(地址)。</p><p id="8706" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以通过做<code class="fe mm mn mo mp b">arr.push(5);</code>，我们实际上并没有改变<code class="fe mm mn mo mp b">arr</code>指向的引用，而是改变了存储在那个引用中的值。</p><p id="a0f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对象也是如此:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="5dcc" class="mu lq in mp b gy mv mw l mx my">const obj = {<br/> name: 'David',<br/> age: 30<br/>};</span><span id="b380" class="mu lq in mp b gy mz mw l mx my">obj.age = 40;</span><span id="775f" class="mu lq in mp b gy mz mw l mx my">console.log(obj); // { name: 'David', age: 40 }</span></pre><p id="62cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我们也没有改变<code class="fe mm mn mo mp b">obj</code>所指向的引用，但是我们改变了存储在那个引用中的值。<br/>所以上面的代码可以工作，但是下面的代码不能工作。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="ad2c" class="mu lq in mp b gy mv mw l mx my">const obj = { name: 'David', age: 30 };<br/>const obj1 = { name: 'Mike', age: 40 };<br/>obj = obj1; // Uncaught TypeError: Assignment to constant variable.</span></pre><p id="b1fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的代码不起作用，因为我们试图改变<code class="fe mm mn mo mp b">const</code>变量指向的引用。</p><blockquote class="na nb nc"><p id="cb5f" class="kt ku nd kv b kw kx jo ky kz la jr lb ne ld le lf nf lh li lj ng ll lm ln lo ig bi translated"><em class="in">所以在使用</em> <code class="fe mm mn mo mp b"><em class="in">const</em></code> <em class="in">时要记住的关键点是，当我们使用</em> <code class="fe mm mn mo mp b"><em class="in">const</em></code> <em class="in">将一个变量声明为常量时，我们不能重新定义也不能重新分配那个变量，但是如果变量是引用类型，我们可以改变存储在那个位置的值。</em></p></blockquote><p id="e097" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以下面的代码是无效的，因为我们要给它重新赋值。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="21dc" class="mu lq in mp b gy mv mw l mx my">const arr = [1, 2, 3, 4];<br/>arr = [10, 20, 30]; // Uncaught TypeError: Assignment to constant variable.</span></pre><p id="64ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是请注意，我们可以改变数组内部的值，如前所述。</p><p id="2a42" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面重新定义<code class="fe mm mn mo mp b">const</code>变量的代码也是无效的。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="8112" class="mu lq in mp b gy mv mw l mx my">const name = "David";<br/>const name = "Raj"; // Uncaught SyntaxError: Identifier 'name' has already been declared</span></pre><h1 id="8cfd" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><ul class=""><li id="5823" class="nh ni in kv b kw mh kz mi lc nj lg nk lk nl lo nm nn no np bi translated">关键字<code class="fe mm mn mo mp b">let</code>和<code class="fe mm mn mo mp b">const</code>在JavaScript中增加了块范围。</li><li id="a656" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">当我们声明一个变量为<code class="fe mm mn mo mp b">let</code>时，我们不能<code class="fe mm mn mo mp b">re-define</code>或<code class="fe mm mn mo mp b">re-declare</code>另一个变量在同一个作用域(函数或块作用域)中有相同的名字，但是我们可以<code class="fe mm mn mo mp b">re-assign</code>给它赋值。</li><li id="2e7a" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">当我们将一个变量声明为<code class="fe mm mn mo mp b">const</code>时，我们不能在同一作用域(函数或块作用域)中<code class="fe mm mn mo mp b">re-define</code>或<code class="fe mm mn mo mp b">re-declare</code>另一个具有相同名称的<code class="fe mm mn mo mp b">const</code>变量，但是如果变量是数组或对象之类的引用类型，我们可以更改存储在该变量中的值。</li></ul></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="ff0f" class="lp lq in bd lr ls oc lu lv lw od ly lz jt oe ju mb jw of jx md jz og ka mf mg bi translated">ES6导入和导出语法</h1><p id="367f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在ES6开始使用之前，我们在一个HTML文件中有多个<code class="fe mm mn mo mp b">script</code>标签来导入不同的javascript文件，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="2b8e" class="mu lq in mp b gy mv mw l mx my">&lt;script type="text/javascript" src="home.js"&gt;&lt;/script&gt;<br/>&lt;script type="text/javascript" src="profile.js"&gt;&lt;/script&gt;<br/>&lt;script type="text/javascript" src="user.js"&gt;&lt;/script&gt;</span></pre><p id="fa75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，如果我们在不同的javascript文件中有一个同名的变量，这将产生命名冲突，并且您期望的值将不是您得到的实际值。</p><p id="1861" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">ES6通过模块的概念解决了这个问题。</p><p id="ec32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们在ES6中编写的每个javascript文件都被称为一个模块，我们在每个文件中声明的变量和函数对其他文件不可用，直到我们专门从该文件导出它们并将其导入另一个文件。</p><p id="7378" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以文件中定义的函数和变量对于每个文件都是私有的，在我们导出它们之前，不能在文件外部访问它们。</p><p id="279d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有两种类型的导出:</p><ul class=""><li id="ed79" class="nh ni in kv b kw kx kz la lc oh lg oi lk oj lo nm nn no np bi translated">命名导出:一个文件中可以有多个命名导出</li><li id="5d8b" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">默认导出:一个文件中只能有一个默认导出</li></ul><h1 id="3eed" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">指定出口</h1><p id="d2e0" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">要将单个值导出为命名导出，我们可以像这样导出它:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="7d14" class="mu lq in mp b gy mv mw l mx my">export const temp = "This is some dummy text";</span></pre><p id="a18f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们有多个要导出的东西，我们可以在单独的行上写一个导出语句，而不是在变量声明之前，并在花括号中指定要导出的东西。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="a0e4" class="mu lq in mp b gy mv mw l mx my">const temp1 = "This is some dummy text1";<br/>const temp2 = "This is some dummy text2";<br/>export { temp1, temp2 };</span></pre><p id="4a02" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，导出语法不是对象文字语法。所以在ES6中，为了导出某些东西，我们不能像这样使用键值对:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="2cd2" class="mu lq in mp b gy mv mw l mx my">// This is invalid syntax of export in ES6<br/>export { key1: value1, key2: value2 }</span></pre><p id="2168" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了导入我们作为命名导出导出的内容，我们使用以下语法:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="674b" class="mu lq in mp b gy mv mw l mx my">import { temp1, temp2 } from './filename';</span></pre><p id="da25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，当从文件中导入内容时，我们不需要在文件名中添加扩展名<code class="fe mm mn mo mp b">.js</code>,因为它是默认的。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="ec72" class="mu lq in mp b gy mv mw l mx my">// import from functions.js file from current directory <br/>import { temp1, temp2 } from './functions';</span><span id="a56f" class="mu lq in mp b gy mz mw l mx my">// import from functions.js file from parent of current directory<br/>import { temp1 } from '../functions';</span></pre><p id="5391" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Codesandbox演示:<a class="ae ks" href="https://codesandbox.io/s/hardcore-pond-q4cjx" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/hardcore-pond-q4cjx</a></p><p id="d4be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">需要注意的一点是，导出时使用的名称必须与我们导入时使用的名称相匹配。</strong></p><p id="96be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，如果您导出为:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="30fe" class="mu lq in mp b gy mv mw l mx my">// constants.js<br/>export const PI = 3.14159;</span></pre><p id="d740" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后在导入时，我们必须使用与导出时相同的名称</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="2cc6" class="mu lq in mp b gy mv mw l mx my">import { PI } from './constants';</span></pre><p id="c1d1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们不能像这样使用任何其他名称:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="6d0a" class="mu lq in mp b gy mv mw l mx my">import { PiValue } from './constants'; // This will throw an error</span></pre><p id="8d1f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，如果我们已经有了与导出变量同名的变量，我们可以在导入时使用重命名语法，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="1c30" class="mu lq in mp b gy mv mw l mx my">import { PI as PIValue } from './constants';</span></pre><p id="3e4c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们已经将<code class="fe mm mn mo mp b">PI</code>重命名为<code class="fe mm mn mo mp b">PIValue</code>，所以我们现在不能使用<code class="fe mm mn mo mp b">PI</code>变量名，我们必须使用<code class="fe mm mn mo mp b">PIValue</code>变量来获得<code class="fe mm mn mo mp b">PI</code>的输出值。</p><p id="f8ce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也可以在导出时使用重命名语法:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="996a" class="mu lq in mp b gy mv mw l mx my">// constants.js<br/>const PI = 3.14159; </span><span id="9d96" class="mu lq in mp b gy mz mw l mx my">export { PI as PIValue };</span></pre><p id="80e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后在导入时，我们必须像这样使用<code class="fe mm mn mo mp b">PIValue</code>:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="1a44" class="mu lq in mp b gy mv mw l mx my">import { PIValue } from './constants';</span></pre><p id="7482" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要将某个东西导出为命名导出，我们必须首先声明它。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="d7f6" class="mu lq in mp b gy mv mw l mx my">export 'hello'; // this will result in error<br/>export const greeting = 'hello'; // this will work<br/>export { name: 'David' }; // This will result in error<br/>export const object = { name: 'David' }; // This will work</span></pre><p id="af47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">我们导入多个指定导出的顺序并不重要。</strong></p><p id="ba43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看看下面的<code class="fe mm mn mo mp b">validations.js</code>文件。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="8bec" class="mu lq in mp b gy mv mw l mx my">// utils/validations.js</span><span id="f648" class="mu lq in mp b gy mz mw l mx my">const isValidEmail = function(email) {<br/>if (/^[^@ ]+@[^@ ]+\.[^@ \.]{2,}$/.test(email)) {<br/>    return "email is valid";<br/>  } else {<br/>    return "email is invalid";<br/>  }<br/>};</span><span id="5166" class="mu lq in mp b gy mz mw l mx my">const isValidPhone = function(phone) {<br/>if (/^[\\(]\d{3}[\\)]\s\d{3}-\d{4}$/.test(phone)) {<br/>    return "phone number is valid";<br/>  } else {<br/>    return "phone number is invalid";<br/>  }<br/>};</span><span id="1506" class="mu lq in mp b gy mz mw l mx my">function isEmpty(value) { if (/^\s*$/.test(value)) {<br/>    return "string is empty or contains only spaces";<br/>  } else {<br/>    return "string is not empty and does not contain<br/>spaces";<br/>  } <br/>}</span><span id="d16f" class="mu lq in mp b gy mz mw l mx my">export { isValidEmail, isValidPhone, isEmpty };</span></pre><p id="e6b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe mm mn mo mp b">index.js</code>中，我们使用这些函数，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="66c8" class="mu lq in mp b gy mv mw l mx my">// index.js<br/>import { isEmpty, isValidEmail } from "./utils/validations";</span><span id="5a1d" class="mu lq in mp b gy mz mw l mx my">console.log("isEmpty:", isEmpty("abcd")); // isEmpty: string is not empty and does not contain spaces</span><span id="6f75" class="mu lq in mp b gy mz mw l mx my">console.log("isValidEmail:", isValidEmail("abc@11gmail.com")); // isValidEmail: email is valid</span><span id="0217" class="mu lq in mp b gy mz mw l mx my">console.log("isValidEmail:", isValidEmail("ab@c@11gmail.com")); // isValidEmail: email is invalid</span></pre><p id="07e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Codesandbox演示:<a class="ae ks" href="https://codesandbox.io/s/youthful-flower-xesus" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/youthful-flower-xesus</a></p><p id="7ea0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，我们可以只导入所需的导出内容，并且以任何顺序导入，因此我们不需要检查我们在另一个文件中导出的顺序。这就是命名出口的妙处。</p><h1 id="ec3c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">默认导出</h1><p id="355f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如前所述，一个文件中最多只能有一个默认导出。</p><p id="d3c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，您可以将多个命名导出和一个默认导出合并到一个文件中。</p><p id="3eab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要声明默认导出，我们在导出关键字前添加默认关键字，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="8502" class="mu lq in mp b gy mv mw l mx my">//constants.js<br/>const name = 'David'; <br/>export default name;</span></pre><p id="a6f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了导入默认导出，我们不像在命名导出中那样添加花括号，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="fa5c" class="mu lq in mp b gy mv mw l mx my">import name from './constants';</span></pre><p id="b47e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们有多个命名导出和一个默认导出，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="bbe1" class="mu lq in mp b gy mv mw l mx my">// constants.js<br/>export const PI = 3.14159; <br/>export const AGE = 30;<br/>const NAME = "David";<br/>export default NAME;</span></pre><p id="c0b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，要在一行中导入所有内容，我们只需要在花括号前使用默认的导出变量。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="4afd" class="mu lq in mp b gy mv mw l mx my">// NAME is default export and PI and AGE are named exports here<br/>import NAME, { PI, AGE } from './constants';</span></pre><p id="488f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">默认导出的一个特点是我们可以在导入时更改导出变量的名称:</strong></p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="8619" class="mu lq in mp b gy mv mw l mx my">// constants.js<br/>const AGE = 30;<br/>export default AGE;</span></pre><p id="e477" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在另一个文件中，我们可以在导入时使用另一个名称</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="4f0c" class="mu lq in mp b gy mv mw l mx my">import myAge from ‘./constants’; </span><span id="a39d" class="mu lq in mp b gy mz mw l mx my">console.log(myAge); // 30</span></pre><p id="a229" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我们将默认导出变量的名称从<code class="fe mm mn mo mp b">AGE</code>更改为<code class="fe mm mn mo mp b">myAge</code>。</p><p id="786b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样做是因为只能有一个默认导出，所以您可以随意命名它。</p><p id="bf59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">关于默认导出，另一件要注意的事情是导出默认关键字不能出现在变量声明之前，就像这样:</strong></p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="31b6" class="mu lq in mp b gy mv mw l mx my">// constants.js<br/>export default const AGE = 30; // This is an error and will not work</span></pre><p id="b940" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们必须在单独的一行中使用export default关键字，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="69c7" class="mu lq in mp b gy mv mw l mx my">// constants.js </span><span id="d7ad" class="mu lq in mp b gy mz mw l mx my">const AGE = 30; <br/>export default AGE;</span></pre><p id="7065" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，我们可以导出default，而不用像这样声明变量:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="4608" class="mu lq in mp b gy mv mw l mx my">//constants.js<br/>export default {<br/> name: "Billy",<br/> age: 40<br/>};</span></pre><p id="9290" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在另一个文件中这样使用它:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="2bc9" class="mu lq in mp b gy mv mw l mx my">import user from './constants';<br/>console.log(user.name); // Billy <br/>console.log(user.age); // 40</span></pre><p id="de7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用以下语法，还有一种方法可以导入文件中导出的所有变量:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="11b6" class="mu lq in mp b gy mv mw l mx my">import * as constants from './constants';</span></pre><p id="4a70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，我们导入所有在<code class="fe mm mn mo mp b">constants.js</code>中的命名和默认导出，并存储在<code class="fe mm mn mo mp b">constants</code>变量中。所以，<code class="fe mm mn mo mp b">constants</code>就成了现在的一个对象。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="2d71" class="mu lq in mp b gy mv mw l mx my">// constants.js<br/>export const USERNAME = "David";<br/>export default {<br/> name: "Billy",<br/> age: 40<br/>};</span></pre><p id="de7a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在另一个文件中，我们如下使用它:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="d20d" class="mu lq in mp b gy mv mw l mx my">// test.js<br/>import * as constants from './constants';<br/>console.log(constants.USERNAME); // David<br/>console.log(constants.default); // { name: "Billy", age: 40 }<br/>console.log(constants.default.age); // 40</span></pre><p id="5d90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Codesandbox演示:<a class="ae ks" href="https://codesandbox.io/s/green-hill-dj43b" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/green-hill-dj43b</a></p><p id="7780" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您不想在单独的行上导出默认和命名的<br/>导出，您可以如下所示合并它:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="17e2" class="mu lq in mp b gy mv mw l mx my">// constants.js<br/>const PI = 3.14159; const AGE = 30;<br/>const USERNAME = "David";<br/>const USER = {<br/> name: "Billy",<br/> age: 40 <br/>};</span><span id="a5fa" class="mu lq in mp b gy mz mw l mx my">export { PI, AGE, USERNAME, USER as default };</span></pre><p id="26d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们将<code class="fe mm mn mo mp b">USER</code>导出为默认导出，其他导出为命名导出。</p><p id="c81d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在另一个文件中，您可以这样使用它:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="c3eb" class="mu lq in mp b gy mv mw l mx my">import USER, { PI, AGE, USERNAME } from "./constants";</span></pre><p id="a75f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Codesandbox演示:<a class="ae ks" href="https://codesandbox.io/s/eloquent-northcutt-7btp1" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/eloquent-northcutt-7btp1</a></p><h1 id="0f2a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><ol class=""><li id="4ed5" class="nh ni in kv b kw mh kz mi lc nj lg nk lk nl lo ok nn no np bi translated">在ES6中，在一个文件中声明的数据不可被另一个文件访问，直到从该文件导出并导入到另一个文件中。</li><li id="00ac" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo ok nn no np bi translated">如果我们在一个文件中有一个要导出的东西，比如类声明，我们使用默认导出，否则我们使用命名导出。我们还可以将默认导出和命名导出合并到一个文件中。</li></ol></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="8c36" class="lp lq in bd lr ls oc lu lv lw od ly lz jt oe ju mb jw of jx md jz og ka mf mg bi translated">默认参数</h1><p id="b85f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">ES6增加了一个非常有用的特性，在定义函数时提供默认参数。</p><p id="ff48" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设，我们有一个应用程序，一旦用户登录到系统，我们向他们显示一条欢迎消息，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="f392" class="mu lq in mp b gy mv mw l mx my">function showMessage(firstName) {<br/>  return "Welcome back, " + firstName;<br/>}<br/>console.log(showMessage('John')); // Welcome back, John</span></pre><p id="cb7e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，如果我们的数据库中没有用户名，因为它是注册时的可选字段，该怎么办呢？然后我们可以在用户登录后向用户显示<code class="fe mm mn mo mp b">Welcome Guest</code>消息。</p><p id="7354" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们首先需要检查是否提供了<code class="fe mm mn mo mp b">firstName</code>,然后显示相应的消息。在ES6之前，我们必须编写这样的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="9a7b" class="mu lq in mp b gy mv mw l mx my">function showMessage(firstName) {<br/>  if(firstName) {<br/>    return "Welcome back, " + firstName;<br/>  } else {<br/>    return "Welcome back, Guest";<br/>  }<br/>}</span><span id="d8d4" class="mu lq in mp b gy mz mw l mx my">console.log(showMessage('John')); // Welcome back, John <br/>console.log(showMessage()); // Welcome back, Guest</span></pre><p id="9f20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是现在在ES6中使用默认的函数参数，我们可以编写如下所示的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="bc9b" class="mu lq in mp b gy mv mw l mx my">function showMessage(firstName = 'Guest') {<br/>   return "Welcome back, " + firstName;<br/>}</span><span id="d47f" class="mu lq in mp b gy mz mw l mx my">console.log(showMessage('John')); // Welcome back, John <br/>console.log(showMessage()); // Welcome back, Guest</span></pre><p id="eb47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">我们可以将任何值作为默认值赋给函数参数。</strong></p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="e50e" class="mu lq in mp b gy mv mw l mx my">function display(a = 10, b = 20, c = b) { <br/> console.log(a, b, c);<br/>}</span><span id="78bf" class="mu lq in mp b gy mz mw l mx my">display(); // 10 20 20<br/>display(40); // 40 20 20<br/>display(1, 70); // 1 70 70<br/>display(1, 30, 70); // 1 30 70</span></pre><p id="2e57" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，我们为a和b函数参数分配了唯一的值，但对于c，我们分配的是b的值。因此，如果在调用函数时没有为c提供特定的值，那么我们为b提供的任何值也会被分配给c。</p><p id="0f59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的代码中，我们没有为函数提供所有的参数。所以上面的函数调用将和下面的一样:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="c0eb" class="mu lq in mp b gy mv mw l mx my">display(); // is same as display(undefined, undefined, undefined)<br/>display(40); // is same as display(40, undefined, undefined)<br/>display(1, 70); // is same as display(1, 70, undefined)</span></pre><p id="4b14" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，如果传递的参数是<code class="fe mm mn mo mp b">undefined</code>，那么相应的参数将使用默认值。</p><p id="a071" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">我们也可以将复杂值或计算值指定为默认值。</strong></p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="72dd" class="mu lq in mp b gy mv mw l mx my">const defaultUser = {<br/>  name: 'Jane',<br/>  location: 'NY',<br/>  job: 'Software Developer'<br/>};</span><span id="84d1" class="mu lq in mp b gy mz mw l mx my">const display = (user = defaultUser, age = 60 / 2 ) =&gt; { <br/> console.log(user, age);<br/>};<br/>display();</span><span id="68c5" class="mu lq in mp b gy mz mw l mx my">/* output</span><span id="d9c8" class="mu lq in mp b gy mz mw l mx my">{<br/>  name: 'Jane',<br/>  location: 'NY',<br/>  job: 'Software Developer'<br/>} 30 </span><span id="7c4b" class="mu lq in mp b gy mz mw l mx my">*/</span></pre><p id="257f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，看看下面的ES5代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="f8ef" class="mu lq in mp b gy mv mw l mx my">// ES5 Code<br/>function getUsers(page, results, gender, nationality) {<br/>  var params = "";<br/>  if(page === 0 || page) {<br/>   params += `page=${page}&amp;`; <br/>  }<br/>  if(results) {<br/>   params += `results=${results}&amp;`;<br/>  }<br/>  if(gender) {<br/>   params += `gender=${gender}&amp;`;<br/>  }<br/>  if(nationality) {<br/>   params += `nationality=${nationality}`;<br/>  }</span><span id="0467" class="mu lq in mp b gy mz mw l mx my">  fetch('https://randomuser.me/api/?' + params) <br/>   .then(function(response) {<br/>     return response.json(); <br/>   })<br/>   .then(function(result) { <br/>    console.log(result);<br/>   }) <br/>   .catch(function(error) {<br/>     console.log('error', error); <br/>   }); <br/>}</span><span id="b10f" class="mu lq in mp b gy mz mw l mx my">getUsers(0, 10, 'male', 'us');</span></pre><p id="5d9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这段代码中，我们通过在<code class="fe mm mn mo mp b">getUsers</code>函数中传递各种可选参数，对<a class="ae ks" href="https://randomuser.me/" rel="noopener ugc nofollow" target="_blank">随机用户</a> API进行API调用。</p><p id="1adc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，在进行API调用之前，我们已经添加了各种if条件来检查参数是否被添加，并且基于此，我们正在像这样构造查询字符串:<code class="fe mm mn mo mp b">https://randomuser.me/api/? page=0&amp;results=10&amp;gender=male&amp;nationality=us</code></p><p id="32ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，我们可以在定义函数参数时使用默认参数，而不是添加这么多if条件，如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="a30f" class="mu lq in mp b gy mv mw l mx my">function getUsers(page = 0, results = 10, gender = 'male',nationality = 'us') {<br/> fetch(`https://randomuser.me/api/?page=${page}&amp;results=${results}&amp;gender=${gender}&amp;nationality=${nationality}`)<br/> .then(function(response) { <br/>  return response.json();<br/> }) <br/> .then(function(result) {<br/>   console.log(result); <br/> })<br/> .catch(function(error) { <br/>  console.log('error', error);<br/>  }); <br/>}</span><span id="70fd" class="mu lq in mp b gy mz mw l mx my">getUsers();</span></pre><p id="e9cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你所看到的，我们已经大大简化了代码。因此，当我们不向<code class="fe mm mn mo mp b">getUsers</code>函数提供任何参数时，它将采用默认值，我们也可以像这样提供自己的值:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="db3e" class="mu lq in mp b gy mv mw l mx my">getUsers(1, 20, 'female', 'gb');</span></pre><p id="26e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此它将覆盖函数的默认参数。</p><h1 id="434d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">空不等于未定义</h1><p id="0785" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">但是你需要注意的一件事是<code class="fe mm mn mo mp b">null</code>和<code class="fe mm mn mo mp b">undefined</code>在定义默认参数时是两回事。</p><p id="944c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看看下面的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="b71e" class="mu lq in mp b gy mv mw l mx my">function display(name = 'David', age = 35, location = 'NY'){<br/> console.log(name, age, location); <br/>}</span><span id="dc39" class="mu lq in mp b gy mz mw l mx my">display('David', 35); // David 35 NY<br/>display('David', 35, undefined); // David 35 NY</span></pre><p id="b210" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于我们没有在第一次调用中提供第三个参数来显示，默认情况下它将是<code class="fe mm mn mo mp b">undefined</code>，因此location的默认值将在两个函数调用中使用。但是下面的函数调用并不相等。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="8f79" class="mu lq in mp b gy mv mw l mx my">display('David', 35, undefined); // David 35 NY<br/>display('David', 35, null); // David 35 null</span></pre><p id="d373" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们将<code class="fe mm mn mo mp b">null</code>作为参数传递时，我们特别告诉将<code class="fe mm mn mo mp b">null</code>的值赋给与<code class="fe mm mn mo mp b">undefined</code>不同的<code class="fe mm mn mo mp b">location</code>参数，因此它不会采用<code class="fe mm mn mo mp b">NY</code>的默认值。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="1c84" class="lp lq in bd lr ls oc lu lv lw od ly lz jt oe ju mb jw of jx md jz og ka mf mg bi translated">数组.原型.包含</h1><p id="7847" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">ES7增加了一个<code class="fe mm mn mo mp b">includes</code>方法，用于检查数组中是否存在元素，并返回一个布尔值<code class="fe mm mn mo mp b">true</code>或<code class="fe mm mn mo mp b">false</code>。</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="346d" class="mu lq in mp b gy mv mw l mx my">// ES5 Code</span><span id="c005" class="mu lq in mp b gy mz mw l mx my">const numbers = ["one", "two", "three", "four"];</span><span id="4c34" class="mu lq in mp b gy mz mw l mx my">console.log(numbers.indexOf("one") &gt; -1); // true<br/>console.log(numbers.indexOf("five") &gt; -1); // false</span></pre><p id="632e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用Array <code class="fe mm mn mo mp b">includes</code>方法的相同代码可以写成如下所示:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="fad9" class="mu lq in mp b gy mv mw l mx my">// ES7 Code</span><span id="1a77" class="mu lq in mp b gy mz mw l mx my">const numbers = ["one", "two", "three", "four"];</span><span id="5c48" class="mu lq in mp b gy mz mw l mx my">console.log(numbers.includes("one")); // true<br/>console.log(numbers.includes("five")); // false</span></pre><p id="6724" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以使用Array <code class="fe mm mn mo mp b">includes</code>方法使得代码简短易懂。</p><p id="bd9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在比较不同的值时,<code class="fe mm mn mo mp b">includes</code>方法也很方便。</p><p id="9838" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">看看下面的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="992e" class="mu lq in mp b gy mv mw l mx my">const day = "monday";</span><span id="a91b" class="mu lq in mp b gy mz mw l mx my">if(day === "monday" || day === "tuesday" || day === "wednesday") {<br/>  // do something<br/>}</span></pre><p id="592a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上述使用<code class="fe mm mn mo mp b">includes</code>方法的代码可以简化如下:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="016b" class="mu lq in mp b gy mv mw l mx my">const day = "monday";</span><span id="dd75" class="mu lq in mp b gy mz mw l mx my">if(["monday", "tuesday", "wednesday"].includes(day)) {<br/>  // do something<br/>}</span></pre><p id="add5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以在检查数组中的值时，<code class="fe mm mn mo mp b">includes</code>方法非常方便。</p><h1 id="d77a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结束点</h1><p id="e723" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated"><strong class="kv io">这只是</strong> <a class="ae ks" href="https://yogeshchavan1.podia.com/mastering-modern-javascript?coupon=LA1HR55" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">掌握现代JavaScript </strong> </a> <strong class="kv io">指南中的一些内容的预览。</strong></p><p id="82e0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">《T21掌握现代JavaScript》这本书涵盖了成为现代JavaScript技能专家所需要知道的一切。</p><p id="25d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">通过一次性购买，您将在每次新发布的ESNext中免费获得该书的更新版本。</strong></p><p id="47a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这本书包含了所有的概念，这些概念是学习React的先决条件，也是更好地使用React所必需的。</p><p id="dd72" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是你面对任何JavaScript/React面试所需要的唯一指南，在这些面试中，ES6+特性是成功面试的必备要素。</p><p id="9279" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另外，查看我的免费<a class="ae ks" href="https://yogeshchavan1.podia.com/react-router-introduction" rel="noopener ugc nofollow" target="_blank">React路由器简介</a>课程，从头开始学习React路由器。</p><p id="8872" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">想要了解关于JavaScript、React、Node.js的最新常规内容吗？在LinkedIn上关注我。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="cc42" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不要忘记订阅我的每周简讯，里面有惊人的技巧、窍门和文章，直接在这里的收件箱里。 </p></div></div>    
</body>
</html>