<html>
<head>
<title>Better JavaScript — Arrays and Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的JavaScript——数组和属性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/better-javascript-arrays-and-properties-ba261c2c13b3?source=collection_archive---------12-----------------------#2020-10-22">https://javascript.plainenglish.io/better-javascript-arrays-and-properties-ba261c2c13b3?source=collection_archive---------12-----------------------#2020-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c40e827d8eabbc995f296b05f0178d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GoRal5qOEzABKZmT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@vivintsolar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vivint Solar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="58f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进JavaScript代码的方法。</p><h1 id="0422" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安全调用hasOwnProperty</h1><p id="e5b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">hasOwnProperty</code>是<code class="fe me mf mg mh b">Object.prototype</code>的一部分，这意味着它可以被覆盖或删除。</p><p id="c62a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了确保它始终可用，我们可以直接从<code class="fe me mf mg mh b">Object.prototype</code>调用它。</p><p id="2cdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5212" class="mq lc iq mh b gy mr ms l mt mu">const hasOwnProperty = Object.prototype.hasOwnProperty;</span></pre><p id="904d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3aaf" class="mq lc iq mh b gy mr ms l mt mu">const hasOwnProperty = {}.hasOwnProperty;</span></pre><p id="0fd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2dea" class="mq lc iq mh b gy mr ms l mt mu">hasOwnProperty.call(dict, 'james');</span></pre><p id="4203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b27b" class="mq lc iq mh b gy mr ms l mt mu">const dict = {<br/>  james: 33,<br/>  bob: 22,<br/>  mary: 41<br/>};</span></pre><p id="99b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以抽象出检查对象入口的逻辑。</p><p id="205a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以用项目创建一个类。</p><p id="63a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6c64" class="mq lc iq mh b gy mr ms l mt mu">class Dict {<br/>  constructor(elements) {<br/>    this.elements = elements;<br/>  }</span><span id="9895" class="mq lc iq mh b gy mv ms l mt mu">  has(key) {<br/>    return {}.hasOwnProperty.call(this.elements, key);<br/>  }</span><span id="ed3f" class="mq lc iq mh b gy mv ms l mt mu">  set(key, val) {<br/>    this.elements[key] = val;<br/>  }</span><span id="3cf2" class="mq lc iq mh b gy mv ms l mt mu">  get(key) {<br/>    return this.elements[key];<br/>  }</span><span id="99a8" class="mq lc iq mh b gy mv ms l mt mu">  remove(key) {<br/>    delete this.elements[key];<br/>  }<br/>}</span></pre><p id="44ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个<code class="fe me mf mg mh b">Dict</code>类来保存一个<code class="fe me mf mg mh b">elements</code>实例变量，我们可以用一些方法来操作这个变量，以完成常见的字典操作。</p><p id="3eb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">has</code>检查该属性是否存在。</p><p id="cf7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">set</code>用值设置键。</p><p id="0bf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">get</code>用给定的键获取值。</p><p id="7246" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">remove</code>从对象中删除一个条目。</p><p id="b1a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以通过书写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bafb" class="mq lc iq mh b gy mr ms l mt mu">const dict = new Dict({<br/>  james: 33,<br/>  bob: 22,<br/>  mary: 41<br/>});</span></pre><h1 id="6610" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对有序集合使用数组</h1><p id="4f54" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">数组应该用于有序集合。</p><p id="5bed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有序集合有一个索引，它们按照给定的顺序被迭代。</p><p id="3bb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来创建数组:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b577" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2, 3];</span></pre><p id="e9ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="79ec" class="mq lc iq mh b gy mr ms l mt mu">for (const a of arr) {<br/>  console.log(a);<br/>}</span></pre><p id="4d05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用for-of循环遍历了<code class="fe me mf mg mh b">arr</code>数组。</p><p id="590d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它总是从开始迭代到结束，所以顺序是可预测的。</p><p id="a17c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-of循环不应该被误认为是for-in循环，for-in循环以不可预知的顺序遍历所有项。</p><h1 id="bf01" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">切勿向Object.prototype添加可枚举属性</h1><p id="4df1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该给<code class="fe me mf mg mh b">Object.prototype</code>添加可枚举属性。</p><p id="2954" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.prototype</code>是一个我们不拥有的属性，所以我们不应该改变它，因为它会给出大多数人不期望的结果。</p><p id="9051" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，for-in循环将获取原型的可枚举属性，因此它将被迭代。</p><p id="febe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望这种情况发生。</p><p id="483c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想给<code class="fe me mf mg mh b">Object.prototype</code>添加一个属性，那么它应该是不可枚举的。</p><p id="6604" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4ee5" class="mq lc iq mh b gy mr ms l mt mu">Object.defineProperty(Object.prototype, "allKeys", {<br/>  value() {<br/>    const result = [];<br/>    for (const key in this) {<br/>      result.push(key);<br/>    }<br/>    return result;<br/>  },<br/>  writable: true,<br/>  enumerable: false,<br/>  configurable: true<br/>});</span></pre><p id="a45f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">enumerable</code>设置为<code class="fe me mf mg mh b">false</code>，这样它就不会被for-in循环拾取。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/df2e10433becdec3b3a3c572732d817d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R1YGQPWw6sLFthV1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Fewings</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cbd6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d834" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该给<code class="fe me mf mg mh b">Object.prototype</code>添加可枚举属性。</p><p id="ff80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，为了安全地调用<code class="fe me mf mg mh b">hasOwnProperty</code>，我们不应该直接从对象本身调用它，因为它可以被修改。</p><p id="9f0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组适用于有序集合。</p><p id="a29b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>