<html>
<head>
<title>Asynchronous Redux Without Middlewares — Using ES2017</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无中间件的异步Redux使用ES2017</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-redux-without-middlewares-using-es2017-a42c2699d4d0?source=collection_archive---------0-----------------------#2019-03-21">https://javascript.plainenglish.io/asynchronous-redux-without-middlewares-using-es2017-a42c2699d4d0?source=collection_archive---------0-----------------------#2019-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/011b7d29a7881164e3569b16d0d249f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Um8Opydr45L5L8CU7lF8Qg.png"/></div></div></figure><p id="804d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有中间件也可以处理异步redux操作，有了ES2017 async/await，我们可以用更清晰的方式来处理。</p><h2 id="b4d3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">我该做吗？</h2><p id="463f" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我在这里不是说你不应该使用thunk或saga。如果您愿意，您可以将它视为一个练习，帮助我们加深对redux和函数式编程的了解。此外，我们将以一种可测试的方式来完成这一切。</p><h2 id="947a" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">该项目</h2><p id="c5a3" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们将创建一个简单的React项目，使用GitHub API通过用户名搜索存储库。如果你想看看最终产品的样子，请访问下面的链接:</p><p id="4203" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lr" href="https://async-redux-without-middleware.herokuapp.com" rel="noopener ugc nofollow" target="_blank">https://async-redux-without-middleware.herokuapp.com</a></p><h1 id="8bee" class="ls ku in bd kv lt lu lv ky lw lx ly lb lz ma mb le mc md me lh mf mg mh lk mi bi translated">让我们编码</h1><p id="95ab" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">我们将使用create-react-app CLI:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="dba4" class="kt ku in mo b gy ms mt l mu mv">npx create-react-app async-redux-without-middlewares<br/>cd async-redux-without-middlewares</span></pre><p id="90d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们也安装依赖项</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ddf8" class="kt ku in mo b gy ms mt l mu mv">npm install -s redux react-redux axios</span></pre><h2 id="1bb2" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">http服务</h2><p id="2495" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">创建服务是为了将http请求与业务逻辑分开。在此之上，我们将添加一个抽象层，导出的不是服务对象，而是生成服务对象的函数。这允许我们隔离axios依赖性，帮助我们测试服务，而不必实际调用http请求。</p><p id="2bad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> services/repos.js </strong></p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="fc9a" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">行动</h2><p id="1923" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated"><strong class="jx io"> actions/repos.js </strong></p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="05f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导出的函数<code class="fe my mz na mo b">getReposByUsernameInjector</code>将用于我们的主容器<code class="fe my mz na mo b">connect()</code>。它不会被引用，而是被执行，其结果将成为组件的一个属性。</p><p id="c1d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接收<code class="fe my mz na mo b">getReposByUsername</code>的所有依赖项作为参数，隔离函数，允许我们编写测试，而不必导入存储或实际调用我们的服务。</p><h2 id="b2e4" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">连接</h2><p id="73e5" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">在react中，容器是连接到redux状态的组件。出于教学的原因，我们将把连接从组件本身中分离出来。</p><p id="3967" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> components/Main.js </strong></p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2ee4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">containers/connected main . js</strong></p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5b02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na mo b">connect()</code>的第二个参数是一个名为<code class="fe my mz na mo b">mapDispatchToProps</code>的函数，它允许您创建在被调用时调度的函数，并将结果对象属性作为道具传递给组件。</p><p id="ce10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想学习更多关于动作分派的知识，我强烈推荐阅读redux文档中的这一页。</p><div class="nb nc gp gr nd ne"><a href="https://react-redux.js.org/using-react-redux/connect-mapdispatch" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">连接:使用mapDispatchToProps调度动作React Redux</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">作为传递给connect的第二个参数，mapDispatchToProps用于将操作分派给存储。派遣…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">react-redux.js.org</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jt ne"/></div></div></a></div><p id="6583" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">连接所有这些之后，流程看起来像这样:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/083a92727d1d5b2fa5b10165b2723df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuWBS5MA15mPe3jcU6ttKw.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">Click to expand</figcaption></figure><h1 id="899b" class="ls ku in bd kv lt lu lv ky lw lx ly lb lz ma mb le mc md me lh mf mg mh lk mi bi translated">我如何测试它？</h1><h2 id="9e86" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">服务</h2><p id="81b0" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了测试我们的服务，我们只需要调用一个自定义对象作为axios，并期望使用repos url调用<code class="fe my mz na mo b">get()</code>函数。</p><p id="6173" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> services/repos.test.js </strong></p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="47e3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">行动</h2><p id="9c93" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了测试我们的操作，我们将设置一个定制的<code class="fe my mz na mo b">dispatch()</code>和服务来模拟四种可能性:成功、空repos、用户名未找到和连接错误。</p><p id="502b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> actions/repos.test.js </strong></p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="d8a8" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">集装箱</h2><p id="5f8c" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">因为我们将连接容器与组件分开，所以单独测试它更容易。</p><figure class="mj mk ml mm gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="d4a6" class="ls ku in bd kv lt lu lv ky lw lx ly lb lz ma mb le mc md me lh mf mg mh lk mi bi translated">其他组件</h1><p id="e0cf" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">有更多的代码文件来涵盖所有的项目。但是这些都是基本React的简单实现。现在评论会断章取义，而且会使这篇文章太长。如果你想探索更多的细节，这里是GitHub库:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/andregardi/async-redux-without-middlewares" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">Andre gardi/async-redux-无中间件</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在GitHub上创建一个帐户，为Andre gardi/async-redux-无中间件开发做出贡献。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="ny l np nq nr nn ns jt ne"/></div></div></a></div><p id="9e87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注</strong>:在最终项目中，我添加了用于可视组件的<code class="fe my mz na mo b">@material-ui/core</code>和<code class="fe my mz na mo b">@material-ui/icons</code>，以及用于托管Heroku上静态服务器的<code class="fe my mz na mo b">express</code>。</p></div></div>    
</body>
</html>