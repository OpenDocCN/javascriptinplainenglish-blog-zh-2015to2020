<html>
<head>
<title>Building Our Own Blog Using New Technologies: Deno</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用新技术构建我们自己的博客:Deno</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-your-own-blog-with-deno-62c9909c69ce?source=collection_archive---------2-----------------------#2020-06-12">https://javascript.plainenglish.io/build-your-own-blog-with-deno-62c9909c69ce?source=collection_archive---------2-----------------------#2020-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="97f4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在这个由两部分组成的故事中，我们将使用两种现代技术开发我们自己的博客:Deno用于后端，AlpineJS用于前端。我们将从后端开始。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/14d09ad5da7ff646fc547ae0daed16ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tctyvF08tOwaqH85"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@blancapaloma4?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Blanca Paloma Sánchez</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="50ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你正在读这篇文章，很有可能你以前写过博客，或者你正在考虑这样做。有很多平台可以托管你的博客，比如<a class="ae ks" href="https://www.blogger.com" rel="noopener ugc nofollow" target="_blank"> Blogger </a>、<a class="ae ks" href="https://wordpress.com/" rel="noopener ugc nofollow" target="_blank"> WordPress </a>，或者<a class="ae ks" href="https://medium.com/" rel="noopener"> Medium </a>。但是有时候，你想拥有自己的博客。这可能是因为你想写的文章类型不适合这些平台。也许你只是想根据你自己的审美风格化。或者你只是想测试一项新技术，就像我一样。</p><h1 id="d359" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">我们的项目</h1><p id="1419" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果我们开发自己的博客，我们需要将博客条目存储在某个地方。我们需要访问它们，知道有哪些条目。我们需要一个后端。</p><p id="4ae4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将使用Deno作为我们后端的运行时。在此之上，我们将使用Alosaur作为web服务器框架。由于Deno相当新，我们将保持简单，我们不会连接到任何数据库；一个JSON文件将跟踪哪些帖子是可用的，我们将把它们作为HTML文件。</p><h1 id="833e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">迪诺？恐龙吗？</h1><p id="c4f8" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">不，<a class="ae ks" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank">Deno</a>——虽然Deno的图标是一只可爱的恐龙。</p><p id="223e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从其网站:</p><blockquote class="mm mn mo"><p id="6dfe" class="kt ku mp kv b kw kx jo ky kz la jr lb mq ld le lf mr lh li lj ms ll lm ln lo ig bi translated">Deno是一个简单、现代和安全的JavaScript和TypeScript运行时，它使用V8并内置于Rust中。</p></blockquote><p id="15f6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Deno是由Ryan Dahl创建的，他也被称为Node.js的创造者，Deno开始是作为一个原型来修复Ryan Dahl与Node.js之间的遗憾，如果你对这些遗憾感兴趣，你可以在<a class="ae ks" href="https://www.youtube.com/watch?v=M3BM9TB-8yA" rel="noopener ugc nofollow" target="_blank">这个视频</a>中听到Ryan Dahl本人的意见。</p><p id="7cf3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Deno于2018年开始开发，但就在最近，5月13日，开发团队发布了1.0.0版本，这是第一个稳定的、可供部署的版本。</p><p id="2b23" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Deno附带了一个广泛的标准库，包括I/O、格式化和UUID生成等。此外，还存在许多第三方模块。Deno的开发团队主持了一个由他们中许多人组成的<a class="ae ks" href="https://deno.land/x" rel="noopener ugc nofollow" target="_blank">精选列表</a>。</p><h2 id="765b" class="mt lq in bd lr mu mv dn lv mw mx dp lz lc my mz mb lg na nb md lk nc nd mf ne bi translated">阿洛索龙</h2><p id="add1" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">Deno的第三方模块之一是<a class="ae ks" href="https://deno.land/x/alosaur" rel="noopener ugc nofollow" target="_blank">Alosaur</a>——保持恐龙主题。</p><p id="6473" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Alosaur是一个基于控制器的web服务器框架。它广泛使用decorators来指示路线，类似于<a class="ae ks" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest </a>。如果你熟悉Nest，Alosaur会让你有宾至如归的感觉。</p><h1 id="332b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">你好，Alosaur</h1><p id="b3d7" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">让我们从Hello World Alosaur应用程序开始。从那里，我们将建立和抽象我们的应用程序，直到它的最终结果。</p><p id="30dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于Alosaur使用了decorators，我们需要用以下选项声明一个<code class="fe nf ng nh ni b">tsconfig.json</code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ec43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的Hello World应用程序如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="71b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">与Node.js不同，Deno既不使用<code class="fe nf ng nh ni b">package.json</code>也不使用<code class="fe nf ng nh ni b">index.js</code>主文件。我们使用命令<code class="fe nf ng nh ni b">deno run</code>并指定我们希望运行的文件。我们还需要用标志<code class="fe nf ng nh ni b">-c</code>或<code class="fe nf ng nh ni b">--config</code>来指示我们想要使用的配置文件。关于<code class="fe nf ng nh ni b">run</code>命令的更多信息，您可以执行<code class="fe nf ng nh ni b">deno run --help</code>。</p><p id="4c3d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们运行上面的程序。我们的辉煌结果是什么？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c14d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可能还记得，Deno的主要功能设计之一是其安全性。用户需要指定应用程序需要的所有权限。幸运的是，Deno的错误消息指出了我们需要添加哪个标志。所以让我们再试一次:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="013e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们再次遇到类似的错误消息。我们缺少<code class="fe nf ng nh ni b">--allow-net</code>旗帜。让我们再次运行应用程序:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="08ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">终于成功了！如果现在我们带着浏览器去<code class="fe nf ng nh ni b">http://localhost:8000/home/text</code>，迎接我们的将是<em class="mp"> Hello world </em>消息。</p><p id="2f49" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们检查第一行，应用程序没有从<code class="fe nf ng nh ni b">node_modules</code>目录或类似目录中导入Alosaur。事实上，<code class="fe nf ng nh ni b">node_modules</code>在Deno中并不存在。所有Deno模块都是通过URL导入的。当执行程序时，Deno从其本地缓存中搜索所需的模块。如果没有找到模块，Deno将下载模块。如果我们想重新下载模块，我们可以在运行应用程序时传递<code class="fe nf ng nh ni b">--reload</code>标志。</p><p id="d81b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nf ng nh ni b">@Controller('/home')</code>表示类是一个控制器，通常用于一种类型的资源，以及访问它的路径。</p><p id="adbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nf ng nh ni b">@Get('/text')</code>表示在指定路线上收到<code class="fe nf ng nh ni b">GET</code>请求时执行该方法，在本例中为<code class="fe nf ng nh ni b">/home/text</code>。</p><p id="da72" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nf ng nh ni b">@Area()</code>声明一个控制器模块。</p><p id="2f8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并且一个<code class="fe nf ng nh ni b">App</code>声明了一组区域。</p><p id="13d4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以使用<code class="fe nf ng nh ni b">Deno.env.get</code>获得环境变量，在这个例子中，我们获得了要监听的端口。</p><h1 id="f148" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">管理依赖关系</h1><p id="7a67" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">Deno使用URL来调用它需要的依赖项。这会变得有点笨拙，特别是如果我们偶然开始使用同一个包的不同版本，因为我们要为每个文件写URL。</p><p id="a1f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，Deno团队考虑了这个问题，并在他们的<a class="ae ks" href="https://deno.land/manual/linking_to_external_code" rel="noopener ugc nofollow" target="_blank">链接到第三方代码</a>手册页中描述了<code class="fe nf ng nh ni b">deps.ts</code>的用法，这是一个导出我们使用的所有依赖项的文件。</p><p id="ff67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于Hello World程序，<code class="fe nf ng nh ni b">deps.ts</code>文件看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><h1 id="2da2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">数据库ˌ资料库</h1><p id="94c5" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">因为我们想保持简单，我们不会有一个适当的数据库。我们将自己用两个JSON文件来管理它:一个用于可用帖子的列表，另一个指示每个帖子的位置。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><h1 id="9464" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">服务</h1><p id="7807" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们将抽象出我们的业务逻辑来为服务中的帖子提供服务。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="1428" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nf ng nh ni b">getPosts</code>返回可用帖子的数组，如<code class="fe nf ng nh ni b">post_list.json</code>中所列。<code class="fe nf ng nh ni b">readJson</code>是Deno标准库中的一个函数，读取JSON文件并解析它。</p><p id="bb3f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nf ng nh ni b">getPost</code>以HTML的形式发布帖子。首先我们从<code class="fe nf ng nh ni b">post_loc.json</code>开始读取位置。我们使用<code class="fe nf ng nh ni b">normalize</code>和<code class="fe nf ng nh ni b">join</code>生成绝对路径，它们都来自Deno的标准库。最后，我们用<code class="fe nf ng nh ni b">serveFile</code>提供文件，同样来自标准库——你可以看到Deno的标准库相当完整。</p><p id="81de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们收到的请求是一个Alosaur请求。幸运的是，它公开了底层Deno的本地服务器请求，这是我们在<code class="fe nf ng nh ni b">serveFile</code>中需要的。</p><h1 id="d819" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">控制器</h1><p id="93c9" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">控制器将管理我们的应用程序路由。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="769a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们在构造函数中将服务声明为属性。在Alosaur中，依赖注入是自动处理的；没有必要给服务添加装饰器——除了在这里<a class="ae ks" href="https://github.com/alosaur/alosaur/tree/master/src/injection" rel="noopener ugc nofollow" target="_blank">记录的特定情况。</a></p><p id="98df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nf ng nh ni b">list</code>在<code class="fe nf ng nh ni b">GET</code>请求到<code class="fe nf ng nh ni b">/posts</code>时被调用，并返回可用职位列表。我们可以很容易地返回原始类型或对象，我们不需要直接操纵响应。</p><p id="43e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在对<code class="fe nf ng nh ni b">/posts/:id</code>的<code class="fe nf ng nh ni b">GET</code>请求中，<code class="fe nf ng nh ni b">blogPost</code>被调用，其中<code class="fe nf ng nh ni b">:id</code>是请求的帖子id。<code class="fe nf ng nh ni b">@Param('id')</code>装饰器将从请求路由中提取ID。<code class="fe nf ng nh ni b">@Req()</code>装饰器给出了完整的请求对象，这是我们服务的<code class="fe nf ng nh ni b">getPost</code>和服务HTML文件所需要的。因为我们返回的是一个文件，而不仅仅是某个对象，所以我们不能像在<code class="fe nf ng nh ni b">list</code>中那样直接<code class="fe nf ng nh ni b">return</code>。</p><h1 id="df8b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">面积</h1><p id="9c26" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">这个区域只是收集控制器。它用于模块化开发。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><h1 id="1cba" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">中间件</h1><p id="448c" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">对于这个应用程序，我们只使用一个中间件，REST logger中间件，它将记录所有收到的请求。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="bf76" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们修饰了<code class="fe nf ng nh ni b">Log</code>类，以表明这个类是一个将在所有路由中执行的中间件(<code class="fe nf ng nh ni b">RegExp('/')</code>)。它还实现了<code class="fe nf ng nh ni b">MiddlewareTarget</code>，它定义了在请求解析之前执行的方法<code class="fe nf ng nh ni b">onPreRequest</code>，以及在请求解析之后执行的方法<code class="fe nf ng nh ni b">onPostRequest</code>。</p><p id="0081" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为我们想要打印响应状态，所以我们实现了<code class="fe nf ng nh ni b">onPostRequest</code>。</p><p id="f947" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用标准库中的<a class="ae ks" href="https://deno.land/std/fmt" rel="noopener ugc nofollow" target="_blank"> fmt </a>，标准库为我们提供了用于打印的颜色。这使得我们的日志更容易阅读。</p><p id="1642" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nf ng nh ni b">context</code>参数具有请求和响应属性。从请求中我们得到方法、URL和Deno的本地服务器请求，这进一步给出了HTTP版本和调用的IP和端口。<br/>遗憾的是，在撰写本文时，Alosaur没有返回响应状态，除非在控制器的响应中特别定义。为了得到它，我们要经历一个淘汰过程。</p><ul class=""><li id="371b" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">我们检查是否有错误。如果是，我们返回错误代码。如果错误没有错误代码，我们返回500(内部服务器错误)。</li><li id="d26b" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">如果没有错误，并且响应定义了一个状态，我们返回这个状态。</li><li id="0f5f" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">否则，请求成功，我们返回200。</li></ul><p id="1f86" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们一起打印所有内容。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/fce635de97d9040de94eefed55421ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJ-4mc3dBMqmyDnruYSnew.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">REST logger middleware output</figcaption></figure><p id="b25a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑到我们获得状态的迂回方式，它并不完美，在某些情况下可能会失败，比如404错误(我们应该在请求<code class="fe nf ng nh ni b">/home/json</code>时得到404)。<br/>打印日期来自使用<code class="fe nf ng nh ni b">Logger.log</code>。它的实现超出了本文的范围，但是如果您对我写它感兴趣，请告诉我。</p><h1 id="9b64" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">应用</h1><p id="aa87" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们终于准备好把所有东西放在一起了！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="2548" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们首先用我们的区域(<code class="fe nf ng nh ni b">PostArea</code>)和中间件(<code class="fe nf ng nh ni b">Log</code>)来声明我们的<code class="fe nf ng nh ni b">App</code>。</p><p id="a26e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了增加一点安全性，我们处理CORS(跨源资源共享)。Alosaur使其易于实现。创建的应用程序有<code class="fe nf ng nh ni b">useCors</code>方法，它接收一个<code class="fe nf ng nh ni b">CorsBuilder</code>。对于构建器，我们选择接受任何原点，允许任何方法，但是我们将接受的头限制为<code class="fe nf ng nh ni b">Origin</code>、<code class="fe nf ng nh ni b">X-Requested-With</code>、<code class="fe nf ng nh ni b">Authorization</code>、<code class="fe nf ng nh ni b">Content-Type</code>和<code class="fe nf ng nh ni b">Accept</code>。<br/>对于起源和方法，我们都可以限制我们所允许的。</p><p id="744b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">写博客时，我们可能会使用自己的图片。我们需要为他们服务。Alosaur也使得服务静态文件变得容易。我们只需将包含公共资产的根文件夹交给<code class="fe nf ng nh ni b">root</code>。就是这样。</p><p id="3a92" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">处理应用程序错误很重要，所以我们需要一个全局错误处理程序。通过使用应用程序中的<code class="fe nf ng nh ni b">error</code>方法，我们可以对任何抛出的错误做出反应。在我们的例子中，记录它并返回一个错误页面。</p><p id="0c64" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们用给定的端口启动应用程序。</p><p id="03e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您一直在跟踪和编程，让我在您运行应用程序之前打断您一下。Deno的主要关注点是安全性，未经许可从磁盘读取文件将是相当大的安全漏洞。所以我们需要添加一个标志。我们最后的运行命令是:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1087" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将读取限制在当前目录。</p><p id="4e90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">打开您最喜欢的浏览器，进入<code class="fe nf ng nh ni b">http://localhost:8000/posts</code>查看可用帖子列表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/fcda3c91c2e0d6bf8a5cdd820fa77cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3Q3LQ3f3wwcGHZb9D_lag.png"/></div></div></figure><p id="ef11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或者看帖子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oc"><img src="../Images/f463d4f6f0d4f6b0597b3135aaf5462b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vy3o_QFM6kH_Skd_eyJEdQ.png"/></div></div></figure><p id="cf01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">帖子看起来有点丑。当我们实现前端时，我们将添加适当的样式。</p><h1 id="a1c4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">锁</h1><p id="a2c3" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在我们有了博客的后端。但是如果我们想让其他人合作，会发生什么呢？或者，由于依赖项是可能没有指定版本的URL，当我们重新加载模块时，我们下载了一个有重大变化的新模块？</p><p id="1aae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于NPM和纱线，我们分别有<code class="fe nf ng nh ni b">package-lock.json</code>和<code class="fe nf ng nh ni b">yarn.lock</code>。Deno的开发团队考虑过这个问题，Deno也提供了一个锁机制。</p><p id="ab12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们创建一个名为<code class="fe nf ng nh ni b">lock.json</code>的锁文件，并使用以下命令下载所有依赖项。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="3af6" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">码头工人</h1><p id="3e40" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">对于大多数开发团队来说，当前工作流的一部分包括使用Docker，或者拥有相同的工作空间，或者用于部署。因此，让我们看看如何为我们的后端创建一个Docker映像。</p><p id="a03e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，GitHub用户Hayd一直在开发Deno图像以供使用(查看它们<a class="ae ks" href="https://github.com/hayd/deno-docker" rel="noopener ugc nofollow" target="_blank">这里</a>)。我们将遵循模板，并添加一些变化。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="b9f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Dockerfile文件是不言自明的。值得注意的是，我们复制了<code class="fe nf ng nh ni b">deps.ts</code>和<code class="fe nf ng nh ni b">lock.json</code>来缓存所有的依赖项，并且我们没有将<code class="fe nf ng nh ni b">--allow-read</code>限制到当前目录，因为Docker本身提供了一个安全层。</p><h1 id="1bc2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">部署</h1><p id="ac91" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果我们开发博客是为了让人们阅读，如果我们在<code class="fe nf ng nh ni b">localhost</code>运行我们的博客，没有多少人能够这样做。因此，让我们部署后端，以便以后我们的前端可以使用它。</p><p id="7772" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Heroku是一个云平台即服务，支持多种编程语言。我们可以创建一个免费的帐户，不需要介绍和卡的细节，并主持我们的应用程序。问题是Deno不是受支持的语言之一。幸运的是，Heroku允许<a class="ae ks" href="https://devcenter.heroku.com/articles/build-docker-images-heroku-yml" rel="noopener ugc nofollow" target="_blank">构建Docker图像</a>。我们需要添加一个<code class="fe nf ng nh ni b">heroku.yml</code>文件来指示使用哪个Dockerfile文件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nl nk l"/></div></figure><p id="e298" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以给出更多的选择，但是对于我们的目的来说，这就是我们所需要的。</p><p id="91f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们运行以下命令:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="751b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将会出现权限错误。我们只需要注释或删除<code class="fe nf ng nh ni b">USER deno</code>行，这样我们就可以在Heroku容器中以root权限运行。修好那条线后，我们再推一次，就行了！</p><p id="846b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此时，我们可能会问自己，Heroku在哪个端口运行它的应用程序？因为我们没有设置任何环境变量，我们的docker文件公开了端口8000。Heroku总是在80端口运行，忽略docker文件中的<code class="fe nf ng nh ni b">EXPOSE</code>。它还设置了一个<code class="fe nf ng nh ni b">PORT</code>环境变量。我们预料到了这一点，这就是为什么我们在应用程序中使用<code class="fe nf ng nh ni b">PORT</code>的原因，尽管在开发中我们一直使用默认的8000。</p><p id="4a55" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以通过在Heroku中检查应用程序页面的URL或运行<code class="fe nf ng nh ni b">heroku open -a your-blog-name</code>来打开您的应用程序。</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><p id="1772" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢您的阅读！在下一篇文章中，我们将使用AlpineJS开发博客的前端。当然这个后端是不可知的，所以可以随意开发任何前端并使用这个后端😉如果我有什么错误或不清楚的地方，请留下评论，我会尽快回答。</p><h1 id="708e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">资源</h1><div class="ok ol gp gr om on"><a href="https://deno.land/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">德诺</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">编辑描述</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">德诺.兰德</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb km on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://deno.land/x" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">第三方模块| Deno</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">deno.land/x是一个为Deno脚本的URL重写服务。代码URL的基本格式是https://deno.land/x/[email…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">德诺.兰德</p></div></div></div></a></div><div class="ok ol gp gr om on"><a href="https://deno.land/manual/linking_to_external_code" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">德诺</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">编辑描述</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">德诺.兰德</p></div></div></div></a></div><div class="ok ol gp gr om on"><a href="https://github.com/alosaur/alosaur/tree/master/src/injection" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">阿洛龙/阿洛龙</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">用于构造函数注入的TypeScript/JavaScript的轻量级依赖注入容器。塞林格·塞林格…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb km on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://deno.land/std/fmt" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">德诺</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">编辑描述</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">德诺.兰德</p></div></div></div></a></div><div class="ok ol gp gr om on"><a href="https://github.com/hayd/deno-docker" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">hayd/deno-docker</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">Dockerhub上发布的deno的Docker文件:amazonlinux1 build用于在AWS Lambda上运行deno。要运行main.ts…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div></div></a></div><div class="ok ol gp gr om on"><a href="https://devcenter.heroku.com/articles/build-docker-images-heroku-yml" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">用heroku.yml构建Docker图像</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">heroku.yml文件是一个可以用来定义heroku应用程序的清单。它允许您:建立Docker图像在…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">devcenter.heroku.com</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb km on"/></div></div></a></div><h2 id="0789" class="mt lq in bd lr mu mv dn lv mw mx dp lz lc my mz mb lg na nb md lk nc nd mf ne bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="873b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">订阅我们的YouTube频道</strong> </a> <strong class="kv io">获取更多类似内容！</strong></p></div></div>    
</body>
</html>