<html>
<head>
<title>How Svelte’s State System Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯维尔特的国家体系是如何运作的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-sveltes-state-system-works-713e7c60f47e?source=collection_archive---------4-----------------------#2020-07-27">https://javascript.plainenglish.io/how-sveltes-state-system-works-713e7c60f47e?source=collection_archive---------4-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d10ae1593429152e36b5b503bf8c121b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiYkyxuBTQzXGz_WLe5JJw.png"/></div></div></figure><p id="b6a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前端框架为开发人员提供了一种更简单的方式来编写具有复杂状态的应用程序。每个框架都为管理状态以及如何更新DOM提供了自己的解决方案。例如，在React中，当您想用一个<code class="fe kw kx ky kz b">this.useState</code>调用或一个钩子来更新状态时，您必须显式声明。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi la"><img src="../Images/07bbbef42207a1d90f3155d2d2c45dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ov0rIrVukWGAzZYF3Y9-g.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">An example React component which updates state with a hook</figcaption></figure><p id="30c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常很容易理解一个框架如何在幕后运行。Vue、React和Angular都要求你创建一个框架可以控制的类或函数。您必须将它们的状态变量声明为类的属性或钩子。您还可以将函数绑定为组件的属性。</p><h2 id="99f0" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kj ls lt lu kn lv lw lx kr ly lz ma mb bi translated">脱颖而出的框架</h2><p id="6a7b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">Svelte一直在慢慢成长，并在其他前端框架中拥有一个小而忠诚的粉丝群。Svelte也可能有最独特的方法来编写前端网站。从表面上看，它似乎非常类似于Vue，然而在幕后，它是完全不同的。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/fbd9cfe8948882ebbb5a7541c929ec7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaTWLpoM8OY_DsiDW4mbvg.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">The same React component but written in Svelte</figcaption></figure><p id="5cf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Svelte将前端开发的所有方面合并到一个文件中。代码放在一个<code class="fe kw kx ky kz b">script</code>标签中，样式放在一个<code class="fe kw kx ky kz b">style</code>标签中。其余的代码被假定为HTML，并成为组件使用的模板。当构建一个苗条的应用程序时，编译器会自动为你构建普通的JavaScript组件。这一点的力量在于纤细的束小得令人难以置信。事实上，在您的最终包中只有很少的代码(只有大约500行样板代码)。当看到上面的Svelte代码时，人们一定会想:“Svelte如何知道在第<code class="fe kw kx ky kz b">text="Updated!"</code>行重新呈现组件？”Svelte声称要建立“控制论增强的网络应用程序”，所以，我看了看Svelte的源代码以及我编译的包，看看这些控制论增强到底是什么。</p><h2 id="0e25" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kj ls lt lu kn lv lw lx kr ly lz ma mb bi translated">Svelte是一个编译器</h2><p id="c585" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我认为这个概念也许是在和苗条的人一起工作时需要理解的最重要的想法。虽然从纯粹的定义来看，框架是苗条的仍然属于这一类；它不是React或Angular那样的框架。正如我前面提到的，为了让你的应用程序运行，在构建的包中只需要很少的代码。相反，苗条的编译器将你的<code class="fe kw kx ky kz b">.svelte</code>文件翻译成JavaScript组件。下面是Svelte在构建包时生成的一些代码的例子。下面的代码将生成我之前提供的Svelte文件的DOM内容。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/2a43744ae53a0dd43e412a141ebab0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S44AP5Y0uGQgSrhNdLPrZw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">The code which Svelte generated to build the DOM content of the component above</figcaption></figure><p id="c798" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，虽然细长的代码确实存在于您的包中，但它包含在您的实际组件中，而不是作为样板或多余的绒毛。粗略估计，同样的用纤体写的待办事项清单应用程序，其捆绑包大小只有同等React应用程序的13%。此外，由于这些组件不依赖于太多的外部代码，首次交互的时间比React或Angular要快得多。</p><h2 id="9317" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kj ls lt lu kn lv lw lx kr ly lz ma mb bi translated">苗条是如何工作的</h2><p id="f778" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">让我们看看Svelte如何编译你的代码，并生成帮助器方法，让你的应用程序实际工作。具体来说，我们将关注为管理状态和更新DOM而创建的助手方法。如果我们看看我之前展示的例子的构建文件，我们可以看到Svelte是如何编译<code class="fe kw kx ky kz b">updateText</code>方法的。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/e0a424d080d354cc59257f8d903a69b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0UMVzwgnuiDTZl_vEYQ5w.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">The compiled updateText method</figcaption></figure><p id="225f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际的方法签名没有改变，但是包含关系操作符的代码行改变了。实际上，它被移到了这个<code class="fe kw kx ky kz b">$$invalidate</code>方法的第二个参数中。所以这个函数必须以某种方式更新苗条组件的状态。我们可以从它的签名中看到，它采用了我们正在更新的变量的名称以及更新后的变量。</p><p id="fd23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这很酷。我们可以直接看到Svelte的编译器是如何工作的。它实际上是在重写我们的代码，让我们能够自动重写DOM！这种情况会发生在很多不同的地方，不仅仅是国家。</p><p id="6195" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我们来说幸运的是，<code class="fe kw kx ky kz b">$$invalidate</code>方法也在我们的捆绑中。所以让我们来看看这个函数实际上是做什么的。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/525dc0131a83bf12b3a0fd122d555e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2q3nwBFa6q4fhBLHeZi9aw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">The $$invalidate method</figcaption></figure><p id="f9bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它实际上很小，非常容易理解。注释应该清楚地说明不同行的作用(为了清楚起见，我添加了它们)，但是我会更详细地解释它。首先，该函数用我们正在改变的变量的新值更新<code class="fe kw kx ky kz b">ctx</code>对象。<code class="fe kw kx ky kz b">ctx</code>仅仅是组件状态的不同部分的存储。然后，它将该变量添加到一个名为<code class="fe kw kx ky kz b">dirty</code>的东西中。那个变量只是一个集合，它包含了已经被更新的变量。Svelte这样做是为了它只需要更新DOM中实际上受新状态影响的部分，而不是重写整个内容。最后，它让应用程序知道这个特定的组件需要重新呈现。在DOM更新后，还有一个函数被调用，它清空脏集。</p><p id="58d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是Svelte如何在幕后管理其状态的要点。它没有像React挂钩那样要求用户显式声明状态何时更新，而是选择保持简单的JavaScript语法。虽然这确实使代码更容易编写，但有些操作符不会被Svelte注册，这可能相当令人沮丧。此外，如果我在看一个带有局部变量的函数，可能会弄不清楚哪个操作符实际上会更新组件的状态。这时像<code class="fe kw kx ky kz b">setState</code>或钩子这样的东西会使代码更加清晰。</p><p id="796e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Svelte的编译器非常有趣。它通过直接使用普通的JavaScript HTML元素消除了对虚拟DOM的需求。它还注入辅助方法并操纵您的代码，为其提供现代web应用程序所需的额外功能。</p><p id="2e2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了我们在这里看到的之外，还有很多其他的东西。如果你对Svelte感兴趣，我强烈建议你多读一些，因为它能让你更好地理解框架在幕后是如何工作的。</p><h2 id="2874" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kj ls lt lu kn lv lw lx kr ly lz ma mb bi translated">简单英语的JavaScript</h2><p id="6551" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ka ir">！</strong></p></div></div>    
</body>
</html>