<html>
<head>
<title>A hands-on guide for a Server-Side Rendering React app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端渲染React应用的实践指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-hands-on-guide-for-a-server-side-rendering-react-app-dd1efa3ec0d8?source=collection_archive---------1-----------------------#2020-09-21">https://javascript.plainenglish.io/a-hands-on-guide-for-a-server-side-rendering-react-app-dd1efa3ec0d8?source=collection_archive---------1-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c3c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建React应用程序和服务器端渲染</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/547094485ed5474e01d239fbbf93cc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCQyhhUHvbMVVB4f1u6VYw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image credit: Author</figcaption></figure><blockquote class="kv kw kx"><p id="cb72" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">本文更新了React 18，Create React App 5，React Router 6。这篇新文章是<a class="ae lv" href="https://medium.com/p/4e630aae274c" rel="noopener">服务器端渲染React 18应用</a>的实践指南。</p></blockquote><p id="372d" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在前一篇文章的<a class="ae lv" href="https://medium.com/javascript-in-plain-english/a-hands-on-guide-for-creating-a-production-ready-react-app-864ad98e7497" rel="noopener">中，我们描述了如何进行产品构建并将其部署到服务器上。自然，下一步就是服务器端的渲染了。我们将通过将</a><a class="ae lv" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> Create React App </a>转换为服务器端呈现的应用程序来完成这个过程。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="1893" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">术语</h1><h2 id="106a" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">什么是客户端渲染(CSR)？</h2><p id="be6e" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">它是一种浏览器下载最小HTML页面，使用JavaScript渲染并填充内容的技术。</p><p id="63e1" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">初始页面加载的CSR时间可能会更长，但后续加载会更快。它减轻了服务器的负担，并依靠JavaScript库的力量。然而，搜索引擎优化(SEO)很难，因为没有静态的内容可以抓取。</p><h2 id="4801" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">什么是服务器端渲染(SSR)？</h2><p id="5238" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">它是一种浏览器下载完整的HTML页面的技术，该页面已经由服务器呈现。</p><p id="8279" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">SSR的优势是为了SEO。初始页面加载速度更快。但是它需要重新加载整个页面以进行后续更改。这可能会使服务器过载。</p><h2 id="764c" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">什么是单页应用程序(SPA)？</h2><p id="3d66" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">这是一个使用客户端渲染的应用程序。它在浏览器中直接动态地呈现每条路线，而不是每条路线都有不同的HTML页面。</p><h2 id="e36e" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">什么是通用(同构)JavaScript？</h2><p id="5f3f" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">它是一个运行在客户机和服务器上的Javascript应用程序。它在客户端将HTML呈现为SPA，在服务器端也呈现相同的HTML，然后发送到浏览器进行显示。</p><p id="81c1" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我们为CSR编写React代码。相同的代码库可用于SSR。React是通用JavaScript。</p><p id="96a2" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">SSR先于CSR存在。今天，随着通用JavaScript的出现，它又复活了。当今天提到SSR时，它很可能意味着带有通用JavaScript的SSR。</p><h1 id="eac1" class="mg mh iq bd mi mj np ml mm mn nq mp mq jw nr jx ms jz ns ka mu kc nt kd mw mx bi translated">创建React应用程序和CSR</h1><p id="7cad" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">安装<a class="ae lv" href="https://medium.com/better-programming/10-fun-facts-about-create-react-app-eb7124aa3785" rel="noopener"> Create React App </a>，运行<code class="fe nu nv nw nx b">npm start</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/38369a88235d479a0e2d2e1575c1dcdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-Yy7UjORD_1he6L1DI2oA.png"/></div></div></figure><p id="f8fc" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在<code class="fe nu nv nw nx b">Elements</code>选项卡中，它显示了JavaScript渲染的旋转标志的HTML (JSX)和一些文本信息。</p><p id="c362" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">这是一个典型的CSR，HTML内容由JavaScript呈现。从<code class="fe nu nv nw nx b">Network</code>标签中，我们可以读取从服务器下载的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/68da04300285826519607a9d1f1b6e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5Q_HQkTyx3jIMPtX8T8Dg.png"/></div></div></figure><p id="aa90" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">HTML的主体有一堆JavaScript文件，但没有实际内容。SEO很难获得任何有意义的信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="00e3" class="mg mh iq bd mi mj np ml mm mn nq mp mq jw nr jx ms jz ns ka mu kc nt kd mw mx bi translated">使用Express部署生产版本</h1><p id="460c" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated"><a class="ae lv" href="https://medium.com/javascript-in-plain-english/a-hands-on-guide-for-creating-a-production-ready-react-app-864ad98e7497" rel="noopener">创建生产就绪型React应用的实践指南</a>为服务器端渲染奠定基础。</p><p id="21dd" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">这里是一个简短的回顾。</p><p id="d409" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">如下创建<code class="fe nu nv nw nx b">server/index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cf74" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">执行<code class="fe nu nv nw nx b">npm run build</code>来创建一个生产版本。然后运行<code class="fe nu nv nw nx b">nodemon server</code>用Express服务器部署它。</p><p id="f9d6" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在<code class="fe nu nv nw nx b">Network</code>选项卡中，它显示了从服务器中检索到的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0c4b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">有3个JavaScript文件(第17 - 124行、第125行、第126行)带有空的标记内容(第16行)。因此，这是企业社会责任。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="06ae" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">在Express服务器内部构建SSR</h1><p id="fb9a" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">在Express服务器中构建SSR有3个步骤。</p><h2 id="d9d1" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">步骤1:使用ReactDOM.hydrate()或react DOM . hydrate root()<em class="oc"/>来显示服务器呈现的标记。</h2><blockquote class="kv kw kx"><p id="72e1" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是一个前<a class="ae lv" href="https://betterprogramming.pub/the-complete-guide-to-react-18-dd8763430345" rel="noopener ugc nofollow" target="_blank"> React 18 </a>的解决方案，它使用的是使用serviceWorker的Create React App的旧版本。</p></blockquote><p id="3563" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><code class="fe nu nv nw nx b">ReactDOM.hydrate()</code> <strong class="lb ir"> </strong>类似于as <code class="fe nu nv nw nx b">ReactDOM.render()</code>。它用于合并一个容器，该容器的HTML内容已经由<code class="fe nu nv nw nx b">ReactDOMServer</code>对象呈现。它的语法是<code class="fe nu nv nw nx b">ReactDOM.hydrate(element, container[, callback])</code>，和<code class="fe nu nv nw nx b">ReactDOM.render(element, container[, callback])</code>几乎一模一样。</p><p id="b18f" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">由于<code class="fe nu nv nw nx b">ReactDOM.hydrate()</code>是在一个已经有服务器呈现标记的节点上调用的，React将保留它，并且只附加事件处理程序。这使得初始负载性能良好。</p><p id="4d05" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><code class="fe nu nv nw nx b">ReactDOM.hydrate()</code>用于<code class="fe nu nv nw nx b">src/index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ff28" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在第7行，<code class="fe nu nv nw nx b">ReactDOM.render()</code>被替换为<code class="fe nu nv nw nx b">ReactDOM.hydrate()</code>。</p><blockquote class="kv kw kx"><p id="9808" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是一个<a class="ae lv" href="https://betterprogramming.pub/the-complete-guide-to-react-18-dd8763430345" rel="noopener ugc nofollow" target="_blank"> React 18 </a>的解决方案:<code class="fe nu nv nw nx b"><em class="iq">hydrate</em></code>替换为<code class="fe nu nv nw nx b"><em class="iq">hydrateRoot</em></code>，从<code class="fe nu nv nw nx b"><em class="iq">react-dom/client</em></code>导出。它的语法是<code class="fe nu nv nw nx b"><em class="iq">hydrateRoot(container, element)</em></code>。新的根提供了并发性改进。</p><p id="a512" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">它还使用了使用reportWebVitals的Create React应用程序的新版本。</p></blockquote><p id="cb3f" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><code class="fe nu nv nw nx b">ReactDOM.hydrateRoot()</code>用于<code class="fe nu nv nw nx b">src/index.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="d9d4" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">步骤2:使用ReactDOMServer对象将组件呈现为静态标记。</h2><p id="2e69" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">React提供了<code class="fe nu nv nw nx b"><a class="ae lv" href="https://reactjs.org/docs/react-dom-server.html" rel="noopener ugc nofollow" target="_blank">ReactDOMServer</a></code>对象来将组件呈现给静态标记。它向浏览器发送一个已经填充了数据的页面。</p><p id="21ad" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">React代码是通用的JavaScript，在客户端和服务器上都可以运行。</p><p id="ab72" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">实现SSR有不同的方案和方法。<code class="fe nu nv nw nx b">@babel/register</code>就是其中一个包。它作为<code class="fe nu nv nw nx b"><a class="ae lv" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">devDependencies</a></code>的一部分与<code class="fe nu nv nw nx b">babel-plugin-transform-assets</code>一起安装。</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="3be6" class="my mh iq nx b gy oh oi l oj ok">"devDependencies": {<br/>  "@babel/register": "^7.11.5",<br/>  "babel-plugin-transform-assets": "^1.0.2"<br/>}</span></pre><p id="c795" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">以下是<code class="fe nu nv nw nx b">server/index.js</code>中的SSR实现。我们不使用<a class="ae lv" href="https://betterprogramming.pub/what-might-be-coming-in-npm-9-6985cf2678a6" rel="noopener ugc nofollow" target="_blank"> ES模块</a>来编写代码，因为<code class="fe nu nv nw nx b">@babel/register</code>不支持动态编译native Node.js ES模块。据说目前还没有稳定的API来拦截ES模块的加载。</p><blockquote class="kv kw kx"><p id="645c" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">注意:从<a class="ae lv" href="https://betterprogramming.pub/the-complete-guide-to-react-18-dd8763430345" rel="noopener ugc nofollow" target="_blank">反应18 </a>，<code class="fe nu nv nw nx b"><em class="iq">renderToString</em></code>仍然工作，但是有有限的<code class="fe nu nv nw nx b">Suspense</code>支持。React 18改版服务器端API，放入<code class="fe nu nv nw nx b">react-dom/server</code>。这些新的API完全支持服务器上的<code class="fe nu nv nw nx b">Suspense</code>和流SSR。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c2a1" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在第1行，我们通过<code class="fe nu nv nw nx b">require</code>钩子设置了Babel，它可以动态地自动编译文件。如果没有这个钩子和相关的预置，我们将会遇到<code class="fe nu nv nw nx b">SyntaxError: Cannot use import statement outside a module</code>。</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="a52a" class="my mh iq nx b gy oh oi l oj ok">$ nodemon server<br/>[nodemon] 2.0.4<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching path(s): *.*<br/>[nodemon] watching extensions: js,mjs,json<br/>[nodemon] starting `node server`<br/>/Users/fuje/app/react-app1/src/App.js:1<br/>import React from "react";<br/>^^^^^^</span><span id="faef" class="my mh iq nx b gy ol oi l oj ok">SyntaxError: Cannot use import statement outside a module<br/>    at wrapSafe (internal/modules/cjs/loader.js:1071:16)<br/>    at Module._compile (internal/modules/cjs/loader.js:1121:27)<br/>    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1177:10)<br/>    at Module.load (internal/modules/cjs/loader.js:1001:32)<br/>    at Function.Module._load (internal/modules/cjs/loader.js:900:14)<br/>    at Module.require (internal/modules/cjs/loader.js:1043:19)<br/>    at require (internal/modules/cjs/helpers.js:77:18)<br/>    at Object.&lt;anonymous&gt; (/Users/fuje/app/react-app1/server/index.js:3:13)<br/>    at Module._compile (internal/modules/cjs/loader.js:1157:30)<br/>    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1177:10)<br/>[nodemon] app crashed - waiting for file changes before starting...</span></pre><p id="dd5f" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在第2行，我们设置了两个预设:</p><ul class=""><li id="9897" class="om on iq lb b lc ld lf lg lw oo lx op ly oq lu or os ot ou bi translated"><code class="fe nu nv nw nx b">@babel/preset-env</code>，一个智能预设，它使用最新的JavaScript，而不需要微观管理目标环境所需的语法转换。</li><li id="3928" class="om on iq lb b lc ov lf ow lw ox lx oy ly oz lu or os ot ou bi translated"><code class="fe nu nv nw nx b">@babel/preset-react</code>，智能预设，自动导入JSX转换到的功能。</li></ul><p id="39e9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">第3 - 14行是<code class="fe nu nv nw nx b">babel-plugin-transform-assets</code>的插件。它设置了如何转换静态媒体文件的规则。如果没有这个，它会抛出<code class="fe nu nv nw nx b">SyntaxError: Unexpected token ‘&lt;’</code>作为<code class="fe nu nv nw nx b">svg</code>标签。</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="3293" class="my mh iq nx b gy oh oi l oj ok">$ nodemon server<br/>[nodemon] 2.0.4<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching path(s): *.*<br/>[nodemon] watching extensions: js,mjs,json<br/>[nodemon] starting `node server`<br/>/Users/fuje/app/react-app5/src/logo.svg:1<br/>&lt;svg ae lv" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"&gt;<br/>^</span><span id="f04f" class="my mh iq nx b gy ol oi l oj ok">SyntaxError: Unexpected token '&lt;'<br/>    at wrapSafe (internal/modules/cjs/loader.js:1071:16)<br/>    at Module._compile (internal/modules/cjs/loader.js:1121:27)<br/>    at Module._extensions..js (internal/modules/cjs/loader.js:1177:10)<br/>    at Object.newLoader [as .js] (/Users/fuje/app/react-app5/node_modules/pirates/lib/index.js:104:7)<br/>    at Module.load (internal/modules/cjs/loader.js:1001:32)<br/>    at Function.Module._load (internal/modules/cjs/loader.js:900:14)<br/>    at Module.require (internal/modules/cjs/loader.js:1043:19)<br/>    at require (internal/modules/cjs/helpers.js:77:18)<br/>    at Object.&lt;anonymous&gt; (/Users/fuje/app/react-app5/src/App.js:2:1)<br/>    at Module._compile (internal/modules/cjs/loader.js:1157:30)<br/>[nodemon] app crashed - waiting for file changes before starting...</span></pre><p id="87d9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在第16行，需要React。</p><p id="812a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">第17行需要<code class="fe nu nv nw nx b">ReactDOMServer</code>。</p><p id="6fbc" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在第18行，需要默认导出<code class="fe nu nv nw nx b">src/App.js</code>。</p><p id="d7a7" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我们将<code class="fe nu nv nw nx b">app.use()</code>移到第47行，在<code class="fe nu nv nw nx b">app.get()</code>之后(第25 - 45行)。否则，<code class="fe nu nv nw nx b">app.use()</code>将为根路由服务包括<code class="fe nu nv nw nx b">index.html</code>在内的静态文件，执行将没有机会到达<code class="fe nu nv nw nx b">app.get()</code>中间件。</p><p id="b6a4" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">第26行显示了被调用的请求URL。对于创建React应用程序，它们列出如下:</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="901d" class="my mh iq nx b gy oh oi l oj ok">Request URL = /<br/>Request URL = /static/css/main.519b5a55.chunk.css<br/>Request URL = /static/media/logo.5d5d9eef.svg<br/>Request URL = /static/js/main.fdf902fb.chunk.js<br/>Request URL = /static/js/2.bc7ff9af.chunk.js<br/>Request URL = /static/css/main.519b5a55.chunk.css.map<br/>Request URL = /static/js/main.fdf902fb.chunk.js.map<br/>Request URL = /static/js/2.bc7ff9af.chunk.js.map<br/>Request URL = /manifest.json<br/>Request URL = /logo192.png</span></pre><p id="2041" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">第27 - 29行确保只有根路径被<code class="fe nu nv nw nx b">app.get()</code>渲染。静态资产将跳到第47行的下一个中间件。</p><p id="d659" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">在第30行，<code class="fe nu nv nw nx b">ReactDOMServer.renderToString(element)</code>用于在服务器上生成HTML。从理论上讲，可以写成<code class="fe nu nv nw nx b">ReactDOMServer.renderToString(&lt;App /&gt;)</code>。但那会抛出<code class="fe nu nv nw nx b">SyntaxError: Unexpected token ‘&lt;’</code>。</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="2fd1" class="my mh iq nx b gy oh oi l oj ok">$ nodemon server<br/>[nodemon] 2.0.4<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching path(s): *.*<br/>[nodemon] watching extensions: js,mjs,json<br/>[nodemon] starting `node server`<br/>/Users/fuje/app/react-app5/server/index.js:42<br/>  const reactApp = ReactDOMServer.renderToString(&lt;App /&gt;);<br/>                                                 ^</span><span id="e5e6" class="my mh iq nx b gy ol oi l oj ok">SyntaxError: Unexpected token '&lt;'<br/>    at wrapSafe (internal/modules/cjs/loader.js:1071:16)<br/>    at Module._compile (internal/modules/cjs/loader.js:1121:27)<br/>    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1177:10)<br/>    at Module.load (internal/modules/cjs/loader.js:1001:32)<br/>    at Function.Module._load (internal/modules/cjs/loader.js:900:14)<br/>    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)<br/>    at internal/main/run_main_module.js:18:47<br/>[nodemon] app crashed - waiting for file changes before starting...</span></pre><p id="e179" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">要求<code class="fe nu nv nw nx b">@babel-register</code>对被要求的文件不起作用，但对以后被要求的文件起作用。将包含<code class="fe nu nv nw nx b">ReactDOMServer.renderToString(&lt;App /&gt;)</code>的代码移动到所需的单独文件中，或者直接使用<code class="fe nu nv nw nx b">React.createElement()</code>。</p><p id="b96c" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">第31行显示了服务器呈现的标记代码:</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="1c55" class="my mh iq nx b gy oh oi l oj ok">&lt;div class="App" data-reactroot=""&gt;&lt;header class="App-header"&gt;&lt;img src="static/media/logo.5d5d9eef.svg" class="App-logo" alt="logo"/&gt;&lt;p&gt;Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.&lt;/p&gt;&lt;a class="App-link" href="https://reactjs.org" target="_blank" rel="noopener noreferrer"&gt;Learn React&lt;/a&gt;&lt;/header&gt;&lt;/div&gt;</span></pre><p id="89c9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">33号线装载产品<code class="fe nu nv nw nx b">index.html</code>。</p><p id="bd85" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">第34 - 44行读取<code class="fe nu nv nw nx b">index.html</code>的内容。如果没有错误，服务器生成的标记(第42行)被呈现给根标签，然后最终的<code class="fe nu nv nw nx b">index.html</code>响应初始加载。</p><p id="52fc" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">执行<code class="fe nu nv nw nx b">nodemon server</code>。从<code class="fe nu nv nw nx b">Network</code>选项卡中，下载的脚本显示了服务器呈现的标记。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="3cc1" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">从<code class="fe nu nv nw nx b">Elements</code>选项卡，以下是HTML的新主体:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="da38" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">正文内容包含完整的内容，SEO可以使用它来获取有意义的信息。</p><p id="ff19" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">虽然有一堆JavaScript文件，但是不执行。这可以通过关闭bowser中的JavaScript来证明。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/2357fe6087b508ef8779f10daaa061cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3gbsBdyfeVvq0TGhAn6Cw.png"/></div></figure><p id="9149" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">这是SSR。禁用JavaScript，代码继续工作。</p><h2 id="4d96" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">步骤3:处理页面特定的需求。</h2><p id="ff40" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">我们让单页React应用程序发挥了作用。多条路线的app怎么样？</p><p id="1118" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">首先，将<code class="fe nu nv nw nx b">react-router-dom</code>作为<code class="fe nu nv nw nx b"><a class="ae lv" href="https://medium.com/better-programming/package-jsons-dependencies-in-depth-a1f0637a3129" rel="noopener">dependencies</a></code>之一安装。</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="57bc" class="my mh iq nx b gy oh oi l oj ok">"devDependencies": {<br/>  “react-router-dom”: “^5.2.0”,<br/>  ...<br/>}</span></pre><p id="d7e1" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">修改<code class="fe nu nv nw nx b">src/App.js</code>如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="847b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">执行<code class="fe nu nv nw nx b">npm run build</code>，然后运行<code class="fe nu nv nw nx b">nodemon server</code>。</p><pre class="kg kh ki kj gt od nx oe of aw og bi"><span id="de82" class="my mh iq nx b gy oh oi l oj ok">Error: Invariant failed: Browser history needs a DOM<br/>    at invariant (/Users/fuje/app/react-app5/node_modules/tiny-invariant/dist/tiny-invariant.cjs.js:13:11)<br/>    at Object.createHistory [as createBrowserHistory] (/Users/fuje/app/react-app5/node_modules/history/cjs/history.js:273:16)<br/>    at new BrowserRouter (/Users/fuje/app/react-app5/node_modules/react-router-dom/modules/BrowserRouter.js:11:13)<br/>    at processChild (/Users/fuje/app/react-app5/node_modules/react-dom/cjs/react-dom-server.node.development.js:2995:14)<br/>    at resolve (/Users/fuje/app/react-app5/node_modules/react-dom/cjs/react-dom-server.node.development.js:2960:5)<br/>    at ReactDOMServerRenderer.render (/Users/fuje/app/react-app5/node_modules/react-dom/cjs/react-dom-server.node.development.js:3435:22)<br/>    at ReactDOMServerRenderer.read (/Users/fuje/app/react-app5/node_modules/react-dom/cjs/react-dom-server.node.development.js:3373:29)<br/>    at Object.renderToString (/Users/fuje/app/react-app5/node_modules/react-dom/cjs/react-dom-server.node.development.js:3988:27)<br/>    at /Users/fuje/app/react-app5/server/index.js:42:35<br/>    at Layer.handle [as handle_request] (/Users/fuje/app/react-app5/node_modules/express/lib/router/layer.js:95:5)</span></pre><p id="1ab2" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">不幸的是，<code class="fe nu nv nw nx b">BrowserRoute</code>在幕后使用了HTML5 <a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries" rel="noopener ugc nofollow" target="_blank">推送状态历史API </a>，Node.js不支持。</p><p id="56e9" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">对于SSR，应该在通用JavaScript中使用<code class="fe nu nv nw nx b"><a class="ae lv" href="https://reactrouter.com/core/guides/static-routes" rel="noopener ugc nofollow" target="_blank">StaticRouter</a></code>。但是，<code class="fe nu nv nw nx b">StaticRouter</code>目前是一个alpha软件。</p><blockquote class="kv kw kx"><p id="63d9" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们正在开发一个软件包，用于静态路由配置和反应路由器，以继续满足这些用例。它现在正在开发中，但我们希望您能尝试一下并提供帮助。</p><p id="1106" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae lv" href="https://github.com/reacttraining/react-router/tree/master/packages/react-router-config" rel="noopener ugc nofollow" target="_blank"> React路由器配置</a></p></blockquote><p id="1196" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">另一种选择是MemoryRouter，它将URL历史记录保存在内存中(不读写地址栏)。它在测试和非浏览器环境中很有用。</p><p id="bf16" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">下面是<code class="fe nu nv nw nx b">src/App.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="37b2" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">35线和39线使用<code class="fe nu nv nw nx b">MemoryRouter</code>。</p><p id="5487" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">执行<code class="fe nu nv nw nx b">npm run build</code>，然后运行<code class="fe nu nv nw nx b">nodemon server</code>。转到<code class="fe nu nv nw nx b">http://localhost:8080</code>，我们看到如下页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/e4b1244fb4d961af22df3a0123c73bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*PXr_9Kbnzg6RDwGs.png"/></div></figure><p id="7465" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">该应用程序的工作，虽然在地址栏的网址不会更新。</p><p id="a9ec" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">路由工作有一个警告。还有其他事情需要处理，比如数据获取、Redux等。服务器端的工作不像客户端那么简单。根据要求，每个页面可能都需要特别注意。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="85c1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="d7aa" class="pw-post-body-paragraph ky kz iq lb b lc nk jr le lf nl ju lh lw nm lk ll lx nn lo lp ly no ls lt lu ij bi translated">我们已经展示了如何为Create React应用程序设置SSR。这些是步骤:</p><ol class=""><li id="4e78" class="om on iq lb b lc ld lf lg lw oo lx op ly oq lu pc os ot ou bi translated">使用<code class="fe nu nv nw nx b">ReactDOM.hydrate() or ReactDOM.hydrateRoot()</code>显示服务器渲染的标记。</li><li id="bac3" class="om on iq lb b lc ov lf ow lw ox lx oy ly oz lu pc os ot ou bi translated">使用<code class="fe nu nv nw nx b">ReactDOMServer</code>对象将组件呈现为静态标记。</li><li id="990b" class="om on iq lb b lc ov lf ow lw ox lx oy ly oz lu pc os ot ou bi translated">处理页面特定需求</li></ol><p id="cdef" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">我们使用<code class="fe nu nv nw nx b">ReactDOMServer</code>对象将组件呈现给静态标记。它可以用于SSR和静态渲染。</p><p id="e15d" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">当请求文件时，SSR按需发生。静态呈现在构建时发生一次。两者都是SEO友好的。</p><p id="4b51" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">如果页面只包含静态数据，静态呈现会更快。但是，如果响应是动态的，SSR是更好的选择。有时，混合方法可能是最适合这种情况的。静态呈现超出了本文的范围。</p><p id="7888" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">Remix是一个全栈的web框架，专注于用户界面，并通过web基础工作。它包括SSR和其他开箱即用的特性，没有样板文件。</p><p id="09c0" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae lv" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p><h2 id="e0f9" class="my mh iq bd mi mz na dn mm nb nc dp mq lw nd ne ms lx nf ng mu ly nh ni mw nj bi translated">进一步阅读</h2><div class="pd pe gp gr pf pg"><a rel="noopener  ugc nofollow" target="_blank" href="/5-tips-to-scale-up-your-react-apps-8fb68319062e"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd ir gy z fp pl fr fs pm fu fw ip bi translated">扩展React应用的5个技巧</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">1.将Bit用于可组合设计2。设计令牌3。网络请求的定制钩子4。客户端与服务器状态5。一个…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu kp pg"/></div></div></a></div></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="9e03" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><em class="la">更多内容看</em> <a class="ae lv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> <em class="la">说白了就是</em> </strong> </a> <em class="la">。报名参加我们的</em> <a class="ae lv" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> <em class="la">免费周报</em> </strong> </a> <em class="la">。关注我们关于</em> <a class="ae lv" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> <em class="la">推特</em> </strong> </a>，<a class="ae lv" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> <em class="la">领英</em> </strong> </a> <em class="la">，</em><a class="ae lv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lb ir"><em class="la">YouTube</em></strong></a><em class="la">，以及</em> <a class="ae lv" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> <em class="la">不和</em> </strong> </a> <em class="la">。对增长黑客感兴趣？检查</em> <a class="ae lv" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir"> <em class="la">电路</em> </strong> </a> <em class="la">。</em></p></div></div>    
</body>
</html>