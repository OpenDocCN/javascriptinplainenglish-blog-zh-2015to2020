<html>
<head>
<title>How to efficiently refactor Class Components into Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何有效地将类组件重构为钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-efficiently-refactor-class-components-into-hooks-932b40c49bbe?source=collection_archive---------7-----------------------#2020-05-25">https://javascript.plainenglish.io/how-to-efficiently-refactor-class-components-into-hooks-932b40c49bbe?source=collection_archive---------7-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c85e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解useCallback和useRef的重要性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2977dd3f44f6b47d4000e2037a1ac01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZjYymd1XbJlgoeMr"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@karishea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kari Shea</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ce86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将探讨如何将类组件转换为基于钩子的组件，并理解一些内置钩子的重要性。</p><p id="0101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是钩子的新手，可以看看我以前的文章<a class="ae kv" href="https://levelup.gitconnected.com/an-introduction-to-react-hooks-50281fd961fe" rel="noopener ugc nofollow" target="_blank">这里的</a>来了解React钩子的介绍。</p><h2 id="8693" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">我们开始吧</strong></h2><p id="ad62" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">从<a class="ae kv" href="https://github.com/myogeshchavan97/class-components-to-hooks" rel="noopener ugc nofollow" target="_blank">这里</a>克隆初始项目代码</p><p id="47fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要运行该应用程序，请按顺序执行以下命令</p><p id="2248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.纱线安装<br/> 2。纱线起点</p><p id="0c6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在此找到现场工作演示<a class="ae kv" href="https://class-components-to-hooks.now.sh/" rel="noopener ugc nofollow" target="_blank"/></p><p id="a1ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本项目中，主要组件代码在<code class="fe mq mr ms mt b">src/components/Profile.js</code>中</p><p id="ed43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们显示用户配置文件与认证填充值，并允许用户对配置文件信息进行修改，并将其存储在redux。</p><p id="292e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个演示，为了简单起见，我在<code class="fe mq mr ms mt b">src/utils/ api.js</code>中创建了一个假的API，而不是创建一个单独的Nodejs服务器来处理请求。</p><p id="06f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来理解来自<code class="fe mq mr ms mt b">Profile</code>组件的代码</p><p id="7dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个组件中，当组件被挂载时，我们进行API调用来获取用户配置文件细节</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/e8c164da09e3128afeb3c0a4c6fc3c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZcBdMm6MGGMIa09IjyW9w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">componentDidMount</figcaption></figure><p id="993a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦用户配置文件数据被添加到redux store中，我们将通过实现<code class="fe mq mr ms mt b">componentDidUpdate</code>方法并将其设置为本地状态来获取该数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/d872e358a0f5c412a35bf7eef3d4d676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_qo9FislBJcywTxBgJDOw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">componentDidUpdate</figcaption></figure><p id="ce0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据在<code class="fe mq mr ms mt b">this.props.profile</code>可用，因为我们在<code class="fe mq mr ms mt b">Profile.js</code>中增加了<code class="fe mq mr ms mt b">mapStateToProps</code>方法</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/f7a42830bbdddae7fcba8ffe5e785aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lM4TqVX-CBDeKWEISRUwQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">mapStateToProps</figcaption></figure><p id="9a71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们更改名字或姓氏时，我们调用<code class="fe mq mr ms mt b">handleOnChange</code>方法来更新本地状态。</p><p id="baba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们提交表单时，我们调用<code class="fe mq mr ms mt b">handleSubmit</code>方法来检查是否输入了所有的值，然后分派动作用更新的数据更新存储。</p><p id="177b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是使用基于类的方法的<code class="fe mq mr ms mt b">Profile</code>组件的所有功能。</p><p id="c00a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将把它转换成使用钩子。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="4835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mq mr ms mt b">Profile</code>声明为功能组件</p><pre class="kg kh ki kj gt ne mt nf ng aw nh bi"><span id="335d" class="ls lt iq mt b gy ni nj l nk nl">const Profile = (props) =&gt; {<br/>  //some code <br/>};</span></pre><p id="bc68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了存储名字和姓氏，使用<code class="fe mq mr ms mt b">useState</code>钩子创建一个状态对象，并为<code class="fe mq mr ms mt b">useState</code>钩子添加导入。</p><p id="6317" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，为<code class="fe mq mr ms mt b">errorMsg</code>和<code class="fe mq mr ms mt b">isSubmitted</code>状态值添加单独的<code class="fe mq mr ms mt b">useState</code>调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将<code class="fe mq mr ms mt b">Profile</code>类的render方法返回的JSX复制到<code class="fe mq mr ms mt b">Profile</code>功能组件中。</p><p id="1f0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将每个输入字段的值属性从<code class="fe mq mr ms mt b">this.first_name</code>更改为<code class="fe mq mr ms mt b">state.first_name</code>，将<code class="fe mq mr ms mt b">this.last_name</code>更改为<code class="fe mq mr ms mt b">lastname</code>，并将<code class="fe mq mr ms mt b">this.handleOnChange</code>更改为<code class="fe mq mr ms mt b">handleOnChange</code></p><p id="8b75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mq mr ms mt b">this.handleSubmit</code>改为<code class="fe mq mr ms mt b">handleSubmit</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7acf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将添加handleSubmit和<code class="fe mq mr ms mt b">handleOnChange</code>处理程序</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="735b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些处理程序中，我们已经将<code class="fe mq mr ms mt b">this.state</code>更改为<code class="fe mq mr ms mt b">state</code>并将<code class="fe mq mr ms mt b">this.props</code>更改为<code class="fe mq mr ms mt b">props</code>，并且更新了各自的状态值。</p><p id="36ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，通过运行<code class="fe mq mr ms mt b">yarn start</code>命令启动应用程序，您将看到应用程序显示在控制台中，没有任何错误，输入值也在改变</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/3a14f1c1fb169d5f6f8caafccab020ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLOuaeWGUxd6dLJfqPzZaw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Initial Screen</figcaption></figure><p id="7d6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当组件被挂载时，将调用API来获取用户数据。</p><p id="3d1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在钩子中实现<code class="fe mq mr ms mt b">componentDidMount</code>方法，我们需要将空数组作为第二个参数传递给<code class="fe mq mr ms mt b">useEffect</code>钩子。</p><pre class="kg kh ki kj gt ne mt nf ng aw nh bi"><span id="0625" class="ls lt iq mt b gy ni nj l nk nl">useEffect(() =&gt; {    <br/> props.dispatch(initiateGetProfile());  <br/>}, []);</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ad37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您检查应用程序，您将在控制台和终端中看到警告</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/0b7bdc2bc02e4d1fbbcb7f00b56c64b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyepAM9CALjtwuLLMuOeBw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console warning</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/07b56a961185ae05b72b23dffdbf3826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Xr8CNWB8jHfTbKL06dYSw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Terminal warning</figcaption></figure><p id="cf08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为每当我们在<code class="fe mq mr ms mt b">useEffect</code>中使用任何在<code class="fe mq mr ms mt b">useEffect</code>钩子外声明的变量时，我们都需要在依赖数组中提到它。在这种情况下，它是道具。</p><p id="3a56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们在依赖数组中添加道具</p><pre class="kg kh ki kj gt ne mt nf ng aw nh bi"><span id="07fd" class="ls lt iq mt b gy ni nj l nk nl">useEffect(() =&gt; {<br/> props.dispatch(initiateGetProfile());<br/>}, [props]);</span></pre><p id="1825" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你看到终端，它是干净的，没有错误，但我们的组件不断得到重新呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f2df519867a936f7b257695a1c671b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*WvUPCiF6-P-VxSbcbdOcyA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App re-rendering</figcaption></figure><p id="d4a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我们需要在做出任何改变之前提及<code class="fe mq mr ms mt b">componentDidUpdate</code>方法中的条件</p><pre class="kg kh ki kj gt ne mt nf ng aw nh bi"><span id="4dd4" class="ls lt iq mt b gy ni nj l nk nl">componentDidUpdate(prevProps) {<br/>  if (!_.isEqual(prevProps.profile, this.props.profile)) {<br/>    const { first_name, last_name } = this.props.profile;<br/>    this.setState({ first_name, last_name });<br/>  }<br/>}</span></pre><p id="8129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这个动作不只是被调度一次，而是被无限期调用。</p><p id="11d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们需要使用<code class="fe mq mr ms mt b">useCallback</code>钩子。它接受与<code class="fe mq mr ms mt b">useEffect</code>钩子相同的参数，但是它将返回一个函数的<code class="fe mq mr ms mt b">memoized</code>版本。</p><pre class="kg kh ki kj gt ne mt nf ng aw nh bi"><span id="40c8" class="ls lt iq mt b gy ni nj l nk nl">const processOnMount = useCallback(() =&gt; {<br/>    props.dispatch(initiateGetProfile());<br/>}, [props]);</span><span id="34a7" class="ls lt iq mt b gy ns nj l nk nl">useEffect(() =&gt; {<br/>  processOnMount();<br/>}, [processOnMount]);</span></pre><p id="0ecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是由于<code class="fe mq mr ms mt b">useCallback</code>中传递的道具，这个will还是一样的。要真正解决这个问题，我们需要添加条件，使用<code class="fe mq mr ms mt b">useRef</code>钩子只运行一次。</p><p id="1674" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，我们会将<code class="fe mq mr ms mt b">useRef</code>初始化为false，当动作被调度一次后，我们会将其设置为true。由<code class="fe mq mr ms mt b">useRef</code>创建的Ref包含<code class="fe mq mr ms mt b">current</code>属性，该属性实际保存传递给<code class="fe mq mr ms mt b">useRef</code>的值。</p><pre class="kg kh ki kj gt ne mt nf ng aw nh bi"><span id="3889" class="ls lt iq mt b gy ni nj l nk nl">const processOnMount = useCallback(() =&gt; {<br/>  if (!propsRef.current) { // check if current value is false<br/>    props.dispatch(initiateGetProfile());<br/>    propsRef.current = true;<br/>  }<br/>}, [props]);</span><span id="4963" class="ls lt iq mt b gy ns nj l nk nl">useEffect(() =&gt; {<br/>  processOnMount();<br/>}, [processOnMount]);</span></pre><p id="cd9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您检查应用程序，您将看到该动作只被调度一次，因为只显示了一个<code class="fe mq mr ms mt b">console.log</code>。</p><blockquote class="nt nu nv"><p id="3e13" class="kw kx nw ky b kz la jr lb lc ld ju le nx lg lh li ny lk ll lm nz lo lp lq lr ij bi translated">所以将类组件转换成钩子有时很棘手，但是一旦你有了这个想法，你就可以很容易地编写钩子了。</p></blockquote><p id="86eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将获取更新后的redux store值，并通过添加另一个<code class="fe mq mr ms mt b">useEffect</code>钩子显示在输入字段中。</p><pre class="kg kh ki kj gt ne mt nf ng aw nh bi"><span id="df20" class="ls lt iq mt b gy ni nj l nk nl">seEffect(() =&gt; {<br/> setState(props.profile);<br/>}, [props, props.profile]);</span></pre><p id="f905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，每当redux存储更新时，我们将获得设置为state的更新值。</p><p id="fd09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们需要提到依赖数组中的<code class="fe mq mr ms mt b">props</code>和<code class="fe mq mr ms mt b">props.profile</code>。</p><p id="422f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您运行该应用程序，您将看到该应用程序正在按预期工作。用户详细信息会显示在页面加载中，并且在发生变化时也会在商店中更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/06ab9f23b931abd9a3fc70bae1f25b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*vNFZzUev0IAYFqYNoyQisQ.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Updated store</figcaption></figure><p id="17f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，您会在控制台中看到警告。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/332a8745752273d11ec472f805c2fecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2RpE1x7Bgv6ulImE6ENDA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Warning</figcaption></figure><p id="3848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会感到惊讶，因为我们已经有了受控输入，因为我们使用的是最初正确设置为空字符串的值属性，并且还有正确更新状态的<code class="fe mq mr ms mt b">onChange</code>处理程序。仍然认为我们正在从<code class="fe mq mr ms mt b">controlled</code>向<code class="fe mq mr ms mt b">uncontrolled</code>转变，反之亦然。</p><p id="236a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为当我们加载组件时，即使我们用<code class="fe mq mr ms mt b">first_name</code>和<code class="fe mq mr ms mt b">last_name</code>属性将状态设置为对象，它在组件加载时仍是一个空对象，如下图所示。</p><p id="69e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请仔细查看react dev工具中的钩子部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/bf006314d6004930be6c3d44d74a731f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_j5U2LjMA5YsnmFV8KMHLA.png"/></div></div></figure><p id="68fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将看到，在几分之一秒内，状态从<code class="fe mq mr ms mt b">state: {}</code>变为<code class="fe mq mr ms mt b">state: {first_name: "Tim", last_name: "Lindholm"}</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/99fd28c6c14d09fbc9a6d6293deb3cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/1*luCwJJfLoD3bs_xSoTm6oA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Empty state change</figcaption></figure><p id="9c42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当状态最初为空对象时，<code class="fe mq mr ms mt b">state.first_name</code>和<code class="fe mq mr ms mt b">state.last_name</code>将变为<code class="fe mq mr ms mt b">undefined</code>，并被设置为输入字段的值属性。</p><p id="171b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，输入从<code class="fe mq mr ms mt b">uncontrolled</code>变为<code class="fe mq mr ms mt b">controlled</code>。所以要解决这个问题，我们需要初始化值prop为空字符串，如果它是<code class="fe mq mr ms mt b">undefined</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/bcb45c20c64601712259da33c5942b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfLbxg8YH8sxwN-0qP3IoQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Initialize to empty value</figcaption></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7ff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以通过钩子<a class="ae kv" href="https://github.com/myogeshchavan97/class-components-to-hooks/tree/using-hooks" rel="noopener ugc nofollow" target="_blank">这里</a>和现场演示<a class="ae kv" href="https://class-components-to-hooks.now.sh/" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的源代码</p><p id="c672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。我希望你学到了新东西。</p><p id="d0e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">别忘了直接在你的收件箱</strong> <a class="ae kv" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我的每周简讯，里面有惊人的技巧、窍门和文章。</strong>T9】</a></p><h1 id="10e5" class="oe lt iq bd lu of og oh lx oi oj ok ma jw ol jx md jz om ka mg kc on kd mj oo bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="a0d1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我们的YouTube频道</strong> </a> <strong class="ky ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>