<html>
<head>
<title>What Redux looks like under the hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下的Redux是什么样子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-redux-looks-like-under-the-hood-98636de046d4?source=collection_archive---------1-----------------------#2020-01-26">https://javascript.plainenglish.io/what-redux-looks-like-under-the-hood-98636de046d4?source=collection_archive---------1-----------------------#2020-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f32183665669677d40fc855bbb943ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MOhviViWZCeJf1E4.png"/></div></div></figure><p id="2b0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux是一个被数百万人使用的状态管理库<a class="ae kw" href="https://npm-stat.com/charts.html?package=redux&amp;from=2018-07-01&amp;to=2019-10-23" rel="noopener ugc nofollow" target="_blank">。它提供了一种简单的方法来管理您的全局状态，订阅它并安全地更新它。你们大多数人都知道它是什么，但没有多少人知道它是如何工作的。在这篇文章中，我将向你展示这个项目是如何构建的，它是如何编写的，以及它背后的哲学。在阅读结束时，您可以期望了解Redux是如何设计的，并能够自由阅读其源代码。</a></p><p id="39bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">UPD(2020年2月2日):<a class="ae kw" href="https://github.com/markerikson" rel="noopener ugc nofollow" target="_blank"> Mark Erikson，</a> Redux core maintainer伸手在内容上做了一些笔记，我也做了相应的修改。最重要的是，<code class="fe kx ky kz la b">master</code>分支拥有Redux的TypeScript版本，但是移植还没有完成，发布的Redux包仍然是vanilla JS。</p><p id="a5bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您继续阅读之前，有一个合理的警告:Redux是用TypeScript编写的，在本文的其余部分，我将假设您了解TS知识。我也不会解释如何使用Redux，所以如果你从未听说过它，我建议先阅读文档。不过你不需要知道React，因为我纯粹是在处理Redux。最后，我不属于Redux团队，也不是核心贡献者。我开过几个pr，但这篇文章纯粹是我的主观看法，你们不要当官方看待。</p><p id="43f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文书工作完成后，让我们开始研究源代码。如果你想在你的电脑上继续，我建议克隆/分叉官方Redux repo。</p><h1 id="b5ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">项目结构</h1><p id="0678" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在探索源代码本身之前，让我向您展示这个项目是如何构建的。与任何节点包一样，它有一个<code class="fe kx ky kz la b">package.json</code>文件:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a75d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我省略了几个部分(<code class="fe kx ky kz la b">keywords</code>和<code class="fe kx ky kz la b">devDependencies</code>)，因为它们现在不重要。那么，仅仅看着<code class="fe kx ky kz la b">package.json</code>我们能学到什么呢？嗯，这个包的名字是<code class="fe kx ky kz la b">redux</code> (duh)，它在麻省理工学院的许可下是开源的，它唯一的依赖项是<code class="fe kx ky kz la b">@babel/runtime</code>，它正在用<code class="fe kx ky kz la b">jest</code>进行测试。通过检查脚本部分，我们看到源代码用<a class="ae kw" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>格式化，用<a class="ae kw" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> eslint </a>标记，用<a class="ae kw" href="https://github.com/Microsoft/TypeScript" rel="noopener ugc nofollow" target="_blank">类型脚本</a>编译，用<a class="ae kw" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> rollup </a>打包。执行所有检查和测试的综合脚本是<code class="fe kx ky kz la b">prepare</code>脚本。在项目根中随意运行<code class="fe kx ky kz la b">npm run prepare</code>(如果您已经克隆了repo)并观察输出。如果开发人员没有搞砸任何事情，它应该执行以下任务:</p><ol class=""><li id="041c" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">清理输出目录(<code class="fe kx ky kz la b">/dist /types /es /coverage /lib</code>)</li><li id="fd0c" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">静态检查TypeScript类型</li><li id="c0bd" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">用更漂亮的检查格式</li><li id="da01" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">用ESlint检查代码质量</li><li id="5d4f" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">使用汇总构建生产版本</li><li id="453a" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">用Jest测试项目</li></ol><p id="e839" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会感到困惑，为什么我们需要将redux构建到产品版本中。毕竟，它被导入到项目中，而项目本身在以后会被编译成产品版本。这是redux跨运行时(不同版本的节点、浏览器、其他JS运行时)和JS运行时内不同环境(例如测试)工作所必需的。这是一个很好的实践，我鼓励你在开发自己的库时使用像<code class="fe kx ky kz la b">rollup</code>或<code class="fe kx ky kz la b">bob</code>这样的工具。</p><p id="604f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">main</code>、<code class="fe kx ky kz la b">unpkg</code>和<code class="fe kx ky kz la b">module</code>属性为不同的运行时指定入口点。对于常规节点，使用<code class="fe kx ky kz la b">main</code>。<code class="fe kx ky kz la b">unpkg</code>用于<a class="ae kw" href="https://unpkg.com/" rel="noopener ugc nofollow" target="_blank"> unpkg </a>打包器，<code class="fe kx ky kz la b">module</code>用于支持ES6模块的never环境。这一切都有可能是因为<code class="fe kx ky kz la b">rollup</code>。最后，<code class="fe kx ky kz la b">types</code>属性指向TypeScript类型定义，以在任何导入Redux的项目中提供林挺和类型检查。</p><p id="6d2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是目前我们需要package.json提供的所有内容。我们的下一站是配置文件。这些都是不言自明的，但我还是要回顾一下，以防万一:</p><ul class=""><li id="baa8" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv my mq mr ms bi translated"><code class="fe kx ky kz la b">.babelrc</code>-Babel trans piler配置文件，该文件指定了代码应该如何传输以及期望的兼容性级别</li><li id="39ee" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">.editorconfig</code> -大多数主要代码编辑器和ide都理解的公共配置文件。用于在开发机器之间实现一致性</li><li id="85a8" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">.eslintignore</code>，<code class="fe kx ky kz la b">.eslintrc.js</code>-ESLint的配置文件。指定使用的规则和忽略的文件</li><li id="a175" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">.gitbook.yaml</code>-git book的配置，一个markdown文档解决方案(我不确定它是否被实际使用)</li><li id="062b" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">.prettierrc</code>-config for appellister，指定代码格式化的规则</li><li id="1da5" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">.travis.yml</code> -为TravisCI配置，设置环境并告诉Travis运行什么脚本(这是<code class="fe kx ky kz la b">prepare</code>脚本)</li><li id="564f" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">netlify.yml</code>-Netlify配置，用于部署包含文档的网站</li><li id="d502" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">rollup.config.js</code> -指定目标和目录映射的汇总配置</li><li id="3cb1" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">tsconfig.json</code> -类型脚本传输程序的配置</li></ul><p id="b7b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一节中，我要讲的最后一件事是目录结构。以下是项目根目录中的目录及其用途的列表:</p><ul class=""><li id="7d75" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv my mq mr ms bi translated"><code class="fe kx ky kz la b">build, dist, es, lib, types</code> -我之前提到的生产版本输出</li><li id="9349" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">docs</code> -降价格式的API文档</li><li id="3f24" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">examples</code> -真实世界使用示例的集合。每一个都是一个独立的NPM包。</li><li id="b3ee" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">website</code> -一个<a class="ae kw" href="https://docusaurus.io/" rel="noopener ugc nofollow" target="_blank"> Docasaurus </a>驱动的文档网站。提供网站本身并从/docs文件夹中获取文档。一个独立的NPM包装</li><li id="06bb" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv my mq mr ms bi translated"><code class="fe kx ky kz la b">src</code> -源代码(最后)</li></ul><p id="4bfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您应该知道像Redux这样受欢迎且稳定的库是如何构建的了。现在我将谈谈它如何与CI/CD配合使用。</p><h1 id="1dc9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">项目基础设施</h1><p id="c226" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">该项目托管在ReduxJS组织内的Github上。它包括其他的配套库，比如<a class="ae kw" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank"> react-redux </a>、<a class="ae kw" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank"> reselect </a>和<a class="ae kw" href="https://github.com/reduxjs/redux-toolkit" rel="noopener ugc nofollow" target="_blank"> redux-toolkit </a>。</p><p id="6204" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正在使用的CI解决方案是TravisCI，您可以在这里监控它<a class="ae kw" href="https://travis-ci.org/reduxjs/redux" rel="noopener ugc nofollow" target="_blank">。它在每个拉请求时触发，并运行我前面介绍过的<code class="fe kx ky kz la b">prepare</code>脚本。这确保了测试总是通过，回购中的代码总是被一致地格式化，并且没有引入回归。</a></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/4098fd072b70857b48de5ead1bd7a296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*dzI84vMJtQYzBb8A"/></div></figure><p id="6be5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文档存放在Netlify上，它也运行一些检查。对于每个pull请求，它检查源代码中是否存在不安全的http链接，并在一个临时URL上部署新的docs版本，这样每个人都可以查看并协作。</p><p id="3ffc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我没有找到任何CD解决方案来发布新的包版本，也没有任何自动化的版本增量，所以我假设这是手动完成的。UPD:已确认，没有版本控制/发布自动化。</p><h1 id="6848" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">核心功能</h1><p id="9637" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在终于到了钻研源代码的时候了。我们从<code class="fe kx ky kz la b">src/index.ts</code>开始。为了方便起见，这个文件只是从其余文件中导入所有定义，并从一个地方重新导出它们。下面是清单(稍微简化了一点):</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7e71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了什么应该很清楚了。第1-8行是您应该熟悉的核心Redux函数的导入。接下来，在第10到39行，类型定义被重新导出。TypeScript开发人员使用它们来定义严格的类型存储、减少器和动作创建器。最后，在第41–48行有主导出，在JS和TS环境中使用，包含核心特性。到目前为止，一切顺利。</p><h2 id="1f56" class="na lc iq bd ld nb nc dn lh nd ne dp ll kj nf ng lp kn nh ni lt kr nj nk lx nl bi translated">创建商店</h2><p id="aace" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">接下来，我们来探究一下<code class="fe kx ky kz la b">createStore</code>函数，其源代码位于src/createStore.ts(简体):</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b83f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在第16–25行看到函数类型签名。它看起来非常混乱，因为它严重依赖于类型泛型。这样做是为了使TS环境中的严格类型化成为可能，代价是源代码的可读性。<code class="fe kx ky kz la b">S</code>是根状态本身的类型定义，<code class="fe kx ky kz la b">A</code>是动作的通用定义(注意，它扩展了<code class="fe kx ky kz la b">Action</code>以确保每个动作都有定义的类型)。我现在不讨论<code class="fe kx ky kz la b">Ext</code>和<code class="fe kx ky kz la b">StateExt</code>。</p><p id="b4f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第26–54行是验证逻辑。它检查:</p><ol class=""><li id="1b19" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">您没有通过多个增强器(第26–35行)。这样做是为了简化逻辑，这就是为什么你必须使用<code class="fe kx ky kz la b">applyMiddleware</code>将多个中间件合并成一个。</li><li id="e92d" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">检查初始状态是否是一个函数，在这种情况下，它被视为一个增强器(第37–40行)</li><li id="7670" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">如果增强子存在，检查它是否是一个函数。如果是，将自身作为参数传递给增强器(给它一个提供自定义逻辑的机会)并返回。如果它不是一个函数，抛出一个错误，因为它没有意义(第45–54行)。</li></ol><p id="a460" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然文章名为“代码评审”，我也将给出一些评论和我对代码质量的看法。我会立刻将验证逻辑移到<code class="fe kx ky kz la b">createStore</code>函数之外。它现在有280行，对于一个功能来说，这是太多的行和责任了。尽管我不打算在本文中讨论单元测试(但是如果我应该的话，请告诉我)，这使得测试尤其困难。UPD:有人向我指出，验证逻辑在其他任何地方都不被使用，让它可重用是没有意义的。我同意，但是我关心的主要是可读性。不要误解我的意思，它的可读性很好，我只是在寻找进一步提高它的方法。</p><p id="5f8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第56–60行，您可以看到正在设置的核心变量。<code class="fe kx ky kz la b">currentReducer</code>被设置为<code class="fe kx ky kz la b">reducer</code>(保存你作为参数传递的根规约)，<code class="fe kx ky kz la b">currentState</code>保存状态对象，<code class="fe kx ky kz la b">isDispatching</code>，告诉你一个动作是否正在被调度。我们还有<code class="fe kx ky kz la b">currentListeners</code>和<code class="fe kx ky kz la b">nextListeners</code>，乍一看很混乱。监听器是回调函数，当一个动作被调度时被触发(即使它没有改变状态的内容)。<code class="fe kx ky kz la b">currentListeners</code>保存这类回调函数的列表，在调度时使用。<code class="fe kx ky kz la b">currentListeners</code>是不可变的，这意味着您不能直接更改它的内容，但是您可以重新分配整个列表。<code class="fe kx ky kz la b">nextListeners</code>是可变的，是<code class="fe kx ky kz la b">currentListeners</code>的浅拷贝。每当您添加或删除一个侦听器时，它都会改变<code class="fe kx ky kz la b">nextListeners</code>。最后，当您调度一个动作时，就在触发回调之前，<code class="fe kx ky kz la b">nextListeners</code>被分配给<code class="fe kx ky kz la b">currentListeners</code>(第206行)。这样做是为了防止在分派操作时与添加/删除侦听器相关联的并发错误。令人困惑的部分是，如果有这样的保护，为什么我们需要检查<code class="fe kx ky kz la b">subscribe</code> / <code class="fe kx ky kz la b">unsubscribe</code>函数中的<code class="fe kx ky kz la b">isDispatching</code>？这是一个以太代码或注释的问题，在这种情况下证明<a class="ae kw" href="https://everyday.codes/best-practices/improve-code-readability-by-getting-rid-of-comments/" rel="noopener ugc nofollow" target="_blank">是无用的。</a></p><p id="658a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">ensureCanMutateNextListeners</code>(第69-73行)函数检查<code class="fe kx ky kz la b">nextListeners</code>和<code class="fe kx ky kz la b">currentListeners</code>是否引用同一个对象，如果是，则复制一个<code class="fe kx ky kz la b">currentListeners</code>的浅拷贝并将其分配给<code class="fe kx ky kz la b">nextListeners</code>。它在<code class="fe kx ky kz la b">nextListeners</code>的任何突变之前被调用，以确保这些变化不会传播到<code class="fe kx ky kz la b">currentListeners</code>，原因我在前面解释过。</p><p id="b9bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第80-87行的<code class="fe kx ky kz la b">getState</code>函数对您来说应该很熟悉:您可能在代码中的某个地方使用过它。这也很简单:检查是否有任何动作正在调度，如果没有，返回当前状态。不鼓励您直接使用它而不是依赖像react-redux这样的订阅者/包装器的原因正是因为如果有任何东西被调度，它就会抛出。当编写异步代码或使用中间件如<code class="fe kx ky kz la b">redux-thunk</code>时，这将是特别痛苦的。作为旁注:不要混淆<code class="fe kx ky kz la b">redux-thunk</code>提供的<code class="fe kx ky kz la b">getState</code>功能和直接在商店对象上调用<code class="fe kx ky kz la b">getState</code>。<code class="fe kx ky kz la b">redux-thunk</code>将提供必要的保护，确保您不会以异常结束。</p><p id="d06d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">UPD: <code class="fe kx ky kz la b">redux-thunk</code>本身不提供任何保护，但是从架构上来说，因为它包装了<code class="fe kx ky kz la b">dispatch</code>函数，所以它们是不需要的:<code class="fe kx ky kz la b">getState</code>保证在thunk中是合法的。</p><p id="514a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第115–153行，我们有订阅功能。它实现了我前面介绍的监听器功能。这也非常简单:检查是否有任何东西被分派(尽管这似乎是多余的),然后将新的侦听器推到<code class="fe kx ky kz la b">nextListeners</code>列表中。它返回一个<code class="fe kx ky kz la b">unsubscribe</code>函数，被调用者将使用该函数将自己从监听器列表中删除。它检查监听器是否仍然被订阅(以防被调用者存储了对<code class="fe kx ky kz la b"> unsubscribe</code>的引用并多次调用它)，检查是否有任何东西正在被分派，如果一切都清除了，就从<code class="fe kx ky kz la b">nextListeners</code>中删除监听器。)将<code class="fe kx ky kz la b">currentListeners</code>设置为<code class="fe kx ky kz la b">null</code>。这样做是为了绝对确保不再调用未订阅的侦听器。这似乎是多余的(因为在任何正常情况下都不应该发生)，但我相信开发人员有充分的理由这样做。</p><p id="35b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，调度功能(第180–213行)，这是redux状态的圣杯。首先是第181-186行，它将检查动作是否是一个简单的对象。也就是说，如果操作是可序列化的。这对redux的概念非常重要，并允许其他很酷的特性，如持久化状态或时间旅行。接下来(第188–193行)确保动作定义了一个<code class="fe kx ky kz la b">type</code>属性，因为没有它，动作就没有任何意义。最后，一个熟悉的检查，如果有任何东西被分派。现在，redux代码库中最重要的几行:</p><pre class="me mf mg mh gt nm la nn no aw np bi"><span id="b3a1" class="na lc iq la b gy nq nr l ns nt">try { <br/>  isDispatching = true <br/>  currentState = currentReducer(currentState, action) <br/>} finally { <br/>  isDispatching = false <br/>}</span></pre><p id="fac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它首先将<code class="fe kx ky kz la b">isDispatching</code>标志设置为true，并对状态应用一个动作。您可以看到没有对状态可变性的检查(如果从reducer收到的引用指向相同的状态)，而且，我认为应该有一个。不是一个抛出错误的错误，但至少记录一个警告。在减少状态之后，不管情况如何，<code class="fe kx ky kz la b">isDispatching</code>标志被恢复为真。</p><p id="96ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置完成后，在第218行调度“@@INIT”动作。这样做是为了用缩减器的初始状态填充状态。由于您无法导入此操作类型，因此无法为其添加切换用例，这将在返回初始状态的切换用例中强制执行默认分支。</p><p id="1510" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，所有东西都被组合成一个由<code class="fe kx ky kz la b">createStore</code>函数返回的<code class="fe kx ky kz la b">store</code>对象。全部完成！</p><h2 id="d720" class="na lc iq bd ld nb nc dn lh nd ne dp ll kj nf ng lp kn nh ni lt kr nj nk lx nl bi translated">应用中间件</h2><p id="3072" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们要看的下一个函数是applyMiddleware。它允许为动作分派过程注入定制逻辑。你可能会把它和<code class="fe kx ky kz la b">redux-thunk</code>、<code class="fe kx ky kz la b">redux-saga</code>、<code class="fe kx ky kz la b">redux-logger</code>等中间件配合使用。下面是它的源代码(简体):</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="98df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个文件比redux代码库的其余部分要短得多。<code class="fe kx ky kz la b">applyMiddleware</code>函数接受要应用的中间件列表，并返回一个将在<code class="fe kx ky kz la b">createStore</code>中调用的回调函数(第47行)。这个函数接受<code class="fe kx ky kz la b">createStore</code>函数本身并返回另一个回调(！).这最后一个回调将接受与<code class="fe kx ky kz la b">createStore</code>函数相同的参数集，并将使用<code class="fe kx ky kz la b">createStore</code>函数创建存储，并将中间件附加到其上。至少我认为这是一个不必要的复杂性。我认为这种逻辑对于中间件来说有些过头了，但是它确实允许进行更多的微调，这可能是其他中间件存储增强器所需要的。另一个问题是' @@INIT '动作将在应用中间件之前在<code class="fe kx ky kz la b">createStore</code>函数中调度。</p><p id="f5e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第14行，通过调用<code class="fe kx ky kz la b">createStore</code>函数来创建存储，调用方式与第一次调用的方式相同，除了增强器之外，这次它们没有被传递。在第15行，创建了虚拟<code class="fe kx ky kz la b">dispatch</code>功能。它抛出一个错误，直到函数返回，以确保在构建中间件时没有任何事情发生。</p><p id="107e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第22–25行，创建了<code class="fe kx ky kz la b">middlewareAPI</code>对象。它公开了来自存储区的getState函数和自定义调度函数。它将被传递给中间件，给它们自定义行为的干预点。例如，redux-thunk将这些函数注入到异步动作创建器中。</p><p id="fe50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第26–27行创建了中间件链。这是通过遍历<code class="fe kx ky kz la b">middlewares</code>列表并使用之前创建的<code class="fe kx ky kz la b">middlewareAPI</code>对象调用每个中间件来完成的。这个链是一个函数列表，这些函数接受一个动作，对它做一些事情(例如，等待)并返回一个动作，这个动作可能是也可能不是最初的那个动作。在第27行，返回前的最后一行，<code class="fe kx ky kz la b">dispatch</code>函数被中间件组成的链覆盖。组合意味着函数列表变成一个函数，将它们一个接一个地链接起来。这是通过<code class="fe kx ky kz la b">compose</code>函数完成的，它也是redux代码库的一部分。</p><p id="3b21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，store对象被解包，dispatch函数被覆盖，您的增强redux存储准备就绪！</p><h1 id="bb61" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结束语</h1><p id="a2fa" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这篇文章已经比我预期的要长，所以我现在要结束了。有几个方面和功能我没有介绍，但是通过这篇文章中的知识，你将能够自己理解它们。我要说Redux是一个编写优雅的库，它非常简洁，代码清晰，非常感谢它的众多贡献者。谢谢你的阅读，让我知道我接下来应该解剖什么库！</p></div></div>    
</body>
</html>