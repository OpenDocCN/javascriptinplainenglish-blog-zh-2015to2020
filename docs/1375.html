<html>
<head>
<title>Rxjs Operators — Utility Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rxjs操作员—公用事业操作员</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-operators-utility-operators-38e825959a53?source=collection_archive---------4-----------------------#2020-03-08">https://javascript.plainenglish.io/rxjs-operators-utility-operators-38e825959a53?source=collection_archive---------4-----------------------#2020-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ad6074bf78eece33ba05d8d8f6667b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*li9wCIlBBCXD8fso"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rgeorgelucian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">George Lucian Rusu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="6bde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看一些帮助我们做各种事情的实用操作符，包括<code class="fe lb lc ld le b">tap</code>、<code class="fe lb lc ld le b">delay</code>、<code class="fe lb lc ld le b">delayWhen</code>和<code class="fe lb lc ld le b">dematerialize</code>操作符。</p><h1 id="7eaf" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">轻敲，水龙头</h1><p id="316d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">tap</code>运算符返回一个可观测值，让我们对源可观测值的每次发射执行一些副作用，并返回来自源的相同发射值。</p><p id="82f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要3个可选参数。第一个是一个<code class="fe lb lc ld le b">nextOrObserver</code>对象，它是一个普通的可观察对象或对<code class="fe lb lc ld le b">next</code>的回调。第二个是<code class="fe lb lc ld le b">error</code>回调，这是对源代码中错误的回调。最后是<code class="fe lb lc ld le b">complete</code>回调，当源可观察性完成时调用。</p><p id="bca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它让我们通过运行一个函数来拦截污染源的排放。然后，它返回与源可观测值相同的输出。</p><p id="60a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ec71" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { tap } from "rxjs/operators";<br/>const of$ = of(1, 2, 3);<br/>const result = of$.pipe(<br/>  tap(<br/>    val =&gt; console.log(`value: ${val}`),<br/>    error =&gt; console.log(error),<br/>    () =&gt; console.log("complete")<br/>  )<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="415e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a37e" class="mq lg iq le b gy mr ms l mt mu">value: 1<br/>1<br/>value: 2<br/>2<br/>value: 3<br/>3<br/>complete</span></pre><p id="52ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们记录了发出的值:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="bb5f" class="mq lg iq le b gy mr ms l mt mu">val =&gt; console.log(`value: ${val}`)</span></pre><p id="f0cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe lb lc ld le b">of$</code>观察完成时，我们记录了<code class="fe lb lc ld le b">'complete'</code>,通过写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="5eb9" class="mq lg iq le b gy mr ms l mt mu">() =&gt; console.log("complete")</span></pre><h1 id="b87e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">耽搁</h1><p id="d500" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">delay</code>运算符返回一个可观测值，该可观测值将可观测源的项目发射延迟指定的<code class="fe lb lc ld le b">delay</code>值或直到给定日期。</p><p id="fa6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多需要两个参数。第一个是<code class="fe lb lc ld le b">delay</code>，它是以毫秒为单位的延迟持续时间，或者是一个<code class="fe lb lc ld le b">Date</code>，直到源项目的发射被延迟。</p><p id="9e5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是可选的<code class="fe lb lc ld le b">scheduler</code>，默认为<code class="fe lb lc ld le b">async</code>。它让我们通过返回的可观察值来改变发送值的计时机制。</p><p id="cec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="32bf" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { delay } from "rxjs/operators";<br/>const of$ = of(1, 2, 3);<br/>const result = of$.pipe(delay(1000));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="673a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它，通过<code class="fe lb lc ld le b">delay(1000)</code>将来自<code class="fe lb lc ld le b">of$</code>的可观察值的发射延迟一秒。</p><p id="6363" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该在延迟后得到1、2和3。</p><p id="cad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以将发射延迟到特定日期，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e323" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { delay } from "rxjs/operators";<br/>import moment from "moment";<br/>const of$ = of(1, 2, 3);<br/>const result = of$.pipe(<br/>  delay(<br/>    moment()<br/>      .add(5, "seconds")<br/>      .toDate()<br/>  )<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="7215" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述代码将从当前日期和时间起延迟5秒钟从<code class="fe lb lc ld le b">of$</code>发出值。</p><p id="e5ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出应该保持不变。</p><h1 id="5fb5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">延迟时间</h1><p id="c282" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">delayWhen</code>运算符返回一个可观测值，该可观测值将可观测源的发射延迟一个给定的时间间隔，该时间间隔由另一个可观测值的发射决定。</p><p id="d69e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多需要两个参数。第一个是<code class="fe lb lc ld le b">delayDurationSelector</code>函数，它为源可观察对象发出的每个值返回一个可观察对象。当这个函数返回的可观察对象发出时，那么来自源可观察对象的值也将发出。</p><p id="fc5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是<code class="fe lb lc ld le b">subscriptionDelay</code>的可选参数。它是一个可观察对象，一旦它发出任何值，就会触发对源可观察对象的订阅。</p><p id="8771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b8c7" class="mq lg iq le b gy mr ms l mt mu">import { of, interval } from "rxjs";<br/>import { delayWhen } from "rxjs/operators";<br/>const of$ = of(1, 2, 3);<br/>const result = of$.pipe(delayWhen(val =&gt; interval(Math.random() * 5000)));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="c80c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将延迟发射每一个由<code class="fe lb lc ld le b">of$</code>发出的可观察到的值<code class="fe lb lc ld le b">Math.random() * 5000</code>毫秒。这意味着每个值将在<code class="fe lb lc ld le b">interval(Math.random() * 5000)</code>发出时发出。</p><p id="efbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果将是1、2和3将以随机顺序发射。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/7f255706a3eb4deca18fb3f53dcf64fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vXJwZkIPu3RHpreA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@hudsonhintze?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hudson Hintze</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="bab0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">消失</h1><p id="0453" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">dematerialize</code>返回一个可观察对象，将<code class="fe lb lc ld le b">Notification</code>对象的可观察对象转化为它们所代表的发射。</p><p id="af4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不需要参数。</p><p id="c9a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8d61" class="mq lg iq le b gy mr ms l mt mu">import { of, Notification } from "rxjs";<br/>import { dematerialize } from "rxjs/operators";</span><span id="11f7" class="mq lg iq le b gy mw ms l mt mu">const notifA = new Notification("N", 1);<br/>const notifB = new Notification("N", 2);<br/>const notifE = new Notification("E", undefined, new Error("error"));<br/>const materialized = of(notifA, notifB, notifE);<br/>const upperCase = materialized.pipe(dematerialize());<br/>upperCase.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));</span></pre><p id="c69c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a5b3" class="mq lg iq le b gy mr ms l mt mu">1<br/>2<br/>Error: error</span></pre><p id="c916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们将<code class="fe lb lc ld le b">Notification</code>对象的值转换成了由返回的可观察对象发出的值。</p><p id="d765" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递给<code class="fe lb lc ld le b">Notification</code>构造函数的第二个参数是为发出的正常值发出的值。<code class="fe lb lc ld le b">error</code>是<code class="fe lb lc ld le b">Notification</code>构造函数的第三个参数。</p><p id="54f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">tap</code>返回一个可观测值，让我们对源可观测值的每次发射执行一些副作用，然后从源发射相同的值。</p><p id="f6b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">delay</code>返回一个可观测值，该可观测值将可观测源的项目发射延迟指定的<code class="fe lb lc ld le b">delay</code>值或直到给定的<code class="fe lb lc ld le b">Date</code>。</p><p id="5960" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">delayWhen</code>返回一个可观测值，该可观测值将源可观测值的发射延迟一个给定的时间间隔，该时间间隔由另一个可观测值的发射决定。</p><p id="7708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">dematerialize</code>返回一个可观察对象，它发出由源可观察对象发出的<code class="fe lb lc ld le b">Notification</code>对象中设置的值。</p></div></div>    
</body>
</html>