<html>
<head>
<title>How to create private members in a JavaScript Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript类中创建私有成员</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/private-member-in-javascript-class-2359ef666aaf?source=collection_archive---------0-----------------------#2019-05-25">https://javascript.plainenglish.io/private-member-in-javascript-class-2359ef666aaf?source=collection_archive---------0-----------------------#2019-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/59f004d3410b6bb8f6f7d4bdf4f8a241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtAnywS8tbO1UotziTGbaQ.jpeg"/></div></div></figure><p id="db34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，一直到ES6，官方都不支持JavaScript类中的私有成员。</p><p id="8569" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，有几种方法可以让<em class="kt">表现得好像我们有一个</em>。</p><h1 id="4651" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">关闭</h1><p id="9452" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">JavaScript的闭包自然成为变量所在的“作用域”。如果我们在正确的地方定义了一个类成员，我们就可以拥有私有类成员。</p><p id="7dd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有三种方法可以做到这一点。</p><h2 id="646e" class="lx kv in bd kw ly lz dn la ma mb dp le kg mc md li kk me mf lm ko mg mh lq mi bi translated"><code class="fe mj mk ml mm b">1. Constructors</code></h2><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="8ad8" class="lx kv in mm b gy mv mw l mx my">function ConstructorCar(initValue) {<br/>   this.publicMember = initValue;<br/>   let _privateMember = initValue; //private member<br/>   this.getPrivateMember = function() { return _privateMember; }<br/>   this.setPrivateMember = function(v) { _privateMember = v; }<br/>}</span><span id="91b7" class="lx kv in mm b gy mz mw l mx my">ConstructorCar.prototype.drive = function() {<br/>  //this._privateMember undefined<br/>  console.log(“Drive! “+this._privateMember); <br/>}</span><span id="2e9d" class="lx kv in mm b gy mz mw l mx my">const car2 = new ConstructorCar(100);<br/>console.log(“getPrivateMember: “+car2.getPrivateMember());<br/>car2.drive();</span></pre><h2 id="2f68" class="lx kv in bd kw ly lz dn la ma mb dp le kg mc md li kk me mf lm ko mg mh lq mi bi translated">2.班级</h2><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="8f43" class="lx kv in mm b gy mv mw l mx my">class ClassCar {<br/> constructor(mileage) {<br/>   this.mileage = mileage; //this is public<br/>   var privateMember = mileage;//this is private<br/>   this.getPrivateMember = function() { return this.privateMember; }<br/>   this.setPrivateMember = function(v) { this.privateMember = v; }<br/> }<br/> drive() {<br/>   this.mileage ++;<br/>   console.log(‘Drive! ‘+this.mileage);<br/>   console.log(‘privateMember? ‘+this.privateMember); //undefined<br/> }<br/>}</span><span id="62d3" class="lx kv in mm b gy mz mw l mx my">const car1 = new ClassCar(100);<br/>console.log(“privateMember:”+car1.privateMember);//undefined<br/>car1.getPrivateMember();<br/>car1.drive();</span></pre><h2 id="5a97" class="lx kv in bd kw ly lz dn la ma mb dp le kg mc md li kk me mf lm ko mg mh lq mi bi translated">3.工厂</h2><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="3e0f" class="lx kv in mm b gy mv mw l mx my">//Factory<br/>let FactoryCarProto = (function() {<br/>   var mileage = 0;<br/>   var _privateMember = 0;<br/>   const FactoryCarProto = {<br/>       mileage,<br/>       setMileage(m) {<br/>          this.mileage = m;<br/>       },<br/>       drive() {<br/>          this.mileage ++;<br/>          console.log(‘Drive !’);<br/>       },<br/>       setPrivateMember(v) {<br/>          _privateMember = v;<br/>       },<br/>       getPrivateMember() {<br/>          return _privateMember;<br/>       }<br/>   };<br/>   return FactoryCarProto;<br/>})();</span><span id="3204" class="lx kv in mm b gy mz mw l mx my">function factoryCar() {<br/>   return Object.create(FactoryCarProto);<br/>}</span><span id="be67" class="lx kv in mm b gy mz mw l mx my">const car3 = factoryCar();<br/>car3.drive();<br/>car3._privateMember; //undefined<br/>car3.setPrivateMember(100);<br/>car3.getPrivateMember();</span></pre><p id="ac02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">闭包方法有一个缺点，对于访问私有数据的方法，它们必须在构造函数中创建，这意味着我们在每个实例中都要重新创建它们。会对内存和性能产生影响。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="9b7f" class="ku kv in bd kw kx nh kz la lb ni ld le lf nj lh li lj nk ll lm ln nl lp lq lr bi translated">使用WeakMap</h1><p id="59f8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">这种方法建立在闭包方法之上。</p><p id="89c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们使用作用域变量方法创建一个私有WeakMap，然后使用该WeakMap检索与此相关的私有数据。</p><p id="51c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这比作用域变量方法更快，因为所有的实例可以共享一个WeakMap，所以我们不需要每次创建一个实例都重新创建方法。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="cfa2" class="lx kv in mm b gy mv mw l mx my">let Person = (function () {<br/> let privateProps = new WeakMap();</span><span id="0f59" class="lx kv in mm b gy mz mw l mx my"> class Person {<br/>   constructor(name) {<br/>     this.name = name; // this is public<br/>     privateProps.set(this, {age: 20+name}); // this is private<br/>   }</span><span id="b6c2" class="lx kv in mm b gy mz mw l mx my">   greet() {<br/>     console.log("Hello: "+privateProps.get(this).age);<br/>   }</span><span id="d3f6" class="lx kv in mm b gy mz mw l mx my">   getAge() {<br/>     return privateProps.get(this).age;<br/>   }</span><span id="fe2b" class="lx kv in mm b gy mz mw l mx my">   setAge(age) {<br/>      privateProps.set(this, {age: age+name});<br/>   }</span><span id="109f" class="lx kv in mm b gy mz mw l mx my"> }<br/> return Person;</span><span id="9d45" class="lx kv in mm b gy mz mw l mx my">})();<br/>let joe = new Person(‘Joe’);<br/>console.log(“joe.age? “+joe.age); //undefined;<br/>joe.greet();</span></pre><p id="5c06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你认为WeekMap方式很难看，我们的下一个方法甚至更糟...</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="3590" class="ku kv in bd kw kx nh kz la lb ni ld le lf nj lh li lj nk ll lm ln nl lp lq lr bi translated">使用限定范围的符号</h1><p id="a9ef" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们可以使用符号作为属性名，如下所示。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="1323" class="lx kv in mm b gy mv mw l mx my"><br/>let ClassCar = (function() {<br/>   let privateMemberKey = Symbol(‘privateMember’);<br/>   class ClassCar {<br/>   constructor(mileage) {<br/>      this.mileage = mileage; //this is public<br/>      this[privateMemberKey] = mileage;//this is private<br/>   }<br/>   drive() {<br/>      this.mileage ++;<br/>      console.log(‘Drive! ‘+this.mileage);<br/>      console.log(‘privateMember? ‘+this[privateMemberKey]);<br/>   }<br/> }<br/> return ClassCar;<br/>})();</span><span id="7a79" class="lx kv in mm b gy mz mw l mx my">const car1 = new ClassCar(100);<br/>car1.drive();<br/></span></pre><p id="0c3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，有一种方法可以绕过它:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="d6df" class="lx kv in mm b gy mv mw l mx my">//this will give out private member keys</span><span id="fc38" class="lx kv in mm b gy mz mw l mx my">Object.getOwnPropertySymbols(car1)</span></pre><p id="e859" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以不是真的100% <code class="fe mj mk ml mm b">private</code>。</p><h1 id="9c6f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">厌倦了所有这些变通办法？</h1><p id="0c38" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">好消息！</p><p id="4558" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ESnext来了，JS终于有了对私有成员的支持！</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="350a" class="lx kv in mm b gy mv mw l mx my">class MyClass {<br/>  a = 1;          // .a is public<br/>  #b = 2;         // .#b is private<br/>  static #c = 3;  // .#c is private and static<br/>  static d = 4;<br/>  x = 100;<br/>  incB() {<br/>    this.#b++;<br/>  }<br/>  getB() {<br/>    return this.#b;<br/>  }<br/>  getC() {<br/>    //this.#c ++; //this will error out<br/>    return this.#c;<br/>  }<br/>  /*#incX() { //this won't work<br/>    this.x++;<br/>  }*/<br/>}</span><span id="910d" class="lx kv in mm b gy mz mw l mx my">MyClass.d; //4<br/>var myc = new MyClass();<br/>myc.getC(); // 3</span></pre><h1 id="75a1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">然而…</h1><p id="869e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">ESnext仍然不支持私有函数——<code class="fe mj mk ml mm b">#incX</code>无法工作。</p><p id="13c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">永远记住，不是所有的浏览器都支持新标准(是的，我说的就是你)。</p></div></div>    
</body>
</html>