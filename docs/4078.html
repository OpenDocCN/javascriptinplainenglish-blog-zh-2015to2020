<html>
<head>
<title>JavaScript Algorithms: Valid Parentheses (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:有效括号(LeetCode)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-valid-parentheses-leetcode-71c5b2f61077?source=collection_archive---------0-----------------------#2020-11-15">https://javascript.plainenglish.io/javascript-algorithms-valid-parentheses-leetcode-71c5b2f61077?source=collection_archive---------0-----------------------#2020-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ea1f9e917a45c7061bb044083f0f2e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*243ViVGuthS455jo"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@eklektikum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Iva Rajović</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="83e8" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">描述</h1><p id="6534" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">给定一个仅包含字符<code class="fe lw lx ly lz b">'('</code>、<code class="fe lw lx ly lz b">')'</code>、<code class="fe lw lx ly lz b">'{'</code>、<code class="fe lw lx ly lz b">'['</code>和<code class="fe lw lx ly lz b">']'</code>的字符串<code class="fe lw lx ly lz b">s</code>，确定输入的字符串是否有效。</p><p id="db77" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">在以下情况下，输入字符串有效:</p><ol class=""><li id="2921" class="mf mg in la b lb ma lf mb lj mh ln mi lr mj lv mk ml mm mn bi translated">左括号必须用相同类型的括号括起来。</li><li id="6e0a" class="mf mg in la b lb mo lf mp lj mq ln mr lr ms lv mk ml mm mn bi translated">左括号必须以正确的顺序结束。</li></ol><p id="8b18" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例1: </strong></p><pre class="mt mu mv mw gt mx lz my mz aw na bi"><span id="72b7" class="nb kb in lz b gy nc nd l ne nf"><strong class="lz io">Input:</strong> s = "()"<br/><strong class="lz io">Output:</strong> true</span></pre><p id="cc21" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例2: </strong></p><pre class="mt mu mv mw gt mx lz my mz aw na bi"><span id="46a3" class="nb kb in lz b gy nc nd l ne nf"><strong class="lz io">Input:</strong> s = "()[]{}"<br/><strong class="lz io">Output:</strong> true</span></pre><p id="a41b" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例3: </strong></p><pre class="mt mu mv mw gt mx lz my mz aw na bi"><span id="870b" class="nb kb in lz b gy nc nd l ne nf"><strong class="lz io">Input:</strong> s = "(]"<br/><strong class="lz io">Output:</strong> false</span></pre><p id="8428" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例4: </strong></p><pre class="mt mu mv mw gt mx lz my mz aw na bi"><span id="a240" class="nb kb in lz b gy nc nd l ne nf"><strong class="lz io">Input:</strong> s = "([)]"<br/><strong class="lz io">Output:</strong> false</span></pre><p id="3ada" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例5: </strong></p><pre class="mt mu mv mw gt mx lz my mz aw na bi"><span id="f9a6" class="nb kb in lz b gy nc nd l ne nf"><strong class="lz io">Input:</strong> s = "{[]}"<br/><strong class="lz io">Output:</strong> true</span></pre><p id="a2b3" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">约束:</strong></p><ul class=""><li id="5c66" class="mf mg in la b lb ma lf mb lj mh ln mi lr mj lv ng ml mm mn bi translated"><code class="fe lw lx ly lz b">1 &lt;= s.length &lt;= 104</code></li><li id="7476" class="mf mg in la b lb mo lf mp lj mq ln mr lr ms lv ng ml mm mn bi translated"><code class="fe lw lx ly lz b">s</code>仅由括号组成<code class="fe lw lx ly lz b">'()[]{}'</code>。</li></ul><h1 id="1c40" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决办法</h1><p id="e791" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这里最好的数据结构是<code class="fe lw lx ly lz b">stack</code>。因为我们需要检查这些括号的正确顺序。例如，如果我们有<code class="fe lw lx ly lz b">{][}</code>，括号的数量是正确的，但是顺序是错误的。</p><p id="be70" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">所以。算法非常简单——仔细检查这些括号，如果我们看到一个开始字符，我们需要把它推到<code class="fe lw lx ly lz b">stack</code>，如果没有(结束)——我们需要检查<code class="fe lw lx ly lz b">stack</code>的顶部是否是一个相应的开始字符。</p><p id="a7fb" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">让我们看看下面的例子<code class="fe lw lx ly lz b">{[()]}</code></p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7395" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">让我们想想如何优化这个解决方案。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/c744d5b716fa9c5519db6452f94561d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ihpMLVV9jQ6PXQjT"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@jasonstrull?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jason Strull</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b0f7" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">我们可以创建一个带有开始字符的<code class="fe lw lx ly lz b">Set</code>和带有结束字符的<code class="fe lw lx ly lz b">Map</code>来开始键-值对。现在，我们很容易理解它是否是开放的。如果没有，我们可以很容易地判断出<code class="fe lw lx ly lz b">stack</code>是否有相应的带有开始字符的顶部。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f138" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">看起来更好，但我们仍然可以改进它。</p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="e10d" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">我们可以按结束字符，而不是按开始字符。当我们看到一些结束字符时，我们可以将其与<code class="fe lw lx ly lz b">stack</code>的顶部匹配。因此我们可以减少我们的代码库(只使用<code class="fe lw lx ly lz b">Map</code>)。</p><p id="029b" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">下面我们来看同一个例子<code class="fe lw lx ly lz b">{[()]}</code></p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="15d1" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">让我们实现这种方法:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="94c8" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">我们可以检查<code class="fe lw lx ly lz b">s.length</code>是否均匀。如果不是，我们可以返回false。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c81c" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">现在，我认为它是最优的。因此，时间复杂度是<code class="fe lw lx ly lz b">O(n)</code>，空间复杂度也是<code class="fe lw lx ly lz b">O(n)</code>，因为在最坏的情况下，如果我们得到一个只有开始字符<code class="fe lw lx ly lz b">(({[([{{[(</code>的序列，我们会把它们都推到<code class="fe lw lx ly lz b">stack</code>。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/4bb65d94d231013962801b5567733231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tsv8OgaIJbp9teJv8lBrxw.png"/></div></div></figure><p id="1ff6" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">我希望，它对你有用。感谢阅读！期待您的反馈。回头见，✌️</p><p id="1c65" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="la io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="la io">！</strong></p></div></div>    
</body>
</html>