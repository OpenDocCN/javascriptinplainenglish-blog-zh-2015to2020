<html>
<head>
<title>JavaScript Algorithm: Minimum Distances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:最小距离</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithm-minimum-distances-65dfde1ca83f?source=collection_archive---------2-----------------------#2020-02-12">https://javascript.plainenglish.io/javascript-algorithm-minimum-distances-65dfde1ca83f?source=collection_archive---------2-----------------------#2020-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7c53a4ae76c6d0a39e714df3c55362fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uaRmUWgS5F7LEyw03iOyvQ.png"/></div></div></figure><p id="e8f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于今天的算法，我们将编写一个名为<code class="fe kw kx ky kz b">minimumDistances</code>的函数，它将接受一个数组<code class="fe kw kx ky kz b">a</code>作为输入。</p><p id="fd7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个函数中，我们得到了一个整数数组。每个值都是通过其索引找到的。这个函数的目标是找到数组中任何一对匹配值，并通过计算它们的索引差来确定这两个匹配值之间的距离。计算差异后，确定哪个匹配对具有最小的距离并输出该值。如果不存在匹配对，该函数将返回-1。这里有一个例子:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="135d" class="li lj iq kz b gy lk ll l lm ln">let a = [2,5,3,7,2,3];</span></pre><p id="c86d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的示例数组中，唯一具有匹配值的数字是<strong class="ka ir"> 2 </strong>和<strong class="ka ir"> 3 </strong>。</p><p id="4a61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2的索引是a[0]和a[4]。如果我们减去指数<code class="fe kw kx ky kz b">4 — 0 = 4</code>，我们得到4。</p><p id="d59b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3的索引是a[2]和a[5]。如果我们减去指数<code class="fe kw kx ky kz b">5 — 2 = 3</code>，我们得到3。</p><p id="a913" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在两个距离(4和3)中，该函数将返回最小距离值3。</p><p id="d0be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把这个转换成代码。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7e6a" class="li lj iq kz b gy lk ll l lm ln">let distances = [];</span></pre><p id="638b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">distances</code>变量将是保存所有匹配对与我们的输入数组的距离的数组。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="daed" class="li lj iq kz b gy lk ll l lm ln">for(let i = 0; i&lt;a.length; i++){<br/>    if(a.indexOf(a[i]) !== a.lastIndexOf(a[i])){<br/>      let minDistance = a.lastIndexOf(a[i]) - a.indexOf(a[i]);<br/>      distances.push(minDistance);<br/>    }<br/>}</span></pre><p id="fa60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在输入和数组中循环，首先检查迭代的数字在输入数组中是否匹配。我们使用<code class="fe kw kx ky kz b">indexOf()</code>，它返回第一个出现的指定值的索引。我们还使用了<code class="fe kw kx ky kz b">lastIndexOf()</code>，它返回最后出现的指定值的索引。如果两种方法返回相同的索引，那么这意味着没有匹配对。如果两种方法返回不同的索引，那么这意味着数组中有另一个匹配的数字。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4714" class="li lj iq kz b gy lk ll l lm ln">let minDistance = a.lastIndexOf(a[i]) - a.indexOf(a[i]);<br/>distances.push(minDistance);</span></pre><p id="c6ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当这种情况发生时，我们取匹配数字的索引并减去它们。我们将差异或距离放入我们的<code class="fe kw kx ky kz b">distances</code>数组。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="5c67" class="li lj iq kz b gy lk ll l lm ln">if(distances.length === 0){<br/>    return -1;<br/>}else{<br/>    distances.sort(function(a, b) {<br/>      return a - b;<br/>    });<br/>    <br/>    return distances[0];<br/>}</span></pre><p id="89d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一个数组没有匹配对，我们会知道，因为我们的<code class="fe kw kx ky kz b">distances</code>数组将保持为空。如果这是真的，那么我们将返回-1。</p><p id="b70b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有，那么我们将返回最小的距离。我们通过对数组排序来做到这一点。我们使用<code class="fe kw kx ky kz b">sort()</code>方法和<code class="fe kw kx ky kz b">sort()</code>方法中的比较函数对数组进行排序。比较函数通过将我们的值作为数字而不是字符串进行比较来帮助定义排序顺序(默认方法)。这是为了防止当我们的数组包含一位数和多位数时出现奇怪的排序顺序。</p><p id="3698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们的数组是从最小到最大排序的，我们只关心最小的距离，所以我们返回<code class="fe kw kx ky kz b">distances</code>数组中的第一个值。</p><p id="4ace" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是代码的其余部分:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="b577" class="li lj iq kz b gy lk ll l lm ln">function minimumDistances(a) {</span><span id="0d11" class="li lj iq kz b gy lo ll l lm ln">    let distances = [];</span><span id="33f2" class="li lj iq kz b gy lo ll l lm ln">    for(let i = 0; i&lt;a.length; i++){<br/>        if(a.indexOf(a[i]) !== a.lastIndexOf(a[i])){</span><span id="e0c6" class="li lj iq kz b gy lo ll l lm ln">        let minDistance = a.lastIndexOf(a[i]) - a.indexOf(a[i]);<br/>            distances.push(minDistance);<br/>        }<br/>    }<br/>  <br/>    if(distances.length === 0){<br/>        return -1;<br/>    }else{<br/>        distances.sort(function(a, b) {<br/>          return a - b;<br/>        });<br/>    <br/>        return distances[0];<br/>    }<br/>}</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="cfc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您认为这个算法有用，请查看我的其他JavaScript算法解决方案文章:</p><div class="lw lx gp gr ly lz"><a href="https://medium.com/@endubueze00/javascript-algorithm-viral-advertising-168a872cb557" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">JavaScript算法:病毒式广告</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">对于今天的算法，我们将编写一个名为viralAdvertising的函数，它将接受一个整数n作为…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jw lz"/></div></div></a></div><div class="lw lx gp gr ly lz"><a href="https://medium.com/javascript-in-plain-english/javascript-algorithm-sock-merchant-de9ffa754dfc" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">JavaScript算法:袜子商人</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">对于今天的算法，我们将编写一个名为sockMerchantthat的函数，它将接受两个输入，一个整数n…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn jw lz"/></div></div></a></div></div></div>    
</body>
</html>