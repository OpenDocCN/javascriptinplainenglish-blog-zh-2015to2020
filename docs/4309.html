<html>
<head>
<title>Algorithm Problem Solving: Two-Sum and Three-Sum Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法问题求解:二和与三和问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithm-problem-solving-two-sum-and-three-sum-problem-762606f68b65?source=collection_archive---------4-----------------------#2020-12-02">https://javascript.plainenglish.io/algorithm-problem-solving-two-sum-and-three-sum-problem-762606f68b65?source=collection_archive---------4-----------------------#2020-12-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d35b0b2b4dbeb04a33993510dbeae610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y65yryox9S1rihWg8F13OA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Problem Solving : Two-Sum and Three-Sum Problem</figcaption></figure><div class=""/><blockquote class="jz ka kb"><p id="8e02" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf jd">更新:这篇文章目前包含三和问题的强力方法，不久将更新更好的方法。</strong></p></blockquote><p id="a881" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我已经开始探索2020年代码的出现。对于第一天，场景包括编写一个程序来找出“n”个数字的乘积，这些数字加起来等于给定的目标总值。所以，理想地找到这两三个元素是关键。本文解释了实现这一点的各种方法。</p><h1 id="f2bf" class="lf lg jc bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">两个求和问题的问题陈述</strong></h1><p id="ce9c" class="pw-post-body-paragraph kc kd jc kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">给定一个整数数组<code class="fe mi mj mk ml b">nums</code>和一个整数<code class="fe mi mj mk ml b">target_sum</code>，返回<em class="ke">两个数，使它们相加为</em> <code class="fe mi mj mk ml b">target_sum</code>。</p><p id="a82e" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">例如，假设您的样本输入包含以下内容，并且提供的目标总和是<strong class="kf jd"> 2020 </strong></p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c67b" class="mu lg jc ml b gy mv mw l mx my">1721<br/>979<br/>366<br/>299<br/>675<br/>1456</span></pre><p id="ef55" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在这个列表中，总计为<code class="fe mi mj mk ml b">2020</code>的两个条目是<code class="fe mi mj mk ml b">1721</code>和<code class="fe mi mj mk ml b">299</code>。</p><h2 id="d03e" class="mu lg jc bd lh mz na dn ll nb nc dp lp lb nd ne lt lc nf ng lx ld nh ni mb nj bi translated">方法1:暴力</h2><p id="40b0" class="pw-post-body-paragraph kc kd jc kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">暴力方法很简单。循环遍历每个元素<code class="fe mi mj mk ml b">x</code> <em class="ke"> </em>并查找是否有另一个值<code class="fe mi mj mk ml b">y</code>，该值等于<code class="fe mi mj mk ml b">y = target_sum — x</code>。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nk"><img src="../Images/0b8f2f9feb07bae2f27274f42adc3829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcPnE4fLNljhPOgPaFCHrg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Brute Force way to solve two sum problem using JavaScript</figcaption></figure><h2 id="a636" class="mu lg jc bd lh mz na dn ll nb nc dp lp lb nd ne lt lc nf ng lx ld nh ni mb nj bi translated">方法2:使用哈希映射。</h2><p id="2a46" class="pw-post-body-paragraph kc kd jc kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">时间复杂度和空间复杂度之间的权衡是相反的，在我们的第二种方法中，我们将创建一个散列表。在第一个for循环中，我们遍历数组，并将hashMap中的元素分配给push。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nl"><img src="../Images/d60250c5d95fa079f947267b65dec571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8g6FxJss_u7staQqhvM5pA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Reducing the time complexity in internal for loop from O(n*2) to O(n)</figcaption></figure><p id="2373" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在我们的第二个for循环中，我们使用hasOwnProperty并尝试查找target_sum和当前index元素之间的差值元素。</p><h1 id="1f8b" class="lf lg jc bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">三个和问题的问题陈述</h1><p id="5c22" class="pw-post-body-paragraph kc kd jc kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">给定一个由<em class="ke"> n </em>个整数组成的数组<code class="fe mi mj mk ml b">nums</code>，在<code class="fe mi mj mk ml b">nums</code>中是否有元素<em class="ke"> a </em>、<em class="ke"> b </em>、<em class="ke"> c </em>使得<em class="ke">a</em>+<em class="ke">b</em>+<em class="ke">c</em>=<code class="fe mi mj mk ml b">target_sum</code>？找出数组中所有唯一的三元组，给出<code class="fe mi mj mk ml b">target_sum</code>的和。</p><p id="a5f6" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">例如，假设您的样本输入包含以下内容，并且提供的目标总和是<strong class="kf jd"> 2020 </strong></p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="0beb" class="mu lg jc ml b gy mv mw l mx my">1721<br/>979<br/>366<br/>299<br/>675<br/>1456</span></pre><p id="aba9" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在上面的列表中，总计为<code class="fe mi mj mk ml b">2020</code>的三个条目是<code class="fe mi mj mk ml b">979</code>、<code class="fe mi mj mk ml b">366</code>和<code class="fe mi mj mk ml b">675</code>。</p><h2 id="84e4" class="mu lg jc bd lh mz na dn ll nb nc dp lp lb nd ne lt lc nf ng lx ld nh ni mb nj bi translated">方法1:暴力</h2><p id="4012" class="pw-post-body-paragraph kc kd jc kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">在这种方法中，我们尝试计算当前元素(使用第一个for循环获得)与接下来两个后续元素(使用下面的for循环获得)的和。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nm"><img src="../Images/a6756d1f87d2bfe171b73c3645e7d3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBlaqoEXvlW-ZXvPSuwuZw.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Solving Three sum problem using Brute Force</figcaption></figure><h2 id="0fd4" class="mu lg jc bd lh mz na dn ll nb nc dp lp lb nd ne lt lc nf ng lx ld nh ni mb nj bi translated">做一些修正</h2><p id="4749" class="pw-post-body-paragraph kc kd jc kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">在上述方法中，每个I、j和k变量的索引被访问的次数多于所需次数。从而创建重复条目。我们可以通过简单地跟踪如下访问的索引来避免这种情况。执行所需的时间将几乎相同，但我们至少会摆脱重复。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nn"><img src="../Images/55f8a1716aca00df01f0b5c8559aa3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04rnlAzD5GkDir_TpPWLow.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Removing Duplicate entries in three sum solution set</figcaption></figure><h2 id="0ef8" class="mu lg jc bd lh mz na dn ll nb nc dp lp lb nd ne lt lc nf ng lx ld nh ni mb nj bi translated">美化最内层循环中的代码</h2><p id="5a59" class="pw-post-body-paragraph kc kd jc kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">就像我们在Two Sum方法2中所做的一样，我们可以在最内部的for循环中使用Array.find()方法，使它看起来很漂亮(它对当前的时间复杂度没有影响)。</p><figure class="mm mn mo mp gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi no"><img src="../Images/f7a9eb1a086ee9737cb1479c4285a73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZbQVAeYzv5NVYhPXrPwmw.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Reducing the time complexity in innermost for loop from O(n) to O(1)</figcaption></figure><p id="6b97" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">上述解决方案没有优化到使用最短的执行时间。然而，他们至少会让你重新开始你是如何看待动态编程的。</p><p id="9885" class="pw-post-body-paragraph kc kd jc kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在我的同名GitHub repo中探索更多关于<strong class="kf jd"> <em class="ke"> adventOfCode </em> </strong>问题语句及其解决方案的信息。这是链接</p><div class="im in gp gr io np"><a href="https://github.com/Kailashw/adventOfCode" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jd gy z fp nu fr fs nv fu fw jb bi translated">凯拉什/adventOfCode</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">《降临代码》是一个小型编程难题的年度降临日历，适用于各种技能集和技能水平…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od iu np"/></div></div></a></div></div></div>    
</body>
</html>