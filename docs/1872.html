<html>
<head>
<title>JavaScript Mistakes — Clumsy and Useless Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误——笨拙而无用的表达式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-mistakes-clumsy-and-useless-expressions-733a61bec51b?source=collection_archive---------5-----------------------#2020-04-30">https://javascript.plainenglish.io/javascript-mistakes-clumsy-and-useless-expressions-733a61bec51b?source=collection_archive---------5-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/921facb0cd0662fdfb14675c53079763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hSH-5JR4DaVwCr5C"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@itookthose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sid Balachandran</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c27d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="bf1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看到一些不应该出现在JavaScript代码中的笨拙或无用的表达式，包括无用的块、幻数、多行字符串和空格，以及在没有分配返回对象的情况下使用<code class="fe lb lc ld le b">new</code>。</p><h1 id="e440" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不必要的嵌套块</h1><p id="3ce6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">从ES2015开始，我们可以定义块来隔离我们的代码。它们用花括号表示。</p><p id="2087" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于分离用<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">const</code>声明的块范围的变量或者以严格模式声明的类声明或函数声明很有用，</p><p id="aa6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们应该不必要地添加块。例如，以下是无用的:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0eaf" class="mq lg iq le b gy mr ms l mt mu">{<br/>  function foo() {}<br/>}</span></pre><p id="1a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该把函数声明放在块中。这在JavaScript中是不允许的，因为它们只允许在顶层使用。</p><p id="a20d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该将函数声明放在顶层，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="48de" class="mq lg iq le b gy mr ms l mt mu">function foo() {}</span></pre><p id="90ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该把用<code class="fe lb lc ld le b">let</code>和<code class="fe lb lc ld le b">const</code>声明的变量和常量放在一个块中，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1f37" class="mq lg iq le b gy mr ms l mt mu">{<br/>  let x = 1;<br/>  const y = 2;<br/>}</span></pre><p id="de44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe lb lc ld le b">x</code>和<code class="fe lb lc ld le b">y</code>放在块中。这样，它们只能在块内部被访问。</p><h1 id="cf98" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有神奇的数字</h1><p id="6f24" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">幻数是在我们的代码中多次出现的数字，没有任何明确的含义。它们应该被命名为常量，以使它们的含义清晰，并且我们可以在多个地方引用该常量。</p><p id="bc11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，如果我们需要更改值，我们只需更改一次，而不是在多个地方进行更改。</p><p id="3b92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0851" class="mq lg iq le b gy mr ms l mt mu">let x = 1;<br/>let y = 1;<br/>let z = 1;</span></pre><p id="2bbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将1移入一个常数，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0de2" class="mq lg iq le b gy mr ms l mt mu">const numPerson = 1;<br/>let x = numPerson;<br/>let y = numPerson;<br/>let z = numPerson;</span></pre><p id="6d34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们知道1是人数，我们也可以在多个地方重用它，如果我们需要改变它，只在一个地方改变它。</p><h1 id="5524" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有多个空格</h1><p id="dccf" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">多个空间令人困惑，而且不太干净。例如，代替书写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7c1f" class="mq lg iq le b gy mr ms l mt mu">if(foo  === "baz") {}</span></pre><p id="5424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该改为写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4ce1" class="mq lg iq le b gy mr ms l mt mu">if(foo === "baz") {}</span></pre><p id="cf3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们可以在行尾的多个空格后添加注释。例如，以下内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="478c" class="mq lg iq le b gy mr ms l mt mu">if(foo === "baz") {}    // check if foo is 'baz'</span></pre><p id="9c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它能让注释排列得更好，那么注释出现在一段代码后的多个空格之后也是可以的。</p><h1 id="a6d7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有多行字符串</h1><p id="9415" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们想在拥有模板字符串之前编写多行字符串，我们必须编写如下内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="5ff9" class="mq lg iq le b gy mr ms l mt mu">let x = "foo \<br/>         bar";</span></pre><p id="198e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe lb lc ld le b">'bar'</code>放在带有<code class="fe lb lc ld le b">\</code>的新行上。这是JavaScript的一个未记录的特性，现在我们有了模板字符串，我们不应该使用它。</p><p id="b6d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用如下的模板字符串:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4b18" class="mq lg iq le b gy mr ms l mt mu">let x = `foo <br/>bar`;</span></pre><p id="6cfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a231" class="mq lg iq le b gy mr ms l mt mu">let x = 'foo\nbar'</span></pre><p id="66f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模板字符串保留所有的空格，所以我们必须精确地使用空格，</p><p id="f76f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">\n</code>字符也创建了一个新行。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/a1756c9383af79f6e3254fea59d2fa6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xUTNXBPjZ40b_ObN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Gold</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="055d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不要在没有指定返回对象的情况下使用new运算符</h1><p id="f10b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">new</code>操作符用于创建一个构造函数的新实例。所以，我们总要把它赋给某样东西。</p><p id="d183" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">new</code>而不将返回的结果赋给任何东西是可疑的，因为要么它什么也没实现，要么我们用它来产生副作用。</p><p id="d36d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数不是提交副作用的好地方，因为大多数人期望它返回构造函数的实例。</p><p id="49c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该在没有将返回值赋给我们选择的变量或常量的情况下使用<code class="fe lb lc ld le b">new</code>操作符。</p><p id="9b3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="eb90" class="mq lg iq le b gy mr ms l mt mu">new<strong class="le ir"> </strong>Foo();</span></pre><p id="057e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8b4f" class="mq lg iq le b gy mr ms l mt mu">const foo = new Foo();</span></pre><h1 id="444e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不要使用函数构造函数</h1><p id="3d6d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">Function</code>构造函数不好。我们传入字符串来指定参数和函数体。最后一个参数是主体，而它之前的参数是参数。</p><p id="f4ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们很难调试，因为它们都是字符串。因为它们都是字符串，所以也很难阅读。</p><p id="3811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果它们是动态的，那么攻击者可以注入他们自己的代码，创建他们自己的函数并运行恶意代码。</p><p id="1f85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该不惜一切代价避免使用<code class="fe lb lc ld le b">Function</code>构造函数。而不是写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="28a9" class="mq lg iq le b gy mr ms l mt mu">const add = new Function("a", "b", "return a + b");</span></pre><p id="b84b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="644c" class="mq lg iq le b gy mr ms l mt mu">const add = (a, b) =&gt; a + b;</span></pre><p id="10d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，它们就很干净，很容易调试。</p><h1 id="e65d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="da41" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">无用的块、多余的空格、不标准的多行字符串都应该避免。</p><p id="1697" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幻数应该被指定为常量，这样它们就可以被理解和重用。</p><p id="001d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe lb lc ld le b">new</code>返回的任何东西都应该赋给一个变量或常量。</p><p id="5aa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们永远不应该使用<code class="fe lb lc ld le b">Function</code>构造函数来使我们的代码易于阅读和调试，并让我们避免潜在的安全问题。</p><h2 id="5f4a" class="mq lg iq bd lh mw mx dn ll my mz dp lp ko na nb lt ks nc nd lx kw ne nf mb ng bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="fbc3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="34ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>