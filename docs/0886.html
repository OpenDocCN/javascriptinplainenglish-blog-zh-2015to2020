<html>
<head>
<title>Nuxt-Socket.IO: How Namespaces Config May Make Your Life Insanely Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">nuxt-插座。IO:名称空间配置如何让您的生活变得无比简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nuxt-socket-io-how-namespaces-config-may-make-your-life-insanely-easier-5d6947d2f9da?source=collection_archive---------6-----------------------#2019-12-28">https://javascript.plainenglish.io/nuxt-socket-io-how-namespaces-config-may-make-your-life-insanely-easier-5d6947d2f9da?source=collection_archive---------6-----------------------#2019-12-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2ca4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TL；DR——这份圣诞礼物来得有点晚，但我认为一旦它被完全理解，nuxt-socket-io 的用户会喜欢它的。现在，可以配置套接字了。IO发射器、监听器和“发射回”直接在指定的<em class="kn">名称空间</em>的<code class="fe kj kk kl km b">nuxt.config</code>中。本文描述了如何利用这个新特性。</p><p id="67cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">声明:我是nuxt-socket-io模块的作者。我在这里提出了一种新的语法，可能需要一些时间来适应，但我认为这是一种有意义的语法。以开放的心态对待它。</p><p id="b1a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:语法中显示的箭头应该类似于我的封面图片中的箭头(两个破折号和一个“&gt;”)。您看到的Unicode箭头只是该网站自动格式化的一部分。</p></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><p id="1f86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">先决条件:</strong></p><ol class=""><li id="f5d0" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated"><a class="ae ki" href="https://medium.com/javascript-in-plain-english/introduction-to-nuxt-socket-io-b78c5322d389" rel="noopener">Nuxt插座介绍。IO </a> —这描述了Nuxt插座。IO和基本设置。</li></ol><p id="b661" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">简介:</strong></p><p id="4277" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插座。IO是web的实时引擎，也是Nuxt-Socket。IO模块使得在Nuxt应用程序中使用它变得简单明了。很多时候，希望实例化套接字。组件内部的IO客户端，然后将通信范围限制在那些组件应该和将要关心的范围内。</p><p id="704b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，聊天室组件可能只想与聊天室服务对话，而房间的频道可能只想与该频道的服务对话。在特定渠道发送的信息不应该泄露到房间的其他地方。无论我们是否称它们为“通道”或“房间”，单词“名称空间”似乎对每种情况都是最合适的。另外，尽管“房间”和“频道”将我们的思维局限于“仅仅是一个聊天应用程序”，但另一方面，“名称空间”这个术语是通用的，它允许我们考虑所有web应用程序的范围通信。</p><p id="eb72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了将组件的IO范围限定为给定名称空间的IO之外，通常还希望在组件被销毁时发出断开连接的信号(即关闭套接字)。虽然开发人员自己完成清理步骤是个好习惯，但是对于给定应用程序中的每个组件来说，这种习惯要么很麻烦，要么很容易忘记。</p><p id="6893" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，考虑到上述情况，nuxt-socket-io插件和名称空间配置特性有以下目标:</p><ul class=""><li id="0064" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh le lb lc ld bi translated">插件必须允许在“nuxt.config”中为每个套接字配置名称空间。</li><li id="9e92" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated">该插件必须在页面和组件级别支持发射器、监听器和“发射回”的配置。</li><li id="22ca" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated">对于已经配置了模块的用户来说，配置必须和vuex选项(监听器和发送回)一样简单。</li><li id="a883" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated">这个新特性必须支持一个新的、更直观的箭头(\-\--&gt;)语法(两个破折号和一个“&gt;”)。Medium.com格式错误地连接了破折号)。这使得IO配置更容易进行版本控制，并在需要时与利益相关者(非开发人员)共享。</li><li id="0784" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated">该配置必须支持在指定的IO事件之前和之后运行挂钩。</li><li id="24ec" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated">默认情况下，插件必须在组件被销毁之前自动断开套接字(通过将<code class="fe kj kk kl km b">teardown: false</code>选项传递给<code class="fe kj kk kl km b">this.$nuxtSocket</code>可以覆盖这一点)。</li><li id="4568" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated">该插件通过鼓励应用程序开发人员编写更少但更一致的代码，让他们的生活变得更轻松。</li><li id="1a95" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated">该插件仍然必须公开socket.io客户端实例，以防开发人员需要直接访问客户端API方法。<br/> <br/>现在，可以在<code class="fe kj kk kl km b">nuxt.config</code>中配置名称空间了。每个套接字集可以有自己的名称空间配置，每个名称空间现在可以有发射器、监听器和发射回。该配置支持每个条目中的箭头语法，以帮助描述流(也支持前/后挂钩指定)。</li></ul><p id="48e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">配置名称空间</strong></p><p id="5271" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本节描述如何为每个名称空间配置发射器、监听器和发射回。一般语法是:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/4d1c5d6f4e9798fe216f805eadea2f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*psywWV0UkAb3eDi3jURAiw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">General Syntax</figcaption></figure><p id="36cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时正文包括一个“+”、“←”或一个“→”。虽然字符“]”、“[”、“+”、“↓”和“→”的使用和位置非常严格，但是您为钩子、事件和道具使用的*名称*完全由您决定。</p><p id="f0ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kn">具体的</em>语法如下:</p><ul class=""><li id="f95d" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh le lb lc ld bi translated"><strong class="jm io">发射器:</strong></li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/2a58b89efee4a43563e7555f8d051ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*S6tkKGAiTit1yQZEk6DU5g.jpeg"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Emitter Syntax</figcaption></figure><p id="08fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">**如何看待这个问题:IO事件由<code class="fe kj kk kl km b">componentMethod</code>触发，事件“componentMethod”用“msg”发送(在组件中定义为<code class="fe kj kk kl km b">this.msg</code>)。当服务器响应时，该响应将发送到组件的prop <code class="fe kj kk kl km b">componentProp</code>。<code class="fe kj kk kl km b">preEmit</code> hook在事件发送前运行，<code class="fe kj kk kl km b">postRx</code> hook在接收到数据后运行。这里的一个好东西是<em class="kn">插件</em>为你创建了<em class="kn">组件方法</em>,这样你就不必这么做了。只要调用它，它就会工作。</p><p id="19f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">→挂钩<code class="fe kj kk kl km b">preEmit</code>和<code class="fe kj kk kl km b">postRx</code>是可选的，但是如果使用它们，则需要“]”和“[”字符，以便插件可以解析它们。这些钩子将在组件的方法部分定义，如<code class="fe kj kk kl km b">this.preEmit</code>和<code class="fe kj kk kl km b">this.postRx</code><br/>→<code class="fe kj kk kl km b">msg</code>是可选的，但如果使用，必须使用“+”字符<br/>→<code class="fe kj kk kl km b">componentMethod</code>由插件自动创建，并发送同名事件。如果<code class="fe kj kk kl km b">componentMethod</code>被命名为“getMessage”，它发送事件“getMessage”<br/>→这个<code class="fe kj kk kl km b">componentProp</code>是可选的，但是如果被输入，它将是一个属性，如果有响应返回，它将与响应一起被设置。这也是可选的，需要在组件上进行初始定义，否则它不会被设置。如果你试图渲染未定义的道具，Vuejs也会抱怨。如果条目中省略了<code class="fe kj kk kl km b">componentProp</code>，箭头“→”也可以省略。</p><ul class=""><li id="e33a" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh le lb lc ld bi translated"><strong class="jm io">听众</strong>:</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi lx"><img src="../Images/1ff2fcf6ab626650b0f1d2908ef8be21.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*PUiSXLI-Xoslzbfgzmlb_A.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Listeners Syntax</figcaption></figure><p id="68b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">**如何看待这个问题:当接收到事件“listenEvent”时，属性<code class="fe kj kk kl km b">this.componentProp</code>将被设置为该事件的数据。<code class="fe kj kk kl km b">preHook</code>将在接收数据时运行，但在设置<code class="fe kj kk kl km b">componentProp</code>之前。<code class="fe kj kk kl km b">postRx</code>设定<code class="fe kj kk kl km b">componentProp</code>后，挂钩将运行。</p><p id="b909" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">→两个<code class="fe kj kk kl km b">preHook</code>和<code class="fe kj kk kl km b">postRx</code>挂钩都是可选的。这里，<code class="fe kj kk kl km b">preHook</code>在接收数据时被调用，但<em class="kn">在</em>设置<code class="fe kj kk kl km b">componentProp</code>之前。<code class="fe kj kk kl km b">postRx</code>挂钩是在设置好道具后调用的。<code class="fe kj kk kl km b">this.preHook</code>和<code class="fe kj kk kl km b">this.postRx</code>需要在组件的方法部分定义，如果计划使用其中一个的话。<br/> →如果使用箭头语法，当接收到<code class="fe kj kk kl km b">listenEvent</code>时，<code class="fe kj kk kl km b">componentProp</code>将设置该事件的数据。如果只输入了<code class="fe kj kk kl km b">listenEvent</code>,那么插件将尝试在同名的组件上设置一个属性。即，如果<code class="fe kj kk kl km b">listenEvent</code>是“progressRxd ”,那么插件将尝试在组件上设置<code class="fe kj kk kl km b">this.progressRxd</code>。<br/> →重要提示:这个语法现在也可以作用于Vuex选项的突变和动作，它们也被设置为监听器。</p><ul class=""><li id="2950" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh le lb lc ld bi translated"><strong class="jm io">发射回来</strong>:</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/a9ae547a554a1931e08cf4d1014fcfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4MF_onYrMOqZH-YhbCkscA.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Emitbacks Syntax</figcaption></figure><p id="3c0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">**如何思考这个问题:当一个组件的属性<code class="fe kj kk kl km b">watchProp</code>发生变化时，发回事件“emitEvt”。<code class="fe kj kk kl km b">preEmitHook</code>将在数据发出之前运行，而<code class="fe kj kk kl km b">postAck</code>将在服务器确认其事件(如果有的话)之后运行。</p><p id="d082" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">→ <code class="fe kj kk kl km b">preEmitHook</code>和<code class="fe kj kk kl km b">postAck</code>挂钩可选。<code class="fe kj kk kl km b">preEmitHook</code>在发出事件前运行，<code class="fe kj kk kl km b">postAck</code> hook在收到确认消息(如果有)后运行。如果计划使用的话,<code class="fe kj kk kl km b">this.preEmitHook</code>和<code class="fe kj kk kl km b">this.postAck</code>需要在组件的方法中定义。<br/> → <code class="fe kj kk kl km b">watchProp</code>是组件上使用“myobj . child . grande”语法观察的属性。就像在组件上一样。<br/> → <code class="fe kj kk kl km b">emitEvt</code>是当<code class="fe kj kk kl km b">watchProp</code>改变时向服务器发出的事件名称。如果省略<code class="fe kj kk kl km b">watchProp</code>和箭头“←”，则<code class="fe kj kk kl km b">emitEvt</code>将兼作<code class="fe kj kk kl km b">watchProp</code>。<br/> →重要提示:这个语法现在也可以在Vuex选项中工作，有一个重要的区别。在Vuex(尤其是Nuxt)中，监视属性路径可能需要正斜杠“/”。例如，如果stores文件夹中有一个“examples.js”文件，其状态属性为“sample”和“sample2”，则watchProp必须指定为“examples/sample”和“examples/sample2”。该规则的例外是“index.js ”,它被视为存储根。即index.js中的“样本”将简称为“样本”而非“索引/样本”)</p></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><p id="246b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">配置示例:</strong></p><p id="de61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下面的配置为例:<code class="fe kj kk kl km b">nuxt.config.js</code>中的<br/>:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi md"><img src="../Images/98bbaa30e239407e204039bfd2670749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*ki14IBIctqwZxpS_bo5dvw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Namespaces Config Example</figcaption></figure><ol class=""><li id="c8a6" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">首先，我们来分析一下<code class="fe kj kk kl km b">/index</code>配置。</li></ol><ul class=""><li id="9cf7" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh le lb lc ld bi translated"><strong class="jm io">发射器</strong> : <br/>当<code class="fe kj kk kl km b">getMessage()</code>被调用时，事件“getMessage”将与组件数据<code class="fe kj kk kl km b">this.testMsg</code>一起发送。<code class="fe kj kk kl km b">this.testMsg</code>应该在组件上定义，但如果没有定义，则不会发送任何消息(当组件数据未定义时，插件会发出警告)。当收到响应时，组件上的<code class="fe kj kk kl km b">this.message2Rxd</code>将被设置为该响应。</li><li id="4ba6" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated"><strong class="jm io">监听器</strong> : <br/>当接收到<code class="fe kj kk kl km b">chatMessage2</code>时，将设置组件上的<code class="fe kj kk kl km b">this.chatMessage2</code>。当接收到<code class="fe kj kk kl km b">chatMessage3</code>时，映射的属性<code class="fe kj kk kl km b">this.message3Rxd</code>将被设置。</li></ul><p id="0bf7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.让我们来分析一下<code class="fe kj kk kl km b">/examples</code>的配置。</p><ul class=""><li id="885c" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh le lb lc ld bi translated"><strong class="jm io">发送回</strong> : <br/>当<code class="fe kj kk kl km b">this.sample3</code>组件发生变化时，事件“sample3”将被发送回服务器。当<code class="fe kj kk kl km b">this.myObj.sample4</code>在组件中改变时，映射的事件“sample4”将被发射回来。</li><li id="9d57" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated"><strong class="jm io">发射器</strong> : <br/>当<code class="fe kj kk kl km b">this.getProgress()</code>被调用时，首先会调用<em class="kn"/><code class="fe kj kk kl km b">this.reset()</code>(如果定义了的话)，然后<em class="kn"/>事件“getProgress”会被发出，并带有消息<code class="fe kj kk kl km b">this.refreshInfo</code>。当收到响应时，<code class="fe kj kk kl km b">this.progress</code>将被设置为响应，然后<code class="fe kj kk kl km b">this.handleDone()</code>将被调用(如果已定义)。</li><li id="296e" class="kv kw in jm b jn lf jr lg jv lh jz li kd lj kh le lb lc ld bi translated"><strong class="jm io">监听器</strong> : <br/>当接收到事件“progress”时，<code class="fe kj kk kl km b">this.progress</code>将被设置为该数据。</li></ul><p id="0125" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">聊天室:一个更令人兴奋的例子</p><p id="ac8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想看一个稍微刺激一点的例子吗？看看我的[非常基础的]聊天室例子！</p><p id="6490" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.克隆我的git回购:<a class="ae ki" href="https://github.com/richardeschloss/nuxt-socket-io" rel="noopener ugc nofollow" target="_blank">https://github.com/richardeschloss/nuxt-socket-io</a>T34】2。用<code class="fe kj kk kl km b">npm run dev:server</code> <br/> 3运行服务器。前往聊天室页面:<a class="ae ki" href="https://localhost:3000/rooms" rel="noopener ugc nofollow" target="_blank">https://localhost:3000/rooms</a>尽情享受吧！(打开两个浏览器窗口，因为…你需要至少两个客户端进行对话；你也可以和自己聊天，如果你想的话:))</p><p id="f1c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本系列的下一篇文章将有助于解释这个例子。</p><p id="2fb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="e0eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是关于nuxt-socket-io的新名称空间配置特性的一个相当长但很重要的讨论。虽然阅读本文所花费的时间可能比预期的要长，但是利用您在这里学到的知识，很有可能会大大减少您在未来的web应用程序上花费的时间。一开始可能会很颠簸，但我想随着时间的推移，你会习惯这种语法的。如果你讨厌它，不用担心…插件仍然会直接暴露socket.io客户端API，所以如果需要，你的指尖会有。</p><p id="0dda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一条:<a class="ae ki" href="https://medium.com/javascript-in-plain-english/nuxt-socket-io-how-to-create-a-stealth-mode-chat-application-in-under-10-minutes-28e8e42ceae8?source=your_stories_page---------------------------" rel="noopener"> Nuxt套接字。IO:如何在10分钟内创建隐形模式聊天应用</a></p><p id="f9ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">信用/认可</strong></p><p id="700a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢apronti的<a class="me mf ep" href="https://medium.com/u/c6a10d62e582?source=post_page-----5d6947d2f9da--------------------------------" rel="noopener" target="_blank">打开了这个问题并询问了它。起初，我不认为有一个干净的方法来创建这个功能，我最初退出得太早。但是，经过更多的思考，我认为这个解决方案可能会让大多数用户满意(祈祷吧)。</a></p></div></div>    
</body>
</html>