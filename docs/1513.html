<html>
<head>
<title>Create and Use Data Types with Express GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express GraphQL创建和使用数据类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-and-use-data-types-with-express-graphql-518da213383b?source=collection_archive---------10-----------------------#2020-03-25">https://javascript.plainenglish.io/create-and-use-data-types-with-express-graphql-518da213383b?source=collection_archive---------10-----------------------#2020-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce2aedf6e8511aca345869bbdd2e882b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-PS3QukUHq3lEo-n"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@srd844?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephen Dawson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="27d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用Express创建一个简单的GraphQL服务器。为此，我们需要<code class="fe lb lc ld le b">express-graphql</code>和<code class="fe lb lc ld le b">graphql</code>包装。</p><p id="41b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何创建和使用我们自己的GraphQL数据类型。</p><h1 id="40da" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">对象类型</h1><p id="63aa" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在许多情况下，我们不想接受并从API返回一个数字或一个字符串。我们可以创建自己的数据类型来接受和返回我们想要从API中得到的任何东西。</p><p id="555a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了<code class="fe lb lc ld le b">express-graphql</code>包，我们可以在一个字符串中定义我们的数据类型，然后将其传递给<code class="fe lb lc ld le b">buildSchema</code>函数。</p><p id="8560" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来定义我们的类型，构建一个模式，并将我们的解析器添加到我们的代码中:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d8e9" class="mq lg iq le b gy mr ms l mt mu">const express = require('express');<br/>const graphqlHTTP = require('express-graphql');<br/>const { buildSchema } = require('graphql');<br/>const schema = buildSchema(`<br/>  type RandomDie {<br/>    numSides: Int!<br/>    rollOnce: Int!<br/>    roll(numRolls: Int!): [Int]<br/>  }</span><span id="1b0c" class="mq lg iq le b gy mv ms l mt mu">  type Query {<br/>    getDie(numSides: Int): RandomDie<br/>  }<br/>`);</span><span id="8538" class="mq lg iq le b gy mv ms l mt mu">class RandomDie {<br/>  constructor(numSides) {<br/>    this.numSides = numSides;<br/>  }</span><span id="992b" class="mq lg iq le b gy mv ms l mt mu">  rollOnce() {<br/>    return 1 + Math.floor(Math.random() * this.numSides);<br/>  }</span><span id="1e33" class="mq lg iq le b gy mv ms l mt mu">  roll({ numRolls }) {<br/>    const output = [];<br/>    for (let i = 0; i &lt; numRolls; i++) {<br/>      output.push(this.rollOnce());<br/>    }<br/>    return output;<br/>  }<br/>}</span><span id="de05" class="mq lg iq le b gy mv ms l mt mu">const root = {<br/>  getDie: ({ numSides }) =&gt; {    <br/>    return new RandomDie(numSides || 6);<br/>  },<br/>};</span><span id="6fd5" class="mq lg iq le b gy mv ms l mt mu">const app = express();</span><span id="3b93" class="mq lg iq le b gy mv ms l mt mu">app.use('/graphql', graphqlHTTP({<br/>  schema: schema,<br/>  rootValue: root,<br/>  graphiql: true,<br/>}));<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="5090" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过编写以下内容来定义我们的模式:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="22cb" class="mq lg iq le b gy mr ms l mt mu">const schema = buildSchema(`<br/>  type RandomDie {<br/>    numSides: Int!<br/>    rollOnce: Int!<br/>    roll(numRolls: Int!): [Int]<br/>  }<br/>  type Query {<br/>    getDie(numSides: Int): RandomDie<br/>  }<br/>`);</span></pre><p id="8c10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lb lc ld le b">numSides</code>场和<code class="fe lb lc ld le b">rollOnce</code><code class="fe lb lc ld le b">roll</code>法定义了<code class="fe lb lc ld le b">RandomDie</code>型。</p><p id="846d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义了我们的<code class="fe lb lc ld le b">getDie</code>查询，以允许访问我们在<code class="fe lb lc ld le b">RandomDie</code>类型中定义的成员。</p><p id="0d3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们定义了我们的<code class="fe lb lc ld le b">RandomDie</code>类，我们将在我们稍后定义的<code class="fe lb lc ld le b">getDie</code>解析器中使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f72b" class="mq lg iq le b gy mr ms l mt mu">class RandomDie {<br/>  constructor(numSides) {<br/>    this.numSides = numSides;<br/>  }<br/>  rollOnce() {<br/>    return 1 + Math.floor(Math.random() * this.numSides);<br/>  }<br/>  roll({ numRolls }) {<br/>    const output = [];<br/>    for (let i = 0; i &lt; numRolls; i++) {<br/>      output.push(this.rollOnce());<br/>    }<br/>    return output;<br/>  }<br/>}</span></pre><p id="353d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个类中，我们创建了<code class="fe lb lc ld le b">rollOnce</code>和<code class="fe lb lc ld le b">roll</code>方法，我们将返回结果。</p><p id="28fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们定义<code class="fe lb lc ld le b">getDie</code>解析器如下:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0e3e" class="mq lg iq le b gy mr ms l mt mu">const root = {<br/>  getDie: ({ numSides }) =&gt; {    <br/>    return new RandomDie(numSides || 6);<br/>  },<br/>};</span></pre><p id="6c7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从参数中获取<code class="fe lb lc ld le b">numSides</code>，然后在实例化时将其传递给<code class="fe lb lc ld le b">RandomDie</code>构造函数。</p><p id="da5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe lb lc ld le b">/graphql</code>页面，我们可以在图形化界面中进行如下查询:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0467" class="mq lg iq le b gy mr ms l mt mu">{<br/>  getDie(numSides: 6) {<br/>    rollOnce<br/>    roll(numRolls: 3)<br/>    numSides<br/>  }<br/>}</span></pre><p id="fbf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该得到如下的回应:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="648d" class="mq lg iq le b gy mr ms l mt mu">{<br/>  "data": {<br/>    "getDie": {<br/>      "rollOnce": 3,<br/>      "roll": [<br/>        6,<br/>        4,<br/>        5<br/>      ],<br/>      "numSides": 6<br/>    }<br/>  }<br/>}</span></pre><p id="a283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们访问字段和调用没有参数的方法的方式与使用<code class="fe lb lc ld le b">rollOnce</code>和<code class="fe lb lc ld le b">numSides</code>的方式相同。</p><p id="473b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与传统的REST APIs相比，这种定义对象的方式为我们提供了一些优势。我们可以只进行一次查询来获得我们需要的东西，而不是使用一个API请求来获得关于一个对象的基本信息，以及多个请求来了解关于该对象的更多信息。</p><p id="dbe3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这节省了带宽，提高了性能，并简化了客户端逻辑。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ad7d4167cefbf2abbca7373c4fe3ec37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-HYaFX-ao_wVQBb8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@webaroo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Webaroo.com.au</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3811" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="966c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以通过将它与模式的其他部分放在一起来创建新的类型。然后我们可以使用<code class="fe lb lc ld le b">buildSchema</code>函数来构建模式。</p><p id="74cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，我们就创建了一个类来将类型字段映射到类成员中。然后，我们可以在解析器中实例化该类。</p><p id="95a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以通过发送类名作为查询名，然后发送成员名和参数(如果需要的话)来发出请求。</p><h2 id="00e4" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated"><strong class="ak">用简单的英语写的JavaScript的注释:</strong></h2><p id="8029" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>