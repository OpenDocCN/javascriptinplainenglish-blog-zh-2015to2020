# 学习 Angular 最难的部分

> 原文：<https://javascript.plainenglish.io/the-hardest-parts-of-learning-angular-5b9ba1a4bbb6?source=collection_archive---------0----------------------->

## 有角的

## Angular 没有学习曲线，它有学习悬崖。但是哪些部分最难把握呢？

![](img/b12da004e90c7d49eaf850edcc39362b.png)

Sitting on the Angular Learning Cliff

> “Angular 适合初学者”
> 
> —没有一个人

# 一个完整的 JavaScript Web 框架

## 是什么让 Angular 与众不同？

Angular 是最流行的 JavaScript 框架之一。它由 Google 开发和维护，用于构建现代的单页应用程序(SPA)和渐进式 Web 应用程序(PWA)。

作为一个完整的框架，**它拥有 JavaScript web 应用程序所需的一切。**

它提供了自以为是的架构，通过在组件、服务、指令、管道和模块之间划分应用程序结构，实现了关注点的完全分离。这些是提供独特特征和功能的不同类型的`class`。这种架构使得可扩展的开发&在大型团队中运行良好。

**它提供 web 开发的完整 MVC**。它提供了支持高级动态渲染的内置组件和模板，以及能够使用延迟加载来分割包大小的模块&减少前期主包大小。

作为一名 web 开发人员，使用 Angular 可以继承所面临的最常见问题的解决方案。这些解决方案内置于框架中。这是它区别于 React 和其他“聚焦视图”库**的地方。**

Angular 提供的开箱即用的最重要和最有价值的功能是 Angular CLI、智能 IDE 工具、动态渲染、模板、依赖注入、AOT-JIT、路由、动画、通用服务器端渲染(SSR)、测试、可访问性、国际化、安全功能、PWA 支持、Web-Workers 等等。

**这些内置功能和工具展示并鼓励以有角度的方式做事**。这些都是你必须学会充分利用框架的东西。

## TypeScript 增加了复杂性

Angular 的 web 开发概念方法是通过对常见有用的 JavaScript 模式进行高级抽象来实现的。对于使用 Angular 的 web 开发人员来说，这涉及到从这些抽象中学习语法。

对于那些不熟悉 TypeScript 或者还没有学习过它的人来说， **TypeScript 对陡峭的学习曲线**有很大的帮助。

Angular 和 TypeScript 的结合有时让它感觉像是自己的编程语言。

它使用实验性的 decorators 为其 NgModules 和类类型提供注释，作为其架构的一部分。在 Angular 中，装饰器赋予类在应用程序中的用途。Angular 中每个支持的类类型都用它的名字来修饰(例如`@Component`)。

## 这需要心态的转变

作为一名 Angular 开发新手，您发现您必须改变您的编程心态。这需要时间和一个令人沮丧的过程。它极大地降低了您的开发效率。

**这是由于……**的综合作用

*   反应式方法
*   独特的架构(NgModules)
*   具有单一职责的角类(装饰者)

> 这个想法是，当你熟悉这个框架时，你最终会收到你的投资回报(ROI)。

由于 Angular CLI 的脚手架功能，Angular ROI 以快速应用程序开发的形式出现。

直到你熟悉了这个架构，并且自动知道什么时候应该使用`Directive` vs `Component` vs `Service` vs `Pipe`，没有什么可能是*。*

*一旦你跨越了学习的悬崖，你会觉得你实际上又可以估计开发时间了(就像你平时一样)。你不太可能被 Angular 在《引擎盖下》中所做的事情绊倒。*

*但在那之前，你必须经历学习角度最困难的部分。*

> *但是学习 Angular 最难的部分是什么？*

# *1)固执己见的架构和独特的语法*

*特定于角度的抽象提供了支持高级交互和功能的语法糖。这可以从使用 TypeScript 装饰器定义**模块和组件**的方式中看出。*

*这意味着开发者省去了复杂性，将细节留在“引擎盖下”。*

*Angular 严重影响你构建项目的方式。获得 Angular 所能提供的最大价值意味着了解模块、组件、指令、服务、管道等之间的区别。这些是角度应用的基本部分。例如，在类的上方使用一个装饰符来表示它是一个`@Component`还是一个`@Directive`。*

## *组件和指令*

*组件是角度应用程序的构建块。一个应用程序主要由许多组件组成。您通过组件模板编写 UI，组件模板通过 TypeScript 类与业务逻辑进行交互。*

*Angular 提供组件接口，通过实现函数来启用某些功能。这些可以以生命周期挂钩的形式出现，比如使用 TypeScript 接口实现的`NgOnInit`。*

*对我来说，**最难理解的是它是如何联系起来并组合成一个 web 应用程序的。***

*使用组件 vs 服务的时间很容易确定，一开始在组件 vs 指令之间选择有点困难，但是**知道创建指令的正确情况是困难的。***

> *我经常发现我自己增加了组件的复杂性，而我本应该将该功能指定给一个指令。*

*此外，指令可以是**结构**或**属性**指令**。***

*第一次使用指令时，通过指令与应用程序交互的方式是最难学习的。Angular 通过更具体的语法和 TypeScript 装饰器(如`@HostBinding`和`@HostListener`)以独特的方式访问 DOM 和主机。*

*Angular 中的指令是考虑 DOM 的一种独特方式，需要一些时间来适应。*

## *接口*

*Angular 提供的接口使用起来相对简单，但是**有几百个**。困难在于知道在某些情况下应该实现哪个接口。了解可用的接口并将接口与某些功能相关联通常是通过花费在堆栈溢出或查看其他代码上的时间来积累的。*

*对于初学者来说，理解使用特定接口的正确环境几乎不可能从文档中推断出来。*

## *模块*

*在 Angular 中，模块是`@NgModule`的。有各种模块，如域功能模块、路由功能模块、路由模块、服务功能模块、小部件功能模块。了解其中的区别是很棘手的，因为肯定会有重叠，特别是如果您正在快速开发您的应用程序，或者没有无数开发人员来分担工作量。*

> *如果你不小心根据模块的类型来组织模块，你最终会创建复杂的混合模块，这些模块几乎可以做任何事情。*

## *Angular 文档引用了这些模块类型:*

*   *领域功能模块。*
*   *布线特征模块。*
*   *路由模块。*
*   *服务功能模块。*
*   *小部件功能模块。*

*了解这些类型之间的区别以及它们应该是什么样子，将会提高可读性以及其他开发人员对应用程序的理解。这也有助于重构和调整你的应用程序。当您想要重构应用程序的某些部分时，知道从哪里开始可以节省时间。*

## *服务和依赖注入*

*另一方面，服务非常容易理解。**它们应该包含“业务逻辑”。***

*为每个特定目的创建一个新服务。这意味着他们应该严格遵守单一责任原则。如果您想要一个服务来处理身份验证，您可以称它为`AuthService`并且它将专门处理身份验证，**仅此而已**。如果您决定需要处理用户操作，您应该创建一个名为`UserService`的新服务。*

> *服务应该是[干的](https://dzone.com/articles/software-design-principles-dry-and-kiss)(不要重复自己)*

*服务是通过依赖注入初始化的类。*

*要使用服务，通过`constructor`将服务作为依赖注入，就像`constructor (private authService: AuthService)`一样。*

*此后，您将通过`this.authService`进入`AuthService`。*

*将服务视为“业务逻辑”可以很容易理解何时使用服务。*

*虽然这很容易概念化，但**服务会变得复杂。***

## *服务的复杂性*

*当服务相互交互以及与应用程序的其他部分交互时，服务变得复杂起来。起初，服务的提供者范围可能很难理解。*

*最终，有两种类型的服务:*

*   *一个*
*   *非独生子女*

## *一个*

*Singleton Services 是应用程序范围的服务，在应用程序中只有一个服务实例。这意味着当在不同的组件中使用服务时，您将共享变量；**您正在使用相同的实例**。*

*您可以使用服务装饰器`providedIn: 'root'`创建应用程序范围的服务。或者您可以将其保留为`providedIn: 'any'`，Angular 将自动将其实例化为单例，此外，如果它没有被当前的捆绑包使用，那么您将从树摇动中受益。*

## *非单身*

*在整个应用程序中，非单例服务可以有同一个服务的多个实例。这意味着当在两个不同的组件中使用服务时，不会共享变量。*

*在组件或指令元数据(装饰器)中使用`providers: [UserService]`将提供一个新的服务实例。*

*因此，您可以通过单例、非单例和应用程序的其余部分之间的交互来了解复杂性会出现在哪里。*

*很重要的一点是，要明确一个服务是否应该是单例的。您的大多数服务可能是单个的，所以这应该会在一定程度上限制复杂性。*

# *2)动态模板引擎*

*Angular 的主要特点之一是其独特的 HTML 模板，集成了定制元素，类似于 XML。**你与这些 HTML 模板的交互方式是特定于角度的**，与 React 或其他流行框架中的交互方式不同。Angular 提供自定义属性和 HTML 元素，支持 HTML 的动态呈现。*

*对有角度的 HTML 元素的依赖意味着需要学习一些新概念。这些是`ng-content`、`ng-container`和`ng-template`。这些为 DOM 提供了不同的功能。然而，它们的共同点是都引用 DOM 中的一个元素。*

> *这些元素看起来就像魔法一样，直到你完全理解它们是如何“在引擎盖下”工作的。*

## *ng 内容、ng 容器、ng 模板之间的区别*

*它们用于向 Angular 指示动态加载组件的位置。*

## *`ng-content`*

*这用于内容投影。这对于构建可重用的组件是必不可少的。它允许您通过从外部投影到组件中来扩展和定制组件。*

## *`ng-container`*

*这是不干扰 DOM 的分组元素。它只是被插入到被引用的地方。基于条件和模板表达式排除和包含 HTML 是最简单的方法。可以在`if else`语法和模板变量中用`ng-container`引用`ng-templates`。*

## *ng 模板*

*这用于保存模板引用。您可以在`ng-template`中包装一个模板，通过使用它的模板引用有条件地将其插入 DOM。*

> *没有通过条件显示的元素被保存为一个`ng-template`，直到它们被有条件地插入。*

***结构化指令是根据业务逻辑和应用程序数据有条件地将元素插入 DOM** 的最有用的方法。*

*它们包括:*

*   *NgIf*
*   *NgFor*
*   *NgSwitch*

> *如果这些没有提供您想要的功能，您甚至可以自己编写。*

*与任何单页面应用程序(SPA)一样，动态呈现是应用程序的核心。它描述了 HTML 动态插入 DOM 的方式。理解 Angular 在幕后是如何工作的，使得开发 Angular 应用程序变得简单明了，并且尽可能地可预测。*

*但是同样，Angular 做了很多“幕后”的事情，让你作为开发人员的生活变得更容易。因此，**事情一开始并不那么容易预测**。*

# *3) RXJS 烘焙*

*在整个 Angular 框架中，都依赖于 [RxJS 库](https://github.com/ReactiveX/rxjs) (JavaScript 反应式扩展)。*

*你基本上可以假设 RXJS 是 Angular 的一部分。原因是 Angular 本身就是用 RXJS 搭建的。*

***你无法逃避它。***

*由于这个原因，当你开始学习 Angular 时，你会立即注意到对反应式编程的强调。这是一个观察和承诺无处不在的框架。您将看到在 HTTP 客户端、路由器事件和其他 Angular 提供的服务中使用的 Observables。*

*你会注意到，如果不处理数据流，你将一事无成**，这并不是一件坏事**。*

*但是，它确实逼着你深入学习 RxJS 特别是 Angular 与数据流交互的方式。*

*虽然 RXJS 很棒，而且对于 Angular 中的反应式编程来说是必不可少的，但是它极大地缩短了学习曲线。*

> *单独学习 RXJS 是很费时间的，**所以同时学习 Angular 和 RXJS 必然是一个令人生畏的过程。***

*起初，RxJS 的核心概念很容易掌握，但你会遇到未被发现的错误，几天后你会抓耳挠腮，最终意识到你并没有像在 RXJS 上想象的那样牢固掌握。*

*随着代码开始变得越来越复杂，RXJS 操作符的内部工作方式将会让你措手不及。*

> *如果你对 RXJS 运算符做出假设，你最终会被发现*

*如果你不熟悉数据流，这需要改变思维模式。虽然 RxJS 是特定于 JavaScript 的，[**react vex**](http://reactivex.io/)，但是包含 RxJS、Rx.NET 和 RxJava 等实现的库很可能有您的语言的实现。所以你可能熟悉反应式编程和处理数据流。*

*处理数据流本身并不困难。困难的部分是理解操作者如何工作。很难理解 RxJS 操作符是如何转换数据流和修改行为的。*

*调试 RxJS 流时，不仅要观察发出的数据，还要观察发出的顺序、时间、数据类型以及其他方面的行为。*

*如果您没有完全理解 RxJS，这可能会使调试您的应用程序变得困难。为了调试您的代码，您必须理解预期的行为，以及实际的行为是如何偏离的，以便能够有效地进行测试。*

## *角度反应式编程*

*反应式编程意味着把一切都看成是异步的，对随时间发生的事件做出反应，而不一定是按顺序。你认为数据是从数据流中产生的，带有可观察到的信息，并承诺一直到达目的地。*

*在 Angular 中，这意味着从 API 一直到模板的**。***

> *你越早意识到一切都应该是一条溪流，越好*

*在任何实际工作进入应用程序之前认识到数据流的重要性意味着您可以从一开始就使用' **RxJS** x **Angular** 最佳实践，构建真正的端到端反应式应用程序。*

> *在这个上下文中，端到端意味着数据开始和结束都是通过模板中的`async`管道解包的可观察数据；避免手动订阅。*

*幸运的是，Angular 是一个鼓励反应式编程的框架。在使用 RxJS 和 Angular 时，您将开始意识到作为标准库一部分的`async`管道是您最常用的 Angular 管道之一。*

***在 Angular 中，异步管道是端到端反应式应用的最佳工具。在你的模板中使用`data$ | async`可以自动处理观察值的订阅和取消订阅。***

*在 RxJS 中，防止在组件类中使用`subscribe()`手动订阅是一个众所周知的最佳实践。异步管道是符合这一最佳实践的最佳工具。RxJS 提供了一个全面的库，其中包含用于转换、组合、创建和过滤数据流的操作符，因此大多数时候您应该能够找到一种方法来防止手动订阅。*

*您需要了解[热和](https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339)冷观察值之间的区别，RxJS 流的[大理石图](https://rxmarbles.com/)，组件的不同方法(智能或非智能)，以及如何实现端到端的反应式 web 应用程序。*

*开始了解 RxJS 的最佳途径是通过 [learnrxjs](http://learnrxjs.io) 。*

*[](https://www.learnrxjs.io/) [## 介绍

### 是当今 web 开发中最热门的库之一。提供强大的功能方法来处理…

www.learnrxjs.io](https://www.learnrxjs.io/) 

如果您更喜欢视觉学习，可视化数据流和 RxJS 操作符的一个好方法是通过大理石图。

大理石图显示了发射的顺序以及运算符如何影响可观测数据流的行为。

 [## Rx marbles:Rx 可观测量的交互图

### 在可观测量上学习、构建和测试 Rx 函数

rxmarbles.com](https://rxmarbles.com/) 

# 最重要的是心态的转变

由于 Angular 给 web 开发带来了一系列的新概念，思维模式需要转变。Angular 的工作方式鼓励采用反应性方法，并以 RxJS 作为反应性催化剂。

除了新概念、方法、语法和 RxJS，您还必须考虑影子 DOM。**Angular 用“Angular 方式”做任何事情的原因是因为 shadow DOM 和 NgZone** 。

> NgZone 是跨异步任务持续存在的执行上下文

Angular 在与 DOM 交互时提供解决方案，因为它确保任务在 Angular 区域内执行。这对变化检测很重要。

**不在区域内执行的任务有被 Angular 检测不到的风险。**这意味着由于 Angular 使用 shadow DOM 和 NgZone 的方式，对 DOM 的更新不会如期进行。

NgZone 的存在为开发应用程序提供了一个额外的视角。这意味着你必须考虑任务是“在范围内”还是“在范围外”。

这也意味着你很少会偏离 Angular 的做事方式而不在不知不觉中产生一个 bug。它迫使你学习 Angular 的做事方式，并完全遵循 Angular 的 web 开发方法。因此，你不能真的推迟学习 Angular 的某些部分。

当开始学习 Angular 时，一开始一切都似乎很陌生，尤其是如果你来自纯 JavaScript 背景。如果你习惯了打字稿，会有一些熟悉，但就连你也未必能幸免。

使用 Angular 构建 web 应用程序最终是有回报的，但前提是你已经搞清楚了什么是“幕后”。

## 学习 Angular 之前你应该知道什么

作为一个初学棱角分明的人，**认知超负荷会是一种熟悉的心理状态。**

但是一旦你掌握了语法，隐藏在引擎盖下的东西将会困扰你。

不幸的是，你不知道它什么时候会绊倒你，知道 Angular 中什么是重要的唯一方法是通过亲身经历。

这意味着一次又一次的失败。这需要耐心。

但是**一旦你解决了，一切都开始变得有意义，**回报是巨大的。

*感谢阅读！有任何问题，请在评论中告诉我。**