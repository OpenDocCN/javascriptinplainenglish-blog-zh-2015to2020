<html>
<head>
<title>Node.js Tips — Test Apps, Retries, and Logging Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—测试应用程序、重试和记录对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-test-apps-retries-and-logging-objects-868e0c140c38?source=collection_archive---------9-----------------------#2020-07-18">https://javascript.plainenglish.io/node-js-tips-test-apps-retries-and-logging-objects-868e0c140c38?source=collection_archive---------9-----------------------#2020-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/39153b7b07f6f37efa6ed20293c04bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E9U1EAi59RdHlOjJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@angro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Antonio Grosz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="69c7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何检查路径是绝对的还是相对的</h1><p id="2b95" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">path</code>模块的<code class="fe me mf mg mh b">isAbsolute</code>方法检查路径是否是绝对的。</p><p id="2a37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="679c" class="mq lc iq mh b gy mr ms l mt mu">const path = require('path');<br/>//...</span><span id="ca70" class="mq lc iq mh b gy mv ms l mt mu">if (path.isAbsolute(somePath)) {<br/>  //...<br/>}</span></pre><p id="c5b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过<code class="fe me mf mg mh b">somePath</code>中地方法来检查它。</p><p id="e500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是绝对路径，它返回<code class="fe me mf mg mh b">true</code>，否则返回<code class="fe me mf mg mh b">false</code>。</p><h1 id="9f3c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Winston中记录JavaScript对象和数组</h1><p id="f76e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过设置<code class="fe me mf mg mh b">prettyPrint</code>属性来用Winston美化对象。</p><p id="7472" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2e45" class="mq lc iq mh b gy mr ms l mt mu">const level = 'debug';</span><span id="0f58" class="mq lc iq mh b gy mv ms l mt mu">const logger = new winston.Logger({<br/>  transports: [<br/>    new winston.transports.Console({<br/>      name: 'debug-console',<br/>      level,<br/>      prettyPrint(object) {<br/>        return JSON.stringify(object);<br/>      },<br/>      handleExceptions: true,<br/>      json: false,<br/>      colorize: true<br/>    })<br/>  ],<br/>  exitOnError: false<br/>});</span></pre><p id="fbfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">prettyPrint</code>设置为一个函数，该函数返回stringified对象来打印对象内容。</p><p id="c6b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用<code class="fe me mf mg mh b">%j</code>标签记录JSON。</p><p id="10c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5315" class="mq lc iq mh b gy mr ms l mt mu">logger.log("info", "an object %j", obj);</span></pre><p id="1506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">obj</code>是一个对象。</p><h1 id="79df" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Mocha的每个钩子之后从内部检测测试失败</h1><p id="007b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以检查<code class="fe me mf mg mh b">afterEach</code>钩子中的<code class="fe me mf mg mh b">this.currentTest.state</code>属性来检查刚刚运行的测试的状态。</p><p id="36d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bf19" class="mq lc iq mh b gy mr ms l mt mu">afterEach(function() {<br/>  if (this.currentTest.state === 'failed') {<br/>    // ...<br/>  }<br/>});</span></pre><p id="47bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">state</code>是<code class="fe me mf mg mh b">'failed'</code>，那么它失败了。</p><h1 id="2309" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中设置Cookie值</h1><p id="d81d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">res.cookie</code>方法在响应中设置一个cookie。</p><p id="b6b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a125" class="mq lc iq mh b gy mr ms l mt mu">const cookieParser = require('cookie-parser');<br/>//...</span><span id="2e74" class="mq lc iq mh b gy mv ms l mt mu">app.use(cookieParser());</span><span id="54e5" class="mq lc iq mh b gy mv ms l mt mu">app.get('/foo', (req, res) =&gt; {<br/>  res.cookie('foo', 'baz');<br/>});</span></pre><p id="9f60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是键，第二个是值。</p><p id="6d23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还包括<code class="fe me mf mg mh b">cookieParser</code>。</p><p id="dbb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以传入一个秘密作为参数来签署cookie。</p><p id="ae5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9623" class="mq lc iq mh b gy mr ms l mt mu">const cookieParser = require('cookie-parser');<br/>//...</span><span id="aa2d" class="mq lc iq mh b gy mv ms l mt mu">app.use(cookieParser('secret'));</span><span id="4e9d" class="mq lc iq mh b gy mv ms l mt mu">app.get('/foo', (req, res) =&gt; {<br/>  res.cookie('foo', 'baz');<br/>});</span></pre><p id="849d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一个秘密的密钥串来签署一个cookie。</p><h1 id="b9fb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何对快速路由器路由进行单元测试</h1><p id="27c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过导出Express应用程序对Express路由器路由进行单元测试。</p><p id="6f2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过将导出的app传入Supertest的<code class="fe me mf mg mh b">request</code>函数来使用Supertest。</p><p id="ca77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下快速应用程序:</p><p id="f84d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bf03" class="mq lc iq mh b gy mr ms l mt mu">const app = express();<br/>// ...<br/>const router = require('../app/router')(app);</span><span id="77bd" class="mq lc iq mh b gy mv ms l mt mu">module.exports = app;</span></pre><p id="576e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写以下代码来编写我们的测试:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b2a1" class="mq lc iq mh b gy mr ms l mt mu">const chai = require('chai');<br/>const should = chai.should();<br/>const sinon = require('sinon');<br/>const request = require('supertest');<br/>const app = require('app');</span><span id="0061" class="mq lc iq mh b gy mv ms l mt mu">describe('person route', () =&gt; {<br/>  request(app)<br/>    .get('/api/persons')<br/>    .expect('Content-Type', /json/)<br/>    .expect('Content-Length', '4')<br/>    .expect(200, "ok")<br/>    .end((err, res) =&gt; {<br/>      if (err) throw err;<br/>    });<br/>});</span></pre><p id="5d23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入从<code class="fe me mf mg mh b">app.js</code>导入的<code class="fe me mf mg mh b">app</code>。</p><p id="11a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们通过调用<code class="fe me mf mg mh b">get</code>发出GET请求。</p><p id="5d99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">expect</code>来检查响应头和状态代码。</p><p id="02f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">end</code>来完成请求，并在回调中得到带有<code class="fe me mf mg mh b">res</code>的响应。</p><h1 id="f4ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重复请求，直到一个成功，没有阻塞</h1><p id="9e47" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了重复请求直到成功，我们可以使用<code class="fe me mf mg mh b">async.retry</code>方法。</p><p id="16f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dcc3" class="mq lc iq mh b gy mr ms l mt mu">const async = require('async');<br/>const axios = require('axios');</span><span id="f2f0" class="mq lc iq mh b gy mv ms l mt mu">const makeRequest = async (uri, callback) =&gt; {<br/>  try {<br/>    const result = await axios.get(uri);<br/>    callback(null, result);<br/>  } catch (err) {<br/>    callback(err);<br/>  }<br/>};</span><span id="7d8e" class="mq lc iq mh b gy mv ms l mt mu">const uri = 'http://www.test.com/api';</span><span id="31ff" class="mq lc iq mh b gy mv ms l mt mu">async.retry({<br/>    times: 5,<br/>    interval: 200<br/>  },<br/>  (callback) =&gt; {<br/>    return makeRequest(uri, callback)<br/>  },<br/>  (err, result) =&gt; {<br/>    if (err) {<br/>      throw err; <br/>    }<br/>  });</span></pre><p id="5f1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe me mf mg mh b">makeRequest</code>函数，它在完成后调用<code class="fe me mf mg mh b">callback</code>。</p><p id="827a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将它传递给带有选项的<code class="fe me mf mg mh b">async.retry</code>方法。</p><p id="a26c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">times</code>是尝试的次数。</p><p id="1c59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">interval</code>具有以毫秒为单位的重试间隔。</p><p id="a645" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是要调用的异步函数。</p><p id="511e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数是请求成功或重试次数用尽时的回调。</p><p id="5301" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">result</code>有结果了。<code class="fe me mf mg mh b">err</code>有误差。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e6f6074531160b3f512a29497ec289b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*guKclbLrx9CUMluR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danonline1995?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Muir</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d1d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3f3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">async.retry</code>方法来重试异步函数。</p><p id="8030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以打印出用Winston记录的JavaScript对象。</p><p id="6541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用Supertest测试Express应用程序，我们必须导出Express应用程序并将其用于Supertest。</p><p id="2edd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Express可以在响应中设置cookies。</p><h2 id="a706" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="6ff0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>