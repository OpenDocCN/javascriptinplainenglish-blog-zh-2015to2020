<html>
<head>
<title>Object-Oriented JavaScript — Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-promises-500ca78baec7?source=collection_archive---------9-----------------------#2020-11-18">https://javascript.plainenglish.io/object-oriented-javascript-promises-500ca78baec7?source=collection_archive---------9-----------------------#2020-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7fc4bc3e180945bae7b14de6be4b4f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*69EJd7CnEzaMa5gr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2f36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript承诺。</p><h1 id="a6fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺</h1><p id="0099" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">承诺是回电的另一种选择。</p><p id="5870" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺让我们检索异步函数调用的结果。</p><p id="74d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺比回调更容易，给了我们更多可读的代码。</p><p id="646b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们可以挑战几个州。</p><p id="6079" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺可能是悬而未决的，这意味着结果还没有准备好。</p><p id="122f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是初始状态。</p><p id="b2da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果准备好了，承诺就兑现了。</p><p id="4d71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有错误，那么结果将被拒绝。</p><p id="f379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个待定的承诺被履行或拒绝时，运行由<code class="fe me mf mg mh b">then</code>排队的相关回调。</p><p id="6468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比异步回调要好。</p><p id="6416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要运行许多异步函数，那么我们必须重复嵌套它们。</p><p id="0a70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="01e7" class="mq lc iq mh b gy mr ms l mt mu">asyncFunction(arg, result =&gt; {<br/>  asyncFunction(arg, result =&gt; {<br/>    //...<br/>  })<br/>})</span></pre><p id="465f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多次运行异步函数。</p><p id="87e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们必须做更多，那么就会有更多的嵌套，阅读起来会更困难。</p><p id="79d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">asyncFunction</code>是一个承诺，那么我们可以给<code class="fe me mf mg mh b">then</code>回电。</p><p id="f227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺兑现后的回拨运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8e84" class="mq lc iq mh b gy mr ms l mt mu">asyncFunction(arg)<br/>  .then(result =&gt; {<br/>    //...<br/>  });</span></pre><p id="4a2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是不停地呼唤<code class="fe me mf mg mh b">then</code>，直到我们呼唤出所有我们想要的承诺:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0ca4" class="mq lc iq mh b gy mr ms l mt mu">asyncFunction(arg)<br/>  .then(result =&gt; {<br/>    //...<br/>    return asyncFunction(argB);<br/>  })<br/>  .then(result =&gt; {<br/>    //...<br/>  })</span></pre><p id="ef30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">then</code>回调返回一个承诺，所以我们可以继续调用<code class="fe me mf mg mh b">then</code>直到我们完成。</p><p id="4514" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了捕捉承诺错误，我们可以用回调来调用<code class="fe me mf mg mh b">catch</code>方法。</p><p id="e782" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fa3e" class="mq lc iq mh b gy mr ms l mt mu">readFileWithPromises('text.json')<br/>  .then(text =&gt; {<br/>    //...<br/>  })<br/>  .catch(error =&gt; {<br/>    console.error(error)<br/>  })</span></pre><h1 id="0e38" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创造承诺</h1><p id="4978" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Promise</code>构造函数创建承诺。</p><p id="9e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a0fb" class="mq lc iq mh b gy mr ms l mt mu">const p = new Promise(<br/>  (resolve, reject) =&gt; {<br/>    if (...) {<br/>      resolve(value);<br/>    } else {<br/>      reject(reason);<br/>    }<br/>  });</span></pre><p id="8e8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入了一个回调函数，它有<code class="fe me mf mg mh b">resolve</code>和<code class="fe me mf mg mh b">reject</code>参数，这些都是函数。</p><p id="5a04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">resolve</code>用给定的价值兑现了承诺。</p><p id="3dc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">reject</code>拒绝有值的承诺。</p><p id="b51f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将than与<code class="fe me mf mg mh b">then</code>和<code class="fe me mf mg mh b">catch</code>一起使用，就像我们在前面的例子中所做的那样:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8488" class="mq lc iq mh b gy mr ms l mt mu">p<br/>  .then(result =&gt; {<br/>    //...<br/>  })<br/>  .catch(error =&gt; {<br/>    //...<br/>  })</span></pre><p id="3a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在<code class="fe me mf mg mh b">then</code>回调中抛出错误时，如果在抛出错误的<code class="fe me mf mg mh b">then</code>之后调用<code class="fe me mf mg mh b">catch</code>,它也会被捕获:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a5a0" class="mq lc iq mh b gy mr ms l mt mu">readFilePromise('file.txt')<br/>  .then(() =&gt; {<br/>    throw new Error()<br/>  })<br/>  .catch(error =&gt; {<br/>    'Something went wrong'<br/>  });</span></pre><h1 id="1b07" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Promise.all()</h1><p id="ee26" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.all</code>让我们并行运行一个承诺数组，并返回一个承诺，该承诺解析为数组中所有承诺的数组。</p><p id="e6c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果所有的承诺都实现了，那么承诺结果的数组将在then <code class="fe me mf mg mh b">then</code>回调的参数中返回。</p><p id="67ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="61b4" class="mq lc iq mh b gy mr ms l mt mu">Promise.all([<br/>    p1(),<br/>    p2()<br/>  ])<br/>  .then(([r1, r2]) =&gt; {<br/>    //<br/>  })<br/>  .catch(err =&gt; {<br/>    console.log(err)<br/>    ''<br/>  })</span></pre><p id="cab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用返回承诺的<code class="fe me mf mg mh b">p1</code>和<code class="fe me mf mg mh b">p2</code>来称呼<code class="fe me mf mg mh b">Promise</code>。</p><p id="7112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">r1</code>和<code class="fe me mf mg mh b">r2</code>就是结果。</p><p id="e828" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">catch</code>如果任何一个承诺被拒绝，则捕捉其中的错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/6022c3e962e66d6756bc2aae5ffe0c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Ggq2lRD5Hl2wlWo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6fb3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="75cb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Promise</code>构造函数创建承诺。</p><p id="4325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.all</code>并行运行多极承诺，并返回一个解析为所有结果的数组的承诺。</p><p id="ecdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>