# JavaScript Async/Await 和 Promises:像你五岁时一样解释。

> 原文：<https://javascript.plainenglish.io/javascript-async-await-and-promises-explained-like-youre-five-years-old-61733751e9a5?source=collection_archive---------0----------------------->

![](img/b0cb88446d52a09c9b50722a3e2e5099.png)

任何自称为 JavaScript 开发人员的人都不得不使用回调函数、Promises 或最近的 Async/Await 语法。如果你已经在这个游戏中呆了足够长的时间，那么你可能已经看到了嵌套回调是执行异步 JavaScript 的唯一方式的时代的转变。

当我第一次开始学习和编写 JavaScript 时，已经有十亿本指南和教程在解释如何使用它们。然而，他们中的许多人只是解释了如何在回调到承诺，或者承诺到异步/等待之间转换。不可否认，对于许多人来说，这对他们相处和编写代码来说已经足够了。

然而，如果你像我一样，并且*真的*想要理解异步编程(而不仅仅是 JavaScript 语法！)，那么您可能会同意我的观点，即缺乏从头开始解释异步编程的内容。

# “异步”是什么意思？

![](img/60868c2c8236762a6689f210dc4f543f.png)

The face of many when dealing with async

一般来说，通过问这个问题，你会得到如下的答案:

*   多个线程同时执行代码
*   一次运行多位代码
*   并发(？)

这些都是*某种程度上*沿着正确的路线。但是我不会给你一个你可能以后会忘记的技术定义，我会给你**一个五岁小孩能理解的例子**。

# 一个更人性化的类比

![](img/e7d22ec26c6ab5904dabf51d79401ace.png)

想象你正在煮一些蔬菜汤。为了一个简单的类比，让我们假设所说的蔬菜汤只包含洋葱和胡萝卜。这种汤的配方可能如下:

1.  切一些胡萝卜。
2.  切一些洋葱。
3.  往锅里加水，打开炉子，等水烧开。
4.  将胡萝卜放入锅中，煮 5 分钟。
5.  将洋葱放入锅中，再煮 10 分钟。

这些说明简单明了，但是如果你们中的任何人真的在阅读这篇文章，你会意识到这种**并不是最省时的烹饪方式。对于那些没有经验的厨师来说，原因如下:**

*   步骤 3、4 和 5*除了看锅和记时间，实际上不需要你作为厨师做任何事情。*
*   ***步骤 1 和步骤 2*做*** 需要你主动去做一些事情。*

*因此，一个更熟练的厨师可能会这样做:*

1.  *开始烧一壶水*
2.  *在等锅里的水烧开的时候，开始切一些胡萝卜。*
3.  *当你完成切胡萝卜的时候，水应该已经开了，所以加入胡萝卜。*
4.  *当胡萝卜在锅里煮的时候，把洋葱切碎。*
5.  *加入洋葱，然后再煮 10 分钟。*

*虽然还有同样多的事情要做，但你可以希望看到这样会更快更有效率。这是与异步编程完全相同的核心概念:**你永远不会想无所事事地纯粹等待*某事，而有其他事情你可以花精力去做。****

*我们都知道在编程中，**等待**经常发生——无论是等待来自服务器、文件系统 I/O 等的 HTTP 响应。但是你的 CPU 的执行周期是宝贵的，应该**总是**积极地*做一些事情* ***，*** 而不是等待:因此，**异步编程**。*

# *现在，让我们开始真正的 JavaScript，好吗？*

*![](img/467792e9999de296a8b5a19f17d32431.png)*

*好了，还是以蔬菜汤为例，我要定义几个函数来表示上面的动作。*

*首先，让我们定义正常的同步函数，这些函数表示根本不需要等待的任务。这些是您的优秀的普通 JavaScript 函数——尽管请注意，我通过让它们进行一些昂贵的计算，模拟了需要积极处理(并花费时间)的任务`chopCarrots`和`chopOnions`。我已经注释掉了实际的实现，因为它们并不重要，但是它们可以在脚注中找到。*

*Synchronous functions*

*至于异步函数，首先我将快速解释 JavaScript 的类型系统如何处理异步性:基本上，**异步操作的所有结果(包括空结果)都必须包装在 Promise 类型中。***

*为了让函数返回承诺，您可以*

*   *明确返回承诺，即**返回新的承诺(…..);***
*   *在函数签名中添加`async`*
*   **或两者皆有。**

*出于我不打算深入本文的原因，您应该 ***总是*** 在异步函数上使用`async`关键字。*

*因此，对于我们的异步函数(代表制作蔬菜汤的步骤 3–5):*

*Our async functions representing tasks that eventually require waiting of some sort*

*同样，我已经删除了实现的细节，但是如果你想看的话，我会把它们贴在最后。*

*同样需要知道的是，为了等待承诺的结果，你可以用它来做一些事情，你可以简单地使用`await`关键字:*

*Most basic example of Async/Await syntax*

*所以现在，我们只需要把这些放在一起:*

*但是等等！没用！你会得到一个`SyntaxError: await is only valid in async functions`。为什么？因为，如果你没有声明一个函数为`async`，那么默认情况下 JavaScript 认为它是一个*同步* 函数——同步意味着没有等待！(这也意味着你根本不能在函数之外的顶层脚本中使用`await`)。*

*因此，我们简单地将`async`关键字添加到`makeSoup`函数中:*

*This should work!*

*瞧啊。注意，在第 2 行，我调用了不带关键字`await`的异步`boilPot()`函数，因为我们实际上不想等到锅烧开了才开始切胡萝卜。在我们需要把胡萝卜放进锅里之前，我们只需要遵守诺言，因为我们不想在水开之前这么做。*

*在`await`通话过程中会发生什么？嗯，没什么…..有点…*

*在`makeSoup`函数的上下文中，你可以简单地把它想象成你在等待某事发生(或者等待*最终返回*的结果)。*

*但是，请记住:你(中央处理器)永远不会想坐在那里纯粹等待某事，而有其他事情你可以花精力去做。*

*因此，如果我们不只是做汤，而是做这个:*

*Multiple tasks at once*

*然后，当我们在做`await` -ing `letPotKeepBoiling`的时候，我们实际上也可以做意大利面。*

*看到了吗？一旦你理解了 Async/Await，它实际上很容易使用，不是吗？*

# *明确的承诺呢？*

*好吧，如果你坚持的话，我也会明确地使用承诺。记住，async/await 方法**是基于承诺本身的，因此这两种方法是完全兼容的。***

*在我看来，显式承诺是在使用旧式回调和新的性感的 async/await 语法之间的折中。或者，你也可以把性感的 async/await 语法看作仅仅是*隐含的*承诺。毕竟，async/await 是在承诺之后出现的，而承诺本身是在回调之后出现的。*

*因此，请乘坐我们的时间机器进行一次短暂的访问，回电 hell⁴:*

*我不想撒谎，我是在写这篇文章的时候匆忙写的，花了我不愿意承认的时间。你们中的许多人根本不知道发生了什么。亲爱的主啊，那些试镜不都很糟糕吗？让这成为一个教训，永远不要再碰回调...*

*而且，像承诺的那样(*呵呵*)，用明确的承诺:*

*Using Promises explicitly with .then callbacks*

*正如你所看到的，承诺的某些方面仍然很难实现。*

*我就不细说了，基本上:*

*   *`.then`是一个关于承诺的方法，它获取承诺的结果并将其传递给参数函数(本质上是一个回调函数……)*
*   *你永远不能在`.then`的上下文之外打开承诺的结果。⁵本质上，`.then`就像一个`async`块，它将`await`的结果传递给回调函数。*
*   *还有用于处理错误的`reject`回调和用于处理错误的`.catch`承诺方法，但我不会深入讨论，因为还有数十亿个其他承诺教程。*

# *结论*

*我真的希望你从这篇文章中对承诺和异步编程有所了解，或者至少学会了一种向别人解释的好方法。*

***那么，应该用哪个呢？明确承诺还是异步/等待**？答案完全取决于你——我认为混合使用它们也没什么不好，因为它们彼此完全兼容。*

*也就是说，就我个人而言，我 100%支持 Async/Await 阵营，对我来说，代码更清晰，更能反映异步编程真正的多任务特性。*

*你是哪一个？在评论里发帖！*

***【1】**:此处有完整的源代码[。](https://gist.github.com/jackel119/b0599ff78e2a14b07439dd251dad464c#file-complete-js)*

***【2】:**见此处[。](https://dev.to/mywebstuff_hq/async-function-vs-a-function-that-returns-a-promise-3lpo)*

***【3】**:你可能会说 JavaScript 可以通过函数体和递归检查来推断 async/await 类型，但是 JavaScript 并不关心编译时的静态类型安全，更不用说让开发人员能够显式地看到更方便了。*

***【4】**:我编写“异步”函数时，假设它们与`setTimeout`在同一个回调接口下工作。请注意，回调与承诺是不兼容的，反之亦然。*

*对你们这些功能怪胎来说，承诺就是一个单子！*