<html>
<head>
<title>How to Use Map, Filter and Reduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用映射、过滤和减少</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-map-filter-and-reduce-5b512e6ad3c6?source=collection_archive---------3-----------------------#2020-08-09">https://javascript.plainenglish.io/how-to-use-map-filter-and-reduce-5b512e6ad3c6?source=collection_archive---------3-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4e2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">需要了解的3个强大的JavaScript数组方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/29e38ebb9ed3867db261ccc102fba581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhR0GNM_wrfEawQ4HfU2ZQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@clemhlrdt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Clément H</a> on <a class="ae kv" href="https://unsplash.com/s/photos/web-development?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你问一个开发人员“需要知道哪些最重要的JavaScript数组方法？”，你可能会听到提到<code class="fe ls lt lu lv b"><strong class="ky ir">map</strong></code>、<code class="fe ls lt lu lv b"><strong class="ky ir">filter</strong></code>和<code class="fe ls lt lu lv b"><strong class="ky ir">reduce</strong></code>。这3个强大的方法使您能够遍历数组的内容，类似于使用一个<code class="fe ls lt lu lv b">for</code>循环。这些方法中的每一个都将创建一个新的数组(或元素、对象等)。对于<code class="fe ls lt lu lv b">reduce</code>，基于提供的回调函数，<strong class="ky ir">他们</strong> <strong class="ky ir">不会变异或者改变原来的数组</strong>。</p><p id="8b62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么要用<code class="fe ls lt lu lv b">map</code>、<code class="fe ls lt lu lv b">filter</code>或者<code class="fe ls lt lu lv b">reduce</code>而不是<code class="fe ls lt lu lv b">for</code>循环？</p><ul class=""><li id="62f8" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">他们可以创建更容易阅读的代码。</li><li id="ee64" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">他们写得更快。</li><li id="ad6b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">它们使得将方法链接在一起变得容易。</li><li id="f0fd" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">它们不会破坏原始数组。</li></ul><p id="b5a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将分解这3个流行的数组方法。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="dc87" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Array.map()</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d6644d4fffbf75a81fdc955042f7c28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/1*W_HVVAJRmF2knzJ_ZkD3gg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Mighty morphin’ array elements 🔥</figcaption></figure><p id="1ec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map()</code>方法<strong class="ky ir">按顺序调用数组中每个元素的回调函数，并创建一个由结果组成的全新数组。</strong>原来的数组不会改变。如果您计划使用新数组做某事，或者希望为数组中的每个元素创建一个新值，此方法会很有帮助。</p><p id="ed64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="c0e8" class="no ms iq lv b gy np nq l nr ns">let array = [1, 2, 3, 4, 5]</span><span id="6366" class="no ms iq lv b gy nt nq l nr ns">let newArray = array.map(element =&gt; element * 2)</span><span id="80e4" class="no ms iq lv b gy nt nq l nr ns">console.log(newArray) // [2, 4, 6, 8, 10]</span><span id="fb3c" class="no ms iq lv b gy nt nq l nr ns">console.log(array) // [1, 2, 3, 4, 5]</span></pre><p id="9c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以这样写，在别处命名一个函数，函数名作为回调传入<code class="fe ls lt lu lv b">map()</code>:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="b377" class="no ms iq lv b gy np nq l nr ns">let dogs = [<br/>    {name: "Missy", breed: "Pit mix"},<br/>    {name: "Cody", breed: "Havanese"},<br/>    {name: "Petunia", breed: "Shepherd Lab mix"},<br/>    {name: "Riley", breed: "🤷‍♀️"}<br/>]</span><span id="adbd" class="no ms iq lv b gy nt nq l nr ns">const getDogInfo = function(dog) {<br/>  let info = [dog.name, " is a ", dog.breed].join(" ");<br/>  return info;<br/>}</span><span id="4880" class="no ms iq lv b gy nt nq l nr ns">let dogInfo = dogs.map(getDogInfo)</span><span id="146c" class="no ms iq lv b gy nt nq l nr ns">console.log(dogInfo)<br/>// ["Missy  is a  Pit mix", <br/>// "Cody  is a  Havanese", <br/>// "Petunia  is a  Shepherd Lab mix", <br/>// "Riley  is a  🤷‍♀️"]</span></pre><p id="9b03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">map</code>的完整语法实际上有点长，但是在大多数用例中，我们将只传入<code class="fe ls lt lu lv b">currentValue</code>(或者我们正在迭代的元素)和回调函数。根据<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> MDN </a>和<a class="ae kv" href="https://www.w3schools.com/jsref/jsref_map.asp" rel="noopener ugc nofollow" target="_blank"> W3Schools </a>，完整的语法是这样的:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="774e" class="no ms iq lv b gy np nq l nr ns"><em class="nu">array</em>.map(<em class="nu">function(currentValue, *index*, *arr*), *thisArg*</em>)<br/>// *optional*</span></pre><p id="3346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(数组中正在处理的当前元素的)<code class="fe ls lt lu lv b">index</code>、<code class="fe ls lt lu lv b">arr</code>(数组<code class="fe ls lt lu lv b">map</code>被调用)和<code class="fe ls lt lu lv b">thisArg</code>(执行<code class="fe ls lt lu lv b">callback</code>时用作<code class="fe ls lt lu lv b">this</code>的值)都是可选参数。当省略<code class="fe ls lt lu lv b">thisArg</code>时，<code class="fe ls lt lu lv b">this</code>的值将被视为未定义。</p><p id="ea32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里阅读更多关于<code class="fe ls lt lu lv b">map()</code> <a class="ae kv" href="https://www.digitalocean.com/community/tutorials/4-uses-of-javascripts-arraymap-you-should-know" rel="noopener ugc nofollow" target="_blank">的潜在用例</a>。</p><h1 id="7922" class="mr ms iq bd mt mu nv mw mx my nw na nb jw nx jx nd jz ny ka nf kc nz kd nh ni bi translated">Array.filter()</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e1409340094d9ebefdefa5a294e2dc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*ft17UgTC6JKsakCL3rcMKg.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Choosing just those elements you <strong class="bd ob">really</strong> want ❤️</figcaption></figure><p id="0792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">filter()</code>方法与<code class="fe ls lt lu lv b">map()</code>相似，因为它也对数组中的每个元素调用一个回调函数，并按顺序分配一个值，并且创建一个全新的数组，而不改变原来的数组。<strong class="ky ir">新过滤的数组由回调函数返回true的所有元素组成。</strong>原始数组中任何返回false的元素都将被跳过。如果没有返回true的元素，将返回一个空数组。</p><p id="9cca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法非常适合(你猜对了)过滤掉你不想要或不需要的元素，这样在新数组中只留下你想要的元素。</p><p id="db8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="05f2" class="no ms iq lv b gy np nq l nr ns">let primates = ["gibbon", "gorilla", "bonobo", "pygmy marmoset", "cotton-top tamarin", "squirrel monkey", "howler monkey"]</span><span id="9be1" class="no ms iq lv b gy nt nq l nr ns">let apes = primates.filter(primate =&gt; primate.length &lt;= 7 )<br/>// clearly not how you determine an ape, just for demo purposes!!🙈</span><span id="81d9" class="no ms iq lv b gy nt nq l nr ns">console.log(apes) // ["gibbon", "gorilla", "bonobo"]<br/>// but yes, these are apes 😉</span></pre><p id="50d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者另一个例子，回调函数在别处被命名并被传入:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="6922" class="no ms iq lv b gy np nq l nr ns">let recipes = <!-- -->['tempeh piccata', 'vegan nachos', 'tofu scramble', 'kitchari', 'mushroom risotto', 'pad thai', 'zucchini pasta', 'portobello mushroom burger']</span><span id="d864" class="no ms iq lv b gy nt nq l nr ns">const findTastyFood = function(food) {<br/>   return !food.includes('mushroom')<br/>   // no mushrooms!! 🍄 🙅‍♀️ 🚫<br/>}</span><span id="3cba" class="no ms iq lv b gy nt nq l nr ns">let tastyFoods = recipes.filter(findTastyFood)</span><span id="4bc1" class="no ms iq lv b gy nt nq l nr ns">console.log(tastyFoods) // ["tempeh piccata", "vegan nachos", "tofu scramble", "kitchari", "pad thai", "zucchini pasta"]<br/>// no gross mushrooms here! 👍</span></pre><p id="8dca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">filter()</code>的完整语法与<code class="fe ls lt lu lv b">map()</code>非常相似，并添加了额外的可选值，如下所示:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="3876" class="no ms iq lv b gy np nq l nr ns"><em class="nu">array</em>.filter(<em class="nu">function(currentValue, *index*, *arr*), *thisArg*</em>)<br/>// *optional*</span></pre><h1 id="ef26" class="mr ms iq bd mt mu nv mw mx my nw na nb jw nx jx nd jz ny ka nf kc nz kd nh ni bi translated">Array.reduce()</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6b67c5cdb220b121d187d802fcf06f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*DId9l9MU2zTUm-2SseHOiw.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Reduce that array! ✨</figcaption></figure><p id="a951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">reduce()</code>方法<strong class="ky ir">使用累加器将函数应用于数组的每个值，并将数组缩减为单个值。</strong>你可以把<strong class="ky ir"> </strong>累加器想象成数组中每个元素将被“相加”的“总数”或“结果”，类似于用一个迭代<code class="fe ls lt lu lv b">total += array[i]</code>的函数声明<code class="fe ls lt lu lv b">let total = 0</code>。累加器可以返回很多东西，比如一个数组，一个对象或者一个数字。与<code class="fe ls lt lu lv b">map</code>和<code class="fe ls lt lu lv b">filter</code>一样，带有<code class="fe ls lt lu lv b">reduce</code>的原始数组将保持不变。</p><p id="2e8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是完整的语法:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="dd60" class="no ms iq lv b gy np nq l nr ns"><em class="nu">array</em>.reduce(<em class="nu">function(accumulator, currentValue, *index*, *arr*), *initialValue*</em>)<br/>// *optional*</span></pre><p id="9f95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">index</code>、<code class="fe ls lt lu lv b">arr</code>和<code class="fe ls lt lu lv b">initialValue</code>都是可选值，就像<code class="fe ls lt lu lv b">map</code>和<code class="fe ls lt lu lv b">filter</code>一样，但通常建议包含<code class="fe ls lt lu lv b">initialValue</code>。如果提供了一个元素，那么<code class="fe ls lt lu lv b">accumulator</code>(总计)将等于<code class="fe ls lt lu lv b">initialValue</code>，<code class="fe ls lt lu lv b">currentValue</code>将等于数组中的第一个元素。如果没有提供<code class="fe ls lt lu lv b">initialValue</code>，数组的第一个元素将被认为是<code class="fe ls lt lu lv b">accumulator</code>，第二个元素将成为<code class="fe ls lt lu lv b">currentValue</code>。(<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> MDN </a>)</p><p id="5492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果没有<code class="fe ls lt lu lv b">initialValue</code>:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="3098" class="no ms iq lv b gy np nq l nr ns">let sum = [0, 1, 2, 3, 4].reduce( <br/>   (accumulator, currentValue, currentIndex, array) =&gt; <br/>      accumulator + currentValue )</span><span id="9b24" class="no ms iq lv b gy nt nq l nr ns">console.log(sum) // 10</span></pre><p id="2b67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迭代将如下所示，最终总和为10:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/f74d06d375fbf53a0370c7f3fd7eaf18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDiSOzb5rerA7YAzhv2IIQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">via <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">MDN</a></figcaption></figure><p id="1e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们提供10的<code class="fe ls lt lu lv b">initialValue</code>:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="66c5" class="no ms iq lv b gy np nq l nr ns">let sum = [0, 1, 2, 3, 4].reduce(<br/>   (accumulator, currentValue, currentIndex, array) =&gt; {<br/>      return accumulator + currentValue<br/>   }, 10)</span><span id="24ef" class="no ms iq lv b gy nt nq l nr ns">console.log(sum) // 20</span></pre><p id="e21f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将从10开始，并从那里添加数组中的每个元素，给出最终的总和20:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/e138db896cc846aa78863df0634d4a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ec42Hu5YPdwWoZN74Zsgfg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">via <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">MDN</a></figcaption></figure><p id="a0c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">reduce</code>方法可以有很多用途，也有助于浓缩数学谱之外的信息。例如，如果您曾经发现自己链接了<code class="fe ls lt lu lv b">map</code>和<code class="fe ls lt lu lv b">filter</code>，那么您可以用<code class="fe ls lt lu lv b">reduce</code>替换这两个方法，从而减少遍历并降低时间复杂度。</p><p id="2492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里还有一个例子:</p><pre class="kg kh ki kj gt nk lv nl nm aw nn bi"><span id="f263" class="no ms iq lv b gy np nq l nr ns">let fruits = ['🍊', '🍐', '🍓', '🍇', '🍒', '🍊', '🍇']<br/><br/>let countedFruit = fruits.reduce(function (allFruit, fruit) { <br/>  if (fruit in allFruit) {<br/>    allFruit[fruit]++<br/>  }<br/>  else {<br/>    allFruit[fruit] = 1<br/>  }<br/>  return allFruit<br/>}, {})</span><span id="c146" class="no ms iq lv b gy nt nq l nr ns">console.log(countedFruit) // <!-- -->{🍊: 2, 🍐: 1, 🍓: 1, 🍇: 2, 🍒: 1}</span></pre></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="c69c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这三种方法都有更多的使用案例，更多的例子可以在<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> MDN </a>、<a class="ae kv" href="https://www.digitalocean.com/community/tutorials/list-processing-with-map-filter-and-reduce" rel="noopener ugc nofollow" target="_blank">数字海洋</a>等网站找到。</p><p id="3c10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p></div></div>    
</body>
</html>