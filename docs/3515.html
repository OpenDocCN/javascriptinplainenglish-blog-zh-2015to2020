<html>
<head>
<title>How to Build a CRUD App with Amplify and AWS AppSync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Amplify和AWS AppSync构建CRUD应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-crud-app-with-amplify-and-aws-appsync-a31ecbad58a7?source=collection_archive---------12-----------------------#2020-10-05">https://javascript.plainenglish.io/how-to-build-a-crud-app-with-amplify-and-aws-appsync-a31ecbad58a7?source=collection_archive---------12-----------------------#2020-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2e81" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用GraphQL变异对数据库执行CRUD操作</h2></div><p id="5797" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" href="https://docs.amplify.aws/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>是一个让我们快速开发网络或移动应用的框架。在本教程中，我们将继续学习如何使用GraphQL变异对数据库执行CRUD操作。AWS Amplify有一个完整的工具链，通过GraphQL连接和管理API。我们将在本教程中创建的API是一个使用AWS AppSync(一个托管的GraphQL服务)的GraphQL API，数据库将是Amazon DynamoDB(一个NoSQL数据库)。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/b0eb7cfb87f006c67291240614c346c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0htFkSFqrNBhMJ2BL8XE2A.png"/></div></div></figure><p id="f3ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在你开始本教程之前，请跟随<a class="ae ky" href="https://www.instamobile.io/mobile-development/react-native-aws-amplify/" rel="noopener ugc nofollow" target="_blank">第1部分</a>，在那里我们讨论了设置Amplify作为一个框架，以及使用自定义UI的电子邮件认证。</p><h2 id="186b" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">创建一个GraphQL API</h2><p id="6301" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">要开始创建API并连接数据库，请在终端窗口中运行以下命令。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="a9ca" class="ll lm in mk b gy mo mp l mq mr">amplify add api</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/5e77ff81cf0d22ca6593b247b41dd95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*Fy9biWUXR2yUMpeX.png"/></div></figure><p id="65b1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个CLI执行会自动完成几件事情。首先，它创建了一个全功能的GraphQL API，包括数据源、带有查询、变异和订阅的基本模式结构的解析器。它还通过发送请求下载运行这些操作所需的客户端代码和配置文件。上面的命令将提示我们选择我们想要编写的API类型。输入配置文件API名称。在下面的例子中，我们保留默认的配置文件名。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d0da2919f9620d03c25dfddbc80ac64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*IwVm0fEryVMgkxuW.png"/></div></figure><p id="849b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，它将再次为我们提供两个选项，告诉我们如何对AWS AppSync API进行身份验证。在实时应用程序中，我们有不同的用户访问数据库并向它发出请求。选择选项<strong class="ke io"> Amazon Cognito用户池</strong>。这是一种更务实的方法。因为我们已经用认证模块配置了<strong class="ke io"> Amazon Cognito用户池</strong>，所以我们不需要在这里进行配置。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mu"><img src="../Images/f026ff57f79f7d748e6232ad7506bd1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qkAGqGuoOZzjZrdJ.png"/></div></div></figure><p id="6608" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于接下来的两个问题<strong class="ke io">您是否希望为GraphQL API配置高级设置</strong>和<strong class="ke io">您是否有带注释的GraphQL模式？</strong>答案是<code class="fe mv mw mx mk b">N</code>或否。Amplify附带预定义的模式，以后可以更改。</p><p id="aaf5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当提示<strong class="ke io">选择一个模式模板</strong>时，选择选项<strong class="ke io">带字段的单个对象。</strong></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi my"><img src="../Images/77e4fe4e92ad99790002490ebf10f7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AQtxbqCnC3x41D8f.png"/></div></div></figure><p id="3584" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们继续之前，让我们编辑由这个过程创建的GraphQL模式。转到React本地项目，从根目录打开文件<code class="fe mv mw mx mk b">amplify/backed/api/[API_NAME]/schema.graphql</code>。</p><p id="1cd2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">AppSync创建的默认模型如下:</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="6d0b" class="ll lm in mk b gy mo mp l mq mr">type Todo @model {<br/>  id: ID!<br/>  name: String!<br/>  description: String<br/>}</span></pre><p id="60b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">目前，在CLI中完成该过程时，一定会提示一条警告，描述为:</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="c760" class="ll lm in mk b gy mo mp l mq mr">The following types do not have '@auth' enabled. Consider using @auth with @model <br/>- Todo</span></pre><p id="4439" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们已经启用了认证模块，所以我们可以在<code class="fe mv mw mx mk b">schema.graphql</code>文件中添加<code class="fe mv mw mx mk b">@auth</code>指令。默认情况下，启用所有者授权允许任何登录用户创建记录。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="01a2" class="ll lm in mk b gy mo mp l mq mr">type Todo @model @auth(rules: [{ allow: owner }]) {<br/>  id: ID!<br/>  name: String!<br/>  description: String<br/>}</span></pre><p id="59c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不熟悉GraphQL模型及其类型，这里有一个简单的概述。</p><p id="d857" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GraphQL模式中的<code class="fe mv mw mx mk b">type</code>是存储在数据库中的一段数据。每种类型可以有一组不同的字段。把<code class="fe mv mw mx mk b">type</code>想象成一个来自JavaScript后台的对象。例如，在上面的模式中，<code class="fe mv mw mx mk b">Todo</code>模型的类型有三个字段:<code class="fe mv mw mx mk b">id</code>、<code class="fe mv mw mx mk b">name</code>和<code class="fe mv mw mx mk b">description</code>。另外，<code class="fe mv mw mx mk b">@model</code>指令用于在Amazon DynamoDB中存储类型。这是亚马逊在存储我们的应用程序数据时使用的数据库。</p><p id="069a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感叹号<code class="fe mv mw mx mk b">!</code>表示存储数据时该字段是必需的，并且必须有一个值。在上面的模式中，Todo类型有两个必需字段:<code class="fe mv mw mx mk b">id</code>和<code class="fe mv mw mx mk b">name</code>。</p><p id="b463" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">保存此文件，我们刚才所做的所有更改现在都保存在本地。</p><h2 id="7bbe" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">将API发布到AWS云</h2><p id="db5c" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">在运行该命令时，作为一个提示，它会返回一个表，其中包含有关我们已经使用、修改或启用的资源的信息。这些资源的名称在<strong class="ke io">类别</strong>部分描述。</p><p id="8333" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上表中的<strong class="ke io">资源</strong>名称是上一节中选择的API名称。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d51cfae07f32dfda4d2e0da871ceeac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/0*Z5JMkOnxU830dIyC.png"/></div></figure><p id="6f40" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Amplify CLI界面现在将检查模式，然后在将最终更改发布到云之前编译它以查找任何错误。</p><p id="3cf7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步，它会提示我们选择是否要为新创建的GraphQL API生成代码。按下<code class="fe mv mw mx mk b">Y</code>。然后选择JavaScript作为代码生成语言。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi na"><img src="../Images/35bd3f7c3d0a723c4463b3030548d87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*exfgLWNHS41BItzp.png"/></div></div></figure><p id="21f1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按<code class="fe mv mw mx mk b">Y</code>进入下一个询问更新所有GraphQL相关操作的问题。同样，让最大语句深度作为<code class="fe mv mw mx mk b">2</code>的默认值。更新AWS云上的资源需要一些时间，完成后会提示一条成功消息。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi my"><img src="../Images/0d0bb8aecba7afd5fbb52622256851f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DjNzrN8FtA4tX3Tt.png"/></div></div></figure><h2 id="5d8a" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">在React本机应用程序中添加输入字段</h2><p id="cec0" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">为了捕捉用户输入，我们将通过React hook <code class="fe mv mw mx mk b">useState</code>使用两个状态变量。第一个状态变量是todo项的name <code class="fe mv mw mx mk b">name</code>字段和一个名为<code class="fe mv mw mx mk b">todos</code>的数组。这个数组将用于从GraphQL API中获取所有的todo项，并在UI上显示这些项。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="0cd8" class="ll lm in mk b gy mo mp l mq mr">const [name, setName] = useState(''); <br/>const [todos, setTodos] = useState([]);</span></pre><p id="ab92" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，从React Native导入<code class="fe mv mw mx mk b">TextInput</code>和<code class="fe mv mw mx mk b">TouchableOpacity</code>来创建一个输入字段和一个可按下的按钮，该按钮具有在<code class="fe mv mw mx mk b">Home</code>组件下的<code class="fe mv mw mx mk b">StyleSheet</code>引用对象中定义的一些自定义样式。这里是<code class="fe mv mw mx mk b">Home.js</code>的完整代码:</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="aff9" class="ll lm in mk b gy mo mp l mq mr">import React, { useState } from 'react';<br/>import {<br/>  View,<br/>  Text,<br/>  TextInput,<br/>  TouchableOpacity,<br/>  StyleSheet,<br/>  Button,<br/>  ScrollView,<br/>  Dimensions<br/>} from 'react-native';<br/>import { Auth } from 'aws-amplify';<br/><br/>const { width } = Dimensions.get('window');<br/><br/>export default function Home({ updateAuthState }) {<br/>  const [name, setName] = useState('');<br/>  const [todos, setTodos] = useState([]);<br/><br/>  async function signOut() {<br/>    try {<br/>      await Auth.signOut();<br/>      updateAuthState('loggedOut');<br/>    } catch (error) {<br/>      console.log('Error signing out: ', error);<br/>    }<br/>  }<br/><br/>  const addTodo = () =&gt; {};<br/><br/>  return (<br/>    &lt;View style={styles.container}&gt;<br/>      &lt;Button title="Sign Out" color="tomato" onPress={signOut} /&gt;<br/>      &lt;ScrollView&gt;<br/>        &lt;TextInput<br/>          style={styles.input}<br/>          value={name}<br/>          onChangeText={text =&gt; setName(text)}<br/>          placeholder="Add a Todo"<br/>        /&gt;<br/>        &lt;TouchableOpacity onPress={addTodo} style={styles.buttonContainer}&gt;<br/>          &lt;Text style={styles.buttonText}&gt;Add&lt;/Text&gt;<br/>        &lt;/TouchableOpacity&gt;<br/>      &lt;/ScrollView&gt;<br/>    &lt;/View&gt;<br/>  );<br/>}<br/><br/>const styles = StyleSheet.create({<br/>  container: {<br/>    flex: 1,<br/>    alignItems: 'center',<br/>    marginTop: 20<br/>  },<br/>  input: {<br/>    height: 50,<br/>    borderBottomWidth: 2,<br/>    borderBottomColor: 'tomato',<br/>    marginVertical: 10,<br/>    width: width * 0.8,<br/>    fontSize: 16<br/>  },<br/>  buttonContainer: {<br/>    backgroundColor: 'tomato',<br/>    marginVertical: 10,<br/>    padding: 10,<br/>    borderRadius: 5,<br/>    alignItems: 'center',<br/>    width: width * 0.8<br/>  },<br/>  buttonText: {<br/>    color: '#fff',<br/>    fontSize: 24<br/>  }<br/>});</span></pre><p id="0763" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确保您正在终端窗口中运行<code class="fe mv mw mx mk b">expo start</code>命令，以查看此步骤的结果。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/efec30e210862be2eae8d34840420400.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*ZqXo8vlwzpGC4zd2.png"/></div></figure><h2 id="d526" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">使用GraphQL API添加变异</h2><p id="134b" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">GraphQL的一个变种就是处理像添加、删除或修改数据这样的操作。目前，React本机应用程序是基本的，但它的目的是让您熟悉作为工具链的Amplify及其与跨平台框架的集成。</p><p id="5f4e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要添加一个项目并在React本机应用程序中检索该项目，让我们添加一些业务逻辑，以便通过一个突变与GraphQL后端进行通信。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="a311" class="ll lm in mk b gy mo mp l mq mr">/* eslint-disable */<br/>// this is an auto generated file. This will be overwritten<br/><br/>export const createTodo = /* GraphQL */ `<br/>  mutation CreateTodo(<br/>    $input: CreateTodoInput!<br/>    $condition: ModelTodoConditionInput<br/>  ) {<br/>    createTodo(input: $input, condition: $condition) {<br/>      id<br/>      name<br/>      description<br/>      createdAt<br/>      updatedAt<br/>      owner<br/>    }<br/>  }<br/>`;<br/>export const updateTodo = /* GraphQL */ `<br/>  mutation UpdateTodo(<br/>    $input: UpdateTodoInput!<br/>    $condition: ModelTodoConditionInput<br/>  ) {<br/>    updateTodo(input: $input, condition: $condition) {<br/>      id<br/>      name<br/>      description<br/>      createdAt<br/>      updatedAt<br/>      owner<br/>    }<br/>  }<br/>`;<br/>export const deleteTodo = /* GraphQL */ `<br/>  mutation DeleteTodo(<br/>    $input: DeleteTodoInput!<br/>    $condition: ModelTodoConditionInput<br/>  ) {<br/>    deleteTodo(input: $input, condition: $condition) {<br/>      id<br/>      name<br/>      description<br/>      createdAt<br/>      updatedAt<br/>      owner<br/>    }<br/>  }<br/>`;</span></pre><p id="ae3f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是通过Amplify实现的，要使用上述任何一种突变，我们可以直接在组件文件中导入方法。在<code class="fe mv mw mx mk b">Home.js</code>文件中，从<code class="fe mv mw mx mk b">aws-amplify</code>包中导入<code class="fe mv mw mx mk b">API</code>和<code class="fe mv mw mx mk b">graphqlOperation</code>。<code class="fe mv mw mx mk b">API</code>是AWS资源的类别，导入的第二个函数是运行变异或查询的方法。另外，从<code class="fe mv mw mx mk b">graphql/mutation.js</code>文件导入突变<code class="fe mv mw mx mk b">createTodo</code>。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="d9e7" class="ll lm in mk b gy mo mp l mq mr">// ... <br/>import { Auth, API, graphqlOperation } from 'aws-amplify'; import { createTodo } from '../graphql/mutations';</span></pre><p id="ea5c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将逻辑添加到我们在上一节中定义的<code class="fe mv mw mx mk b">addTodo</code>自定义处理程序方法中。这将是一个异步函数，从变异中获取结果并更新<code class="fe mv mw mx mk b">todos</code>数组。它将<code class="fe mv mw mx mk b">name</code>作为输入，其中<code class="fe mv mw mx mk b">name</code>是项目的文本。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="f555" class="ll lm in mk b gy mo mp l mq mr">const addTodo = async () =&gt; {<br/>  const input = { name };<br/>  const result = await API.graphql(graphqlOperation(createTodo, { input }));<br/><br/>  const newTodo = result.data.createTodo;<br/>  const updatedTodo = [newTodo, ...todos];<br/>  setTodos(updatedTodo);<br/>  setName('');<br/>};</span></pre><p id="f1ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们进入下一部分之前，尝试添加一些数据。</p><h2 id="d9b3" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">运行查询以从AWS AppSync获取数据</h2><p id="d182" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">为了从数据库中获取数据，我们需要运行一个查询。与突变类似，Amplify也负责基于生成的GraphQL模式创建初始查询。</p><p id="a79b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有可用的查询都可以在<code class="fe mv mw mx mk b">src/graphql/queries.js</code>中找到。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="54c4" class="ll lm in mk b gy mo mp l mq mr">/* eslint-disable */<br/>// this is an auto generated file. This will be overwritten<br/><br/>export const getTodo = /* GraphQL */ `<br/>  query GetTodo($id: ID!) {<br/>    getTodo(id: $id) {<br/>      id<br/>      name<br/>      description<br/>      createdAt<br/>      updatedAt<br/>      owner<br/>    }<br/>  }<br/>`;<br/>export const listTodos = /* GraphQL */ `<br/>  query ListTodos(<br/>    $filter: ModelTodoFilterInput<br/>    $limit: Int<br/>    $nextToken: String<br/>  ) {<br/>    listTodos(filter: $filter, limit: $limit, nextToken: $nextToken) {<br/>      items {<br/>        id<br/>        name<br/>        description<br/>        createdAt<br/>        updatedAt<br/>        owner<br/>      }<br/>      nextToken<br/>    }<br/>  }<br/>`;</span></pre><p id="ceb5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要从GraphQL API获取所有数据并显示在设备屏幕上，让我们使用上面文件中的查询。将<code class="fe mv mw mx mk b">listTodos</code>导入到<code class="fe mv mw mx mk b">Home.js</code>文件中:</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="8253" class="ll lm in mk b gy mo mp l mq mr">import { listTodos } from '../graphql/queries';</span></pre><p id="31f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了从数据库中获取数据，让我们使用<code class="fe mv mw mx mk b">useEffect</code>钩子。确保从React库导入它:</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="ce65" class="ll lm in mk b gy mo mp l mq mr">import React, { useState, useEffect } from 'react';</span></pre><p id="0be3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们定义另一个名为<code class="fe mv mw mx mk b">fetchTodos</code>的处理程序方法，通过运行查询<code class="fe mv mw mx mk b">listTodos</code>来获取数据。这将是一个异步方法，所以让我们使用<code class="fe mv mw mx mk b">try/catch</code>块来捕捉获取数据时的任何初始错误。在<code class="fe mv mw mx mk b">Home</code>组件中添加以下代码片段:</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="851b" class="ll lm in mk b gy mo mp l mq mr">useEffect(() =&gt; {<br/>  fetchTodos();<br/>}, []);<br/><br/>async function fetchTodos() {<br/>  try {<br/>    const todoData = await API.graphql(graphqlOperation(listTodos));<br/>    const todos = todoData.data.listTodos.items;<br/>    console.log(todos);<br/>    setTodos(todos);<br/>  } catch (err) {<br/>    console.log('Error fetching data');<br/>  }<br/>}</span></pre><p id="be13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从数据库返回的数据数组如下所示:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/917920b255d80684a2edc9ed1f7a7298.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/0*ayAPomr436_jHQq9.png"/></div></figure><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="1045" class="ll lm in mk b gy mo mp l mq mr">return (<br/>  &lt;View style={styles.container}&gt;<br/>    &lt;Button title="Sign Out" color="tomato" onPress={signOut} /&gt;<br/>    &lt;ScrollView&gt;<br/>      &lt;TextInput<br/>        style={styles.input}<br/>        value={name}<br/>        onChangeText={text =&gt; setName(text)}<br/>        placeholder="Add a Todo"<br/>      /&gt;<br/>      &lt;TouchableOpacity onPress={addTodo} style={styles.buttonContainer}&gt;<br/>        &lt;Text style={styles.buttonText}&gt;Add&lt;/Text&gt;<br/>      &lt;/TouchableOpacity&gt;<br/>      {todos.map((todo, index) =&gt; (<br/>        &lt;View key={index} style={styles.itemContainer}&gt;<br/>          &lt;Text style={styles.itemName}&gt;{todo.name}&lt;/Text&gt;<br/>        &lt;/View&gt;<br/>      ))}<br/>    &lt;/ScrollView&gt;<br/>  &lt;/View&gt;<br/>);</span></pre><p id="22b0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，更新相应的样式:</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="2cf6" class="ll lm in mk b gy mo mp l mq mr">const styles = StyleSheet.create({<br/>  // ...<br/>  itemContainer: {<br/>    marginTop: 20,<br/>    borderBottomWidth: 1,<br/>    borderBottomColor: '#ddd',<br/>    paddingVertical: 10,<br/>    flexDirection: 'row',<br/>    justifyContent: 'space-between'<br/>  },<br/>  itemName: {<br/>    fontSize: 18<br/>  }<br/>});</span></pre><p id="987e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是您将得到的结果:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/fc033fe3f515e9d267a267fa1a4f1376.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*z7-OXCplVR9Tg-6Z.png"/></div></figure><h2 id="a5b7" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">在查询提取数据时添加加载指示器</h2><p id="a551" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">现在，当应用程序刷新或用户登录时，需要时间进行网络调用来加载数据，因此，在呈现列表项时会有轻微的延迟。让我们使用React Native的<code class="fe mv mw mx mk b">ActivityIndicator</code>添加一个加载指示器。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="1028" class="ll lm in mk b gy mo mp l mq mr">// modify the following import statement<br/>import {<br/>  View,<br/>  Text,<br/>  TextInput,<br/>  TouchableOpacity,<br/>  StyleSheet,<br/>  Button,<br/>  ScrollView,<br/>  Dimensions,<br/>  ActivityIndicator<br/>} from 'react-native';</span></pre><p id="113a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了知道查询运行时何时显示加载指示器，让我们在<code class="fe mv mw mx mk b">Home</code>组件中添加一个名为<code class="fe mv mw mx mk b">loading</code>的新状态变量，初始值为布尔值<code class="fe mv mw mx mk b">false</code>。当获取数据时，最初这个值是<code class="fe mv mw mx mk b">true</code>，只有当从API获取数据时，它的值才被再次设置为<code class="fe mv mw mx mk b">false</code>。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="1e59" class="ll lm in mk b gy mo mp l mq mr">export default function Home({ updateAuthState }) {<br/>// ...<br/>const [loading, setLoading] = useState(false);<br/><br/>// modify the fetchTodos method<br/> async function fetchTodos() {<br/>    try {<br/>      setLoading(true);<br/>      const todoData = await API.graphql(graphqlOperation(listTodos));<br/>      const todos = todoData.data.listTodos.items;<br/>      console.log(todos);<br/>      setTodos(todos);<br/>      setLoading(false);<br/>    } catch (err) {<br/>      setLoading(false);<br/>      console.log('Error fetching data');<br/>    }<br/>  }<br/><br/>  // then modify the JSX contents<br/><br/>  return (<br/>    {/* rest remains same */}<br/>    &lt;ScrollView&gt;<br/>        {/* rest remains same */}<br/>        {loading &amp;&amp; (<br/>          &lt;View style={styles.loadingContainer}&gt;<br/>            &lt;ActivityIndicator size="large" color="tomato" /&gt;<br/>          &lt;/View&gt;<br/>        )}<br/>        {todos.map((todo, index) =&gt; (<br/>          &lt;View key={index} style={styles.itemContainer}&gt;<br/>            &lt;Text style={styles.itemName}&gt;{todo.name}&lt;/Text&gt;<br/>          &lt;/View&gt;<br/>        ))}<br/>      &lt;/ScrollView&gt;<br/>  )<br/>}<br/><br/>// also modify the styles<br/><br/>const styles = StyleSheet.create({<br/>  // ...<br/>  loadingContainer: {<br/>    marginVertical: 10<br/>  }<br/>});</span></pre><p id="22a0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是输出:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b86b67cddde111849652f82ac7d8d46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*Cd4PosxfKY62ud_H.gif"/></div></figure><h2 id="ad8d" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">运行删除突变来删除项目\</h2><p id="ca04" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">要从<code class="fe mv mw mx mk b">todos </code>数组中删除一个项目，需要执行变异<code class="fe mv mw mx mk b">deleteTodo</code>。让我们使用列表中的每一项的<code class="fe mv mw mx mk b">TouchableOpacity</code>和<code class="fe mv mw mx mk b">@expo/vector-icons</code>在UI上添加一个按钮。在<code class="fe mv mw mx mk b">Home.js</code>组件文件中，首先导入图标和突变。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="9963" class="ll lm in mk b gy mo mp l mq mr">// ...<br/> import { Feather as Icon } from '@expo/vector-icons'; <br/>import { createTodo, deleteTodo } from '../graphql/mutations';</span></pre><p id="4db6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，定义一个名为<code class="fe mv mw mx mk b">removeTodo</code>的处理程序方法，该方法将从<code class="fe mv mw mx mk b">todos</code>数组中删除todo项，并通过对其使用<code class="fe mv mw mx mk b">filter</code>方法来更新数组。这次突变的<code class="fe mv mw mx mk b">input</code>将是todo项的<code class="fe mv mw mx mk b">id</code>。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="a24f" class="ll lm in mk b gy mo mp l mq mr">const removeTodo = async id =&gt; {<br/>  try {<br/>    const input = { id };<br/>    const result = await API.graphql(<br/>      graphqlOperation(deleteTodo, {<br/>        input<br/>      })<br/>    );<br/>    const deletedTodoId = result.data.deleteTodo.id;<br/>    const updatedTodo = todos.filter(todo =&gt; todo.id !== deletedTodoId);<br/>    setTodos(updatedTodo);<br/>  } catch (err) {<br/>    console.log(err);<br/>  }<br/>};</span></pre><p id="f569" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在呈现todo列表项的位置添加按钮。</p><pre class="la lb lc ld gt mj mk ml mm aw mn bi"><span id="42c4" class="ll lm in mk b gy mo mp l mq mr">{<br/>  todos.map((todo, index) =&gt; {<br/>    return (<br/>      &lt;View key={index} style={styles.itemContainer}&gt;<br/>        &lt;Text style={styles.itemName}&gt;{todo.name}&lt;/Text&gt;<br/>        &lt;TouchableOpacity onPress={() =&gt; removeTodo(todo.id)}&gt;<br/>          &lt;Icon name="trash-2" size={18} color="tomato" /&gt;<br/>        &lt;/TouchableOpacity&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  });<br/>}</span></pre><p id="448f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是完成这一步后您将得到的输出。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e014207f93cfef0191cb918a5bb9f93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/0*56BakVpxTjK5AeoT.gif"/></div></figure><h2 id="f517" class="ll lm in bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">摘要</h2><p id="604c" class="pw-post-body-paragraph kc kd in ke b kf me jo kh ki mf jr kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">完成本教程后，您会发现使用AWS AppSync和Amplify创建GraphQL API是多么简单。</p><p id="0e3f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<a class="ae ky" href="https://www.instamobile.io/" rel="noopener ugc nofollow" target="_blank"> Instamobile </a>，我们正在构建随时可用的React原生应用，由各种后端支持，如AWS Amplify或Firebase，以帮助开发者更快地制作他们自己的移动应用。</p><p id="3db8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae ky" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ke io">！</strong></p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="1b3e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nm">原载于2020年10月5日</em><a class="ae ky" href="https://www.instamobile.io/react-native-tutorials/aws-appsync-react-native/" rel="noopener ugc nofollow" target="_blank"><em class="nm">https://www . insta mobile . io</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>