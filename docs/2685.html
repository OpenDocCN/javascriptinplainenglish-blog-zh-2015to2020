<html>
<head>
<title>Builder Pattern in JavaScript/TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript/TypeScript中的生成器模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/builder-pattern-in-javascript-typescript-80341c2d3dea?source=collection_archive---------8-----------------------#2020-07-14">https://javascript.plainenglish.io/builder-pattern-in-javascript-typescript-80341c2d3dea?source=collection_archive---------8-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/517447dcd8152adbdb37657948303a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3tfZiS6x31tk4k9l4w7lQ.jpeg"/></div></div></figure><p id="4c8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章不仅仅是关于JS/TS中的构建器模式，我将解释我背后的思考过程，看看你是否能理解。我相信每个人都有独特的解决问题的方法，希望你能从中学到一些东西。</p><p id="d3c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个月前，我买了Imtiaz Ahmed的这本非常有用的设计模式课程。虽然这个课程是用Java编写的，但是我用Typescript实现了所有的设计模式。我将会讨论这门课的一个重要任务，在这里提到，</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="c6f1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">业务需求:</h1><p id="bd01" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">公司需要一个方便的API来与搜索引擎交互。您需要使用构建器模式来创建下面的JSON结构。这个JSON结构实际上是一个查询，可以提交给一个名为Elasticsearch的搜索引擎。Elasticsearch是一个开源工具，人们可以下载并使用，但这并不重要。我们公司的开发人员使用您的builder API应该能够创建这样的JSON请求。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/92608d6cfef9750c4512808e66167b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_OOKW9bwhqlZgY9Mo1wsw.png"/></div></div></figure><p id="44a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是JSON结构的<strong class="ka ir">规则</strong>:</p><ol class=""><li id="df54" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">在bool部分中可以有一个must或should部分，如图所示。</li><li id="cc69" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">但是请记住，在每一个“必须”或“应该”中，都可以有嵌套的bool部分。匹配部分很简单，可以有任何属性名及其值。</li></ol><p id="792a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，上面的JSON查询只过滤那些“牛奶”商品。“item_type”属性的值为“Dairy”。产品位置应为“新墨西哥州”，仓库编号为37。</p><p id="42b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当它们被转换成JSON格式时，您需要创建几个表示这个JSON结构的类。</p><p id="26af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建名为Query、Bool、Must、Match和Test的类。您可能还需要一个名为QueryBuilder的类，或者您想给它取什么名字都行。客户端将调用构建器方法来创建Musts、Shoulds等的实例。并打印出JSON格式的组合对象，以证明API按预期工作。</p><p id="ba33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个开发者如何使用API的例子:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="3ee8" class="nf lf iq nb b gy ng nh l ni nj">QueryBuilder builder = new QueryBuilder();</span><span id="f2b6" class="nf lf iq nb b gy nk nh l ni nj">builder.bool().mustMatch(“item”, “Milk”).mustMatch(“item_type”, “Dairy”);</span><span id="d4f0" class="nf lf iq nb b gy nk nh l ni nj">builder.bool().shouldMatch(“product_location”,”NewMexico”).shouldMatch(“warehouse_number”, 37);</span></pre><p id="75d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，如果需要，开发人员需要能够在musts或shoulds中嵌套bools。这是一个嵌套bool的例子，在现有的should部分中包含一个must。开发人员希望像这样使用API:</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="f6a8" class="nf lf iq nb b gy ng nh l ni nj">let builder: QueryBuilder = new QueryBuilder();</span><span id="32a2" class="nf lf iq nb b gy nk nh l ni nj">builder.bool().shouldMatch(“lot_number”,307).bool().mustMatch(“expiry_date”, “Jan 2020”);</span><span id="b50b" class="nf lf iq nb b gy nk nh l ni nj"><strong class="nb ir">OR</strong></span><span id="84b0" class="nf lf iq nb b gy nk nh l ni nj">builder.bool().mustMatch("item", "Milk").mustMatch("item_type", "Dairy");<br/>builder.bool().shouldMatch("product_location", "New Mexico").shouldMatch("warehouse_number", 37);</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="0f99" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">解决方案和我的思考过程:</h1><p id="2ee3" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">到目前为止，我学习的所有构建器模式都非常容易理解和实现，例如，</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="5f82" class="nf lf iq nb b gy ng nh l ni nj">const myHouse = new HouseBuilder('Adder')<br/>.setFloor(5)<br/>.makeGarden()<br/>.makeParking()<br/>.build();</span></pre><p id="a56e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在我的<a class="ae kw" href="https://github.com/pineshmenat/OOP-Design/tree/master/src/6.Design%20Patterns/3.Builder/HouseExample" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> github </strong> </a>上查看House Builder的详细实现。这里需要注意的一点是，我们调用不同方法来构建房子的顺序并不重要，我可以在makeGarden()之后调用setFloor(5 ),就像在最后调用构建方法House obj被构建时一样。所以顺序在这里并不重要，但这不是我们指派问题的情况。</p><p id="217c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的QueryBuilder赋值中，我们可以在bool部分中有一个must或should部分。我们可以在每个“必须”或“应该”中嵌套bool部分。所以这里的顺序非常重要，我通过学习上面的HouseBuilder模式获得的知识不足以解决这个问题。</p><p id="6cd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我花了很多时间来思考不同的解决方案，我不想在网上搜索。我不断尝试不同的方法。这里提到了其中一些，</p><ul class=""><li id="9a30" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv nl ms mt mu bi translated">为了验证客户端调用API函数的顺序，我想使用if-else，但是当我意识到查询可能是嵌套的，并且验证所有这些都是没有意义的if-else时，我放弃了</li><li id="f615" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv nl ms mt mu bi translated">我试图通过多态来达到同样的效果，但是我没有达到我的预期，我不得不放弃这个想法。</li></ul><p id="6ae8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我吸收了一段时间的问题，并决定逆向工程。让我来解释一下</p><p id="69d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里查询对象最后没有被构建，不像我们调用的HouseBuilder。在所有创建房屋对象的方法调用结束时使用build()方法。这让我想到，每次当我们调用QueryBuilder方法时，这些方法中的每一个都应该返回一个class对象，我们应该能够只调用我们允许的特定方法。</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="986a" class="nf lf iq nb b gy ng nh l ni nj">builder.bool().shouldMatch(“lot_number”,307).bool().mustMatch(“expiry_date”, “Jan 2020”);</span></pre><ul class=""><li id="ab79" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv nl ms mt mu bi translated">这里QueryBulder应该有一个bool()方法，它将返回一个Bool类的对象。</li><li id="f159" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv nl ms mt mu bi translated">Bool类将有shoudMatch()和mustMatch()方法，它们将分别返回Should和Must类型的obj。</li><li id="008d" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv nl ms mt mu bi translated">现在，这个Should和Must类将拥有bool()方法，该方法将返回Bool类型的obj。这样我们就可以在查询中的should或must中嵌套bool。</li></ul><p id="5c7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们深入了解一下<a class="ae kw" href="https://github.com/pineshmenat/OOP-Design/tree/master/src/7.Final%20Assignment" rel="noopener ugc nofollow" target="_blank">的实现代码</a>，</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4815" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇文章对你有帮助，如果是的话，你可以给我一些掌声鼓励我写更多的东西，我不期待起立鼓掌；)谢谢。</p><h1 id="6e2d" class="le lf iq bd lg lh no lj lk ll np ln lo lp nq lr ls lt nr lv lw lx ns lz ma mb bi translated">简单英语的JavaScript</h1><p id="3e07" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ka ir">！</strong></p></div></div>    
</body>
</html>