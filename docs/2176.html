<html>
<head>
<title>4 Ways to Write More Effective TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更有效的打字稿的4种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-ways-to-write-more-effective-typescript-72033322c290?source=collection_archive---------1-----------------------#2020-05-27">https://javascript.plainenglish.io/4-ways-to-write-more-effective-typescript-72033322c290?source=collection_archive---------1-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="81b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写有效的TypeScript包括理解其目的、重新思考您的方法、避免常见的不良做法以及使用TypeScript的功能。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/006f2caa976d97a477b8da45dff14710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*169SbvCUF3gT1hFk0Heg1w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Finding his inner TypeScript — The TypeScript Mindset</figcaption></figure><h1 id="c988" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">打字稿思维模式</h1><p id="6d83" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当你有效地使用它时，TypeScript是一种强大的语言。</p><p id="4f4f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这意味着，尽管很难，脱离JavaScript思维模式，采用类型脚本思维模式。这意味着<strong class="lp ir">在你写代码的时候采用不同的个性，</strong>改变你思考过程的方式和你通过语法表达自己的方式。</p><p id="76e2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">因此，产生的TypeScript代码将提供对开发人员思维过程的更深入的了解。</p><blockquote class="mo"><p id="30ec" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">TypeScript允许您更清楚准确地定义意图。</p></blockquote><p id="89f0" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">将JavaScript和TypeScript视为两种不同的个性有助于认识到，要成为一名有效的TypeScript程序员，您必须适应哪些个性特征。</p><h2 id="4bea" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">如果JavaScript是一个人，它应该是“随和的”，“敢于尝试任何事情”的类型</h2><p id="510d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们都知道那种类型。那种你可以从中取乐的类型，但是当事情发展到严重的时候，你不应该太依赖他们。他们有把生活中重要的事情搞砸的倾向；最重要的时候。<strong class="lp ir">他们通常需要大量的帮助和指导，才能被认为是可靠的。</strong></p><p id="77a6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">用JavaScript术语来说，这种额外的帮助和指导意味着额外的测试、类型检查和冗长的注释。TypeScript不太可能需要的额外保证。</p><h2 id="4a54" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">TypeScript讨厌这些类型</h2><p id="de89" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">TypeScript不信任任何人。它不会盲目地相信任何事情，希望以后不会引起问题。TypeScript希望事先了解一切。它想看到你的思维过程和意图。没有懒惰。没有遗漏。</p><p id="6065" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">TypeScript希望你告诉它从你的代码中可以得到什么，这样它就可以帮助你。</p><h2 id="dbf9" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">打字稿开发人员的积极心态</h2><blockquote class="mo"><p id="b776" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">TypeScript需要思维方式的转变，变得更加主动、严格和深思熟虑。</p></blockquote><p id="3e7b" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">TypeScript为我们提供了支持这种积极心态的特性。我们获得了显式注释代码的能力，通过静态类型化为工具提供了所需的信息，从而改善了开发体验。它允许我们达到用JavaScript很难达到的静态分析水平。它能让我们在虫子出现之前就抓住它们。</p><p id="c972" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">JavaScript太宽容了，但是TypeScript试图改变这一点。</p><h1 id="39c2" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">打字稿的注意事项</h1><p id="e0bf" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这些该做的和不该做的是特定于TypeScript 的<strong class="lp ir">(不是TypeScript和JavaScript)。在这些该做和不该做的事情中有一个共同的主题，那就是<strong class="lp ir">不受欢迎的类型脚本行为是出于对他们的代码暂时像JavaScript一样运行的渴望</strong>。</strong></p><p id="ee83" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">虽然如果您有编写JavaScript的长期历史，那么TypeScript可能会暂时影响生产率，但是一旦您掌握了这种语言，除了质量和可读性之外，生产率将会超过JavaScript所能达到的水平。</p><blockquote class="mo"><p id="3578" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">如果你坚持使用TypeScript，你将会爱上它为你的代码所做的一切，并且你会对代码充满信心。</p></blockquote><p id="26dd" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">因此，不使用类型似乎可以节省时间。然而，那是短期的。<strong class="lp ir">坚持JavaScript行为的长期负面后果超过了任何最初的好处。</strong></p><p id="3cfe" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">后果通过未被发现的错误、糟糕的可读性和更大的(更少可重用的)代码库表现出来。</p><p id="eb59" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">不可避免的是，你将不得不在很短的时间内正确地学习TypeScript(所以你最好尽快完成)。</p><p id="acb5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">因为归根结底，创建TypeScript是为了解决JavaScript的缺点。</p><blockquote class="np nq nr"><p id="8676" class="ln lo ns lp b lq mj jr ls lt mk ju lv nt ml ly lz nu mm mc md nv mn mg mh mi ij bi translated">我在上一篇文章中提供了关于TypeScript如何“保存”JavaScript的更详细的解释。</p></blockquote><div class="nw nx gp gr ny nz"><a href="https://medium.com/swlh/typescript-rescued-the-javascript-language-bfc944c0f96b" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">TypeScript拯救了JavaScript语言</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">它通过静态类型、改进的开发人员工具和OOP特性将可伸缩性带到了一个有缺陷和令人沮丧的…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div><blockquote class="mo"><p id="033e" class="mp mq iq bd mr ms oo op oq or os mi dk translated">从长远来看，TypeScript可以为您节省大量时间和金钱。</p></blockquote><p id="2b6b" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><strong class="lp ir">所以这里有一些写更有效的打字稿的技巧… </strong></p><h1 id="c79b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">1)使用严格模式</h1><p id="7d06" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">使用它。你以后会感谢自己的。就像在<code class="fe ot ou ov ow b">tsconfig.json</code>中的编译器选项中提供<code class="fe ot ou ov ow b">strict: true</code>一样简单。</p><blockquote class="mo"><p id="1f63" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">严格模式默认为<code class="fe ot ou ov ow b">false</code>。</p></blockquote><p id="e229" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">严格模式通过更严格的类型来改进验证。它为我们代码中的类型提供了更强的保证。将<code class="fe ot ou ov ow b">strict</code>转到<code class="fe ot ou ov ow b">true</code>会启用属于严格系列的所有功能。然后由您根据需要禁用各个选项。严格模式提供了广泛的类型检查行为。</p><h2 id="8ef7" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">严格系列—严格模式选项</h2><p id="275d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当<code class="fe ot ou ov ow b">strict: true</code>时，一些重要选项作为严格系列的一部分被启用。</p><p id="a235" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这些是…</p><ul class=""><li id="7726" class="ox oy iq lp b lq mj lt mk lw oz ma pa me pb mi pc pd pe pf bi translated"><code class="fe ot ou ov ow b"><strong class="lp ir">strictNullChecks</strong></code> —当这是<code class="fe ot ou ov ow b"><strong class="lp ir">false</strong></code>时，<code class="fe ot ou ov ow b">null</code>和<code class="fe ot ou ov ow b">undefined</code>被TypeScript编译器忽略；这意味着您可以将任何值赋给<code class="fe ot ou ov ow b">null</code>或<code class="fe ot ou ov ow b">undefined</code>而不受TypeScript的干扰。这不能保证变量是<code class="fe ot ou ov ow b">null</code>或<code class="fe ot ou ov ow b">undefined</code>，通常会导致无法捕捉的错误。</li></ul><blockquote class="np nq nr"><p id="2364" class="ln lo ns lp b lq mj jr ls lt mk ju lv nt ml ly lz nu mm mc md nv mn mg mh mi ij bi translated">将<code class="fe ot ou ov ow b"><em class="iq">strictNullChecks</em></code>设置为<code class="fe ot ou ov ow b"><em class="iq">true</em></code>指示编译器开始关心<code class="fe ot ou ov ow b"><em class="iq">null</em></code>和<code class="fe ot ou ov ow b"><em class="iq">undefined</em></code>，这意味着从那时起<strong class="lp ir">你必须明确定义变量何时可以是</strong> <code class="fe ot ou ov ow b"><strong class="lp ir"><em class="iq">null</em></strong></code> <strong class="lp ir">或</strong> <code class="fe ot ou ov ow b"><strong class="lp ir"><em class="iq">undefined</em></strong></code>类型。这可防止无意中操作<code class="fe ot ou ov ow b"><em class="iq">null</em></code>值。</p></blockquote><ul class=""><li id="91ae" class="ox oy iq lp b lq mj lt mk lw oz ma pa me pb mi pc pd pe pf bi translated"><code class="fe ot ou ov ow b"><strong class="lp ir">noImplicitAny</strong></code> —这意味着当<code class="fe ot ou ov ow b">true</code>，<strong class="lp ir">时，你必须声明变量、函数、参数等的所有类型。这防止我们退回到类似JavaScript的函数:定义一个没有类型的函数。</strong></li></ul><blockquote class="np nq nr"><p id="12dd" class="ln lo ns lp b lq mj jr ls lt mk ju lv nt ml ly lz nu mm mc md nv mn mg mh mi ij bi translated">因此，<code class="fe ot ou ov ow b"><em class="iq">const func = (param) =&gt; 'param is ' + param</em></code>将引发错误，而<code class="fe ot ou ov ow b"><em class="iq">const func = (param</em><strong class="lp ir"><em class="iq">: string</em></strong><em class="iq">) =&gt; 'param is ' + param</em></code>将是有效的TypeScript。</p></blockquote><h2 id="90de" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">为什么使用严格模式？</h2><p id="99b4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir">在生命周期的早期修复问题会更便宜</strong>。首先，根据代码的质量/状态，您可能会被看到的错误数量淹没。</p><p id="8903" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">但是重要的是要记住，TypeScript比JavaScript更容易抱怨。它的目标是构建高质量的应用程序，具有更强的类型和更少的错误。</p><p id="5aee" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">严格模式是符合TypeScript打字系统的最容易的途径。它为我们提供了智能的洞察力，帮助我们更好地理解代码中的关系；我们的项目分成的许多小组件、系统和服务之间的关系是相互作用的。</p><h2 id="c657" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">可能不使用严格模式的情况→从JavaScript迁移</h2><p id="911d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">最初你可能会尝试像<code class="fe ot ou ov ow b">false</code>一样使用严格模式。</p><p id="e1e2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在用JavaScript编写的现有项目中，迁移到TypeScript是一种关闭严格模式会使转换更加平滑的情况。</p><p id="3233" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于新项目，<strong class="lp ir">我看不出你为什么不使用严格模式</strong>的任何逻辑理由。从项目一开始就使用它是构建您有信心的有效的TypeScript应用程序的一种方式。</p><blockquote class="mo"><p id="c281" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">你越早遵守严格的打字规则，你就能越早从你新学到的习惯中获益。</p></blockquote><h1 id="eafc" class="kv kw iq bd kx ky kz la lb lc ld le lf jw pg jx lh jz ph ka lj kc pi kd ll lm bi translated">2)不要抑制类型</h1><p id="e0d1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在TypeScript中取消类型会让您编写更冗长的JavaScript版本。你再也没有权利称之为TypeScript了。</p><h2 id="950a" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">用“任何”来掩盖气味</h2><p id="2e00" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">抑制类型最常见的方式是通过<strong class="lp ir">转换为类型</strong> <code class="fe ot ou ov ow b"><strong class="lp ir">any</strong></code>。</p><p id="f035" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">有时很容易想让编译器安静下来。尤其是如果你有一个截止日期，并且你99.9%确定你知道你在做什么。</p><p id="a825" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">然而，最好是针对原因，而不是症状。</strong>所以也许要想想TypeScript为什么对你大喊大叫。也许是因为你没有正确地注释你的代码…</p><p id="53d1" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">抑制类型给人的印象是发生了两件事情中的一件:开发人员更关心的是完成<strong class="lp ir">而不是正确<strong class="lp ir">或者他们没有用类型注释他们的代码，直到他们被编译器调用(这里使用了<code class="fe ot ou ov ow b">any</code>类型转换)。</strong></strong></p><p id="dfc6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">可以变成<strong class="lp ir">类型抑制→错误→类型抑制→错误的永无止境的循环。</strong></p><h2 id="8484" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">强制转换为“any”类型的危险</h2><p id="42fa" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通过将一个变量强制转换为any like <code class="fe ot ou ov ow b">(obj as any).getName()</code>，你告诉transpiler，当这个变量出现时，任何事情都会发生。您可以调用任何方法，并将其分配给任何类型的任何对象。</p><p id="a83b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你是在告诉全世界‘这个变量可能是任何东西’。这是否给了你(以及其他看你代码的人)代码不会被破解的信心？</p><p id="f460" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">此外，在代码中的几个地方使用type <code class="fe ot ou ov ow b">any</code>意味着您将在大块代码中抑制所有与类型相关的错误。这使得TypeScript编译器更难工作，测试更难，可读性更差，并导致那些每个人都讨厌的耗时的bug。</p><h2 id="2519" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">如果您不知道类型或无法创建类型，请使用“未知”</h2><p id="40bd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果不知道类型，请使用<code class="fe ot ou ov ow b">unknown</code>。</p><blockquote class="np nq nr"><p id="6521" class="ln lo ns lp b lq mj jr ls lt mk ju lv nt ml ly lz nu mm mc md nv mn mg mh mi ij bi translated">在没有类型断言的情况下，任何东西都可以赋给<code class="fe ot ou ov ow b"><em class="iq">unknown</em></code>，但是<code class="fe ot ou ov ow b"><em class="iq">unknown</em></code>除了自身之外不能赋给任何东西。</p></blockquote><p id="5f5f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这意味着在类型为<code class="fe ot ou ov ow b">unknown</code>的变量上调用方法会引发错误<strong class="lp ir">，这是一件好事</strong>。因为你不想调用一个你不能保证存在的方法。它会扰乱你的应用程序流程，影响用户体验。</p><h2 id="9542" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">正确定义您的类型以避免这种情况</h2><p id="c266" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果在编写TypeScript代码时没有正确定义类型，您将会陷入这样的境地:</p><ol class=""><li id="faaa" class="ox oy iq lp b lq mj lt mk lw oz ma pa me pb mi pj pd pe pf bi translated">您会遇到错误。</li><li id="5ebe" class="ox oy iq lp b lq pk lt pl lw pm ma pn me po mi pj pd pe pf bi translated">意识到您应该做什么(即从工作流的开始返回并用正确的类型编写TypeScript代码)。</li><li id="d661" class="ox oy iq lp b lq pk lt pl lw pm ma pn me po mi pj pd pe pf bi translated">选择反对，因为由于你离开它的时间长度，它现在是一个非常令人生畏的任务。</li><li id="910e" class="ox oy iq lp b lq pk lt pl lw pm ma pn me po mi pj pd pe pf bi translated">多写一些糟糕的代码。</li><li id="2874" class="ox oy iq lp b lq pk lt pl lw pm ma pn me po mi pj pd pe pf bi translated"><strong class="lp ir">重复</strong>。</li></ol><p id="0c77" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">那是一种你不想处于的情况。我们都经历过。</p><h1 id="6d74" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">3)不要忽视警卫类型</h1><p id="f20f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">使用鸭式类型，很难确定一个对象是否属于某种类型。对于TypeScript中的接口，您经常需要检查对象实现了哪个接口(数据的形状)。</p><p id="29ba" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，<strong class="lp ir">如果不比较底层的区别属性，就不能可靠地检查接口</strong>的类型相等性。</p><h2 id="6dab" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">但是，内置的“类型”防护呢？</h2><p id="c7dc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe ot ou ov ow b">typeof</code>守卫只能检查<code class="fe ot ou ov ow b">string</code>、<code class="fe ot ou ov ow b">number</code>、<code class="fe ot ou ov ow b">bigint</code>、<code class="fe ot ou ov ow b">function</code>、<code class="fe ot ou ov ow b">boolean</code>、<code class="fe ot ou ov ow b">symbol</code>、<code class="fe ot ou ov ow b">object</code>、<code class="fe ot ou ov ow b">undefined</code>。</p><p id="4e68" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">因此，检查自定义类型的相等性超出了</strong> <code class="fe ot ou ov ow b"><strong class="lp ir">typeof</strong></code> <strong class="lp ir">操作符的范围。</strong></p><blockquote class="mo"><p id="be4b" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">typeof运算符只提供了一种浅层的类型检查。</p></blockquote><p id="db91" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">使用<code class="fe ot ou ov ow b">typeof</code>的类型检查过于简单，不适用于定制类型(类和接口)。</p><h2 id="2909" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">…而‘实例’警卫呢？</h2><p id="c7c5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">只有在对<strong class="lp ir">类</strong>进行类型检查时<code class="fe ot ou ov ow b">instanceof</code>保护才有价值。它检查一个对象是否是一个类的实例。它不为接口做任何事情。</p><p id="685d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">因此，很容易产生假阴性；即使基础形状相同，也返回false。因此，使用接口的<code class="fe ot ou ov ow b">instanceof</code>是不可能的。</p><h2 id="ade1" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">使用自定义类型脚本类型保护</h2><p id="3d57" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">编写TypeScript类型保护提供了一种在与对象交互之前检查接口类型的可重用方法。类型保护本质上是一个函数，它返回一个<code class="fe ot ou ov ow b">boolean</code>。</p><p id="b74f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你需要传递<strong class="lp ir">对象来检查</strong>作为你的守卫函数的参数。</p><pre class="kg kh ki kj gt pp ow pq pr aw ps bi"><span id="6888" class="nd kw iq ow b gy pt pu l pv pw">function isPerson(user: Person | Dog) user is Person {</span><span id="87e2" class="nd kw iq ow b gy px pu l pv pw">return user.discriminator === 'person';</span><span id="0ba9" class="nd kw iq ow b gy px pu l pv pw">}</span></pre><h1 id="4318" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">4)不要忽视泛型的力量</h1><p id="3253" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">泛型是编写可在整个项目中重用的可伸缩代码的关键。泛型是一个关键的类型脚本特性，它将<strong class="lp ir">增加代码的可伸缩性</strong>。</p><p id="8efb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">编写泛型代码涉及使用泛型参数，如<code class="fe ot ou ov ow b">filter&lt;T&gt;(param: T[]): T[]</code> <strong class="lp ir">，其中</strong> <code class="fe ot ou ov ow b"><strong class="lp ir">T</strong></code> <strong class="lp ir">是一个泛型类型</strong>，它被传递到函数定义中，如<code class="fe ot ou ov ow b">filter&lt;User[]&gt;(users)</code>和<code class="fe ot ou ov ow b">filter&lt;Post[]&gt;(post)</code>，这允许编译器满足函数体内该类型的所有用法。</p><blockquote class="mo"><p id="f31a" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">您可以将泛型视为动态类型的占位符。</p></blockquote><p id="26ed" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">为了确保一个函数作为通用函数工作，该函数必须具有单一的职责，并且该函数需要处理不同的输入。</p><h2 id="fe79" class="nd kw iq bd kx ne nf dn lb ng nh dp lf lw ni nj lh ma nk nl lj me nm nn ll no bi translated">泛型为您做了什么:</h2><ul class=""><li id="25e6" class="ox oy iq lp b lq lr lt lu lw py ma pz me qa mi pc pd pe pf bi translated">提倡干原则。</li><li id="4fb7" class="ox oy iq lp b lq pk lt pl lw pm ma pn me po mi pc pd pe pf bi translated">减少您编写的代码量。</li><li id="4f35" class="ox oy iq lp b lq pk lt pl lw pm ma pn me po mi pc pd pe pf bi translated">给你多态函数的类型保证。</li></ul><p id="f841" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">由于对编程行为的影响，泛型最终会降低开发成本。第一种方式是通过节省时间(和金钱),因为你通常会重新发明轮子。</p><p id="2aac" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">其次，它<strong class="lp ir">用更少的函数、类和组件促进了一个干净的代码库</strong>。对于团队来说，这是一个更容易开发、理解和使用周围代码的环境。</p><p id="a18d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，<strong class="lp ir">它阻止我们使用</strong><code class="fe ot ou ov ow b"><strong class="lp ir">any</strong></code><strong class="lp ir"/>类型，这在编写可重用的JavaScript时是不可避免的。由于编译时更强的类型检查，这将导致更健壮的代码库，更少由于类型相关的错误而导致的错误。</p><h1 id="d64f" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">所以基本上，让TypeScript是TypeScript。</h1><p id="9f82" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">退回到JavaScript习惯和模式会阻止TypeScript完成其设计目的。如果您通过采用TypeScript生活方式来满足TypeScript编译器，您将在以后获得回报。</p><blockquote class="mo"><p id="7c75" class="mp mq iq bd mr ms mt mu mv mw mx mi dk translated">感谢阅读！有任何问题，请在评论中告诉我。</p></blockquote><h2 id="1395" class="nd kw iq bd kx ne qb dn lb ng qc dp lf lw qd nj lh ma qe nl lj me qf nn ll no bi translated">为什么不在操场上尝试一下TypeScript功能呢？</h2><div class="nw nx gp gr ny nz"><a href="https://www.typescriptlang.org/play/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">playground——探索TypeScript和JavaScript的在线编辑器</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">Playground让你以一种安全和可共享的方式在线编写类型脚本或JavaScript。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div></div><div class="ab cl qg qh hu qi" role="separator"><span class="qj bw bk qk ql qm"/><span class="qj bw bk qk ql qm"/><span class="qj bw bk qk ql"/></div><div class="ij ik il im in"><h1 id="6550" class="kv kw iq bd kx ky qn la lb lc qo le lf jw qp jx lh jz qq ka lj kc qr kd ll lm bi translated"><strong class="ak">简明英语团队的笔记</strong></h1><p id="1508" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae qs" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="lp ir">JavaScript in Plain English</strong></a><a class="ae qs" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="lp ir">AI in Plain English</strong></a><a class="ae qs" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="lp ir">UX in Plain English</strong></a><a class="ae qs" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="lp ir">Python in Plain English</strong></a><strong class="lp ir"/>—谢谢，继续学习！</p><p id="16bb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们还推出了一个YouTube，希望你能通过<a class="ae qs" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="ed57" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae qs" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">submissions @ plain English . io</strong></a><strong class="lp ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>