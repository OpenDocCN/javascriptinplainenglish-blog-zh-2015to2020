<html>
<head>
<title>Build a Simple Todo App with React ⚛</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React ⚛创建一个简单的Todo应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-simple-todo-app-with-react-561579b39ad1?source=collection_archive---------0-----------------------#2020-02-15">https://javascript.plainenglish.io/build-a-simple-todo-app-with-react-561579b39ad1?source=collection_archive---------0-----------------------#2020-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa176e2baa6c4fcc884616187abe76cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPjPhc2gYkTplzF_DH-g5Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The Finished Product</figcaption></figure><p id="92bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我知道这是一个过度的项目，但是，构建一个todo应用程序是学习React和巩固库的一些基本原则的好方法。所以今天，我们将构建一个简单的React应用程序，看起来就像上面的图片。</p><h1 id="803e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置</h1><p id="e588" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们将在<a class="ae md" href="http://codepen.io" rel="noopener ugc nofollow" target="_blank"> Codepen </a>中构建这个应用程序，这将为我们提供一种快速的方式来设置环境，并在我们编码时查看我们对应用程序所做的实时更改。首先，请访问Codepen的网站，选择左侧面板上的按钮来创建一个新的笔。</p><p id="1121" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了确保我们可以在Codepen中使用React，我们需要向我们的应用程序添加适当的依赖项。为此，首先选择页面顶部的“设置”按钮。然后选择“Javascript”选项卡。在这里，您需要将Javascript预处理器设置为“Babel ”,并添加react和react-dom外部脚本。您的笔设置应该像这样:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/e6045f5eb6952744bc438e82b05e62d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*W6r8Ab9YE_wslQDpKR64UQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Adding React dependencies</figcaption></figure><p id="8d1a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于我们的风格，我们将使用一个名为布尔玛的外部CSS框架。在设置菜单仍然打开的情况下，翻到CSS标签，向下滚动到外部脚本部分，搜索“bulma”。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/6e175c336c1a2831b672d7ce0543daa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*4kVD1DnQ_uzvxu97WTl2uA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Adding Bulma framework</figcaption></figure><p id="7baf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">只需点击顶部的结果添加布尔玛到您的项目。添加完这些依赖项后，您可以单击“保存并关闭”。现在，我们准备开始编码了！</p><h1 id="21a0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设计</h1><p id="4bb4" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">但是在我们开始之前还有一件事…在你开始打字之前有一个你将要建立的计划总是一个好主意。尤其是在用React构建用户界面的时候。我们希望对接口的外观有一些了解，这样我们就可以知道我们需要构建什么组件，以及每个组件将负责处理什么数据。</p><p id="33f8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我画了一个todo应用程序的草图，并标记了我们需要创建的所有组件:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/94f5abe5234da8687598c165230e03e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*im1mYDbcVrNAHgOBjpOzMw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Todo App Layout</figcaption></figure><p id="733d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，看起来我们需要构建三个主要组件…</p><ol class=""><li id="aa2b" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mq mr ms mt bi translated">Header —这将在所有任务上方简单地显示一些消息。我要让我的显示列表中总共有多少任务。</li><li id="3548" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">TodoList —这是一个用于存放待办事项列表的容器。我们可能会为每个单独的行创建一个单独的“todo”组件，但我们会在到达那里时处理它。</li><li id="9df4" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">提交表单—这是用于向列表添加新待办事项的表单。</li></ol><p id="0f55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">需要注意一些事情:</p><p id="20ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将有一个包含一切的“应用程序”组件。我认为这使得所有的任务都存在于应用程序组件中，因为这些数据将决定几个子组件的外观。因此，我们的应用程序组件需要是一个基于类的组件，这样我们就可以在状态中存储所有的任务。</p><p id="caa4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我认为我们需要的另一个基于类的组件是SubmitForm组件。每当你有一个表单元素时，明智的做法是让它成为一个由<em class="mz">控制的</em>组件，这意味着数据是由React管理的，而不是DOM。当我们编写SubmitForm组件时，您将看到这是如何实现的。</p><p id="0849" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为这篇文章不是关于CSS的，所以我在这里包含了你需要的所有CSS:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="0065" class="nf lb iq nb b gy ng nh l ni nj">form {<br/>  display: flex;<br/>  padding: 10px;<br/>}<br/>.wrapper {<br/>  min-height: 100vh;<br/>  display: flex;<br/>  justify-content: center;<br/>  align-items: center;<br/>  background-image: url('data:image/svg+xml,%3Csvg ae md" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg" width="4" height="4" viewBox="0 0 4 4"%3E%3Cpath fill="%239C92AC" fill-opacity="0.4" d="M1 3h1v1H1V3zm2-2h1v1H3V1z"%3E%3C/path%3E%3C/svg%3E');<br/>}<br/>.input {<br/>  margin-right: 10px;<br/>}<br/>.frame {<br/>  width: 40vw;<br/>  max-width: 400px;<br/>}<br/>.header {<br/>  display: inline;<br/>  text-align: center;<br/>}<br/>.list-wrapper {<br/>  max-height: 200px;<br/>  overflow-y: auto;<br/>}</span></pre><p id="9260" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继续将它复制到CodePen项目的CSS面板中。</p><h1 id="0958" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">密码</h1><p id="c5db" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">好了，是时候开始写代码了！如果你在任何时候遇到困难，可以在这里随意查阅已经完成的应用:<a class="ae md" href="https://codepen.io/wilstaley/pen/KKwypJW" rel="noopener ugc nofollow" target="_blank">https://codepen.io/wilstaley/pen/KKwypJW</a></p><p id="d9a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们首先在CodePen的HTML面板中创建一个id为“root”的div。这将是我们需要编写的唯一html，因为react-dom库会将我们的react代码添加到这个HTML页面中。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b7fb28c703393303cbd985140c5b9e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*HA8STh7uLugmdV6EiVRFyw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Root Div that our React code will be added to</figcaption></figure><p id="a728" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，现在让我们跳到JavaScript面板，开始创建我们的应用程序组件。请记住，这是将所有todos保持在其状态的首要组件。它也将是我们创建的所有其他组件的父组件。</p><p id="3a34" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是首先，我们应该确保我们能在屏幕上显示一些东西。所以最初，我只是创建了最基本的基于类的组件。它只有一个返回单个div的render方法。然后我添加代码，使其呈现在我们的页面上。这是最初几个步骤之后的样子:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e417a97c0ebfd2b039e45ac8cac462ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*uHWmdZwxOAC-WoGk-GvIGw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Creating the App Component and Rendering it to the Page</figcaption></figure><p id="3452" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦你有了这些代码，你应该会看到“应用组件”出现在你的应用中(CodePen的底部面板)。如果看不到任何内容，请确保正确配置了CodePen设置，并且代码编写正确。</p><p id="d4d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以向我们的应用程序组件添加状态了！将以下代码添加到您的应用程序组件中render方法的上方:</p><p id="12e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no nb b">state = { tasks: ['task 1', 'task 2', 'task 3'] };</code></p><p id="9721" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个状态对象只包含一个项目，即tasks。Tasks是一个字符串数组，它是应用程序中todo项目的内容。当这个数组更新时，我们的应用程序应该重新呈现，以显示新的变化。</p><p id="d1a1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，这看起来不错…但我们不希望我们的应用程序只显示“应用程序组件”，所以让它呈现别的东西。</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="68af" class="nf lb iq nb b gy ng nh l ni nj">class App extends React.Component {<br/>  state = {<br/>    tasks: ['task 1', 'task 2', 'task 3']<br/>  };</span><span id="efa4" class="nf lb iq nb b gy np nh l ni nj">  render() {<br/>    return(<br/>       &lt;div className='wrapper'&gt;<br/>        &lt;div className='card frame'&gt;<br/>          &lt;Header /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="fe38" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里我们有两个外div。第一个有一个“包装器”类。这个div占据了整个页面，并确保todo列表水平居中和垂直居中。它还有一个花哨的圆点背景。这个的CSS在我一开始给你的代码里。第二个div有一个“card”和“frame”类。这些是布尔玛类，将为我们做一些造型。如果你想了解更多关于布尔玛的信息，你可以在这里阅读他们的文档:<a class="ae md" href="https://bulma.io/documentation/" rel="noopener ugc nofollow" target="_blank">https://bulma.io/documentation/</a></p><p id="65ad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这两个div中，我们有Header组件。但是我们实际上还没有创建这个！让我们现在做那件事。</p><p id="9f40" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Header组件只需要显示我们的todo列表的标题。但是因为我想让我的显示列表中有多少项，所以我将把这个数字作为道具传递给组件。标题组件将类似于以下内容:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="9b9d" class="nf lb iq nb b gy ng nh l ni nj">const Header = (props) =&gt; {<br/>  return(<br/>    &lt;div className='card-header'&gt;<br/>      &lt;h1 className='card-header-title header'&gt;<br/>        You have {props.numTodos} Todos<br/>      &lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="967e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里所有的类名都是由布尔玛提供的，用于设计头部的样式，无需编写CSS。</p><p id="6582" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这里，我们传入props来获取todos数量的引用。但是为了让它工作，我们需要将它添加到我们的应用程序组件内的标题组件中！返回到应用程序组件并更新标题，如下所示:</p><p id="7c1e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no nb b">&lt;Header numTodos={this.state.tasks.length} /&gt;</code></p><p id="deec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们不需要添加另一个状态变量来跟踪任务的数量，因为我们可以将数组的长度作为一个属性传入。现在我们应该看到待办事项列表的标题出现了！</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ce50d7e71060270efcfcc7361a79c46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*BZ-RV6TGbE_FDnRuFjR7Zw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Header Component</figcaption></figure><p id="ddd2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您手动向状态中的任务添加另一个字符串，您应该会看到标题中的数字相应地更新！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="221e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们构建TodoList组件。为了让TodoList能够访问所有的todos，我们将把任务作为道具传递。我们将把每个todo字符串提取到它自己的Todo组件中。为此，我们将使用地图功能:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="0e99" class="nf lb iq nb b gy ng nh l ni nj">const TodoList = (props) =&gt; {<br/>  const todos = props.tasks.map((todo, index) =&gt; {<br/>    return &lt;Todo content={todo} key={index} id={index} /&gt;<br/>  })<br/>  return( <br/>    &lt;div className='list-wrapper'&gt;<br/>      {todos}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="c90d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，我们使用map函数返回一个Todo组件数组。每当我们使用map函数时，React都希望我们为每个项目使用一个唯一的“key”属性。为了让每个todo都有一个惟一的键，我们在map函数中使用了index参数。我们还用它来创建一个id属性，我们将在从我们的状态中删除todos时使用它。</p><p id="13ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，很明显，因为我们正在使用一个虚构的“Todo”组件，所以我们需要创建它！</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="4bdd" class="nf lb iq nb b gy ng nh l ni nj">const Todo = (props) =&gt; {<br/>  return(<br/>    &lt;div className='list-item'&gt;<br/>      {props.content}<br/>      &lt;button class="delete is-pulled-right"&gt;&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="2730" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Todo道具非常简单。它显示作为道具传入的内容(或任务字符串)。它还有一个按钮，用于删除该任务。现在，我们需要做的就是将TodoList组件添加到我们的应用程序中，我们应该会看到我们的任务出现了！</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="0287" class="nf lb iq nb b gy ng nh l ni nj">&lt;Header numTodos={this.state.tasks.length}/&gt;<br/>&lt;TodoList tasks={this.state.tasks} /&gt;</span></pre><p id="4781" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不要忘记，我们需要传递任务数组作为道具！</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/af0bac2567ce0d4927ef11da06e9a31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*qdOsAIjCcpRDNiqkwf0rbA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">TodoList Component</figcaption></figure><p id="9e4b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们的应用程序中有了待办事项/任务列表……当然，移除按钮并不能真正移除任务。现在让我们添加该功能。为了从列表中删除一个项目，我们需要从状态中删除该项目的能力。让我们在应用程序组件中编写一个函数，它将处理从任务数组中删除元素的操作:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="466e" class="nf lb iq nb b gy ng nh l ni nj">handleDelete = (index) =&gt; {<br/>    const newArr = [...this.state.tasks];<br/>    newArr.splice(index, 1);<br/>    this.setState({tasks: newArr});<br/>}</span></pre><p id="25a1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个函数复制状态数组，删除给定索引的元素，并更新状态。因此，无论何时调用这个函数，应用程序都会重新呈现，因为我们更新了状态。</p><p id="6804" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了让我们的Todo组件能够访问这个函数，我们现在需要将它作为一个prop传递下去。因此，更新应用程序组件，使用新的道具来呈现TodoList，如下所示:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="353c" class="nf lb iq nb b gy ng nh l ni nj">&lt;Header numTodos={this.state.tasks.length} /&gt;<br/>&lt;TodoList tasks={this.state.tasks} onDelete={this.handleDelete} /&gt;</span></pre><p id="e59c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后当我们映射到Todo组件时，将它添加为一个道具…</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="a125" class="nf lb iq nb b gy ng nh l ni nj">const todos = props.tasks.map((todo, index) =&gt; {<br/>    return &lt;Todo content={todo} key={index} id={index} onDelete={props.onDelete} /&gt;<br/>})</span></pre><p id="8028" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，在Todo组件中，我们可以添加一个onClick处理程序，每当按下delete按钮时，它都会触发这个函数:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="a291" class="nf lb iq nb b gy ng nh l ni nj">&lt;button class="delete is-pulled-right" onClick={() =&gt; {props.onDelete(props.id)}}&gt;&lt;/button&gt;</span></pre><p id="559c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意，我们将该todo的id作为参数传递给delete函数。这是用于从数组中移除该项的索引。现在，每当我们单击删除按钮时，应该会调用handleDelete函数，应用程序应该会重新呈现。我们现在可以从列表中删除todos了！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="71be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们可以创建SubmitForm组件并包装它。我们将从制作一个简单的基于类的组件开始，该组件呈现文本输入和提交按钮:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="7a2c" class="nf lb iq nb b gy ng nh l ni nj">class SubmitForm extends React.Component {<br/>  render() {<br/>    return(<br/>      &lt;form&gt;<br/>        &lt;input <br/>          type='text'<br/>          className='input'<br/>          placeholder='Enter Item'<br/>        /&gt;<br/>        &lt;button className='button'&gt;Submit&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="0b53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还记得我提到的让它成为“受控”组件的事情吗？下面是我们如何修改该组件，使其输入由React管理:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="ef5a" class="nf lb iq nb b gy ng nh l ni nj">class SubmitForm extends React.Component {<br/>  state = { term: '' };</span><span id="df17" class="nf lb iq nb b gy np nh l ni nj">  render() {<br/>    return(<br/>      &lt;form&gt;<br/>        &lt;input <br/>          type='text'<br/>          className='input'<br/>          placeholder='Enter Item'<br/>          value={this.state.term}<br/>          onChange={(e) =&gt; this.setState({term: e.target.value})}<br/>        /&gt;<br/>        &lt;button className='button'&gt;Submit&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="8841" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们用“term”键添加状态。这个“术语”代表文本输入字段中的文本。现在我们将输入的值属性设置为这个术语。所以每当状态改变时，输入字段的值实际上是由React控制的。最后一步只是添加一个onChange处理程序，每当我们键入文本输入时，它都会更新状态。</p><p id="85ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">瞧啊。我们现在有一个受控的输入。最后一步是将用户输入的内容添加到我们的待办事项列表中…</p><p id="f9b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，就像我们在App组件中添加了一个处理删除的函数一样，现在让我们添加一个处理添加的函数:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="7f4a" class="nf lb iq nb b gy ng nh l ni nj">handleSubmit = task =&gt; {<br/>    this.setState({tasks: [...this.state.tasks, task]});<br/>}</span></pre><p id="c56f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个函数只是将旧任务数组的内容复制到一个新数组中，并添加新任务。</p><p id="e834" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，如果我们的SubmitForm组件要使用这个函数，它需要作为一个道具传递下去。因此，现在是在App中添加SubmitForm组件的最佳时机:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="fc05" class="nf lb iq nb b gy ng nh l ni nj">&lt;Header numTodos={this.state.tasks.length} /&gt;<br/>&lt;TodoList tasks={this.state.tasks} onDelete={this.handleDelete} /&gt;<br/>&lt;SubmitForm onFormSubmit={this.handleSubmit} /&gt;</span></pre><p id="2dba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们将在SubmitForm组件中添加一个事件处理程序，用于当用户实际按下submit按钮或enter键时:</p><pre class="mf mg mh mi gt na nb nc nd aw ne bi"><span id="d6c5" class="nf lb iq nb b gy ng nh l ni nj">class SubmitForm extends React.Component {<br/>  state = { term: '' };</span><span id="1e92" class="nf lb iq nb b gy np nh l ni nj">  handleSubmit = (e) =&gt; {<br/>    e.preventDefault();<br/>    if(this.state.term === '') return;<br/>    this.props.onFormSubmit(this.state.term);<br/>    this.setState({ term: '' });<br/>  }</span><span id="1c7f" class="nf lb iq nb b gy np nh l ni nj">  render() {<br/>    return(<br/>      &lt;form onSubmit={this.handleSubmit}&gt;<br/>        &lt;input <br/>          type='text'<br/>          className='input'<br/>          placeholder='Enter Item'<br/>          value={this.state.term}<br/>          onChange={(e) =&gt; this.setState({term: e.target.value})}<br/>        /&gt;<br/>        &lt;button className='button'&gt;Submit&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="7e9b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们稍微分解一下。首先，我们向表单元素添加了一个onSubmit侦听器。每当用户按下提交按钮或按下回车键时，这将调用组件的' handleSubmit '函数。在handleSubmit函数中，首先我们有<code class="fe nm nn no nb b">e.preventDefault();</code>。这只是防止页面在提交表单时自动刷新。然后，我们检查输入字段中是否有任何文本。如果它是空的，我们什么也不做，从这个函数返回。否则，我们调用作为道具传递的函数，该函数实际上将todo项添加到我们的应用程序的状态中。最后，我们将输入的文本重置为空字符串，从而清空字段。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="52a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">恭喜你！现在你有了一个全功能的应用程序，可以添加和删除列表中的待办事项。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa176e2baa6c4fcc884616187abe76cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPjPhc2gYkTplzF_DH-g5Q.png"/></div></div></figure><p id="f7f7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望你喜欢这个教程。如果你想看到更多这样的教程，请考虑成为www.patreon.com/wilstaley T2的赞助人</p><p id="b474" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谢谢！</p></div></div>    
</body>
</html>