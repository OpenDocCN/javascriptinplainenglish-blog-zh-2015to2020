<html>
<head>
<title>All About React Hooks — useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有关于反应钩子-使用效果</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/all-about-react-hooks-useeffect-b02b7e8d7b5a?source=collection_archive---------6-----------------------#2020-11-01">https://javascript.plainenglish.io/all-about-react-hooks-useeffect-b02b7e8d7b5a?source=collection_archive---------6-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/59edf846320e4f5de5df1f50237c4416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOJBOVtz1KIAlMh-HihgfA.jpeg"/></div></div></figure><p id="8744" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子是在<a class="ae kw" href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" rel="noopener ugc nofollow" target="_blank"> React 16.8 </a>版本中新加入的。它们允许您使用状态和其他React特性，而无需编写类组件。</p><blockquote class="kx"><p id="2672" class="ky kz iq bd la lb lc ld le lf lg kv dk translated">useEffect挂钩允许您在函数组件中执行副作用</p></blockquote><p id="4415" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">使用效果挂钩是万能的👑钩子的形状。是<code class="fe lm ln lo lp b">componentDidMount</code>、<code class="fe lm ln lo lp b">componentDidUpdate</code>和<code class="fe lm ln lo lp b">componentWillUnmount</code>的组合。它用于在组件挂载时获取数据，在状态或属性改变时执行数据，在组件卸载时清理数据。这个useEffect挂钩可能真的令人困惑💡直到你理解或知道它是如何工作的。</p><p id="2ff6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将用代码片段解释<code class="fe lm ln lo lp b">useEffect</code>挂钩，这样您就可以理解useEffect是如何工作的。</p><h1 id="7fcb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">像componentDidMount一样运行一次</h1><p id="0a8c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">默认情况下，useEffect钩子在组件的每次渲染后运行，为了只在挂载时运行useEffect，传递一个空数组<code class="fe lm ln lo lp b">[]</code>作为第二个参数。useEffect需要一个<em class="mt">依赖</em>来重新渲染，这里我们声明这个useEffect没有任何<em class="mt">依赖</em>来重新渲染。所以它只渲染一次。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="cc10" class="nc lr iq lp b gy nd ne l nf ng">useEffect(() =&gt; {<br/> // Your code here<br/>}, []);</span></pre><h1 id="d8e5" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">关于道具/状态的变化</h1><p id="9773" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">默认情况下，useEffect钩子在每次渲染后运行，您也可以通过将props或state变量作为第二个参数传递来控制何时重新渲染，第二个参数是一个依赖关系数组，如果依赖关系数组中的任何变量发生变化，useEffect钩子将运行。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="b167" class="nc lr iq lp b gy nd ne l nf ng">useEffect(() =&gt; {<br/> // Your code here<br/>}, [variableName]);</span></pre><h1 id="f083" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">每次渲染后</h1><p id="fc8d" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">useEffect钩子在每次渲染后运行，如果你简单地忽略第二个参数，它将完成这项工作🙃</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="1ee1" class="nc lr iq lp b gy nd ne l nf ng">useEffect(() =&gt; {<br/> // Your code here<br/>});</span></pre><h1 id="0243" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">卸载时</h1><p id="add8" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">要执行卸载组件的操作，</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="647c" class="nc lr iq lp b gy nd ne l nf ng">useEffect(() =&gt; {<br/>  return () =&gt; {<br/>   // unmount code here<br/>  }<br/>});</span></pre><p id="22ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将放在<code class="fe lm ln lo lp b">return () ⇒ { }</code>块中的代码将在卸载之前执行。卸载功能不只是在卸载组件时执行。它在每次useEffect运行之前执行，从最后一次渲染开始清理。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/f4d98cb97821b4e2da91401647c9aba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_c6VGlBytl3GzjScINnV-w.jpeg"/></div></div></figure><p id="d3b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考</p><ol class=""><li id="cc99" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated"><a class="ae kw" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-intro.html</a></li></ol></div></div>    
</body>
</html>