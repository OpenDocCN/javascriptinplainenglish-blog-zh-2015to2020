<html>
<head>
<title>I tested a React app with Jest, Enzyme, Testing Library and Cypress. Here are the differences.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用Jest，Enzyme，Testing Library和Cypress测试了一个React app。以下是不同之处。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-tested-a-react-app-with-jest-testing-library-and-cypress-here-are-the-differences-3192eae03850?source=collection_archive---------0-----------------------#2019-10-24">https://javascript.plainenglish.io/i-tested-a-react-app-with-jest-testing-library-and-cypress-here-are-the-differences-3192eae03850?source=collection_archive---------0-----------------------#2019-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4da2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最后，对最流行的React测试工具进行并行代码比较。请看我们试图用Jest、Enzyme、Testing Library和Cypress编写完全相同的测试。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/360ac863fabbff821155c6a7cafcffb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mOptOjq8fY-ruFFd_B3nA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Jest vs Testing Library vs Cypress: The results of the tests are in!</figcaption></figure><h2 id="2172" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">您可能知道知道如何测试您的代码很重要。</h2><p id="8703" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">许多技术领域的工作需要至少一个测试工具/框架/库的测试知识。</p><p id="aace" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">在这里，我们将向您展示如何使用三种不同的工具编写测试，这样您不仅可以看到它们之间的差异，还可以开始理解如何使用每种工具编写测试，并形成您自己的观点，在某些情况下哪种工具可能比另一种工具更好。</p><p id="11fb" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们将从我以前的一篇文章中选取React To Do应用程序— <a class="ae mp" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56" rel="noopener"> <strong class="lt ir">我在React和Vue中创建了完全相同的应用程序。下面是不同之处</strong></a><strong class="lt ir"/>——并将使用<strong class="lt ir"> Jest、</strong>测试其所有核心功能，这是由脸书(他也创建了React)创建的测试工具、<strong class="lt ir">测试库</strong>(以前的React测试库)，这是React文档中实际推荐使用的工具，以及<strong class="lt ir"> Cypress </strong>，这是一个e2e测试工具(稍后将详细介绍这意味着什么)。</p><p id="16d8" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><em class="mq">注意:你通常会听到这些测试工具被称为测试库，但是我想试着明确区分测试库和</em> <strong class="lt ir"> <em class="mq">测试库</em> </strong> <em class="mq">。因此，当我们提到小写的测试库时，我们称它为测试工具。</em></p><h2 id="fdc2" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是玩笑？</h2><p id="3d5b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">根据他们的网站，<em class="mq">“Jest是一个JavaScript测试框架，旨在确保任何JavaScript代码库的正确性。它允许你用一个平易近人的、熟悉的、功能丰富的API来编写测试，并快速给出结果。Jest有很好的文档记录，需要很少的配置，并且可以扩展以满足您的需求。”</em></p><p id="0e72" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在，为了用Jest进行测试，我们还选择了一个叫做Enzyme的工具。根据他们网站的说法，Enzyme是一个<em class="mq">“React的JavaScript测试工具，可以更容易地测试React组件的输出”</em>。所以在这里，我们使用它来呈现我们的应用程序及其组件，以便Jest可以在上面运行测试。Enzyme还为我们提供了在测试中模拟事件的能力，比如点击和输入等等。Jest和Enzyme一起使用是很常见的，所以我决定在这里做同样的事情，以便为您提供更广泛的工具。</p><h2 id="6588" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是测试库？</h2><p id="71e6" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">根据他们的网站，“Testing Library系列库是一个非常轻量级的测试解决方案，不需要所有的实现细节。它提供的主要实用工具包括查询节点，类似于用户查找节点的方式。通过这种方式，testing-library有助于确保您的测试让您对UI代码充满信心。”他们的哲学是“<em class="mq">你的测试越像你的软件被使用的方式，他们就能给你越多的信心”。</em></p><h2 id="1883" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">柏树是什么？</h2><p id="68ab" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">根据他们的网站，Cypress是一个端到端(e2e)“为人类建造的测试运行程序”，测试“易于阅读和理解”，可以在你的浏览器中运行，“以你的浏览器可以呈现的速度运行”。最后，Cypress提供了“可读的错误消息，帮助你快速调试”。你可能已经注意到了，我从网站上找不到很好的文本，但是我不得不从他们的页面上挑选句子。</p><h2 id="8559" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">两者有什么区别？</h2><p id="f325" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我在这里应该提到的一个关键区别是Jest和测试库通常是您可能会提到的单元测试和集成测试库，而Cypress通常用于端到端(e2e)测试。这意味着您将从头到尾测试您的应用程序，就好像您是一个使用您的应用程序的用户一样(包括所有的点击和页面导航等等)。</p><p id="4648" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这并不是说你不能为e2e使用Jest和测试库，或者你不能为单元和/或集成测试使用Cypress。您甚至会发现，您决定采用一种混合的方法，并且在您的测试中使用不止一种工具。当谈到你认为什么是最好的解决方案时，这真的取决于你。</p><h2 id="d671" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在我们查看测试之前，让我们快速回顾一下我们的React To Do应用程序，并列出我们将测试的所有功能。</h2><p id="e015" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们有三个文件:<strong class="lt ir"> App.js </strong>、<strong class="lt ir"> ToDo.js、</strong>和<strong class="lt ir"> ToDoItem.js </strong>。</p><p id="a1c7" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><strong class="lt ir"> App.js </strong>只是我们的根组件，它呈现了我们的<strong class="lt ir"> ToDo.js </strong>。<strong class="lt ir"> ToDo.js </strong>是我们的主文件，处理我们所有的应用程序逻辑——把它想象成我们的待办事项应用程序的大脑。默认情况下，我们的待办事项应用有两项。这些被映射到<strong class="lt ir"> ToDoItem.js </strong>，这意味着我们最终在<strong class="lt ir"> ToDo </strong>组件中呈现了两个<strong class="lt ir"> ToDoItem </strong>。</p><p id="382d" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">如果你对检查代码感兴趣，这里有一个没有测试的回购链接:<a class="ae mp" href="https://github.com/sunil-sandhu/react-todo-2019" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/react-todo-2019</a>。</p><h2 id="635e" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我们将测试什么？</h2><p id="382b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们将测试我们的应用程序是否能够做到以下几点:</p><ol class=""><li id="10d7" class="mr ms iq lt b lu mk lx ml le mt li mu lm mv mj mw mx my mz bi translated">不崩溃地渲染</li><li id="e7c7" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">呈现两个默认待办事项</li><li id="2421" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">呈现用于键入新待办事项的输入字段</li><li id="0c56" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">呈现用于添加待办事项的“添加”按钮</li><li id="696b" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">如果按下“添加”按钮，但输入字段为空，则阻止创建新的待办事项</li><li id="211d" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">如果按下“添加”按钮，但输入字段为空，则向用户显示警告</li><li id="4c4b" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">如果按下“添加”按钮并且输入字段有内容，则添加新的待办事项</li><li id="008d" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">当按下单个待办事项的“删除”按钮时，从应用程序中删除该待办事项</li><li id="746c" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">在ToDo的两个默认项目中，如果第一个ToDo项目已经从应用程序中删除，第二个项目现在应该成为第一个(也是唯一的)项目。</li><li id="dfd3" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">对于作为道具从ToDo传递到ToDoItem的数据，每个ToDoItem都应该呈现传递给它的文本。</li><li id="8ad8" class="mr ms iq lt b lu na lx nb le nc li nd lm ne mj mw mx my mz bi translated">每个ToDoItem应呈现一个“删除”按钮。</li></ol><p id="130f" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">对于一个相当简单的应用程序，我们至少要进行11次测试。这应该给我们一个很好的介绍，让我们了解每个测试工具，看看他们如何处理这些。让我们快速看一下这三个应用程序的文件结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/b6b2305fce92c38e57d189690bdc236d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YiGr0ZqIr6SGpZxLUbea0g.png"/></div></div></figure><p id="0cf7" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我想指出的一点是，我们已经使用创建-反应-应用程序(CRA)来引导我们的反应应用程序。这意味着它默认安装了Jest。我们不会把它从我们的设置中删除，因为Jest实际上在更多的地方会派上用场，而不仅仅是在Jest设置中。当然，如果你愿意，你可以把它完全去掉。</p><h1 id="f012" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">玩笑</h1><p id="ae75" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">让我们再来看看我们的文件结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b551a61d16412bf543d44e5b76495475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*ikJUGlsxkXmI0pfiS3UQRA.png"/></div></figure><p id="dfe7" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们在这里可以看到，我们的Jest设置中有三个测试文件:<strong class="lt ir"> App.test.js </strong>、<strong class="lt ir"> ToDo.test.js </strong>和<strong class="lt ir"> ToDoItem.test.js </strong>。现在我想注意的第一件事是把这些文件放在它们的<strong class="lt ir">旁边。js </strong>同行没必要。如果我们愿意，我们可以把这些都放在一个名为<strong class="lt ir"> Tests </strong>的文件夹中。这是因为<strong class="lt ir"> create-react-app </strong>设置为自动搜索文件名中包含<strong class="lt ir"> .test.js </strong>的任何文件，因此它们可以放在任何地方。对于如何命名和放置它们，还有其他的选择，但是我们在这里不再深入讨论。这同样适用于<strong class="lt ir">测试库</strong>和<strong class="lt ir"> Cypress </strong>设置。</p><p id="8dd5" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">无论如何，让我们来看看我们的一个Jest测试，这样您就可以预览语法是什么样子了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/5a08334a537d711b1d356b6fce20143c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUKjcRr9Oh2y8fwk-eJt2A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App.test.js, tested with Jest</figcaption></figure><p id="8141" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">稍后我们将详细讨论这一切意味着什么。</p><p id="d51d" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在，如果你回头看看我们之前附上的显示Jest应用程序的文件夹/文件结构的截图，你可能会记得在<strong class="lt ir"> src </strong>文件夹中看到一个名为<strong class="lt ir"> setupTests.js </strong>的文件。让我们花点时间解释一下这个文件的用途。</p><h2 id="7f81" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">setupTests.js</h2><p id="fa6f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">这个文件基本上是向我们的测试环境发出信号，要求在任何<strong class="lt ir">测试</strong>文件中包含这个代码。这个设置是不必要的，因为我们可以将它添加到每个<strong class="lt ir">测试</strong>文件中。然而，本着保持代码干燥的精神，我们选择创建这个文件。需要注意的一点是，我们不必告诉我们的应用程序去获取这个文件，因为<strong class="lt ir"> create-react-app </strong>已经有了一个内部设置，可以在<strong class="lt ir"> src </strong>目录中查找这个文件。在我们的例子中，我们只需创建文件并添加以下代码行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/00bc382cf08b7221c1acbc6591ca34b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZaW5wjnKVh_oa-m2G3WkQ.png"/></div></div></figure><p id="060e" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这基本上引入了酶和一个适配器，使酶可以与最新版本的React一起使用。然后我们通过添加<code class="fe nu nv nw nx b">Enzyme.configure</code>函数来设置它。这不是我自己创造的东西，而是从酶网站上的文档中获得的。</p><h1 id="3c26" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">测试库</h1><p id="320f" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">让我们再看一下我们的文件结构，然后我们将进入每个文件并回顾正在发生的事情:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/bb818216f2ed40447274efea44c849a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bUF-_2NQp3NiR8iqUTkFZg.png"/></div></figure><p id="1560" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">对于测试库，您可以看到我们有与Jest完全相同的文件结构。这意味着我们有三个测试文件，<strong class="lt ir"> App.test.js </strong>、<strong class="lt ir"> ToDo.test.js </strong>和<strong class="lt ir"> ToDoItem.test.js </strong>。</p><p id="f764" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">和Jest一样，让我们看一下我们的一个测试库测试文件，这样您就可以预览语法的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/30ea8b9e2823354ebd38c8f3ff6f00d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KFnZ2FBKNO5F8WNRJ9E6w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App.test.js, tested with Testing Library</figcaption></figure><p id="7152" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">和Jest一样，我也无法在这些截图中包含所有的测试，因为有些文件有很多行。但是我想在这里展示的是这些文本中使用的语言(或者说是语法)。</p><p id="b6ac" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在你可能会注意到，测试库的设置与Jest非常相似。在测试库的情况下，它实际上使用并扩展了Jest的<code class="fe nu nv nw nx b">expect()</code>断言的功能。</p><p id="aea3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我想指出的是，虽然我们已经允许测试库在我们的设置中包含Jest的部分，但你不必使用Jest测试库。我们选择它是因为我们的<strong class="lt ir"> create-react-app </strong>已经默认捆绑了Jest。</p><p id="6672" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们还使用了一个<strong class="lt ir"> setupTests.js </strong>文件。这个文件的目的与Jest相同，但是让我们花一点时间来解释一下我们在这个文件中包含了什么。</p><h2 id="cf2c" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">setuptests.js</h2><p id="a108" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">正如我们的Jest设置一样，我们选择通过创建这个文件来保持代码尽可能的干燥。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/4ad87d672928c7c186f47e25ac9cf4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaeQA8TA8cFk5T8JwfF0Sg.png"/></div></div></figure><p id="8fcf" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">如您所见，它只有一行代码，从测试库包中导入一个模块，扩展了<code class="fe nu nv nw nx b">expect</code>断言的功能。这使得我们能够使用像<code class="fe nu nv nw nx b">toBeInTheDocument()</code>这样的东西作为我们断言的一部分。</p><p id="0ec3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这符合测试库的测试方法，即模拟用户如何使用你的应用程序/网站。用户并不关心一个应用程序/网站是如何实现的，而是关心它是否做了它应该做的事情。因此，如果我们使用我们提到的最后一个断言，用户会关心某些元素是否出现在页面上。如果元素意味着"<em class="mq">在文档"</em>中，我们用<code class="fe nu nv nw nx b">toBeInTheDocument</code>进行测试。</p><p id="f88f" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">你会从测试库中的测试文件中看到，我们正在从<code class="fe nu nv nw nx b">”@testing-library/react”</code>导入一个<code class="fe nu nv nw nx b">render</code>函数。这基本上相当于我们在Jest + Enzyme设置中使用了<code class="fe nu nv nw nx b">mount</code>函数。</p><p id="6e7a" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">Jest和Testing Library的一个关键区别在于，Testing Library的查询标准基于必须添加到组件元素中的<code class="fe nu nv nw nx b">data</code>标签。例如，如果我想获取一个特定的input元素，我不会通过寻找一个<code class="fe nu nv nw nx b">input</code>元素来获取它，或者甚至是我们的<code class="fe nu nv nw nx b">input</code>元素正在使用的一个特定的类。相反，我们会给我们的<code class="fe nu nv nw nx b">input</code>元素添加一个<code class="fe nu nv nw nx b">data-testid</code>标签。然后它看起来像这样:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="32d1" class="kv kw iq nx b gy of og l oh oi">&lt;input<br/><strong class="nx ir">data-testid=”todo-input”<br/></strong>type=”text”<br/>value={toDo}<br/>onChange={handleInput}<br/>onKeyPress={handleKeyPress}<br/>/&gt;</span></pre><p id="fc8f" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">然后在我们的<strong class="lt ir"> ToDo.test.js </strong>文件中，我们将通过编写<code class="fe nu nv nw nx b">getByTestId(“todo-input”)</code>来查询它。</p><p id="ade5" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">测试库遵循由<code class="fe nu nv nw nx b">data-testid</code>查询的哲学的原因是因为这些id在应用程序的生命周期中通常不会改变，因此，您的测试不会因为某个类名的改变而变得脆弱和容易被破坏。现在，我们实际上可以通过添加<code class="fe nu nv nw nx b">data-testid</code>并通过它们进行查询来遵循Jest中相同类型的模式。如果我们这样做，我们的测试可能看起来像这样:</p><p id="f7cc" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><code class="fe nu nv nw nx b">app.find(“[data-testid=’ToDoInput’]”)</code></p><p id="4613" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">公平地说，如果使用任何测试工具，这很可能是一个鼓励采用的模式，因为<code class="fe nu nv nw nx b">data-testid</code>属性比css <code class="fe nu nv nw nx b">className</code>更不容易改变。所以，如果你用Jest或者其他工具编写测试，请记住这一点。现在我们将继续通过对html元素或类进行分类来测试Jest(和Cypress ),但是请注意，根据数据属性抓取是更好的实践。</p><h1 id="f5bd" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">柏树</h1><p id="8c05" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">让我们再看一下我们的文件结构，然后我们将进入每个文件并回顾正在发生的事情:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/28fda981d2832591275508f8c7bb0d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*B9KBHJMBcVD2qKu4Sse4zA.png"/></div></figure><p id="0747" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">Cypress和其他两个测试工具的最大区别是Cypress有自己的文件夹来处理测试文件。因此，我们没有单独的<strong class="lt ir"> test.js </strong>文件用于App、ToDo和ToDoItem，而是有一个文件<strong class="lt ir"> App.test.js </strong>，它位于<strong class="lt ir"> integration </strong>文件夹中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c7b07d8a8fadb55acf486341445bf219.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*t3038farIRzQs6eta8T-eg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">cypress/integration/App.test.js</figcaption></figure><p id="5f37" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">因为Cypress用于端到端(e2e)测试，所以我们在设置中只需要一个文件。这是因为Cypress有效地打开了一个浏览器并运行了所有需要的测试。我们可以用三个独立的文件来完成这个任务，但是这意味着我们必须运行三个独立的e2e测试。这仍然可行，但不是最佳的方法。</p><p id="af14" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><em class="mq">注意:Cypress提供了其他功能，比如一个</em><strong class="lt ir"><em class="mq">fixtures</em></strong><em class="mq">文件夹，它将是我们存储模拟数据的地方。我们也可以选择在</em> <strong class="lt ir"> <em class="mq">支持</em> </strong> <em class="mq">文件夹中扩展Cypress的功能。我们的测试不需要这些，所以我们不会在这里讨论它们。</em></p><p id="fa60" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">与Jest和测试库一样，让我们看一下我们的Cypress测试文件，这样您就可以预览语法的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/ecab1276380b4fa7f28404c95848157f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76zfNicNbYFJUEGjxnGxiw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App.test.js, tested with Cypress</figcaption></figure><p id="881a" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">注意:与Jest和Cypress相比，我们在这里展示了更多的预览。这不是故意的。这仅仅是因为我们将所有的测试都放在一个文件中，所以截图最终显示了更多的测试结果。</p><h2 id="d786" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我们所有的测试都使用了<code class="fe nu nv nw nx b">describe()</code>块和it()函数</h2><p id="b9df" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">你会从我们所有例子的测试中注意到一个相似之处，那就是它们都遵循相同的模式，每个测试都有一个包含一些<code class="fe nu nv nw nx b">it()</code>语句的<code class="fe nu nv nw nx b">describe()</code>块。还有其他方法来构建这些，比如使用<code class="fe nu nv nw nx b">test()</code>而不是<code class="fe nu nv nw nx b">it()</code>，但是我们选择了这种方法，因为它通常是最常见的，这意味着我们可以更好地构建我们的测试，使它们看起来尽可能地相似。</p><h2 id="1fd1" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">总之，到目前为止，我们已经讨论了很多东西，我们还没有真正地并排回顾测试。</h2><p id="ab58" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">因此，让我们一步一步地了解我们想要测试的每个标准，看看每个测试工具是如何处理它的。</p><h1 id="c959" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">1.渲染时不崩溃。</h1><p id="cfe5" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">这通常被称为“冒烟测试”,我们只是确保我们的应用程序不会抛出错误，并且实际上按照预期加载。在这种情况下，您可能会看到人们检查我们的组件是否返回长度1。我真的不喜欢那些考试，因为它们不够有表现力。因此，我选择检查我们的待办事项应用程序的标题标签是否已经呈现。</p><h2 id="8038" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">玩笑</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="67fd" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里我们创建了一个名为<code class="fe nu nv nw nx b">app</code>的变量，并将其设置为<code class="fe nu nv nw nx b">mount()</code>函数，该函数接收导入到同一个文件中的<code class="fe nu nv nw nx b">App</code>组件。请注意，我们通过将组件作为<code class="fe nu nv nw nx b">&lt;App/&gt;</code>传入，将组件作为React组件传入。</p><p id="c07c" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">然后我们在Jest中使用<code class="fe nu nv nw nx b">find()</code>函数，它的工作方式与JavaScript中的<code class="fe nu nv nw nx b">querySelector</code>基本相同。但是我们没有写像<code class="fe nu nv nw nx b">document.querySelector</code>这样的东西，而是写了<code class="fe nu nv nw nx b">app.find</code>，因为<code class="fe nu nv nw nx b">app</code>已经被分配给了我们的<code class="fe nu nv nw nx b">&lt;App/&gt;</code>组件。您会注意到，我们将<code class="fe nu nv nw nx b">text()</code>链接到它上面，它基本上从该元素返回文本。最后，我们检查它是否等于<code class="fe nu nv nw nx b">"React To Do”</code>。这是区分大小写的，所以在我们的例子中，每个单词的大写字母的使用是至关重要的，因为这就是我们的待办事项应用程序。</p><h2 id="3269" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">测试库</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4a85" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里我们使用对象析构从我们的<code class="fe nu nv nw nx b">render()</code>函数中捕获<code class="fe nu nv nw nx b">getByText</code>的值，它已经被导入到文件中。这类似于Jest中使用的<code class="fe nu nv nw nx b">mount()</code>函数。还有许多其他的值出现在<code class="fe nu nv nw nx b">render()</code>函数中，但是对于这个测试，我们只需要<code class="fe nu nv nw nx b">getByText</code>值。这基本上是从我们用来搜索的任何东西中抓取所有文本，在这个例子中，是我们的应用程序组件。</p><p id="3e9d" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">和Jest一样，我们已经导入了我们的<code class="fe nu nv nw nx b">App</code>组件，然后用尖括号将它传递给我们的<code class="fe nu nv nw nx b">render()</code>函数，这意味着<code class="fe nu nv nw nx b">App</code>是作为<code class="fe nu nv nw nx b">&lt;App/&gt;</code>传递的。在上面代码片段的第4行，你会看到我们将<code class="fe nu nv nw nx b">"React To Do"</code>作为<code class="fe nu nv nw nx b">getByText()</code>函数的参数传入。</p><p id="40b7" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">最后，我们链接到它上面，<code class="fe nu nv nw nx b">toBeInTheDocument()</code>。正如您可能已经猜到的，这将检查传入的值是否存在于文档中。</p><h2 id="2627" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">柏树</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0697" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里我们从输入<code class="fe nu nv nw nx b">cy</code>开始，这有点类似于在jQuery中使用<code class="fe nu nv nw nx b">$</code>美元符号。在赛普拉斯，我们从<code class="fe nu nv nw nx b">cy</code>开始所有的测试。然后我们使用<code class="fe nu nv nw nx b">get()</code>，这类似于在JavaScript中使用<code class="fe nu nv nw nx b">querySelector</code>。然后我们链接到它上面<code class="fe nu nv nw nx b">contains()</code>，它接受一个参数。然后检查<code class="fe nu nv nw nx b">h1</code>是否包含我们传入的参数— <code class="fe nu nv nw nx b">"React To Do"</code> —在本例中是<code class="fe nu nv nw nx b">React To Do</code>。</p><p id="2635" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">您可能还注意到，我们在顶部有一个<code class="fe nu nv nw nx b">before()</code>函数，它基本上指示Cypress在运行任何测试之前先做这件事。<strong class="lt ir"> App.test.js </strong>内的所有其他测试都位于主<code class="fe nu nv nw nx b">describe()</code>程序块内的<code class="fe nu nv nw nx b">describe()</code>程序块内。在一个文件中有多个<code class="fe nu nv nw nx b">describe()</code>块并不是必需的——这实际上取决于您选择的测试的表达方式。</p><p id="2585" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">无论如何，我们实际上有一个根<code class="fe nu nv nw nx b">describe()</code>块，然后在它里面有更多的<code class="fe nu nv nw nx b">describe()</code>块。由于这种设置，我们在根<code class="fe nu nv nw nx b">describe()</code>块中只需要一个<code class="fe nu nv nw nx b">before()</code>函数。</p><p id="8ca5" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">关于Cypress另一件值得注意的事情是，因为我们正在测试一个我们正在本地开发的应用程序，它还没有编译。我们必须通过运行<code class="fe nu nv nw nx b">yarn start</code> / <code class="fe nu nv nw nx b">npm run start</code>来启动<strong class="lt ir"> create-react-app </strong>的服务器。这必须在运行任何测试之前首先完成，否则Cypress将尝试访问<strong class="lt ir"> localhost:3000 </strong>并且那里什么也没有。</p><p id="084e" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们本可以在代码中添加另一个步骤，让Cypress为我们处理这个问题，但是在本文中我们选择了反对。</p><h1 id="87aa" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">2–4.呈现两个默认ToDo项；呈现用于键入新待办事项的输入字段；呈现用于添加待办事项的“添加”按钮。</h1><h2 id="5eec" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">玩笑</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Jest</figcaption></figure><p id="bb45" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里我们使用了与之前类似的功能，但是使用了<code class="fe nu nv nw nx b">length</code>来检查这里的长度。这与JavaScript中检查数组长度的方式相同。你会注意到我们在第一次测试中使用了<code class="fe nu nv nw nx b">toBe</code>，但是在第二次和第三次测试中使用了<code class="fe nu nv nw nx b">toEqual</code>。</p><p id="baa3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">通常对于我们上面使用的例子，我们只需要使用严格相等的<code class="fe nu nv nw nx b">===</code>来检查<code class="fe nu nv nw nx b">toBe</code>就可以了。因为我们处理的是原语，所以这应该没问题。当我们想要检查像对象这样的东西的深度相等时，我们通常会使用<code class="fe nu nv nw nx b">toEqual</code>。在这里，我选择使用两者，这样您就可以知道两者都存在——并且两者都仍然可以处理数字和字符串等原语。</p><p id="31f3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><strong class="lt ir">测试库</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Testing Library</figcaption></figure><p id="c820" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">您在这里可以看到，我们的第一组测试与前面的测试库示例中使用的测试非常相似。然而，在第二次和第三次测试中，你会看到我们使用了一个<code class="fe nu nv nw nx b">getByTestId</code>变量。这就是我们开始使用测试库最佳实践的地方，即将<code class="fe nu nv nw nx b">data-testid</code>属性附加到我们计划测试的应用程序中的所有元素上。因此，在这些例子中，我们的应用程序中的元素看起来像这样:<code class="fe nu nv nw nx b">&lt;input data-testid=”todo-input”/&gt;</code>和<code class="fe nu nv nw nx b">&lt;button data-testid=”add”/&gt;</code>。</p><p id="ec89" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们的<code class="fe nu nv nw nx b">getByTestId</code>也是这样工作的，所以基本上就是一个<code class="fe nu nv nw nx b">querySelector</code>。正如你所看到的，我们用和前面例子一样的方式使用<code class="fe nu nv nw nx b">toBeInTheDocument()</code>。</p><h2 id="d656" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">柏树</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Cypress</figcaption></figure><p id="007c" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里你会看到我们从<code class="fe nu nv nw nx b">cy.get()</code>开始每个测试，这和我们之前做的一样。在这些测试中，我们用<code class="fe nu nv nw nx b">should()</code>链接每一个。这允许我们在代码中进行断言。你会看到在每个内部，有两个参数被传递。每个的第一个参数是<code class="fe nu nv nw nx b">"have.length"</code>。当我们需要第二个参数时，我们使用<code class="fe nu nv nw nx b">have.</code>，所以在我们的例子中，我们使用像<code class="fe nu nv nw nx b">cy.get('.ToDo-Item').should('have.length', 2)</code>这样的东西。这是因为我们的应用程序默认呈现两个待办事项，所以页面上应该有两个带有<code class="fe nu nv nw nx b">ToDo-Item</code>类的元素。</p><p id="ae46" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">此外，我们的<code class="fe nu nv nw nx b">should()</code>函数还有另一个选项，只需要一个参数。这是当我们不需要检查某个特定的值时，比如当我们检查我们的元素是否有特定的长度时。如果我们不需要传入一个值进行比较，而只是想检查某件事是真是假，我们可以考虑使用<code class="fe nu nv nw nx b">be</code>。一个例子可能是类似<code class="fe nu nv nw nx b">cy .get(‘h1’).should(‘be.visible’)</code>的东西，我们只是想检查h1标签在页面上是否可见，并且没有被css隐藏。</p><h1 id="ebdb" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">5–7.如果按下“添加”按钮，但输入字段为空，则阻止创建新的待办事项；如果按下“添加”按钮，但输入字段为空，则向用户显示警告；如果按下“添加”按钮，并且输入字段有内容，则添加一个新的待办事项。</h1><h2 id="3288" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">玩笑</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2cbd" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里有三个新的东西需要回顾-<code class="fe nu nv nw nx b">afterAll()</code>、<code class="fe nu nv nw nx b">jest.fn()</code>和<code class="fe nu nv nw nx b">simulate()</code>。奇怪的是，我们将按相反的顺序讨论这些问题。在上面代码片段的第9行，您将看到我们查询我们的应用程序，找到一个类别为<code class="fe nu nv nw nx b">.ToDo-Add</code>的添加按钮。然后，我们链接上<code class="fe nu nv nw nx b">simulate()</code>功能。这是我们可以从酶获得的东西。这允许我们模拟诸如点击和输入输入等事件。它接受参数，在我们的例子中，我们传入<code class="fe nu nv nw nx b">"click"</code>。正如您所料，这模拟了点击我们的按钮，为我们的应用程序添加新的待办事项。</p><p id="fb05" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">因为我们的应用程序有两个默认项目已经开始，我们对我们的应用程序说，我们仍然期望这是2，即使点击添加按钮。其原因是，如果输入字段为空，我们的应用程序不允许添加新项目。我们的应用程序没有添加新项目，而是通过浏览器中的本机警报功能向用户显示警报。这就把我们带到了第二个我们想研究的新事物——T9。</p><p id="fa55" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">Jest允许我们模仿函数。这通常是当我们想要覆盖我们的应用程序的典型行为时，这可能是出于各种原因，从避免昂贵和/或缓慢的操作，如从API或数据库获取数据，到替换否则在我们的测试环境中不可用的函数，如位于浏览器窗口中的<code class="fe nu nv nw nx b">alert()</code>函数。这里我们通过编写<code class="fe nu nv nw nx b">window.alert = jest.fn()</code>来替换原生函数。这实际上阻止了我们的测试在遇到这一点时中断，因为它会因为缺少一个窗口而中断——结果是没有了<code class="fe nu nv nw nx b">alert()</code>功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/cbe5ba25901ead24a4f74aa7e56c8744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDhAnIwB-TS2UPKuuhZD3w.png"/></div></div></figure><p id="eb7c" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">然后，您将看到下一个测试检查现在作为<code class="fe nu nv nw nx b">window.alert</code>的函数是否已经被调用。这里我们用<code class="fe nu nv nw nx b">toHaveBeenCalled()</code>。如果我们需要检查这个函数是否被调用了不止一次，那么这个方法是有变化的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/568cb76ced050f8e447f50d1818b6044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wX2APp9MJI0071beEkUBg.png"/></div></div></figure><p id="880e" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里我们再次使用了<code class="fe nu nv nw nx b">simulate()</code>函数，但是在这种情况下，我们使用<code class="fe nu nv nw nx b">"change"</code>作为第一个参数。这与在React中检查<code class="fe nu nv nw nx b">onChange</code>事件的方式是一样的，对于输入字段的改变也是如此。您会注意到，我们创建了一个名为event的变量，并传入一个键为<code class="fe nu nv nw nx b">target</code>的对象，该对象的值是另一个键为<code class="fe nu nv nw nx b">value</code>的对象的值<code class="fe nu nv nw nx b">"Create more tests"</code>。这是为了模仿抓取输入字段的<code class="fe nu nv nw nx b">event</code>对象时<code class="fe nu nv nw nx b">event</code>对象的典型外观。</p><p id="0803" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">无论如何，我们将那个<code class="fe nu nv nw nx b">event</code>变量作为第二个参数传递给我们的<code class="fe nu nv nw nx b">simulate()</code>函数。之后，我们模拟一个点击事件。最后，我们用一个类<code class="fe nu nv nw nx b">".ToDoItem-Text"</code>获取第三个元素——它的索引为零，为2——并检查它是否等于我们之前传入的事件文本的值，即<code class="fe nu nv nw nx b">"Create more tests"</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/4620a6a5410cf7c3b4c6c1dfe5621736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frjZ9Of_sVM0FZBnJM3ODQ.png"/></div></div></figure><p id="b1de" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们想要解释的第三个新特性是<code class="fe nu nv nw nx b">afterAll()</code>函数。这基本上是在一个<code class="fe nu nv nw nx b">describe()</code>块中的所有测试结束时运行的。我们运行这个只是为了将测试环境中待办事项的数量恢复为2，这是默认的数量。我们通过找到第一个带有<code class="fe nu nv nw nx b">".ToDoItem-Delete"</code>类的元素，并点击它来实现。这不是完全必要的，但我选择这样做。如果我们想更精确，我们真的想在我们的应用程序中寻找第三个删除按钮，因为这将与我们添加的新项目相对应。为此，我们应该编写如下代码:<code class="fe nu nv nw nx b">app.find(".ToDoItem-Delete").at(2).simulate("click")</code>。</p><h2 id="6757" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">测试库</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7dd3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里的许多测试运行类似于我们在Jest中看到的那些。我们实际上使用Jest以完全相同的方式来模仿<code class="fe nu nv nw nx b">window.alert</code>函数。您还可以看到，我们甚至检查是否通过使用<code class="fe nu nv nw nx b">toHaveBeenCalled()</code>以相同的方式调用了该函数。这里唯一的变化是我们使用了<code class="fe nu nv nw nx b">fireEvent.click()</code>而不是<code class="fe nu nv nw nx b">simulate("click")</code>。您还会注意到，我们将想要点击的元素作为参数传入<code class="fe nu nv nw nx b">fireEvent.click</code>中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/0586b2096106db144c74bf4d775defb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pr88hGrlhMMOEXe7h1Sksw.png"/></div></div></figure><p id="6073" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">添加新项目的测试也与Jest的测试非常相似。我们创建了一个<code class="fe nu nv nw nx b">event</code>变量，使用<code class="fe nu nv nw nx b">fireEvent</code>来模拟输入字段上的输入变化，将我们的<code class="fe nu nv nw nx b">event</code>作为第二个参数传入。</p><p id="d6b3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">然后我们检查带有<code class="fe nu nv nw nx b">todo-input</code>的<code class="fe nu nv nw nx b">data-testid</code>的元素的值是否与我们的<code class="fe nu nv nw nx b">event</code>变量的值相匹配。在我们的Jest例子中，我们没有这样做，我打算把它去掉，但是我会把它留在里面。</p><p id="3d75" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">最后，我们单击在应用程序中添加新待办事项的按钮，然后通过<code class="fe nu nv nw nx b">toBeInTheDocument()</code>检查文档中是否有文本值为<code class="fe nu nv nw nx b">"Create more tests"</code>的元素。这个检查与我们之前检查输入值的测试不同，因为<code class="fe nu nv nw nx b">getByText</code>寻找包含文本的DOM节点，而我们的输入DOM节点不包含文本，而是包含一个<code class="fe nu nv nw nx b">event</code>对象。我们可以通过简单地注释掉测试中单击“add”按钮的行来测试这一声明的有效性，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/b71477e2485b905ba20e9060fb2da07b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4S1VGvv6EIg4_sEnUV-hdA.png"/></div></div></figure><p id="8501" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">并检查我们的测试是否仍然通过——它没有通过。</p><h2 id="c85c" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">柏树</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="42a8" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们这里处理事情的方式完全不同。同样，这是因为我们的测试是在浏览器内部运行的。首先我们<code class="fe nu nv nw nx b">get()</code>我们的添加按钮，它有一个类<code class="fe nu nv nw nx b">".ToDo-Add"</code>并且通过链接<code class="fe nu nv nw nx b">click()</code>来模拟一个点击事件。然后我们<code class="fe nu nv nw nx b">get()</code>我们的输入字段，链接一个<code class="fe nu nv nw nx b">type()</code>函数并传入<code class="fe nu nv nw nx b">"Create more tests"</code>的值。</p><p id="9a60" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们在这里继续链接一个<code class="fe nu nv nw nx b">should()</code>函数，看看我们的输入字段现在是否有<code class="fe nu nv nw nx b">have.value</code>的值<code class="fe nu nv nw nx b">"Create more tests"</code>。同样，这最后一点可能是不必要的，但我保留它是为了测试库，所以我保留它是为了Cypress。</p><p id="f430" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">继续，我们再一次<code class="fe nu nv nw nx b">get()</code>我们的<code class="fe nu nv nw nx b">".ToDo-Add"</code>按钮，并在上面链上一个<code class="fe nu nv nw nx b">click()</code>。最后，我们通过在<code class="fe nu nv nw nx b">.ToDo-Item</code>上运行<code class="fe nu nv nw nx b">get()</code>函数来检查我们有多少待办事项，并检查它的长度是否为3——这将是我们的两个默认事项，加上我们刚刚创建的事项。这涵盖了我们需要查看的检查，如果输入字段为空，是否阻止添加待办事项，因为如果没有阻止，我们的<code class="fe nu nv nw nx b">cy.get(“.ToDoItem”).should(“have.length”, 3)</code>测试将失败，因为它的长度将为4。</p><h1 id="ccc2" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">8–9.当按下单个待办事项的“删除”按钮时，从应用程序中删除该待办事项。在ToDo的两个默认项目中，如果第一个ToDo项目已经从应用程序中删除，第二个项目现在应该成为第一个(也是唯一的)项目。</h1><h2 id="09de" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">玩笑</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4325" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里的测试与之前使用的测试类型相同。您将在这里看到的一个区别是，两个测试中间都链接了一个<code class="fe nu nv nw nx b">first()</code>。因为有多个元素具有匹配的类名，所以我们可以使用<code class="fe nu nv nw nx b">first()</code>来获取第一个实例。</p><h2 id="32d7" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">测试库</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7599" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里的一个区别是测试库作为查询项的独立值，类似于JavaScript如何使用<code class="fe nu nv nw nx b">querySelector</code>和<code class="fe nu nv nw nx b">querySelectorAll</code>。在测试库中我们有<code class="fe nu nv nw nx b">getByTestId</code>和<code class="fe nu nv nw nx b">queryAllByTestId</code>。所以我们创建了一个名为<code class="fe nu nv nw nx b">deleteButtons</code>的变量，并给它赋值<code class="fe nu nv nw nx b">queryAllByTestId</code>。</p><p id="472c" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里我们检查了待办事项的长度是2。然后我们通过写<code class="fe nu nv nw nx b">fireEvent.click(deleteButtons[0])</code>点击索引中的第一个元素。最后，我们检查了待办事项的长度现在是否为1。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/072e5ed3d975b84a9b70f190d8e5a2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6iENrPWewVd7kAEgohXp7Q.png"/></div></div></figure><p id="66c2" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">之后的测试非常相似。然而，在这种情况下，我们单击第一个“删除”按钮，然后检查第一个待办事项现在是否有值<code class="fe nu nv nw nx b">"buy milk"</code>。这里的意义在于，这最初是我们的第二个待办事项。实际上，我们正在检查它是否已经从位置2移动到位置1(或者位置1移动到位置0，如果你指的是零索引)。</p><h2 id="7b3a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">柏树</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9248" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">在Cypress中，我们通过使用CSS中的<code class="fe nu nv nw nx b">nth-child</code>选择器来查询条目。所以在这里，我们希望抓住<code class="fe nu nv nw nx b">.ToDoItem-Delete</code>按钮位置1的<code class="fe nu nv nw nx b">nth-child</code>并<code class="fe nu nv nw nx b">click()</code>它。然后我们检查我们的<code class="fe nu nv nw nx b">.ToDoItem</code> s的位置1处的<code class="fe nu nv nw nx b">nth-child</code>是否包含<code class="fe nu nv nw nx b">"buy milk"</code>，以确保物品已经从位置2移动到位置1。</p><h1 id="0646" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">10–11.对于作为道具从ToDo传递到ToDoItem的数据，每个ToDoItem都应该呈现传递给它的文本；每个ToDoItem应呈现一个“删除”按钮。</h1><h2 id="5039" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">玩笑</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ffd5" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这里我们隔离了我们的<code class="fe nu nv nw nx b">ToDoItem</code>组件，并创建了一个名为<code class="fe nu nv nw nx b">item</code>的变量，我们将它作为<code class="fe nu nv nw nx b">ToDoItem</code>的道具传递给我们的<code class="fe nu nv nw nx b">mount()</code>函数，如下所示:<code class="fe nu nv nw nx b">mount(&lt;ToDoItem item={item}/&gt;</code>。</p><p id="7e4b" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">你可能会在酵素社区听到一些关于渲染组件时使用<code class="fe nu nv nw nx b">mount()</code>还是<code class="fe nu nv nw nx b">shallow()</code>的抱怨。简而言之，<code class="fe nu nv nw nx b">mount()</code>将呈现该组件中的所有内容，包括子组件等等，而<code class="fe nu nv nw nx b">shallow()</code>将尝试单独呈现该组件，因此子组件不会被包括在内。</p><p id="86b9" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我选择一直使用<code class="fe nu nv nw nx b">mount()</code>,因为我觉得这更接近于你的用户看到你的应用程序ie的样子。他们将看到你的应用程序的整体，而不是孤立的组件。</p><p id="362a" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">无论如何，这里对<code class="fe nu nv nw nx b">ToDoItem.test.js</code>的测试在这一点上非常简单。我们检查来自我们的<code class="fe nu nv nw nx b">item</code>道具的文本是否通过书写来呈现:<code class="fe nu nv nw nx b">expect(toDoItem.find(“p”).text()).toEqual(item.text)</code>。最后，我们检查ToDoItem组件是否有一个“删除”按钮。下面是这两种测试的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/1eb98eb7ec44adebbbb8d3cce8c97f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BlMQ7ABHobQPcFY8RLd2Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Remember that our item variable is an object with a key of text and a value of “Clean the pot”.</figcaption></figure><h2 id="6d37" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">测试库</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8343" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">至此，您大概可以推断出这些测试是如何工作的。它们也非常类似于那些为笑话而写的。</p><h2 id="157d" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">柏树</h2><p id="e497" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们没有这方面的测试。原因是我们在真实的浏览器中运行这些测试，因此，不能以这种方式模拟传递虚拟数据。这并不是一个真正的问题，因为能够在浏览器中直观地看到我们之前的两个待办事项就足以证明我们的数据以正确的格式正确地传递了。</p><h1 id="daaa" class="ng kw iq bd kx nh ni nj la nk nl nm ld jw nn jx lh jz no ka ll kc np kd lp nq bi translated">这就是我们想要的🎉</h1><p id="96ef" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们已经向您展示了如何用三种不同的测试工具编写十多个等价的测试！</p><p id="e2e3" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">当谈到测试时，有更多的功能，如处理异步代码、模拟和快照测试，但我希望阅读这篇文章至少让您对Jest、Testing Library和Cypress之间的差异有了基本的了解。现在至少拿起其中的一个，写一堆测试，并留下评论让我知道你是如何进行的！</p><h2 id="82ed" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">有兴趣看看代码吗？</h2><p id="96c3" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">以下是回复:</p><p id="710a" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">笑话:<a class="ae mp" href="https://github.com/sunil-sandhu/react-todo-2019-with-jest" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/react-todo-2019-with-jest</a></p><p id="83d1" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">测试库:<a class="ae mp" href="https://github.com/sunil-sandhu/react-todo-2019-with-testing-library" rel="noopener ugc nofollow" target="_blank">https://github . com/sunil-sand Hu/react-todo-2019-with-testing-Library</a></p><p id="4bdb" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">柏树:<a class="ae mp" href="https://github.com/sunil-sandhu/react-todo-2019-with-cypress" rel="noopener ugc nofollow" target="_blank">https://github . com/sunil-sand Hu/react-todo-2019-with-cypress</a></p><p id="b4c8" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><em class="mq">更多内容看</em> <a class="ae mp" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt ir"> <em class="mq">说白了就是io </em> </strong> </a> <em class="mq">。报名参加我们的</em> <a class="ae mp" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt ir"> <em class="mq">免费周报</em> </strong> </a> <em class="mq">。关注我们关于</em><a class="ae mp" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir"><em class="mq">Twitter</em></strong></a>，<a class="ae mp" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir"><em class="mq">LinkedIn</em></strong></a><strong class="lt ir"><em class="mq">，</em></strong><a class="ae mp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir"><em class="mq">YouTube</em></strong></a><strong class="lt ir"><em class="mq">，以及</em></strong><em class="mq"/><strong class="lt ir"><em class="mq">不和</em> </strong>  </p></div></div>    
</body>
</html>