<html>
<head>
<title>Introduction to JavaScript Async Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript异步编程简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-javascript-async-programming-48c15b709300?source=collection_archive---------7-----------------------#2020-06-15">https://javascript.plainenglish.io/introduction-to-javascript-async-programming-48c15b709300?source=collection_archive---------7-----------------------#2020-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/62a4a9a82a90c88408eb56086bdc53a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mYiXuMOBG5ih_OPL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tueio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kasia Wanner</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="eba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用JavaScript进行异步编程。</p><h1 id="73ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步性</h1><p id="8e12" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在同步编程中，事情一次发生一件。</p><p id="414a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在异步或异步编程中，多件事情可以同时发生。</p><p id="6b41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一件事情发生时，我们的程序继续运行。</p><p id="08d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript程序依靠异步编程而不是线程来运行多个进程。</p><p id="12f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们等待一件事在后台完成，同时运行另一件事。</p><h1 id="a8b1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复试</h1><p id="9ac8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步编程的一种方法是回调。这些ate函数在慢速动作完成后被调用。</p><p id="5cec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，一个基本的例子是<code class="fe me mf mg mh b">setTimeout</code>函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9e81" class="mq lc iq mh b gy mr ms l mt mu">setTimeout(() =&gt; console.log("hello"), 500);</span></pre><p id="99fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">setTimeout</code>函数在500毫秒后运行回调函数。</p><p id="31f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调将<code class="fe me mf mg mh b">'hello'</code>记录到控制台。</p><p id="6a28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们有一个接一个发生的不止一个异步动作，这就不能很好地工作。</p><p id="28f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9999" class="mq lc iq mh b gy mr ms l mt mu">readStorage("book", caches =&gt; {<br/>  const [firstCache] = caches;<br/>  readStorage(firstCache, info =&gt; {<br/>    console.log(info);<br/>  });<br/>});</span></pre><p id="2997" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须嵌套回调以异步读取缓存，然后运行另一个异步回调来记录信息。</p><p id="3c40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌套越多，我们的代码就越难阅读。</p><p id="eafb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们必须想出一个更好的方法。</p><h1 id="0eda" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺</h1><p id="d20a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">承诺是一个异步动作，可能在某个时刻完成并产生一个值。</p><p id="872c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的承诺是用<code class="fe me mf mg mh b">Promise.resolve</code>产生的。</p><p id="b91e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e66c" class="mq lc iq mh b gy mr ms l mt mu">const prom = Promise.resolve(1);<br/>prom<br/>  .then(val =&gt; console.log(val));</span></pre><p id="b1e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">Promise.resolve</code>来返回一个解析为1的承诺。</p><p id="8583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已解决意味着产生了一个值。</p><p id="c2ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">then</code>并传入一个回调来获取解析后的值。</p><p id="1785" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">then</code>方法也返回另一个承诺。</p><p id="c39b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建一个承诺，我们可以使用<code class="fe me mf mg mh b">Promise</code>作为构造函数。</p><p id="3387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b3a4" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');</span><span id="4114" class="mq lc iq mh b gy mv ms l mt mu">const readFile = (fileName) =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    fs.readFile(fileName, (err, data) =&gt; {<br/>      resolve(data);<br/>    });<br/>  });<br/>}</span></pre><p id="16af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个用Node.js <code class="fe me mf mg mh b">fs</code>模块读取文件的承诺。</p><p id="d0bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解析后的值是由<code class="fe me mf mg mh b">resolve</code>函数产生的，我们将它与文件内容一起传入<code class="fe me mf mg mh b">data</code>参数。</p><h1 id="a458" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">失败</h1><p id="98c5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了处理承诺中的失败，我们不能像处理同步代码那样用try-catch来处理它。</p><p id="f28e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们使用<code class="fe me mf mg mh b">reject</code>函数拒绝具有错误值的承诺。</p><p id="b9d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">catch</code>方法来处理错误情况。</p><p id="8065" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9997" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');</span><span id="a0a6" class="mq lc iq mh b gy mv ms l mt mu">const readFile = (fileName) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    fs.readFile(fileName, (err, data) =&gt; {<br/>      if (err){<br/>        return reject(err);<br/>      }<br/>      resolve(data);<br/>    });<br/>  });<br/>}</span></pre><p id="c2b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们拒绝定义<code class="fe me mf mg mh b">err</code>时的承诺。</p><p id="3854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，我们可以如下使用<code class="fe me mf mg mh b">catch</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a698" class="mq lc iq mh b gy mr ms l mt mu">readFile('foo.txt')<br/>  .catch(err =&gt; console.log(err))<br/>  .then(file =&gt; console.log(file))</span></pre><p id="f587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">未捕获的异常由环境处理，如果不处理，承诺拒绝将传播到环境。</p><h1 id="981c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺的集合</h1><p id="ff2c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Promise.all</code>方法同时运行一组不相关的承诺。</p><p id="1220" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它以一系列承诺作为其论据。</p><p id="38a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fcb9" class="mq lc iq mh b gy mr ms l mt mu">Promise.all([<br/>    Promise.resolve('foo'),<br/>    Promise.resolve('bar')<br/>  ])<br/>  .then(([val1, val2]) =&gt; console.log(val1, val2))</span></pre><p id="2762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组中有两个不相关的承诺，所以我们可以使用<code class="fe me mf mg mh b">Promise.all</code>。</p><p id="0bf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们调用<code class="fe me mf mg mh b">then</code>时，我们在<code class="fe me mf mg mh b">then</code>回调中得到一个数组值作为参数。</p><p id="1c31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个承诺的解决值都有一个条目。</p><h1 id="d5a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步函数</h1><p id="ab0a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步函数是上面提到的promise代码的简写。</p><p id="6d0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">await</code>类似于<code class="fe me mf mg mh b">then</code>。</p><p id="2cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">try/catch类似于<code class="fe me mf mg mh b">catch</code>。</p><p id="310c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以重写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4881" class="mq lc iq mh b gy mr ms l mt mu">readFile('foo.txt')<br/>  .catch(err =&gt; console.log(err))<br/>  .then(file =&gt; console.log(file))</span></pre><p id="78e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收件人:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f851" class="mq lc iq mh b gy mr ms l mt mu">(async () =&gt; {<br/>  try {<br/>    const file = await readFile('foo.txt');<br/>  } catch (err) {<br/>    console.log(err)<br/>  }<br/>})();</span></pre><p id="20ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">readFile</code>函数，用<code class="fe me mf mg mh b">await</code>得到解析后的值。</p><p id="264f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">try/catch</code>同<code class="fe me mf mg mh b">catch</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2438bd5b2ea30273e591779e27447be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3FC65EBO4tsw675"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bradley_brister?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bradley Brister</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fa67" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1b9b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步编程因承诺而变得简单。</p><p id="f6dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Promise</code>构造函数来创建我们自己的承诺。</p><p id="f686" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">then</code>方法获取承诺的解析值。</p><p id="6039" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">catch</code>从被拒绝的承诺中捕捉错误。</p><p id="2672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>功能是<code class="fe me mf mg mh b">then</code>和<code class="fe me mf mg mh b">catch</code>的较短语法。</p><h2 id="de0c" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="a3e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>