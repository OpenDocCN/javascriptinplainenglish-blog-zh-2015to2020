<html>
<head>
<title>10 JavaScript interview questions for 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年10个JavaScript面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-javascript-interview-questions-for-2020-697b40de9480?source=collection_archive---------0-----------------------#2020-02-07">https://javascript.plainenglish.io/10-javascript-interview-questions-for-2020-697b40de9480?source=collection_archive---------0-----------------------#2020-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/534d5f9a20b4d433aba115736ff28a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f1fZSYbLB8Ifklg6.png"/></div></div></figure><p id="110f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript正在成为世界上最流行的编程语言。随着对JS开发人员需求的增长，你必须做好准备。以下是十大JavaScript问题，帮助你在下一次面试中获得理想工作。</p><h1 id="f185" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">var和let有什么区别？</h1><p id="d025" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">虽然这看起来很简单，但你不会相信我不得不拒绝了多少候选人，仅仅因为他们不能回答这个问题。区别在于范围的级别。<code class="fe ma mb mc md b">var</code>是函数范围的，但是<code class="fe ma mb mc md b">let</code>(和<code class="fe ma mb mc md b">const</code>)是块范围的。要理解其中的区别，请看这个例子:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="2b73" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">==和===有什么区别？</h1><p id="6f64" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你的答案是“<code class="fe ma mb mc md b">==</code>按值比较，<code class="fe ma mb mc md b">===</code>也按类型比较”，那就不对了。JS引擎的理解是，<code class="fe ma mb mc md b">==</code>允许类型强制，<code class="fe ma mb mc md b">===</code>不允许。类型强制是解释器自动进行的类型转换。这是JS中大多数混乱的来源(就像<code class="fe ma mb mc md b">[] == ![]</code>是真的)。您可以在以下代码片段中观察到不同之处:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="7fc4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">“this”关键字是什么意思？</h1><p id="7aaa" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你可能会回答说这指向了类体内部的实例，但这也是不对的。首先，JS中的<a class="ae kw" href="https://everyday.codes/javascript/please-stop-using-classes-in-javascript/" rel="noopener ugc nofollow" target="_blank">类是语法糖</a>，没有引入任何新特性。<code class="fe ma mb mc md b">this</code>关键字在任何函数中都可用，并指向包含该函数的对象。举个例子可能更容易理解:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="3309" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是构造函数？</h1><p id="a672" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">JS中的构造函数也不是与类相关的函数，而是与<code class="fe ma mb mc md b">this</code>关键字紧密联系在一起。用关键字<code class="fe ma mb mc md b">new</code>调用构造函数，并返回<code class="fe ma mb mc md b">this</code>的值。注意，在构造函数中<code class="fe ma mb mc md b">this</code>并不指向外部对象，而是用作占位符对象:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="0923" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将这种基于回拨的呼叫转换为基于承诺的呼叫</h1><p id="fdc2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这与其说是一个问题，不如说是一个练习，但不管怎样，这是你必须知道的事情。回调只是你打算以后调用的函数。当你不得不等待某些东西(例如来自API的响应)时，它们最常用。但是，基于回调的代码太复杂了，这就是引入承诺的原因。我不打算在这里深入探讨，但是如果你现在知道什么是承诺，请看这篇文章。在下一个例子中，要求您将<code class="fe ma mb mc md b">getData</code>回调函数转换为承诺:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8a94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Promise构造函数接受一个回调，该回调接收两个函数:<code class="fe ma mb mc md b">resolve</code>和<code class="fe ma mb mc md b">reject</code>。在回调中，你执行耗时的任务，并根据结果调用“解决”或“拒绝”。</p><h1 id="0d00" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">NaN === NaN？</h1><p id="ad6b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">假的。这是无休止的争论的来源，也是关于JS的最令人困惑的部分之一。简而言之，<code class="fe ma mb mc md b">NaN</code>代表的不是数字，仅仅因为一个值不是数字，另一个值不是数字，并不意味着它们相等。不利的一面是，你不能用<code class="fe ma mb mc md b">myVariable === NaN</code>真正检查一个变量是否是<code class="fe ma mb mc md b">NaN</code>。您可以使用<code class="fe ma mb mc md b">Number.isNaN</code>功能或<code class="fe ma mb mc md b">myVariable !== myVariable</code>进行检查。</p><h1 id="5bc0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi">0.1 + 0.2 === 0.3?</h1><p id="ebc9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">假的。这个技巧不仅适用于JS:它在任何语言的浮点运算中都很常见。这与CPU处理浮点数的方式有关。<code class="fe ma mb mc md b">0.1 + 0.2</code>的实际值类似于<code class="fe ma mb mc md b">0.300000001</code>，为了检查是否相等，您应该编写<code class="fe ma mb mc md b">Math.abs(0.3 - (0.2 + 0.1)) &lt;= EPS</code>，其中EPS是一个任意的小值(例如0.00001)。</p><h1 id="353e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JS中的原始数据类型有哪些？</h1><p id="5722" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">JS中的原始数据类型不是对象，也没有方法。以下是JS中原始数据类型的列表:</p><ul class=""><li id="d82b" class="mk ml iq ka b kb kc kf kg kj mm kn mn kr mo kv mp mq mr ms bi translated">布尔代数学体系的</li><li id="e8ae" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">空</li><li id="b278" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">不明确的</li><li id="9daa" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">数字</li><li id="c408" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">BigInt</li><li id="245e" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">线</li><li id="ab1c" class="mk ml iq ka b kb mt kf mu kj mv kn mw kr mx kv mp mq mr ms bi translated">标志</li></ul><h1 id="a7b5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是“严格”模式？</h1><p id="0eec" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在JS中，通过将<code class="fe ma mb mc md b">"use strict";</code>放在文件的开头来启用严格模式。严格模式支持代码中更严格的错误检查，并使调试更容易。例如，这个代码片段可以在常规JS中工作，但不是严格的:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="77a4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">这段代码的输出是什么？</h1><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="23b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">undefined</code>。发生这种情况是因为JS将在第2行的“return”后插入分号，并将第3-5行视为作用域而不是对象定义。</p><p id="1153" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，祝您在面试中好运！更多有趣的内容，请查看我的其他文章:</p><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/7-really-good-reasons-not-to-use-typescript-166af597c466" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">不使用TypeScript的7个非常好的理由</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">有很多理由使用TypeScript，但我会给你7个不使用的理由。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jw nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/to-infinity-and-beyond-with-javascript-proxy-api-8d4f7a26c8dc" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">使用JavaScript代理API无限超越</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">代理API是一个高级的概念，但是如果你想掌握JavaScript，代理API是你绝对需要的…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np jw nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/implementing-the-builder-pattern-in-javascript-without-classes-eaf41f93b9c0" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">在没有类的情况下用JavaScript实现构建器模式</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">在JavaScript中使用高级设计模式的力量，而没有类的开销</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np jw nb"/></div></div></a></div><figure class="me mf mg mh gt jr gh gi paragraph-image"><a href="http://eepurl.com/gYiA29"><div class="gh gi ns"><img src="../Images/446049aa060bbaea15a64e1a907b1030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*zWeFS3E1gbkEuBmpbvm6Rg.jpeg"/></div></a></figure></div></div>    
</body>
</html>