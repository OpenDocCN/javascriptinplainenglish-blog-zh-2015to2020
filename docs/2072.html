<html>
<head>
<title>Early Returns/Guard Clauses in JavaScript (and React)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的早期返回/保护子句(和React)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/early-return-with-react-hooks-f96fa4a33124?source=collection_archive---------6-----------------------#2020-05-17">https://javascript.plainenglish.io/early-return-with-react-hooks-f96fa4a33124?source=collection_archive---------6-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="62fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是提前返回/保护子句，为什么应该使用它们，以及如何在React中使用的示例</h2></div><h1 id="a08c" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">议程</h1><p id="f76d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我们将浏览以下部分:</p><ul class=""><li id="8bb6" class="lt lu iq kz b la lv ld lw lg lx lk ly lo lz ls ma mb mc md bi translated">提前回报的基本概念</li><li id="f201" class="lt lu iq kz b la me ld mf lg mg lk mh lo mi ls ma mb mc md bi translated">使用提前退货的原因</li><li id="11b1" class="lt lu iq kz b la me ld mf lg mg lk mh lo mi ls ma mb mc md bi translated">将提前返回与React一起使用</li><li id="ae15" class="lt lu iq kz b la me ld mf lg mg lk mh lo mi ls ma mb mc md bi translated">使用带挂钩的提前返回</li></ul><p id="8add" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">现在，让我们开始吧。</p><h1 id="fd8a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">什么是提前归还？</h1><p id="09ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">早期返回是一种模式，它建议我们通过检查前提条件来避免嵌套的<code class="fe mm mn mo mp b">if-else</code>语句，并尽可能早地返回或抛出。通常情况下，提前归还也被称为警卫条款或保镖模式。</p><p id="a8f6" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">这种模式的一个基本的虚构例子是转动下面的代码</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bd34" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">…变成这样:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mx my mz"><p id="232e" class="kx ky na kz b la lv jr lc ld lw ju lf nb mj li lj nc mk lm ln nd ml lq lr ls ij bi translated">我想提一下，Swift(苹果发布的一种面向iOS/MacOS开发的现代语言)甚至把guard作为内置语言特性！</p></blockquote><h1 id="8cca" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">使用提前退货的原因</h1><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/44566e55781ff3cba21c75bec80e618a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xy6urR37pADBSx8aL7dapQ.jpeg"/></div></div></figure><h2 id="4312" class="nl kg iq bd kh nm nn dn kl no np dp kp lg nq nr kr lk ns nt kt lo nu nv kv nw bi translated">1.它使我们的代码可读和可理解</h2><p id="3867" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">简单看一下上面的例子，早期返回版本在视觉上是扁平的，比深度嵌套版本更容易阅读和理解。</p><h2 id="bc9b" class="nl kg iq bd kh nm nn dn kl no np dp kp lg nq nr kr lk ns nt kt lo nu nv kv nw bi translated">2.当处理复杂的情况时，它卸下了我们头脑中的负担</h2><p id="7d5d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">想象一下(或者回忆一下)在函数中有很多嵌套的<code class="fe mm mn mo mp b">if-else</code>分支的情况，我们在编写逻辑时会有多经常迷路？</p><p id="59cf" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">相比之下，如果我们能够尽早摆脱无效和特殊情况，我们将能够安心地专注于功能的“真实”主体。</p><h1 id="d0bc" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">我们如何在React中使用早期返回？</h1><p id="f0a5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在React中，<code class="fe mm mn mo mp b">Component</code>是组成我们的UI构建块的边界，在这个级别中很容易应用早期返回。例如，我们可以在数据加载时返回一个<code class="fe mm mn mo mp b">Spinner</code>，在出现错误时返回一个<code class="fe mm mn mo mp b">Alert</code>，在数据为空时返回一些消息，在数据准备就绪时返回“真正的”表示元素。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="07f8" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">胡克呢？</h1><p id="5ccd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面代码中的<code class="fe mm mn mo mp b">MyComponent</code>是一个表示性组件，我们可以将<code class="fe mm mn mo mp b">useData</code>钩子<em class="na">(想象一下我们在代码库中的某个地方有这个定制钩子)</em>放在它里面，让组件自己加载数据:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f915" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">然而，有一件非常重要且令人沮丧的事情需要注意——如果我们打算在某些情况下在<code class="fe mm mn mo mp b">return</code>语句后调用一个钩子，我们就不能提前返回。原因是<a class="ae nx" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank"> React要求我们每次组件渲染</a>的时候都要按照相同的顺序调用钩子。</p><p id="6586" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">也就是说，下面的代码是<strong class="kz ir">无效</strong>，React会为你记录错误和警告，因为<code class="fe mm mn mo mp b">useData2</code>钩子和<code class="fe mm mn mo mp b">React.useMemo</code>钩子并不总是被调用——调用钩子的顺序是变化的。</p><blockquote class="mx my mz"><p id="ec5a" class="kx ky na kz b la lv jr lc ld lw ju lf nb mj li lj nc mk lm ln nd ml lq lr ls ij bi translated">您可能会收到错误和警告，例如:“React检测到XXX调用的钩子顺序发生了变化”和“渲染的钩子比之前渲染的多”</p></blockquote><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b909" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">一个直接的解决方案是将空检查移到钩子内部:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c7aa" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">显然，到处都是空检查真的很烦人，当我们有许多数据要加载，而它们又相互依赖，其中一些需要被有条件地调用时，情况会变得更糟<em class="na">(当我使用来自多个来源的数据并聚集它们来构建报告时，我确实遇到过这种情况)</em>。</p><p id="4eea" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">解决这个问题的一个可维护的方法是使用我们的老朋友——<code class="fe mm mn mo mp b">render props</code>。</p><p id="ddeb" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">也就是说，我们可以分别编写加载<code class="fe mm mn mo mp b">data1</code>和<code class="fe mm mn mo mp b">data2</code>的组件。当数据未准备好时，这些组件不呈现任何内容，当数据准备好时，它们调用<code class="fe mm mn mo mp b">children</code>函数来呈现实际的dom。我把这些组件称为<code class="fe mm mn mo mp b">DataGuard</code></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="039f" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">一旦我们有了这些<code class="fe mm mn mo mp b">DataGuard</code>，我们就能像这样组合它们:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="52ff" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">通过这样做，我们不再需要担心到处传播和复制空检查，这些<code class="fe mm mn mo mp b">DataGuard</code>组件是高度可重用和可组合的——它们只是为它们的子组件提供数据，与DOM emit无关，因此它们可以在任何需要数据的地方使用，而不管数据应该如何呈现。</p><p id="3c00" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">一个有趣的观察是，当使用<code class="fe mm mn mo mp b">DataGuard</code>组件时，我们开始看到嵌套组件的金字塔。我认为这很好，因为在树中嵌套组件正是React的工作方式——如果我们问自己:我们如何使用组件？答案可能简单地变成“我们把它放在另一个组件里面”。一直到根组件都是如此——在<code class="fe mm mn mo mp b">ReactDOM.render</code>函数中传递的那个。</p><p id="1bcf" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">感谢阅读:)</p><h2 id="0c51" class="nl kg iq bd kh nm nn dn kl no np dp kp lg nq nr kr lk ns nt kt lo nu nv kv nw bi translated"><strong class="ak">简明英语笔记</strong></h2><p id="326e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击此处 查看我们，并确保订阅该频道😎</p></div></div>    
</body>
</html>