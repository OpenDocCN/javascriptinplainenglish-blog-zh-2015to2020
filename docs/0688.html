<html>
<head>
<title>Sharing UI Components to Build Consistent UIs Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">共享UI组件以更快地构建一致的UI</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/sharing-ui-components-to-build-consistent-uis-faster-5e60141ca855?source=collection_archive---------4-----------------------#2019-11-26">https://javascript.plainenglish.io/sharing-ui-components-to-build-consistent-uis-faster-5e60141ca855?source=collection_archive---------4-----------------------#2019-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0c1c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用<a class="ae kc" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> bit.dev </a>共享真正可重用的组件，以保持用户界面的一致性并加快构建速度。</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><a href="https://bit.dev"><div class="gh gi kd"><img src="../Images/3fe7978bf7616679b319b3b31f5ef17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RZP_jNEEilVtmjGH4O4UHQ.gif"/></div></a><figcaption class="kl km gj gh gi kn ko bd b be z dk">The Bit workflow: Build, reuse and sync UI components</figcaption></figure><p id="a404" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在当今的应用程序开发世界中，UI组件(React、Vue、Angular、Stencil等)是我们应用程序UI的模块化构建模块。</p><p id="b4a9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">作为模块化单元，<a class="ae kc" href="https://blog.bitsrc.io/sharing-components-at-the-enterprise-12f9e5f1bb67" rel="noopener ugc nofollow" target="_blank">我们的组件可以而且应该在不同的项目(和团队成员)之间共享</a>以加速开发，减少错误，使我们的代码更易于维护，并为不同屏幕和应用程序的用户提供一致的体验。</p><p id="0566" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是，<a class="ae kc" href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l3bhezsg" rel="noopener ugc nofollow" target="_blank">共享可重用的UI组件</a>说起来容易做起来难，没有合适的工具和知识来完成这项工作。因此，我收集了一些有用的方法来共享UI组件并在应用程序间重用它们。希望这有所帮助，有什么问题请随意评论和提问。干杯。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="f11b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">内容</strong>:</p><ul class=""><li id="a5cc" class="ln lo in kr b ks kt kv kw ky lp lc lq lg lr lk ls lt lu lv bi translated"><strong class="kr io">为什么UI组件很难打包复用？</strong></li><li id="1876" class="ln lo in kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated"><strong class="kr io">用Bit检查组件的可重用性。</strong></li><li id="92bf" class="ln lo in kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated"><strong class="kr io">将文件作为组件跟踪+自动定义依赖关系。</strong></li><li id="582d" class="ln lo in kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated"><strong class="kr io">应用可复用编译器+孤立构建。</strong></li><li id="8512" class="ln lo in kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated"><strong class="kr io">版本化+导出组件。</strong></li><li id="3f67" class="ln lo in kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated"><strong class="kr io">复用和更新组件。</strong></li><li id="8e1a" class="ln lo in kr b ks lw kv lx ky ly lc lz lg ma lk ls lt lu lv bi translated">逐步建立你的用户界面库。</li></ul><h1 id="166d" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">为什么组件很难打包和重用？</h1><figure class="ke kf kg kh gt ki gh gi paragraph-image"><a href="https://bit.dev/collections"><div class="gh gi mt"><img src="../Images/ab6467b06fb1b3375760d7915667596a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ns2l6w5Jn8zrnWoDXRVng.png"/></div></a><figcaption class="kl km gj gh gi kn ko bd b be z dk">A component collection shared to bit.dev</figcaption></figure><p id="51b0" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">到目前为止，打包组件迫使开发人员经历传输、捆绑、遗留浏览器支持、大小、映射、类型检测和无数其他优化。这足以阻止这个想法。</p><p id="76ae" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">传统上，打包组件以供重用必须涉及将组件从您的应用程序拆分到不同的存储库中。每个组件都必须作为一个包进行样板化，包括手动定义依赖关系等。您还必须为每个组件配置构建和测试步骤，以便它可以在项目之外运行。每一个改变都需要重构你共享的每一个组件的配置。这是大量的工作。</p><p id="ea2e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">今天，有一个新的共享UI组件叫做<a class="ae kc" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"><strong class="kr io">Bit</strong></a>(<a class="ae kc" href="https://github.com/teambit/bit" rel="noopener ugc nofollow" target="_blank"><strong class="kr io">GitHub</strong></a>)。Bit帮助您逐渐使您现有的组件可重用，自动化大部分过程并帮助您了解还需要什么，并在您的团队可以共享和重用它们的模块化集合中共享它们。</p><p id="dca5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">然后，它帮助您分发可重用的组件，以便人们可以在他们的代码中轻松地找到、尝试和使用您的组件。最后，它让每个人都可以从他们自己的项目中建议对组件的更新，这样采用组件就成了一个简单的选择。</p><p id="5d89" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">下面我将简要回顾一下这个工作流程，您可以随意继续<a class="ae kc" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank">并亲自尝试一下</a>。不管你有没有UI库，这个工作流程都是一样的，因为Bit并不“关心”你从哪个repo共享你的组件。</p><h1 id="cbfc" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">让你的UI组件真正可重用</h1><figure class="ke kf kg kh gt ki gh gi paragraph-image"><a href="https://bit.dev"><div class="gh gi kd"><img src="../Images/6914fc3ab1309f53f73e8fc94ca7f974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z_Uh1w8QjcSMzJwwlEnBzA.gif"/></div></a></figure><p id="265a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">Bit通过为您提供工具来帮助您<strong class="kr io">构建更多可重用的组件</strong>:</p><p id="91a1" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">使用自动依赖定义和易于应用的构建配置等特性，自动化打包组件的大部分工作。</p><p id="f252" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">通过让你在项目之外真正隔离地测试、构建和呈现每个组件，了解每个组件可重用性的真实状态。</p><h2 id="3fee" class="mu mc in bd md mv mw dn mh mx my dp ml ky mz na mn lc nb nc mp lg nd ne mr nf bi translated">短设置</h2><p id="e45b" class="pw-post-body-paragraph kp kq in kr b ks ng jo ku kv nh jr kx ky ni la lb lc nj le lf lg nk li lj lk ig bi translated">首先，你需要<a class="ae kc" href="https://docs.bit.dev/docs/installation#install-via-npm-yarn" rel="noopener ugc nofollow" target="_blank">安装位</a>并<a class="ae kc" href="https://docs.bit.dev/docs/workspace#bit-workspace" rel="noopener ugc nofollow" target="_blank">为你的项目工作空间</a>初始化它。这非常简单，只需使用几个CLI命令:</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="196f" class="mu mc in nm b gy nq nr l ns nt">$ npm install bit-bin --global<br/>$ cd project-directory<br/>$ bit init</span></pre><p id="4aa7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">然后，前往bit.dev和<a class="ae kc" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank">快速创建一个免费账户</a>。然后，创建一个集合来承载您的共享UI组件。最后，运行<code class="fe nu nv nw nm b">bit login</code>向您的bit.dev集合验证您的CLI:</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="82e9" class="mu mc in nm b gy nq nr l ns nt">$ bit login</span></pre><h2 id="ba19" class="mu mc in bd md mv mw dn mh mx my dp ml ky mz na mn lc nb nc mp lg nd ne mr nf bi translated">定义和跟踪可重用组件</h2><p id="cd89" class="pw-post-body-paragraph kp kq in kr b ks ng jo ku kv nh jr kx ky ni la lb lc nj le lf lg nk li lj lk ig bi translated">现在，让我们使用Bit来使用<code class="fe nu nv nw nm b">bit add</code>命令跟踪我们项目中作为组件的一组文件。这将“告诉”Bit开始跟踪你的工作空间中的组件。它还会“告诉”Bit来分析每个组件的依赖关系，并自动为每个组件创建一个<code class="fe nu nv nw nm b">package.json</code>。很酷，对吧？</p><h2 id="075f" class="mu mc in bd md mv mw dn mh mx my dp ml ky mz na mn lc nb nc mp lg nd ne mr nf bi translated">例子</h2><p id="3757" class="pw-post-body-paragraph kp kq in kr b ks ng jo ku kv nh jr kx ky ni la lb lc nj le lf lg nk li lj lk ig bi translated">让我们假设下面的app结构只有一个<code class="fe nu nv nw nm b">hello-world</code>组件。</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="2c7a" class="mu mc in nm b gy nq nr l ns nt">. <br/>├── package.json <br/>└── src     <br/>    ├── hello-world.js     <br/>    └── index.js</span></pre><p id="5b87" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们使用<code class="fe nu nv nw nm b">bit add</code>来跟踪hello-world组件，告诉它哪些文件是这个组件的一部分:</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="f8bd" class="mu mc in nm b gy nq nr l ns nt">$ bit add src/hello-world.js src/index.js --id hello/world <br/>tracking component hello/world:     <br/>    added src/hello-world.js     <br/>    added src/index.js</span></pre><p id="33af" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在运行一个快速的<code class="fe nu nv nw nm b">bit status</code>来查看组件是否被跟踪，并且不需要项目中的任何附加文件:</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="bcb3" class="mu mc in nm b gy nq nr l ns nt">$ bit status <br/>new components      <br/>     &gt; hello/world... ok</span></pre><p id="f361" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们现在看到，该组件打包了执行所需的所有文件。但是，它还没有配置构建步骤(编译/传输),如果我们希望它在项目之外运行，这是必要的。</p><h2 id="0216" class="mu mc in bd md mv mw dn mh mx my dp ml ky mz na mn lc nb nc mp lg nd ne mr nf bi translated">应用可重用的编译器</h2><p id="40f0" class="pw-post-body-paragraph kp kq in kr b ks ng jo ku kv nh jr kx ky ni la lb lc nj le lf lg nk li lj lk ig bi translated">让我们对组件应用一个编译器，这样它就可以在我们的创作项目的上下文之外作为一个独立的单元进行构建。Bit为<a class="ae kc" href="https://bit.dev/bit/envs" rel="noopener ugc nofollow" target="_blank">预制的编译器</a>提供了实现可重用UI组件的最佳实践。</p><p id="8a6b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们使用Bit将<a class="ae kc" href="https://bit.dev/bit/envs/compilers/react" rel="noopener ugc nofollow" target="_blank"> React标准编译器</a>导入到我们的工作空间中，并将其应用到组件中，以便它可以在任何地方构建和运行。如果使用React TypeScript，只需<a class="ae kc" href="https://bit.dev/bit/envs/compilers/react-typescript" rel="noopener ugc nofollow" target="_blank">选择匹配的编译器</a>，依此类推。</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="25f2" class="mu mc in nm b gy nq nr l ns nt">$ bit import bit.envs/compilers/react --compiler <br/>the following component environments were installed <br/>- bit.envs/compilers/babel@0.0.7</span></pre><p id="1428" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">酷毙了。现在运行<code class="fe nu nv nw nm b">bit build</code>,确保组件可以在真正独立于项目环境的情况下构建，从而使其可重用。</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="ebf9" class="mu mc in nm b gy nq nr l ns nt">$ bit build </span></pre><p id="4957" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">该组件作为一个独立的单元构建，我们现在知道它可以在任何新项目中开箱即用，使用它自己定义的构建配置。</p><p id="3848" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">该组件现在可以进行版本控制和共享了！🎊</p><h1 id="bf51" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">版本控制和导出组件</h1><p id="6061" class="pw-post-body-paragraph kp kq in kr b ks ng jo ku kv nh jr kx ky ni la lb lc nj le lf lg nk li lj lk ig bi translated">接下来，让我们为组件标记一个版本。Bit跟踪工作空间中所有组件之间的关系，并允许您对单个组件及其受影响的从属组件进行版本控制和更新。</p><p id="37bc" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这种情况下，让我们为<code class="fe nu nv nw nm b">hello-world</code>组件设置一个0.0.1版本:</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="9257" class="mu mc in nm b gy nq nr l ns nt">$ bit tag hello/world <br/>1 components tagged | 1 added, 0 changed, 0 auto-tagged<br/>added components:  hello/world@0.0.1</span></pre><p id="370e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">太棒了。现在运行一个快速的<code class="fe nu nv nw nm b">bit status</code>来查看组件是否被版本化并准备好导出。</p><blockquote class="nx ny nz"><p id="d5a1" class="kp kq oa kr b ks kt jo ku kv kw jr kx ob kz la lb oc ld le lf od lh li lj lk ig bi translated">注意:您可以为组件添加docuemntation，它将自动提取并出现在您的bit.dev集合中。<a class="ae kc" href="https://docs.bit.dev/docs/documenting-components" rel="noopener ugc nofollow" target="_blank">在此了解更多信息</a>。</p></blockquote><p id="7086" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">最后，让我们将组件导出(发布)到您的bit.dev集合中！</p><pre class="ke kf kg kh gt nl nm nn no aw np bi"><span id="5668" class="mu mc in nm b gy nq nr l ns nt">$ bit export user-name.collection-name <br/>1 component exported to collection user-name/collection-name</span></pre><p id="44d6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在去看看你的收藏，看看组件。您可以将示例保存在组件的渲染沙箱中，<a class="ae kc" href="https://docs.bit.dev/docs/tutorials/bit-react-tutorial#preview-the-react-component" rel="noopener ugc nofollow" target="_blank">如这里所解释的</a>。</p><h1 id="eb94" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">重用共享的UI组件</h1><figure class="ke kf kg kh gt ki gh gi paragraph-image"><a href="https://bit.dev"><div class="gh gi kd"><img src="../Images/665c8f8988f7e76d0c22350e0bea16a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CMvpSPNdlYG7sti06LbtuQ.gif"/></div></a></figure><p id="54c2" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">当您将一个组件共享给<a class="ae kc" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> bit.dev </a>时，它可以通过两种方式使用。第一步是<a class="ae kc" href="https://docs.bit.dev/docs/installing-components" rel="noopener ugc nofollow" target="_blank">使用标准的npm/yarn客户端，像安装bit.dev包注册表中的任何其他包一样安装组件</a>。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cf856866566fd7187e4ebbbad3d59c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*LiMG7-z8hJHmgeQHkxuMYQ.png"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">Example: installing a hero component using npm from the bit.dev registry</figcaption></figure><p id="b55a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">请注意，您将只为特定的组件安装(并获取更新),因此您可以保持应用程序的捆绑包大小更轻，开发速度更快。</p><p id="4951" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">第二种方式是将<code class="fe nu nv nw nm b"><a class="ae kc" href="https://docs.bit.dev/docs/sourcing-components" rel="noopener ugc nofollow" target="_blank">bit import</a></code> <a class="ae kc" href="https://docs.bit.dev/docs/sourcing-components" rel="noopener ugc nofollow" target="_blank">的构件变成一个项目</a>。这将引入组件的源代码，同时作为一个组件被逐位跟踪。</p><p id="a662" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这个工作流的最大优点是您现在可以直接从消费项目(！idspnonenote)中修改组件的源代码。)以便更容易采用该组件。然后，您可以将更改标记为新版本，并将它们导出(给定权限)回您的集合——以便其他项目可以获取更改并合并组件的版本。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="ll lm l"/></div></figure><h1 id="6da7" class="mb mc in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">逐步构建你的用户界面库</h1><p id="f56d" class="pw-post-body-paragraph kp kq in kr b ks ng jo ku kv nh jr kx ky ni la lb lc nj le lf lg nk li lj lk ig bi translated">通过这个工作流程，您不仅可以更容易地隔离、打包和重用组件。你也可以逐步建立自己的模块化UI库，而不必失去对交付的关注并为此大做文章:)</p><p id="1e98" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">您可以不断地使应用程序中的组件可重用，在一个简短的反馈循环中迭代，看看每个组件是否可以独立于项目进行构建、测试和渲染，并将它们共享到您的bit.dev集合中。</p><p id="0ec1" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">下次您或您的团队成员需要某个组件时，您可以快速检查它是否在那里，准备好被重用或更新。如果没有，只需编写组件并将其导出到您的共享UI组件集合中。</p><p id="0027" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在很短的时间内，你应该能够<a class="ae kc" href="https://blog.bitsrc.io/building-a-consistent-ui-design-system-4481fb37470f" rel="noopener ugc nofollow" target="_blank">增加你的ui</a>的一致性，同时通过重用加速交付。您还会发现附加的价值，比如通过模块化使维护变得更简单，让新的团队成员更容易加入等等。请随意尝试。</p><p id="ddd3" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">感谢阅读，干杯！🍻</p></div></div>    
</body>
</html>