<html>
<head>
<title>An Intro To Apollo GraphQL With React Hooks And Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍带有React钩子和上下文API的Apollo GraphQL</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-intro-to-apollo-graphql-with-react-hooks-and-context-api-1de5c3ab3c83?source=collection_archive---------4-----------------------#2020-04-29">https://javascript.plainenglish.io/an-intro-to-apollo-graphql-with-react-hooks-and-context-api-1de5c3ab3c83?source=collection_archive---------4-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2f93b349d63bb34312f64ff49cb39a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDFThqpsGcfPHKskN2WO9w.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@souvenirpixels?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">James Wheeler</a> on <a class="ae jd" href="https://unsplash.com/s/photos/fishing-hooks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="2adb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前我写过如何使用阿波罗图形QL <a class="ae jd" href="https://medium.com/swlh/an-intro-to-graphql-with-apollo-client-and-angular-7bcf66638e11" rel="noopener">这里</a>角。我在egghead.io上看了一个来自<a class="lb lc ep" href="https://medium.com/u/7341702f4f0e?source=post_page-----1de5c3ab3c83--------------------------------" rel="noopener" target="_blank">伊芙·波尔切洛</a>的GraphQL视频，我觉得用Angular和Apollo GraphQL客户端模仿她在GraphQL操场上(【https://pet-library.moonhighway.com】T5)的动作会很有趣。</p><p id="a148" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我一直想尝试React有一段时间了，我想到了使用hooks和功能组件在React中重写angular app，并希望与您分享我的学习经验。</p><h2 id="6306" class="ld le jg bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">项目</h2><p id="04b3" class="pw-post-body-paragraph kd ke jg kf b kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">我们的项目将是一个简单的克隆宠物图书馆游乐场从头开始使用React和阿波罗客户端，其功能包括认证，返回所有宠物的列表和检查/检查宠物。我们不会在这个项目中使用基于类的组件，因为react钩子让我们管理本地组件状态和组件生命周期。</p><p id="0d6b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以在这里  查看完整源代码<a class="ae jd" href="https://github.com/rajvirtual/react-apollo-graphql-hooks" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="mb">。</em></strong></a></p><h2 id="8eec" class="ld le jg bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">文件夹结构</h2><figure class="md me mf mg gt is gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/a8a0d39bf7da27c8b71cc0cd2776e1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*qEIgY64vPzk-zoiT9R8LiA.png"/></div></figure><p id="0275" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图显示了我们将要使用的文件夹结构。所有可重复使用的组件将放入组件文件夹，代表页面或路线的页面将放入页面文件夹。组件使用的钩子将会在钩子文件夹中结束。将由组件访问的React上下文将放在providers文件夹中。</p><p id="c803" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组件文件夹将包括以下组件:</p><ul class=""><li id="38b4" class="mh mi jg kf b kg kh kk kl ko mj ks mk kw ml la mm mn mo mp bi translated">List.js:一个简单的表示组件，将呈现宠物列表，并将宠物作为道具。</li><li id="d679" class="mh mi jg kf b kg mq kk mr ko ms ks mt kw mu la mm mn mo mp bi translated">CheckIn.js:用于登记宠物并刷新列表的组件。</li><li id="a49a" class="mh mi jg kf b kg mq kk mr ko ms ks mt kw mu la mm mn mo mp bi translated">CheckOut.js:签出宠物的组件，签入和签出组件都将宠物Id作为属性。</li><li id="ee56" class="mh mi jg kf b kg mq kk mr ko ms ks mt kw mu la mm mn mo mp bi translated">SelectStatus.js:根据状态过滤出宠物的组件。</li></ul><p id="69bb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pages文件夹将包括以下组件:</p><ul class=""><li id="1a28" class="mh mi jg kf b kg kh kk kl ko mj ks mk kw ml la mm mn mo mp bi translated">js:一个包含过滤器下拉列表和列表组件的容器组件。</li><li id="4489" class="mh mi jg kf b kg mq kk mr ko ms ks mt kw mu la mm mn mo mp bi translated">Login.js:处理认证的组件。</li></ul><p id="9fff" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用create-react-app来创建我们的项目。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="095d" class="ld le jg mw b gy na nb l nc nd">create-react-app react-apollo-graphql-hooks</span></pre><p id="90df" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将在我们的项目中使用react bootstrap，因此让我们通过键入以下命令将其添加到我们的项目中:</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="d4dd" class="ld le jg mw b gy na nb l nc nd">npm install react-bootstrap bootstrap</span></pre><p id="9462" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将在components文件夹中创建SelectStatus.js，并添加以下代码。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="dd06" class="ld le jg mw b gy na nb l nc nd">export const SelectStatus = ({ petStatus, defaultValue, onSelect }) =&gt; {<br/>  const setSelect = (e) =&gt; {<br/>    e.preventDefault();<br/>    let index = e.target.options.selectedIndex;<br/>    let status = petStatus[index];<br/>    if (onSelect) {<br/>      onSelect(status);<br/>    }<br/>  };</span><span id="aa42" class="ld le jg mw b gy ne nb l nc nd">return (<br/>    &lt;&gt;<br/>      &lt;Form.Group controlId="status"&gt;<br/>        &lt;Col&gt;<br/>          &lt;Form.Label&gt;Pet Status:&lt;/Form.Label&gt;<br/>        &lt;/Col&gt;<br/>        &lt;Col&gt;<br/>          &lt;Form.Control<br/>            as="select"<br/>            defaultValue={defaultValue?.name}<br/>            onChange={(e) =&gt; setSelect(e)}<br/>          &gt;<br/>            {petStatus.map((item) =&gt; {<br/>              return &lt;option key={item.key}&gt;{item.name}&lt;/option&gt;;<br/>            })}<br/>          &lt;/Form.Control&gt;<br/>        &lt;/Col&gt;<br/>      &lt;/Form.Group&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="6ccd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">暂时忽略道具{ petStatus，defaultValue，onSelect }，稍后我们将回到这些。正如你所看到的，这个组件只是一个表示性的组件，不包含任何内部状态，只是通过循环宠物状态列表来呈现引导“选择”组件。</p><p id="2624" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续讨论列表组件。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="ef52" class="ld le jg mw b gy na nb l nc nd">export const List = ({ pets }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;div className="row mt-4"&gt;<br/>        &lt;div className="col-sm-8"&gt;<br/>          &lt;table className="table table-striped"&gt;<br/>            &lt;thead&gt;<br/>              &lt;tr&gt;<br/>                &lt;td className="w-25"&gt;<br/>                  &lt;p&gt; Pet &lt;/p&gt;<br/>                &lt;/td&gt;<br/>                &lt;td className="w-30"&gt;<br/>                  &lt;p&gt; Category&lt;/p&gt;<br/>                &lt;/td&gt;<br/>                &lt;td className="w-50"&gt;<br/>                  &lt;p&gt; Customer&lt;/p&gt;<br/>                &lt;/td&gt;<br/>                &lt;td className="w-50"&gt;<br/>                  &lt;p&gt; Action&lt;/p&gt;<br/>                &lt;/td&gt;<br/>              &lt;/tr&gt;<br/>            &lt;/thead&gt;<br/>            &lt;tbody&gt;<br/>              {pets.map((item) =&gt; {<br/>                return (<br/>                  &lt;tr key={item.id}&gt;<br/>                    &lt;td&gt;{item.name}&lt;/td&gt;<br/>                    &lt;td&gt;{item.category}&lt;/td&gt;<br/>                    &lt;td&gt;{item.inCareOf?.name}&lt;/td&gt;<br/>                    &lt;td&gt;<br/>                      {item.status === "AVAILABLE" ? (<br/>                        &lt;CheckOut petId={item.id} /&gt;<br/>                      ) : (<br/>                        &lt;CheckIn petId={item.id} /&gt;<br/>                      )}<br/>                    &lt;/td&gt;<br/>                  &lt;/tr&gt;<br/>                );<br/>              })}<br/>            &lt;/tbody&gt;<br/>          &lt;/table&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>      ;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="311f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也只是一个表示组件，将呈现一个宠物列表。它还有一个签入/签出组件，接受一个宠物id作为道具。让我们稍后回到签入/签出组件。</p><p id="49af" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建容器组件之前，让我们编写第一个Apollo客户端钩子。使用以下代码在Hooks文件夹中创建usePetsHooks.js。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="1d52" class="ld le jg mw b gy na nb l nc nd">import { useQuery } from "<a class="ae jd" href="http://twitter.com/apollo/client" rel="noopener ugc nofollow" target="_blank">@apollo/client</a>";<br/>import gql from "graphql-tag";</span><span id="54f9" class="ld le jg mw b gy ne nb l nc nd">const petFieldsQuery = gql`<br/>  fragment petFields on Pet {<br/>    id<br/>    name<br/>    category<br/>    status<br/>    inCareOf {<br/>      name<br/>    }<br/>  }<br/>`;</span><span id="0138" class="ld le jg mw b gy ne nb l nc nd">export const filterPetsQuery = gql`<br/>  query petsQuery($status: PetStatus) {<br/>    allPets(status: $status) {<br/>      ...petFields<br/>    }<br/>  }<br/>  ${petFieldsQuery}<br/>`;</span><span id="4bca" class="ld le jg mw b gy ne nb l nc nd">export default (status) =&gt; {<br/>  return useQuery(filterPetsQuery, {<br/>    fetchPolicy: "network-only",<br/>    variables: {<br/>      status: status,<br/>    },<br/>  });<br/>};</span></pre><p id="7c91" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用Apollo客户端的useQuery钩子来获取GraphQL数据。对useQuery的调用返回一个对象，该对象的属性包括loading、error、data和refetch函数。当我们使用签入/签出功能时，我们将研究如何使用refetch函数。我还将fetchPolicy保持为“仅网络”，因为我们对这个项目中的缓存查询结果不感兴趣。</p><p id="fd8b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要确保当我们签入/签出时，列表会刷新，这样当前的宠物就会从列表中消失。还记得useQuery返回一个refetch函数吗？当我们签入一只宠物时，我们想从签入组件中调用这个refetch函数。我们如何在不使列表组件成为refetch的传递组件的情况下做到这一点？</p><p id="5f84" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是使用上下文API，这样我们就不必通过List组件手工将props传递给CheckIn/CheckOut组件。因此，使用API我们可以创建一个新的上下文。使用以下代码创建一个文件refetchProvider.js。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="84ee" class="ld le jg mw b gy na nb l nc nd">import React from "react";<br/>export const PetsContext = React.createContext({});<br/>export const PetsProvider = PetsContext.Provider;</span></pre><p id="0c3d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Provider可以包含任何值，也可以是函数(动作)。在下一节中，我们将把refetch函数设置为provider值。</p><p id="44a9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来让我们创建容器组件ListContainer.js。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="5824" class="ld le jg mw b gy na nb l nc nd">export const ListContainer = () =&gt; {</span><span id="3344" class="ld le jg mw b gy ne nb l nc nd">const petStatus = [<br/>    { key: 1, id: null, name: "All" },<br/>    { key: 2, id: "AVAILABLE", name: "Available" },<br/>    { key: 3, id: "CHECKEDOUT", name: "Checked Out" },<br/>  ];<br/>const [selectedStatus, setSelectedStatus] = useState(() =&gt; null);</span><span id="c27f" class="ld le jg mw b gy ne nb l nc nd">const { loading, error, data, refetch } = usePetsQuery(<br/>    selectedStatus ? selectedStatus.id : null<br/>  );</span><span id="8ae7" class="ld le jg mw b gy ne nb l nc nd">const onSelectStatus = (status) =&gt; {<br/>    setSelectedStatus(status);<br/>  };</span><span id="e64a" class="ld le jg mw b gy ne nb l nc nd">const onRefetch = () =&gt; {<br/>    refetch();<br/>  };</span><span id="0c3c" class="ld le jg mw b gy ne nb l nc nd">if (loading) return "Loading...";<br/>if (error) return `Error! ${error.message}`;</span><span id="fe50" class="ld le jg mw b gy ne nb l nc nd">return (<br/>    &lt;&gt;<br/>      &lt;Container className="mt-4"&gt;<br/>        &lt;Form&gt;<br/>          &lt;Form.Row&gt;<br/>            &lt;SelectStatus<br/>              petStatus={petStatus}<br/>              onSelect={onSelectStatus}<br/>              defaultValue={selectedStatus}<br/>            /&gt;<br/>            &lt;div className="ml-auto"&gt;<br/>              &lt;Logout /&gt;<br/>            &lt;/div&gt;<br/>          &lt;/Form.Row&gt;<br/>        &lt;/Form&gt;<br/>        &lt;PetsProvider value={() =&gt; onRefetch()}&gt;<br/>          &lt;List pets={data.allPets} /&gt;<br/>        &lt;/PetsProvider&gt;<br/>      &lt;/Container&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="6031" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用容器模式，这样我们可以将状态和事件与表示组件分开。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="7c2a" class="ld le jg mw b gy na nb l nc nd">const [selectedStatus, setSelectedStatus] = useState(() =&gt; null);</span></pre><p id="3bd3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们使用React.useState来维护选择下拉菜单的状态。useState返回一个数组，我们可以使用ES6析构语法来访问这些值。当我们更改选择过滤器时，我们需要重新呈现整个列表组件，updater函数(setSelectedStatus)将负责这项工作。</p><p id="28ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意我们如何将列表组件包装到PetsProvider中。这有助于我们在每个组件中使用上下文。我们将很快在CheckIn组件中看到这一点。</p><p id="f705" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于签入功能，让我们创建一个签入组件。</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="d425" class="ld le jg mw b gy na nb l nc nd">export const CheckIn = ({ petId }) =&gt; {</span><span id="7803" class="ld le jg mw b gy ne nb l nc nd">const refetch = useContext(PetsContext);</span><span id="8309" class="ld le jg mw b gy ne nb l nc nd">const doCheckIn = useCheckInMutation();<br/>  const checkIn = () =&gt; {<br/>    doCheckIn(<br/>      {<br/>        variables: { petId: petId },<br/>      },<br/>      { refetchQueries: [`petsQuery`] }<br/>    )<br/>      .then((_) =&gt; {<br/>        refetch();<br/>      })<br/>      .catch((e) =&gt; console.log(e));<br/>  };</span><span id="3208" class="ld le jg mw b gy ne nb l nc nd">if (!isLoggedIn()) {<br/>    return null;<br/>  }</span><span id="8010" class="ld le jg mw b gy ne nb l nc nd">return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; checkIn()} className="btn btn-link"&gt;<br/>        Check In<br/>      &lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="db70" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从useContext API获得对refetch处理程序的引用。在签入突变发生后，我们将调用refetch()函数，该函数将依次调用ListContainer.js中的onRefetch处理程序。</p><h2 id="6d6b" class="ld le jg bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">结论</h2><p id="ada6" class="pw-post-body-paragraph kd ke jg kf b kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">这是我尝试分享我使用React hooks和Context API所学到的东西。这个示例项目展示了如何使用useState维护本地状态，以及如何将上下文传递给内部组件，只要它们在同一个组件树中的某个位置。你可以在这里 找到更多关于钩子<a class="ae jd" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> <em class="mb">的信息。</em></a></p><p id="ddee" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里  查看<a class="ae jd" href="https://github.com/rajvirtual/react-apollo-graphql-hooks" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> <em class="mb">的完整源代码。</em></strong></a></p><h2 id="2b41" class="ld le jg bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="a520" class="pw-post-body-paragraph kd ke jg kf b kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae jd" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf jh">AI in Plain English</strong></a><a class="ae jd" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf jh">UX in Plain English</strong></a><a class="ae jd" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf jh">Python in Plain English</strong></a><strong class="kf jh"/>——谢谢，继续学习！</p><p id="49ff" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jd" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">submissions @ plain English . io</strong></a><strong class="kf jh"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>