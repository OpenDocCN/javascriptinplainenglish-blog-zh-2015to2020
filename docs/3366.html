<html>
<head>
<title>The Complete Flow And Design Of Redux in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">还原反应的全流程和设计</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redux-in-react-complete-flow-and-design-5a0e96d99b69?source=collection_archive---------5-----------------------#2020-09-23">https://javascript.plainenglish.io/redux-in-react-complete-flow-and-design-5a0e96d99b69?source=collection_archive---------5-----------------------#2020-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da19" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">如果</em> <strong class="ak"> <em class="kf">反应过来</em> </strong> <em class="kf">就是力量，那么</em> <strong class="ak"> <em class="kf">反应过来——热毒的</em> </strong> <em class="kf">就是你的超能力。</em></h2></div><p id="45f2" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">状态变化是React做出反应并触发DOM重新呈现的唯一事情。<em class="lc">状态是一条数据，您可以在其中存储属于组件的属性</em>。随着应用程序的增长，管理状态可能很困难。组件之间的数据传输可能会变得非常困难，并且涉及到一长串的道具，这并不是一种优雅的方式。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/a9a0df73f117eaea75990e2a7f4eca19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEFjglTwlDi7SOmgidFXWQ.png"/></div></div></figure><p id="a672" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们将数据从一个组件发送到另一个组件，但是如果最终所有的东西都是JavaScript，并且我们将JS文件打包作为输出，那么为什么我们不能设置一个全局变量来保存我们整个应用程序的状态呢？我们可以简单地从一个组件更新全局变量，并从另一个组件访问它，而不是将数据从一个组件传递到另一个组件。它将解决管理国家和长支柱链的问题。</p><p id="d700" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">问题在于，reactor不会对以这种方式定义的全局变量中的任何更改做出反应。这就是Redux通过提供一个<strong class="ki ir">中心商店来拯救自己的地方。</strong></p><h1 id="f0a2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak">热毒</strong></h1><p id="6c1d" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated">Redux将这个全局变量作为<strong class="ki ir">中心存储</strong>提供给我们，并为我们提供更新存储(状态)的流程或过程，以便对其做出反应。</p><p id="09cf" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">Redux的构建模块:</p><ol class=""><li id="e2ba" class="mm mn iq ki b kj kk km kn kp mo kt mp kx mq lb mr ms mt mu bi translated"><strong class="ki ir">中央存储区:</strong>存储整个应用程序状态的巨大js对象</li><li id="5076" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb mr ms mt mu bi translated"><strong class="ki ir">动作:</strong>部件向减速机发送的带类型(描述)的信息包</li><li id="b693" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb mr ms mt mu bi translated"><strong class="ki ir">reductor:</strong>一个简单的js函数，接收旧的状态和动作作为输入，返回更新的状态。它应该只是输入和输出，没有延迟</li><li id="cc36" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb mr ms mt mu bi translated"><strong class="ki ir">订阅:</strong>每当商店状态更新时在组件中触发</li><li id="8e83" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb mr ms mt mu bi translated"><strong class="ki ir"> mapStateToProps: </strong>它将我们需要的部分状态(全局变量)映射到组件道具<br/>中注意:<strong class="ki ir"><em class="lc">use selector</em></strong><em class="lc">hook是一种新的&amp;clean way</em></li><li id="9497" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb mr ms mt mu bi translated"><strong class="ki ir">mapdispatchtrops:</strong>它把你想要调度的动作映射到道具的组成部分<br/>中注意:<strong class="ki ir"><em class="lc">used is patch</em></strong><em class="lc">hook是一种新的&amp;clean way</em></li><li id="3276" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb mr ms mt mu bi translated"><strong class="ki ir">连接:</strong>该功能用于配置组件中的mapStateToProps和mapDispatchToProps】注意:<em class="lc">如果使用useSelector useDispatch</em>则不需要</li></ol><h1 id="8e06" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak">理论</strong></h1><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi na"><img src="../Images/6742c567b923d872a0514b9a5e22a567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u957afVw94Zq5N2R6s1FQ.png"/></div></div></figure><ul class=""><li id="18e6" class="mm mn iq ki b kj kk km kn kp mo kt mp kx mq lb nb ms mt mu bi translated">首先创建一个减速器并存储(全局变量)并连接它们</li><li id="a5d1" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb nb ms mt mu bi translated">从具有类型(描述)的组件调度动作，该动作将到达缩减器<em class="lc">(这里，我们从一个组件发起状态改变)</em></li><li id="0122" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb nb ms mt mu bi translated">到达reducer后，将应用某种逻辑(基于类型),它将返回一个更新的状态(全局变量)</li><li id="062d" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb nb ms mt mu bi translated">一旦reducer更新状态(全局变量)<em class="lc">(在这里，我们可以访问另一个组件中更新的状态)</em>，组件中的所有订阅都将被触发</li><li id="c630" class="mm mn iq ki b kj mv km mw kp mx kt my kx mz lb nb ms mt mu bi translated">在订阅中，我们必须指定我们需要状态(全局变量)的哪一部分，即mapStateToProps，以及我们需要通过connect函数调度什么操作，即mapDispatchToProps。</li></ul><p id="44dd" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">注:</strong>动作既没有直达店铺，也没有任何逻辑。它只是一个信使。只有减速器可以更新存储，因此<strong class="ki ir"> <em class="lc">减速器与存储</em> </strong>紧密相连。</p><h1 id="05be" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak">让我们开始</strong></h1><h2 id="5b00" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak"> 1。安装Redux </strong></h2><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="e496" class="nc lq iq np b gy nt nu l nv nw">npm install redux</span></pre><h2 id="150f" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak"> 2。创建一个减速器</strong></h2><p id="7d41" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated">因为我们需要在创建存储时在<strong class="ki ir"> createStore </strong>函数中传递一个reducer，因为<em class="lc">存储和reducer是强连接的</em>。</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="5196" class="nc lq iq np b gy nt nu l nv nw">const initialState = {<br/>  rank: 1,<br/>  userName: 'ABC',<br/>  country: 'India',<br/>  profession: 'Software Engineer',<br/>};<br/>const reducer = (state = initialState, action) =&gt; {<br/>  return { ...state };<br/>};<br/>export default reducer;</span></pre><h2 id="caee" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak"> 3。使用创建的减速器</strong>创建商店</h2><p id="eca2" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated">Index.js是在我们的应用程序启动之前创建商店的好地方。</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="7b9d" class="nc lq iq np b gy nt nu l nv nw">import { createStore } from 'redux';<br/>const store = createStore(reducer);</span></pre><h2 id="0871" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak"> 4。连接商店以作出反应</strong></h2><p id="1101" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated">现在，我们已经使用redux创建了一个存储，但是我们需要将它与react连接起来，以便react知道它。为此，我们需要一个包<strong class="ki ir"> react-redux。</strong></p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="d90f" class="nc lq iq np b gy nt nu l nv nw">npm install react-redux</span></pre><p id="4b52" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">React-redux为我们提供Provider，Provider包装我们的app并注入到store中。Provider是一个助手组件，它允许我们将存储注入到react组件中。我们需要在provider中传递特殊属性<strong class="ki ir"> store </strong>，并在其中传递我们创建的store。</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="59a3" class="nc lq iq np b gy nt nu l nv nw">import { Provider } from 'react-redux';</span><span id="88eb" class="nc lq iq np b gy nx nu l nv nw">ReactDOM.render(&lt;Provider store={store}&gt;<br/>                   &lt;App /&gt;<br/>                &lt;/Provider&gt;, document.getElementById("root"));</span></pre><p id="9237" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这样，我们的<em class="lc">商店就连接到了react应用程序</em>。</p><h2 id="237c" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak"> 5。在组件</strong>内访问存储、调度动作和订阅</h2><p id="4f05" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated">我们不能使用store.getState()或类似store.dispatch()的操作直接访问组件中的商店，这是行不通的。React-Redux应该能够为我们处理这个问题，为此它为我们提供了<strong class="ki ir"> connect </strong>函数。</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="81bf" class="nc lq iq np b gy nt nu l nv nw">Syntax of connect,</span><span id="986e" class="nc lq iq np b gy nx nu l nv nw">export default connect(<strong class="np ir"><em class="lc">mapStateToProps, </em>mapDispatchToProps)</strong>(ComponentA)</span></pre><p id="3a02" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">Connect接受两个参数，分别是<strong class="ki ir">mapStateToProps<em class="lc"/></strong><em class="lc">(您想要的状态的一部分)和</em><strong class="ki ir"><em class="lc"/>mapdispatctoprops</strong>(<em class="lc">您想要调度的动作</em> ) <strong class="ki ir">。</strong>让我们来看看细节:</p><h2 id="90c3" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak"> 5.1。访问商店</strong></h2><p id="fc86" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated"><strong class="ki ir">从中央状态</strong>(或者存储)你想要在组件中的那部分状态，或者从庞大的JS对象中你需要的值。</p><p id="809a" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在第一个参数中，我们将创建一个变量mapStateToProps，它存储一个函数，并期望将存储在Redux中的状态作为输入，并返回一个js对象，该对象映射组件的Props中所有传递的属性。</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="9719" class="nc lq iq np b gy nt nu l nv nw">const <strong class="np ir"><em class="lc">mapStateToProps</em></strong> = centralState =&gt; {<br/>  return {<br/>    rank: centralState.rank,<br/>    name: centralState.userName,<br/>  };<br/>};</span></pre><p id="e84e" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">考虑一下，我们在中央存储中有四个属性:<em class="lc"> rank、username、country、</em>和<em class="lc"> profession、</em>，但是我们只对<em class="lc"> rank </em>和user <em class="lc"> name、</em>感兴趣，所以我们可以在mapStateToProps内部的对象中传递rank和username。这被称为状态的一部分，这些值将被映射到组件的属性中。可以在组件中以<em class="lc"> props.rank </em>和<em class="lc"> props.userName的形式访问。</em></p><p id="d4ea" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">注意:</strong>这个函数最终会被react-redux调用，因为我们会将它传递给connect。这只是配置我们需要的部件的一种方式。</p><h2 id="8b77" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak"> 5.2。调度动作</strong></h2><p id="5122" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated"><strong class="ki ir">您想要从组件</strong>分派的动作将到达reducers并更新状态。</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="2281" class="nc lq iq np b gy nt nu l nv nw">const <strong class="np ir">mapDispatchToProps</strong> = dispatch =&gt; {<br/>  return {<br/>    incRank: () =&gt; dispatch({ type: "RANK" })<br/>  };<br/>};</span></pre><p id="3819" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在第二个参数中，mapDispatchToProps存储一个函数，并期待来自Redux的dispatch方法，并返回一个对象，该对象将在组件的Props中映射该函数的引用。</p><p id="fafe" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这里，incRank将被存储在保存fn引用的组件的props中，并且可以在需要时被调度。现在，您只需点击一个按钮，即可发送该邮件:</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="be29" class="nc lq iq np b gy nt nu l nv nw">&lt;button onClick={<strong class="np ir">props.incRank</strong>}&gt;<br/>        Rank Count<br/>&lt;/button&gt;</span></pre><p id="1a68" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在我们需要在<strong class="ki ir"> connect </strong>函数中传递这两个参数。</p><pre class="le lf lg lh gt no np nq nr aw ns bi"><span id="bce3" class="nc lq iq np b gy nt nu l nv nw">import React from "react";<strong class="np ir"><br/>import { connect } from "react-redux";</strong></span><span id="dbd5" class="nc lq iq np b gy nx nu l nv nw">const UserComponent = props =&gt; {<br/>  return (<br/>  .....<br/>  );<br/>};</span><span id="cb34" class="nc lq iq np b gy nx nu l nv nw">const mapStateToProps = centralState =&gt; {<br/>  return {<br/>  .....<br/>  };<br/>};</span><span id="c511" class="nc lq iq np b gy nx nu l nv nw">const mapDispatchToProps = dispatch =&gt; {<br/> .....<br/>};</span><span id="ac81" class="nc lq iq np b gy nx nu l nv nw"><strong class="np ir">export default connect(mapStateToProps, mapDispatchToProps)(UserComponent);</strong></span></pre><p id="50d0" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir"> <em class="lc">注:</em> </strong> <em class="lc">以上事情(访问存储即mapStateToProps</em><strong class="ki ir"><em class="lc"/></strong><em class="lc">和调度动作即mapDispatchToProps)现在可以很容易地完成，而不需要使用connect complications。通过使用钩子，上面的代码在使用connect时也是有效的，但是使用这些钩子要干净得多。</em></p><p id="72dc" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir"> <em class="lc"> useSelector:获取状态(或状态的一部分)<br/> useDispatch:分派动作</em> </strong></p><h2 id="1424" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated">上下文API能代替Redux吗？</h2><p id="317b" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated">在小型项目中可以避免Redux，因为它会增加开发人员的复杂性。React内置了上下文API，因此我们不需要任何额外的依赖。它的尺寸更小，实现更简单。然而，目前<em class="lc">上下文API对于低频率更新(例如认证)</em>是好的，但是对于你的应用的状态管理是不好的。</p><h2 id="654b" class="nc lq iq bd lr nd ne dn lv nf ng dp lz kp nh ni mb kt nj nk md kx nl nm mf nn bi translated"><strong class="ak">下一步(又名“你接下来应该学什么”)</strong></h2><p id="62aa" class="pw-post-body-paragraph kg kh iq ki b kj mh jr kl km mi ju ko kp mj kr ks kt mk kv kw kx ml kz la lb ij bi translated"><strong class="ki ir"> <em class="lc">中间件</em> : </strong>中间件是可以添加在两个进程之间执行某些操作的一段代码。我们之前了解到，reducers不应该处理任何复杂的任务，而应该只是输入和输出，没有延迟。所以对于异步代码，我们可以添加中间件(Thunk，Saga)。</p></div></div>    
</body>
</html>