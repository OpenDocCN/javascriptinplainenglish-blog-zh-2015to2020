<html>
<head>
<title>Principles of Functional Programming in JavaScript That Will Make Your Coding Life Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数式编程原则将使您的编码生活更加简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/principles-of-functional-programming-in-javascript-that-will-make-your-coding-life-easier-ed1416d2b726?source=collection_archive---------5-----------------------#2020-10-14">https://javascript.plainenglish.io/principles-of-functional-programming-in-javascript-that-will-make-your-coding-life-easier-ed1416d2b726?source=collection_archive---------5-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3311" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写更安全的代码和限制副作用的方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/797e3d50b856c0e8fbbae82eb945353a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wzr36m1oTlLMVcr2"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shahadat Rahman</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有谁爱写没有副作用的函数？</p><p id="e617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想我们作为程序员都是这样。</p><p id="d63e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，在这个故事中，我将带你了解函数式编程的基本原则，这些原则将使你的编码生活变得更容易。</p><p id="f9b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。</p><h1 id="2cc6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.纯函数</h1><p id="a2d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">说到纯函数，你只需要记住两件事:</p><ul class=""><li id="29af" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">如果给定相同的参数，它们将返回相同的结果。</li><li id="de88" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">它们不会引起任何副作用。</li></ul><h2 id="ed90" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">如果给定相同的参数，则返回相同的结果</h2><p id="18e8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们看看下面这个简单的例子:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="758e" class="nd lt iq nq b gy nu nv l nw nx">const DISCOUNT = 0.5;</span><span id="a41c" class="nd lt iq nq b gy ny nv l nw nx">const calculatePrice = price =&gt; price * DISCOUNT;</span><span id="d254" class="nd lt iq nq b gy ny nv l nw nx">let actualPrice = calculatePrice(15); // 7.5</span></pre><p id="ef1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<strong class="ky ir"> calculatePrice </strong>纯吗？不，不是的。</p><p id="3851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么？因为全局变量<strong class="ky ir"> DISCOUNT </strong>没有作为参数传递给函数。如果您改变<strong class="ky ir">折扣的</strong>值，返回的结果也会改变，尽管参数<strong class="ky ir">价格</strong>保持不变。</p><p id="5439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使它成为纯函数，你必须像这样给函数增加一个参数:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="c243" class="nd lt iq nq b gy nu nv l nw nx">const DISCOUNT = 0.5;</span><span id="809b" class="nd lt iq nq b gy ny nv l nw nx">const calculatePrice = (price, discount) =&gt; price * discount;</span><span id="54be" class="nd lt iq nq b gy ny nv l nw nx">let actualPrice = calculatePrice(15, DISCOUNT); // 7.5</span></pre><p id="85a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，它满足了纯函数的第一法则。</p><p id="8ec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果给定相同的参数，并不总是能够写出返回相同结果的函数。你不需要担心，因为这不是一件坏事。你怎么能指望一个每次执行都返回随机数的函数是纯函数呢？</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="3c60" class="nd lt iq nq b gy nu nv l nw nx">const saySomething = threshold =&gt; {<br/>  if (Math.random() &gt; threshold) {<br/>    return ‘I am something’;<br/>  } else {<br/>    return ‘I am something else’;<br/>  }<br/>}</span><span id="1afa" class="nd lt iq nq b gy ny nv l nw nx">saySomething(0.5);</span></pre><h2 id="4dc8" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">不要引起副作用</h2><p id="fb70" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">什么是副作用？</p><p id="018e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个函数被调用时，它不仅返回一个值，还会改变一些东西，比如一个全局变量或者一个引用参数。副作用使得函数不可预测。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="3159" class="nd lt iq nq b gy nu nv l nw nx">let totalPrice = 15;</span><span id="20f7" class="nd lt iq nq b gy ny nv l nw nx">const calculateFinalPrice = discount =&gt; {<br/>  if (totalPrice &gt; 10) {<br/>    totalPrice = totalPrice * discount;<br/>  }<br/>  <br/>  return totalPrice;<br/>}</span><span id="445b" class="nd lt iq nq b gy ny nv l nw nx">console.log(calculateFinalPrice(0.2)); // 3<br/>console.log(totalPrice); // 3</span></pre><p id="d267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的示例中，变量<strong class="ky ir"> totalPrice </strong>满足条件，它被更改为新值。</p><p id="ceb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从长远来看，改变函数范围之外的东西通常会导致难以控制你的源代码，所以你需要使它纯净。</p><p id="76a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们不直接将新值赋给全局变量，而是仅用于计算并返回最终结果。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="4ff8" class="nd lt iq nq b gy nu nv l nw nx">let totalPrice = 15;</span><span id="3cff" class="nd lt iq nq b gy ny nv l nw nx">const calculateFinalPrice = discount =&gt; {<br/>  let finalPrice = totalPrice;<br/>  <br/>  if (finalPrice &gt; 10) {<br/>    finalPrice = finalPrice * discount;<br/>  }<br/> <br/>  return finalPrice;<br/>}</span><span id="21ae" class="nd lt iq nq b gy ny nv l nw nx">console.log(calculateFinalPrice(0.2)); // 3<br/>console.log(totalPrice); // 15</span></pre><p id="f915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于给定的输入，纯函数总是返回相同的结果。您应该努力构建稳定的应用程序，并使您的源代码更易于测试。</p><h1 id="3813" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.不变</h1><p id="ed37" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">回头看看上面的例子，你可以看到我没有直接修改变量<strong class="ky ir"> totalPrice </strong>，我得到了一个新变量，并对它做了一些修改。</p><p id="5f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是不变性的概念，一个物体应该是不随时间变化的，或者我们应该强迫它不变。这样，您的代码更安全，更可控。一般来说，您可以通过使事情不可变来避免意外的行为。</p><p id="a87e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然JavaScript中的基本类型是不可变的，但对象和数组的行为相反，这些类型的数据结构可以改变。</p><p id="c526" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以原始类型为例:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="18db" class="nd lt iq nq b gy nu nv l nw nx">let totalPrice = 13;<br/>let finalPrice = totalPrice;<br/>finalPrice = finalPrice * 0.3;</span><span id="3a55" class="nd lt iq nq b gy ny nv l nw nx">console.log(totalPrice); // 13<br/>console.log(finalPrice); // 3.9</span></pre><p id="00c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你给一个基本变量赋值时，实际值被赋值。这就是为什么在上面的例子中，虽然我们首先将<strong class="ky ir"> totalPrice </strong>分配给了<strong class="ky ir"> finalPrice </strong>，但是<strong class="ky ir"> finalPrice </strong>的变化并不影响<strong class="ky ir"> totalPrice </strong>的值。</p><p id="cd7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象和数组的作用方式不同:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="2665" class="nd lt iq nq b gy nu nv l nw nx">let languages = [‘JavaScript’, ‘C++’, ‘Kotlin’, ‘Golang’];<br/>let clonedLanguages = languages;<br/>clonedLanguages[0] = ‘Java’;</span><span id="cdc7" class="nd lt iq nq b gy ny nv l nw nx">console.log(clonedLanguages); // [“Java”, “C++”, “Kotlin”, “Golang”]<br/>console.log(languages); // [“Java”, “C++”, “Kotlin”, “Golang”]</span></pre><p id="baa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您将一个对象或数组分配给另一个对象或数组时，您分配的是对包含实际值的内存的引用。这就是为什么在上面的例子中，改变<strong class="ky ir">克隆语言</strong>的值会导致<strong class="ky ir">语言</strong>的相同变化，因为它们都指向内存中的同一个地址。</p><p id="573f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">起初，当接近不变性时，你会觉得有点烦人。是的，您必须通过在流程中创建新实例来编写更多代码。然而，从长远来看，你会感谢这种恼人的行为，因为它有助于避免意想不到的行为。如果你在基于反应的项目中使用redux，你就会明白我的意思。</p><h1 id="5c3b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.对透明性有关的</h1><p id="a183" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">与纯函数类似，参照透明度被定义为一个表达式，它可以被它的值替换，而不改变程序的结果。您也可以将其理解为一个函数，它总是为相同的给定参数返回相同的值，并且不会引起任何副作用。</p><p id="f675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8912" class="nd lt iq nq b gy nu nv l nw nx">const sumOf = (a, b) =&gt; a + b;</span><span id="5bdb" class="nd lt iq nq b gy ny nv l nw nx">sumOf(2, 3); // 5</span></pre><p id="4de6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您在示例中所见，它是参照透明的，因为在任何给定的<strong class="ky ir"> a </strong>和<strong class="ky ir"> b </strong>的情况下，<strong class="ky ir"> sumOf(a，b) </strong>的结果保持不变。</p><p id="4abe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">什么时候它不是参照透明的？看看上面例子的一个简单变化。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="3424" class="nd lt iq nq b gy nu nv l nw nx">const sumOf = (a, b) =&gt; {<br/>  console.log(a, b);<br/>  return a + b;<br/>}</span><span id="ea72" class="nd lt iq nq b gy ny nv l nw nx">const take1 = (a, b) =&gt; {<br/>  let result = sumOf(a, b);<br/>  return result + result;<br/>}</span><span id="f4d3" class="nd lt iq nq b gy ny nv l nw nx">const take2 = (a, b) =&gt; {<br/>  return sumOf(a, b) + sumOf(a, b);<br/>}</span><span id="bf60" class="nd lt iq nq b gy ny nv l nw nx">take1(1, 2);<br/>take2(1, 2);</span></pre><p id="429a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会认为<strong class="ky ir"> take1(1，2) </strong>和<strong class="ky ir"> take2(1，2) </strong>的结果是一样的，是6。然而，事实并非如此。<strong class="ky ir"> take1 </strong>只打印一次日志，而<strong class="ky ir"> take2 </strong>打印两次日志。以下是实际结果:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="d775" class="nd lt iq nq b gy nu nv l nw nx">take1(1, 2); // 1 2 result = 6<br/>take2(1, 2); // 1 2 1 2 result = 6</span></pre><p id="5df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么要关心引用透明度？因为它使您的代码可测试和可预测，所以您可以在编写每一行代码时避免任何不确定性。</p><h1 id="ddbc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.一流的功能</h1><p id="fe4d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当谈到第一类函数时，我们指的是被视为对象的函数。这意味着您可以将函数作为参数传递给其他函数，甚至作为其他函数的结果返回一个函数。JavaScript就是这样对待函数的。</p><p id="1015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们使用函数作为值，所以我们可以将它们存储在变量、对象和数组中。</p><p id="6d58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><p id="3ffd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为变量分配函数:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="336c" class="nd lt iq nq b gy nu nv l nw nx">const sum = (a, b) =&gt; a + b;</span></pre><p id="4b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将函数作为参数传递:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="c417" class="nd lt iq nq b gy nu nv l nw nx">const averageOfTwo = (sum, a, b) =&gt; sum(a, b) / 2;</span></pre><p id="89ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果返回一个函数:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="4924" class="nd lt iq nq b gy nu nv l nw nx">const operation = (a, b) =&gt; {<br/>  return (a, b) =&gt; a + b;<br/>}</span><span id="bab7" class="nd lt iq nq b gy ny nv l nw nx">const op = operation(3, 5);<br/>console.log(op(5, 3)); // 8</span></pre><h1 id="9439" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.高阶函数</h1><p id="96c1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果满足以下条件，则函数为高阶函数:</p><ul class=""><li id="afcc" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">它采用其他函数作为参数。</li><li id="53c7" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">或者它返回一个函数作为结果。</li></ul><p id="04aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高阶函数可以缩短代码并使其更简单，从而减少错误并增加可读性。</p><p id="f9f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript中一些常见的高阶函数，您很可能使用过，但直到现在才知道这个概念:</p><h2 id="063e" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">。地图</h2><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="ed4f" class="nd lt iq nq b gy nu nv l nw nx">const names = [‘Amy’, ‘James’, ‘Tom’];<br/>const uppercasedNames = names.map(name =&gt; name.toUpperCase());</span><span id="e302" class="nd lt iq nq b gy ny nv l nw nx">console.log(uppercasedNames); // [“AMY”, “JAMES”, “TOM”]</span></pre><h2 id="3c86" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">。为每一个</h2><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="f578" class="nd lt iq nq b gy nu nv l nw nx">const names = [‘Amy’, ‘James’, ‘Tom’];</span><span id="7540" class="nd lt iq nq b gy ny nv l nw nx">names.forEach(name =&gt; console.log(name));</span></pre><h2 id="3f6d" class="nd lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">。过滤器</h2><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8f78" class="nd lt iq nq b gy nu nv l nw nx">const numbers = [3, 4, 1, 6, 7, 10];<br/>const evenNumbers = numbers.filter(number =&gt; number % 2 === 0);</span><span id="8ee3" class="nd lt iq nq b gy ny nv l nw nx">console.log(evenNumbers); // [4, 6, 10]</span></pre><h1 id="0daf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="1861" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">函数式编程是一个很好的标准，您应该遵循它来提高代码的质量和可维护性。</p><p id="d2a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述概念是函数式编程的基础，它将帮助你让其他程序员喜欢你的编码方式。</p><p id="e2f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这个故事对你有用。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="b094" class="ls lt iq bd lu lv og lx ly lz oh mb mc jw oi jx me jz oj ka mg kc ok kd mi mj bi translated">进一步阅读</h1><div class="ol om gp gr on oo"><a href="https://medium.com/javascript-in-plain-english/11-javascript-concepts-every-web-developer-should-know-to-take-their-skills-to-the-next-level-37ef6693111a" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">每个Web开发人员都应该知道的11个JavaScript概念，让他们的技能更上一层楼</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">不了解这些概念，就无法掌握JavaScript。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div></div></div>    
</body>
</html>