<html>
<head>
<title>🧠 Memory leaks and Garbage Collection 🗑️ in JavaScript.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的🧠内存泄漏和垃圾收集🗑️。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/memory-leaks-and-garbage-collection-%EF%B8%8F-in-javascript-you-need-to-know-this-3fa8173e8b3c?source=collection_archive---------1-----------------------#2019-10-12">https://javascript.plainenglish.io/memory-leaks-and-garbage-collection-%EF%B8%8F-in-javascript-you-need-to-know-this-3fa8173e8b3c?source=collection_archive---------1-----------------------#2019-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0cdb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">你应该知道这个</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7daf385d1f471293a1d7472ad96500a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0SgfNK2cbkF9ysDNSehKg.png"/></div></div></figure><p id="e532" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">内存泄漏是每个开发人员最终都要面对的问题。</p><h1 id="1a65" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">什么是内存泄漏？</h1><p id="f1dc" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">本质上，内存泄漏可以定义为应用程序不再需要的内存，由于某种原因，这些内存没有返回到操作系统或空闲内存池。</p><blockquote class="mh mi mj"><p id="3fc5" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">当然，您可以选择不同的内存管理方式，这些方式可能会减少内存泄漏的机会。</p><p id="e2a4" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">但是，某块内存是否闲置，其实是一个不可判定的问题。</p></blockquote></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="7812" class="lk ll in bd lm ln mv lp lq lr mw lt lu jt mx ju lw jw my jx ly jz mz ka ma mb bi translated">Javascript中的内存管理和内存生命周期👇</h1><p id="ba0e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们定义了各种原语、对象、函数等。在我们的节目中。当我们这样做时，JavaScript引擎会在设备的主内存中为它们分配一个空间。不同的浏览器有不同的技术来管理它们的数据。</p><p id="67af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">内存生命周期</strong>在<strong class="kq io"> <em class="mk">高级语言</em> </strong>中，我们只会显式地读写内存(使用内存)。在<strong class="kq io"> <em class="mk">低级语言</em> </strong>中，所有三个步骤开发者都需要明确地照顾到。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/3b88f77e1077058807a09dfc55a084f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dv8mEIH-u0NCaMfOj0mAUA.png"/></div></div></figure><p id="579d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">✅ <strong class="kq io">给变量分配内存。</strong></p><p id="1a54" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">✅ <strong class="kq io">使用已定义的变量。</strong></p><p id="49d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">✅ <strong class="kq io">把它们从记忆中删除。</strong></p><blockquote class="mh mi mj"><p id="77e6" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">我们之所以在学习任何编程语言时都需要理解内存管理的概念，是为了防止内存泄漏。</p><p id="e7ad" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">在任何程序中，内存泄漏都可能导致几个问题，<strong class="kq io"> <em class="in">包括执行缓慢、程序崩溃、</em> </strong>(处理数据时的大延迟)等。</p><p id="e348" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">💡管理内存最重要的任务是检测程序中未使用的变量，并将它们从内存中移除。</p></blockquote><p id="276e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当声明变量时，Javascript会自动为变量分配内存</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/b8fdea549818eb04d7c4ce7f2796a831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSjMDOs4hhJ3rrShMlpQ1w.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">define various primitives</figcaption></figure><p id="e40b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当不再需要该内存时，分配的内存将被释放。内存泄漏和大多数与内存相关的问题都是在释放内存时出现的。最难的部分是找到不再需要的内存，并由<strong class="kq io">垃圾收集器</strong>找到。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="561d" class="lk ll in bd lm ln mv lp lq lr mw lt lu jt mx ju lw jw my jx ly jz mz ka ma mb bi translated">垃圾收集工👇</h1><blockquote class="mh mi mj"><p id="659d" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">垃圾收集语言中泄漏的主要原因是不需要的引用。" via<a class="ae ng" href="http://twitter.com/auth0" rel="noopener ugc nofollow" target="_blank">@ auth 0</a><a class="ae ng" href="http://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" rel="noopener ugc nofollow" target="_blank">http://auth 0 . com/blog/four-types-of-leaks-in-your-JavaScript-code-and-how-to-get-off-them/</a></p></blockquote><p id="1452" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript使用垃圾收集器来决定一段代码是否需要内存。大多数垃圾收集器使用一种叫做<strong class="kq io"> <em class="mk">标记-清除</em> </strong>的算法。</p><p id="cfed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">简单来说，算法“<strong class="kq io"><em class="mk"/></strong>”由以下步骤组成:</p><p id="2c29" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">1️⃣ <strong class="kq io">垃圾收集器建立了一个“根”列表。</strong></p><p id="1cb0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">根通常是全局变量，对它的引用保存在代码中。<strong class="kq io">窗口</strong>对象始终存在，因此垃圾收集器可以认为它及其所有子对象始终存在(即<strong class="kq io"> <em class="mk">不是垃圾</em> </strong>)。</p><p id="454c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2️⃣ <strong class="kq io">所有根都被检查并标记为活动。</strong></p><p id="b1c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所有的子节点也被递归地检查。从一个根<strong class="kq io"> <em class="mk">可以到达的一切都不被认为是垃圾</em> </strong>。</p><p id="2231" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3️⃣ <strong class="kq io">所有没有被标记为活动的内存现在都被认为是垃圾。</strong></p><p id="a9fe" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">收集器现在可以释放内存并将其返回给操作系统。</p><blockquote class="mh mi mj"><p id="2495" class="ko kp mk kq b kr ks jo kt ku kv jr kw ml ky kz la mm lc ld le mn lg lh li lj ig bi translated">现代垃圾收集器以不同的方式改进了这种算法，但本质是相同的:可到达的内存块被如此标记，其余的被视为垃圾。</p></blockquote><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="68e4" class="lk ll in bd lm ln mv lp lq lr mw lt lu jt mx ju lw jw my jx ly jz mz ka ma mb bi translated">三种常见的JavaScript漏洞</h1><p id="1b37" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">👉<strong class="kq io">偶然的全局变量</strong></p><p id="4705" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript允许的方式之一是它处理未声明变量的方式<strong class="kq io">:对未声明变量的引用会在全局对象中创建一个新变量。</strong></p><p id="bb6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在浏览器的情况下，全局对象是一个“<strong class="kq io">窗口</strong>”。例如:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/b445cd0601c66e834331b485808b4f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXfWwppE-CM8w6hDs4Hcdg.png"/></div></div></figure><p id="c47a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，事实上</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/c5995a7e545faaf3e9f40775412bf6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ecg_NpFobehZpbRb7Lu0fw.png"/></div></div></figure><p id="4d9f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果<code class="fe nl nm nn no b"><strong class="kq io">bar</strong></code>应该只保存对<code class="fe nl nm nn no b"><strong class="kq io">someFn</strong></code>函数范围内的变量的引用，而您忘记了使用var来声明它，则会创建一个意外的全局变量。</p><p id="5df6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了防止这些错误发生，请在JavaScript文件的开头添加<code class="fe nl nm nn no b">'<strong class="kq io">use strict</strong>';</code>。这使得解析JavaScript的模式更加严格，可以防止意外的全局变量。</p><div class="np nq gp gr nr ns"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">严格模式</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">ECMAScript 5中引入的JavaScript的严格模式是一种选择JavaScript的受限变体的方式，因此…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">developer.mozilla.org</p></div></div><div class="ob l"><div class="oc l od oe of ob og km ns"/></div></div></a></div><p id="e859" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">👉<strong class="kq io">遗忘的回调或定时器</strong></p><p id="6ba2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">setInterval的使用在JavaScript中相当普遍。大多数库都提供了接受回调的观察器和其他工具。</p><p id="79c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面的例子说明了悬空定时器会发生什么:<strong class="kq io"> <em class="mk">引用不再需要的节点或数据的定时器。</em> </strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/7b46754a9510294bfc96ddff5c804af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsSVmmEDvoOwXqzqAI-RWQ.png"/></div></div></figure><p id="bbd9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由<code class="fe nl nm nn no b">node</code>表示的对象将来可能会被移除，使得区间处理程序中的整个块变得不必要。然而，由于时间间隔仍处于活动状态，处理程序无法被收集(<strong class="kq io">需要停止时间间隔，这样才会发生</strong>)。</p><p id="5aa8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果不能收集间隔处理程序，也不能收集它的依赖项。这意味着，<code class="fe nl nm nn no b">someResource</code>可能存储了相当大的数据，也不能被收集。</p><p id="8658" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">对于观察者</strong>来说，重要的是一旦不再需要它们，就要明确地调用来移除它们</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nk"><img src="../Images/86a45b4853b60c6bfb8b1bb89d5f3a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czktiYoiaJ7iuBP3Dzhk7g.png"/></div></div></figure><p id="b671" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">像<em class="mk"> jQuery e.t.c </em>这样的框架和库确实会在释放节点之前移除监听器。</p><p id="6f44" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是由库内部处理的，确保不会产生泄漏，即使是在有问题的浏览器下运行，如🎃旧的网络浏览器。</p><p id="3458" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">👉<strong class="kq io">超出DOM引用范围</strong></p><p id="c6ea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有时，将DOM节点存储在数据结构中可能很有用。</p><p id="22f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设您想要快速更新表中几行的内容。在字典或数组中存储对每个DOM行的引用可能是有意义的。</p><p id="0779" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">发生这种情况时，会保留对同一个DOM元素的两个引用:一个在DOM树中，另一个在字典中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/71387e4aecbbd8bc3e829ba69e4d21f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBuxjTKN0n0lrWA2DPuyrA.png"/></div></div></figure><p id="958f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">如果将来您决定删除这些行，您需要使这两个引用都不可访问。</strong></p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="14c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你喜欢这篇文章，请在社交媒体上与你的开发者朋友分享。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/d6e2b79f9281c7073ed281db6d739641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SzlUGhZrzsVCdGYr.gif"/></div></div></figure></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="25b7" class="lk ll in bd lm ln mv lp lq lr mw lt lu jt mx ju lw jw my jx ly jz mz ka ma mb bi translated">推荐阅读</h1><div class="np nq gp gr nr ns"><a href="https://medium.com/front-end-weekly/understanding-javascript-memory-management-using-garbage-collection-35ed4954a67f" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">理解使用垃圾收集的JavaScript内存管理</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">内存管理的主要目标是为系统提供动态分配的内存</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oj l od oe of ob og km ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://data-flair.training/blogs/javascript-garbage-collection/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">JavaScript垃圾收集——用图表和例子解开它</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">对于那些想要掌握任何编程语言(包括JavaScript)的人来说，垃圾收集是必不可少的</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">数据-天赋.培训</p></div></div><div class="ob l"><div class="ok l od oe of ob og km ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">JavaScript中的4种内存泄漏类型以及如何消除它们</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在本文中，我们将探讨客户端JavaScript代码中常见的内存泄漏类型。我们还将学习如何…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">auth0.com</p></div></div><div class="ob l"><div class="ol l od oe of ob og km ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">标记和清除:垃圾收集算法</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">所有动态创建的对象(在C++和Java中使用new)都在堆中分配了内存。如果我们继续下去…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ob l"><div class="om l od oe of ob og km ns"/></div></div></a></div></div></div>    
</body>
</html>