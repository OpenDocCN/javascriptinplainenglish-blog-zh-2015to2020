<html>
<head>
<title>Understanding hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的提升</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-hoisting-in-javascript-11cb313f2a20?source=collection_archive---------1-----------------------#2019-05-08">https://javascript.plainenglish.io/understanding-hoisting-in-javascript-11cb313f2a20?source=collection_archive---------1-----------------------#2019-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b6dc83e84ce7dea9bfdab229a09e0749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcJvknvxlpyTlVCZKEZubQ.png"/></div></div></figure><p id="0bdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许用这个词来描述正在发生的事情并不恰当，因为它会让人联想到小型起重机将变量从代码中吊到顶部的画面，但是这里有一篇关于提升意味着什么的快速文章。</p><p id="3ff7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当V8引擎(读取javaScript代码并将其编译成C++的工具)解析任何javaScript文件时，您可能已经知道它是从上到下逐行处理的。</p><p id="cf99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但在此之前，V8会快速扫描文件，寻找任何变量和函数声明。例如:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3f88" class="li lj iq kz b gy lk ll l lm ln">const a = 23;</span><span id="628e" class="li lj iq kz b gy lo ll l lm ln">function greet(){<br/>  console.log("Hello");<br/>}</span></pre><p id="604c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，在文件被执行之前，V8知道<code class="fe kw kx ky kz b">a</code>是一个常量，一个名为<code class="fe kw kx ky kz b">greet</code>的函数存在。</p><p id="21e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您打开一个快速的<a class="ae lp" href="https://repl.it/" rel="noopener ugc nofollow" target="_blank"> REPL </a>实例并将下面的代码粘贴到那里，您可以看到这一点。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="03f4" class="li lj iq kz b gy lk ll l lm ln">console.log(a);</span><span id="028d" class="li lj iq kz b gy lo ll l lm ln">var a = 23;</span><span id="ba88" class="li lj iq kz b gy lo ll l lm ln">//=&gt; undefined</span></pre><p id="c38b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(注意那是一个<code class="fe kw kx ky kz b">var</code>，而不是<code class="fe kw kx ky kz b">const</code>或<code class="fe kw kx ky kz b">let</code>。稍后会有更多内容)</p><p id="b208" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">a是<code class="fe kw kx ky kz b">undefined</code>的原因是V8 ' <em class="lq">提升</em>所有的变量声明，并在内存中给它们分配空间。注意，我说的是“变量声明”(简单地说，<code class="fe kw kx ky kz b">var a</code>)，而不是变量赋值(应该是<code class="fe kw kx ky kz b">var a = 23</code>)，这就是为什么它知道<code class="fe kw kx ky kz b">a</code>的存在，但不知道a的值是23。</p><p id="1844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">V8的行为就好像变量是在任何东西被赋值之前就在页面顶部声明的，因此得名— <strong class="ka ir">提升。</strong></p><h1 id="14e4" class="lr lj iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">功能也被提升</h1><p id="9887" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在下面的示例中:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="98d4" class="li lj iq kz b gy lk ll l lm ln">sayHello();</span><span id="d78d" class="li lj iq kz b gy lo ll l lm ln">function sayHello(){<br/>  console.log("Hello");<br/>}</span><span id="62d5" class="li lj iq kz b gy lo ll l lm ln">//=&gt; Hello</span></pre><p id="f02d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个函数<code class="fe kw kx ky kz b">sayHello</code>都是被吊起来放在内存里的，这也是为什么你可以在声明之前调用它，它仍然像在被调用之前就声明了一样工作。</p><h1 id="1b3d" class="lr lj iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">..但是函数赋值没有被提升</h1><p id="ea72" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们从上面取同样的代码，使它成为一个匿名函数并把它赋给变量<code class="fe kw kx ky kz b">sayHello</code>，然后在赋值前调用它。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="ece4" class="li lj iq kz b gy lk ll l lm ln">sayHello();</span><span id="a0c7" class="li lj iq kz b gy lo ll l lm ln">var sayHello = function(){<br/>  console.log("Hello");<br/>}</span><span id="229c" class="li lj iq kz b gy lo ll l lm ln">//=&gt; sayHello is not a function</span></pre><p id="8ca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，变量<code class="fe kw kx ky kz b">sayHello</code>被提升，但是它在执行时的值是<code class="fe kw kx ky kz b">undefined</code>。</p><h1 id="ecc2" class="lr lj iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">快速忽略变量和范围</h1><p id="79de" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">这和提升没有必然的联系，但是我在for循环中发现了一个惊人的现象。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="ebf7" class="li lj iq kz b gy lk ll l lm ln">console.log('value of i before', i);</span><span id="923e" class="li lj iq kz b gy lo ll l lm ln">for(var i = 0; i &lt; 6; i++){<br/>  console.log("Hello");<br/>}</span><span id="f095" class="li lj iq kz b gy lo ll l lm ln">console.log('value of i after', i);</span><span id="890a" class="li lj iq kz b gy lo ll l lm ln">//=&gt; value of i before undefined<br/>//=&gt; value of i after 5</span></pre><p id="d776" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会认为<code class="fe kw kx ky kz b">i</code>的作用域应该在那个<code class="fe kw kx ky kz b">for</code>循环块内部，结果是I在外部也是可用的。</p><p id="5731" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，如果你尝试注销<code class="fe kw kx ky kz b">window.i</code>，你仍然会得到<code class="fe kw kx ky kz b">5</code>(它绑定到窗口对象)。</p><p id="dfaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个在代码中使用<code class="fe kw kx ky kz b">let</code>而不是<code class="fe kw kx ky kz b">var</code>的好例子，这似乎到处都在泄漏范围。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="aa80" class="li lj iq kz b gy lk ll l lm ln">console.log('value of i before', i);</span><span id="0793" class="li lj iq kz b gy lo ll l lm ln">for(let i = 0; i &lt; 5; i++){<br/>  console.log(i);<br/>}</span><span id="b165" class="li lj iq kz b gy lo ll l lm ln">console.log('value of i after', i);</span><span id="ca9e" class="li lj iq kz b gy lo ll l lm ln">//=&gt; ReferenceError: i is not defined</span></pre><h1 id="9380" class="lr lj iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">const and let</h1><p id="2985" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">有趣的是，<code class="fe kw kx ky kz b">const</code>和<code class="fe kw kx ky kz b">let</code>的升起方式与<code class="fe kw kx ky kz b">var</code>不同。</p><p id="534a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="9c2d" class="li lj iq kz b gy lk ll l lm ln">console.log(a);</span><span id="6294" class="li lj iq kz b gy lo ll l lm ln">const a = 23;</span><span id="d398" class="li lj iq kz b gy lo ll l lm ln">//=&gt; ReferenceError: a is not defined</span></pre><p id="13dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lp" href="https://www.vojtechruzicka.com/javascript-hoisting-var-let-const-variables/" rel="noopener ugc nofollow" target="_blank">这篇由<a class="ae lp" href="https://www.vojtechruzicka.com/" rel="noopener ugc nofollow" target="_blank"> Vojtech Ruzicka </a>撰写的文章</a>比我说的更有说服力:</p><blockquote class="mt mu mv"><p id="39a6" class="jy jz lq ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">在let/const的情况下，直到声明实际出现的那一行才会初始化为undefined。而且只有在没有立即分配的情况下。在上面的行中，变量位于时间死区，访问它会导致引用错误。</p></blockquote></div></div>    
</body>
</html>