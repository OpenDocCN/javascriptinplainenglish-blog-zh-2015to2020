<html>
<head>
<title>Take advantage of useMemo in React for better performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用React中的useMemo获得更好的性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-the-memo-with-react-for-better-performance-ce3d40538480?source=collection_archive---------7-----------------------#2020-06-20">https://javascript.plainenglish.io/use-the-memo-with-react-for-better-performance-ce3d40538480?source=collection_archive---------7-----------------------#2020-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8ae7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将看看memo函数和React，以及我们如何使用它来优化渲染，这将在大型应用程序中非常有帮助，因为减少了子组件的数量和不必要的渲染。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df946bd4a24260af6cdc06add5d08ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09A0BnFHn1aPvG2N566_DA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">chuttersnap</a> on <a class="ae ky" href="/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="01dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了演示它是如何工作的，我们将把它应用到一个带有计数器的表单组件中，作为一个常见的场景。</p><h2 id="015f" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">1.跟踪渲染的数量</h2><p id="cd4e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">首先，我们有<code class="fe lx ly lz ma b">App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">App.js without memo</figcaption></figure><p id="6784" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意我们有一个子组件<code class="fe lx ly lz ma b">Count.js</code>和输入字段，一个文本值的状态。</p><p id="2aa6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lx ly lz ma b">Count.js</code>有两份工作；递增<code class="fe lx ly lz ma b">count</code>变量，并计算它渲染了多少次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Count.js without memo</figcaption></figure><pre class="kj kk kl km gt md ma me mf aw mg bi"><span id="1952" class="kz la in ma b gy mh mi l mj mk">onClick={() =&gt; { setCount(c =&gt; c +1) }}</span></pre><p id="b22e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们每点击一次按钮，上面的行计数就增加1，下面的行通过创建一个默认为<code class="fe lx ly lz ma b">0</code>的引用来跟踪组件更新或渲染的次数，并在每次调用函数<code class="fe lx ly lz ma b">count</code>时增加计数:</p><pre class="kj kk kl km gt md ma me mf aw mg bi"><span id="e0e5" class="kz la in ma b gy mh mi l mj mk">const rendrs = React.useRef(0);<br/>...<br/>&lt;div&gt;renders: {renders.current++}&lt;/div&gt;<br/>...</span></pre><p id="3be3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看它的实际应用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/78a50713890cd4673fc2df8b9c1fb556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CmOp--03flCcFwseN_LFcw.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Every time a character has pressed an update happens.</figcaption></figure><p id="d3c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们注意到，即使修改上层组件<code class="fe lx ly lz ma b">App.js</code>中的输入字段也会强制调用<code class="fe lx ly lz ma b">Count</code>函数(它是一个子组件),这会导致不必要的渲染(假设内部组件的工作只是改变状态中的<code class="fe lx ly lz ma b">count</code>变量)。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="4d95" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">2.使用备忘录功能</h2><p id="f5b1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">正如我们已经看到的，每次一个角色被按下，详尽的更新就发生了。现在，我们将看看memo函数，并了解如何使用它。</p><p id="7912" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们将<code class="fe lx ly lz ma b">Count</code>包装在<code class="fe lx ly lz ma b">React.memo</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Count.js with memo</figcaption></figure><p id="b750" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在这里所做的就是将<code class="fe lx ly lz ma b">Count</code>箭头函数包装在<code class="fe lx ly lz ma b">React.memo</code>中:</p><pre class="kj kk kl km gt md ma me mf aw mg bi"><span id="a300" class="kz la in ma b gy mh mi l mj mk">React.memo( {/*functon*/} );</span></pre><p id="4f5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在的情况是，只有当<code class="fe lx ly lz ma b">state</code>改变或接收到新的<code class="fe lx ly lz ma b">prop</code>时，组件才会更新。</p><p id="b68d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的演示向我们展示了这个强大而简单的技巧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/734f0baeeff64724d709e137eacd168c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SIRXNw33QQrVvHL8IxTnmA.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Pressing characters will not update the component.</figcaption></figure></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="4d04" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">3.在将道具传递给子组件的情况下</h2><p id="3306" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><strong class="jm io"> 3.1.A功能属性</strong></p><p id="30d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们需要传递一个属性，比如说我们例子中的函数<code class="fe lx ly lz ma b">Count</code>，让它成为一个函数。</p><p id="77ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将功能作为道具添加到子组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">pass a function as a prop</figcaption></figure><p id="7560" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从<code class="fe lx ly lz ma b">Count</code>功能组件调用<code class="fe lx ly lz ma b">prop</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Calling onEven()</figcaption></figure><p id="c488" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/8d71b8d892ab057e020665a2eb88d6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dILk5s54_D1heXXnivVd9w.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">The same issue happens again</figcaption></figure><p id="b43d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的问题是每次<code class="fe lx ly lz ma b">App.js</code>被更新时，一个新的函数被创建并作为<code class="fe lx ly lz ma b">prop</code>传递给函数<code class="fe lx ly lz ma b">Count</code>，要修复它，需要使用一个<code class="fe lx ly lz ma b">useCallBack</code>函数:</p><pre class="kj kk kl km gt md ma me mf aw mg bi"><span id="3218" class="kz la in ma b gy mh mi l mj mk">...<br/>const onEven = React.useCallback(() =&gt; setText(""), [setText]);<br/>...<br/>&lt;Count onEven={onEven}/&gt;<br/>...</span></pre><p id="4c41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">神奇的是，只有当<code class="fe lx ly lz ma b">setText</code>改变时，函数<code class="fe lx ly lz ma b">Even</code>才会改变。</p><p id="6655" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3.2一个物体道具</strong></p><p id="1941" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们给子组件添加一个对象<code class="fe lx ly lz ma b">prop</code>:</p><pre class="kj kk kl km gt md ma me mf aw mg bi"><span id="e2d9" class="kz la in ma b gy mh mi l mj mk">...<br/>const data = { isEven: true };<br/>...<br/>&lt;Count onEven={onEven} data={data}/&gt;<br/>...</span></pre><p id="4ccb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我保证我们还会有同样的问题！原因是数据的参考正在发生变化。</p><p id="cabd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我们在<code class="fe lx ly lz ma b">App..js</code>中使用了另一个<code class="fe lx ly lz ma b">Hook</code>:</p><pre class="kj kk kl km gt md ma me mf aw mg bi"><span id="e781" class="kz la in ma b gy mh mi l mj mk">...<br/>const data = React.useMemo( () =&gt; ({ isEven: false,}),[] );<br/>...</span></pre><p id="fccf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是可行的，因为<code class="fe lx ly lz ma b">React.useMemo</code>不会创建另一个对象，除非依赖关系发生了变化(在我们的例子中是静态的),所以它只会创建一次。</p><p id="b39d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者使用组件<code class="fe lx ly lz ma b">Count</code>中<code class="fe lx ly lz ma b">React.memo</code>的第二个参数:</p><pre class="kj kk kl km gt md ma me mf aw mg bi"><span id="98fa" class="kz la in ma b gy mh mi l mj mk">...<br/>}, (prevProps, nextProps) =&gt; {<br/>  if(prevProps.data.isEven !== nextProps.data.isEven)<br/>    return false;<br/>  return true;<br/>   }<br/>);</span></pre><p id="bb7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，只有当<code class="fe lx ly lz ma b">props</code>的值改变时，组件才重新渲染。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="a48e" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">我希望你喜欢这个快速教程</h2><p id="8bee" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">下一次将使用一个免费的可视化库来介绍许多类型的图表，以及更多关于React性能的内容。如果你喜欢我介绍这个话题的方式，你可以看看我以前关于Highcharts的文章:</p><div class="mu mv gp gr mw mx"><a href="https://medium.com/javascript-in-plain-english/quick-integration-of-highcharts-with-react-9f796a396093" rel="noopener follow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd io gy z fp nc fr fs nd fu fw im bi translated">如何在React with Highcharts上创建数据可视化</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">Highcharts是一个用JavaScript编写的图表和数据可视化库</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">medium.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><p id="37b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://www.linkedin.com/in/hafid-menasria-9327b1a6/" rel="noopener ugc nofollow" target="_blank"> LinkedIn个人资料</a></p><p id="add3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保重！</p></div></div>    
</body>
</html>