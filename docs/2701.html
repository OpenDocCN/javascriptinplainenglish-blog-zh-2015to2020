<html>
<head>
<title>How To Avoid Code Repetition In React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免反应成分中的代码重复</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-avoid-code-repetition-in-react-components-1441180db425?source=collection_archive---------1-----------------------#2020-07-16">https://javascript.plainenglish.io/how-to-avoid-code-repetition-in-react-components-1441180db425?source=collection_archive---------1-----------------------#2020-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="65a1" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">编写反应组件的更好方法是避免重复的代码。</h2><div class=""/><div class=""><h2 id="fd4b" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">编写React组件的更好方法是主要关注业务逻辑。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2a14c376d522b4b9755a6e44363e9904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6kuAN3YrL3lJ1g3J"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@vikubi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Victória Kubiaki</a> on <a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2710" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在我的前一篇文章<a class="ae lb" href="https://medium.com/javascript-in-plain-english/setting-up-redux-to-avoid-boilerplate-code-33abf57a293b" rel="noopener"/>中，我们讨论了如何编写一个泛型函数，在十行代码内生成减压器。今天，在继续避免样板代码系列的同时，我会告诉你如何在编写反应组件时避免重复的代码。</p><p id="b802" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">正如您在编写反应组件时可能注意到的，您必须编写类似的代码来确保您是否拥有渲染反应组件的所有数据。让我用一个例子来详细说明这一点，假设您需要在页面上显示API数据，您必须确保如果:</p><ul class=""><li id="2b7f" class="ly lz in le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated"><strong class="le ix">API调用被触发？</strong></li><li id="39f7" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated"><strong class="le ix">API调用正在进行中？</strong></li><li id="5b18" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated"><strong class="le ix">API是否返回非空数据？</strong></li><li id="ee3a" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated"><strong class="le ix">是否有服务器或应用编程接口错误？</strong></li></ul><p id="5dbd" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">现在，假设应用程序中有五个页面，需要进行不同的API调用并显示数据。这意味着您必须在渲染页面时检查所有这些点。</p><p id="0dcd" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">必须有更好的方法来做到这一点。好吧，有很多，但是让我们来看看最明显的一个:我们可以提取所有这些逻辑，并从中创建一个组件，然后将实际的React组件呈现为该组件的子组件。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="6618" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">为了在生产中实现组件的代码，我们需要:</p><ul class=""><li id="be5b" class="ly lz in le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated">制作一个特设的，反过来，将渲染实际的业务逻辑。</li><li id="c8f0" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">特设检查所有的先例规则。</li><li id="9856" class="ly lz in le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">使其可在不同组件之间共享。</li></ul><p id="6563" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我们现在开始制作组件:</p><p id="e57f" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我们先做第一件事，制作一个呈现其子组件的组件。没什么特别的，我们会用道具中的<code class="fe mt mu mv mw b">children</code>来做这个。让我们称我们的组件为<code class="fe mt mu mv mw b">renderUI:</code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/9ed95cc453545855173d6860522f85b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aPsGQwMBCH_Mf-9PPhJrg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">initialized the base component</figcaption></figure><p id="949e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">让我们先检查一下API调用是否正在进行。如果你还记得上一篇帖子，我在各州都有一个名为<code class="fe mt mu mv mw b">isFetching</code>的房产。如果API调用正在进行，则该值将设置为true。根据业务逻辑，默认值可以是<code class="fe mt mu mv mw b">true</code>或<code class="fe mt mu mv mw b">false</code>。当API调用被解决时，它将被设置为<code class="fe mt mu mv mw b">false</code>。现在，这个属性在呈现组件时将非常有用。如果该值为<code class="fe mt mu mv mw b">true</code>，则需要显示加载消息或加载动画。我们将整个减速器状态作为<code class="fe mt mu mv mw b">keyData</code>传递给部件。检查<code class="fe mt mu mv mw b">isFetching</code>值，决定是显示数据还是加载信息:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/8ca14ae33889997f6e0598625142dc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XT6mFwYKU5gUPBEukAnbTQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">show loading message if isFetching is set to true.</figcaption></figure><p id="3bf9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">既然我们已经检查了API是否正在进行中。让我们检查一下API响应中是否有错误。我在我的Reducer状态中存储了另一个名为“errors”的变量。我将各种错误(无论是用户错误还是API响应错误)存储在这个变量中。如果is-fetching等于false并且error非空，我将显示我的错误消息，而不是呈现实际的组件:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/d7c4eaeab1b1ca1cbc948895f255fc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qUpap0te6kVmBr3eyAbFg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Show API or network errors.</figcaption></figure><p id="3d3a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">假设API调用成功，并且响应中没有错误。但是API没有响应任何数据。这意味着我们还需要检查非空数据。现在，为了统一起见，我将API数据存储在每个Reducer状态下的一个名为<code class="fe mt mu mv mw b">response</code>的变量中。我们将检查API响应是否为空，如果为空，我们将向用户显示一条有意义的消息，但是如果API响应非空，我们将呈现组件:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/abc197b7911157b36d54e7b12d4bdc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Js2AJggDvc8uSxJmeqzBpQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">show a message if API returns empty data.</figcaption></figure><p id="38ed" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">好吧，我在这部分更新了一些代码。首先，对数据和错误逻辑的检查变得更大了。此外，我认为这可以在其他一些地方重用。于是，我把那个逻辑提取出来，做了一个单独的函数，<code class="fe mt mu mv mw b">selectPresentableData</code>。它检查所有与规则相关的数据，并返回一个字符串，基于这个字符串，我们的<code class="fe mt mu mv mw b">renderUI</code>将呈现相关的组件。其余的事情在代码中是不言自明的。</p><p id="a0b0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">差不多就是这样了。现在，您不必每次都手动检查数据。我们的render-UI组件将负责数据检查。现在让我们看看如何在代码中使用render-UI组件:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/f215e2e15f36d177fec799499faea57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xc3xjbGgxG6QKC5-9s846Q.png"/></div></div></figure><p id="6c14" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">上面的组件呈现了一个图像列表。图像列表来自API(比如在按钮点击时或页面加载时)，并通过props或直接通过Redux(通过hooks或任何您喜欢的方式)存储传递给组件。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="4b9b" class="nc nd in bd ne nf ng dn nh ni nj dp nk ll nl nm nn lp no np nq lt nr ns nt it bi translated">专业提示:</h2><p id="9b16" class="pw-post-body-paragraph lc ld in le b lf nu jx lh li nv ka lk ll nw ln lo lp nx lr ls lt ny lv lw lx ig bi translated">您还可以在同一页面的多个部分多次使用该组件。比方说，如果您需要在页面的不同部分显示不同部分的API响应。你可以在所有这些地方使用<code class="fe mt mu mv mw b">RenderUI</code>组件。您可能希望为每个部分制作<code class="fe mt mu mv mw b">keyData</code>,如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/fc3ac9116a8f41e4a0554f175e441636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvml_MvkeXkiD02WfSNKHA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">using <code class="fe mt mu mv mw b"><em class="oa">RenderUI</em></code> component at multiple places in a single component.</figcaption></figure><p id="1469" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">您可以根据需要制作<code class="fe mt mu mv mw b">keyData</code>。比方说，响应数据不是来自API，但是如果数据为空，您希望显示一条消息，您可以手动将<code class="fe mt mu mv mw b">isFetching</code>传递给<code class="fe mt mu mv mw b">false</code>，并且仍然可以获得组件的好处。发挥你的想象力吧，有很多地方可以用。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="e7ca" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">这里是完整的<code class="fe mt mu mv mw b">RenderUI</code>组件的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">RenderUI component</figcaption></figure><h1 id="5cb8" class="od nd in bd ne oe of og nh oh oi oj nk kc ok kd nn kf ol kg nq ki om kj nt on bi translated">关于作者:</h1><p id="bfba" class="pw-post-body-paragraph lc ld in le b lf nu jx lh li nv ka lk ll nw ln lo lp nx lr ls lt ny lv lw lx ig bi translated">Bharat自2011年以来一直是前端开发人员。他对“前端开发经验”情有独钟。他喜欢学习和教授技术。他和最可爱的女人以及珍贵的双胞胎孩子一起享受生活。</p><p id="5274" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">总的来说是个好人。在<a class="ae lb" href="https://twitter.com/iiisoni" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lb" href="https://github.com/iiison" rel="noopener ugc nofollow" target="_blank"> Github </a>、<a class="ae lb" href="https://www.linkedin.com/in/iiison/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到他。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oo oc l"/></div></figure></div></div>    
</body>
</html>