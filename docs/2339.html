<html>
<head>
<title>JavaScript Basics — Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础——原型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-basics-prototypes-bd5ba0663157?source=collection_archive---------6-----------------------#2020-06-14">https://javascript.plainenglish.io/javascript-basics-prototypes-bd5ba0663157?source=collection_archive---------6-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c8262b67748a735e23ea41d570baaf82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*axrvT46D9MFQeNLQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ivanjevtic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ivan Jevtic</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3ac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript原型。</p><h1 id="c97c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型</h1><p id="c66d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">原型是其他对象继承的对象。</p><p id="1517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是JavaScript中继承的方式。</p><p id="cbb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们创建一个空对象:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="df3a" class="mn lc iq mj b gy mo mp l mq mr">const empty = {};</span></pre><p id="ce76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在上面调用<code class="fe ms mt mu mj b">toString</code>方法。</p><p id="22c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cd01" class="mn lc iq mj b gy mo mp l mq mr">console.log(empty.toString());</span></pre><p id="4445" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用它，我们会在控制台日志中记录<code class="fe ms mt mu mj b">[object Object]</code>。</p><p id="3fa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们的对象没有定义任何东西，它们仍然有继承的属性。</p><p id="ed4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">toString</code>方法来自<code class="fe ms mt mu mj b">Object.prototype</code>属性，默认情况下，丢失的对象从该属性继承。</p><p id="e3b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个属性不在对象本身中，那么JavaScript解释器将在它的原型中搜索该属性。</p><p id="3d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe ms mt mu mj b">getPrototypeOf</code>方法来获得一个对象的原型。</p><p id="821c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a284" class="mn lc iq mj b gy mo mp l mq mr">console.log(Object.getPrototypeOf(empty));</span></pre><p id="088e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到一个记录了一堆函数的对象。</p><p id="fc67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们记录了<code class="fe ms mt mu mj b">empty</code>对象，我们可以看到<code class="fe ms mt mu mj b">__proto__</code>属性也有同样的内容。</p><p id="c718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多对象并不直接继承自<code class="fe ms mt mu mj b">Object.prototype</code>。</p><p id="6fc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，函数继承自<code class="fe ms mt mu mj b">Function.prototype</code>，而后者继承自<code class="fe ms mt mu mj b">Object.prototype</code>。</p><p id="ebe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组继承自<code class="fe ms mt mu mj b">Array.prototype</code>，而<code class="fe ms mt mu mj b">Array.prototype</code>继承自<code class="fe ms mt mu mj b">Object.prototype</code>。</p><h1 id="8b5e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象.创建</h1><p id="ec7e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe ms mt mu mj b">Object.create</code>来创建一个对象，并把原型传递给方法。</p><p id="cdd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5278" class="mn lc iq mj b gy mo mp l mq mr">const protoDog = {<br/>  speak(words) {<br/>    console.log(words);<br/>  }<br/>}</span><span id="7d1b" class="mn lc iq mj b gy mv mp l mq mr">const dog = Object.create(protoDog);</span></pre><p id="8fec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们看到，当我们记录<code class="fe ms mt mu mj b">dog</code>的值时，我们看到了带有<code class="fe ms mt mu mj b">speak</code>方法的<code class="fe ms mt mu mj b">__proto__</code>属性，这就是我们在<code class="fe ms mt mu mj b">protoDog</code>中拥有的。</p><h1 id="7db4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">班级</h1><p id="b0c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript中的类只不过是其原型继承模型之上的语法糖。</p><p id="ff25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个类通过列出它的方法和属性来定义一种对象的形状。</p><p id="ec83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从类创建的对象称为类的实例。</p><p id="930b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一个给定类的实例，我们必须创建一个从正确原型派生的对象。</p><p id="a6e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类只是语法更好的构造函数。</p><p id="8b4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以定义构造函数以fikkiwsL的形式返回一个对象</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b98c" class="mn lc iq mj b gy mo mp l mq mr">function Dog(name) {<br/>  this.name = name;<br/>}</span><span id="3406" class="mn lc iq mj b gy mv mp l mq mr">Dog.prototype.speak = function(words) {<br/>  console.log(`${this.name} says '${words}'`);<br/>};</span></pre><p id="7b12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的原型中有带有<code class="fe ms mt mu mj b">speak</code>方法的<code class="fe ms mt mu mj b">Dog</code>构造函数。</p><p id="8199" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写以下代码来创建一个<code class="fe ms mt mu mj b">Dog</code>实例:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6663" class="mn lc iq mj b gy mo mp l mq mr">const dog = new Dog('james');<br/>dog.speak('hello');</span></pre><p id="f440" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有函数都会自动获得一个名为<code class="fe ms mt mu mj b">prototype</code>的属性，我们可以将实例方法放入其中。</p><p id="43dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数的名称被大写，这样就可以与其他函数区分开来。</p><p id="95c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们检查原型，我们会得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6aa1" class="mn lc iq mj b gy mo mp l mq mr">console.log(Object.getPrototypeOf(dog) === Dog.prototype);</span></pre><p id="a175" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">日志<code class="fe ms mt mu mj b">true</code>。</p><h1 id="5e50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更好的语法</h1><p id="912a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了让我们的生活更简单，我们可以使用类语法来重写我们的<code class="fe ms mt mu mj b">Dog</code>构造函数。</p><p id="bafb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6262" class="mn lc iq mj b gy mo mp l mq mr">class Dog {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="489d" class="mn lc iq mj b gy mv mp l mq mr">  speak(words) {<br/>    console.log(`${this.name} says ${words}`);<br/>  }<br/>}</span></pre><p id="b0ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个类以<code class="fe ms mt mu mj b">class</code>关键字开头。</p><p id="f3d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe ms mt mu mj b">constructor</code>来代替构造函数体。</p><p id="ca6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">speak</code>方法现在在类中，而不是将其添加到<code class="fe ms mt mu mj b">prototype</code>属性中。</p><p id="4a82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类声明只允许将方法添加到原型中。</p><p id="5b2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类可以用在语句和表达式中，因为它们只是构造函数。</p><p id="0de1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写下这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5867" class="mn lc iq mj b gy mo mp l mq mr">const obj = new class {<br/>  hello() {<br/>    return "hello";<br/>  }<br/>};</span></pre><p id="d9c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个<code class="fe ms mt mu mj b">class</code>表达式，它可以立即与<code class="fe ms mt mu mj b">new</code>关键字一起使用。</p><p id="ef19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼<code class="fe ms mt mu mj b">obj.hello</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e143" class="mn lc iq mj b gy mo mp l mq mr">console.log(obj.hello());</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/655966126bd4d9b0cb7a0b134b73e4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p-TH6BWlfLaayFlH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@maartendeckers?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maarten Deckers</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="70ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">覆盖继承的属性</h1><p id="5a4e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe ms mt mu mj b">extends</code>关键字来覆盖继承的属性。</p><p id="fab7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容从一个类创建一个子类:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9227" class="mn lc iq mj b gy mo mp l mq mr">class Dog {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  speak(words) {<br/>    console.log(`${this.name} says ${words}`);<br/>  }<br/>}</span><span id="a596" class="mn lc iq mj b gy mv mp l mq mr">class GoodDog extends Dog {<br/>  speak(words) {<br/>    console.log(`good dog ${this.name} says ${words}`);<br/>  }<br/>}</span></pre><p id="181c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe ms mt mu mj b">GoodDog</code>类，它是<code class="fe ms mt mu mj b">Dog</code>的子类。</p><p id="6c85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">extends</code>关键字表示我们继承了<code class="fe ms mt mu mj b">Dog</code>原型的所有属性。</p><h1 id="1370" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="25bd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript使用原型继承。</p><p id="f615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们继承来自对象原型的属性。</p><p id="e036" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数物体都以<code class="fe ms mt mu mj b">Object.prototype</code>为基本原型。</p><p id="6d1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建具有固定成员集的对象，我们可以使用构造函数。</p><p id="a228" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使创建构造函数更容易，我们可以使用类语法。</p><h2 id="b8fe" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语中的JavaScript</h2><p id="c31b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似的内容吧！</strong></p></div></div>    
</body>
</html>