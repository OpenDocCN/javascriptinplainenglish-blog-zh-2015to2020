<html>
<head>
<title>Understanding JavaScript Execution Context, Call Stack and Stack Overflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript执行上下文、调用堆栈和堆栈溢出</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-javascript-execution-context-call-stack-and-stack-overflow-157b7b358e88?source=collection_archive---------3-----------------------#2020-02-01">https://javascript.plainenglish.io/understanding-javascript-execution-context-call-stack-and-stack-overflow-157b7b358e88?source=collection_archive---------3-----------------------#2020-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/13d27be81618eeb83584fb441d93ea3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c81ybh16ndKq999uB0EnSQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Stack of Stones</figcaption></figure><p id="a817" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JavaScript很奇怪。在不完全理解JavaScript的情况下使用JavaScript是可能的，而且大多数时候JavaScript可以让你逃脱惩罚。如果你像我一样是一个有抱负的JavaScript忍者，那么你肯定会想理解JavaScript。这将有助于您更好地调试代码并理解代码是如何工作的。</p><p id="1dae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇文章中，我对JavaScript执行上下文和调用堆栈给出了一个非常简单的解释。在这篇文章的最后，你将会有一个帮助你理解这些概念的心智模型。</p><h1 id="3758" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">给我上下文</strong></h1><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/dbb6edee46f9b2e556ffa3025a3fbd8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*zraNCxHviU6o5CM5R1tyiA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Wetin dey occur?</figcaption></figure><p id="ab5a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我记得看过一部电影，一个年轻的情人男孩和他的女朋友在咖啡店约会。当他在等她时，一位漂亮的女服务员走了过来。</p><p id="55c5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">女服务员看到小男孩的衬衫领子粗糙，弯下腰，用手搂住他的脖子，帮他把衣领弄直。就在这时，小男孩的女朋友走了进来，看到女服务员用手搂住她的情人，以为她在吻他！她走出了咖啡店，后来又走出了年轻人的生活。可怜的孩子。</p><p id="93a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可能会得出结论，这个小男孩的情人有信任问题，她所看到的欺骗了她。为了正确地陈述情况，她断章取义<em class="ma">。</em></p><h1 id="000f" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">JavaScript执行上下文</strong></h1><p id="e3b2" class="pw-post-body-paragraph jz ka in kb b kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw ig bi translated">假设您有以下JavaScript代码:</p><pre class="lw lx ly lz gt mg mh mi mj aw mk bi"><span id="63e5" class="ml ky in mh b gy mm mn l mo mp">function first() {<br/>  second();<br/>}</span><span id="ae1b" class="ml ky in mh b gy mq mn l mo mp">function second() {<br/>  third();<br/>}</span><span id="c630" class="ml ky in mh b gy mq mn l mo mp">function third() {<br/>console.log('I am the third function')<br/>}</span><span id="149c" class="ml ky in mh b gy mq mn l mo mp">function boss() {<br/>  first();<br/>}</span><span id="8a26" class="ml ky in mh b gy mq mn l mo mp">// call the boss function<br/>boss()</span></pre><p id="3397" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">调用<code class="fe mr ms mt mh b">boss </code>函数将执行<code class="fe mr ms mt mh b">first()</code>函数，后者执行<code class="fe mr ms mt mh b">second()</code>，后者执行<code class="fe mr ms mt mh b">third()</code>函数。在每个执行点，JavaScript引擎必须能够告诉它当前正在执行哪个函数。它必须知道当前执行的<em class="ma">上下文</em>。</p><p id="a7fd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JavaScript通过在每次执行函数时创建所谓的<em class="ma">执行上下文</em>来实现这一点。</p><p id="6faa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">执行上下文是一个<strong class="kb io">内部JavaScript概念</strong>，JavaScript引擎使用它来<strong class="kb io">跟踪</strong>代码的执行。</p><p id="7623" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">想象一下，JavaScript引擎会问自己:<em class="ma">我当前正在执行哪些代码？</em>执行语境回答了这一点。</p><h1 id="dc2c" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">全球语境</strong></h1><p id="0da0" class="pw-post-body-paragraph jz ka in kb b kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw ig bi translated">现在您知道了，当函数被调用时，JavaScript引擎为它们创建一个执行上下文——这让引擎知道它当前正在执行哪个函数。引擎如何知道它当前执行的代码是否是函数中的<em class="ma">而不是</em>，也就是说，它如何知道全局代码？(想想全局代码有不在函数中的代码。)</p><p id="68fd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JavaScript中有两种类型的上下文:函数上下文和全局上下文。在全局范围内而不是在函数内部执行的代码被放在全局上下文中。全局上下文通常表示为<code class="fe mr ms mt mh b">main</code>。而且通常是第一个被创造出来的。</p><h1 id="0b10" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">调用堆栈</strong></h1><blockquote class="mu mv mw"><p id="82e1" class="jz ka ma kb b kc kd ke kf kg kh ki kj mx kl km kn my kp kq kr mz kt ku kv kw ig bi translated"><em class="in">“这样，末后的要在前，先在后……”——马太福音20:16 </em></p></blockquote><p id="9000" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">单独为每个函数调用创建一个执行上下文并不能完全回答这个问题，“我当前正在执行哪个代码？”。JavaScript引擎必须能够组织每个函数调用的执行上下文，使它更容易知道执行的顺序——哪个先执行。</p><p id="1bf2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的例子中，当执行<code class="fe mr ms mt mh b">boss </code>函数时，情况是这样的:</p><pre class="lw lx ly lz gt mg mh mi mj aw mk bi"><span id="1a8a" class="ml ky in mh b gy mm mn l mo mp">boss -&gt; first -&gt; second -&gt; third</span></pre><p id="b530" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后函数调用必须“展开”，这意味着<code class="fe mr ms mt mh b">third </code>函数的执行将首先完成，然后<code class="fe mr ms mt mh b">second</code>函数的执行完成，然后<code class="fe mr ms mt mh b">first </code>函数的执行完成，然后<code class="fe mr ms mt mh b">boss </code>函数的执行完成。</p><p id="afc1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">尽管首先调用了<code class="fe mr ms mt mh b">boss </code>方法，但它最后完成。该功能的执行遵循<strong class="kb io">先进后出</strong>的方法。</p><p id="0792" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以想象函数执行上下文按照它们被创建的顺序一个在另一个之上。这样第一个在底部，最后一个在顶部。(请记住，必须首先创建全局上下文。)</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/96a44bd6579516d6fa2d909ddf9c8330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mtKgjtdBYoqyGavHm4hPg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Creation of execution contexts</figcaption></figure><p id="ff60" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，函数的执行从顶部开始完成——当一个函数完成时，它从顶部被“移除”,并且它下面的一个被执行。这一直持续到调用堆栈为空！第一次真的变成了最后一次！</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/31f7f5251400c06faf048d0ca7d23f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8R4wmyZxEh3eUIcZ1N7xEw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Popping of execution contexts when the execution is finished</figcaption></figure><p id="5bd2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JavaScript引擎创建一个<code class="fe mr ms mt mh b">stack </code>数据结构，函数执行上下文在函数被调用时放置在该数据结构中。这个数据结构被称为<strong class="kb io">调用堆栈</strong>。将执行上下文放入调用堆栈称为<em class="ma">插入</em>，而移除称为<em class="ma">弹出</em>。</p><p id="3a06" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当调用栈为空时，JavaScript引擎知道代码执行已经完成。</p><h1 id="9828" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">什么是栈溢出？</strong></h1><p id="2f4c" class="pw-post-body-paragraph jz ka in kb b kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw ig bi translated">JavaScript引擎中实现的调用堆栈的大小不是无限的，它有一个限制，坏代码可能会超过这个限制。</p><p id="93bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请考虑以下情况:</p><pre class="lw lx ly lz gt mg mh mi mj aw mk bi"><span id="72e7" class="ml ky in mh b gy mm mn l mo mp">function foo() {<br/>  foo()<br/>}</span><span id="8b67" class="ml ky in mh b gy mq mn l mo mp">foo();</span></pre><p id="6edc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">函数<code class="fe mr ms mt mh b">foo </code>调用自己，然后再次调用自己，没有停止的条件，所以我们有一个函数调用的无限循环。如果在浏览器中执行这段代码，浏览器将抛出一个错误，告诉您已经超出了调用堆栈的大小。当这种情况发生时，我们说堆栈溢出了。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/602badd4404f2757291e469acc821810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70RGNkLyAhDsIMwWFre1LA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><em class="nb">Testing the code in Brave Browser</em></figcaption></figure><p id="d647" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">从概念上讲，这是调用堆栈中发生的情况:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0c18c6c0e1458a62020b597576c45cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7VhC2dGxtwMCtbMDuyTMmQ.png"/></div></div></figure><p id="03da" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">啊哈！就是它，JavaScript执行上下文，调用栈和栈溢出去神秘化！</p><h1 id="f770" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">闭幕词</strong></h1><p id="658e" class="pw-post-body-paragraph jz ka in kb b kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw ig bi translated">感谢您读到这里！我打赌这是值得的。如果你像我喜欢写这篇文章一样喜欢读这篇文章，(打字…对吗？:) )请在社交媒体上分享，你可以在twitter上关注我<a class="ae nc" href="https://twitter.com/solathecoder" rel="noopener ugc nofollow" target="_blank">@ sola the code</a>。</p><p id="d43f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">黑客快乐！</p><p id="da49" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="ma">如果你点击拍手图标50次，你认为会发生什么？</em></p></div></div>    
</body>
</html>