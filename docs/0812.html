<html>
<head>
<title>Writing Your Very First Unit Test With Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest编写你的第一个单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-your-first-unit-test-with-jest-b4953dabb931?source=collection_archive---------0-----------------------#2019-12-15">https://javascript.plainenglish.io/writing-your-first-unit-test-with-jest-b4953dabb931?source=collection_archive---------0-----------------------#2019-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5efc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何提高React组件的代码质量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/69a2d0332e2c14f16c5bfd4fc1a17ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3tkV_XrchRc_N0FRABDlg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae kv" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/writing-your-very-first-unit-test-with-jest"><div class="gh gi kw"><img src="../Images/c19cb3069af1beba3c93258d9fcfe139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-PVzecNs3s4ZbJsdsgIsGA.png"/></div></a></figure><p id="d32d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">单元测试是任何大型应用程序的重要组成部分。他们的主要工作是覆盖最小的单元，比如单个的函数或方法。本质上，是代码中最小的可测试组件。他们测试他们是否按预期工作。</p><p id="f301" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">编写好的单元测试并不像有些人想的那样显而易见。例如，测试什么和不测试什么并不总是很清楚。你应该如何测试那些你应该测试的？它容易被其他人阅读和理解吗？或者几个月后被你发现？—在编写单元测试时，您可能需要回答这些问题。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a0f2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">好的单元测试有什么特点？</h1><p id="caa9" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">在编写任何单元测试之前，我们需要知道哪些事情是我们需要记住的，以便使它们变得更好。</p><p id="cee5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，正如前面提到的，好的单元测试不会测试显而易见的东西。例如，你不应该测试不是你自己写的代码。测试框架功能性— <em class="mx">在React </em>的情况下测试生命周期方法——只是浪费时间。这超出了范围，不应该是你的责任。</p><p id="12e1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最好是，他们应该测试代码中最小的可测试组件:函数或方法。纯函数是最好测试的。如果您需要为给定的测试编写大量的模拟，那么您很可能不需要单元测试。相反，它可以被集成或验收测试所覆盖。</p><p id="13b8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">同样重要的是要提到，你为单元测试编写的测试数量将会比你为集成编写的数量多。单元测试和验收测试在数量上的差异会更大。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/0f4408de472e041ba478730b1267df8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Q-5Bd__Lz4QxEkQyM6bTg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The testing pyramid which shows that complexity grows upwards while quantity grows downwards</figcaption></figure><p id="13f6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在你可能会问——如果我需要写这么多最终用户看不到的代码，那还有什么意义呢？有什么好处？真的值得花费时间和精力吗？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1e81" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">为什么我们需要测试我们的应用程序？</h1><p id="2d8b" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">那么编写单元测试有什么好处呢？</p><p id="1f14" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">到目前为止，最大的回报是它将使您的过程更加敏捷。它有助于您应对未来的变化，因为您可以放心地接触已经实现的代码。万一您的更改可能会导致bug，它不会进入生产环境，但会破坏您的单元测试。这意味着您的代码质量将会提高，因为您的测试套件将在提交给最终用户之前更早地捕捉到bug。</p><p id="259b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这也意味着修复bug的成本将会降低，因为你知道去哪里找，为什么你的应用程序会崩溃。</p><p id="3d3f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们已经解决了这个问题，让我们从建立项目和引入Jest开始。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c150" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">设置项目</h1><p id="9210" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">想象我们有一个React制造的计算器。我们想编写一些测试来涵盖加、减、乘、除的功能。为了加速这个过程，我在代码编辑器中准备了一个<a class="ae kv" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>样板文件和一些函数，我们可以为它们编写测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c0ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它被导入到<code class="fe nb nc nd ne b">App.js</code>中。</p><p id="c8d7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是我的项目结构，在引导create-react-app之后，一切就绪。什么都没有改变，我只添加了<code class="fe nb nc nd ne b">AppController.js</code>文件，我们将在测试中用到它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/2af7dd1ecf714a6fa866fdf9eec105dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*Wwr3fdWphvoDsRqyZKyxxg.png"/></div></figure><p id="8acd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要开始用Jest编写测试，我们首先需要获得依赖关系。运行<code class="fe nb nc nd ne b"><a class="ae kv" href="https://www.npmjs.com/package/jest" rel="noopener ugc nofollow" target="_blank">npm i jest</a></code>来安装它。一旦准备好，我们可以添加一个脚本到我们的<code class="fe nb nc nd ne b">package.json</code>文件，它将为我们运行Jest:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1cd7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们每次运行<code class="fe nb nc nd ne b">npm run unit</code>，它都会调用<code class="fe nb nc nd ne b">run.js</code>文件，执行Jest。我们也可以指定一个配置文件。让我们先看看<code class="fe nb nc nd ne b">run.js</code>里面有什么，然后再看看我们需要什么来进一步配置它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4cff" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要让Jest运行测试文件，我们只需要三行代码。首先，我导入Jest本身，然后从CLI中提取参数。在这个例子中，<code class="fe nb nc nd ne b">argv</code>将代表配置文件。</p><p id="828a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">配置文件将负责决定运行哪些文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="eecf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">属性将在指定的位置搜索测试文件。因为我为测试创建了一个单独的目录，并且专门为单元测试创建了一个子目录，所以我们需要后退两个目录。指定<code class="fe nb nc nd ne b">rootDir</code>将帮助我们将<code class="fe nb nc nd ne b">testMatch</code>指向我们项目的根。</p><p id="155d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我还使用了一些正则表达式，因此它将匹配<code class="fe nb nc nd ne b">.spec</code>和<code class="fe nb nc nd ne b">.test</code>文件以及<code class="fe nb nc nd ne b">.js</code>或<code class="fe nb nc nd ne b">.ts</code>扩展名。</p><p id="17b7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在一切都配置好了，如果您运行<code class="fe nb nc nd ne b">npm run unit</code>，您将得到一个错误，说“没有找到测试…”所以让我们创建一个！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/a595039b8c934c7793ef7a20a9c6b243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxSwn2MWZPY3lRwyK3mkMw.png"/></div></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ccaa" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">编写您的第一个单元测试</h1><p id="fea7" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">让我们在<code class="fe nb nc nd ne b">tests/unit</code>中创建一个名为<code class="fe nb nc nd ne b">AppController.spec.js</code>的新文件。为了测试它，我们需要首先导入文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="da7e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">导入后，我使用了两个函数调用:</p><ul class=""><li id="2c39" class="nh ni iq kz b la lb ld le lg nj lk nk lo nl ls nm nn no np bi translated"><code class="fe nb nc nd ne b">describe</code>用于将相关测试分组在一起。例如，这里我们为单个类编写测试。</li><li id="495f" class="nh ni iq kz b la nq ld nr lg ns lk nt lo nu ls nm nn no np bi translated"><code class="fe nb nc nd ne b">it</code>用于指定我们应该对代码运行的测试。这是支票要去的地方。</li></ul><p id="8156" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">名字很重要。你应该总是努力描述。每当您运行测试时，这些都会显示在您的CLI中。如果有任何失败，您将很容易发现哪个测试是罪魁祸首。</p><p id="9b46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以对于每一种方法，我们都有一个测试。让我们看看可以为它们编写什么样的异常:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="531b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如你所见，我们可以提出各种案例。为了测试每个方法，我们可以使用<code class="fe nb nc nd ne b">expect</code>函数。我们传入想要测试的方法，然后验证输出值应该是什么或不应该是什么。</p><p id="bd24" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，我们可以测试给定相同的参数，函数是否产生相同的输出，但是它们的顺序被交换了。我们可以测试负数和数字<code class="fe nb nc nd ne b">0</code>的异常。在<code class="fe nb nc nd ne b">divide</code>的情况下，我们可以测试如果除以0会发生什么。</p><p id="0428" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="mx">笑话</em> <a class="ae kv" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank"> <em class="mx">文档</em> </a> <em class="mx">相当广泛，你可以好好看看</em> <code class="fe nb nc nd ne b"><em class="mx">expect</em></code> <em class="mx">还有哪些可用的匹配器。</em></p><p id="d640" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在运行测试，一切都应该变成绿色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7f7e62ca93a028a9bfbcd1bb0a1fc100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*xkA20qWEMS79by8LUTSH-A.png"/></div></figure><p id="40c3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是如果我们改变这一点呢:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9e0b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">变成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="61d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们真的想把它四舍五入到一位小数？在我们的测试中，这不是一个错误的类型，这就是我们希望我们的功能如何工作。我们的测试套件将捕捉错误，测试将失败。它将生成以下内容，准确描述它所期望的和它所收到的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/5b017daf73b5260bef3dcb5e078a020e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_NM8s9mEZ12wDEscL7a4w.png"/></div></div></figure><p id="1a0f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在你可以确信，如果你曾经引起一个bug，它将被Jest捕获，让你的用户体验到一个无bug版本的应用程序。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="b5a7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="de18" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">这些测试可以在部署之前插入到配置项中，或者您甚至可以使用<a class="ae kv" href="https://www.npmjs.com/package/husky/v/3.0.0" rel="noopener ugc nofollow" target="_blank"> husky </a>作为预提交挂钩来运行它。因此，如果你的代码破坏了什么，它甚至不会进入存储库。</p><p id="018c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您现在可以安全地部署您的应用程序，无需担心任何问题。或者万一发生了，你仍然有机会在它到达用户之前修复它。</p><p id="40eb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想玩已经完成的项目，你可以从<a class="ae kv" href="https://github.com/flowforfrank/jest-test" rel="noopener ugc nofollow" target="_blank"> GitHub </a>克隆它。感谢您花时间阅读这篇文章，祝您测试愉快！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi nx"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/how-to-e2e-test-your-application-with-cypress"><div class="gh gi kw"><img src="../Images/a951b01c482309b3243caaab811eeafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*b3MpvdTSFd6ujeH3zNxFTA.png"/></div></a></figure></div></div>    
</body>
</html>