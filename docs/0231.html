<html>
<head>
<title>How to use Throttle and Debounce in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用节流和去抖</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-throttle-and-debounce-in-javascript-9cb20fdb24ca?source=collection_archive---------2-----------------------#2019-08-30">https://javascript.plainenglish.io/how-to-use-throttle-and-debounce-in-javascript-9cb20fdb24ca?source=collection_archive---------2-----------------------#2019-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cec8b6112d034f30c76eeeac88810793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bpiw0ZImoVwjefNv.png"/></div></div></figure><p id="3f13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">节流和去抖动是两种流行且广泛使用的编码技术，有助于提高在一定时间内重复执行的JavaScript代码的性能。在本教程中，我们将学习<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> Throttle和Debounce，以及如何在我们的代码中实现它们以提高代码的性能，并用JavaScript编写更好更快的代码。</p><p id="161e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">节流和去抖动使编码人员能够控制调用方法的速度。它们在处理事件处理程序分配时特别有用。我们可以举滚动处理程序、键盘事件，甚至只是快速点击一个按钮的例子。</p><h1 id="c7ce" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是节流？</h1><p id="d45d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">throttle是一个高阶函数，它采用一个方法和一个超时函数，并且只允许该函数在指定的时间内最多执行一次。是为了保证函数在指定的时间段内最多调用一次。这意味着，如果某个函数最近才运行过，节流会阻止它运行。</p><p id="d792" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，我们在哪里使用节流技术呢？</p><ul class=""><li id="62d3" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">我们在按钮点击中使用节流来防止垃圾点击。</li><li id="b51a" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">我们可以在API调用中使用节流。</li><li id="7a70" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">throttle可以在<code class="fe ml mm mn mo b">mousemove</code> / <code class="fe ml mm mn mo b">touchmove</code>事件处理程序中使用。</li></ul><h2 id="cb06" class="mp kv in bd kw mq mr dn la ms mt dp le kg mu mv li kk mw mx lm ko my mz lq na bi translated">节流的实施</h2><p id="7b1e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，让我们举一个简单的例子，它解释了有和没有节流的代码。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="f623" class="mp kv in mo b gy nj nk l nl nm">export class IncreaseTheNumber extends Component&lt;{}, {num : number}&gt; {</span><span id="b29e" class="mp kv in mo b gy nn nk l nl nm">state = {num: 0}; <br/>increase = () =&gt; { <br/> this.setState({num: this.state.num + 1});<br/>}</span><span id="1036" class="mp kv in mo b gy nn nk l nl nm">render() { <br/>  return ( <br/>     &lt;div&gt; <br/>       {this.state.num}<br/>      &lt;div&gt; <br/>        &lt;button onClick={this.increase}&gt;Increment!&lt;/button&gt; <br/>      &lt;/div&gt; <br/>     &lt;/div&gt; <br/>   ); <br/> }<br/>}</span></pre><p id="8475" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们有一个状态<code class="fe ml mm mn mo b">num</code>和一个可以增加这个状态<code class="fe ml mm mn mo b">increase</code>的方法。我们可以点击一个按钮来增加<code class="fe ml mm mn mo b">num</code>。在这里，我们可以按我们想要的速度点击<code class="fe ml mm mn mo b">Increment </code>按钮，它将增加<code class="fe ml mm mn mo b">num </code>状态。现在考虑我们需要延迟状态<code class="fe ml mm mn mo b">num</code>来增加我们点击按钮的速度。因此，我们可以使用<strong class="jx io">油门</strong>来减缓增量。查看下面的示例，在该示例中实现了节流:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="a71c" class="mp kv in mo b gy nj nk l nl nm">export class IncreaseTheNumber extends Component&lt;{}, {num: number}&gt;{</span><span id="c258" class="mp kv in mo b gy nn nk l nl nm">state = {num: 0}; <br/>increase= () =&gt; {<br/>   this.setState({num: this.state.num + 1}); }<br/>}</span><span id="307a" class="mp kv in mo b gy nn nk l nl nm">function throttle(func, timeout) {  <br/>  let exexute: true;  <br/>  return (...args) =&gt; {    <br/>   if (!execute) {      <br/>      return;    <br/>   }     <br/>    execute= false;    <br/>    func(...args);    <br/>    setTimeout(() =&gt; {      <br/>       execute = true;    <br/>     }, timeout);  <br/>   };<br/>}</span><span id="5b7b" class="mp kv in mo b gy nn nk l nl nm">increaseWithThrottle = throttle(this.increase, timeout);</span><span id="c25b" class="mp kv in mo b gy nn nk l nl nm">render() { <br/>  return ( <br/>       &lt;div &gt; <br/>         {this.state.numSpells}<br/>         &lt;div&gt; <br/>           &lt;button onClick={this.increase}&gt;Increment&lt;/button&gt;          <br/>           &lt;button onClick={this.increaseWithThrottle}&gt; Increment with Throttled &lt;/button&gt; <br/>         &lt;/div&gt; <br/>        &lt;/div&gt; <br/>         ); <br/> }<br/>}</span></pre><p id="bb33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们现在有一个名为<code class="fe ml mm mn mo b">increaseWithThrottle</code>的按钮，它实现了节流技术并延迟了<code class="fe ml mm mn mo b">num</code>状态的增量。</p><p id="1cf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要理解<code class="fe ml mm mn mo b">throttle</code>方法。<code class="fe ml mm mn mo b">throttle </code>是一个采用函数和超时的方法。Throttle返回一个新方法，该方法在原始方法周围形成一个闭包。</p><p id="ec9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们需要跟踪一个名为<code class="fe ml mm mn mo b">execute </code>的变量，它阻止内部方法执行，除非超时。如果我们执行该方法，我们还会触发一个超时，当超时结束时会将<code class="fe ml mm mn mo b">execute </code>设置为true。这就是我们在JavaScript中实现节流的方式。</p><p id="34e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们继续<strong class="jx io">去抖</strong>！！</p><h1 id="ea3c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是去抖？</h1><p id="1ca7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">基本上，去抖动可能比节流更常用。在许多情况下，你可以有一个比油门更好的去抖效果。</p><p id="3d3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">去抖</strong>和<strong class="jx io">油门</strong>只是有点不同。在节流的情况下，我们在方法调用发生时减慢它们的速度。但是在<strong class="jx io">去抖</strong>的情况下，我们根本不执行该方法，直到该方法的先前执行已经停止。从编码概念来看，这似乎是一种更安全的方式。</p><p id="06c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想在用户完成输入、滚动或导航时执行计算或获取API，这真的很有用。</p><p id="475c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，我们在哪里使用去抖技术呢？</p><ul class=""><li id="c4cf" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">我们在<code class="fe ml mm mn mo b">resize</code>事件处理程序中使用去抖。</li><li id="40ba" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">我们可以在<code class="fe ml mm mn mo b">scroll</code>事件处理程序中使用去抖。</li><li id="1f94" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">谴责可用于自动完成或自动保存功能。</li></ul><h2 id="5ea1" class="mp kv in bd kw mq mr dn la ms mt dp le kg mu mv li kk mw mx lm ko my mz lq na bi translated">去抖的实现</h2><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="b115" class="mp kv in mo b gy nj nk l nl nm">export class IncreaseTheNumber extends Component&lt;{}, {num: number}&gt;{</span><span id="561f" class="mp kv in mo b gy nn nk l nl nm">state = {num: 0}; <br/>increase= () =&gt; {<br/>   this.setState({num: this.state.num + 1}); }<br/>}</span><span id="94e8" class="mp kv in mo b gy nn nk l nl nm">function debounce(func: Function, timeout: number) {  <br/>   let timer: NodeJS.Timeout;  <br/>   return (...args: any) =&gt; {    <br/>      clearTimeout(timer);    <br/>      timer = setTimeout(() =&gt; {      <br/>          func(...args);    <br/>        }<br/>       ,timeout);  <br/>      };<br/>    }</span><span id="bf65" class="mp kv in mo b gy nn nk l nl nm">incrementWithDebounced = debounce(this.castSpell, timeout);</span><span id="7039" class="mp kv in mo b gy nn nk l nl nm">render() { <br/>  return ( <br/>       &lt;div &gt; <br/>         {this.state.numSpells}<br/>         &lt;div&gt; <br/>           &lt;button onClick={this.increase}&gt;Increment&lt;/button&gt;          <br/>           &lt;button onClick={this.incrementWithDebounced}&gt; Increment with Debounce&lt;/button&gt; <br/>         &lt;/div&gt; <br/>        &lt;/div&gt; <br/>         ); <br/>   }<br/>}</span></pre><p id="668a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里使用去反跳函数，我们会注意到我们可以任意多次点击带有去反跳的增量，但是它只会在我们停止点击后执行。其代码类似于前面的节流组件，但只有去抖方法。</p><p id="25c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，虽然油门依赖于简单的<code class="fe ml mm mn mo b">true </code>或<code class="fe ml mm mn mo b">false</code>，但有了去抖，我们需要保持对计时器的访问。我们从节点模块实现了<code class="fe ml mm mn mo b">timer </code>,因为我们需要在每次方法被再次调用时清除之前的超时。然后，我们设置一个新的超时方法来调用内部方法。</p><p id="a715" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是<strong class="jx io">去抖</strong>的实现方式。</p><p id="7e5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，JavaScript节流和去反跳的总体概念在本文中完全转换了。</p></div></div>    
</body>
</html>