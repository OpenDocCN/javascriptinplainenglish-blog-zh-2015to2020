<html>
<head>
<title>Magical JavaScript behaviors I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神奇的JavaScript行为I</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/magical-javascript-behaviors-4b5c4d151663?source=collection_archive---------4-----------------------#2020-03-10">https://javascript.plainenglish.io/magical-javascript-behaviors-4b5c4d151663?source=collection_archive---------4-----------------------#2020-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ea4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简短、有用的JavaScript课程——让它变得简单。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/16978ba3bcbfe2660846969768791a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moV4XtnRPQt8W5uIZNwDQg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A man throwing dice</figcaption></figure><h1 id="c809" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">第一部分</h1><p id="383f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在我想写的关于这个主题的第一篇文章中，我收集了一系列JavaScript特有的行为。我用一些简单的例子来解释它们，并展示如何避免它们，因为它们会导致在我们的代码处于生产阶段时很难检测到的错误。</p><h1 id="fd29" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">案例</h1><ul class=""><li id="7d7b" class="mj mk iq lp b lq lr lt lu lw ml ma mm me mn mi mo mp mq mr bi translated">真等于假</li><li id="4876" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">最小值大于零</li><li id="cb74" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">南不是南</li><li id="63e6" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">神奇地求和</li><li id="c4a7" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">数字的比较</li><li id="c5db" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">Try-catch-finally上的意外返回值</li><li id="7405" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">箭头功能</li><li id="3e2f" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">神秘回归</li><li id="d851" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">关系运算符为空</li><li id="cf30" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">蝙蝠侠！</li></ul><h1 id="e01b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">真等于假</h1><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1d4d" class="nc kw iq my b gy nd ne l nf ng">!!"false"==!!"true";  //true<br/>!!"false"===!!"true"; //true</span></pre><p id="c1c9" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4873" class="nc kw iq my b gy nd ne l nf ng">//true is 'truthy' and represented <br/>//by the number 1,<br/>//'true' in string form is NaN.<br/>//false (1 == NaN)<br/>true == "true";   <br/>false == "false"; <br/>//false</span><span id="0f1f" class="nc kw iq my b gy nm ne l nf ng">//'false' is not the <br/>//empty string,<br/>//so it's a truthy value<br/>!!"false"; //true<br/>!!"true";  //true</span></pre><h2 id="1aee" class="nc kw iq bd kx nn no dn lb np nq dp lf lw nr ns lh ma nt nu lj me nv nw ll nx bi translated">最小值大于零</h2><p id="2968" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">号码。MIN_VALUE是最小的数字，在JavaScript中似乎大于零:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="757a" class="nc kw iq my b gy nd ne l nf ng">Number.MIN_VALUE &gt; 0; <br/>//true</span></pre><p id="a5fc" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="6c3b" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">号码。MIN_VALUE是5e-324，即在float precision范围内可以表示的最小正数，也就是说，这是最接近零的数字。它定义了浮点数给你的最佳分辨率。</p><h1 id="032d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">南不是南</h1><p id="1000" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">第一，南是什么？</p><p id="7ee5" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">“NaN”是“Not a Number”的首字母缩写，当我们试图将一个数字转换为一种非数值类型的数据时，就会出现此错误，因此会引发异常“NaN”。IEEE 754浮点标准在1985年引入了NaN的使用。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="53b2" class="nc kw iq my b gy nd ne l nf ng">NaN === NaN; <br/>//false<br/>NaN == NaN;  <br/>//false</span></pre><p id="6750" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="a419" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">相关的IEEE标准定义了一个数值常数NaN(不是一个数字)。它规定NaN应该不等于自身进行比较，以避免由于当时计算机的十进制精度而导致的错误。</p><p id="95de" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">如果想知道某个东西是不是NaN，可以使用ES6 feature Object.is()。运行Object.is(NaN，NaN)返回true。</p><h1 id="7ddc" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">神奇地求和</h1><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="55f6" class="nc kw iq my b gy nd ne l nf ng">9999999999999999;       <br/>//10000000000000000 wtf!<br/>10000000000000000 + 1;   <br/>//10000000000000000 wtf!<br/>10000000000000000 + 1.1;<br/>//10000000000000002 wtf!<br/>10000000000000000 + 10; <br/>//10000000000000010</span></pre><p id="643d" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="3e52" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">这些事情是由IEEE 754–2008浮点运算标准引起的。它舍入到最接近的偶数。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a41f" class="nc kw iq my b gy nd ne l nf ng">10  - 2 <br/> //8<br/> 10  + 2 <br/> //12<br/>'10' -2  <br/> //8<br/>'10' +2  <br/> //102<br/>'10' -'2'<br/> //8<br/>'10' +'2'<br/>//102</span></pre><p id="57bd" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="c86a" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">数字-数字:减法<br/>数字+数字:加法</p><p id="0e1c" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">数字-字符串:减法<br/>数字+字符串:串联</p><p id="d50e" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">字符串-字符串:减法<br/>字符串+字符串:串联</p><h1 id="65e0" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">数字的比较</h1><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8dd5" class="nc kw iq my b gy nd ne l nf ng">1 &lt; 2 &lt; 3; <br/>//true<br/>3 &gt; 2 &gt; 1; <br/>//false</span></pre><p id="3cde" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="57c5" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">问题出在表达式的第一部分。您可以使用大于或等于运算符来修复它。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="30a6" class="nc kw iq my b gy nd ne l nf ng">1 &lt; 2 &lt; 3; <br/>//(1 &lt; 2) -&gt; true -&gt; 1<br/>true (1) &lt; 3;<br/>1 &lt; 3;     <br/>// true</span><span id="83b9" class="nc kw iq my b gy nm ne l nf ng">3 &gt; 2 &gt; 1; <br/>//(3 &gt; 2) -&gt; true -&gt; 1<br/>true &gt; 1; <br/>1 &gt; 1; <br/>// -&gt; false</span><span id="d4ad" class="nc kw iq my b gy nm ne l nf ng">3 &gt; 2 &gt;= 1; <br/>// (3 &gt; 2) -&gt; true -&gt; 1<br/>true &gt; 1; <br/>1 &gt;= 1; // -&gt; true</span></pre><h1 id="e04d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Try-catch-finally上的意外返回值</h1><p id="75fb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">下一个IIEF(立即调用的函数表达式)的结果是什么？</p><p id="f203" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">返回值为假。这是因为“Finally块”总是会执行。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="40d9" class="nc kw iq my b gy nd ne l nf ng">(() =&gt; {<br/> try {<br/>   return true;<br/> } finally {<br/>   return false;<br/> }<br/>})();<br/>//false</span></pre><p id="deac" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">您可以像下一个示例那样修复它:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d74d" class="nc kw iq my b gy nd ne l nf ng">(() =&gt; {<br/> let result = false;<br/> try {<br/>   result =  true;<br/> } finally {<br/>   return result;<br/> }<br/>})();<br/>//true</span></pre><h1 id="c63c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">箭头功能</h1><p id="ced1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">考虑下面的例子:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="54ad" class="nc kw iq my b gy nd ne l nf ng">let foo =() =&gt; {console.log("Hello!)};<br/>foo();<br/>//Hello</span><span id="702c" class="nc kw iq my b gy nm ne l nf ng">let foo2= () =&gt; {};<br/>foo2(); <br/>//undefined</span></pre><p id="9567" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="5131" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">您获得undefined，因为花括号是箭头函数语法的一部分。</p><p id="9da6" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">如果将返回值用括号括起来，可以解决这个问题并获得{}对象，如下例所示:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="9b69" class="nc kw iq my b gy nd ne l nf ng">let foo3 = () =&gt; ({});<br/>foo3();<br/>//{}</span></pre><h2 id="ff66" class="nc kw iq bd kx nn no dn lb np nq dp lf lw nr ns lh ma nt nu lj me nv nw ll nx bi translated">神秘回归</h2><p id="3a69" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">考虑下面的IIEF函数</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="41ce" class="nc kw iq my b gy nd ne l nf ng">(function() {<br/>  return<br/>  {<br/>    greeting: "Hello";<br/>  }<br/>})();<br/>//undefined</span></pre><p id="8d6f" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="1f69" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">这个返回是因为自动分号插入，它自动在大多数换行符后插入分号。</p><p id="aad4" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">结果函数类似于:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="594a" class="nc kw iq my b gy nd ne l nf ng">(function() {<br/>  return<strong class="my ir">;//!!</strong><br/>  {<br/>    greeting: "Hello";<br/>  }<br/>})();//undefined</span></pre><p id="10ac" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">您可以像下面的例子一样解决这个问题:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c768" class="nc kw iq my b gy nd ne l nf ng">(function() {<br/>  return { greeting: "Hello" }<br/>})();<br/>//{greeting: "Hello"}</span></pre><h1 id="9cb0" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">关系运算符为空</h1><p id="d499" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">接下来的比较行为很奇怪。根据这个例子，最后一个结果表明“null &gt;=0”，所以在上面的一个比较中，它必须为真。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2d6c" class="nc kw iq my b gy nd ne l nf ng">null &gt; 0<br/>//false<br/>null == 0<br/>//false<br/>null &gt;= 0 <br/>//true</span></pre><p id="f3a3" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="e3d9" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">原因是比较将null转换为数字0。这就是为什么null &gt;= 0为真，null &gt; 0为假。但是null和undefined的等式check ==是在没有任何转换的情况下定义的。这就是为什么null== 0是假的。</p><h1 id="65b1" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">蝙蝠侠！</h1><p id="3f33" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了完成这个JavaScript“神奇事物”的小列表，我们现在要做一些有趣的事情。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0d3d" class="nc kw iq my b gy nd ne l nf ng">Array(16).join('robin' — 1) + ' Batman!';<br/>//"NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"</span></pre><p id="1e40" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">解释:</p><p id="50a8" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated">NaN是计算' robin'-1的结果(它是NaN，因为你不能从一个字符串中减去1)。NaN被转换成一个字符串并连接16次，然后在末尾追加“Batman”。</p><h1 id="a942" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="3af5" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有了JavaScript，很明显你永远不会感到无聊，但是你必须明白为什么会出现这些情况，以避免将来的编码错误。我的想法是写更多关于这些“特殊”案例的文章，在那之前，我希望你喜欢这篇文章，你可以在<a class="ae ny" href="https://medium.com/@kesk/magical-javascript-behaviors-ii-8ca9beff77b4" rel="noopener">神奇的JavaScript行为II </a>中继续看更多的例子</p><h1 id="7eef" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">参考</h1><p id="7016" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这些例子大部分都是受Brian Leroux在2012年的<a class="ae ny" href="https://www.youtube.com/watch?v=et8xNAc2ic8" rel="noopener ugc nofollow" target="_blank">演讲</a>的启发。</p><p id="7326" class="pw-post-body-paragraph ln lo iq lp b lq nh jr ls lt ni ju lv lw nj ly lz ma nk mc md me nl mg mh mi ij bi translated"><a class="ae ny" href="https://www.pexels.com/es-es/@fotografierende?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">摄影爱好者的照片</a>。</p></div></div>    
</body>
</html>