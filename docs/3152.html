<html>
<head>
<title>Working with Node.js Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js流</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/working-with-nodejs-streams-a0d35aca0cc0?source=collection_archive---------1-----------------------#2020-09-04">https://javascript.plainenglish.io/working-with-nodejs-streams-a0d35aca0cc0?source=collection_archive---------1-----------------------#2020-09-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/3e2a2b9aee10fbea0be2cd2d33f201f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*IuR3RnHKQZkZv6Ahv3txmA.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Datastream</figcaption></figure><h2 id="e3ec" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是流？</h2><p id="53d0" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">流是可能不完整的数据集合，我们可能无法在内存中容纳它们。</p><p id="555e" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">当我们观看在线视频时，我们使用流。我们需要下载整个视频才能看吗？答案是否定的。因此，视频数据是不完整的，但我们可以观看我们想要的部分！</p><p id="db1f" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">假设我们正在上传一个12GB大小的视频。问题是我们的内存只有4GB。那么怎么可能上传这样的文件呢？答案是，使用流，我不需要使用内存，也不需要在内存中加载12GB的文件，我将在流中一个块一个块地发送这个文件。</p><h2 id="f88a" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Node.js中我们在哪里使用流？</h2><p id="4919" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">一些实现流接口的Node.js模块。<br/> HTTP响应是流中最常见的例子。HTTP响应在客户端是可读的流，在服务器端是可写的流。我们将讨论不同类型的流。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lr"><img src="../Images/088a11421577d964b2e060f571f114b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceaWdMsQiQuh2OlisaWE0g.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Screenshot from www.freecodecamp.com</figcaption></figure><h2 id="7c72" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">有哪些不同类型的流？</h2><ul class=""><li id="9c18" class="ma mb in kt b ku kv ky kz ke mc ki md km me ll mf mg mh mi bi translated">可写流:我们可以写这个流。</li><li id="ecdc" class="ma mb in kt b ku mj ky mk ke ml ki mm km mn ll mf mg mh mi bi translated">可读流:我们可以从这个流中读取。</li><li id="cc49" class="ma mb in kt b ku mj ky mk ke ml ki mm km mn ll mf mg mh mi bi translated">双工流:我们可以读写这个流。</li><li id="624a" class="ma mb in kt b ku mj ky mk ke ml ki mm km mn ll mf mg mh mi bi translated">转换:转换流是双工流，其中输出在某种程度上与输入相关。</li></ul><p id="a968" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">没有恰当的例子就不可能理解这些句子。让我们来看几个例子:</p><h2 id="61d6" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可写流示例</h2><p id="3409" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated"><strong class="kt io">写入HTTP响应</strong></p><p id="fd80" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这是一个简单的HTTP服务器，我们想看看是否可以写入HTTP响应:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mo"><img src="../Images/c64b0ac7847e036e907ba8c57f25508a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9QKonmmM8-7XHNvpsm5CUQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Simple HTTP server</figcaption></figure><p id="5424" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这是一台监听端口2000的服务器。正如你所看到的，我们已经用<code class="fe mp mq mr ms b">write</code>方法在这个可写的流上写了几行。如果我们向该端口发送请求，输出将如下所示:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mo"><img src="../Images/825a9352f28ac2cb7b285ace3fd0d635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLRCzH9Hh3tTAsHXbD27-A.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">The output of a request sent to port 2000</figcaption></figure><p id="2704" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">这段代码的另一个重要部分是在可写流上使用<code class="fe mp mq mr ms b">end</code>方法。</p><p id="954d" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如果我们不使用<code class="fe mp mq mr ms b">end()</code>方法，客户端将一直等到请求超时。</p><p id="61a3" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><strong class="kt io">写入文件</strong></p><p id="81ec" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我们想在一个文件中写一个特定的句子一百万次。</p><p id="6e04" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我们可以创建一个字符串，我们可以将这个句子追加一百万次，但是在现实世界中，我们不能这样做，因为有时这个变量的大小会超过我们的内存大小。这是流定义的一部分，我们可以用一个可写的流来填充我们的句子。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mt"><img src="../Images/c9f59e0b2fa5bf9866e87c6340004c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*slVZS_XBQYo4QhEp7e1Pig.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Writing to a file using fs.createWriteStream</figcaption></figure><h2 id="ac8e" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可读流示例</h2><p id="9b2d" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated"><strong class="kt io">从文件中读取</strong></p><p id="5eab" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">假设我们想从一个大文件中读取数据，比如我们用可写流创建的文件，我们想检查一个单词是否存在。因为将整个文件加载到内存中不是一个好主意，我们可以使用一个可读的流来代替。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mt"><img src="../Images/cd48fb205801b11cc2cf7d582356e3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PYD6Yb0MATw5YQjNBNRjA.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Reading from a file using a readable stream</figcaption></figure><p id="6f24" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">记住流是事件发射器，我们可以注册事件监听器。这里我们使用<code class="fe mp mq mr ms b">data</code>事件来记录数据。</p><h2 id="5ffd" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可读流的两种模式</h2><p id="e3a2" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">可读流有两种模式:</p><p id="5ae5" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated"><strong class="kt io">暂停模式</strong>和<strong class="kt io">流动模式</strong></p><p id="4c30" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">当我们使用<strong class="kt io">流动模式</strong>时，数据即将到来，我们必须使用事件处理程序并监听<code class="fe mp mq mr ms b">data</code>事件。实际上，当我们使用事件处理程序时，我们将可读流切换到<strong class="kt io">流动模式</strong>。为了改变流模式，我们可以使用<code class="fe mp mq mr ms b">paused()</code>方法和<code class="fe mp mq mr ms b">resume()</code>。在<strong class="kt io">暂停模式下，</strong>我们使用<code class="fe mp mq mr ms b">read()</code>方法读取数据。</p><h2 id="0472" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们如何从一个可读的流中读取并写入另一个可写的流？</h2><p id="d4f5" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">让我们用一个简单的例子来看看答案。我们知道HTTP响应在服务器上是一个可写的流，我们也知道我们可以从一个文件创建一个可读的流。所以让我们将文件的内容作为对用户的响应。我们有一个可读的流，我们想把它写入一个可写的流(响应)。</p><p id="73d7" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">第一种方法是使用事件处理程序:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mt"><img src="../Images/301ea73adddae66813a643000eecbc1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u06ho08a2vgJFxAttLpWYg.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">send a file in response</figcaption></figure><p id="675b" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如你所见，我们有两个事件监听器，一个用于向<code class="fe mp mq mr ms b">res</code>写入数据，一个用于结束响应。</p><p id="21e5" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">第二种方法是使用管道，就像Linux中的管道一样。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mt"><img src="../Images/c9364edce7e433315d6aadc6aa8f0102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUcaLGhWoqgDQ0Bas5uYUg.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Using pipe method</figcaption></figure><p id="5821" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">可读流有一个<code class="fe mp mq mr ms b">pipe</code>方法，我们可以用它来传递可写流。</p><h2 id="fd6a" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">双工流的例子</h2><p id="3309" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们可以使用<code class="fe mp mq mr ms b">stream</code>模块创建任何类型的流。</p><p id="110a" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">为了拥有一个双工流，我们需要同时实现<code class="fe mp mq mr ms b">read</code>和<code class="fe mp mq mr ms b">write</code>方法:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/7ca9cb97dadf534ba04df5ad63ec1179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_sG2m37ZKMT3vOstIw0KQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Duplex stream</figcaption></figure><p id="83e4" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我使用了可读流<code class="fe mp mq mr ms b">process.stdin</code>和可写流<code class="fe mp mq mr ms b">process.stdout</code>，所以当我在控制台上写东西时，我是在向那个双工流写东西。</p><h2 id="8c0b" class="jv jw in bd jx jy jz dn ka kb kc dp kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">转换流及其用法的示例</h2><p id="049f" class="pw-post-body-paragraph kr ks in kt b ku kv kw kx ky kz la lb ke lc ld le ki lf lg lh km li lj lk ll ig bi translated">我们需要使用<code class="fe mp mq mr ms b">stream.Transform</code>来创建一个转换流，我们需要做的就是实现转换方法。</p><p id="db2c" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">例如，我想用<code class="fe mp mq mr ms b">*</code>替换流的编号:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/bff325e88cac2b4fc6c31116fbfc7287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAENdwK70K6eaSKvRXfzvQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Simple transform stream to convert numbers of a string to *</figcaption></figure><p id="a8b7" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">如你所见，我们必须使用<code class="fe mp mq mr ms b">push</code>方法向可读流添加内容，我们可以访问来自可写流的<code class="fe mp mq mr ms b">chunk</code>。</p><p id="61f8" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">现在让我们看看结果是什么:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/bf40ee710b76b30920205ef5802e0f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dl2RGTMcWiZjMnkc4m7rg.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Console result of using a transform stream</figcaption></figure><p id="0093" class="pw-post-body-paragraph kr ks in kt b ku lm kw kx ky ln la lb ke lo ld le ki lp lg lh km lq lj lk ll ig bi translated">我输入了第一行，第二行由transform stream写到<code class="fe mp mq mr ms b">process.stdout</code>。</p></div></div>    
</body>
</html>