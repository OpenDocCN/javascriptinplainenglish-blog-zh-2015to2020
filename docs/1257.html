<html>
<head>
<title>Running Repetitive Test Code with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest运行重复的测试代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/running-repetitive-test-code-with-jest-d71bda3eb01d?source=collection_archive---------3-----------------------#2020-02-19">https://javascript.plainenglish.io/running-repetitive-test-code-with-jest-d71bda3eb01d?source=collection_archive---------3-----------------------#2020-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43f65a916cd7dd0c455de9600d3d90ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L49rWOmCvca-haiI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@benwhitephotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ben White</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4c9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的单元测试中，我们经常不得不编写在每次测试前后运行的测试代码。我们必须经常编写它们来运行代码，在测试前设置夹具，并在测试后运行代码来清理一切。</p><p id="438a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很容易地用Jest做到这一点，因为它附带了一些钩子来做到这一点。</p><p id="2c54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何以不重复的方式编写重复的安装和拆卸代码。</p><h1 id="35ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何编写安装和拆卸代码</h1><p id="ea98" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了Jest，我们可以通过使用<code class="fe me mf mg mh b">beforeEach</code>和<code class="fe me mf mg mh b">afterEach</code>钩子来编写安装和拆卸代码。</p><p id="8be5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">beforeEach</code>在每次测试前运行代码，<code class="fe me mf mg mh b">afterEach</code>在每次测试后运行代码。该顺序适用于一个<code class="fe me mf mg mh b">describe</code>块内，如果没有<code class="fe me mf mg mh b">describe</code>块，则适用于整个文件。</p><p id="1fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设我们在<code class="fe me mf mg mh b">example.js</code>中有以下代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7b12" class="mq lc iq mh b gy mr ms l mt mu">const getStorage = (key) =&gt; localStorage.getItem(key);<br/>const setStorage = (key, value) =&gt; localStorage.setItem(key, value);<br/>module.exports = {<br/>    getStorage,<br/>    setStorage<br/>}</span></pre><p id="4ae8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为他们编写的测试如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1376" class="mq lc iq mh b gy mr ms l mt mu">const { getStorage, setStorage } = require('./example');</span><span id="9016" class="mq lc iq mh b gy mv ms l mt mu">beforeEach(() =&gt; {<br/>    localStorage.setItem('foo', 1);<br/>    expect(localStorage.getItem('bar')).toBeNull();<br/>});</span><span id="3a1f" class="mq lc iq mh b gy mv ms l mt mu">afterEach(() =&gt; {<br/>    localStorage.clear();<br/>});</span><span id="06a4" class="mq lc iq mh b gy mv ms l mt mu">test('getStorage("foo") is 1', () =&gt; {<br/>    expect(getStorage('foo')).toBe('1');<br/>});</span><span id="3b9d" class="mq lc iq mh b gy mv ms l mt mu">test('setStorage saves data to local storage', () =&gt; {<br/>    setStorage('bar', 2);<br/>    const bar = +localStorage.getItem('bar');<br/>    expect(getStorage('foo')).toBe('1');<br/>    expect(bar).toBe(2);<br/>});</span></pre><p id="ed02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向<code class="fe me mf mg mh b">beforeEach</code>钩子传递一个回调函数，在下面的每个测试之前运行代码。</p><p id="ce43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们用一个带有键<code class="fe me mf mg mh b">'foo'</code>和值<code class="fe me mf mg mh b">'1'</code>的条目预填充本地存储。</p><p id="ed07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还检查本地存储中是否没有关键字为<code class="fe me mf mg mh b">'bar’</code>的项目:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="64d2" class="mq lc iq mh b gy mr ms l mt mu">expect(localStorage.getItem('bar')).toBeNull();</span></pre><p id="017d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们将在<code class="fe me mf mg mh b">afterEach</code>钩子中运行<code class="fe me mf mg mh b">localStorage.clear()</code>,所有测试都将通过上面的<code class="fe me mf mg mh b">expect</code>。</p><p id="e6c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们在每个测试运行之后，向<code class="fe me mf mg mh b">afterEach</code>传递一个回调来运行代码。</p><p id="f07c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过以下方式清除本地存储:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b777" class="mq lc iq mh b gy mr ms l mt mu">localStorage.clear();</span></pre><p id="5918" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当运行测试时，我们得到键为<code class="fe me mf mg mh b">'bar'</code>的条目是<code class="fe me mf mg mh b">null</code>，因为我们在第一次测试中没有填充它。</p><p id="2235" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二个测试中，我们将让那个<code class="fe me mf mg mh b">expect(getStorage(‘foo’)).toBe(‘1’);</code>通过，因为我们在我们的<code class="fe me mf mg mh b">beforeEach</code>钩子中用它填充了本地存储。</p><p id="9fbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后因为我们跑了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0992" class="mq lc iq mh b gy mr ms l mt mu">setStorage('bar', 2);</span></pre><p id="1090" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要保存一个带有键<code class="fe me mf mg mh b">'bar'</code>和值<code class="fe me mf mg mh b">'2'</code>的项目，我们将得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="12ea" class="mq lc iq mh b gy mr ms l mt mu">expect(bar).toBe(2);</span></pre><p id="f6f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过，因为我们在测试中保存了项目。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ad31672ddc2be7993a61b28ec5513eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4mwbwLzfTRbPJ3cV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@halgatewood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hal Gatewood</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="90a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步代码</h1><p id="cdc6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在上面的例子中，我们在钩子中运行同步代码。如果钩子接受一个<code class="fe me mf mg mh b">done</code>参数或者返回一个承诺，我们也可以在钩子中运行异步代码。</p><p id="536b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想运行一个接受回调的函数，并按如下方式异步运行它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3b64" class="mq lc iq mh b gy mr ms l mt mu">const asyncFn = (callback) =&gt; {<br/>    setTimeout(callback, 500);<br/>}</span></pre><p id="2732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">beforeEach</code>钩子中，我们可以如下运行<code class="fe me mf mg mh b">asyncFn</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1298" class="mq lc iq mh b gy mr ms l mt mu">const { asyncFn } = require('./example');</span><span id="a593" class="mq lc iq mh b gy mv ms l mt mu">beforeEach((done) =&gt; {<br/>    const callback = () =&gt; {<br/>        localStorage.setItem('foo', 1);<br/>        done();<br/>    }<br/>    asyncFn(callback);<br/>    expect(localStorage.getItem('bar')).toBeNull();<br/>});</span></pre><p id="a539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它和前面的<code class="fe me mf mg mh b">beforeEach</code>回调做同样的事情，只是它是异步完成的。注意，我们在回调中调用从参数传入的<code class="fe me mf mg mh b">done</code>。</p><p id="45d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们忽略它，测试就会超时而失败。测试中的代码和以前一样。</p><p id="e961" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过在传递给钩子的回调中返回承诺来等待承诺的解决。</p><p id="d607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在<code class="fe me mf mg mh b">example.js</code>中，我们可以编写以下函数来运行一个承诺:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f610" class="mq lc iq mh b gy mr ms l mt mu">const promiseFn = () =&gt; {<br/>    return new Promise((resolve) =&gt; {<br/>        localStorage.setItem('foo', 1);<br/>        resolve();<br/>    });<br/>}</span></pre><p id="800c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以将<code class="fe me mf mg mh b">promiseFn</code>放在<code class="fe me mf mg mh b">module.exports</code>中，然后在我们的<code class="fe me mf mg mh b">beforeEach</code>中运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0f17" class="mq lc iq mh b gy mr ms l mt mu">beforeEach(() =&gt; {<br/>    expect(localStorage.getItem('bar')).toBeNull();<br/>    return promiseFn();<br/>});</span></pre><p id="c353" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们运行了在这个钩子之前导入的<code class="fe me mf mg mh b">promiseFn</code>,并且我们返回了由那个函数返回的承诺，它像第一个例子一样设置本地存储，除了它是异步完成的。</p><p id="63ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在我们把所有东西放在一起之后，我们在<code class="fe me mf mg mh b">example.js</code>中有了下面的代码，我们在钩子中的测试代码中运行这些代码并进行测试:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="966f" class="mq lc iq mh b gy mr ms l mt mu">const getStorage = (key) =&gt; localStorage.getItem(key);<br/>const setStorage = (key, value) =&gt; localStorage.setItem(key, value);<br/>const asyncFn = (callback) =&gt; {<br/>    setTimeout(callback, 500);<br/>}<br/>const promiseFn = () =&gt; {<br/>    return new Promise((resolve) =&gt; {<br/>        localStorage.setItem('foo', 1);<br/>        resolve();<br/>    });<br/>}<br/>module.exports = {<br/>    getStorage,<br/>    setStorage,<br/>    asyncFn,<br/>    promiseFn<br/>}</span></pre><p id="cc11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">asyncExample.test.js</code>将钩子改为异步的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e4e2" class="mq lc iq mh b gy mr ms l mt mu">const { getStorage, setStorage, asyncFn } = require('./example');</span><span id="e5dc" class="mq lc iq mh b gy mv ms l mt mu">beforeEach((done) =&gt; {<br/>    const callback = () =&gt; {<br/>        localStorage.setItem('foo', 1);<br/>        done();<br/>    }<br/>    asyncFn(callback);<br/>    expect(localStorage.getItem('bar')).toBeNull();<br/>});</span><span id="37ca" class="mq lc iq mh b gy mv ms l mt mu">afterEach(() =&gt; {<br/>    localStorage.clear();<br/>});</span><span id="3706" class="mq lc iq mh b gy mv ms l mt mu">test('getStorage("foo") is 1', () =&gt; {<br/>    expect(getStorage('foo')).toBe('1');<br/>});</span><span id="fbad" class="mq lc iq mh b gy mv ms l mt mu">test('setStorage saves data to local storage', () =&gt; {<br/>    setStorage('bar', 2);<br/>    const bar = +localStorage.getItem('bar');<br/>    expect(getStorage('foo')).toBe('1');<br/>    expect(bar).toBe(2);<br/>});</span></pre><p id="77d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么在<code class="fe me mf mg mh b">example.test.js</code>中我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d741" class="mq lc iq mh b gy mr ms l mt mu">const { getStorage, setStorage } = require('./example');</span><span id="15d2" class="mq lc iq mh b gy mv ms l mt mu">beforeEach(() =&gt; {<br/>    localStorage.setItem('foo', 1);<br/>    expect(localStorage.getItem('bar')).toBeNull();<br/>});</span><span id="aee9" class="mq lc iq mh b gy mv ms l mt mu">afterEach(() =&gt; {<br/>    localStorage.clear();<br/>});</span><span id="dc88" class="mq lc iq mh b gy mv ms l mt mu">test('getStorage("foo") is 1', () =&gt; {<br/>    expect(getStorage('foo')).toBe('1');<br/>});</span><span id="1b2c" class="mq lc iq mh b gy mv ms l mt mu">test('setStorage saves data to local storage', () =&gt; {<br/>    setStorage('bar', 2);<br/>    const bar = +localStorage.getItem('bar');<br/>    expect(getStorage('foo')).toBe('1');<br/>    expect(bar).toBe(2);<br/>});</span></pre><p id="775f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，在<code class="fe me mf mg mh b">promiseExample.test.js</code>中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bbd4" class="mq lc iq mh b gy mr ms l mt mu">const { getStorage, setStorage, promiseFn } = require('./example');</span><span id="641e" class="mq lc iq mh b gy mv ms l mt mu">beforeEach(() =&gt; {<br/>    expect(localStorage.getItem('bar')).toBeNull();<br/>    return promiseFn();<br/>});</span><span id="31ec" class="mq lc iq mh b gy mv ms l mt mu">afterEach(() =&gt; {<br/>    localStorage.clear();<br/>});</span><span id="7a49" class="mq lc iq mh b gy mv ms l mt mu">test('getStorage("foo") is 1', () =&gt; {<br/>    expect(getStorage('foo')).toBe('1');<br/>});</span><span id="0504" class="mq lc iq mh b gy mv ms l mt mu">test('setStorage saves data to local storage', () =&gt; {<br/>    setStorage('bar', 2);<br/>    const bar = +localStorage.getItem('bar');<br/>    expect(getStorage('foo')).toBe('1');<br/>    expect(bar).toBe(2);<br/>});</span></pre><h1 id="da92" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">之前和之后</h1><p id="5d46" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在每个文件中只运行一次安装和拆卸代码，我们可以使用<code class="fe me mf mg mh b">beforeAll</code>和<code class="fe me mf mg mh b">afterAll</code>钩子。我们可以像处理<code class="fe me mf mg mh b">beforeEach</code>和<code class="fe me mf mg mh b">afterEach</code>钩子一样，用我们想要运行的代码传入回调。</p><p id="f381" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别是回调在文件中的测试运行之前和文件中的测试运行之后运行一次，而不是在每次测试之前和之后运行。</p><p id="ff75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">beforeAll</code>的回调在<code class="fe me mf mg mh b">beforeEach</code>的回调之后运行，而<code class="fe me mf mg mh b">afterAll</code>的回调在<code class="fe me mf mg mh b">afterEach</code>的回调之后运行。</p><p id="491b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该顺序适用于一个<code class="fe me mf mg mh b">describe</code>块内，如果没有<code class="fe me mf mg mh b">describe</code>块，则适用于整个文件。</p><h1 id="6e4c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仅运行一个测试</h1><p id="b16c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以编写<code class="fe me mf mg mh b">test.only</code>而不是<code class="fe me mf mg mh b">test</code>来只运行一个测试。这对于故障排除是很方便的，因为我们不必运行所有的测试，它帮助我们锁定失败的测试的问题。</p><p id="7ba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了编写所有测试都需要运行的测试代码，我们开玩笑地使用了<code class="fe me mf mg mh b">beforeEach</code>和<code class="fe me mf mg mh b">afterEach</code>钩子。</p><p id="1563" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了编写只在每个<code class="fe me mf mg mh b">describe</code>块或文件中运行的测试代码，我们可以使用<code class="fe me mf mg mh b">beforeAll</code>和<code class="fe me mf mg mh b">afterAll</code>钩子。</p><p id="82f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">beforeAll</code>的回调在<code class="fe me mf mg mh b">beforeEach</code>的回调之后运行，而<code class="fe me mf mg mh b">afterAll</code>的回调在<code class="fe me mf mg mh b">afterEach</code>的回调之后运行。</p></div></div>    
</body>
</html>