<html>
<head>
<title>JavaScript Best Practices — Ternaries, Promises, Arrays, and Alerts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—术语、承诺、数组和警报</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-ternaries-promises-arrays-and-alerts-2f2b7015d98e?source=collection_archive---------6-----------------------#2020-07-22">https://javascript.plainenglish.io/javascript-best-practices-ternaries-promises-arrays-and-alerts-2f2b7015d98e?source=collection_archive---------6-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/496c58fb968f368b6e8638760b77a9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RYp5BMdBCK7Vx_sX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danonline1995?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Muir</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5317" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="4386" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">三元表达式的操作数</h1><p id="288f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">三元表达式可以分布在多行之间。</p><p id="2f2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cb4f" class="mn lc iq mj b gy mo mp l mq mr">const foo = bar &lt; baz ? value1 : value2;</span></pre><p id="e6aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5123" class="mn lc iq mj b gy mo mp l mq mr">const foo = bar &lt; baz ?<br/>    value1 :<br/>    value2;</span></pre><p id="c639" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要一致，它们都是合适的。</p><h1 id="ad7e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造函数名称应该以大写字母开头</h1><p id="46cc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该以大写字母开始构造函数的名字。</p><p id="3c0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="35e1" class="mn lc iq mj b gy mo mp l mq mr">const friend = new Person();</span></pre><p id="55c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a824" class="mn lc iq mj b gy mo mp l mq mr">const friend = new person();</span></pre><p id="f2cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个普遍接受的约定，因此我们应该遵循它以保持一致性。</p><h1 id="7cb5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调用不带参数的构造函数时使用括号</h1><p id="72e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当调用不带参数的构造函数时，我们应该加上括号。</p><p id="3b14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们可以跳过它，我们也应该添加它，这样人们就知道我们正在调用它。</p><p id="dc38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a506" class="mn lc iq mj b gy mo mp l mq mr">const person = new Person;</span></pre><p id="c591" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ac5f" class="mn lc iq mj b gy mo mp l mq mr">const person = new Person();</span></pre><h1 id="c848" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">变量声明后的空行</h1><p id="cd1e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可能希望在声明一组变量后添加一行。</p><p id="d45a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1547" class="mn lc iq mj b gy mo mp l mq mr">let foo;<br/>let bar;</span><span id="e7e9" class="mn lc iq mj b gy ms mp l mq mr">let abc;</span></pre><p id="0375" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用空行将变量分组。</p><h1 id="59cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">return</code>语句前的空行</h1><p id="2e50" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该删除<code class="fe mt mu mv mj b">return</code>语句前的空行。</p><p id="db19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6f17" class="mn lc iq mj b gy mo mp l mq mr">function foo() {<br/>  return;<br/>}</span></pre><p id="32be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2cb1" class="mn lc iq mj b gy mo mp l mq mr">function foo() {<br/> <br/>  return;<br/>}</span></pre><p id="7301" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多余的空行看起来很奇怪，对清晰没有帮助。</p><h1 id="a924" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">方法链中每次调用后换行</h1><p id="6dc9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们调用一长串的方法，我们应该把它们放在自己的行中。</p><p id="3764" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dc46" class="mn lc iq mj b gy mo mp l mq mr">$("#p").css("color", "green").slideUp(2000).slideDown(2000);</span></pre><p id="ab13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="104f" class="mn lc iq mj b gy mo mp l mq mr">$("#p")<br/>  .css("color", "green")<br/>  .slideUp(2620)<br/>  .slideDown(2420);</span></pre><p id="b5c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">减少水平滚动是好的。</p><p id="7366" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">差异也更容易阅读。</p><h1 id="a54e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">警报的使用</h1><p id="ad8d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe mt mu mv mj b">alert</code>进行调试。</p><p id="97db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">console</code>物体或<code class="fe mt mu mv mj b">debugger</code>可以用于此。</p><p id="15c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以使用<code class="fe mt mu mv mj b">alert</code>来显示警报。</p><p id="ba34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">console</code>有多种方法记录表达式值。</p><p id="5e69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的代码中设置一个断点。</p><h1 id="81bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">Array</code>构造函数</h1><p id="3dcb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">Array</code>构造函数有一个很好的用途。</p><p id="4b30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来创建空数组并用数据填充它。</p><p id="d68a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3ef9" class="mn lc iq mj b gy mo mp l mq mr">Array(10).fill().map((_, i) =&gt; i)</span></pre><p id="af86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个包含从0到9的条目的数组。</p><p id="98f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用10调用<code class="fe mt mu mv mj b">Array</code>构造函数来创建10个空条目。</p><p id="2af3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe mt mu mv mj b">map</code>将条目映射到整数。</p><h1 id="2865" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有作为承诺执行者的异步函数</h1><p id="3f22" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">async</code>函数已经返回了承诺，所以我们不应该把它放在构造函数中。</p><p id="3ddb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是多余的，任何错误都会丢失，不会导致<code class="fe mt mu mv mj b">Promise</code>构造函数拒绝。</p><p id="36bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8a32" class="mn lc iq mj b gy mo mp l mq mr">const result = new Promise(async (resolve, reject) =&gt; {<br/>  readFile('foo.txt', (err, result) =&gt; {<br/>    if (err) {<br/>      reject(err);<br/>    } else {<br/>      resolve(result);<br/>    }<br/>  });<br/>});</span></pre><p id="c80f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="03f1" class="mn lc iq mj b gy mo mp l mq mr">const result = new Promise((resolve, reject) =&gt; {<br/>  readFile('foo.txt', (err, result) =&gt; {<br/>    if (err) {<br/>      reject(err);<br/>    } else {<br/>      resolve(result);<br/>    }<br/>  });<br/>});</span></pre><p id="8e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只在非<code class="fe mt mu mv mj b">async</code>功能中使用它。</p><h1 id="85b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">No await</code>内部循环</h1><p id="c5c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该将我们的条目映射到一个承诺数组，并使用<code class="fe mt mu mv mj b">Promise.all</code>来并行运行它们，而不是遍历每个条目并等待它们解决。</p><p id="e20e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等待要慢得多，我们可以并行运行它们，因为它们彼此不依赖。</p><p id="d2cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="235d" class="mn lc iq mj b gy mo mp l mq mr">const foo = async (things) =&gt; {<br/>  const results = [];<br/>  for (const thing of things) {<br/>    results.push(await bar(thing));<br/>  }<br/>  return baz(results);<br/>}</span></pre><p id="b338" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b01f" class="mn lc iq mj b gy mo mp l mq mr">const = async (items) =&gt; {<br/>  const results = items.map(thing =&gt; toPromise(item));<br/>  return baz(await Promise.all(results));<br/>}</span></pre><p id="29cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个函数将<code class="fe mt mu mv mj b">things</code>映射到一个承诺数组。</p><p id="9ca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe mt mu mv mj b">await</code>和<code class="fe mt mu mv mj b">Promise.all</code>同时呼叫他们。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/4ae275dd7acfa3dc70d887bbfe96007e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aOTswTgerv9BhNeo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lakael?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lauren Kay</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2295" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d8fc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该用<code class="fe mt mu mv mj b">Promise.all</code>来称呼独立的诺言。</p><p id="ecbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变量声明可以用线分组。</p><p id="86f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">三元表达式可以放在一行或多行中。</p><p id="f138" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法链可以放在多行中。</p><p id="1f18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">永远不要将<code class="fe mt mu mv mj b">async</code>函数放在<code class="fe mt mu mv mj b">Promise</code>构造函数中。</p><p id="3fba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">Array</code>构造函数适合创建空数组。</p><h1 id="a8af" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="4a5d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>