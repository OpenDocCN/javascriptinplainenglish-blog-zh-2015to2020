<html>
<head>
<title>Building Web Applications with Kotlin and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin和TypeScript构建Web应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-applications-with-kotlin-and-typescript-8a165e76252c?source=collection_archive---------1-----------------------#2020-01-07">https://javascript.plainenglish.io/building-applications-with-kotlin-and-typescript-8a165e76252c?source=collection_archive---------1-----------------------#2020-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="74b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">克服整合问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/15a1d90153f61d5d1ad16bab14a1987a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbRPHNtBVeHUKRerhVHiQw.png"/></div></div></figure><p id="4cf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Kotlin 是许多针对JVM的新语言之一。然而，我发现Kotlin特别有用的一点是它面向多个平台，而不仅仅是JVM。</p><p id="2b76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在web应用程序的上下文中，Kotlin 的这种<a class="ae ln" href="https://kotlinlang.org/docs/reference/multiplatform.html" rel="noopener ugc nofollow" target="_blank">多平台特性使我们能够用Kotlin编写一次代码，然后在JVM后端和JavaScript前端使用这些代码。这对于在前端浏览器和后端服务器之间传递复杂的数据结构特别有用。</a></p><p id="c98e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文描述了我在将Kotlin生成的模块与一个<a class="ae ln" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>浏览器应用程序集成时遇到的问题，当然也包括我是如何克服这些问题的。有些解决方案需要一些相当复杂的<a class="ae ln" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>构建脚本代码。我已经通过提供一个<a class="ae ln" href="https://github.com/dhakehurst/net.akehurst.kotlin.kt2ts" rel="noopener ugc nofollow" target="_blank"> Gradle-plugin简化了集成，该插件包装了复杂性</a>，但是下面为那些真正想了解遇到的问题和可能的解决方案的人提供了完整的解释。</p><h1 id="3ce9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">介绍</h1><p id="2aca" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">集成的环境是在服务器端(后端)使用JVM的Web应用程序，而浏览器应用程序(前端)是使用基于类型脚本的框架开发的，例如<a class="ae ln" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>或<a class="ae ln" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>(带有类型脚本选项)。</p><p id="837f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JVM方面，Kotlin的集成很容易，通过适当的构建工具(即Gradle和<a class="ae ln" href="https://plugins.gradle.org/plugin/org.jetbrains.kotlin.multiplatform" rel="noopener ugc nofollow" target="_blank"> Kotlin多平台插件</a>)，Kotlin代码被构建到一个易于使用的jar模块中。这可以像任何其他JVM jar一样使用。</p><p id="c494" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript方面稍微复杂一点。构建工具将编译Kotlin代码并提供(默认情况下)一个包含<a class="ae ln" href="https://github.com/umdjs/umd" rel="noopener ugc nofollow" target="_blank"> UMD </a> JavaScript模块的jar。棘手的部分是将它集成到基于<a class="ae ln" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的浏览器应用程序构建中。</p><p id="3298" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将讨论基于角度的浏览器应用程序的相关问题。然而，我也用一个基于React-TypeScript的应用程序做了同样的事情，并且这个解决方案在两种情况下都有效。</p><p id="477f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在将Kotlin模块集成到Angular build中时，存在许多不同的问题:</p><p id="34be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1.Angular希望在Node.js环境中构建一个项目，该环境<br/> a .希望模块依赖关系是package.json文件<br/>的一部分b .希望这些模块在node_modules目录中被解包(通常由<a class="ae ln" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>、<a class="ae ln" href="https://yarnpkg.com/lang/en/" rel="noopener ugc nofollow" target="_blank"> yarn </a>等)</p><p id="a752" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.Angular需要包含TypeScript声明文件的模块。<br/> -虽然可以使用普通的JavaScript，但没有静态类型信息来帮助编译器(或IDE中的开发人员)。</p><p id="9bc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.序列化，浏览器和服务器之间的数据通信。(我将在另一篇文章中讨论这个问题，因为它本身就是一个大话题。)</p><p id="b289" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解释如何克服前两个问题，我将使用一个小的示例应用程序。该应用程序是一个简单的在线地址簿。我不会(在本文中)讨论认证、安全或数据保护方面的问题。我只是用这个例子来说明如何集成应用程序的Kotlin和Angular部分。</p><p id="4f33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该示例和讨论基于:</p><p id="3870" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">科特林1.3.61 <br/>百分度6.0.1 <br/>角度9.0.0</p><blockquote class="ml mm mn"><p id="3cd7" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">本文并没有(明确地)包含该示例的所有代码，我只是强调了特定于该主题并且需要解释的那些部分。完整的代码可以在<a class="ae ln" href="https://github.com/dhakehurst/example.kotlin.angular" rel="noopener ugc nofollow" target="_blank"> github </a>中找到。</p></blockquote><h1 id="ed4c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">构建脚本</h1><p id="c9d9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">首先，我将描述应用程序的构建脚本和目录结构。我将使用Gradle作为构建工具。(原因很简单，因为在撰写本文时，Gradle是我首选的构建工具。我确信使用其他构建工具也可以采用同样的方法。)</p><p id="6883" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该示例是一个包含以下模块的<a class="ae ln" href="https://docs.gradle.org/current/userguide/multi_project_builds.html" rel="noopener ugc nofollow" target="_blank">多模块梯度构建</a>:</p><ol class=""><li id="9a77" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated"><strong class="kt ir">服务器</strong> : Kotlin-JVM后端和托管前端</li><li id="3fce" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><strong class="kt ir">客户端</strong>:基于Angular/Kotlin-JS浏览器的前端</li><li id="1d8f" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><strong class="kt ir">信息</strong>:前后台传递的通用数据结构</li><li id="591e" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><strong class="kt ir"> user-api </strong>:描述用户(前端)和核心(后端)之间交互的通用接口</li><li id="29c8" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><strong class="kt ir"> user2core </strong>:处理数据序列化和去序列化的通用模块</li></ol><p id="3c99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用目录结构，如:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="6a2f" class="nl lp iq nh b gy nm nn l no np">root<br/> ├╴ client<br/> ├╴ information<br/> ├╴ server<br/> ├╴ user-api<br/> ├╴ user2core</span></pre><p id="54a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有一个<strong class="kt ir">根</strong><a class="ae ln" href="https://docs.gradle.org/current/userguide/kotlin_dsl.html#sec:scripts" rel="noopener ugc nofollow" target="_blank">build . grade le . kts</a>文件来建立Kotlin多平台构建。根构建脚本添加了<a class="ae ln" href="https://kotlinlang.org/docs/reference/building-mpp-with-gradle.html#gradle-plugin" rel="noopener ugc nofollow" target="_blank"> Kotlin Multiplatform插件</a>(但没有在根级别应用):</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="90c9" class="nl lp iq nh b gy nm nn l no np"><em class="mo">//from file: root/build.gradle.kts</em></span><span id="6e96" class="nl lp iq nh b gy nq nn l no np">plugins {<br/>    kotlin("multiplatform") version ("1.3.60") apply false<br/>}</span></pre><p id="f835" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它还为每个Gradle子项目应用和配置插件:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="954e" class="nl lp iq nh b gy nm nn l no np"><em class="mo">//from file: root/build.gradle.kts</em></span><span id="0297" class="nl lp iq nh b gy nq nn l no np">subprojects {<br/>  apply(plugin = "org.jetbrains.kotlin.multiplatform")<br/>  configure&lt;KotlinMultiplatformExtension&gt; {<br/>    js("js") {        // we want to build for a JS target<br/>      browser()<br/>    }<br/>    jvm("jvm8") {     // we want to build for a JVM target<br/>      ...<br/>    }<br/>  }   <br/>}</span></pre><h1 id="14d4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">信息模块</h1><p id="b355" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">信息模块将由JVM <strong class="kt ir">服务器</strong>模块和JS <strong class="kt ir">客户端</strong>模块使用。为了确保可以为两个目标构建Kotlin代码，确保代码是Kotlin通用代码是很重要的。(或者，您必须提供相同代码的两个版本，每个目标平台一个。但这是我们试图避免的。)</p><p id="d566" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">kot Lin-公共代码位于<strong class="kt ir"> commonMain </strong>目录中，如下所示:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="f4a1" class="nl lp iq nh b gy nm nn l no np">root<br/> ├╴ client<br/> ├╴ information<br/> ┆  └╴src<br/> ┆     └╴commonMain<br/> ┆        └╴kotlin<br/> ┆           └╴information.kt<br/> ├╴ server<br/> ┆</span></pre><p id="9de6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Kotlin代码本身只是几个定义示例所需数据结构的数据类:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="7cef" class="nl lp iq nh b gy nm nn l no np"><em class="mo">//from file: information.kt</em></span><span id="2d4b" class="nl lp iq nh b gy nq nn l no np">data class AddressBook(val title: String) {<br/>    var contacts = mutableMapOf&lt;String, Contact&gt;()<br/>}</span><span id="7eb1" class="nl lp iq nh b gy nq nn l no np">data class Contact(val alias: String) {<br/>    var firstName: String? = null<br/>    var lastName: String? = null<br/>    var phoneNumbers = mutableMapOf&lt;String, PhoneNumber&gt;()<br/>}</span><span id="5865" class="nl lp iq nh b gy nq nn l no np">data class PhoneNumber(val label: String, val number: String)</span></pre><p id="f596" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">信息</strong>模块的构建脚本不需要任何特定的东西(目前),因为根构建脚本配置所有子模块为JVM和JS目标平台构建。</p><h1 id="9193" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">客户端模块</h1><p id="b5b8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这是角度代码所在的位置。我们希望它的构建能够在Gradle构建中被触发。但是在角度构建开始之前，我们必须解决第一个问题。也就是说，我们需要将Kotlin构建的JavaScript模块放入node_modules目录中，正如Angular构建所期望的那样。</p><p id="da2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们从添加Gradle依赖配置开始，该配置用于处理我们希望集成到Angular构建中的Kotlin模块的依赖关系。</p><blockquote class="ml mm mn"><p id="453e" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">定义<a class="ae ln" href="https://blog.gradle.org/gradle-metadata-1.0" rel="noopener ugc nofollow" target="_blank">渐变元数据</a>属性很重要，这些属性应该用于匹配所需的依赖关系。Kotlin多平台构建大量使用grade le元数据，以解决grade le对正确人工产物的依赖性。</p></blockquote><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="9025" class="nl lp iq nh b gy nm nn l no np"><em class="mo">//from file: client/build.gradle.kts</em></span><span id="649c" class="nl lp iq nh b gy nq nn l no np">val nodeKotlin by configurations.creating {<br/>  attributes {<br/>    attribute(KotlinPlatformType.attribute, KotlinPlatformType.js)<br/>    attribute(<br/>      Usage.USAGE_ATTRIBUTE,<br/>      project.objects.named(<br/>          Usage::class.java,<br/>          KotlinUsages.KOTLIN_RUNTIME<br/>      )<br/>    )<br/>  }<br/>}</span></pre><p id="d66e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该配置被配置为匹配为JS平台构建并在运行时使用的人工产物。KOTLIN_RUNTIME用法(与KOTLIN_API相反)意味着Gradle将收集运行时所需的所有依赖关系。</p><p id="580e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用这种依赖配置向所需的Kotlin模块添加依赖:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="966e" class="nl lp iq nh b gy nm nn l no np"><em class="mo">//from file: client/build.gradle.kts</em></span><span id="bf1e" class="nl lp iq nh b gy nq nn l no np">dependencies {<br/>  nodeKotlin(project(":information"))<br/>}</span></pre><p id="fede" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，棘手的部分是，我们需要解析所有的<strong class="kt ir"> nodeKotlin </strong>依赖项(过渡地)并将解析的工件(包含JavaScript代码的jar)解包到node_modules目录中。</p><h2 id="36a1" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">打开Kotlin模块的包装</h2><p id="ee78" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">幸运的是，Kotlin Mutiplatform Gradle插件带来了一些任务，使我们能够运行Node和<a class="ae ln" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"> Yarn </a>命令。我们不需要明确地将node和Yarn集成到Gradle构建中(例如通过<a class="ae ln" href="https://plugins.gradle.org/plugin/com.moowork.node" rel="noopener ugc nofollow" target="_blank"> moowork node插件</a>，这是一个伟大的、独立于Kotlin的、用于从Gradle执行Node的替代方案), Kotlin插件提供的Node和Yarn任务已经提供了。</p><p id="d98d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，虽然Kotlin Muliplatform插件也创建了一个node_modules目录，其中包含了我们需要的许多JavaScript模块，但我无法找到一种好的方法让Angular代码使用Kotlin Gradle插件创建的node_modules目录。Angular构建需要自己的node_modules，它位于angular.json和package.json文件的旁边。(我考虑的唯一选择是创建<a class="ae ln" href="https://medium.com/@meghamohan/hard-link-and-symbolic-link-3cad74e5b5dc" rel="noopener">硬链接</a>来欺骗Angular认为node_modules是它想要的。)</p><p id="ec7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我定义了一系列任务来构建(安装)预期的node_modules目录，然后将Kotlin-JS模块放入其中。这些任务如下:</p><ol class=""><li id="4bca" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated"><strong class="kt ir"> yarnInstall </strong>:使用对yarn的调用，安装Angular应用程序所需的JS模块。</li><li id="93c9" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><strong class="kt ir"> unpackKotlinJs </strong>:从Gradle构建脚本中定义的nodeKotlin依赖项中解包Js文件。</li><li id="67e3" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><strong class="kt ir"> nodeBuild </strong>:调用Angular/Node.js构建。</li></ol><h2 id="e8f0" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">在TypeScript代码中使用Kotlin生成的模块</h2><p id="b42b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一旦任务<strong class="kt ir"> unpackKotlinJs </strong>被执行，我们就可以开始开发Angular/TypeScript代码了，因为Kotlin-JS模块应该都在node_modules目录中，正如我们所期望的那样。</p><p id="62e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我尝试了两种选择。</p><ol class=""><li id="2999" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">包括Kotlin生成的JavaScript作为“脚本”。直接在网页中(通过脚本标签)或通过angular.json中的“脚本”部分</li><li id="1351" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">只需使用import语句，让JavaScript模块捆绑器和加载器(即通过webpack)处理一切。</li></ol><p id="3625" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的第一种方法是将代码作为脚本包含在内，但是尽管这样做可行，但并不理想。使用TypeScript import语句肯定是更好的选择。</p><p id="8865" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以将Kotlin生成的模块导入到TypeScript文件中，如下所示:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="a3fb" class="nl lp iq nh b gy nm nn l no np">import * as info_js from 'example.addressbook-information';<br/>import info = info_js.example.addressbook.information;</span><span id="59c8" class="nl lp iq nh b gy nq nn l no np">...</span><span id="228f" class="nl lp iq nh b gy nq nn l no np">let contact = new info.Contact('alias')</span></pre><p id="37c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们做到了！导入到Angular-Typescript组件中的Kotlin模块。</p><p id="9316" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个import语句并不重要，但是它为模块内容创建了一个很好的别名。Kotlin-JS代码是用JavaScript对象生成的，这些对象反映了最初的Kotlin包声明，所以每次我们想要使用Kotlin生成的项时，导入别名使我们不必写出完全限定的名称。</p><blockquote class="oc"><p id="2900" class="od oe iq bd of og oh oi oj ok ol lm dk translated">但是，等一下！！！</p></blockquote><p id="8280" class="pw-post-body-paragraph kr ks iq kt b ku om jr kw kx on ju kz la oo lc ld le op lg lh li oq lk ll lm ij bi translated">我用Kotlin写了这些类，这是一种很好的静态类型语言。我的类型信息都到哪里去了？根据TypeScript，我从Kotlin-JS模块中导入的所有东西的类型都是‘any ’!</p><p id="a0bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为Kotlin没有生成类型信息。(尽管似乎有一个<a class="ae ln" href="https://youtrack.jetbrains.com/issue/KT-16604" rel="noopener ugc nofollow" target="_blank">计划在Kotlin </a>的1.4版本中引入这个。)</p><h1 id="1f34" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Kotlin代码的类型脚本类型</h1><p id="a4af" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在<a class="ae ln" href="https://plugins.gradle.org/search?term=kotlin+typescript" rel="noopener ugc nofollow" target="_blank"> Gradle插件注册中心</a>发布了一些Gradle插件，旨在为Kotlin代码提供类型声明。然而，在撰写本文时，没有一个可用的选项能满足我的需求。</p><p id="7aab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现有的*.d.ts生成器也不适合我的用例，并且/或者需要在Kotlin类上添加注释。</p><p id="059c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我特别不想要(第三方)注释，因为这会将Kotlin代码的依赖关系放到TypeScript生成器上，我强烈认为这是一个糟糕的依赖关系。我的Kotlin类应该乐于成为纯粹的普通Kotlin代码，不需要知道它们是如何被使用的或者在哪里被使用的。他们肯定不需要了解任何关于TypeScript的知识。</p><p id="fbeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，我自己写了*.d.ts生成器。</p><p id="515d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的用例中，这实际上比预期的要容易。主要是因为我正在一个包含JVM目标的Kotlin多平台构建的环境中工作。</p><p id="6304" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用一些Kotlin反射和Kotlin字符串模板，我们可以遍历必要的Kotlin公共类(来自信息模块),并生成一个包含等效的TypeScript声明的*.d.ts文件。(当然，如果我们没有在构建中包含JVM目标，这是不可能的。)</p><p id="7830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还需要创建一个package.json文件，该文件包含一个引用生成的类型声明的“types”条目，以及对生成的JavaScript代码的引用。像这样简单的事情就足够了:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="7d55" class="nl lp iq nh b gy nm nn l no np">{<br/>  "name": "com.example-my-module-common"<br/>  "version": "1.0.0",<br/>  "main": "./com.example-my-module-common.js",<br/>  "types": "./com.example-my-module-common.d.ts"<br/>}</span></pre><h2 id="ccbe" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">第三方库的类型脚本声明</h2><p id="ef32" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">除了在您自己的项目中为Kotlin代码生成类型脚本声明之外，很快就会发现为其他第三方库(尤其是Kotlin stdlib)生成类型脚本声明也是必要的。</p><p id="b6d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，假设第三方库也是一个Kotlin多平台库，有一个JVM目标，可以使用相同的(JVM反射)方法。</p><blockquote class="oc"><p id="0ff7" class="od oe iq bd of og oh oi oj ok ol lm dk translated">除了Kotlin标准库！</p></blockquote><p id="dd36" class="pw-post-body-paragraph kr ks iq kt b ku om jr kw kx on ju kz la oo lc ld le op lg lh li oq lk ll lm ij bi translated">在JVM上，Kotlin stdlib被分成多个不同的模块。在JavaScript目标上，Kotlin提供了一个包含所有内容的特定“kot Lin”JavaScript模块。因此，我发现有必要手动为Kotlin stdlib显式创建TypeScript声明。(嗯，还不是全部。只有我需要的部分-一个持续的任务来增加这一点。)</p><p id="61ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，有问题的是，JavaScript模块名不一定与JVM模块名匹配！。他们有时会，但不总是。</p><blockquote class="ml mm mn"><p id="6920" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">Gradle/Maven基础设施有一个很好的<a class="ae ln" href="https://maven.apache.org/guides/mini/guide-naming-conventions.html" rel="noopener ugc nofollow" target="_blank">全球接受的命名约定</a>的<code class="fe or os ot nh b">&lt;group&gt;:&lt;name&gt;:&lt;version&gt;</code>，这使我能够确保我的模块身份永远不会与其他人的冲突，因为我拥有<code class="fe or os ot nh b">&lt;group&gt;</code>，它是我的反向域名。</p><p id="d3be" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">不幸的是，JavaScript世界没有这么好的约定。更不幸的是，Kotlin生成的JavaScript模块的名称似乎没有遵循任何约定。(尽管它可以很容易地使用来自Gradle构建信息的<code class="fe or os ot nh b">&lt;group&gt;</code>和<code class="fe or os ot nh b">&lt;name&gt;</code>。)</p></blockquote><p id="fd17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，有必要向TypeScript声明代码生成器手动提供JVM ( <code class="fe or os ot nh b">&lt;group&gt;:&lt;name&gt;:&lt;version&gt;</code>)和Kotlin-JS模块名称之间的映射(如果它不遵循相同的约定)。生成器使用它将正确的导入添加到TypeScript声明文件中，以实现模块间的依赖关系。</p><h1 id="cffb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">其他考虑</h1><p id="4155" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我已经讨论了两个主要问题，类型脚本声明和构建环境的集成。然而，还有一些其他相关的兴趣点。</p><h2 id="21e3" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">托管前端代码</h2><p id="62d2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">鉴于它是一个Kotlin后端，我喜欢使用<a class="ae ln" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank"> Ktor.io </a>框架来托管前端代码。这个框架很容易建立，并且有很好的文档记录。例如，以下代码完成了所需的大部分工作:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="a708" class="nl lp iq nh b gy nm nn l no np">val server = embeddedServer(Jetty, port = port, host = host) {<br/>  install(DefaultHeaders)<br/>  install(CallLogging)<br/>  install(Routing)<br/>  install(Sessions) {<br/>    cookie&lt;String&gt;("SESSION_ID")<br/>  }<br/>  install(WebSockets) {<br/>  }<br/>  intercept(ApplicationCallPipeline.Features) {<br/>    call.sessions.set&lt;String&gt;(generateNonce())<br/>  }<br/>  install(SinglePageApplication) {<br/>    defaultPage = "index.html"<br/>    folderPath = "/dist"<br/>    spaRoute = ""<br/>    useFiles = false<br/>  }<br/>  routing {<br/>    webSocket("/ws") {<br/>      handleWebsocketConnection(this)<br/>    }<br/>  }<br/>}</span><span id="54aa" class="nl lp iq nh b gy nq nn l no np">server.start(true)</span></pre><p id="16fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的主要兴趣点是:</p><ol class=""><li id="595f" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">Ktor目前不支持单页应用程序。</li><li id="09a4" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在本例中，WebSockets用于浏览器-服务器通信，但这不是必需的。</li><li id="87ff" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">客户端代码被包装到一个jar中，并从类路径中提供(使用SinglePageApplication特性)。它也可以从文件路径提供。</li></ol><blockquote class="ml mm mn"><p id="5591" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">(Ktor确实支持静态路由，但是它不能很好地与前端路由一起工作。我目前使用的是<code class="fe or os ot nh b">com.github.lambda92:ktor-spa</code>的(略微)修改版本，它提供了你可以在上面的代码中看到的<code class="fe or os ot nh b">SinglePageApplication</code> Ktor特性。)</p></blockquote><h2 id="4497" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">从JavaScript调用Kotlin</h2><p id="c32a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一个重要的“T1”问题是，在<a class="ae ln" href="https://kotlinlang.org/docs/reference/js-to-kotlin-interop.html#jsname-annotation" rel="noopener ugc nofollow" target="_blank">特定情况</a>下，Kotlin编译器在以JavaScript为目标时会“破坏”函数名。</p><p id="23c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，为了确保我们生成的TypeScript声明和Kotlin生成的JavaScript之间的“正确”名称匹配。最好用Kotlin @JSName注释来注释Kotlin函数，您知道这些函数将在TypeScript中使用。(或者干脆全部注释！)</p><blockquote class="ml mm mn"><p id="f3f5" class="kr ks mo kt b ku kv jr kw kx ky ju kz mp lb lc ld mq lf lg lh mr lj lk ll lm ij bi translated">我不喜欢我们必须添加这个注释(如前所述，这是一个“错误的”依赖)。然而，至少它是由Kotlin stdlib提供的注释，所以不需要额外的库依赖。</p></blockquote><h2 id="b411" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">缺少模块、文本编码等</h2><p id="a89d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在JavaScript目标上常用的一些Kotlin库(例如，目前的Ktor)依赖于JavaScript模块，如文本编码、加密、http等。</p><p id="f6e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有必要告诉模块加载器(在基于Node.js的构建中)，这些模块将由浏览器提供，而不是试图在node_modules目录中查找模块。</p><p id="d651" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的应用程序中，我发现将它添加到package.json文件中是可行的(但这取决于所使用的特定模块加载器和配置):</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="e2fa" class="nl lp iq nh b gy nm nn l no np">{<br/>...<br/>"browser": {<br/>    "text-encoding": false,<br/>    "ws": false,<br/>    "fs": false,<br/>    "path": false,<br/>    "os": false,<br/>    "crypto": false,<br/>    "stream": false,<br/>    "http": false,<br/>    "tls": false,<br/>    "zlib": false,<br/>    "https": false,<br/>    "net": false<br/>  }<br/>}</span></pre><p id="3164" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，为了构建和运行JavaScript测试，可能需要将<code class="fe or os ot nh b">text-encoding</code>(尽管不再主动维护)作为一个显式的(package.json)依赖项。</p><h2 id="6b91" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">角度预算</h2><p id="6e80" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">目前，科特林图书馆相当大。我发现我棱角分明的身材几乎总是抱怨预算被超过。很好地使用<a class="ae ln" href="https://en.wikipedia.org/wiki/Tree_shaking" rel="noopener ugc nofollow" target="_blank">树抖动</a>和<a class="ae ln" href="https://en.wikipedia.org/wiki/Dead_code_elimination" rel="noopener ugc nofollow" target="_blank">死代码消除</a>技术通常会使这个问题变得更小。然而，当然，我们也可以简单地增加angular.json文件中定义的限制。</p><h1 id="604d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="1ea9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在我写这篇文章的时候，我已经用这种方法构建了几个不同规模和复杂度的项目。最初，在第一个项目中，我只是专注于将生成的Kotlin-JS代码与现有的Angular UI集成在一起。我没有TypeScript声明文件，只是使用angular.json脚本字段导入了Kotlin JavaScript。</p><p id="e839" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">鉴于IDE没有静态类型支持，开发需要老派的技术(即阅读Kotlin代码)，而不是使用IDE代码完成辅助。我不确定集成工作是否真的值得。在TypeScript中简单地复制数据类肯定会更快(在一个小项目中)。</p><p id="9f39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，随着生成的TypeScript声明的增加，当我进行第三个(大得多的)项目时，其好处真的超过了最初的集成工作。尤其是我现在已经将所有的Gradle build脚本代码打包到它自己的Gradle插件中。</p><p id="7793" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在能够应用DRY原则，用Kotlin写一次我的数据类真的很好。我只需在Gradle构建脚本中应用<a class="ae ln" href="https://github.com/dhakehurst/net.akehurst.kotlin.kt2ts" rel="noopener ugc nofollow" target="_blank">kt2ts Gradle插件</a>，很快我的Kotlin代码就与我的TypeScript代码集成在一起了。</p><h2 id="ab67" class="nl lp iq bd lq nr ns dn lu nt nu dp ly la nv nw ma le nx ny mc li nz oa me ob bi translated">未解决的问题</h2><p id="0475" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">目前有两个集成问题我还没有找到解决方案，欢迎大家提出建议！</p><p id="28e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Kotlin stdlib方法:</strong> Kotlin在生成JavaScript时会篡改方法名(因为JavaScript不支持方法重载)。这意味着，默认情况下，方法(带参数)在JavaScript中有一个混乱的名称，除非用<code class="fe or os ot nh b">@JSName</code>进行注释。不幸的是，Kotlin stdlib类上的许多方法没有被注释以生成可用的JavaScript名称。因此，我使用JVM反射生成TypeScript声明的技术不起作用。因此，从TypeScript代码中调用这些方法(例如Map.put)不会像运行时一样工作。</p><p id="7ad4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我目前的解决方案是，在我自己的类中总是为我需要从TypeScript代码中调用的任何东西提供(JSName)注释函数。这并不理想。</p><p id="bb70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">模块名映射:</strong>通过读取jsJar中包含的‘package . JSON’文件(如果有的话),有可能找出Kotlin生成的JavaScript模块的JavaScript模块名。并不总是有这样的文件。我目前无法找出一种确定性的方法来发现生成的JavaScript模块名。因此，不幸的是，需要提供手动映射。</p></div></div>    
</body>
</html>