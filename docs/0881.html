<html>
<head>
<title>An abbreviated history of JavaScript package managers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript包管理器简史</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e?source=collection_archive---------1-----------------------#2019-12-28">https://javascript.plainenglish.io/an-abbreviated-history-of-javascript-package-managers-f9797be7cf0e?source=collection_archive---------1-----------------------#2019-12-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="ff2b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="ec10" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这篇文章解释了为什么<a class="ae lg" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>、<a class="ae lg" href="https://yarnpkg.com/lang/en/" rel="noopener ugc nofollow" target="_blank">纱</a>和<a class="ae lg" href="https://pnpm.js.org/" rel="noopener ugc nofollow" target="_blank"> pnpm </a>被创造出来，以及它们已经解决的其他主要问题。</p><p id="7ae1" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果有必要的话，你应该阅读一下<a class="ae lg" href="https://gist.github.com/MattGoldwater/f03264a972a04c35367c854853520c3a" rel="noopener ugc nofollow" target="_blank">我为这篇文章</a>准备的词汇表。它定义了术语包、模块、库、依赖、子依赖、裸说明符、依赖图、包注册表和包管理器。</p><p id="1482" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">包管理器有用的基本原因是它们自动化了从安装子依赖到配置依赖树的大量工作。如果你需要更彻底地理解这些好处，我推荐阅读关于<a class="ae lg" href="https://github.com/MattGoldwater/no-package-manager-backend-test" rel="noopener ugc nofollow" target="_blank">我尝试在没有后端包管理器的情况下开始一个项目</a>。我还<a class="ae lg" href="https://github.com/MattGoldwater/no-package-manager-frontend-test" rel="noopener ugc nofollow" target="_blank">写了一篇解释为什么npm，yarn或者pnpm常用在前端</a>。</p><p id="05e1" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在深入包管理器之前，理解node如何找到您试图导入的包也是值得的。为此，我推荐阅读<a class="ae lg" href="https://gist.github.com/MattGoldwater/78f89ea93b9f1dfc19d3440e172cfa49" rel="noopener ugc nofollow" target="_blank">我对node的模块解析系统</a>的解释。</p><h1 id="e582" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Npm</h1><p id="6cf3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Npm于2010年1月12日发布，是node的第一个包注册表和包管理器。</p><p id="5bca" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><a class="ae lg" href="https://nodejs.org/en/blog/npm/npm-1-0-released/" rel="noopener ugc nofollow" target="_blank">2011年5月1日，npm版本1发布</a>，使得<a class="ae lg" href="https://nodejs.org/fa/blog/npm/npm-1-0-global-vs-local-installation/" rel="noopener ugc nofollow" target="_blank">本地包安装工作一致</a>。这一变化是一个巨大的进步，因为让事情与全球软件包一起工作是一件痛苦的事情。如果你全局安装一个包，你会注意到你不能仅仅通过使用一个简单的说明符来导入一个包。</p><p id="5d22" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">您<a class="ae lg" href="https://github.com/mixonic/docs.npmjs.com/blob/master/content/getting-started/fixing-npm-permissions.md#option-2-change-npms-default-directory-to-another-directory" rel="noopener ugc nofollow" target="_blank">可以配置npm将全局包安装到不同的文件夹</a>中，node的模块解析系统将在该文件夹中找到您的包，但这样您的应用程序将可以访问您的所有包，您可能会意外地使用您忘记放在package.json中的全局包。这将导致您的应用程序在其他人试图使用您的应用程序时崩溃。如果我在2010年不得不使用npm，我可以想象自己会犯这个错误，因为全局安装不会自动将你安装的包添加到你的package.json中。</p><p id="016a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">此外，默认情况下，npm仅存储全局软件包的一个副本。例如，如果您运行npm install <a class="ae lg" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> express </a>，然后运行npm install express@4.16.4，express的4.16.4版本将覆盖express的最新版本。这将<a class="ae lg" href="https://stackoverflow.com/questions/12138917/how-to-install-multiple-versions-of-the-same-node-js-module" rel="noopener ugc nofollow" target="_blank">使得在不同的项目中使用不同版本的全局包变得困难。</a></p><p id="ad4d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在版本1 中，npm实现了一个嵌套的依赖结构。这意味着您将在您的根node_modules文件夹中找到您本地安装的包，并且您的所有子依赖项将存储在您的依赖项的node_modules文件夹中。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/1abc6ded5be905fa59909bd7ae68cf42.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*KkW0loUIwTy5b6tX.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">The two versions of B are installed in different directories avoiding dependency hell. <a class="ae lg" href="https://npm.github.io/how-npm-works-docs/npm2/how-npm2-works.html" rel="noopener ugc nofollow" target="_blank">https://npm.github.io/how-npm-works-docs/npm2/how-npm2-works.html</a></figcaption></figure><p id="4b17" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">比如，假设你的app在你的package.json中有包A和包C，包A有依赖包1.0版，包C有依赖包2.0版。包A和C将位于您的根节点模块中。包1.0版将位于包A的node_modules文件夹中，包2.0版将位于包c的node_modules文件夹中。</p><p id="1076" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这种方法解决了“依赖地狱”的问题如果你试图在同一个文件夹中安装一个包的两个版本，就会出现依赖地狱，这会破坏你的应用程序。由于依赖项存储在npm中其依赖项的node_modules文件夹中，所以当您安装软件包时，永远不会发生依赖项地狱。</p><p id="e444" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然而，这种嵌套的依赖关系结构导致了长的文件路径，因为一个依赖关系可以有一个子依赖关系，而子依赖关系又有自己的依赖关系，等等。这导致应用程序在使用Windows时中断。Windows默认对文件路径的大小有260个字符的限制，在Windows 10 之前这个限制不能改变。</p><p id="2678" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Npm版本3“扁平化”了依赖关系树以解决此问题。这意味着默认情况下，所有依赖项和子依赖项都将放在根node_modules文件夹中。如果包的一个版本已经在根node_modules文件夹中，为了避免依赖关系崩溃，它将被放在使用它的依赖关系的node_modules文件夹中，就像在npm v2中一样。因此，依赖树并不是完全平坦的，但它足够平坦，Windows用户的文件路径问题大大减少了。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mc"><img src="../Images/5cd15e71e5f2cc657e1c1fd026d62f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEgwty6roKSgdZioUMVa3g.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk"><a class="ae lg" href="https://npm.github.io/how-npm-works-docs/npm3/how-npm3-works.html" rel="noopener ugc nofollow" target="_blank">https://npm.github.io/how-npm-works-docs/npm3/how-npm3-works.html</a></figcaption></figure><p id="0446" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">再一次想象你的应用在你的package.json中有包A和包C，包A有依赖包1.0版，包C有依赖包2.0版。安装程序包A时，程序包B版本1.0会添加到您的根节点模块文件夹中。安装软件包C时，不能将软件包2.0版添加到根node_modules文件夹中，因为软件包1.0版已经存在。</p><p id="3f72" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">展平依赖关系树也有助于节省磁盘空间和加快安装速度。如果您有上面的应用程序并试图安装软件包D版本1.0，它有软件包B版本1.0的子依赖项，那么您不需要像在npm版本2中一样再次安装软件包B版本1.0。</p><p id="994b" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">随着模块捆绑器的出现，如<a class="ae lg" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> browserify </a>和<a class="ae lg" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>，在前端使用npm也变得更加容易。当时开发人员可能已经在客户端使用了<a class="ae lg" href="https://bower.io/" rel="noopener ugc nofollow" target="_blank"> Bower </a>包管理器。然而，<a class="ae lg" href="https://snyk.io/blog/bower-is-dead/" rel="noopener ugc nofollow" target="_blank"> Bower强制用户每个应用</a>只能安装一个版本的包，这意味着开发者必须手动解决依赖地狱。</p><p id="8e89" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">此外，当时浏览器不支持<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" rel="noopener ugc nofollow" target="_blank"> ES模块</a>，也就是JavaScript模块，你仍然不能在浏览器中使用裸说明符。这意味着Bower用户必须<a class="ae lg" href="https://bower.io/#use-packages" rel="noopener ugc nofollow" target="_blank">键入包路径</a>并担心全球范围的污染。<a class="ae lg" href="https://github.com/MattGoldwater/no-package-manager-frontend-test" rel="noopener ugc nofollow" target="_blank">我在这个回购</a>中提供了这个问题的一个例子。</p><p id="492d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">少数用户更喜欢Bower而不是npm，因为他们更喜欢手动解决依赖性问题，以获得完全扁平的node_modules结构。但是，<a class="ae lg" href="https://bower.io/blog/2016/using-bower-with-yarn/" rel="noopener ugc nofollow" target="_blank">一旦2016年10月11日发布，甚至Bower的维护者也推荐使用Yarn </a>。他们似乎<a class="ae lg" href="https://bower.io/blog/2017/how-to-migrate-away-from-bower/" rel="noopener ugc nofollow" target="_blank">比npm </a>更喜欢yarn，因为它<a class="ae lg" href="https://yarnpkg.com/lang/en/docs/cli/install/#toc-yarn-install-flat" rel="noopener ugc nofollow" target="_blank">提供了一个选项来完全扁平化你的node_modules </a>。</p><h1 id="3d5b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">故事</h1><p id="8de2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">由于有脸书和谷歌的支持，Yarn很快获得了关注，并且用Yarn安装软件包比npm要快得多。Yarn的安装速度比npm更快的一个原因是<a class="ae lg" href="https://www.alexkras.com/understanding-differences-between-npm-yarn-and-pnpm/#twitter-widget-0" rel="noopener ugc nofollow" target="_blank">它使用更快的算法从缓存中获取数据</a>。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi md"><img src="../Images/6c6d8ef63f936d99ef9228c97690ba99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29Ukg0NNLM-AY31STr5UKA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Benchmarks comparing npm and yarn shortly after yarn was released <a class="ae lg" href="https://www.berriart.com/blog/2016/10/npm-yarn-benchmark/" rel="noopener ugc nofollow" target="_blank">https://www.berriart.com/blog/2016/10/npm-yarn-benchmark/</a></figcaption></figure><p id="8025" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Yarn最初还提供了一些优于npm的其他好处。</p><p id="9f51" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Yarn也使用了它的缓存，所以你可以离线使用任何以前下载的包。这个特性对脸书和其他公司来说很重要。那是因为脸书想<a class="ae lg" href="https://engineering.fb.com/web/yarn-a-new-package-manager-for-javascript/" rel="noopener ugc nofollow" target="_blank">切断他们的持续集成环境与互联网的联系</a>所以<a class="ae lg" href="https://smallbiztrends.com/2017/03/can-an-offline-computer-be-hacked.html" rel="noopener ugc nofollow" target="_blank">他们更难破解</a>。</p><p id="f749" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">使用包的离线副本还可以加速持续集成构建时间和常规包安装，因为您不需要发出网络请求来获取包。如果您没有发出网络请求，您不需要担心包的网络请求失败，这使得构建更加可靠。例如，当流行的npm包<a class="ae lg" href="https://www.npmjs.com/package/left-pad" rel="noopener ugc nofollow" target="_blank"/><a class="ae lg" href="https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/" rel="noopener ugc nofollow" target="_blank">从npm注册表</a>中删除时，离线存储包可以让公司避免问题。</p><p id="082d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Yarn还通过从每个包的内容中生成一个<a class="ae lg" href="https://cheapsslsecurity.com/blog/decoded-examples-of-how-hashing-algorithms-work/" rel="noopener ugc nofollow" target="_blank">校验和(又名哈希)</a>来提高应用程序的安全性。简而言之，这是通过使用哈希函数完成的，这是一个纯函数。这意味着每次你输入相同的数据到一个函数中，你都会得到相同的输出。因此，即使你的包中有一个字符发生了变化，Yarn的哈希函数也会识别出出错的地方。这确保了<a class="ae lg" href="https://snyk.io/blog/yarn-is-micro-secure/" rel="noopener ugc nofollow" target="_blank">你不需要担心黑客在你安装软件包的时候改变npm注册表上的软件包内容或者修改软件包</a>。</p><p id="5a23" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Yarn的“锁定文件”也受到了很多关注。第一次安装软件包时，会创建一个名为yarn.lock的文件，它列出了每个已安装软件包的确切版本。每次安装和更新软件包时，Yarn都会更新这个文件。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi me"><img src="../Images/d113f9bfa4eee47d4c7bac6f6a692118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgNHW14bzi6tUbRiPJBzbA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">A yarn.lock file</figcaption></figure><p id="c96b" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">使用npm安装包时，package.json中的包默认情况下会预先固定一个插入符号，<a class="ae lg" href="https://michaelsoolee.com/npm-package-tilde-caret/" rel="noopener ugc nofollow" target="_blank">，表示安装一个包的最新次要版本</a>。这意味着开发人员A可以在下午1点克隆一个使用<a class="ae lg" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>的应用程序，一切正常，但React可能会在下午1:30更新，更新可能会意外包含一个错误。因此，当开发人员B在下午2点安装相同的应用程序时，安装了新版本的React，而该应用程序无法工作。</p><p id="9e9e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">默认情况下，Yarn <a class="ae lg" href="https://yarnpkg.com/lang/en/docs/cli/install/#toc-yarn-install" rel="noopener ugc nofollow" target="_blank">安装yarn.lock文件中列出的包版本，而不是安装基于package.json </a>的最新semver版本。这可以防止开发人员花费时间调试为什么一个应用程序在一台计算机上工作，但在另一台计算机上却坏了。</p><p id="1942" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Npm实际上已经有了自己的锁定文件版本，它命名为<a class="ae lg" href="https://npm.github.io/using-pkgs-docs/shrinkwrap/index.html" rel="noopener ugc nofollow" target="_blank">包膜文件</a>，这将修复这个问题。但是，许多开发人员并不知道包覆面提取文件，因为默认情况下它是不启用的。</p><p id="f1d3" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">2017年5月25日NPM第五版发布的时候<a class="ae lg" href="https://blog.npmjs.org/post/161081169345/v500" rel="noopener ugc nofollow" target="_blank"> npm很大程度上赶上了Yarn。这个版本优化了npm的缓存，将安装速度提高到和Yarn一样快。此外，npm默认启用其版本的锁定文件，并将其重命名为package-lock。你可以在这里</a>了解yarn.lock和package-lock.json <a class="ae lg" href="https://yarnpkg.com/blog/2017/05/31/determinism/" rel="noopener ugc nofollow" target="_blank">的细微差别。Npm也开始使用校验和</a><a class="ae lg" href="https://blog.pusher.com/what-you-need-know-npm-5/" rel="noopener ugc nofollow" target="_blank">让用户从他们的本地缓存离线安装包。</a></p><h1 id="de93" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Pnpm</h1><p id="df61" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Pnpm出现在2017年6月的照片中，当时它<a class="ae lg" href="https://medium.com/pnpm/pnpm-version-1-is-out-935a07af914" rel="noopener">发布了第一版</a>，它的创造者<a class="mf mg ep" href="https://medium.com/u/a29a602b5573?source=post_page-----f9797be7cf0e--------------------------------" rel="noopener" target="_blank">Zoltan·科昌</a> <a class="ae lg" href="https://medium.com/pnpm" rel="noopener">在博客中对此进行了描述</a>。在他的帖子“<a class="ae lg" href="https://medium.com/pnpm/why-should-we-use-pnpm-75ca4bfe7d93" rel="noopener">我们为什么要使用pnpm </a>”中，Kochan解释了pnpm如何让用户节省磁盘空间，并避免npm和Yarn的node_modules结构的问题。</p><p id="9bda" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">当时，当npm和Yarn安装软件包时，他们会为每个项目安装每个软件包的至少一个副本，即使该软件包已经在其缓存中。Pnpm只将一个包安装到它的缓存中一次，这个缓存被称为它的存储。如果您安装了pnpm，您可以在。pnpm-在您的个人文件夹中存储目录。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/b0e2325fdffbc6057f913bebeeb07ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*jvL-6ItnpNEC5CwdhSQVxw.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">.pnpm-store is at the bottom of this picture</figcaption></figure><p id="d557" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">pnpm不是每次在项目中使用一个包时都安装它的副本，而是从您的pnpm存储中创建<a class="ae lg" href="https://en.wikipedia.org/wiki/Hard_link" rel="noopener ugc nofollow" target="_blank">到包中所有文件的硬链接</a>。硬链接本质上是一个拷贝，除非你修改了原始文件或硬链接文件，你会同时改变两个文件。虽然传统副本占用的空间与原始文件一样多，但硬链接只增加了少量空间来命名硬链接文件。</p><p id="c38a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这意味着如果你不止一次的使用一个版本的包，你将几乎不用额外的硬盘空间。例如，即使您在2个或更多pnpm项目中使用react，react也只由pnpm安装一次。</p><p id="129c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这些储蓄复利。流行的初学者工具包<a class="ae lg" href="https://www.npmjs.com/package/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>，默认使用Yarn，附带一个212兆字节的node_modules文件夹。因此，如果我的电脑上有10个以上的create-react-app项目，我会节省2.12千兆字节，再加上更多的空间用于任何不止一次使用的额外库。</p><p id="0d80" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">除了节省磁盘空间，您还可以节省大量安装额外软件包的时间。</p><p id="6ec9" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">因为文件是硬链接的，所以你需要小心修改node_modules的内容。如果您更改了它们的任何内容，您也将临时更改您计算机上所有其他pnpm项目的包。</p><p id="12c7" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">为了缓解这个问题，Pnpm保留了原始包的校验和，这允许它识别您何时更改了它的内容。它会在您下次尝试安装时自动将您的更改恢复到软件包中。</p><p id="3304" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Kochan也不喜欢npm中使用的平面node_modules结构，因为第3版和Yarn允许用户在应用程序代码的根node_modules文件夹中要求子依赖项。在他的博客文章中，<a class="ae lg" href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308" rel="noopener"> pnpm的严格有助于避免愚蠢的错误</a>，Kochan解释说如果用户忘记安装包，这可能会导致问题，但它已经作为子依赖项安装了。这意味着你的项目现在可以工作，但是如果这个子依赖项作为你的依赖项的一个依赖项被删除，它就会中断。如果您的依赖项开始使用该子依赖项的新版本，您的项目也可能会中断。</p><p id="0a34" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Kochan的逻辑是正确的，但npm和Yarn应用如此广泛，以至于许多开发人员已经创建了项目，这些项目导入了不在他们package.json中的包。例如，<a class="ae lg" href="https://github.com/pnpm/pnpm/issues/940#issuecomment-357041802" rel="noopener ugc nofollow" target="_blank"> create-react-native-app </a>就出现了这个问题。这意味着您可以键入NPM install create-react-native-app之类的内容，或者使用Yarn，它可以工作，但不能与pnpm一起工作。</p><p id="2709" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在create-react-native-app的情况下，它使用了依赖关系<a class="ae lg" href="https://www.npmjs.com/package/metro-bundler" rel="noopener ugc nofollow" target="_blank"> metro-bundler </a>，这忘记了向它的package.json添加许多依赖关系。Pnpm用户必须找到库开发人员忘记添加到他们的package.json的依赖关系，并使用<a class="ae lg" href="https://pnpm.js.org/en/2/hooks" rel="noopener ugc nofollow" target="_blank"> pnpm钩子</a>来安装这些依赖关系。为了<a class="ae lg" href="https://medium.com/pnpm/why-package-managers-need-hook-systems-b8125d8b3dc7" rel="noopener">将来为其他人修复问题</a>，他们可以提交一个pull请求来修复第三方库。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mi"><img src="../Images/6c91e3ff0e258ab8e8de8534f8cf508e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DyrK-P8cYzX4rvV5Zqb0g.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">The pnpm hook used so create-react-native-app could work with pnpm</figcaption></figure><p id="364a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Kochan认识到npm和Yarn比pnpm更受欢迎，并且大多数用户希望他们的软件包尽快工作。Kochan在pnpm版本4中做了一个妥协，它将您的子依赖项提升到node_modules文件夹中，您的依赖项可以在那里访问它们。</p><p id="935e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这意味着当你安装其他与npm和Yarn一起工作的包时不会有任何问题。如果你这样做，Pnpm确实提供了一个选项，<a class="ae lg" href="https://pnpm.js.org/en/faq#solution-3" rel="noopener ugc nofollow" target="_blank">可耻地提升</a>，使用类似npm和Yarn的扁平node_modules结构。</p><p id="d0db" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Kochan仍然很严格，不允许你的应用访问它自己的子依赖项。这意味着没有新的pnpm项目会有metro-bundler遇到的问题，但是您不需要修复现有的包来使pnpm一致地工作。</p><p id="1346" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><a class="ae lg" href="https://docs.npmjs.com/misc/config#global-style" rel="noopener ugc nofollow" target="_blank">您还可以使用npm安装带有— global-style标志的软件包，以创建node_modules结构，该结构仅允许您导入直接依赖项。</a></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mj"><img src="../Images/e1c958667ecf92759594094a4b110163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3JlcClu4NBVKMqi2a0Oqg.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">An example pnpm project. React is the only package I installed</figcaption></figure><p id="170f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">从上图可以看出，pnpm的node_modules结构很复杂，但是很管用。Pnpm使用<a class="ae lg" href="https://en.wikipedia.org/wiki/Symbolic_link" rel="noopener ugc nofollow" target="_blank">符号链接</a>(或者Windows上的<a class="ae lg" href="https://docs.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions#junctions" rel="noopener ugc nofollow" target="_blank">连接</a>来构建这个结构，节点跟随这个结构找到包的位置。中的node_modules文件夹。pnpm文件夹是存储子依赖关系的硬链接文件的位置。</p><p id="355e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">React是我的示例中安装的唯一直接依赖项，它直接列在node_modules文件夹中。该文件夹用符号链接到node_modules/文件夹。pnpm/registry . NPM js . org/react/16 . 12 . 0/node _ modules/react包含实际包的位置。Node跟在symlink后面，68个字符，文件路径足够短，pnpm很容易避免触及Windows的260个字符的限制。</p><p id="41c0" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">pnpm还有一个缺点，因为它使用符号链接<a class="ae lg" href="https://intoli.com/blog/node-package-manager-benchmarks/" rel="noopener ugc nofollow" target="_blank">，所以它不能与一些文件监视工具</a>一起工作，比如<a class="ae lg" href="https://facebook.github.io/watchman/" rel="noopener ugc nofollow" target="_blank"> Watchman </a>。这也是Yarn放弃使用symlinks 的<a class="ae lg" href="https://github.com/yarnpkg/yarn/issues/499#issuecomment-251583225" rel="noopener ugc nofollow" target="_blank">原始计划的原因之一。它也不能与不支持硬链接或符号链接的文件系统一起工作。只有当你想把你的项目存储在闪存盘或SD卡上时</a><a class="ae lg" href="https://www.howtogeek.com/177529/htg-explains-why-are-removable-drives-still-using-fat32-instead-of-ntfs/" rel="noopener ugc nofollow" target="_blank">才是个问题。</a></p><p id="9758" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果你有兴趣学习更多关于硬链接、符号链接以及pnpm如何使用它们的知识，我可以看看下面的资源。</p><ol class=""><li id="916d" class="mk ml in kk b kl lh kp li kt mm kx mn lb mo lf mp mq mr ms bi translated"><a class="ae lg" href="https://www.ostechnix.com/explaining-soft-link-and-hard-link-in-linux-with-examples/" rel="noopener ugc nofollow" target="_blank">https://www . ostechnix . com/explaining-soft-link-and-hard-link-in-Linux-with-examples/</a></li><li id="b068" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated"><a class="ae lg" href="https://stackoverflow.com/questions/9042542/what-is-the-difference-between-ntfs-junction-points-and-symbolic-links/48586946#48586946" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/9042542/NTFS-junction-points-and-symbolic-links/48586946 # 48586946</a></li><li id="750a" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated"><a class="ae lg" href="https://pnpm.js.org/en/faq" rel="noopener ugc nofollow" target="_blank">https://pnpm.js.org/en/faq</a></li></ol><h1 id="6a3e" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">工作区</h1><p id="02e3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">2017年8月<a class="ae lg" href="https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/" rel="noopener ugc nofollow" target="_blank"/>，Yarn团队发布了<a class="ae lg" href="https://yarnpkg.com/lang/en/docs/workspaces/" rel="noopener ugc nofollow" target="_blank"> Yarn workspaces </a>，这是一个更容易引导和管理monorepos的功能。</p><p id="4a3d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">monorepo是包含多个项目的存储库。Monorepo通常用于存储谷歌和脸书等大公司的私人代码，也用于React和<a class="ae lg" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>等开源项目。许多开发人员更喜欢monorepo结构，而不是为每个项目创建单独的存储库。这是因为<a class="ae lg" href="https://www.drmaciver.com/2016/10/why-you-should-use-a-single-repository-for-all-your-companys-projects/" rel="noopener ugc nofollow" target="_blank">他们觉得monorepo让更新版本和重构代码变得更加容易，而无需创建新的存储库</a>。</p><p id="1b83" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Yarn帮助开发人员管理monorepo，让他们在mono repo中的所有项目上同时安装软件包。<a class="ae lg" href="https://yarnpkg.com/lang/en/docs/cli/workspace/" rel="noopener ugc nofollow" target="_blank"> yarn workspace </a>命令也让开发者更容易从根目录管理单个项目。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi my"><img src="../Images/10c87d256acafc68fb8641ca1929fee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVdUl-plyGO1PxgA2hnG1Q.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">An example directory structure and root package.json of an app using yarn workspaces.</figcaption></figure><p id="7fa5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">工具<a class="ae lg" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> Lerna </a>还拥有Yarn workspaces的所有功能以及更多功能。Yarn团队推荐使用工作区，因为它安装包更快，也更稳定。他们补充说<a class="ae lg" href="https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/#lerna" rel="noopener ugc nofollow" target="_blank"> Lerna也不能做到这一点，因为它是包管理器的包装器，而不是包管理器本身</a>。Lerna可以与Yarn工作区一起使用，如果您希望使用它的功能来更容易地将包发布到npm注册表，它仍然是有用的。</p><p id="03a9" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Pnpm也实现了自己的<a class="ae lg" href="https://pnpm.js.org/en/workspaces" rel="noopener ugc nofollow" target="_blank">版本的workspaces </a>，npm也将在其<a class="ae lg" href="https://blog.npmjs.org/post/186983646370/npm-cli-roadmap-summer-2019" rel="noopener ugc nofollow" target="_blank">下一个主要版本</a>中添加workspaces特性。<a class="ae lg" href="https://github.com/npm/cli/wiki/Roadmap#workspaces" rel="noopener ugc nofollow" target="_blank"> Npm似乎也计划在未来的版本中添加Lerna的特性来发布软件包</a>。</p><p id="f9e8" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Yarn的下一个主要版本将允许<a class="ae lg" href="https://github.com/yarnpkg/yarn/issues/6953" rel="noopener ugc nofollow" target="_blank">嵌套工作空间</a>。顾名思义，这意味着您将能够在工作区中创建一个工作区。</p><h1 id="94b5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">精确导航处理器(Precision Navigation Processor)</h1><p id="b5b4" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">2018年9月，纱线团队推出了<a class="ae lg" href="https://github.com/yarnpkg/rfcs/pull/101" rel="noopener ugc nofollow" target="_blank">纱线即插即用</a>(纱线PnP)。纱线PnP解决了平面node_modules结构和重复包装安装的相同问题，pnpm以不同的方式解决了这些问题。他们选择使用不同的方法来使包安装更快，并最终消除在连续集成构建上安装的需要。</p><p id="8cfd" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">纱线PnP文档说明<a class="ae lg" href="https://yarnpkg.com/lang/en/docs/pnp/" rel="noopener ugc nofollow" target="_blank">硬链接消除了包重复，但是使用它们需要Node花时间对您的操作系统</a>进行一系列调用。他们在纱线PnP白皮书的第2页上对使用符号链接和硬链接的<a class="ae lg" href="https://github.com/yarnpkg/rfcs/files/2378943/Plugnplay.pdf" rel="noopener ugc nofollow" target="_blank">缺陷做了进一步的详细说明。</a></p><p id="9abe" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">使用纱线PnP，当您的包被安装时，纱线会创建一个名为. pnp.js的文件，而不是node_modules文件夹。. pnp.js文件列出了您的包、它们的依赖关系以及它们在硬盘上的相对路径。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi mz"><img src="../Images/862da3a606e688fc9f91f168f9f3a589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkSy51nymK8W7Pu-Gft29Q.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Information about react in my .pnp.js file</figcaption></figure><p id="46cf" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">纱线PnP修改<a class="ae lg" href="https://nodejs.org/api/modules.html#modules_all_together" rel="noopener ugc nofollow" target="_blank"> Node的默认模块解析</a>本质上是说，不是在文件的父文件夹中查找node_modules目录，而是查看. pnp.js文件。如果它在那里找到该版本的包，它将使用packageLocation字段将您带到磁盘上的适当位置。</p><p id="beba" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">使用纱线PnP时，您可能还会注意到一个名为。pnp，<a class="ae lg" href="https://stackoverflow.com/questions/53135221/what-does-yarn-pnp" rel="noopener ugc nofollow" target="_blank">将更名为。纱线版本2发布时的纱线</a>。这存储了带有<a class="ae lg" href="https://docs.npmjs.com/misc/scripts" rel="noopener ugc nofollow" target="_blank">安装后脚本</a>的包，脚本在包安装后立即运行。这是因为带有安装后脚本的包的内容，如<a class="ae lg" href="https://github.com/sass/node-sass/blob/master/package.json" rel="noopener ugc nofollow" target="_blank"> node-sass </a>，可能会因您的节点版本而有所不同。这意味着必须为每个项目分别安装软件包，因为每个项目可能使用不同的节点版本。</p><p id="04bc" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">由于纱负责解析依赖关系，而不是纱PnP中的节点，纱可以识别您是否正在导入一个被列为开发依赖关系而不是包中依赖关系的依赖关系。</p><p id="f280" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这解决了平面node_modules结构的另一个问题，pnpm无法直接解决这个问题，因为它依赖于node的默认模块解析系统。如果不使用Yarn PnP，你将不得不通过一个外部包来解决这个问题，比如Zoltan·科昌的<a class="ae lg" href="https://www.npmjs.com/package/package-preview" rel="noopener ugc nofollow" target="_blank"> package-preview </a>，当你在运行测试的同时导入devDependencies时<a class="ae lg" href="https://medium.com/pnpm/never-ever-forget-to-install-a-dependency-1c39dd3bbb37" rel="noopener"> catch。</a></p><p id="c444" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">虽然Yarn默认不启用PnP，但是您可以通过添加几行代码来<a class="ae lg" href="https://yarnpkg.com/lang/en/docs/pnp/getting-started/" rel="noopener ugc nofollow" target="_blank">设置它。但是，Yarn PnP目前没有做出pnpm版本4所做的改变，即允许依赖项访问任何子依赖项。这意味着，如果你正在使用一个忘记添加依赖项的包，你的应用程序在使用Yarn PnP时会中断，而它现在可以与其他包管理器一起工作。</a></p><p id="d650" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">像许多新技术一样，纱线PnP变得稳定也需要时间。脸书最近禁用了它，因为它与他们的许多软件包不兼容。</p><p id="4b0e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><a class="ae lg" href="https://dev.to/arcanis/plugnplay-and-tink-4684" rel="noopener ugc nofollow" target="_blank"> Yarn PnP是一种规范，而不是Yarn </a>独有的特性，因此它将来可以被其他包管理器采用。</p><h1 id="1840" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">未来</h1><p id="78ec" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">纱线维护者已经<a class="ae lg" href="https://github.com/yarnpkg/yarn/issues/6953" rel="noopener ugc nofollow" target="_blank">发布了他们的版本2 </a>的计划。这些包括优化Yarn，这样你在克隆一个库之后就不再需要运行Yarn install，并且使Yarn更容易与JavaScript之外的其他语言一起使用。纱线PnP也将默认启用。</p><p id="4ccb" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Npm已经宣布计划在版本8中做出重大改变，他们将其命名为tink。Tink的工作方式是覆盖<a class="ae lg" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">文件系统(fs)节点核心模块</a>，在运行时将您的包加载到所有项目共享的缓存中。</p><p id="c466" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这给用户带来了一些好处。你不必再输入npm install，即使你第一次在一个新项目中使用一个包。另外，<a class="ae lg" href="https://npm.community/t/tink-faq-a-package-unwinder-for-javascript/3191" rel="noopener ugc nofollow" target="_blank">在某些情况下，npm将能够更智能地只下载你需要的包的部分</a>。Npm的文件系统模块替换<a class="ae lg" href="https://npm.community/t/tink-state-of-the-unwinder-2018-10-25/2973" rel="noopener ugc nofollow" target="_blank">也将能够识别TypeScript和JSX文件，无需任何额外的配置</a>。</p><p id="143e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">虽然软件包是在运行时安装的，但您可以运行npm prepare命令，因此它们都是在您的应用程序投入生产之前加载的。</p><p id="02dd" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">由于npm还没有发布第7版，我预计tink正式发布还需要一段时间。如果你等不及了，<a class="ae lg" href="https://www.npmjs.com/package/tink" rel="noopener ugc nofollow" target="_blank">你可以尝试tink </a>的开发版本，但是npm警告不要在生产中使用它。</p><p id="8aa5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">纱线PnP和npm tink具有不同的权衡。<a class="ae lg" href="https://dev.to/arcanis/plugnplay-and-tink-4684" rel="noopener ugc nofollow" target="_blank"> Yarn维护者mal Nison发现覆盖节点核心模块是有风险的</a>，因为这是一个足够大的变化，可能会有一些错误，可能会使你的应用程序不那么安全和可靠。<a class="ae lg" href="https://2019.jsconf.eu/kat-marchan/tink-a-next-generation-package-manager.html" rel="noopener ugc nofollow" target="_blank"> Npm已经承认这种风险，但是指出</a><a class="ae lg" href="https://electronjs.org/" rel="noopener ugc nofollow" target="_blank">electronic</a>已经成功使用了这种方法。</p><p id="3165" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">Npm也更喜欢他们的方法，因为<a class="ae lg" href="https://yarnpkg.com/en/docs/pnp/getting-started" rel="noopener ugc nofollow" target="_blank"> Yarn PnP需要额外的配置</a>来使用某些工具，如webpack、Jest和TypeScript。这些工具已经集成了Yarn PnP ( <a class="ae lg" href="https://github.com/arcanis/jest-pnp-resolver" rel="noopener ugc nofollow" target="_blank"> jest </a>，<a class="ae lg" href="https://github.com/arcanis/pnp-webpack-plugin#ts-loader-integration" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>)和<a class="ae lg" href="https://webpack.js.org/migrate/5/#clean-up-configuration" rel="noopener ugc nofollow" target="_blank"> webpack 5将默认支持Yarn PnP </a>，所以这可能不会是一个长期的问题。</p><p id="cc57" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我希望你喜欢这篇文章！请在评论中告诉我你的想法。</p></div></div>    
</body>
</html>