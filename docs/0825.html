<html>
<head>
<title>Developer Story: Configuration Single Source of Truth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员故事:配置真相的单一来源</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/developer-story-configuration-single-source-of-truth-ea83a1bcb560?source=collection_archive---------4-----------------------#2019-12-17">https://javascript.plainenglish.io/developer-story-configuration-single-source-of-truth-ea83a1bcb560?source=collection_archive---------4-----------------------#2019-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ab5bce0aa628e39055f68d8bb7660f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TtAb0ZKQvLbcvom6.jpg"/></div></div></figure><p id="d776" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原则上，我创建的所有服务器应用程序总是严格管理和验证所有传入的信息。显然，确保从客户端接收的任何数据都经过清理是绝对必要的，但在信任配置数据之前，我总是肯定要验证另一组数据。</p><p id="c6be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之前我已经<a class="ae kt" href="https://medium.com/@keithvictordawson/developer-story-process-management-is-key-5115d2886ccc" rel="noopener">讨论过</a>我个人对于NodeJS应用的过程管理策略。在那个开发者故事条目中，我用来管理应用程序进程的方法也提供了一种向应用程序交付被称为环境变量的配置数据的方式。在这个开发人员故事条目中，我将讨论我的个人策略，即验证所有的配置数据，并为应用程序逻辑的所有角落提供所有配置数据的单一真实来源。</p><p id="b053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提醒一下，通过流程管理系统交付给我的应用程序的配置数据如下所示:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="7778" class="ld le in kz b gy lf lg l lh li"><strong class="kz io"><em class="lj">ecosystem.config.js</em></strong></span><span id="3509" class="ld le in kz b gy lk lg l lh li">...<br/>DB_HOSTS: 'localhost,localhost,localhost',<br/>DB_NAME: 'db_test',<br/>DB_PASSWORD: 'db_password',<br/>DB_PORTS: '27017,27018,27019',<br/>DB_USER: 'db_user',<br/>RS_NAME: 'db_rs',<br/>SERVER_PORT: '1234',<br/>...</span></pre><p id="e0ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是流程管理系统的配置文件，我用它来维护所有服务器应用程序的平稳运行，这些环境变量在初始化时被注入到应用程序中，并可通过所有NodeJS应用程序中可用的<code class="fe ll lm ln kz b">process.env</code>全局变量来检索。正如我前面说过的，我对不简单地相信我在<code class="fe ll lm ln kz b">process.env</code>全局变量上找到的东西非常严格。相反，我验证这个全局变量中包含的所有数据，并构建我自己的更易于编程使用的全局配置对象。</p><p id="3f24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于上面示例中指定的配置数据，验证该数据并使其全局可用的逻辑如下所示:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="6cb6" class="ld le in kz b gy lf lg l lh li"><strong class="kz io"><em class="lj">env.js</em></strong></span><span id="d461" class="ld le in kz b gy lk lg l lh li">const err = require('./util/error')<br/>const logger = require('./log').app<br/>const val = require('./util/validation')</span><span id="c4c8" class="ld le in kz b gy lk lg l lh li">let env = {}</span><span id="67b7" class="ld le in kz b gy lk lg l lh li">module.exports.initialize = async () =&gt; {<br/>  logger.info(`Initializing environment variables`)</span><span id="074e" class="ld le in kz b gy lk lg l lh li">  val.isNonEmptyString(process.env.DB_HOSTS, 'DB_HOSTS')<br/>  const hosts = process.env.DB_HOSTS.split(',')<br/>  val.isNonEmptyArray(hosts, 'DB_HOSTS', val.isNonEmptyString, 'host')<br/>  env.DB_HOSTS = hosts</span><span id="1214" class="ld le in kz b gy lk lg l lh li">  if (hosts.length &gt; 1) {<br/>    val.isNonEmptyString(process.env.DB_PORTS, 'DB_PORTS')<br/>    const ports = process.env.DB_PORTS.split(',')<br/>    val.isNonEmptyArray(ports, 'DB_PORTS', val.isPortString, 'port')<br/>    if (hosts.length !== ports.length) throw err.createError('ENV_HOSTS_PORTS_MISMATCH', FUNCTION_NAME)<br/>    env.DB_PORTS = ports</span><span id="765a" class="ld le in kz b gy lk lg l lh li">    val.isNonEmptyString(process.env.RS_NAME, 'RS_NAME')<br/>    env.RS_NAME = process.env.RS_NAME<br/>  }</span><span id="1bd8" class="ld le in kz b gy lk lg l lh li">  val.isNonEmptyString(process.env.DB_NAME, 'DB_NAME')<br/>  env.DB_NAME = process.env.DB_NAME</span><span id="ab97" class="ld le in kz b gy lk lg l lh li">  val.isNonEmptyString(process.env.DB_PASSWORD, 'DB_PASSWORD')<br/>  env.DB_PASSWORD = process.env.DB_PASSWORD</span><span id="07b5" class="ld le in kz b gy lk lg l lh li">  val.isNonEmptyString(process.env.DB_USER, 'DB_USER')<br/>  env.DB_USER = process.env.DB_USER</span><span id="777f" class="ld le in kz b gy lk lg l lh li">  val.isPortString(process.env.SERVER_PORT, 'SERVER_PORT')<br/>  env.SERVER_PORT = process.env.SERVER_PORT</span><span id="9d1e" class="ld le in kz b gy lk lg l lh li">  logger.info(`Successfully initialized environment variables`)<br/>}</span><span id="b030" class="ld le in kz b gy lk lg l lh li">module.exports.retrieve = () =&gt; {<br/>  const FUNCTION_NAME = 'env.retrieve'<br/>  try {<br/>    if (Object.keys(env).length === 0) throw err.createError('ENV_NOT_INITIALIZED', FUNCTION_NAME)</span><span id="9cdd" class="ld le in kz b gy lk lg l lh li">    return env<br/>  } catch(e) {<br/>    const error = err.createError(e, FUNCTION_NAME)<br/>    logger.error(error.display)<br/>    throw error<br/>  }<br/>}</span></pre><p id="588f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里发生了很多事情，其中一些我之前已经讨论过，一些我第一次在代码示例中展示。您可能注意到的一件事是在几个不同的地方使用了一个<code class="fe ll lm ln kz b">logger</code>变量。我之前在<a class="ae kt" href="https://medium.com/@keithvictordawson/developer-story-always-bring-receipts-ed0ddad4fbcd" rel="noopener">讨论了</a>我在所有NodeJS应用程序中实现日志功能的个人策略，这是使用这种功能的另一个例子。另一件事是通过使用<code class="fe ll lm ln kz b">err</code>变量在整个代码示例中使用的错误处理。我在所有NodeJS应用程序中实现错误处理功能的个人策略将在以后的开发者故事条目中讨论。除了这两件事，这个代码示例中的大部分逻辑都是在<code class="fe ll lm ln kz b">initialize()</code>函数中实现的，该函数利用<code class="fe ll lm ln kz b">val</code>变量对应用程序初始化时提供的所有配置数据进行验证。</p><p id="4e82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会注意到，<code class="fe ll lm ln kz b">val</code>变量是通过从应用程序另一部分的实用程序验证模块导入代码，在脚本顶部初始化的。在验证模块中有许多轻量级的函数，用于检查整个应用程序中的数据。这里主要使用它来检查大多数配置数据是否为非空字符串，但是在验证模块中还有许多其他有用的验证函数，它们在整个应用程序中有许多用途。其中一些验证逻辑是在<a class="ae kt" href="https://www.npmjs.com/package/validator" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">validator</strong></a>NodeJS包的帮助下实现的，如果您的应用程序中需要任何类型的字符串验证，我强烈建议您研究一下这个包。</p><p id="35c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然这里的大部分逻辑非常简单，只是简单的字符串验证，但我验证的主要内容之一是数据库主机的数量与数据库端口的数量相匹配。由于我主要将MongoDB用于我的大多数NodeJS应用程序，并且早期开发之后的所有情况都需要使用副本集数据库配置来实现MongoDB实例，所以包含了这个逻辑以确保主机和端口的两个列表匹配。如果这个检查失败了，那么整个验证过程就失败了，因为如果应用程序不能正确地连接到数据库，那么一开始启动应用程序还有什么意义呢？一旦所有的验证完成，并且在脚本顶部初始化的<code class="fe ll lm ln kz b">env</code>变量的构造完成，全局对象就可以通过使用<code class="fe ll lm ln kz b">retrieve()</code>函数在应用程序的任何地方进行检索。从这个函数的逻辑中您可能会注意到，试图在初始化之前检索全局配置对象将会抛出一个错误。这确保了在全局配置对象没有成功初始化的情况下，应用程序不会完成初始化。</p><p id="e1dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经意识到，这个全局配置对象对于整个应用程序的设置具有巨大的价值。为了确保在应用程序中的任何地方检索它之前已经创建了它，以下代码出现在所有my NodeJS应用程序的启动脚本中:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0157" class="ld le in kz b gy lf lg l lh li"><strong class="kz io"><em class="lj">server.js</em></strong></span><span id="aca6" class="ld le in kz b gy lk lg l lh li">async function run() {<br/>  logger.info(`Initializing application`)</span><span id="95ec" class="ld le in kz b gy lk lg l lh li">  const env = require('./env')<br/>  await env.initialize()<br/>  ...<br/>  })<br/>}</span></pre><p id="f90f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">全局配置对象在应用程序初始化过程的绝对开始时进行初始化，然后才会发生任何其他事情，包括连接到数据库或初始化任何其他应用程序模块。从这一点开始，当下面一行代码放在整个应用程序的任何模块的任何文件的顶部时，所有的配置数据都可以通过<code class="fe ll lm ln kz b">env</code>变量获得:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="caae" class="ld le in kz b gy lf lg l lh li">const env = require(‘../env’).retrieve()</span></pre><p id="37fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了数据库连接过程所需的配置数据之外，应该在硬编码字符串通常出现的任何地方使用这些配置数据。将应用程序的所有硬编码字符串收集到一个地方更好的原因是，可以根据应用程序运行的环境上下文适当地指定它们。这些硬编码的字符串可以用于任何事情，从身份验证过程中使用的令牌化逻辑到应用程序与其他服务器系统的接口，这些服务器系统需要API URL和ID来与这些系统进行身份验证。</p><p id="0010" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为开发人员，您可以选择系统在多大程度上使用这种策略来将配置数据传播给应用程序的其他部分。但是，最好谨慎行事，最大限度地使用它，如果没有其他原因，利用这种策略将允许您验证所有指定的配置数据，以便您可以确保它在用于初始化您的应用程序时是正确的。</p><p id="ff8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至此，您对我如何在所有NodeJS应用程序中验证和传播配置数据已经有了很好的了解。虽然这个策略不是我在开始实现NodeJS应用程序时立即开发的，但它无疑已经成为我现在在职业生涯和个人开发中创建的所有NodeJS应用程序的基础特性。</p><p id="0a8b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我真诚地希望我在这里的分享能够为您提供一个好主意，告诉您如何在所有NodeJS应用程序中实现这样一个系统。当我继续在我的个人项目上取得进一步进展时，请继续关注更多的开发者故事条目。</p></div></div>    
</body>
</html>