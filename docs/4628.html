<html>
<head>
<title>Understanding the Difference Between Function &amp; Class Components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解React中函数和类组件的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-the-difference-between-function-class-components-in-react-35279a119d29?source=collection_archive---------6-----------------------#2020-12-26">https://javascript.plainenglish.io/understanding-the-difference-between-function-class-components-in-react-35279a119d29?source=collection_archive---------6-----------------------#2020-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ef75" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在React应用中选择合适的组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dced10c92e8830d8df94d8e943f389bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VVe7wR6LJrxSGIRD.jpeg"/></div></div></figure><p id="0b84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<strong class="kt ir"> React </strong>中的组件，更好地理解它们如何影响你的<strong class="kt ir">应用的性能</strong>一直是一个令人困惑的话题，开发者最终会拥有一个庞大的代码库，随着时间的推移，越来越难以管理。所以，你将听到的主要答案是<strong class="kt ir">类组件</strong>提供了对更多特性的访问，如<strong class="kt ir"> <em class="ln">(状态)</em> </strong>，但是带有不再有效的<strong class="kt ir">挂钩</strong>。</p><p id="c47f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你一定听说过其中一个有更好的性能，但是性能取决于代码在做什么，而不是选择一个类或函数。性能几乎相同，使用各种优化技术可以产生差异。</p><h1 id="49c9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">功能组件</h1><p id="c636" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">考虑一个组件。让我们以一个简单的<strong class="kt ir">组件</strong>为例，它模拟一个带有<strong class="kt ir"> <em class="ln"> setTimeout </em> </strong>的网络请求，并显示一个确认警告。如果<strong class="kt ir"> <em class="ln">道具.用户</em> </strong>是‘莫希特’，3秒后会简单显示<strong class="kt ir"><em class="ln">‘跟随莫希特’</em></strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/df9431c0f407f97b79652eb5d2dff0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXEbmkxJiOE6yaDMwznXQA.png"/></div></div></figure><p id="145e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，你可以使用箭头或者函数声明，两者的工作方式是一样的。</p><p id="ffd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在课堂上实现上述示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/8c69e2e2cbbd3db0824d6315a93d974f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_hTP0Dr8ZLg3vSztGAxxQ.png"/></div></div></figure><p id="6b43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">人们经常错误地以同样的方式看待这两者，但是它们的含义是不同的。为了观察区别，你可以打开我创建的代码<a class="ae mn" href="https://codesandbox.io/s/serene-bhabha-rig6d?file=/src/ProfilePageFunction.js" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> <em class="ln">沙箱</em> </strong> </a>来更好的理解。</p><p id="c108" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开上面给出的代码沙箱并运行代码，现在尝试这些步骤来测量差异。</p><ol class=""><li id="0943" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm mt mu mv mw bi translated">点击<strong class="kt ir"> <em class="ln">跟随</em> </strong>按钮。<strong class="kt ir">(函数或类你可以选择其中的任何一个)</strong></li><li id="1953" class="mo mp iq kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">在3秒钟之前更改选定的配置文件。</li><li id="fc0a" class="mo mp iq kt b ku mx kx my la mz le na li nb lm mt mu mv mw bi translated">现在阅读文本<strong class="kt ir">警报</strong>。</li></ol><p id="a8e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你会注意到，当我们点击跟随按钮<strong class="kt ir">(使用功能组件)</strong>然后切换到不同的配置文件时，它显示的是以前的用户<strong class="kt ir">的名字</strong>而不是我们3秒后选择的名字。但是当我们按下follow按钮<strong class="kt ir">(使用类组件)</strong>时，每次都会显示新选择的用户名。通过自己运行沙盒，你会得到更好的理解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/12b8ad4db51bb14aef1d0b6f7e60b00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-rS5XGJxAIwv6-1HSIjOg.png"/></div></div></figure><p id="0846" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本例中，如果您按下<strong class="kt ir">“Mohit’s”配置文件</strong>上的follow按钮，然后更改所选用户，在<strong class="kt ir">功能组件</strong> t的情况下，您仍会在警告对话框中看到Mohit。在类组件的情况下，您会在警告对话框中注意到<strong class="kt ir">切换的配置文件</strong>名称。</p><p id="5c8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，第一个行为完全是我们声称对我们来说正确的，因为我的组件不应该混淆我跟随了谁！。</p><h2 id="53f2" class="nd lp iq bd lq ne nf dn lu ng nh dp ly la ni nj ma le nk nl mc li nm nn me no bi translated">那么这种错误行为的原因是什么呢？T9】</h2><p id="d513" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了理解这一点，让我们仔细看看我们类中的<strong class="kt ir"> <em class="ln"> showMessage </em> </strong>方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1e33c2c131064a45bde278dfdf3ae768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*3oLUsduDsdH8VYxEppn4nw.png"/></div></figure><p id="dd6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类方法从<strong class="kt ir"><em class="ln">this . prop . user</em></strong>中读取，并且道具在<strong class="kt ir"> React </strong>中是不可变的，所以它们永远不会改变，但是<strong class="kt ir"> <em class="ln"> this </em> </strong>一直是可变的&amp;这就是<strong class="kt ir"> <em class="ln">的全部目的如果我们的组件在进程中重新渲染，<strong class="kt ir"> <em class="ln"> this.props </em> </strong>将改变&amp;<strong class="kt ir">show message</strong>方法从“<strong class="kt ir"><em class="ln">too new”</em></strong>props<strong class="kt ir">中读取用户。</strong></em></strong></p><p id="348e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这显示了<strong class="kt ir">用户界面</strong>本质中一个有趣的关系，如果我们说UI是当前应用程序状态的函数，那么<strong class="kt ir">事件处理程序</strong>是<strong class="kt ir"> <em class="ln">渲染结果的一部分。</em> </strong>但是调度超时，显示<strong class="kt ir"> <em class="ln"> this.props </em> </strong>中断关系。</p><p id="259a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设没有<strong class="kt ir">功能组件</strong>，那么这个问题的解决方案是什么？</p><p id="f3c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想以某种方式“修复”渲染和修正道具与读取它们的<strong class="kt ir"> <em class="ln"> showMesage </em> </strong>回调之间的连接。我们可以实现这种可能性的一种方法是在事件早期读取<strong class="kt ir"> <em class="ln"> this.props </em> </strong>，然后通过超时完成处理程序传递它们。尽管如此，这种方法会使代码在最后更容易出错，我们不能使用一个以上的属性，我们也不能访问状态，我们会再次遇到同样的问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/620b4b3de2146082aec1d65afc08daec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TwXO1xtL8SDCLFIySA5og.png"/></div></div></figure><p id="b8a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就算我们把<strong class="kt ir"> <em class="ln">预警</em> </strong>代码放在<strong class="kt ir"> <em class="ln"> handleClick </em> </strong>里面也回答不了更大的问题。目的是以这样一种方式构造我们的代码，允许将它分成更多的方法，并且能够读取与该调用相关的呈现所对应的属性和状态。</p><h2 id="7fa9" class="nd lp iq bd lq ne nf dn lu ng nh dp ly la ni nj ma le nk nl mc li nm nn me no bi translated">如果我们<strong class="ak"> <em class="np">绑定</em> </strong>构造函数中的方法会怎么样？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/d6cb65cf34ffa2a5399615cd180b9e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aipmAgqZ_ASL1znmmgUqDg.png"/></div></div></figure><p id="71c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住问题是在阅读<strong class="kt ir"> <em class="ln"> this.props </em> </strong>太晚，不符合我们正在使用的语法，所以不会解决这个问题。如果我们依靠<strong class="kt ir"> JavaScript </strong>闭包，位问题可以得到解决。然而，应该避免闭包，因为很难想象一个值会随着时间而变化。因此，如果我们使用闭包来替代特定渲染中的<strong class="kt ir"> <em class="ln">道具</em> </strong>或<strong class="kt ir"> <em class="ln">状态</em> </strong>，我们很容易就能依赖它们。</p><p id="f7a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数组件捕获渲染值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/bd732eacc06c63ec7aaee4fad47e2eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwwsQqjQPqd6ZBSu-EO5ow.png"/></div></div></figure><p id="d5e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果我们在<strong class="kt ir"> <em class="ln"> render中定义函数，那么拥有一个类又有什么意义呢？</em>T29】</strong></p><p id="5034" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当父组件用不同的道具渲染<strong class="kt ir"> <em class="ln"> ProfilePage </em> </strong>时，<strong class="kt ir"> React </strong>再次调用<strong class="kt ir"> <em class="ln"> ProfilePage </em> </strong>函数&amp;我们已经点击过的事件句柄，该事件句柄属于之前的渲染，有自己的<strong class="kt ir"> <em class="ln">用户</em> </strong>值，正在被<strong class="kt ir"> <em class="ln"> showMessage </em> </strong>读取。这就是为什么在上面的沙盒示例中，当我们在更改所选用户后点击follow <strong class="kt ir"> Mohit </strong>时，它仍然显示<strong class="kt ir">‘Followed Mohit’。</strong></p></div></div>    
</body>
</html>