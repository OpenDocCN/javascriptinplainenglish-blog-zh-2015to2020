<html>
<head>
<title>You definitely should be using Suspense in React — code splitting and preloading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你肯定应该在React中使用悬念——代码拆分和预加载</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-definitely-should-be-using-suspense-in-react-code-splitting-and-preloading-b9cbe393a95?source=collection_archive---------0-----------------------#2020-08-03">https://javascript.plainenglish.io/you-definitely-should-be-using-suspense-in-react-code-splitting-and-preloading-b9cbe393a95?source=collection_archive---------0-----------------------#2020-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db68df32f2c8f1e14df102a9f763a7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UoiBCsLDWfWHNXc6mCAbQ.png"/></div></div></figure><h1 id="c711" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">反应悬念—简短回顾</h1><p id="22de" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">React悬念是React新功能套件的一部分。它基本上让你<em class="lu">暂停</em>组件的渲染，直到满足某个条件。</p><p id="cd77" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">反应悬疑与恐怖发声<strong class="ky ir">并发模式</strong>齐头并进。在本文中，我们不打算谈论这一点，因为它仍处于起步阶段，还不稳定。</p><p id="7184" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然而，你已经可以开始使用React悬念做一件大事了:<strong class="ky ir">通过代码分割延迟加载组件</strong>🎉。</p><h1 id="fad3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">代码分割？</h1><p id="a497" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可能已经通过create-react-app、Gatsby、Next.js或使用模板引导了React应用程序。所有这些都包括一个捆绑器，如Webpack。</p><p id="a9e3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">Webpack基本上获取JavaScript文件(例如，React组件)并将它们捆绑在一起(即，它创建一个包含所有所需内容的大文件)。<strong class="ky ir">但是实际上一切都是从一开始就需要的吗？</strong></p><p id="55bf" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">您可能不需要从一开始就加载所有React组件的代码。假设您有多个路由(即多个页面)，因此并非所有路由同时可见，在应用程序的初始加载时，只有<strong class="ky ir">一个</strong>可见。</p><p id="1043" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这种情况下，您可以稍后获取其他组件的代码，不是吗？从而使初始加载更快🕐。</p><p id="2619" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这种技术通常适用于从一开始就不需要的其他组件，如条件呈现的部分、模态等。</p><p id="f30f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">您可以显著减少初始包的大小，从而显著缩短加载时间🚀。</p><h1 id="227f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">那么React悬念有什么帮助呢？</h1><p id="cf04" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在动态导入的帮助下，我们可以很容易地定义哪些组件需要延迟加载。</p><p id="be11" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们看一个例子:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="f3bb" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这里发生了什么事？</p><p id="e2ef" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们有一个组件，最初呈现一个按钮，上面写着“打开懒惰部分”。当我们按下那个按钮时，另一个组件也会被渲染(即<code class="fe mg mh mi mj b">LazyLoadedComponent</code>)，但是这个组件是延迟加载的！瞧啊。我们已经成功地使用了代码分割。</p><p id="1ef8" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">实际上，你可以在浏览器的开发工具中查看一下，在点击按钮时，可以在网络部分查看。服务器请求一个新的JavaScript块(它有我们的<code class="fe mg mh mi mj b">LazyLoadedComponent</code>的代码)。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/307c9ad3c1752120eb48617f15c8cfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I5YsZkAKRkrnWWNWHausnA.gif"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">A new chunk gets loaded lazily</figcaption></figure><p id="b4b2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是等等，悬念标签上的<code class="fe mg mh mi mj b">fallback</code>属性是怎么回事？</p><p id="f91c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">React将在加载惰性元素的同时呈现<code class="fe mg mh mi mj b">fallback</code>中指定的项目。让我们通过在Chrome Dev Tools中人为地使我们的连接变慢(<em class="lu">节流</em>)并将其设置为慢3G来检查一下。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/968c2319a565f6b7fd9e2ec92d8f5aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ep3obwHn57dGKd5lbrGLEQ.gif"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">React renders the fallback while the element is loading</figcaption></figure><h2 id="77bf" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">React .懒+悬疑= ❤️</h2><p id="7e05" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如你在上面的代码中看到的，我们使用了两个重要的React元素来完成这项工作:<code class="fe mg mh mi mj b">lazy</code>函数和悬念标签。</p><p id="557a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">lazy函数封装了一个动态导入，并且在加载lazy元素的JavaScript块时，它与<code class="fe mg mh mi mj b">Suspense</code>标签一起在幕后执行相同的魔术来呈现回退。</p><h2 id="7025" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">使用React路由器进行惰性渲染</h2><p id="82c2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">将上述技术应用于基于路线的导航是非常方便的。</p><p id="5910" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如果您使用React路由器，您可以实现如下代码拆分:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="570a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">实际React组件中的一切都是相同的。然而，我们不是以传统的方式导入组件，而是以一种<strong class="ky ir">懒惰的方式</strong>。</p><p id="46a3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，当最初加载应用程序时，只有<strong class="ky ir">当前路线</strong>组件的代码将被发送到客户端。随着不同的路由被访问，其余的路由代码将逐渐发送到客户端。整洁！</p><p id="e435" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">通过使用这种简单的方法，您可以节省数百千字节，因此<a class="ae nb" href="https://web.dev/first-contentful-paint/" rel="noopener ugc nofollow" target="_blank">第一次内容丰富的绘制</a>和<a class="ae nb" href="https://web.dev/interactive/" rel="noopener ugc nofollow" target="_blank">到交互</a>的时间将显著减少。</p><h2 id="2132" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">预加载</h2><p id="a335" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">初始加载时间显然很重要。除此之外，有时我们还希望预先为惰性组件/路由预加载代码。</p><p id="5202" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">考虑一个简单的导航栏:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/98d1cf3d8e9a448adcd1b59c4e3dfea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CauHi-9BvqFXuz2wl4IBhg.gif"/></div></div></figure><p id="05b9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">每当用户将鼠标悬停在其中一项上时，我们就可以开始预加载该页面。</p><p id="7b11" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是我们实现这一目标的方法:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5a4b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们在这里使用一个助手函数，<code class="fe mg mh mi mj b">getPreloadableLazyComponent</code>，它接受实际的动态导入函数并返回带有附加属性的React组件:<code class="fe mg mh mi mj b">preload</code>，这是一个你可以在任何你想要开始预加载过程的地方调用<strong class="ky ir">的函数。</strong></p><h1 id="e027" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">最后</h1><p id="17d0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可以从今天开始使用React ( <code class="fe mg mh mi mj b">lazy</code> + <code class="fe mg mh mi mj b">Suspense</code>)的代码拆分功能。从初始加载时间来看，它有很多好处，因为它可以节省<strong class="ky ir">秒</strong>，从而改善用户体验🚀。</p><p id="1014" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">干杯！</p><h2 id="0777" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="f25f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae nb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>