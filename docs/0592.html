<html>
<head>
<title>Using Sinon calledWith to assert that a function was called correctly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sinon calledWith断言函数被正确调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-sinon-calledwith-to-assert-that-a-function-was-called-correctly-458e3277176?source=collection_archive---------4-----------------------#2019-11-13">https://javascript.plainenglish.io/using-sinon-calledwith-to-assert-that-a-function-was-called-correctly-458e3277176?source=collection_archive---------4-----------------------#2019-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c346bc1b515751b01de36c2bac373666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MQxLfTMrZSSGAUG0AqC6A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">loosely linked picture to spies, or something</figcaption></figure><p id="4349" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个单元测试示例，用于确认使用正确的参数调用了特定的函数。</p><h1 id="c503" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">代码</h1><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="b39b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的代码中，我们有两个函数<code class="fe me mf mg mh b">calculateTotal</code>和<code class="fe me mf mg mh b">updateTotal</code>。为了测试它们对于给定的输入是否正确工作，我们将测试用正确的参数调用了<code class="fe me mf mg mh b">databaseUpdater</code>函数。</p><h1 id="0239" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用proxyquire和sinon间谍</h1><p id="533b" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">Proxyquire是一个包，它允许您将需要的模块插入到代码中。</p><p id="6572" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里有一个如何使用proxyquire的简单例子</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="92b7" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分解它</h1><pre class="ly lz ma mb gt mn mh mo mp aw mq bi"><span id="4385" class="mr lb iq mh b gy ms mt l mu mv">const databaseUpdaterSpy = sinon.spy();<br/>const stub = {<br/>  '../model/databaseUpdater': databaseUpdaterSpy,<br/>};</span></pre><p id="66d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里，我使用<code class="fe me mf mg mh b">chai</code>作为断言库，<code class="fe me mf mg mh b">sinon</code>创建间谍，<code class="fe me mf mg mh b">proxyquire</code>存根外部<code class="fe me mf mg mh b">databaseUpdater</code>模块。</p><p id="9d05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，当我的代码调用<code class="fe me mf mg mh b">databaseUpdater</code>时，它正在调用我的sinon spy。这意味着我可以断言我的spy函数是用正确的参数调用的，如下所示:</p><pre class="ly lz ma mb gt mn mh mo mp aw mq bi"><span id="4f0a" class="mr lb iq mh b gy ms mt l mu mv">databaseUpdaterSpy.getCall(0).calledWith()</span></pre><p id="ed27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe me mf mg mh b">getCall(0)</code>函数给出了我的间谍第一次被调用的时间(因为我的间谍可能被调用多次)。然后我可以访问调用它的参数(用<code class="fe me mf mg mh b">calledWith</code>函数)。</p><p id="4133" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们传入一个对象，我们希望用它来断言我们的spy函数。因为，在这种情况下，我们的间谍将被赋予一个对象，并且因为JavaScript中的对象是通过引用存储的，所以具有相同键和值的两个对象将不相等。为了帮助解决这个问题，sinon给了我们<code class="fe me mf mg mh b">sinon.match()</code>来比较两个物体。</p><h1 id="8c73" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">把所有的放在一起</h1><pre class="ly lz ma mb gt mn mh mo mp aw mq bi"><span id="c7d3" class="mr lb iq mh b gy ms mt l mu mv">expect(databaseUpdaterSpy.getCall(0).calledWith(sinon.match({ body: 10 }))).to.be.true;</span></pre><p id="801e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">^在这里，我们期待着<code class="fe me mf mg mh b">databaseUpdater</code>间谍，第一次被调用时，是用一个看起来和<code class="fe me mf mg mh b">{ body: 10 }</code>一模一样的ab对象来调用的。</p><p id="9f82" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望这有用。如果你发现任何错误，请评论。</p></div></div>    
</body>
</html>