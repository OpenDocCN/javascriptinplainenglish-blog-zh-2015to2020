<html>
<head>
<title>What’s the difference between Var, Let and Const in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Var，Let，Const有什么区别？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-different-between-var-let-and-const-in-javascript-e0514d185ff6?source=collection_archive---------9-----------------------#2020-07-06">https://javascript.plainenglish.io/whats-different-between-var-let-and-const-in-javascript-e0514d185ff6?source=collection_archive---------9-----------------------#2020-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jk jl jm jn gh gi paragraph-image"><div class="ab gu cl jo"><img src="../Images/866d3ad804e07979fea8a6f8249af100.png" data-original-src="https://miro.medium.com/v2/format:webp/1*bPIf2_HXNUG4O_tSvWKYsg.png"/></div></figure><p id="33d9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在不久前，JavaScript中只有一种定义变量的方法，那就是使用<code class="fe kp kq kr ks b">var</code>。然而，随着ES6的引入，增加了两种额外的方式，<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>。等等…为什么我们需要三种不同的方法来做同样的事情？有没有一个应该用在另一个之上的例子？这些就是我在这篇文章中要回答的一些问题。但是首先，我们需要讨论一个叫做<strong class="jt io">范围</strong>的概念。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="e599" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">函数作用域与块作用域</h1><p id="01f0" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">JavaScript有两个不同的范围。第一个是<em class="md">功能范围</em>，有时也称为全局范围，第二个是<em class="md">块范围</em>。让我们看几个例子来更好地理解函数作用域和块作用域之间的区别。</p><h2 id="9287" class="me lb in bd lc mf mg dn lg mh mi dp lk kc mj mk lo kg ml mm ls kk mn mo lw mp bi translated"><strong class="ak">功能范围</strong></h2><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a71f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在上面的例子中，<code class="fe kp kq kr ks b">foo</code>的值在函数的第4行被返回，但是当我们试图在第7行的函数之外访问<code class="fe kp kq kr ks b">foo</code>时抛出一个错误。这是因为使用<code class="fe kp kq kr ks b">var</code>定义的变量是<strong class="jt io"> <em class="md">函数作用域的</em> </strong>。它们只能在定义它们的函数中被访问。那么块范围呢？</p><h2 id="9646" class="me lb in bd lc mf mg dn lg mh mi dp lk kc mj mk lo kg ml mm ls kk mn mo lw mp bi translated"><strong class="ak">块范围</strong></h2><p id="c8e0" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">让我们使用<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>再添加几个变量，以及一个<code class="fe kp kq kr ks b">if</code>语句到我们之前的函数中，看看这些变量的范围有什么不同。</p><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="802f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如您在第7–9行中看到的，在<code class="fe kp kq kr ks b">if</code>语句中的所有<code class="fe kp kq kr ks b">console.log()</code>语句都返回预期的变量值。然而，在检查第12–14行时，我们开始看到一些不同之处。在第12行，控制台中显示了<code class="fe kp kq kr ks b">foo</code>的值，但是第13和14行返回了<code class="fe kp kq kr ks b">bar</code>和<code class="fe kp kq kr ks b">baz</code>的ReferenceError。这是因为<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>是<strong class="jt io"> <em class="md">块范围的</em> </strong>！</p><blockquote class="mw mx my"><p id="fb39" class="jr js md jt b ju jv jw jx jy jz ka kb mz kd ke kf na kh ki kj nb kl km kn ko ig bi translated">JavaScript将代码块定义为一组花括号<code class="fe kp kq kr ks b">{}</code>之间的代码。</p></blockquote><p id="fb4d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因为<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>是<em class="md">块作用域的</em>，它们只能用定义它们的<code class="fe kp kq kr ks b">if</code>语句的花括号来访问。由于<code class="fe kp kq kr ks b">var</code>是<em class="md">函数作用域的</em>，并且第12行仍然在第1行定义的<code class="fe kp kq kr ks b">someFunction</code>的花括号内，并在第15行结束，我们可以访问第12行<code class="fe kp kq kr ks b">if</code>块之外的<code class="fe kp kq kr ks b">foo</code>的值。最后，由于第17行在<code class="fe kp kq kr ks b">someFunction</code>之外，我们不能再访问第17行的<code class="fe kp kq kr ks b">foo</code>。</p><p id="b6f7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个例子概述了ES6引入的<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>与旧的<code class="fe kp kq kr ks b">var</code>变量声明在范围上的不同。范围是这些声明之间最明显的区别，但是，它们中的每一个都有一些额外的细微差别。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="dead" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">定义变量</h1><p id="b96c" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">首先让我们看一下遗留的声明性的，<code class="fe kp kq kr ks b">var</code>。</p><h2 id="ac15" class="me lb in bd lc mf mg dn lg mh mi dp lk kc mj mk lo kg ml mm ls kk mn mo lw mp bi translated">在for循环中使用var</h2><p id="7698" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">假设我们有以下for循环:</p><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4680" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么您认为这段代码会输出到控制台上吗？</p><p id="c9eb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">说真的…在你继续滚动之前，先猜一下吧！</p><p id="bf6d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上述代码的输出是:</p><pre class="mq mr ms mt gt nc ks nd ne aw nf bi"><span id="fbc3" class="me lb in ks b gy ng nh l ni nj">0<br/>1<br/>2<br/>3<br/>4<br/>5 // wait...why is this here?!?</span></pre><p id="c167" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们期望我们的代码输出数字0–4，但是我们也从控制台日志的第5行得到数字5。原因是我们使用<code class="fe kp kq kr ks b">var</code>定义了变量<code class="fe kp kq kr ks b">i</code>。因为<code class="fe kp kq kr ks b">var</code>是<em class="md">函数作用域的</em>，它仍然可以在我们的for循环之外访问。一旦<code class="fe kp kq kr ks b">i</code>增加到5，for循环本身就退出。然而，<code class="fe kp kq kr ks b">i</code>保留了值5，这就是第5行返回的内容。</p><h2 id="8253" class="me lb in bd lc mf mg dn lg mh mi dp lk kc mj mk lo kg ml mm ls kk mn mo lw mp bi translated">重新定义var</h2><p id="738f" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">最初使用<code class="fe kp kq kr ks b">var</code>定义的变量可以在以后使用<code class="fe kp kq kr ks b">var</code>重新定义。</p><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="4ad1" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让</h1><p id="671d" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated"><code class="fe kp kq kr ks b">let</code>声明与<code class="fe kp kq kr ks b">var</code>非常相似，在很多方面感觉像是<code class="fe kp kq kr ks b">var</code>的ES6升级版，修补了一些奇怪的地方。让我们看看<code class="fe kp kq kr ks b">let</code>在上面列出的两个例子中是如何工作的。</p><h2 id="ea9d" class="me lb in bd lc mf mg dn lg mh mi dp lk kc mj mk lo kg ml mm ls kk mn mo lw mp bi translated">在for循环中使用<code class="fe kp kq kr ks b">let</code></h2><p id="c001" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">让我们探索一下上面使用的for循环，但是使用<code class="fe kp kq kr ks b">let</code>而不是<code class="fe kp kq kr ks b">var</code>。</p><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="187e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么这次的产量是多少呢？</p><pre class="mq mr ms mt gt nc ks nd ne aw nf bi"><span id="9707" class="me lb in ks b gy ng nh l ni nj">0<br/>1<br/>2<br/>3<br/>4<br/>//ReferenceError: i is not defined</span></pre><p id="4904" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如你所看到的，值1–4被输出到控制台，但是由于<code class="fe kp kq kr ks b">let</code>是<em class="md">块范围的</em>，所以<code class="fe kp kq kr ks b">i</code>在for循环之外是不可访问的。因此，我们在第5行得到一个ReferenceError，而不是将值5输出到控制台。在绝大多数情况下，我们真的不应该在声明了<code class="fe kp kq kr ks b">i</code>的for循环之外访问它。使用<code class="fe kp kq kr ks b">let</code>确保我们不能这样做。</p><h2 id="25cd" class="me lb in bd lc mf mg dn lg mh mi dp lk kc mj mk lo kg ml mm ls kk mn mo lw mp bi translated">重新定义<code class="fe kp kq kr ks b">let</code></h2><p id="5e34" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">类似于<code class="fe kp kq kr ks b">var</code>，我们能够重新定义已经使用<code class="fe kp kq kr ks b">let</code>声明的变量。尽管我们被允许使用的语法更加严格。</p><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="00a4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如你所看到的，我们仍然能够重新定义<code class="fe kp kq kr ks b">foo</code>，但是我们不得不在不使用<code class="fe kp kq kr ks b">let</code>的情况下这样做。这使我们不必试图创建一个变量，而是意外地重新定义一个现有的变量。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="2c51" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">常数</h1><p id="7e7b" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">关键字<code class="fe kp kq kr ks b">const</code>是单词<em class="md">常量</em>的缩写。和<code class="fe kp kq kr ks b">let</code>一样，<code class="fe kp kq kr ks b">const</code>是<em class="md">块范围的</em>。不像<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">var</code>可以不初始化就声明，<code class="fe kp kq kr ks b">const</code>声明的时候必须初始化。这两者的主要区别在于，当使用<code class="fe kp kq kr ks b">const</code>声明一个变量时，它不能被重新赋值。这是有意义的，因为目的是变量保持不变。这意味着在for循环中使用它是没有意义的，因为它不能递增。</p><p id="79d7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">正如我之前提到的，使用<code class="fe kp kq kr ks b">const</code>定义的变量不能被重新分配，但是可以变异。考虑下面的例子。</p><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f494" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如您所见，第8行将抛出一个错误，因为它试图重新分配常量变量<code class="fe kp kq kr ks b">cars</code>。然而，通过将值“porsche”推到数组的末尾来改变<code class="fe kp kq kr ks b">cars</code>的值是完全可以的。上述函数的输出是:</p><pre class="mq mr ms mt gt nc ks nd ne aw nf bi"><span id="14b2" class="me lb in ks b gy ng nh l ni nj">[ 'acura', 'audi', 'bmw', 'porsche' ]</span></pre><p id="98b9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此外，因为<code class="fe kp kq kr ks b">const</code>是块范围的，函数在第19行返回一个ReferenceError，因为<code class="fe kp kq kr ks b">console.log(cars)</code>位于定义变量<code class="fe kp kq kr ks b">cars</code>的<code class="fe kp kq kr ks b">if</code>语句之外。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="6d9c" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">提升</h1><p id="a172" class="pw-post-body-paragraph jr js in jt b ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko ig bi translated">本文的主题不是提升，所以关于什么是提升，我就不赘述了。可以说，在编译阶段，JavaScript将变量和函数声明存储到内存中。打个比方，想象一下JavaScript在执行代码之前，将所有变量和函数声明移到它们作用域的顶部。这不是正在发生的事情，但这是一个好的思考提升的方式。回到本文的主题，<code class="fe kp kq kr ks b">var</code>、<code class="fe kp kq kr ks b">let</code>、<code class="fe kp kq kr ks b">const</code>的吊装方式是有区别的。这里有一个简单的例子:</p><figure class="mq mr ms mt gt jn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ff84" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">与<code class="fe kp kq kr ks b">let</code>或<code class="fe kp kq kr ks b">const</code>相比，<code class="fe kp kq kr ks b">var</code>的吊装方式有一个非常重要的区别。不同之处在于初始化。当var被提升时，不管分配给它的值是多少，它都用值<code class="fe kp kq kr ks b">undefined</code>初始化。相比之下，当<code class="fe kp kq kr ks b">let</code>或<code class="fe kp kq kr ks b">const</code>被提升时，它们根本没有被初始化。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="5dee" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">概述</h1><ul class=""><li id="09e0" class="nk nl in jt b ju ly jy lz kc nm kg nn kk no ko np nq nr ns bi translated"><code class="fe kp kq kr ks b">var</code>是函数作用域，而<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>是块作用域。</li><li id="0cc7" class="nk nl in jt b ju nt jy nu kc nv kg nw kk nx ko np nq nr ns bi translated"><code class="fe kp kq kr ks b">var</code>和<code class="fe kp kq kr ks b">let</code>可以重新分配，而<code class="fe kp kq kr ks b">const</code>不能。</li><li id="98c1" class="nk nl in jt b ju nt jy nu kc nv kg nw kk nx ko np nq nr ns bi translated">当<code class="fe kp kq kr ks b">var</code>被提升时，它被初始化为<code class="fe kp kq kr ks b">undefined</code>的值。当<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>被吊起时，它们根本没有被初始化。</li><li id="0644" class="nk nl in jt b ju nt jy nu kc nv kg nw kk nx ko np nq nr ns bi translated"><code class="fe kp kq kr ks b">var</code>和<code class="fe kp kq kr ks b">let</code>无需初始化即可声明。但是，<code class="fe kp kq kr ks b">const</code>必须在声明的时候初始化。</li></ul><p id="b489" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么什么时候应该用哪个呢？通常最好避免使用var，因为它通常表示在ES6发布之前编写的未受影响的遗留代码。<code class="fe kp kq kr ks b">var</code>的功能范围也可能比<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>的块范围更难跟踪。<code class="fe kp kq kr ks b">let</code>和<code class="fe kp kq kr ks b">const</code>更严格的语法要求也鼓励更好的编码。</p><p id="9536" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在大多数情况下，当创建一个变量时，你的默认值应该是<code class="fe kp kq kr ks b">const</code>。如果您怀疑将来需要重新分配它(for循环、switch语句、算法交换等)。)使用<code class="fe kp kq kr ks b">let</code>。</p><p id="cb8d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有问题吗？其他想法？欢迎在评论中提出来！我希望这能对你有所帮助。</p></div></div>    
</body>
</html>