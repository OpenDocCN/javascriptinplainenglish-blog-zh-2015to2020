<html>
<head>
<title>Building a data layer with Vue and Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Vue和组合API构建数据层</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-data-layer-with-vue-and-composition-api-547cc9761b4c?source=collection_archive---------3-----------------------#2020-08-08">https://javascript.plainenglish.io/building-a-data-layer-with-vue-and-composition-api-547cc9761b4c?source=collection_archive---------3-----------------------#2020-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d254" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你学习一个新的前端库时，比如Vue或React，你可以阅读很多关于某些最佳实践的资料。在有效的组件组合、如何防止性能瓶颈以及状态管理的基础(如Redux、VueX等)上寻找资源应该没有问题。</p><p id="f925" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，有一个领域很难找到任何信息，那就是如何构建一个好的数据层。人们通常会花很多心思来优化和组织视图层，但数据层可能会被忽略，并成为常见的错误来源。</p><p id="cd1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是数据层？</p><p id="cb6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在前端应用程序的上下文中，数据层实际上指的是三层:</p><ol class=""><li id="bc81" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">获取层—使用XHR、获取或Websockets联系服务器的代码。通常是一组服务(类)或纯功能。</li><li id="9973" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">规范化/序列化层—处理传入和传出数据的代码。</li><li id="19c9" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">存储层—处理将数据保存和访问到客户端存储的代码。</li></ol><p id="7981" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">令人惊讶的是，网上关于如何做好这些的信息很少。可能是因为这个逻辑高度依赖于你的API的设计，很难通用化。尽管如此，我还是会试着提供一些指导。</p><h1 id="3aae" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">你需要数据层吗？</h1><p id="72c9" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">如果一个组件直接执行ajax调用，并使用原始响应来呈现数据，而不将其存储在任何类型的客户端存储中，这实质上意味着不涉及数据层。</p><p id="5b41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某些情况下，这是好的，但在很多情况下，根本不是。</p><p id="3d9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这种方法，在以下情况下可能会出现问题…</p><ol class=""><li id="1578" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">同一种请求在多个地方被执行，提取逻辑需要被重用</li><li id="eb05" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">来自服务器的数据需要被处理。</li><li id="d62c" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">部分或全部数据可能需要在其他地方重用</li><li id="4f56" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">数据需要被再次使用，例如当用户回到先前的路线时，再次触发相同的请求不是最佳的。</li><li id="75d8" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">这里涉及到SSR，服务器状态需要传递给客户端</li></ol><p id="37cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着越来越多的内容需要被覆盖，复杂性会呈指数级增长。在一个组件中直接处理这些问题很容易失控，因此您必须开始将逻辑移到其他地方，并开始将其一般化——这就是数据层如何慢慢开始形成的。</p><p id="a3cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您的后端支持GraphQL之类的传统解决方案，或者符合JSON:API之类的标准，那么您可以通过使用现有的数据层客户端(如Apollo或vuex-orm)来节省大部分或全部工作。Apollo需要一个GraphQL后端，使用vuex-orm是有意义的，尤其是如果你的API是Restful的话。</p><p id="239e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果不是，并且你的后台是非传统的，那么工作就在你身上。这就是我要报道的案子。</p><h1 id="9797" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">提取图层</h1><p id="83b4" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">让我们从一个组件开始，它使用Axios执行ajax请求，并将数据传递给模板。</p><p id="57b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该组件获取并处理结果:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="d3eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是在组件中直接联系API的一种非常低级的方法。我们看到一堆引用被使用，如<code class="fe mg mh mi mj b">data</code> <code class="fe mg mh mi mj b">error</code> <code class="fe mg mh mi mj b">isLoading</code>。我们将它们和<code class="fe mg mh mi mj b">fetchUsers</code>函数本身一起传递给模板——以便在需要时可以再次触发(例如让用户重试)。</p><p id="93d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管如此，只是为了获得一些用户还是有很多代码，而且像这样的逻辑肯定会在代码的很多地方出现。</p><p id="5318" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上，我们可以引入第三方解决方案，如vue-use、vue-composition-toolkit、vue-concurrency中的util函数来改进它。或者我们可以开始使用悬念，而不是设置裁判，在<code class="fe mg mh mi mj b">setup</code>中直接使用<code class="fe mg mh mi mj b">async/await</code>并返回一个承诺。</p><p id="dcd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是出于演示的目的，让我们将前面的代码重构为一个通用的解决方案:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="218f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通用的ref设置逻辑被移动到一个名为<code class="fe mg mh mi mj b">useAsync</code>的定制钩子中，只有特定于案例的逻辑通过回调传递给它。回调预计会触发一些ajax并返回数据。</p><p id="da54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我也创建了一个小的<code class="fe mg mh mi mj b">normalizeUser</code>函数，但是以后还会有更多的工作。</p><p id="e949" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还要注意<code class="fe mg mh mi mj b">processError</code>。在来自服务器的所有响应上使用这个函数允许我们向一致和统一的错误处理前进。</p><p id="b621" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这个<code class="fe mg mh mi mj b">useAsync</code>函数在整个应用程序中使用，我们就有效地创建了一个基本的获取层。由于序列化和存储层的需要，它可能需要一些补丁，但基础是存在的。</p><h1 id="7608" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">序列化层</h1><p id="84dd" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">序列化层的目的是处理传入和传出的数据，并至少执行以下一些操作:</p><ol class=""><li id="3092" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">验证响应是否具有正确的格式(可能通过像<a class="ae mk" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>这样的工具)</li><li id="7fa1" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">改变结构以适应用户界面的需要(也许是为了让数据更容易迭代)</li><li id="a645" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">将日期字符串序列化为日期对象</li><li id="90be" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">调整命名，也许将snake_case改为camelCase</li><li id="5040" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">如果需要，提高不同端点之间的命名一致性</li><li id="1123" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">删除我们不需要的数据。这就清楚了FE实际使用的是哪种数据。较小的对象更容易处理，也可能对性能产生影响(潜在的反应跟踪更少)</li></ol><p id="3f28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">API响应中发送的模型往往很大，并且由于历史原因或因为其他客户端(移动应用程序、机器人、第三方脚本)需要而具有额外的属性。</p><p id="e762" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本规范化函数可能如下所示:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="fe06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它的输出是一个小而简单的对象，也提供了一些回退值。</p><p id="ab27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">序列化函数会做相反的事情。将“正常化”的用户变回原来的格式。当您将用户发送回您的API时，可能是在编辑个人数据时，您会用到它。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0bad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里这个函数更简单，可能只返回服务器希望客户机改变的内容的子集。图像被排除在外，因为它们可能由特定的端点处理。在严格的REST-API的情况下，这对于一个<code class="fe mg mh mi mj b">PATCH</code>请求<code class="fe mg mh mi mj b">PATCH /users/1</code>来说是可以的。对于一个合适的<code class="fe mg mh mi mj b">PUT</code>请求来说，整个模型被发送出去，而不仅仅是一组变更，这是不可行的。定制API通常也期望一组变化，否则，它们将是RESTful的:)。</p><h1 id="ebc4" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">商店层</h1><p id="6a5b" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">如果正在获取数据并将其规范化为最简单的格式，它们就可以存储了。</p><p id="c322" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上，有一些问题需要解决。如何存储数据？窝多深？将实体存储在Map(Dict)结构中还是作为数组？</p><p id="faf8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们回到我们之前的<code class="fe mg mh mi mj b">useAsync</code> + <code class="fe mg mh mi mj b">fetchUsers</code>的解决方案。我们在<code class="fe mg mh mi mj b">useAsync</code>内部传递了一个回调函数，它调用Axios并触发规范化函数。这个函数现在应该再做一件事:除了返回数据之外，还要将它们传递给商店。在VueX中，这意味着让它们发生某种变异。</p><p id="8427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将是最直接的方法:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6412" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里发生了什么事？我们使用store中的两个getter—<code class="fe mg mh mi mj b">hasUsers</code>和<code class="fe mg mh mi mj b">users</code>。<code class="fe mg mh mi mj b">hasUsers</code>是一个简单的布尔值返回函数，它检查有效的<code class="fe mg mh mi mj b">users</code>是否在存储中。开始时，它可以只在存储、非空数组或对象中寻找真值。稍后，它可能会变得更加复杂，甚至检查最后一次获取的时间(如果用户在很久以前被加载，它们就不再有效)。</p><p id="d9bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在这一点上，我们陷入了和以前相似的困境。随着我们开始在新组件中处理更多的端点，我们可能不得不一遍又一遍地做这样的事情:</p><ol class=""><li id="7b09" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">检查存储中的有效值，如果存在，立即通过存储getters返回</li><li id="6699" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">成功后，将数据提交给存储</li></ol><p id="7714" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来相似的代码会一遍又一遍地重复，每次我们都必须考虑如何命名getters和mutations。</p><p id="40db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这难道不能被抽象化吗？</p><p id="ffc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，如果我们幸运地拥有一个GraphQL后端和一个Apollo客户端，或者如果我们有一个RESTful，甚至可能是JSON:API后端并使用vuex-orm，我们就不必处理这个问题。在GraphQL领域，我们只执行查询，在REST领域，我们以CRUD方式处理一致的资源，并通过orm进行抽象。</p><p id="1870" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们的API是定制的，我们至少可以优化每个端点发生的逻辑。在每次端点调用时，我们将检查现有值，并可能保存一个新值，或者两者都保存(以防后台重载)。</p><p id="f695" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的钩子能搞定吗？</p><p id="a4cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某种程度上，是的，在这一点上，我们可能应该把它重新命名为类似于<code class="fe mg mh mi mj b">useApi</code>的东西，因为它变得更加固执己见。或者更好的办法是，在<code class="fe mg mh mi mj b">useAsync</code>的顶部加上<code class="fe mg mh mi mj b">useApi</code>。</p><p id="0ce8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有两种方法可以解决这个问题:约定或配置。</p><p id="f2a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">配置</strong>:调用<code class="fe mg mh mi mj b">useApi</code> <br/> <strong class="jm io">约定:</strong>从一个端点名或者从一个函数名派生出getter和mutation名。</p><p id="2ced" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我通常更喜欢传统而不是配置，所以我选择后者。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5d85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，<code class="fe mg mh mi mj b">useApi</code>在<code class="fe mg mh mi mj b">useAsync</code>之上构成。它需要传递一个命名函数，并从中派生出存储getter和setter名称。因此它检查<code class="fe mg mh mi mj b">hasUsers</code>，如果返回true，它返回<code class="fe mg mh mi mj b">Users</code> getter。成功后，它调用<code class="fe mg mh mi mj b">setUsers</code>突变。点击一个新的端点就变成了创建一个函数<code class="fe mg mh mi mj b">X</code>并在<code class="fe mg mh mi mj b">hasX</code> <code class="fe mg mh mi mj b">X</code>和<code class="fe mg mh mi mj b">setX</code>的存储中创建getters和setters的例程。这种方法的一种替代方法是将getter和setter名称传递到<code class="fe mg mh mi mj b">useApi</code>中，但是根据我的经验，这种约定可以减少开销。</p><h1 id="e4f0" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">文件夹结构？</h1><p id="48e3" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">随着这种方法的发展，很明显需要一些额外的代码来获取、序列化和存储数据。它可以并排存储在一个组件中，但是通常更好的方法是创建某种类型的<code class="fe mg mh mi mj b">data</code>文件夹。</p><p id="e461" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在该文件夹中，可以有一个文件列表，每个端点处理程序一个文件。</p><pre class="lz ma mb mc gt ml mj mm mn aw mo bi"><span id="458d" class="mp kx in mj b gy mq mr l ms mt">data<br/>  createUser.js<br/>  findUser.js<br/>  createPost.js<br/>  findPost.js<br/>  login.js<br/>  </span></pre><p id="48f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些函数中的每一个都有一个<code class="fe mg mh mi mj b">normalizeReponse</code>函数、<code class="fe mg mh mi mj b">fetch</code>函数和几个将被传递给存储的突变函数和getter函数。</p><p id="eaf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果逻辑进一步膨胀，就有可能进一步分割:</p><pre class="lz ma mb mc gt ml mj mm mn aw mo bi"><span id="c0b0" class="mp kx in mj b gy mq mr l ms mt">data<br/>  createUser<br/>    fetch.js<br/>    serialize.js<br/>    store.js</span></pre><p id="f771" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是根据我的经验，几乎不需要这么深！</p><h1 id="18a7" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">包扎</h1><p id="81a7" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">我希望这个小小的见解有用。实际上，一个定制的<code class="fe mg mh mi mj b">useApi</code>函数可能会膨胀，但是创建一些灵活、有用且易于维护的东西是可能的——一个定制的高质量数据层。</p><h2 id="2dd5" class="mp kx in bd ky mu mv dn lc mw mx dp lg jv my mz lk jz na nb lo kd nc nd ls ne bi translated">在herohero上订阅每周编码示例、技巧和提示</h2><p id="3cae" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">嘿👋如果你觉得这些内容有帮助，请在herohero 上订阅我，我经常在这里分享我日常使用JavaScript和Vue的经验中的简洁而有用的编码技巧。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><a href="https://herohero.co/martin"><div class="gh gi nf"><img src="../Images/19339e390e1513a8a73f83e1ec1036a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29xXbBkTMAe_w-dkMYfI4Q.png"/></div></a></figure></div></div>    
</body>
</html>