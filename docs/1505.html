<html>
<head>
<title>Server-Side Rendering in React — Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-Redux中的服务器端渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/server-side-rendering-in-react-redux-8d6209fbfed?source=collection_archive---------2-----------------------#2020-03-25">https://javascript.plainenglish.io/server-side-rendering-in-react-redux-8d6209fbfed?source=collection_archive---------2-----------------------#2020-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="66ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在服务器和客户端处理Redux存储？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6ec022a29b3cccbd7bff95b698503d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKHILmDR-vZjei_JKpvdTQ.jpeg"/></div></div></figure><p id="11ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">欢迎阅读我关于React 中<strong class="kt ir">服务器端渲染的系列文章的第三部分。<a class="ae ln" href="https://medium.com/javascript-in-plain-english/server-side-rendering-in-react-expressjs-8a87af0edba4" rel="noopener">上一次我已经描述了</a>如何配置在服务器和客户端渲染的项目。今天，我们将尝试在前面的示例中添加Redux。</strong></p><blockquote class="lo lp lq"><p id="fb9d" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">我假设你知道Redux的基本知识，所以我不会花时间描述它。如果你不熟悉<a class="ae ln" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>架构的概念和<a class="ae ln" href="https://redux.js.org" rel="noopener ugc nofollow" target="_blank"> Redux </a>本身，请查阅其<a class="ae ln" href="https://redux.js.org/introduction/getting-started" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></blockquote><h1 id="67ca" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">软件包安装</h1><p id="eccd" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">首先，在我们开始配置我们的应用程序在服务器和客户机上使用Redux之前，我们必须安装两个包:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/0193a7937e69c621ac35a5ea034f5edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYthguYN-m-uKf-IAfJ94g.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Add redux and react-redux packages</figcaption></figure><p id="27e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mx my mz na b">redux</code>包只包含Redux库。<code class="fe mx my mz na b">react-redux</code>依赖将帮助我们连接Redux和React组件。</p><h1 id="450a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">reducer+App组件的变化</h1><p id="39de" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在我们已经安装了所有必要的包，我们可以继续向我们的项目添加Redux。让我们从添加reducer开始——为此，我将<code class="fe mx my mz na b">reducers</code>文件夹添加到了<code class="fe mx my mz na b">src</code>目录中，并将<code class="fe mx my mz na b">index.js</code>文件放入其中。请看看这个文件的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/1e6fbc54264f37f4aef52785229519c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7JlXw4KRrf1uucN7laGaw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">The reducers/index.js file</figcaption></figure><p id="e62f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以上减速器只处理一种动作类型:<strong class="kt ir"> CHANGE_TEXT </strong>。它改变了<code class="fe mx my mz na b">initialText</code>状态属性的值。接下来要做的事情是修改<code class="fe mx my mz na b">App.js</code>组件代码，以调度按钮点击时的动作。我们可以这样做:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/1092be0490ee608abdcd9b2fff007978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnBMOGCIQtCgnoLTrIwgmg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">The amended App.js component</figcaption></figure><p id="bc20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们已经完全摆脱了组件的内部状态。这是因为从现在开始，我们将在Redux store 中全局保存状态<strong class="kt ir">。得益于从<code class="fe mx my mz na b">react-redux</code>包导入的<code class="fe mx my mz na b">connect</code>函数，可以将状态属性(<code class="fe mx my mz na b">mapStateToProps</code>方法)和方法分派动作(<code class="fe mx my mz na b">mapDispatchToProps</code>函数)注入组件的<code class="fe mx my mz na b">props</code>对象。</strong></p><h1 id="a506" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">服务器端配置</h1><p id="3966" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在是时候对我们的解决方案的服务器部分做一些改变了。请看下面修改后的<code class="fe mx my mz na b">server.js</code>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/e4b7bf13f2c6a2d5611069aa4490bec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHnKBuPGkp9cyYLS-Aym7w.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">The modified server.js file</figcaption></figure><p id="390f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好，让我们分析一下这里发生了什么变化。首先，请看一下导入部分:我们从<code class="fe mx my mz na b">redux</code>包中导入了<code class="fe mx my mz na b">createStore</code>方法；来自<code class="fe mx my mz na b">react-redux</code>库的<code class="fe mx my mz na b">Provide</code>组件和我们几分钟前刚刚添加的<code class="fe mx my mz na b">reducers</code>。</p><p id="14e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，请看看我们如何使用它们。通过调用将<code class="fe mx my mz na b">reducers</code>和<code class="fe mx my mz na b">initialState</code>作为参数传递的<code class="fe mx my mz na b">createStore</code>函数，我们创建了用<code class="fe mx my mz na b">initialState</code>对象初始化的Redux存储。接下来要注意的是，我们用<code class="fe mx my mz na b">Provider</code>组件包装了<code class="fe mx my mz na b">App</code>组件。我们还通过组件的属性将已经创建的Redux存储传递给这个组件。由于这个原因，我们在<code class="fe mx my mz na b">App.js</code>文件中使用的<code class="fe mx my mz na b">connect</code>函数可以访问商店。</p><p id="5f1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还请注意，我们仍然将<code class="fe mx my mz na b">initialState</code>对象作为<code class="fe mx my mz na b">Html</code>组件的属性进行传递。正如您马上会看到的，我们在客户端仍然需要它。</p><h1 id="5d1b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">客户端配置</h1><p id="1f24" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">正如您可能预期的那样，最后要做的事情是修改客户端代码。请看下面的<code class="fe mx my mz na b">client.js</code>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/6305b1e23eed4cca82212fac086d761a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRtT2nf6njEE_I7No-xi0A.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">The modified client.js file</figcaption></figure><p id="8d94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里导入了与在<code class="fe mx my mz na b">server.js</code>文件中相同的三样东西。然后，我们还创建了商店，将<code class="fe mx my mz na b">reducers</code>作为它的第一个参数。这里唯一的区别是我们传递给<code class="fe mx my mz na b">createStore</code>函数的初始状态——它是从存储在<code class="fe mx my mz na b">APP_STATE</code>对象中的值创建的对象。因此，我们使用相同的机制在服务器和客户端之间共享初始状态。</p><p id="c3ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，我们在这里做的最后一件事是将已经创建的store对象作为包装<code class="fe mx my mz na b">App</code>组件的<code class="fe mx my mz na b">Provider</code>组件的属性进行传递。这样，客户端React组件<strong class="kt ir">中使用的所有<code class="fe mx my mz na b">connect</code>方法也可以访问</strong>存储。</p><h1 id="7851" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">摘要</h1><p id="9668" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">今天就到这里。我认为将Redux添加到服务器端渲染的React应用程序中是非常简单的。我们只需要创建存储两次，第一次是在服务器上，然后在加载客户端脚本时再次创建。我们也必须共享初始状态，但是我们可以使用<strong class="kt ir">相同的机制</strong>来实现，就像前面的例子一样，不需要使用Redux。</p><blockquote class="lo lp lq"><p id="a8fe" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">我们今天讨论的例子是我的GitHub存储库中的<a class="ae ln" href="https://github.com/burczu/redux-server-side-rendering-example" rel="noopener ugc nofollow" target="_blank"/>。<strong class="kt ir">我鼓励你克隆它，自己玩。</strong></p></blockquote><p id="7ffc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想，现在我们已经了解了很多关于服务器端渲染的知识，但这还不是我系列的结尾！在下一篇文章中，我将向您展示如何将<a class="ae ln" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> react-router </a>添加到我们的示例中。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="bfad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> P.S. </strong>本文是关于使用React进行服务器端渲染的系列文章的一部分。请参阅以下系列的所有项目列表:</p><ul class=""><li id="faf5" class="ni nj iq kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-an-introduction-55f4c7fa274b" rel="noopener">反应中的服务器端渲染-简介</a></li><li id="f90a" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-expressjs-8a87af0edba4" rel="noopener">React-express . js中的服务器端渲染</a></li><li id="9d25" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-redux-8d6209fbfed" rel="noopener">React-Redux中的服务器端渲染</a></li><li id="77d0" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-redux-ab0af31c9c4b" rel="noopener">反应-反应-路由器中的服务器端渲染</a></li><li id="d96a" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">反应中的服务器端渲染—处理真实数据</li></ul></div></div>    
</body>
</html>