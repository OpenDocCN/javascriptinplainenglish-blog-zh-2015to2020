<html>
<head>
<title>Exploring NestJS — Nest’s module system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索NestJS——Nest的模块系统</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploring-nestjs-nests-module-system-88c6d7ad0970?source=collection_archive---------0-----------------------#2020-02-04">https://javascript.plainenglish.io/exploring-nestjs-nests-module-system-88c6d7ad0970?source=collection_archive---------0-----------------------#2020-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1e57d1418e89b6cd246578bc8e4d09a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l_6HQQM_nfsXWk7y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jonassmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jonas Smith</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抬头！本文是探索NestJS系列的第二部分🙌🏻。</p><p id="84cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你愿意，你可以在这里找到第一部分:<a class="ae kc" href="https://medium.com/javascript-in-plain-english/exploring-nestjs-installing-nestjs-and-getting-started-fb2e4f36b596" rel="noopener">https://medium . com/JavaScript-in-plain-English/exploring-nestjs-installing-nestjs-and-getting-started-FB 2 e 4 f 36 b 596</a>。</p><h1 id="dad9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模块系统到底是什么？</h1><p id="a3f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">NestJS选择使用所谓的<em class="me">“模块”。</em></p><p id="ec20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块是应用程序的一个独立部分，它封装了属于一起的多种功能。</p><p id="a75c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，一个模块包含一个业务领域所需的所有功能。</p><h1 id="7703" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模块系统是如何工作的？</h1><p id="af6d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">假设您正在构建一个有多个用户的应用程序，可能保存在数据库的某个地方。</p><p id="9980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，您必须访问数据本身(用户数据)，为此您需要一些文件，比如说<em class="me"> User.entity.ts ( </em>描述用户实体的结构)和一个服务，通过它您可以进行CRUD操作(创建、读取、更新、删除):<em class="me"> Users.service.ts. </em></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/2c9748bba92a3ba0d20c84b91ba14af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmxNedXqlQvOr4r6fHzH7A.png"/></div></div></figure><p id="235f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须将这两个文件“放”在同一个模块中:<em class="me"> Users.module.ts，</em>，这样它们显然属于同一个模块。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/9dabd6da5311172fa7e536c5c8f5baa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGaoWr6n4fUBAwFjO2h2Aw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The User entity and the Users service will be encapsulated in the same module</figcaption></figure><p id="f2b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当应用程序的另一部分(另一个模块)必须处理任何与用户相关的事情时，它知道<em class="me">用户模块</em>是访问点。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/664dcd374ee79df3ca7747be32abd0d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WrrOuU-csR8TZ-NppEGVw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Example: Games module can access functionalities of the Users module (like getting user details)</figcaption></figure><h1 id="d3a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">根应用程序模块</h1><p id="04ab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每个NestJS应用程序都有一个根模块，称为应用程序模块。</p><p id="e55d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在模块的依赖图中，所有其他模块都在这个模块的“下面”。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/3620a726eecf0f7ecc0e9a0560faaee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjq-ttsakUgggc_xjUt5Qw.png"/></div></div></figure><p id="f51f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您没有在Nest应用程序中创建任何其他模块，您仍将拥有默认的“AppModule”，如下所示:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/c4332da701d3e2de123a5aa909d25d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZwjWxIm-p1L7K6cECz6vg.png"/></div></div></figure><p id="6230" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，模块是通过用<em class="me"> @Module </em> decorator <em class="me">修饰TypeScript类来定义的。</em></p><p id="51a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个模块由其<em class="me">控制器</em>、<em class="me">提供者</em>、<em class="me">导出</em>和<em class="me">导入</em>定义。</p><p id="cfb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来揭开这些是什么意思。</p><h1 id="bc15" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">控制器</h1><p id="6580" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">控制器是用<em class="me"> @Controller </em> decorator注释的简单类。</p><p id="f760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以响应GET、POST、PUT等类型的HTTP请求。</p><p id="3086" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不会在这里深究它们(只在下面的文章中)，但这是一个人的样子:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/238b9c3ad1f564acc618d630e5688379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFuPwhFiF4w5LKrB7coUyA.png"/></div></div></figure><p id="0968" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，假设我们已经定义了这个控制器，我们现在必须把它链接到我们想要的模块。</p><p id="550c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">怎么会？我们只需将控制器添加到模块的“控制器”数组中:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/3ffeafb02ceadab75b18ee1d6a83f3c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuHKgQ2uAP_lwv8eS1Sx9A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We import the controller and add it to the “controllers” array of our module</figcaption></figure><p id="993a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧啊。现在，我们的模块中有了一个控制器。</p><h1 id="18d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提供者</h1><p id="1dea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在NestJS中，一个非常重要的装饰器是<em class="me">@ injectible。</em></p><p id="6b47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你把处理业务逻辑的代码(你的应用程序的所有逻辑，访问数据库，访问外部服务等等。)到服务类中。</p><p id="7e74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务类如下所示:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/b00292c4c7b421d26f5f22f573ca700a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xv3m--xxZ0KeuukiV0DYQ.png"/></div></div></figure><p id="a990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这些服务类上使用了<em class="me">@可注入的</em>装饰器<em class="me"> </em>。它支持将这些服务注入到其他地方，例如可能需要与之通信的其他服务。</p><p id="c873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到我们的模块，我们将服务的名称放入我们的提供者数组中。现在我们的服务属于我们心爱的模块。耶！</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/072311ceb156d55f06e398aaca5e2c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sbVBMvbpJEOKlldjLaiLsw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We must put all our services into the “providers” array so that they belong to the module</figcaption></figure><p id="dc4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，提供商不仅仅是为了服务。</p><p id="029d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以用于许多其他情况(与依赖注入相关)，比如交换实现(用于测试)等等。我们不会详细讨论，因为在开始时掌握这些知识并不重要。</p><h1 id="8b10" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">出口</h1><p id="2f05" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">还记得上面的图表吗，一个模块使用另一个模块？</p><p id="2687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想从一个模块中公开一个服务，您可以通过模块定义的"<em class="me"> exports </em>"数组来实现。</p><p id="103c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:考虑一个封装了所有用户相关功能的模块，姑且称之为UsersModule。</p><p id="4394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模块包含用户服务。</p><p id="638d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们希望应用程序的其他部分访问UsersService并检索一些用户数据，我们必须将其从UsersModule中导出。</p><p id="57d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们这样做:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/cf34d46fb4939942722d83dcae3a676d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odoYWLTwtyAQ6Iwouos5HQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We use the “exports” array of the module to export a subset of the module’s providers</figcaption></figure><p id="0768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，<em class="me"> exports </em>数组是我们的<em class="me"> providers </em>数组的一个子集，指定了哪些提供者(比如服务)可以在其他模块中访问和使用。</p><p id="5822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们只有一件事需要澄清:我们如何在另一个模块中使用UsersService？这就是<em class="me">“进口”</em>的作用。</p><h1 id="22d7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进口</h1><p id="6b94" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您使用<em class="me"> imports </em>数组来指定您想要使用<em class="me">服务</em>的其他模块(或其他提供者)。</p><p id="cb4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/95ba528d22b635ae189ed95a543b6343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHjQglVe4vTPe8CvusYeAA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The “imports” array of a module defined which modules’ providers you’d like to use</figcaption></figure><p id="61bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的示例中，我们在AuthModule中导入UsersModule(一个处理身份验证/授权的模块——可能我们需要获取一些用户详细信息来查看用户是否有权访问某些资源)。</p><p id="cdd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，但是我们如何实际使用从UsersModule导出的服务呢？答案是依赖注入:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/d94d8befe9b5fc6ca51f4a469e0a55ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2n1AAc44nx1fsivd8pj-fQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We use NestJS’ dependency injection to inject UsersService into AuthService</figcaption></figure><p id="1263" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在auth service(auth module的一部分)的构造函数中放置了一个UsersService类型的新字段。这将通过NestJS的依赖注入自动连接。优雅！</p><p id="8b90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此之后，我们可以使用UsersService公开的函数:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/a2200eb696080e6b8088e4b60f50db55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuGXZ9w8Zl-7Jn3Xrnn_9Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">We can now use the functions of the UsersService class</figcaption></figure><h1 id="ee6c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我如何创建自己的模块？</h1><p id="ce81" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你在第1章看到了如何引导一个NestJS项目。</p><p id="73d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Nest CLI在您的Nest应用程序中创建另一个模块非常容易。</p><p id="a63e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，您可以手动完成所有的编码和连接，但是CLI简化了我们的工作。</p><p id="b454" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在现有的NestJS项目目录中打开一个终端窗口(或命令提示符窗口),并编写以下内容:</p><pre class="mg mh mi mj gt mu mv mw mx aw my bi"><span id="d12d" class="mz lc iq mv b gy na nb l nc nd">nest generate module my-first-module</span></pre><p id="9b1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到以下对话框:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/63c64a5dd567ad11180e64c7903fdab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_7fBSZiI-JSY4yBXnpUhQ.png"/></div></div></figure><h2 id="78e7" class="mz lc iq bd ld nf ng dn lh nh ni dp ll ko nj nk lp ks nl nm lt kw nn no lx np bi translated">刚刚发生了什么？</h2><p id="2cff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Nest的CLI用新模块的名称(“my-first-module”)和模块文件本身创建了一个新文件夹:<code class="fe nq nr ns mv b">my-first-module.module.ts</code>:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/b0d871fcbb5836ab3e41a43817dbef71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_AgqQKpN2KNucr_G00Bsw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This module is currently quite empty</figcaption></figure><p id="f6a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所观察到的，这个模块相当空，但是我们将在本系列的下一章添加一些控制器和服务。</p><p id="9716" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还需要注意的是，新模块是在AppModule中注册的:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/fa96fc80b7181fd9394dcad4373fea2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KXY8UZUuCGJ-S6PRPB1Yng.png"/></div></div></figure><p id="3273" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来很眼熟🤔？新模块的注册是通过在AppModule中导入它来完成的。</p><p id="c1bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜🎆！现在，您应该对NestJS中的结构有了清晰的了解。</p><p id="9b41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！</p></div></div>    
</body>
</html>