<html>
<head>
<title>Create an Online Multiplayer Tic-Tac-Toe Game with Vue and Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Vue和Firebase创建一个在线多人井字游戏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-an-online-multiplayer-tic-tac-toe-game-with-vue-and-firebase-5e0be047ba42?source=collection_archive---------1-----------------------#2020-02-24">https://javascript.plainenglish.io/create-an-online-multiplayer-tic-tac-toe-game-with-vue-and-firebase-5e0be047ba42?source=collection_archive---------1-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/665800dcd300636e481870af5c1a4e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*laiS_udmP1T6iti9yRdazA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@casparrubin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae kc" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kd ke kf"><p id="d039" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">你可以在这里找到<a class="ae kc" href="https://github.com/z3n0tus/tic-tac-toe-vue" rel="noopener ugc nofollow" target="_blank">的所有代码。</a></p></blockquote><p id="52e4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">VueJS是一种越来越受web开发人员欢迎的技术。它吸收了Angular &amp; React的一些优点，并将它们集成到一个轻量级的高性能框架中。正因为如此，在Vue中你可以比在Angular <em class="ki">或</em> React中做得更快。</p><p id="391b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">所有的框架都在各自的领域表现良好，所以值得学习它们。在本教程中，我们将通过创建一个井字游戏来探索Vue。我们还将整合firebase，这样我们就可以和其他人在线玩了，尽管这并不是说和自己玩不好玩。</p><p id="853d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">这个教程是给谁看的？</strong></p><p id="7673" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这不是对HTML、JavaScript或CSS的介绍。你需要很好地理解这些语言。您还需要有使用npm下载包的经验，如果您以前使用过React或Angular，这将非常有帮助，因为许多概念是相同的。你还需要知道如何使用终端。不过，你根本不需要了解Vue。我会解释一切。</p><p id="a96f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">我如何开始？</strong></p><p id="d70a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">使用npm，全局下载Vue CLI:</p><p id="6e75" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe li lj lk ll b">npm i -g @vue/cli</code></p><p id="112f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后，通过运行以下命令创建一个项目:</p><p id="62e4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe li lj lk ll b">vue create &lt;project-name&gt;</code></p><p id="406a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果你想在你已经在的文件夹中生成项目，你可以用一个<code class="fe li lj lk ll b">.</code>代替<code class="fe li lj lk ll b">&lt;project-name&gt;</code></p><p id="2d53" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe li lj lk ll b">vue create .</code></p><p id="bb5e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">让生成器完成它的工作，然后在IDE中打开项目的根目录。您应该会看到一堆文件。知道这些大部分是什么并不重要。重要的东西在<code class="fe li lj lk ll b">src</code>文件夹中，我们将在那里完成所有的工作。</p><p id="42a3" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Vue已经在<code class="fe li lj lk ll b">src</code>文件夹中创建了一些文件。我们不需要其中的大部分，因为我们将从零开始。所以继续删除<code class="fe li lj lk ll b">assets/</code>文件夹和<code class="fe li lj lk ll b">components/HelloWorld.vue</code>文件。然后，打开<code class="fe li lj lk ll b">App.vue</code>，删除所有代码，替换为以下代码:</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="27ff" class="lu lv iq ll b gy lw lx l ly lz">&lt;template&gt;<br/>  &lt;h1&gt;Tic Tac Toe&lt;/h1&gt;<br/>&lt;/template&gt;</span><span id="c008" class="lu lv iq ll b gy ma lx l ly lz">&lt;script&gt;<br/>export default {<br/>  name: "app"<br/>};<br/>&lt;/script&gt;</span></pre><p id="aa33" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我一会儿会解释这些东西，但是你可以粘贴它，现在忽略它。</p><p id="bf8d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">此时，如果您使用VSCode，您将需要安装<code class="fe li lj lk ll b">Vetur</code>插件。它为Vue开发提供了很多很好的工具。如果你用的是另一个编辑器，那我就帮不了你了。看医生。</p><p id="663d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">打开项目根目录下的终端并运行<code class="fe li lj lk ll b">npm run serve</code>。然后导航到<code class="fe li lj lk ll b">localhost:8080</code>，如果一切正常，您应该会看到一个空白页面，顶部用大号字母写着<code class="fe li lj lk ll b">Tic Tac Toe</code>。恭喜你，你现在是Vue开发者了。打电话给你所有的朋友。</p><p id="7338" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">Vue入口点</strong></p><p id="536b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Vue入口点住在<code class="fe li lj lk ll b">main.js</code>，长这样。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/43f6bcbad24d08c2beb657f4266b7fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*7TbwNTVNLLCHVe9TBuo9rQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">src/main.js</figcaption></figure><p id="37a9" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这个文件的顶部导入Vue和我们的应用程序组件。请注意，App的扩展名为<code class="fe li lj lk ll b">.vue</code>。所有Vue组件都需要有这个扩展。</p><p id="0f2e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">下一行关闭了一个恼人的生产提示，这只是因为从事Vue工作的人那天想不出该做什么而添加的。</p><p id="d48f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">最后几行初始化应用程序。<code class="fe li lj lk ll b">h</code>是什么，我不知道。也许它代表<code class="fe li lj lk ll b">how the fuck do i name this variable, never mind, i'll just call it h</code>。<code class="fe li lj lk ll b">$mount</code>行将应用程序附加到我们想要的任何元素上。在这里传递<code class="fe li lj lk ll b">#app</code>意味着它将附加到id为<code class="fe li lj lk ll b">app</code>的元素。</p><p id="8752" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">那是主文件。令人兴奋的东西。你还可以做更多的事情，但现在这并不重要。真正的乐趣在别处等着我们。</p><p id="4f1d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">Vue组件的解剖</strong></p><p id="3238" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">看一看<code class="fe li lj lk ll b">App</code>。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/03ef571cdd745823ccdd23b336fb2830.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*sc6ZqL5cqB72Ep_5fjtu9g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">src/App.vue</figcaption></figure><p id="43f5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在本教程的开始，我说过你应该在遵循本指南之前有一些前端知识。如果你听了我的建议，那么这个东西可能看起来很熟悉。</p><p id="c48c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">一个Vue组件由三个标签组成:<code class="fe li lj lk ll b">template</code>、<code class="fe li lj lk ll b">script</code>、&amp;、<code class="fe li lj lk ll b">style</code>。这三个标签表示组件的不同方面。模板是它的HTML，脚本是附带的JavaScript &amp;风格是它的CSS代码。</p><p id="56ed" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在<code class="fe li lj lk ll b">script</code>标签之间，您必须导出一个对象。Vue读取该对象，并提供关于该组件的一些细节。现在我们只是给它一个名字，但是很快我们就会看到如何使用方法、道具&amp;生命周期挂钩。</p><p id="56ca" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir"> Firebase集成</strong></p><p id="0dba" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">为了让我们的井字游戏多人化，我们需要集成Firebase。现在这样做是值得的，这样我们就可以在需要的时候使用Firebase API，而不是在所有游戏代码完成后再对其进行改造。</p><p id="1104" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Firebase是一个web应用平台，提供托管、数据存储和认证等服务。我们将使用实时数据库服务来处理关于活跃的游戏和我们的游戏板的存储信息。由于是实时的，所有连接的玩家将能够看到游戏板的变化。</p><p id="dbd2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">创建Firebase项目</em></p><p id="a4f5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">你需要一个谷歌账户。点击<a class="ae kc" href="https://console.firebase.google.com/u/0/" rel="noopener ugc nofollow" target="_blank">此处</a>登录或注册。</p><p id="213c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">您应该会看到一个<code class="fe li lj lk ll b">Add Project</code>按钮；点击这个按钮，给你的项目起一个你喜欢的名字。下一个屏幕询问有关分析的问题—您不必为此项目启用该功能，但即使启用也没关系。</p><p id="08bb" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">获取项目配置</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/3eb266b74b8678613d6db4d2256f7145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suvQabr9HDEEsQiFX0igTg.png"/></div></div></figure><p id="6d41" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">您应该能够在项目的主屏幕上看到上面的内容。如果你不能，那么回到firebase控制台的主页，点击你的项目名称。完成后，选择<code class="fe li lj lk ll b">&lt;/&gt;</code>图标并命名您的应用程序。我把我的名字叫做<code class="fe li lj lk ll b">tic-tac-toe</code>。启用Firebase托管并注册应用程序。之后你可以点击<code class="fe li lj lk ll b">next</code>直到窗口消失。</p><p id="4b69" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在，我们可以检索我们的应用程序的配置，因为它是创建的。这是一个JSON对象，包含关于程序的信息。我们将用它来连接我们的数据库。你可以通过点击<code class="fe li lj lk ll b">Project Overview</code>右边的cog图标，然后项目设置，然后向下滚动<code class="fe li lj lk ll b">General</code>标签直到你看到<code class="fe li lj lk ll b">Firebase SDK Snippet</code>，然后点击<code class="fe li lj lk ll b">Config</code>来获得配置。复制该对象，它看起来像这样:</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="2e42" class="lu lv iq ll b gy lw lx l ly lz">const firebaseConfig = {<br/>  apiKey: "---",<br/>  authDomain: "---",<br/>  databaseURL: "<a class="ae kc" href="https://tic-tac-toe-vue-3a0b1.firebaseio.com" rel="noopener ugc nofollow" target="_blank">-</a>--",<br/>  projectId: "---",<br/>  storageBucket: "---",<br/>  messagingSenderId: "---",<br/>  appId: "---"<br/>};</span></pre><p id="9bfc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">将其粘贴到Vue项目的<code class="fe li lj lk ll b">src</code>文件夹中的一个新文件<code class="fe li lj lk ll b">firebase.config.js</code>中。把它也加入到你的<code class="fe li lj lk ll b">gitignore</code>中，因为你不想犯这个错误。</p><p id="a900" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后导出，像:<code class="fe li lj lk ll b">export default firebaseConfig;</code>。</p><p id="c851" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">安装燃烧底座</em></p><p id="189c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">您需要安装firebase-tools包来初始化和部署您的项目。在您的终端中运行<code class="fe li lj lk ll b">npm i -g firebase-tools</code>。这使您可以全局访问<code class="fe li lj lk ll b">firebase</code>命令。</p><p id="9b4f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在运行<code class="fe li lj lk ll b">firebase init</code>，并选择以下选项。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/def081640f331a41644b70d88ac394aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCgP2DbT8ljm9RX3sh0KTQ.png"/></div></div></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/731c3af53f1da733cdb418fdc6177eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLFjcqB0vaHpgjfxDRDDeg.png"/></div></div></figure><p id="c284" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">从列表中选择您的项目。这是<strong class="kj ir">不是</strong>你的app。这是您从firebase主屏幕创建的原始项目。我的叫做<code class="fe li lj lk ll b">tic-tac-toe-vue</code>。</p><p id="d738" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">保留数据库规则文件的默认值。</p><p id="4a6b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">你的公共目录应该是<code class="fe li lj lk ll b">dist</code>，<strong class="kj ir">而不是</strong> <code class="fe li lj lk ll b">public</code>。</p><p id="8a67" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">说<code class="fe li lj lk ll b">yes</code>重写所有到index.html的URL(这意味着我们的应用程序可以是单页应用程序)。</p><p id="8715" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">不要覆盖<code class="fe li lj lk ll b">index.html</code>，你不必这样做。</p><p id="c41e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在代码中初始化火焰基地</p><p id="8682" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Firebase需要在代码中设置才能运行。我通常通过创建一个我在<code class="fe li lj lk ll b">main.js</code>中调用的文件来做这件事，尽管实际上你可以直接在那里写代码，如果你愿意的话。</p><p id="fb3a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">首先，将firebase安装到项目的本地依赖项中。</p><p id="e020" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe li lj lk ll b">npm i firebase</code></p><p id="1072" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后在您的<code class="fe li lj lk ll b">src/</code>文件夹中创建一个名为<code class="fe li lj lk ll b">firebase.setup.js</code>的文件，并添加以下代码:</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="2f89" class="lu lv iq ll b gy lw lx l ly lz">import { initializeApp } from 'firebase';<br/>import firebaseConfig from './firebase.config';</span><span id="c682" class="lu lv iq ll b gy ma lx l ly lz">const app = initializeApp(firebaseConfig);</span><span id="61bd" class="lu lv iq ll b gy ma lx l ly lz">export default app;</span></pre><p id="40a4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这在我们的项目中建立了firebase，并允许我们访问它的api方法，比如与数据库对话的方法。</p><p id="6bb4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">最后，只需在<code class="fe li lj lk ll b">src/main.js</code>中导入您的设置文件。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="a4df" class="lu lv iq ll b gy lw lx l ly lz">import './firebase.setup';</span></pre><p id="fe36" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">登录组件</strong></p><p id="3da2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在接下来的几节中，我将提供组件的完整代码作为要点，然后依次解释每个部分:模板、脚本和样式。所有组件都将存储在<code class="fe li lj lk ll b">src/components</code>中，App除外，它将留在原处。没人愿意和App混在一起。</p><p id="f62a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们将首先看一下登录组件。</p><p id="c0a2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">登录组件实际上并不做任何特殊的事情。我们只是让用户输入一个名字，然后点击一个按钮登录。然后，该名称作为“用户”存储在数据库中，如果再次输入该名称，将会检索到该名称。没有密码什么的。去他妈的保安。这是代码。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">src/components/Login.vue</figcaption></figure><p id="30ba" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">模板</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/95971294b944128429f23b0d4ed9bf52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/0*iqIuCWe4s1cr-rsI.png"/></div></figure><p id="3698" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">首先，我们有封闭的模板标签，这在任何Vue组件中都是必要的。就像在React中一样，我们也需要一个单一的父元素，所以这就是<code class="fe li lj lk ll b">div</code>的用途。那我们就有两样没见过的东西了。</p><p id="06e4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">第一个是<code class="fe li lj lk ll b">v-model</code>指令。这就是将值绑定到输入元素的方式。我们在这里引用的<code class="fe li lj lk ll b">username</code>实际上是登录组件状态中的一个属性。每当我们向输入中输入数据时，该属性都会更新以反映这些更改。这就是<code class="fe li lj lk ll b">v-model</code>所做的一切。这就像React中的<code class="fe li lj lk ll b">value</code>和<code class="fe li lj lk ll b">onChange</code>属性生了一个宝宝，那个宝宝长成了瑞安·雷诺兹(性感又酷)。</p><p id="8c92" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">第二个是<code class="fe li lj lk ll b">v-on:click</code>。这就是添加一个点击处理程序的方法，并且<code class="fe li lj lk ll b">login</code>引用了登录组件上的一个函数，每当点击按钮时都应该调用这个函数。</p><p id="141f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">脚本</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/fa26830946e90ef0cb68e6925a61782d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/0*WF-oEFW05Iv6ssKz.png"/></div></figure><p id="44a6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这是所有Vue组件必须导出的对象。它为我们的组件起了一个名字，一个定义组件状态的<code class="fe li lj lk ll b">data</code>函数(在这种情况下我们只有一个字段:<code class="fe li lj lk ll b">username</code>)和一个<code class="fe li lj lk ll b">methods</code>对象，它包含一组我们可以从模板中引用的函数。这里我们有附加到上面点击处理程序的<code class="fe li lj lk ll b">login</code>函数。这个函数检查<code class="fe li lj lk ll b">username</code>状态字段是否不为空，如果是，它发出一个名为‘log in’的事件并传递用户名字段。像这样的事件是一种将数据传递给父组件的方式，就像React中的处理函数一样。我们将在<code class="fe li lj lk ll b">App</code>中拦截此事件，并在事件发生时采取措施。我们将在最后看一看App，看看一切是如何组合在一起的。</p><p id="df57" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">选择游戏组件</strong></p><p id="84a7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">是将处理…选择游戏的组件。真的吗？你需要被告知这些吗？这是代码。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">src/components/SelectGame.vue</figcaption></figure><p id="ff2a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">模板</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/ad103ba1205f9bb18e3b88cc090cb972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MFwv6S7TNYybq2Uk.png"/></div></div></figure><p id="8add" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这里没有什么新东西。该模板呈现两个部分；一个具有用于创建新游戏的输入和按钮；另一个具有输入和用于加入现有游戏的按钮。</p><p id="d84c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果您查看每个按钮，您将能够看到如何以内联方式触发事件。您不需要<em class="ki">在组件中创建处理程序。</em></p><p id="2a28" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">脚本</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/caac90f633e157b1c25160262770aa38.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/0*1FBXibDhlA5I63hv.png"/></div></figure><p id="2917" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这里没什么事情。我们定义了两个状态字段来管理我们的输入框。</p><p id="0433" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">风格</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/47345b544ebdd29c2e95932e24edcca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/0*vb6PbMRZDZ92oYUq.png"/></div></figure><p id="0380" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这不过是基本的CSS。然而，我确实想指出<code class="fe li lj lk ll b">style</code>标签上的<code class="fe li lj lk ll b">scoped</code>属性。这意味着该组件内部的样式将<strong class="kj ir">仅</strong>应用于该组件内部。所以不需要用选择器什么的。你可以只设计标签的样式。哇哦。</p><p id="2ce9" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">游戏板组件</strong></p><p id="dcb1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这是我们在使用App之前需要了解的最后一个组件。它比其他的要大一些，但是展示了Vue的许多重要方面。它基于以下数据结构呈现一个板。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="a98f" class="lu lv iq ll b gy lw lx l ly lz">[<br/>  {<br/>    id: 'top-row',<br/>    tiles: [<br/>      { value: '', pos: '0,0' },<br/>      { value: '', pos: '1,0' },<br/>      { value: '', pos: '2,0' }<br/>    ]<br/>  },<br/>  {<br/>    id: 'middle-row',<br/>    tiles: [<br/>      { value: '', pos: '0,1' },<br/>      { value: '', pos: '1,1' },<br/>      { value: '', pos: '2,1' }<br/>    ]<br/>  },<br/>  {<br/>    id: 'bottom-row',<br/>    tiles: [<br/>      { value: '', pos: '0,2' },<br/>      { value: '', pos: '1,2' },<br/>      { value: '', pos: '2,2' }<br/>    ]<br/>  }<br/>];</span></pre><p id="d17f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">数组中的每个对象代表一行，每个<code class="fe li lj lk ll b">tiles</code>数组中的每个对象代表我们井字游戏棋盘上的一个单幅图块。<code class="fe li lj lk ll b">value</code>字段包含哪个单元占用该图块(x或o),<code class="fe li lj lk ll b">pos</code>字段是每个图块的唯一标识符。</p><p id="8605" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这是组件本身的代码。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="bb08" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">模板</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/0656319b0bee7309aefd27697700fcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kgS-X-P94zJv9RM7.png"/></div></div></figure><p id="fc61" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">该模板由两部分组成。第一部分简单地呈现了<code class="fe li lj lk ll b">gameId</code>，它在<code class="fe li lj lk ll b">SelectGame</code>组件中用于加入一个现有的游戏。第二部分稍微复杂一点。</p><p id="8a8b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">第7行第一个不熟悉的东西是一个<code class="fe li lj lk ll b">v-if</code>指令。这个指令可以放在任何元素上来控制它的可见性。本质上，如果引用的<code class="fe li lj lk ll b">game</code>状态字段还没有定义，那么这个部分就不会被呈现。</p><p id="7346" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">下一行8使用了一个<code class="fe li lj lk ll b">v-for</code>指令。这会根据传递给它的表达式创建一个元素列表。这里，我们说<code class="fe li lj lk ll b">row in game.board</code>，这意味着对于<code class="fe li lj lk ll b">game.board</code>数组中的每个元素，我们将创建一个div及其所有子元素。对于每次迭代，数据都存储在临时变量<code class="fe li lj lk ll b">row</code>中，然后我们可以在div中的任何地方访问它。你可以看到我们在<code class="fe li lj lk ll b">div.tile</code>中使用它。我们必须使用<code class="fe li lj lk ll b">:key</code>来帮助Vue在内部跟踪我们的元素列表。就跟React列表里的<code class="fe li lj lk ll b">key</code>道具一样。</p><p id="8879" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们在第13行也有一个click处理程序，用于在每次单击时编辑图块的<code class="fe li lj lk ll b">value</code>。</p><p id="2ff1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">尽管这段代码可能有点令人困惑(也可能不是)，但它只是简单地遍历了上面数据结构的每一行，并为其创建了一个div。然后，对于每一行，它循环遍历每个图块并为其创建一个div。然后我们的<code class="fe li lj lk ll b">style</code>块使它看起来像一块板。</p><p id="3048" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">脚本</em></p><p id="8cc6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我将一点一点地提取脚本标签，因为它非常大。第一行从<code class="fe li lj lk ll b">firebase</code>导入<code class="fe li lj lk ll b">database</code>。因为我们已经初始化了我们的应用程序，我们可以使用这个函数直接写入实时数据库。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="b554" class="lu lv iq ll b gy lw lx l ly lz">import { database } from "firebase";</span></pre><p id="fa50" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">下一部分是我们定义一些道具的地方。这些就像react中的道具:我们可以从上面传递给组件的数据。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="4581" class="lu lv iq ll b gy lw lx l ly lz">props: ["gameId", "user"]</span></pre><p id="54ec" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后我们定义我们的<code class="fe li lj lk ll b">game</code>状态字段，并将其初始化为<code class="fe li lj lk ll b">null</code>。这将在我们从数据库中检索游戏时进行设置。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="5622" class="lu lv iq ll b gy lw lx l ly lz">data: () =&gt; ({<br/>  game: null<br/>}),</span></pre><p id="706c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后我们有我们的方法块，在这里我们定义了一个单独的<code class="fe li lj lk ll b">updateTile</code>方法。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/6f8f300c8da2a8ee868b43d8a172e0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KqruICU8HB7WzSHd.png"/></div></div></figure><p id="543b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这个函数没有做任何事情，所以我将简单解释一下。</p><p id="e355" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在第33行，我们使用object spread创建了一个<code class="fe li lj lk ll b">game</code>状态字段的副本。</p><p id="846b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后，我们根据从模板传来的参数找到要更新的正确的行和块，并将其值设置为等于我们的玩家正在玩的<code class="fe li lj lk ll b">unit</code>(x或o)。</p><p id="d593" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">最后，我们调用我们的数据库方法。这里的<code class="fe li lj lk ll b">ref</code>对应于实时数据库中的一个路径。在这种情况下，我们在数据库的顶层有一个名为<code class="fe li lj lk ll b">games</code>的对象，该对象上的每个键都是一个<code class="fe li lj lk ll b">gameId</code>。这就是我们存储数据的方式(当我们查看应用程序组件时，您会看到这一点)。所以我们在这里所做的就是告诉firebase进入数据库中的<code class="fe li lj lk ll b">games</code>对象，用我们的id ( <code class="fe li lj lk ll b">gameId</code>)找到游戏，并为它设置新的值，它包含了我们更新的游戏板。</p><p id="7c85" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">最后一部分是<code class="fe li lj lk ll b">created</code>方法。这是一个Vue生命周期挂钩。它在注射后立即运行。你想把它用于api调用之类的东西。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/e35a83340c94cee390285898a0f7153f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/0*bLFn4fcpHeKEfA_b.png"/></div></figure><p id="f51a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在第47行，我们使用与上面相同的ref联系我们的数据库。不过，这次我们不会添加任何东西。相反，我们正在建立一种网络套接字。我们告诉firebase，无论何时产生<code class="fe li lj lk ll b">value</code>事件(当数据改变时会发生这种情况)，我们都希望调用回调:</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="0334" class="lu lv iq ll b gy lw lx l ly lz">snapshot =&gt; {<br/>  this.game = snapshot.val();</span><span id="285b" class="lu lv iq ll b gy ma lx l ly lz">  if (this.game.creator === this.user.name) {<br/>    this.unit = "x";<br/>  } else {<br/>    this.unit = "o";<br/>  }<br/>}</span></pre><p id="fbb7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这将我们的<code class="fe li lj lk ll b">game</code> state字段设置为调用回调(<code class="fe li lj lk ll b">snapshot.val()</code>)时存储在数据库中的值，并计算出我们应该是什么单元。如果我们创造了游戏，那么我们就是<code class="fe li lj lk ll b">x</code>。记住，每次我们的<em class="ki"> </em> <code class="fe li lj lk ll b">/game/${gameId}</code>数据库对象改变时，这个回调就会被调用<em class="ki">，所以这就是我们如何获得实时更新的。</em></p><p id="4566" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">风格</em></p><p id="424f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">同样，这只是CSS使我们的板看起来像一个板，所以我不会粘贴在这里。应该在上面的主旨里。</p><p id="605b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">App组件</strong></p><p id="91e1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这是最大的组成部分，把一切都集合在一起。大多数数据库操作都在这里完成，这里是我们呈现所有定制组件的地方。这是代码。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9bc6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">模板</em></p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/17490307fe6309a95b16d0a18408e22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-fM2qDe4wrvvosF6.png"/></div></div></figure><p id="e8b2" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在第4行，如果<code class="fe li lj lk ll b">user</code>状态字段未定义，我们将呈现<code class="fe li lj lk ll b">Login</code>组件。我们还拦截上面看到的<code class="fe li lj lk ll b">login</code>事件，当我们捕捉到它时，我们调用<code class="fe li lj lk ll b">login</code>处理函数，它是在我们的<code class="fe li lj lk ll b">methods</code>块中定义的。</p><p id="bc77" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在第5行，如果定义了用户，我们将呈现<code class="fe li lj lk ll b">SelectGame</code>组件。我们也拦截<code class="fe li lj lk ll b">create-game</code>和<code class="fe li lj lk ll b">join-game</code>。</p><p id="d1c5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在第7行，我们呈现了<code class="fe li lj lk ll b">Gameboard</code>组件。我们只有在定义了<code class="fe li lj lk ll b">activeGame</code>的情况下才这样做。我们还通过<code class="fe li lj lk ll b">user</code>和<code class="fe li lj lk ll b">gameId</code>道具。冒号是用于将数据绑定到组件的<code class="fe li lj lk ll b">v-bind</code>指令的简写。所以在这种情况下，我们将我们的<code class="fe li lj lk ll b">gameId</code>和<code class="fe li lj lk ll b">user</code>字段绑定到组件，组件将在这些值改变时做出响应。</p><p id="bc3c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><em class="ki">剧本</em></p><p id="0ddd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我会一点一点地接受这一点，就像以前一样。我们首先从firebase导入数据库。我们还导入了所有的组件，即<code class="fe li lj lk ll b">board.js</code>文件(我马上会展示它；它只包含我们上面看到的数据结构)和用于生成游戏id的<code class="fe li lj lk ll b">uuid</code>包。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="a281" class="lu lv iq ll b gy lw lx l ly lz">import { database } from "firebase";<br/>import uuid from "uuid";<br/>import board from "./board";<br/>import Gameboard from "./components/Gameboard";<br/>import Login from "./components/Login";<br/>import SelectGame from "./components/SelectGame";</span></pre><p id="4fab" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后我们导出组件并给它一个名字。我们还定义了<code class="fe li lj lk ll b">components</code>对象，这是告诉Vue您将在模板中使用定制组件的方式。您打算使用的所有定制组件都必须在那里。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="f25d" class="lu lv iq ll b gy lw lx l ly lz">export default {<br/>  name: "app",<br/>  components: { Gameboard, Login, SelectGame }</span></pre><p id="407e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们添加了状态字段<code class="fe li lj lk ll b">user</code>、<code class="fe li lj lk ll b">allUsers</code>和<code class="fe li lj lk ll b">activeGame</code>，它们分别表示当前登录的用户、数据库中的所有用户以及活动游戏的id。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="0748" class="lu lv iq ll b gy lw lx l ly lz">data: () =&gt; ({<br/>  user: null,<br/>  allUsers: [],<br/>  activeGame: null,<br/>}),</span></pre><p id="fc44" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后我们有了<code class="fe li lj lk ll b">methods</code>块。这包含三个方法，所以我们将依次查看每个方法。</p><ul class=""><li id="c147" class="mr ms iq kj b kk kl ko kp lf mt lg mu lh mv le mw mx my mz bi translated">添加用户</li></ul><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/5c2f9f9e89fa16f188799c1f7aef3e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2h_Ob9d3Bq1z4zLX.png"/></div></div></figure><p id="0545" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当从<code class="fe li lj lk ll b">Login</code>组件触发<code class="fe li lj lk ll b">login</code>事件时调用该方法，它负责从<code class="fe li lj lk ll b">allUsers</code>检索正确的用户(如果该用户存在)或创建一个新用户。</p><p id="e6a8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在第30行，它试图从<code class="fe li lj lk ll b">allUsers</code>中找到用户——一个已经在<code class="fe li lj lk ll b">created</code>lifecycle方法中填充的列表，我们马上就会看到——如果它找到了用户，那么它就更新状态(第33行)并从函数中中断。</p><p id="4ded" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果没有找到用户，它将创建一个空的用户对象，然后更新数据库。ref <code class="fe li lj lk ll b">users</code>指向数据库中的整个用户集合，所以我们本质上是获取它，将新用户推入其中，然后覆盖它。最后，我们将<code class="fe li lj lk ll b">user</code>状态字段设置为新用户。</p><ul class=""><li id="11ce" class="mr ms iq kj b kk kl ko kp lf mt lg mu lh mv le mw mx my mz bi translated">创建游戏</li></ul><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/b82f125b399fcafcb58dd81260d8ae12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cA6_4jPoabvqsrZw.png"/></div></div></figure><p id="3a73" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当<code class="fe li lj lk ll b">SelectGame</code>组件触发一个<code class="fe li lj lk ll b">create-game</code>事件并简单地向数据库添加一个游戏，然后设置<code class="fe li lj lk ll b">activeGame</code>字段时，这个函数被调用。传递给<code class="fe li lj lk ll b">newGame</code>的<code class="fe li lj lk ll b">board</code>属性包含了我们之前看到的棋盘数据结构，这样当我们开始玩游戏时就可以使用了。文件存储在<code class="fe li lj lk ll b">src/board.js</code>中。</p><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="3346" class="lu lv iq ll b gy lw lx l ly lz">export default [<br/>  {<br/>    id: 'top-row',<br/>    tiles: [<br/>      { value: '', pos: '0,0' },<br/>      { value: '', pos: '1,0' },<br/>      { value: '', pos: '2,0' }<br/>    ]<br/>  },<br/>  {<br/>    id: 'middle-row',<br/>    tiles: [<br/>      { value: '', pos: '0,1' },<br/>      { value: '', pos: '1,1' },<br/>      { value: '', pos: '2,1' }<br/>    ]<br/>  },<br/>  {<br/>    id: 'bottom-row',<br/>    tiles: [<br/>      { value: '', pos: '0,2' },<br/>      { value: '', pos: '1,2' },<br/>      { value: '', pos: '2,2' }<br/>    ]<br/>  }<br/>];</span></pre><ul class=""><li id="0513" class="mr ms iq kj b kk kl ko kp lf mt lg mu lh mv le mw mx my mz bi translated">加入游戏</li></ul><pre class="lm ln lo lp gt lq ll lr ls aw lt bi"><span id="3a51" class="lu lv iq ll b gy lw lx l ly lz">joinGame(id) {<br/>  this.activeGame = id;<br/>}</span></pre><p id="1043" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当<code class="fe li lj lk ll b">join-game</code>事件被触发时，从<code class="fe li lj lk ll b">SelectGame</code>调用该函数。我们要求用户自己提供id(他们的朋友应该已经发送给他们了)，所以除了设置<code class="fe li lj lk ll b">activeGame</code> state字段之外，我们不需要做任何特殊的事情。这将使<code class="fe li lj lk ll b">Gameboard</code>组件出现，这将触发它使用id从数据库中检索正确的游戏。</p><p id="822b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">最后一部分是<code class="fe li lj lk ll b">created</code>生命周期挂钩。看起来是这样的。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/ee9fc91d085901cd44919b5d3286003a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/0*2pY6sVLtVhXXKona.png"/></div></figure><p id="b7ec" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这只是告诉firebase每当数据库中的<code class="fe li lj lk ll b">users</code>集合发生变化时更新<code class="fe li lj lk ll b">allUsers</code>状态字段。这就是为什么<code class="fe li lj lk ll b">App</code>组件总是能够访问最新的用户列表。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="553f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">就这些了。我故意选择了一个相当复杂的任务，因为我想展示Vue简化事情的方式。<code class="fe li lj lk ll b">v-if</code>和<code class="fe li lj lk ll b">v-for</code>指令简单明了，代码可读性很强。组件的简单结构也是一个巨大的好处，它将不同的方面分开(模板、脚本&amp;风格),但也足够接近，以便在你的大脑中建立逻辑和简单的联系，如果你像我一样拥有糊状香蕉的智力，这是非常好的。我希望这是有帮助的，我希望它能激励你更多地了解Vue。谢了。</p></div></div>    
</body>
</html>