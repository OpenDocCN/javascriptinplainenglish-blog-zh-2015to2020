<html>
<head>
<title>JavaScript ES6 Classes Explained With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用例子解释JavaScript ES6类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-es6-classes-explained-with-examples-8d3d6b5717ad?source=collection_archive---------0-----------------------#2020-12-25">https://javascript.plainenglish.io/javascript-es6-classes-explained-with-examples-8d3d6b5717ad?source=collection_archive---------0-----------------------#2020-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="107c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过实例了解JavaScript中的ES6类</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8bd4b86b6554cc2558536a723b05727d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N1AYUqLzBjDFbddJ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jstrippa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d7f1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="5227" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">ES6类是用于创建JavaScript对象的模板。他们用代码封装数据来处理这些数据。然而，JavaScript类只不过是现有的基于原型的继承和构造函数的语法糖衣。</p><p id="59b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我们将通过一些实际例子来学习JavaScript中的ES6类。让我们开始吧。</p><h1 id="54da" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">类别语法</h1><p id="82ca" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了创建一个JavaScript类，我们声明了关键字<code class="fe mp mq mr ms b">class</code>,其中包含了方法<code class="fe mp mq mr ms b">constructor</code>。当关键字<code class="fe mp mq mr ms b"><strong class="lq ir">new</strong></code>被调用来创建一个新对象时，这个构造函数方法被调用。</p><p id="5516" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="4521" class="mx kx iq ms b gy my mz l na nb"><strong class="ms ir">class</strong> UserInfo {<br/>  <strong class="ms ir">constructor</strong>(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>}</span><span id="f36f" class="mx kx iq ms b gy nc mz l na nb">const newUser = <strong class="ms ir">new</strong> UserInfo("Mehdi", 19);</span></pre><p id="245b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，我们用构造函数定义了一个类<code class="fe mp mq mr ms b">UserInfo</code>。然后我们使用关键字<code class="fe mp mq mr ms b">new</code>调用构造函数来创建我们的对象<code class="fe mp mq mr ms b">newUser</code>。</p><p id="d72a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意，按照惯例，应该对ES6类名使用UpperCamelCase，就像上面使用的<code class="fe mp mq mr ms b">UserInfo</code>一样。</p><h1 id="417c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">向类中添加方法</h1><p id="995e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">创建类方法的语法与创建对象方法的语法相同。您可以向您的类中添加任意数量的方法。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8519" class="mx kx iq ms b gy my mz l na nb">class ClassName {<br/>  constructor() { ... }<br/>  method_1() { ... }<br/>  method_2() { ... }<br/>  method_3() { ... }<br/>  }<br/>}</span></pre><p id="cf63" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是一个例子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="1544" class="mx kx iq ms b gy my mz l na nb">class UserInfo {<br/>  constructor(name, age) {<br/>    this.name = name;<br/>    this.age = age;<br/>  }<br/>  <br/>  <strong class="ms ir">fullName()</strong>{<br/>    return this.name + ' Aoussiad';<br/>  }</span><span id="512d" class="mx kx iq ms b gy nc mz l na nb">}<br/>const newUser = new UserInfo("Mehdi", 19);</span><span id="5106" class="mx kx iq ms b gy nc mz l na nb">// We can access the method fullName as we do with objects.<br/>console.log(<strong class="ms ir">newUser.fullName()</strong>);    // Mehdi Aoussiad</span></pre><p id="258d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">用关键字<code class="fe mp mq mr ms b">new</code>创建对象后，你可以像我们处理对象一样访问你的方法。如果需要，还可以向类方法发送参数。</p><h1 id="b0bc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">静态方法</h1><p id="a19a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">静态方法是在类中定义的函数，无需创建该类的新对象就可以访问它。因为静态方法是在类级别定义的，所以您可以使用类名直接调用它们。</p><p id="b370" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在JavaScript中，必须使用<code class="fe mp mq mr ms b">static</code>关键字来定义静态方法:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="704d" class="mx kx iq ms b gy my mz l na nb"><strong class="ms ir">class</strong> UserInfo {<br/>  constructor(speed, age) {<br/>    this.speed = speed;<br/>    this.age = age;<br/>  }<br/>  <br/>  <strong class="ms ir">static</strong> information(info){<br/>    <strong class="ms ir">return new UserInfo(info, info);</strong><br/>  }</span><span id="d476" class="mx kx iq ms b gy nc mz l na nb">}<br/>const information = UserInfo.<strong class="ms ir">information(20)</strong>;<br/>information.speed; // 20<br/>information.age; // 20</span></pre><h1 id="1479" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">类继承</h1><p id="759b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">用类继承创建的类继承了另一个类的所有方法。要创建一个类继承，使用<code class="fe mp mq mr ms b"><strong class="lq ir">extends</strong></code>关键字。</p><p id="bcae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看看下面的例子，我们将创建一个名为“Model”的类，它将继承“Car”类的方法。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="95fe" class="mx kx iq ms b gy my mz l na nb"><strong class="ms ir">class</strong> Car {<br/>  constructor(brand) {<br/>    this.carname = brand;<br/>  }<br/>  present() {<br/>    return 'I have a ' + this.carname;<br/>  }<br/>}<br/><br/><strong class="ms ir">class</strong> Model <strong class="ms ir">extends</strong> Car {<br/>  constructor(brand, mod) {<br/>    <strong class="ms ir">super</strong>(brand);<br/>    this.model = mod;<br/>  }<br/>  show() {<br/>    return this.present() + ', it is a ' + this.model;<br/>  }<br/>}<br/><br/>let myCar = new Model("Ford", "Mustang");</span></pre><p id="3b57" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，关键字<code class="fe mp mq mr ms b">extends</code>用于确保我们想要继承父类的属性和方法。方法<code class="fe mp mq mr ms b"><strong class="lq ir">super()</strong></code> <strong class="lq ir"> </strong>引用父类。通过调用它，我们可以访问car类(父类)的所有属性和方法。</p><h1 id="de2d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">分级提升</h1><p id="7d1c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript中的类是不提升的，这意味着你不能在声明一个类之前使用它。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="decb" class="mx kx iq ms b gy my mz l na nb">//You cannot use the class yet.<br/>//myCar = new Car("Ford")<br/>//This would raise an error.<br/><br/>class Car {<br/>  constructor(brand) {<br/>    this.carname = brand;<br/>  }<br/>}<br/><br/>//Now you can use the class:<br/>let myCar = new Car("Ford")</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="b7e3" class="kw kx iq bd ky kz nk lb lc ld nl lf lg jw nm jx li jz nn ka lk kc no kd lm ln bi translated">结论</h1><p id="5e19" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如您所见，JavaScript中的ES6类对于可读性和可重用性非常有用和重要。它们提供了用构造函数编写对象的语法糖。比起使用ES5构造函数，我更喜欢类。</p><p id="15af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您阅读本文，希望您觉得有用。如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">订阅我们的YouTube频道</strong> </a> <strong class="lq ir">获取更多类似内容！</strong></p><h1 id="104b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">进一步阅读</h1><div class="np nq gp gr nr ns"><a href="https://medium.com/javascript-in-plain-english/javascript-es6-modules-explained-with-examples-3a85e693d56e" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">JavaScript ES6模块举例说明</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">通过实例了解JavaScript中的ES6模块</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kp ns"/></div></div></a></div></div></div>    
</body>
</html>