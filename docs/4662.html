<html>
<head>
<title>JavaScript Utility Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript实用程序库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-utility-libraries-d9aad9ea2401?source=collection_archive---------4-----------------------#2020-12-29">https://javascript.plainenglish.io/javascript-utility-libraries-d9aad9ea2401?source=collection_archive---------4-----------------------#2020-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bf5904525d4032e5d99894db6c6d75ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOsXG6nA9gUmn9qDfuBLyg.png"/></div></div></figure><h1 id="0364" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">JS、Ramda和Lodash的比较</h1><p id="f22f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有了<a class="ae lu" href="https://tc39.es/ecma262/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> ECMAScript 2020 </em> </a>可用，函数式编程(FP)就不需要外部库了——特别是currying和composition。这类工作的两个主要库是<a class="ae lu" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>和<a class="ae lu" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank"> Lodash FP </a>。UnderscoreJS 是另一个，但是Lodash通常被认为是对这个库的改进。Lodash是下划线的一个分支，它为什么分支的<a class="ae lu" href="https://stackoverflow.com/a/13898916" rel="noopener ugc nofollow" target="_blank">历史相当有趣。</a></p><p id="789f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">然而，对于更复杂的FP情况，使用这些久经考验的库仍然是一个好主意。如果没有利用这些复杂的场景，普通的JavaScript在很大程度上可以跟上实用程序库。一些值得注意的例外是来自<a class="ae lu" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>的<code class="fe mb mc md me b">debounce</code>和来自Ramda的<code class="fe mb mc md me b">merge</code>。</p><p id="397c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">重申一下，导致使用Ramda和Lodash的许多好处已经融入到普通JavaScript中。箭头函数允许一个currying版本，与链接函数一起，可以充分地组合函数。类似地，每个版本都添加了原型方法，这使得Lodash越来越没用了。</p><p id="4991" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><em class="lv">注意</em>:箭头函数不允许<em class="lv">实际的</em>(即<code class="fe mb mc md me b">(a, b) =&gt; {}</code>与<code class="fe mb mc md me b">a =&gt; b =&gt; {}</code>相同，即函数本身跟踪它定义了多少个参数)，非常接近。</p><p id="4e93" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">本文将:</p><ul class=""><li id="d969" class="mf mg iq ky b kz lw ld lx lh mh ll mi lp mj lt mk ml mm mn bi translated">简要概述Ramda和Lodash (FP)</li><li id="794e" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">请注意投资图书馆是否有意义的案例</li><li id="c15c" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">给出几个突出的方法的上下文</li><li id="61de" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">提供一个表格摘要，说明哪个图书馆在哪些方面更好</li><li id="1063" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">提供一个<a class="ae lu" href="https://repl.it/@irmerk/Comparing-Utility-Libraries" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> REPL </strong> </a>和<a class="ae lu" href="https://github.com/irmerk/javascript-utilities-ramda-lodash" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">库</strong> </a>用于生成基准</li></ul><p id="e19e" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">所有这些都是公开的，这意味着你可以自由地对列表做出贡献和调整</p><h1 id="f1e7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Java Script语言</h1><p id="608b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，在过去几年中，原生JavaScript变得更加强大。虽然助手和实用程序库仍然很有帮助，但是它们中的大部分内容都可以简化为<code class="fe mb mc md me b">filter()</code>、<code class="fe mb mc md me b">map()</code>和<code class="fe mb mc md me b">reduce()</code>的某种组合。</p><p id="fa7e" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我在我的<a class="ae lu" href="https://medium.com/better-programming/modern-javascript-techniques-cf2084236af4" rel="noopener">现代Javascript技术</a>文章中写了更多。</p><h1 id="d9d9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用案例:</h1><ul class=""><li id="0f83" class="mf mg iq ky b kz la ld le lh mt ll mu lp mv lt mk ml mm mn bi translated">所需的功能很简单，只需要很少的步骤或转换</li><li id="c585" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">需要一些额外步骤的复杂功能并不是一个障碍</li><li id="ba01" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">束尺寸很重要</li><li id="fb2f" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">从其他库中学习进入这些简化的助手函数的过程</li></ul><h1 id="25f9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">拉姆达</h1><p id="d5c7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Ramda强调更纯粹的功能风格，不变性和无副作用的功能是设计哲学的核心。Ramda是关于<em class="lv">转换</em>数据和<em class="lv">组成</em>函数。这就是为什么像<code class="fe mb mc md me b">throttle</code>和<code class="fe mb mc md me b">debounce</code>这样的东西不被支持，因为它们涉及副作用。为了以一种纯粹的方式实现这一点，<a class="ae lu" href="https://en.wikipedia.org/wiki/Functional_reactive_programming" rel="noopener ugc nofollow" target="_blank">功能性反应式编程</a>将需要用事件流对此进行抽象。</p><p id="1c97" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Ramda功能是自动执行的。这样就可以通过不提供最终参数来轻松地从旧函数构建新函数。排列Ramda函数的参数是为了方便currying。要操作的数据通常最后提供。这最后两点使得将函数构建为更简单的函数序列变得非常容易，每个函数都转换数据并传递给下一个函数。Ramda被设计成支持这种风格的编码。</p><blockquote class="mw mx my"><p id="96a3" class="kw kx lv ky b kz lw lb lc ld lx lf lg mz ly lj lk na lz ln lo nb ma lr ls lt ij bi translated"><em class="iq"> Ramda提供了几个函数，当应用于不合适的输入时，返回有问题的值，如</em><code class="fe mb mc md me b"><em class="iq">undefined</em></code><em class="iq"/><code class="fe mb mc md me b"><em class="iq">Infinity</em></code><em class="iq">或</em> <code class="fe mb mc md me b"><em class="iq">NaN</em></code> <em class="iq">。这些被称为</em> <a class="ae lu" href="https://en.wikipedia.org/wiki/Partial_function" rel="noopener ugc nofollow" target="_blank"> <em class="iq">部分功能</em> </a> <em class="iq">。部分功能需要使用防护装置或零位检查。</em></p></blockquote><p id="24c6" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">对此的补救办法可能是<a class="ae lu" href="https://sanctuary.js.org/" rel="noopener ugc nofollow" target="_blank"> Sanctuary </a>，一个受<a class="ae lu" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>和<a class="ae lu" href="http://www.purescript.org/" rel="noopener ugc nofollow" target="_blank"> PureScript </a>启发的JavaScript函数式编程库。它比Ramda更严格，并提供了类似的功能套件。</p><h1 id="0a98" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用案例:</h1><ul class=""><li id="8887" class="mf mg iq ky b kz la ld le lh mt ll mu lp mv lt mk ml mm mn bi translated">合成，最后获取数据，始终保持一致</li><li id="86d4" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">特定方法，通常涉及复杂操作，例如<code class="fe mb mc md me b">merge</code>、<code class="fe mb mc md me b">assoc</code>、<code class="fe mb mc md me b">pluck</code>...</li><li id="2df9" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">类似的常用方法在多个地方使用</li><li id="a4c1" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">使用<code class="fe mb mc md me b">R.converge()</code>进行复杂的非线性合成</li></ul><h1 id="2154" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">洛达什</h1><p id="3b54" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里没什么可研究的。Lodash是一个非常高效的实用程序库。虽然包的大小在过去是一个问题，但是Lodash在格式上变得更加模块化。这使得像webpack和parcel这样的构建工具能够进行树抖动并删除任何未使用的函数，从而减小包的大小。</p><p id="c2d2" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">请记住，有许多功能<a class="ae lu" href="https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore" rel="noopener ugc nofollow" target="_blank">可以在本机</a>中完成。</p><p id="7a23" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><em class="lv">注意</em>:虽然Lodash在下面使用<code class="fe mb mc md me b">_.toString()</code>方法的基准测试中出现得更快，但结果实际上与JS和Ramda中的相同函数并不相同。</p><h1 id="ed29" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用案例:</h1><ul class=""><li id="4751" class="mf mg iq ky b kz la ld le lh mt ll mu lp mv lt mk ml mm mn bi translated"><code class="fe mb mc md me b">debounce</code></li><li id="130d" class="mf mg iq ky b kz mo ld mp lh mq ll mr lp ms lt mk ml mm mn bi translated">类似的常用方法在多个地方使用</li></ul><h1 id="e141" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Lodash FP</h1><p id="e6e2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Lodash提供了<code class="fe mb mc md me b">lodash/fp</code>，一个促进更函数式编程风格的模块。这个模块允许Lodash函数的可修改版本。这使得Lodash成为Ramda的良好替代品。</p><h1 id="c358" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用案例:</h1><ul class=""><li id="b8b2" class="mf mg iq ky b kz la ld le lh mt ll mu lp mv lt mk ml mm mn bi translated">合成，最后获取数据，始终保持一致</li></ul></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="6174" class="jy jz iq bd ka kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv bi translated">基准测试结果</h1><p id="726c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请注意，我已经用我和我的团队使用的常用方法开始了这个列表，它绝不是详尽的。请随意查看<a class="ae lu" href="https://github.com/irmerk/javascript-utilities-ramda-lodash" rel="noopener ugc nofollow" target="_blank">库</a>并打开一个pull请求来添加更多的方法或测试。</p><figure class="no np nq nr gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="no np nq nr gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="4521" class="jy jz iq bd ka kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv bi translated">结论</h1><p id="c9ac" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Ramda和Lodash重叠，不应该在同一个项目中使用。根据您正在处理的数据和使用的方法，这些库可能非常有用，也可能没有必要。</p><p id="b420" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">应该采取一种“香草-JavaScript-优先”的方法，这些库不应该被用作数据方法的一揽子方法。一旦你遇到用普通JavaScript很难完成的事情，就切换到这些库中的一个。哪一个？归结为味道。两者的语义风格非常相似。</p><p id="822b" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Ramda通常是函数式编程的一种更好的方法，因为它是为此而设计的，并且有一个在这种意义上建立的社区。</p><p id="0642" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">当需要特定功能时，Lodash通常更好。<code class="fe mb mc md me b">debounce</code>)。</p><p id="9157" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">无论哪种方式，<strong class="ky ir">都要确保投资树抖动</strong>来最小化这些库的包大小，因为很可能你只会使用一些方法，而不需要整个库。</p></div></div>    
</body>
</html>