<html>
<head>
<title>State management with Angular 8 and Akita</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular 8和Akita进行状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/state-management-with-angular-8-and-akita-b842aa22b95e?source=collection_archive---------4-----------------------#2019-09-11">https://javascript.plainenglish.io/state-management-with-angular-8-and-akita-b842aa22b95e?source=collection_archive---------4-----------------------#2019-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/66deee11932250cf0db984b4e427cacf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aD4QJgZMyZ6N7MGo9_kmaA.jpeg"/></div></div></figure><div class=""/><p id="3b75" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">早在2017年我就写过一篇文章，在这里用NgRx<a class="ae kw" href="https://medium.com/front-end-weekly/an-intro-to-ngrx-effects-ngrx-store-with-angular-4-c55c4d1d5baf" rel="noopener"><strong class="ka jc"/></a>构建了一个简单的博客应用。最近，我一直在用<a class="ae kw" href="https://github.com/datorama/akita/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> Akita </strong> </a>做实验，这是一种状态管理模式，我发现它更简单，样板代码更少。所以我决定用Akita重写我的示例应用程序，并希望与您分享代码。</p><p id="ca49" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">后端服务器设置</strong></p><p id="bf39" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们使用<a class="ae kw" href="https://github.com/typicode/json-server" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> json-server </strong> </a>来模拟我们的后端服务器。json-server帮助我们为CRUD操作设置一个本地开发服务器。让我们从安装json-server开始。</p><p id="635c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">npm install -g json-server</code></p><p id="6560" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将创建一个名为db.json的JSON文件，并为博客和作者添加一些示例条目，如下所示。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="fff7" class="lj lk jb la b gy ll lm l ln lo">{<br/>  "blogs": [<br/>    {<br/>      "title": "Blog Title 1",<br/>      "author": "John",<br/>      "id": 1<br/>    },<br/>    {<br/>      "title": "Blog Title 2",<br/>      "author": "Harry",<br/>      "id": 2<br/>    }<br/>  ],<br/>  "authors": [<br/>    {<br/>   "id":1,<br/>      "name": "All"<br/>    },<br/>    {<br/>   "id":2,<br/>      "name": "John"<br/>    },<br/>    {<br/>   "id":3,<br/>      "name": "Harry"<br/>    },<br/>    {<br/>   "id":4,<br/>      "name": "Jane"<br/>    }<br/>  ]<br/>}</span></pre><p id="1590" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过运行命令来启动JSON服务器</p><p id="63e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">json-server --watch db.json</code></p><p id="f618" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在您的计算机端口3000上设置一个本地主机服务器。您应该能够导航到<a class="ae kw" href="http://localhost:3000/authors" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/authors</a>并看到所有的作者。</p><p id="b503" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">博客</strong></p><p id="124b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要从服务器返回一个博客列表。让我们在models文件夹下添加一个新文件blog.ts。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="c4bf" class="lj lk jb la b gy ll lm l ln lo">import { ID } from '@datorama/akita';</span><span id="de60" class="lj lk jb la b gy lp lm l ln lo">export interface Blog {<br/>    id: ID;<br/>    title: string;<br/>    author: string;<br/>}</span></pre><p id="36fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">博客商店</strong></p><p id="3da3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建一个博客存储，这是博客状态将要被存储的地方。在我们的示例应用程序中，我们必须拥有一个博客数组，并使用一个过滤函数根据所选作者过滤博客。这些是我们将在商店中展示的一些状态。可以类似于数据库中的表来查看存储。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="e438" class="lj lk jb la b gy ll lm l ln lo">import { EntityState, EntityStore, StoreConfig } from '@datorama/akita';<br/>import { Blog } from '../models/blog';<br/>import { Injectable } from '@angular/core';</span><span id="6941" class="lj lk jb la b gy lp lm l ln lo">export interface BlogState extends EntityState&lt;Blog&gt; { }</span><span id="edde" class="lj lk jb la b gy lp lm l ln lo">@Injectable({<br/>    providedIn: 'root'<br/>})<br/>@StoreConfig({ name: 'blogs' })<br/>export class BlogStore extends EntityStore&lt;BlogState, Blog&gt; {</span><span id="424d" class="lj lk jb la b gy lp lm l ln lo">}</span></pre><p id="90c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要一个过滤器存储来保存过滤器状态，初始值设置为“All”。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="f16e" class="lj lk jb la b gy ll lm l ln lo">export interface FilterState extends EntityState&lt;string&gt; {<br/>    authorFilter: {<br/>        filter: string;<br/>    };<br/>}</span><span id="7eec" class="lj lk jb la b gy lp lm l ln lo">const initialState = {<br/>    authorFilter: {<br/>        filter: 'All'<br/>    }<br/>};</span><span id="0b3c" class="lj lk jb la b gy lp lm l ln lo">@Injectable({<br/>    providedIn: 'root'<br/>})<br/>@StoreConfig({ name: 'filter' })<br/>export class FilterStore extends EntityStore&lt;FilterState, string&gt; {<br/>    constructor() {<br/>        super(initialState);<br/>    }<br/>}</span></pre><p id="1bce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">博客查询</strong></p><p id="cd97" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要一种从存储中查询实体的机制。Akita docs建议组件不要直接从商店获取数据，而是使用查询。让我们创建一个查询文件，并将其命名为blog-query.ts。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="1c28" class="lj lk jb la b gy ll lm l ln lo">import { QueryEntity } from '@datorama/akita';<br/>import { Injectable } from '@angular/core';<br/>import { BlogState, BlogStore } from '../stores/blog-store';<br/>import { Blog } from '../models/blog';<br/>@Injectable({<br/>    providedIn: 'root'<br/>})<br/>export class BlogQuery extends QueryEntity&lt;BlogState, Blog&gt; {<br/>    constructor(protected store: BlogStore) {<br/>        super(store);<br/>    }<br/>}</span></pre><p id="2efc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">过滤查询</strong></p><p id="7058" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们也创建一个过滤查询，添加一个filter-query.ts文件。getValue()方法返回存储的原始值，在我们的例子中是过滤值。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="375a" class="lj lk jb la b gy ll lm l ln lo">export class FilterQuery extends QueryEntity&lt;FilterState, string&gt; {<br/>    constructor(protected store: FilterStore) {<br/>        super(store);<br/>    }</span><span id="8ca5" class="lj lk jb la b gy lp lm l ln lo">    getFilter() {<br/>        return this.getValue().authorFilter.filter;<br/>    }</span><span id="8df4" class="lj lk jb la b gy lp lm l ln lo">}</span></pre><p id="0192" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">博客服务</strong></p><p id="e69e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Akita建议所有异步调用都应该封装在一个服务中。因此，让我们创建一个博客服务，并将博客存储注入到服务中。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="904b" class="lj lk jb la b gy ll lm l ln lo">import { Injectable } from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/>import { tap } from 'rxjs/operators';<br/>import { Blog } from '../models/blog';<br/>import { BlogStore } from '../stores/blog-store';</span><span id="d3eb" class="lj lk jb la b gy lp lm l ln lo">@Injectable({ providedIn: 'root' })<br/>export class BlogService {</span><span id="806b" class="lj lk jb la b gy lp lm l ln lo">  filter = 'All';<br/>  constructor(private http: HttpClient, private blogStore: BlogStore) {<br/>  }</span><span id="3f87" class="lj lk jb la b gy lp lm l ln lo">  private createBlog({ id, title, author }: Partial&lt;Blog&gt;) {<br/>    return {<br/>      id,<br/>      title, author<br/>    };<br/>  }<br/></span><span id="62fe" class="lj lk jb la b gy lp lm l ln lo">  get() {<br/>    return this.http.get&lt;Blog[]&gt;('http://localhost:3000/blogs').pipe(tap(blogs =&gt; {<br/>      this.blogStore.set(blogs);<br/>    }));<br/>  }<br/></span><span id="5e3d" class="lj lk jb la b gy lp lm l ln lo">  add({ title, author }: Partial&lt;Blog&gt;) {<br/>    const blog = this.createBlog({ id: Math.random(), title, author });<br/>    this.blogStore.add(blog);<br/>  }</span><span id="73d2" class="lj lk jb la b gy lp lm l ln lo">  delete(id) {<br/>    this.blogStore.remove(id);<br/>  }</span><span id="2485" class="lj lk jb la b gy lp lm l ln lo">}</span></pre><p id="e326" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们也创建一个作者服务来获取作者列表。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="8aa2" class="lj lk jb la b gy ll lm l ln lo">export class AuthorService {</span><span id="9f22" class="lj lk jb la b gy lp lm l ln lo">  constructor(private authorStore: AuthorStore,<br/>              private http: HttpClient) {<br/>  }</span><span id="e693" class="lj lk jb la b gy lp lm l ln lo">  get() {<br/>    return this.http.get&lt;Author[]&gt;('http://localhost:3000/authors').pipe(tap(entities =&gt; {<br/>      this.authorStore.set(entities);<br/>    }));<br/>  }</span><span id="953d" class="lj lk jb la b gy lp lm l ln lo">}</span></pre><p id="1aea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> UI层</strong></p><p id="3034" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要设计UI层来显示博客的初始列表。为了设计我们的UI层，我们将把我们的UI分成智能组件，也称为容器组件和表示组件(有时称为哑组件)。我们将开始构建应用程序的主屏幕，其中有作者过滤器部分和博客部分。博客部分进一步分为博客列表部分和添加博客部分。这是最终的屏幕输出。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lq"><img src="../Images/285ddb62c108ec725c6d702927886e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TB6-APknW8fJY7-W.JPG"/></div></div></figure><p id="d3f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">作者-章节</strong></p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="41fc" class="lj lk jb la b gy ll lm l ln lo">&lt;div&gt;<br/>    &lt;span&gt;<br/>        Select User:<br/>        &lt;select class="form-control" (change)="onSelectAuthor($event.target.value)"&gt;<br/>            &lt;option *ngFor="let author of authors$ | async"&gt;{{author.name}}&lt;/option&gt;<br/>        &lt;/select&gt;<br/>    &lt;/span&gt;<br/>&lt;/div&gt;</span></pre><p id="9052" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">博客版块</strong></p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="2328" class="lj lk jb la b gy ll lm l ln lo">&lt;app-blog-list (deleteBlogEvent)="deleteBlog($event)" [blogs]="blogs$ | async"&gt;&lt;/app-blog-list&gt;<br/>&lt;app-add-blog [filter]="filter" (addBlogEvent)="addBlog($event)"&gt;&lt;/app-add-blog&gt;</span></pre><p id="d874" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">博客列表</strong></p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="51b6" class="lj lk jb la b gy ll lm l ln lo">&lt;div class="row"&gt;<br/>    &lt;div class="col-sm-6"&gt;<br/>        &lt;table class="table-striped"&gt;<br/>            &lt;thead&gt;<br/>                &lt;tr&gt;<br/>                    &lt;td&gt;<br/>                        &lt;p&gt; Title &lt;/p&gt;<br/>                    &lt;/td&gt;<br/>                    &lt;td&gt;<br/>                        &lt;p&gt; Author&lt;/p&gt;<br/>                    &lt;/td&gt;<br/>                    &lt;td&gt;&lt;/td&gt;<br/>                    &lt;td align="right"&gt;<br/>                        &lt;p&gt;Action&lt;/p&gt;<br/>                    &lt;/td&gt;<br/>                &lt;/tr&gt;<br/>            &lt;/thead&gt;</span><span id="bdec" class="lj lk jb la b gy lp lm l ln lo">            &lt;tr *ngFor="let blog of blogs"&gt;<br/>                &lt;td class="col-sm-1"&gt;<br/>                    {{blog.title}}<br/>                &lt;/td&gt;<br/>                &lt;td&gt;<br/>                    {{blog.author}}<br/>                &lt;/td&gt;<br/>                &lt;td class="col-sm-1"&gt;<br/>                &lt;/td&gt;<br/>                &lt;td align="right" class="col-sm-1"&gt;<br/>                    &lt;button class="btn-link" (click)="deleteBlog(blog)"&gt;Delete&lt;/button&gt;<br/>                &lt;/td&gt;<br/>            &lt;/tr&gt;<br/>        &lt;/table&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="ce75" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">呈现组件通过@Input从智能组件接收数据，智能组件通过@Output从呈现组件接收任何动作。在我们的例子中，blog-section是主要组件，而blog-list是我们的表示组件。author-section是保存作者过滤器下拉列表的组件。</p><p id="64c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将通过调用author服务来加载作者以填充过滤器下拉列表。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="3802" class="lj lk jb la b gy ll lm l ln lo">export class AuthorSectionComponent implements OnInit {</span><span id="83c0" class="lj lk jb la b gy lp lm l ln lo">  @Output()<br/>  updateFilter = new EventEmitter();<br/>  authors$: Observable&lt;Author[]&gt;;<br/>  constructor(private authorService: AuthorService, private filterService: FilterService, private authorQuery: AuthorQuery) { }</span><span id="4e38" class="lj lk jb la b gy lp lm l ln lo">  ngOnInit() {<br/>    this.authorService.get().subscribe();<br/>    this.authors$ = this.authorQuery.selectAll();<br/>  }</span><span id="a5cc" class="lj lk jb la b gy lp lm l ln lo">  onSelectAuthor(author: string) {<br/>    this.updateFilter.emit(author);<br/>    this.filterService.updateFilter(author === 'All' ? 'All' : author);<br/>  }<br/>}</span><span id="ccea" class="lj lk jb la b gy lp lm l ln lo">this.authorService.get().subscribe();</span></pre><p id="e131" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的调用将使用作者数据建立作者存储。您会注意到，我们通过调用store的selectAll()方法来获取authors$ data作为可观察值。可以在这里 了解更多秋田的店铺查询API<a class="ae kw" href="https://netbasal.gitbook.io/akita/entity-store/entity-query/api" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">。<br/>要加载所有的博客，我们可以使用博客查询并只调用selectAll()函数。</strong></a></p><p id="2e95" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">this.blogs$ = this.blogQuery.selectAll();</code></p><p id="468a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在我们的场景中，每当我们更新过滤器或者添加新的博客时，我们的应用程序状态都会改变。RxJS有一个名为combinelatest()的操作符来实现这个功能。这是我们在博客部分更新的代码。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="ea83" class="lj lk jb la b gy ll lm l ln lo">this.blogs$ = combineLatest(<br/>      this.blogQuery.selectAll(),<br/>      this.filterQuery.select(state =&gt; state.authorFilter.filter),<br/>      (blogs: any, authorFilter: any) =&gt; {<br/>        return blogs ? blogs.filter(blog =&gt; authorFilter === 'All' ? blog :   blog.author === authorFilter) : [];<br/>      }</span></pre><p id="e8d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我们向商店添加一个新的博客，或者更新过滤条件时，我们都会收到最新的值，我们只需要将最新的过滤条件应用于从combineLatest()函数接收的新的博客数组。</p><p id="669b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">结论</strong></p><p id="0e7c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，Akita在样板文件和与Angular的集成方面比NgRx简单得多。我发现与NgRx相比，它非常容易实现，只需使用一个服务来设置存储数据，并在组件内部使用一个查询来检索可观察到的数据。</p><p id="3dbe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里 可以找到完整的代码<a class="ae kw" href="https://github.com/rajvirtual/angular-cli-akita" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">。</strong></a></p></div></div>    
</body>
</html>