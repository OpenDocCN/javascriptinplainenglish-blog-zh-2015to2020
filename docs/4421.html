<html>
<head>
<title>How To Use Annotator.js With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Annotator.js与Node.js一起使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/annotatorjs-store-with-nodejs-9b5cf1f4e670?source=collection_archive---------6-----------------------#2020-12-10">https://javascript.plainenglish.io/annotatorjs-store-with-nodejs-9b5cf1f4e670?source=collection_archive---------6-----------------------#2020-12-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d68a95bb9fe539ccf77a60bcdabfc071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCkSUhQocfjnUG0LsrtrbA.png"/></div></div></figure><p id="787f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想对web进行注释，并且正在寻找一个简单可靠的解决方案用于您的项目，那么Annotator.js是一个非常棒的库。这个库非常灵活，您可以在任何应用程序中使用它，但是出于本文的考虑，我将在Node.js中使用它，并设置一个基本存储。我假设你已经准备好了一个基本的Express服务器，我将要使用的数据库设置是Mongodb，好了，让我们开始吧。</p><p id="5f07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先我们需要从<a class="ae kt" href="http://annotatorjs.org/" rel="noopener ugc nofollow" target="_blank">注释器</a>网站下载注释器，你会得到两个文件，一个是注释器JavaScript文件，另一个是注释器CSS文件，将它们粘贴到你的项目文件夹中。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="3e2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述代码所做的是在我们创建的注释中添加一些数据，它包括一些插件，如UI和存储插件，在存储插件中，我们有一些选项，我们将使用这些选项在后端执行crud操作，并使我们的注释持久化，我们为注释器添加了一个前缀，以便在服务器上获取数据和发布数据，该前缀为<a class="ae kt" href="https://localhost:3000/api" rel="noopener ugc nofollow" target="_blank"><em class="la">https://localhost:3000/API</em></a><em class="la"/>因此任何crud操作都可以执行 在客户端，将向服务器发送一个带有我们添加前缀的请求。如上所示，我们添加了两条路由，一条用于创建，另一条用于搜索，</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="184c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，当创建注释时，会向localhost:3000/API/annotation/fileName发出请求，当加载文档时，get请求会发送到localhost:3000/API/search/fileName,<code class="fe lb lc ld le b">window.btoa()</code>函数用于对文件名进行Base64编码。</p><p id="512b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是客户端注释器客户端设置，现在我们将创建我们的注释器存储。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="3016" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们创建注释并将其保存在数据库中的路径，因此在前端，当创建注释时，post请求将被发送到此路径，因此我们从请求体中获取报价、范围和文本，并创建一个对象以使用唯一id保存在数据库中，我们需要编辑和删除注释，作为响应，我们以上面写为<code class="fe lb lc ld le b">annotateobj</code>的格式呈现保存的文档，我们的注释保存在数据库中。</p><p id="f476" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在一步完成了，我们的存储还剩四步，下一步是在文档加载时获取注释。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="7d62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当页面加载时，GET请求被发送到localhost:3000/API/search/{ fileName }，该文件的所有注释都从数据库中获取，我们唯一需要做的就是将结果呈现为object，格式如下</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="0236" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将应用注释，现在只剩下两条路线，我将一起解释它们，</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="d91a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，我们为每个注释添加了一个唯一ID，我们只添加了两个url，您一定想知道为什么我没有添加更新和删除路由。这是因为这些路由是默认实现的，但是您可以自己定义这些URL。我使用了预定义的URL，所以与其他路由类似，发送一个put和delete请求。对于put请求，我们获取更新的对象，创建一个具有唯一id的对象，保存它，并发送新对象作为响应。删除它真的很简单。我们只需要通过id找到那个注释，删除那个注释，然后发送没有那个注释的响应。</p><p id="4e74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您已经拥有了我们的整个注释器存储库并正在运行，您可以在任何应用程序、任何框架中使用它，核心概念保持不变。</p></div></div>    
</body>
</html>