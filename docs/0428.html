<html>
<head>
<title>Best practices in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-practices-in-react-94ccbde2220e?source=collection_archive---------3-----------------------#2019-10-12">https://javascript.plainenglish.io/best-practices-in-react-94ccbde2220e?source=collection_archive---------3-----------------------#2019-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4863e76e08fb5607f0608ac3748de89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dKioq_l14Jjoj8xp"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6014" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React是前端开发人员中最流行的框架之一。你可能开发了许多React应用程序，或者你可能是一个新手，每次我们都想开发最好的。在那篇文章中，从设计、绑定和钩子等新概念的角度评估了一些最佳实践。</p><p id="e9f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你会喜欢:)</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="56d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">组件设计</strong></p><p id="bbbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在进入组件设计之前，让我们看看组件是如何在React中呈现的。</p><ul class=""><li id="fd74" class="lf lg in kc b kd ke kh ki kl lh kp li kt lj kx lk ll lm ln bi translated">当它属性改变时</li><li id="fe22" class="lf lg in kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">当它的状态改变时</li><li id="000d" class="lf lg in kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">当其父级渲染时，每个子级都被重新渲染</li></ul><p id="8ace" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里要说明的一点是关于第三项的。让我们指出问题，然后描述如何解决问题。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="a722" class="mc md in ly b gy me mf l mg mh">&lt;ParentComponent&gt;<br/>  &lt;ChildComponent /&gt;<br/>&lt;/ParentComponent&gt;</span></pre><p id="6ded" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个类似上面例子的组件设计。当ParentComponent被重新渲染时，它的子组件将被重新渲染，不管它是否应该被重新渲染。这将导致不必要的重新渲染，并会降低你的前端性能。</p><p id="a414" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们做什么呢</p><blockquote class="mi mj mk"><p id="50ea" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">避免从React扩展组件。组件，并尝试选择功能组件，因为你现在可以有钩子的力量。</p></blockquote><p id="0155" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你有3个选择来避免不必要的重新渲染。</p><blockquote class="mi mj mk"><p id="4bef" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">虽然据说React真的很快，而且不怕不必要的重新渲染，但这取决于你的项目。如果你的项目是实时更新的，数据获取如此频繁，你应该开始考虑不必要的重新渲染。</p></blockquote><ul class=""><li id="1e12" class="lf lg in kc b kd ke kh ki kl lh kp li kt lj kx lk ll lm ln bi translated">如果从React扩展组件。组件，覆盖<em class="ml">shouldcomponentdupdate</em>函数。这个函数返回一个布尔值，根据返回值，你的组件将被重新渲染或者不被渲染。然而，问题是你必须将每个属性值与之前的值进行比较，以检查是否有改变，你的组件是否会被重新渲染。所以，每当你添加一个新道具时，你也必须把这个对比添加到你的检查表中。</li></ul><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ce14" class="mc md in ly b gy me mf l mg mh">shouldComponentUpdate(nextProps, nextState){<br/>   return nextProps.id !== thisp.rops.id || nextState.name !== this.state.name;<br/>}</span></pre><blockquote class="mi mj mk"><p id="3859" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">不要忘记在比较语句中添加新状态和属性值</p></blockquote><ul class=""><li id="cb0a" class="lf lg in kc b kd ke kh ki kl lh kp li kt lj kx lk ll lm ln bi translated">扩展你的组件<em class="ml">做出反应。纯组件</em>。PureComponent内部运行shouldComponentUpdate函数。然而，这样做的问题是，如果你的属性或状态模型由复杂的嵌套JSON组成，它可能总是返回true。</li></ul><blockquote class="mi mj mk"><p id="b926" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">做出反应。如果您的状态和属性值由原始值或者非嵌套的JSON对象组成，那么PureComponent是很好的选择。对于嵌套的JSON模型，它可能总是返回true，并进行不必要的重新渲染。</p></blockquote><ul class=""><li id="9d7e" class="lf lg in kc b kd ke kh ki kl lh kp li kt lj kx lk ll lm ln bi translated">我推荐的是使用功能组件，忘记上面提到的项目。更简单的组件，不考虑组件的生命周期。</li></ul><blockquote class="mi mj mk"><p id="3576" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">有了hook的实现，您可以尽可能多地使用功能组件，这将为您提供比React更好的性能。成分</p></blockquote><p id="8df4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在<a class="ae jz" href="https://codesandbox.io/embed/component-render-performance-990q7?fontsize=14" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>上查看工作示例。每次你点击按钮，你可以看到哪些组件重新呈现在控制台上。</p><p id="50e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于<a class="ae jz" href="https://codesandbox.io/embed/component-render-performance-990q7?fontsize=14" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>的真实例子</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="049a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">抽象化</strong></p><p id="be95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React改变了开发者的思维方式。它通过建议您将组件分成更小的部分，迫使前端开发人员创建可重用的组件。</p><blockquote class="mp"><p id="9683" class="mq mr in bd ms mt mu mv mw mx my kx dk translated">不要害怕将你的组件分割成小块。尽可能创造小的作品。这些将帮助您创建更多的可重用组件。</p></blockquote><p id="ac3c" class="pw-post-body-paragraph ka kb in kc b kd mz kf kg kh na kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ig bi translated"><strong class="kc io">高阶组件(HOC) </strong></p><p id="8f27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">HOC是通过添加新特性返回新组件的函数，但不改变包装组件的内部状态。为了保持一致性，组件必须为相同的输入提供相同的输出。因此，当您在HOC中更改组件的内部状态时，您可能会失去组件输出的一致性。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f7f4" class="mc md in ly b gy me mf l mg mh">const withReversedLabel = WrappedComponent =&gt; {<br/>  return class extends React.Component {<br/>    render() {<br/>      const label = this.props.label<br/>        .split("")<br/>        .reverse()<br/>        .join("");<br/>      return &lt;WrappedComponent label={label} /&gt;;<br/>    }<br/>  };<br/>};</span></pre><p id="903c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于<a class="ae jz" href="https://codesandbox.io/embed/hoc-jnck2?fontsize=14" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>的真实示例</p><p id="d4e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">包装组件</strong></p><p id="4625" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">包装组件的语法不同于HOC。在HOC中，通过向现有组件添加新功能来返回新组件，而在包装组件设计中，通过添加新功能来呈现子组件。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="681c" class="mc md in ly b gy me mf l mg mh">const Card = ({ children }) =&gt; &lt;div className="card"&gt;{children}&lt;/div&gt;;<br/>const Content = () =&gt; &lt;div&gt;My content&lt;/div&gt;;<br/>const Content2 = () =&gt; &lt;div&gt;My content 2&lt;/div&gt;;</span><span id="8dec" class="mc md in ly b gy ne mf l mg mh">function App() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Card&gt;<br/>        &lt;Content /&gt;<br/>      &lt;/Card&gt;<br/>      &lt;Card&gt;<br/>        &lt;Content2 /&gt;<br/>      &lt;/Card&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="cc9a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你得到了什么？</p><ul class=""><li id="b85f" class="lf lg in kc b kd ke kh ki kl lh kp li kt lj kx lk ll lm ln bi translated">你得到了更多基于组件的语法</li><li id="882e" class="lf lg in kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">您可以限制WrapperComponent中的子计数</li><li id="abbd" class="lf lg in kc b kd lo kh lp kl lq kp lr kt ls kx lk ll lm ln bi translated">您刚刚创建了一个模板card组件，您可以在card component中呈现您想要的任何内容</li></ul><p id="6103" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于<a class="ae jz" href="https://codesandbox.io/embed/wrapper-component-mcbxb?fontsize=14" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>的真实例子</p><p id="d347" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">渲染道具</strong></p><p id="4599" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种模式中，您可以在另一个组件中共享一个组件的属性。它类似于HOC，但语法更强大。</p><p id="b105" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您有一个名为Fetch的组件，可以管理rest调用。在这个组件中，您将处理加载、错误和数据状态。另一个名为Students的组件需要获取数据，您不希望将该业务包含在Student组件中，但希望使用fetch组件。</p><blockquote class="mi mj mk"><p id="ea3f" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">Render props是一种将组件作为函数参数发送到包装类的模式。</p></blockquote><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="fcbe" class="mc md in ly b gy me mf l mg mh">&lt;Fetch <br/>      url="abc.com"<br/>&gt;<br/>      {({ loading, error, data }) =&gt; {<br/>        if (loading) {<br/>          return &lt;div&gt;Loading!&lt;/div&gt;;<br/>        } else if (error) {<br/>          return &lt;div&gt;{error}&lt;/div&gt;;<br/>        } else {<br/>          return &lt;Student data={data} /&gt;;<br/>        }<br/>      }}<br/>&lt;/Fetch&gt;</span></pre><p id="f7d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于<a class="ae jz" href="https://codesandbox.io/embed/render-props-8b26p?fontsize=14" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>的真实例子</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="5ae6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">功能绑定</strong></p><p id="d089" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们先定义问题。大多数开发人员开始使用arrow函数，因为它简单，不需要在构造函数中绑定，而且比在构造函数中绑定函数性能更好。但是，如果使用不当，它会影响性能。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="375a" class="mc md in ly b gy me mf l mg mh">// bad example</span><span id="43cb" class="mc md in ly b gy ne mf l mg mh">function MyComponent = () =&gt; {<br/>   return &lt;button onClick={() =&gt; callMe()}&gt;Click me&lt;/button&gt;<br/>}</span></pre><p id="baeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的问题是，每次组件重新呈现时，都会为callMe函数创建一个新的引用。</p><p id="0029" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了解决这个问题，您可以将函数从onClick事件处理程序中移出。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0ed6" class="mc md in ly b gy me mf l mg mh">function MyComponent = () =&gt; {<br/>   const handleClick = () =&gt; console.log(1);</span><span id="0aed" class="mc md in ly b gy ne mf l mg mh">   return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;<br/>}</span></pre><p id="3d72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，当我像上面那样使用函数时，如何绑定自定义值呢？</p><p id="8969" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设您有一个列表，并且希望将您的id与按钮的onClick功能绑定。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="81ad" class="mc md in ly b gy me mf l mg mh">function App() {<br/>  const handleClick = id =&gt; console.log(id);</span><span id="7536" class="mc md in ly b gy ne mf l mg mh">return datas.map(data =&gt; (<br/>    &lt;button onClick={handleClick.bind(null, data.id)}&gt;Click me!&lt;/button&gt;<br/>  ));<br/>}</span></pre><p id="e5eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://codesandbox.io/embed/function-binding-ilc0q?fontsize=14" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>上的实时示例</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="0668" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">使用钩子&amp;记忆</strong></p><p id="ba34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在v16.8中，钩子进入了功能组件的反应生命周期，为类组件提供动力。有很多内置钩子可以使用，比如useState、useMemo、useCallback等..，您还可以定义自己的钩子，以便在功能组件中使用。</p><p id="fd8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">使用状态</strong></p><p id="aaff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在钩子出现之前，功能组件被称为无状态功能组件，因为它们没有状态。然而，在钩子出现之后，事情发生了变化，无状态功能组件的名字变成了功能组件。</p><p id="af13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">如何使用useState？</strong></p><p id="eb5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是，在使用useState时，它的行为不同于在基于类的组件中使用的setState()函数。当您使用这个. setState()函数时，它会将发送的值与其已经存储的状态合并，而useState只是用新的状态覆盖它的整个状态。</p><p id="4b13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面以最简单的方式显示了useState的用法。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5229" class="mc md in ly b gy me mf l mg mh">const [myState, setMyState] = useState(1); </span></pre><blockquote class="mi mj mk"><p id="ca3c" class="ka kb ml kc b kd ke kf kg kh ki kj kk mm km kn ko mn kq kr ks mo ku kv kw kx ig bi translated">不要忘记初始化您的状态值</p></blockquote><p id="1fac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">反应备忘录</strong></p><p id="64ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如第一节所述，每当父组件的状态/属性改变时，它的所有子组件都会被重新呈现。但是，在React中定义了一个函数，您可以使用它来避免不必要的重新渲染。</p><p id="31ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">response . memo只是记忆组件的道具，并且在内部每当你的道具改变时会重新渲染你的组件。它类似于为基于类的组件描述的应该组件更新方法，但是这个方法只针对功能组件。</p><p id="7d24" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在活生生的例子中看到。有一个父组件和两个子组件，一个由React.memo包装，另一个没有。每当你点击父组件的按钮来触发状态改变时，你会看到功能组件没有反应。尽管它的状态或属性没有改变，但是备忘录将会被重新呈现。</p><p id="1ec3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://codesandbox.io/embed/hardcore-panini-8y2dz?fontsize=14" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>上的实时示例</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="dcf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">如果你喜欢我的文章，你可以鼓掌和跟着我来支持我。<br/>我也在</em><a class="ae jz" href="http://www.linkedin.com/in/muratcatal" rel="noopener ugc nofollow" target="_blank"><em class="ml">LinkedIn</em></a><em class="ml">上，欢迎所有的邀请。</em></p></div></div>    
</body>
</html>