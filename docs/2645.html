<html>
<head>
<title>Node.js Tips — Streams, Scraping, and Promisifying Functions, and Configs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—流、抓取和承诺函数以及配置</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-streams-scraping-and-promisifying-functions-and-f40035c5d862?source=collection_archive---------10-----------------------#2020-07-11">https://javascript.plainenglish.io/node-js-tips-streams-scraping-and-promisifying-functions-and-f40035c5d862?source=collection_archive---------10-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/32105c487325e889a16d62701d65cdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LZ0zNvgRVjVn8oIP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tamasp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tamas Pap</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a284" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="a0d3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中将缓冲区转换为ReadableStream</h1><p id="9715" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">ReadableStreamBuffer</code>构造函数将缓冲区转换成可读的流。</p><p id="29bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d2e7" class="mq lc iq mh b gy mr ms l mt mu">const { ReadableStreamBuffer } = require('stream-buffers');<br/>const readableStreamBuffer = new ReadableStreamBuffer({<br/>  frequency: 10,<br/>  chunkSize: 2048<br/>});</span><span id="a598" class="mq lc iq mh b gy mv ms l mt mu">readableStreamBuffer.put(aBuffer);</span></pre><p id="790d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">aBuffer</code>是我们要转换的缓冲区。</p><p id="54a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">frequency</code>是组块被抽出的频率。</p><p id="41c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以在带有<code class="fe me mf mg mh b">chunkSize</code>属性的构造函数中改变大小。</p><h1 id="73a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js实时抓取网页</h1><p id="7761" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用cheerio库实时抓取网页。</p><p id="29f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f4e1" class="mq lc iq mh b gy mr ms l mt mu">npm install cheerio</span></pre><p id="ccc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="beed" class="mq lc iq mh b gy mr ms l mt mu">const cheerio = require('cheerio');<br/>const $ = cheerio.load('&lt;h1 class="title"&gt;Hello world&lt;/h1&gt;');</span><span id="1e0a" class="mq lc iq mh b gy mv ms l mt mu">$('h1.title').text('Hello James');<br/>$('h1').addClass('welcome');</span><span id="6d81" class="mq lc iq mh b gy mv ms l mt mu">$.html();</span></pre><p id="4410" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以获取HTML的内容，并像处理jQuery一样处理它。</p><p id="201d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它与Axios之类的HTTP客户端结合起来获得HTML。</p><p id="1dc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用Cheerio解析它的内容。</p><p id="c0eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e9c2" class="mq lc iq mh b gy mr ms l mt mu">const axios = require('axios');<br/>const cheerio = require('cheerio');</span><span id="bcbf" class="mq lc iq mh b gy mv ms l mt mu">axios.get('https://example.com')<br/>.then(({ data }) =&gt; {<br/>  const $ = cheerio.load(data);<br/>  const text = $('h1').text();<br/>  console.log(text);       <br/>})</span></pre><p id="c6f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用Axios向一个网站发出GET请求。</p><p id="75fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用cheerio和<code class="fe me mf mg mh b">cheerio.load</code>解析数据。</p><p id="9572" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">text</code>方法得到<code class="fe me mf mg mh b">h1</code>的内容。</p><p id="cc28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何选择器都可以用来获取数据。</p><h1 id="c0b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用JavaScript生成MD5文件散列</h1><p id="1826" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用crypto-js包生成一个MD5散列。</p><p id="4e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们可以运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="58f3" class="mq lc iq mh b gy mr ms l mt mu">npm install crypto-js</span></pre><p id="49f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="05fe" class="mq lc iq mh b gy mr ms l mt mu">import MD5 from "crypto-js/md5";<br/>const md5Hash = MD5("hello world");</span></pre><p id="67b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来生成哈希。</p><h1 id="f174" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js进行服务器端浏览器检测</h1><p id="4fd9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以从请求中获取<code class="fe me mf mg mh b">user-agent</code>头来获取用户代理字符串。</p><p id="feaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解析字符串，我们可以使用ua-parser-js包。</p><p id="d598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9c1f" class="mq lc iq mh b gy mr ms l mt mu">npm install ua-parser-js</span></pre><p id="7a51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的Express应用程序中，我们可以创建自己的中间件来检查用户代理:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="59da" class="mq lc iq mh b gy mr ms l mt mu">const UAParser = require('ua-parser-js');</span><span id="ae8f" class="mq lc iq mh b gy mv ms l mt mu">const checkBrowser = (req, res, next) =&gt; {<br/>  const parser = new UAParser();<br/>  const ua = req.headers['user-agent'];<br/>  const browserName = parser.setUA(ua).getBrowser().name;<br/>  const fullBrowserVersion = parser.setUA(ua).getBrowser().version;</span><span id="0405" class="mq lc iq mh b gy mv ms l mt mu">  console.log(browserName);<br/>  console.log(fullBrowserVersion);<br/>  next();<br/>}</span><span id="ef19" class="mq lc iq mh b gy mv ms l mt mu">app.all(/*/, checkBrowser);</span></pre><p id="755b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">req.headers[‘user-agent’]</code>得到<code class="fe me mf mg mh b">user-agent</code>头。</p><p id="29a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">UAParser</code>构造函数来解析用户代理字符串。</p><p id="3911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">getBrowser</code>来获取浏览器数据。</p><p id="d841" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">name</code>具有浏览器名称，<code class="fe me mf mg mh b">version</code>具有版本。</p><h1 id="cc13" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express应用程序中存储数据库配置的最佳方式</h1><p id="eaf5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将配置存储在配置文件中。</p><p id="fcbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c9fc" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');<br/>const configPath = './config.json';<br/>const configFile = fs.readFileSync(configPath, 'utf-8')<br/>const parsedConfig = JSON.parse(configFile);<br/>exports.storageConfig = parsedConfig;</span></pre><p id="749c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">readFileSync</code>来读取<code class="fe me mf mg mh b">config.json</code>。</p><p id="df7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们解析JSON字符串中的数据。</p><p id="7690" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导出最后一行中的配置。</p><h1 id="d327" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Promisify节点的child_process.exec和child_process.execFile函数</h1><p id="6472" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用蓝鸟转换<code class="fe me mf mg mh b">child_process</code> <code class="fe me mf mg mh b">exec</code>和<code class="fe me mf mg mh b">execFile</code>方法。</p><p id="1c67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ec8c" class="mq lc iq mh b gy mr ms l mt mu">const util = require('util');<br/>const exec = util.promisify(require('child_process').exec);</span><span id="e055" class="mq lc iq mh b gy mv ms l mt mu">const listFiles = async () =&gt; {<br/>  try {<br/>    const { stdout, stderr } = await exec('ls');<br/>    console.log('stdout:', stdout);<br/>    console.log('stderr:', stderr);<br/>  } catch (e) {<br/>    console.error(e);<br/>  }<br/>}</span><span id="8b0d" class="mq lc iq mh b gy mv ms l mt mu">listFiles();</span></pre><p id="a690" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">util</code>库的<code class="fe me mf mg mh b">promisify</code>方法将<code class="fe me mf mg mh b">exec</code>方法转换为承诺。</p><p id="3a52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">ls</code>命令调用promised<code class="fe me mf mg mh b">exec</code>方法。</p><p id="6140" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">stdout</code>和<code class="fe me mf mg mh b">stderr</code>得到全输出。</p><p id="a989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">stdout</code>有结果了。<code class="fe me mf mg mh b">stderr</code>有错误输出。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ce0bf44e05ef5d5554f75406b66f5495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o1IMXFOxsi2u2mpk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alysa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alysa Bajenaru</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="115a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3c33" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将一个缓冲区转换成一个可读的流。</p><p id="5200" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用HTTP客户端和cheerio抓取网页。</p><p id="e825" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">crypto-js使用MD5方法创建MD5散列。</p><p id="53fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自<code class="fe me mf mg mh b">child_process</code>的方法可以转换成承诺。</p><p id="6db2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在服务器端解析用户代理字符串，解析浏览器版本数据。</p><h2 id="5e8f" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="2c43" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>