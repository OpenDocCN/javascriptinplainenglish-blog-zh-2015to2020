<html>
<head>
<title>Why we still need to use state management libraries in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们仍然需要在React中使用状态管理库？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-we-still-need-to-use-state-management-libraries-in-reactjs-1e53bd18dab5?source=collection_archive---------2-----------------------#2020-02-03">https://javascript.plainenglish.io/why-we-still-need-to-use-state-management-libraries-in-reactjs-1e53bd18dab5?source=collection_archive---------2-----------------------#2020-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f0e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么使用just React的状态机制不是一个好主意</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/35e159b00964fa9051b6348227e20be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sdWVxyWuq4Fj1N8C"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@guibolduc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Guillaume Bolduc</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cb89" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="3350" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们有了<code class="fe mk ml mm mn b">hooks</code>和<code class="fe mk ml mm mn b">Context API</code>，在React中开始一个新项目时放弃一个状态管理库似乎很有吸引力——我们应该屈服于这种诱惑吗？让我们通过查看一个简单的购物车示例来找出答案，从树的底部开始——item list视图。</p><h1 id="1f59" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在底部</h1><p id="3fe7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一个上下文消费者组件看起来像这样，当然，这是一个非常简单的例子，但是它很好地说明了主要的兴趣点。它只是呈现一个商品列表，可以在购物车中添加或删除商品。</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="1e6f" class="ms kx iq mn b gy mt mu l mv mw"><strong class="mn ir">const</strong> SimpleItemList = () <strong class="mn ir">=&gt;</strong> {<br/>    // Using the hook to gain access to the context<br/>    <strong class="mn ir">const</strong> context = useContext(GlobalContext);<br/>    <br/>    return (<br/>        &lt;div&gt;<br/>        {context.items.map((item, index) <strong class="mn ir">=&gt;</strong> {<br/>            return (<br/>                &lt;Item<br/>                    key={index}<br/>                    item={item}<br/>                    onAdd={() <strong class="mn ir">=&gt;</strong> {<br/>                        context.addToCart(item);<br/>                    }}<br/>                    onRemove={() <strong class="mn ir">=&gt;</strong> {<br/>                        context.removeFromCart(item);<br/>                    }}<br/>                /&gt;<br/>            );<br/>        })}<br/>        &lt;/div&gt;<br/>    );<br/>};</span></pre><p id="ec01" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">起初，它似乎很好，因为它不需要传入任何道具，只需要直接从上下文中获取我们需要的一切。</p><p id="dcca" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">不过这也有一些缺点:</p><ul class=""><li id="67cf" class="nc nd iq lq b lr mx lu my lx ne mb nf mf ng mj nh ni nj nk bi translated">组件重用是有害的，因为它直接与上下文相关联</li><li id="4865" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">乍一看，很难推断这个组件需要什么变量，因为没有道具</li></ul><p id="0ee2" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">我们可以传入上下文作为组件的道具，使其更具可重用性。</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="26b3" class="ms kx iq mn b gy mt mu l mv mw"><strong class="mn ir">const</strong> context = useContext(props.context);</span></pre><p id="b426" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">如果我们要使用Typescript，我们可以指定组件的props扩展某种描述我们期望的上下文外观的基本接口，但我不建议这样做，因为这看起来像一个黑客，如果情况足够糟糕，这种选择是存在的。</p><h1 id="2437" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在顶部</h1><p id="5e81" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们定义我们的应用程序状态，以及处理它所必需的函数，并使用<code class="fe mk ml mm mn b">Context API</code>将它暴露给我们的其他组件。</p><p id="f598" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">为了使用<code class="fe mk ml mm mn b">Context API</code>，我们需要用上下文提供者组件包装我们的应用程序，以便需要它的孩子可以访问我们的上下文。</p><pre class="kg kh ki kj gt mo mn mp mq aw mr bi"><span id="ce94" class="ms kx iq mn b gy mt mu l mv mw"><strong class="mn ir">function</strong> SimpleStateApp() {<br/>    <strong class="mn ir">const</strong> addToCart = item <strong class="mn ir">=&gt;</strong> {<br/>        setState(prevState <strong class="mn ir">=&gt;</strong> {<br/>            <strong class="mn ir">const</strong> copy = { ...prevState };<br/>            if (copy.cart[item.id]) {<br/>                copy.cart[item.id].count++;<br/>            } else {<br/>                copy.cart[item.id] = { ...item, count: 1 };<br/>            }<br/>            return {<br/>                ...copy<br/>            };<br/>        });<br/>    };</span><span id="0bbe" class="ms kx iq mn b gy nq mu l mv mw"><strong class="mn ir">const</strong> removeFromCart = item <strong class="mn ir">=&gt;</strong> {<br/>        setState(prevState <strong class="mn ir">=&gt;</strong> {<br/>            <strong class="mn ir">const</strong> copy = { ...prevState };<br/>            if (copy.cart[item.id].count === 1) {<br/>                delete copy.cart[item.id];<br/>            } else {<br/>                copy.cart[item.id].count--;<br/>            }<br/>            return {<br/>                ...copy<br/>            };<br/>        });<br/>    };</span><span id="7cc4" class="ms kx iq mn b gy nq mu l mv mw"><strong class="mn ir">const</strong> [state, setState] = useState({<br/>        addToCart: addToCart,<br/>        removeFromCart: removeFromCart,<br/>        items: [...ITEMS_ARRAY],<br/>        cart: {}<br/>    });</span><span id="e403" class="ms kx iq mn b gy nq mu l mv mw">return (<br/>        &lt;GlobalContext.Provider value={state}&gt;<br/>            &lt;div className="App"&gt;<br/>                &lt;header className="App-header"&gt;<br/>                    &lt;div&gt;This is the Simple barn&lt;/div&gt;<br/>                &lt;/header&gt;<br/>                &lt;SimpleItemList /&gt;<br/>                &lt;SimpleCart /&gt;<br/>            &lt;/div&gt;<br/>        &lt;/GlobalContext.Provider&gt;<br/>    );<br/>}</span></pre><p id="7b65" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">它就像一个魔咒！尽管它暴露了一些事情:</p><ul class=""><li id="669e" class="nc nd iq lq b lr mx lu my lx ne mb nf mf ng mj nh ni nj nk bi translated">这仍然是单个组件的局部状态，与其紧密耦合</li><li id="cce5" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">增加业务逻辑的复杂性会增加根组件的复杂性</li></ul><h1 id="399a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="1d35" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我让它看起来比实际情况更糟，因为有很多方法可以避免将所有东西都直接放入根组件中，状态函数可以很容易地移动到单独的文件中，只需在根组件中导入，但我认为最好使用一个适当的状态管理库来将全局状态从任何单个组件中分离出来，使组件尽可能简单，只需要它们运行时的状态。</p><p id="d5cc" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">在这个<a class="ae kv" href="https://github.com/MustSeeMelons/react-state-party" rel="noopener ugc nofollow" target="_blank"> repo </a>中，你可以查看同一个应用的多种状态管理方式。</p></div></div>    
</body>
</html>