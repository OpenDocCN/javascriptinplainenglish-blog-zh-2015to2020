<html>
<head>
<title>Simple Sorting Algorithms in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的简单排序算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-sorting-algorithms-in-javascript-57d512ceaf5d?source=collection_archive---------2-----------------------#2020-01-02">https://javascript.plainenglish.io/simple-sorting-algorithms-in-javascript-57d512ceaf5d?source=collection_archive---------2-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44c1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">冒泡、选择和插入排序</h2></div><p id="037a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">排序是程序员在处理数据时最常遇到的问题之一。在这篇博客中，我们将回顾一些简单的排序算法，每个程序员都应该掌握。所有这些都被认为是简单的，因为它们都具有较慢的时间复杂度O(n)。如果你不确定什么是大O，看看我写的这个<a class="ae lb" href="https://medium.com/swlh/small-math-to-big-o-901a90998871" rel="noopener">博客</a>。</p><p id="fb3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还推荐书签<a class="ae lb" href="https://www.toptal.com/developers/sorting-algorithms" rel="noopener ugc nofollow" target="_blank"> TopTal的排序算法动画</a>或<a class="ae lb" href="https://visualgo.net/en/sorting?slide=1" rel="noopener ugc nofollow" target="_blank"> Visualgo的排序部分</a>来帮助你在阅读这篇博客时以及在你的整个编程生涯中可视化这些算法。程序员最好的朋友是互联网！</p><h1 id="dae9" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">交换助手方法</h1><p id="6607" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">所有这些算法都涉及交换数组中的元素。为了更好地理解算法是如何工作的，我们将抽象出一个叫做“swap”的可重用函数。“Swap”接受一个数组，以及要交换的数组的两个索引。以下是JS和Ruby中的实现:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Swap function in JavaScript</figcaption></figure><h1 id="eb4e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">冒泡排序</h1><p id="7262" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">每个简单的排序算法都是从<strong class="kh ir">定义一个被排序的部分</strong>开始，然后<strong class="kh ir">从那个被排序的部分</strong>向外移动。冒泡排序从查找数组中的最大值开始，并将其移动到最后一个元素——排序部分。然后重复，直到排序后的部分封装了整个数组。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/682a7fb31f64762eb5241c779b01d8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*kaTC1qyABWe2RcRn0fTeXQ.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Bubble Sort First Pass</figcaption></figure><p id="ab73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面我们看到了冒泡排序是如何得名的——它通过不断比较两个元素并交换它们，将最高的元素冒泡到顶部。当上面GIF中的数字变成橙色时，它被视为“已排序”，排序从开始处重新开始。然后继续这个过程，直到整个数组排序完毕。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e86018e4fd3b5846f4b8e9b34182a8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*5MamIim_fvE9k72XAD5ceQ.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Bubble Sort Next Pass</figcaption></figure><p id="2832" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我下面的实现中，我跟踪两个变量currentIndex(排序比较的内容)和endIndex(已经排序的部分)。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">JavaScript Implementation of Bubble Sort</figcaption></figure><h1 id="3aba" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">选择排序</strong></h1><p id="6757" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">选择排序基本上与冒泡排序相反。排序不是找到最大的元素并将其冒泡到顶部，而是找到数组中最小的<strong class="kh ir">元素并将其移动到数组的开头- <strong class="kh ir">新排序的部分</strong>。然后重复，直到排序后的部分包含整个数组。</strong></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c6f25d45c4d37424d44ae7eb054171b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*PrRpfMbxpwyolerV29eweQ.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Selection Sort First Pass</figcaption></figure><p id="c115" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择排序之所以得名，是因为它遍历了整个数组，而<em class="mn">选择了</em>最底层的元素，只有在遍历完整个数组后才交换它。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/f3ecc480d517f899c6e204bf138e38e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*YZQVtb0h9qCCUpNRMBrAMA.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Selection Sort Next 2 Passes</figcaption></figure><p id="f140" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的实现中，我这次跟踪了3个变量——最小的元素、我要比较的当前元素和排序部分的开始。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Selection Sort in JavaScript</figcaption></figure><h1 id="922e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated"><strong class="ak">插入排序</strong></h1><p id="541e" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">最后，我们得出插入排序。插入排序与我们讨论过的前两种排序略有不同，它不首先查找最高或最低的数字——它将数组中的第一个数字视为已排序，并且<strong class="kh ir">相应地将</strong>数字插入排序中。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a727ae218f673100e4e6f66264fb3aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*HE8OysaTiY_4eI6PH9bXhg.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Insertion Sort First 3 Passes</figcaption></figure><p id="f4b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的GIF中，我们看到这种交换有点不同——我们用它们的下一个索引交换元素，为我们正在比较的当前值腾出空间——以便找到正确的位置<em class="mn">插入</em>它。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/8490d050b2737f805f621c8e47c701dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*aqgS2OyeuGhxGfxoutpi8w.gif"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Insertion Sort 4th Pass</figcaption></figure><p id="151c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在实现中，我们希望跟踪三个变量——我们正在排序的部分的beginningIndex、我们正在检查的currentIndex和我们正在比较的currentVal。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk">Insertion Sort JS</figcaption></figure><p id="e08a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，这些排序算法在最坏的情况下都有O(n)的时间复杂度，所以如果处理大量未排序的数据，它们可能会非常慢。然而，这些算法充其量只能达到O(n ),所以如果您有一组几乎已经排序的数据，这些实现中的任何一个都应该可以快速运行。如果你想看看用for循环编写的这些种类的替代版本，请查看这个<a class="ae lb" href="https://gist.github.com/Giagnus64/a1276f8b885221eedd05b79306536588" rel="noopener ugc nofollow" target="_blank">要点</a>。如果你想看用Ruby写的这些排序，看看这个<a class="ae lb" href="https://gist.github.com/Giagnus64/d1909852e74a6df31a66d8e54655d319" rel="noopener ugc nofollow" target="_blank">要点</a>。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="mo mf l"/></div></figure><div class="mp mq gp gr mr ms"><a href="https://medium.com/@sydbails/simplify-your-understanding-of-big-o-notation-and-algorithmic-complexity-dfe20a277b7b" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">简化你对大O符号和算法复杂性的理解</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">这里有一个解释算法复杂性的有用指南，以及理解大O符号如何帮助你写得更好…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ml ms"/></div></div></a></div></div></div>    
</body>
</html>