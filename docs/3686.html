<html>
<head>
<title>Solving a stupid JavaScript problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决一个愚蠢的JavaScript问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solving-a-stupid-javascript-problem-aa54e26e3605?source=collection_archive---------1-----------------------#2020-10-18">https://javascript.plainenglish.io/solving-a-stupid-javascript-problem-aa54e26e3605?source=collection_archive---------1-----------------------#2020-10-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b475" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的故事从<a class="ae ki" href="https://twitter.com/tlakomy/status/1317533732505530368" rel="noopener ugc nofollow" target="_blank">发自<a class="kj kk ep" href="https://medium.com/u/95ecb313f8ac?source=post_page-----aa54e26e3605--------------------------------" rel="noopener" target="_blank">托马兹·扎科米</a>的一条</a>推文开始，他让你想象这个问题会在编码面试中出现。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/cd8e6276b9beaba7ce0d6b0521035719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bt0w_Vt5HTdEzIZZ"/></div></div></figure><p id="9e32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">至于在采访中我会如何回应这个问题，我觉得这取决于问题的焦点是什么。如果问题实际上是树的价值是什么，他们可以走开，或者希望我只是把它粘贴到我的控制台，然后告诉他们走开。</p><p id="6bce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，如果问题是<strong class="jm io">将如何</strong>解决这个问题，那么这就很有趣了，并导致了许多关于JavaScript和编译器工作方式的怪癖。因此，在这篇文章中，我将深入到这些混乱的事物中，探索会产生什么有趣的想法。</p><p id="ce5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还在<a class="ae ki" href="https://www.twitch.tv/videos/774155933" rel="noopener ugc nofollow" target="_blank"> Twitch </a>上串流了解决这个问题的过程。很长，但是给出了另一种观点，如何一点一点的解决这类问题。</p><h1 id="d85e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">高层次的想法</h1><p id="79bb" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">首先，让我们把这个东西变成可复制的状态:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="116d" class="mf ky in mb b gy mg mh l mi mj">let b = 3, d = b, u = b;</span><span id="aeb2" class="mf ky in mb b gy mk mh l mi mj">const tree = ++d * d*b * b++ +<br/> + --d+ + +b-- +<br/> + +d*b+ +<br/> u</span></pre><p id="6391" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我立刻注意到了一些事情。我想编译器可能会有一些小技巧。JavaScript通常会在每一行的末尾添加分号<strong class="jm io">，除非有一个表达式不能终止</strong>。在这种情况下，每行末尾的<code class="fe ml mm mn mb b">+</code>告诉编译器不要终止这条语句。</p><p id="bcb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一行只创建了三个变量，它们都被设置为<code class="fe ml mm mn mb b">3</code>。<code class="fe ml mm mn mb b">3</code>是一个原始值，所以任何时候复制都是通过值完成的<em class="mo">，所以新的变量是用值<code class="fe ml mm mn mb b">3</code>创建的。如果JavaScript通过引用</em>为这些变量<em class="mo">赋值，那么每个新变量<strong class="jm io">将指向</strong>之前使用的变量，但不会为自己创建一个值。</em></p><p id="d1e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://medium.com/nodesimplified/javascript-pass-by-value-and-pass-by-reference-in-javascript-fcf10305aa9c" rel="noopener">延伸阅读</a></p><h1 id="eb79" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">运算符优先级和结合性</h1><p id="5bb8" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这些是解决这个可怕的树问题的关键概念。稍后我会解释每一个，但是在高层次上，它们决定了JavaScript表达式组合的求值顺序。</p><h2 id="31d1" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">运算符优先级</h2><p id="60fc" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">问题:这两种表达方式有什么区别？</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="9fc9" class="mf ky in mb b gy mg mh l mi mj">3 + 5 * 5</span><span id="57b1" class="mf ky in mb b gy mk mh l mi mj">5 * 5 + 3</span></pre><p id="bd18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就结果而言，没有什么不同。任何记得他们在学校的数学课的人都记得你先乘后加。我记得它是作为<strong class="jm io"> BODMAS、</strong>或括号掉除乘加减。在JavaScript中，我们有相同的概念，叫做操作符优先，它简单地表示我们计算表达式的顺序。如果我们想强制<code class="fe ml mm mn mb b">3 + 5</code>先进行评估，那么我们只需执行以下操作</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="3bde" class="mf ky in mb b gy mg mh l mi mj">(3+5) * 5</span></pre><p id="72b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">括号强制首先计算表达式的这一部分，因为<code class="fe ml mm mn mb b">()</code>的运算符优先级高于<code class="fe ml mm mn mb b">*</code>。</p><p id="ee9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个JavaScript操作符都有一个优先级，由于树中有这么多操作符，我们需要理解事物的求值顺序。特别是因为<code class="fe ml mm mn mb b">++</code>和<code class="fe ml mm mn mb b">--</code>会改变<code class="fe ml mm mn mb b">b</code>和<code class="fe ml mm mn mb b">d</code>的值，我们需要知道这些表达式相对于树的其余部分何时被求值。</p><p id="f86c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">重要:</strong> <a class="ae ki" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" rel="noopener ugc nofollow" target="_blank">操作员优先顺序和后续阅读表</a></p><h1 id="b8a0" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结合性</h1><p id="eef4" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">结合性用于确定在给定的具有相同优先级的运算符中计算哪个顺序表达式。例如:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="681d" class="mf ky in mb b gy mg mh l mi mj">a + b + c</span></pre><p id="f8e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个表达式中，我们没有运算符优先级，因为我们只有一个运算符。那么我们是评价为<code class="fe ml mm mn mb b">(a + b) + c</code>还是<code class="fe ml mm mn mb b">a + (b + c)</code>？</p><p id="0021" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道答案是一样的，但是编译器需要知道，这样它可以先选择一个来做，然后继续。在这种情况下，<code class="fe ml mm mn mb b">(a + b) + c</code>就是答案，因为<code class="fe ml mm mn mb b">+</code>操作符是左关联的，这意味着它首先计算左边的表达式。</p><p id="dcd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">"他们为什么不把所有东西都联想起来？"我听到你问了。</p><p id="c7ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，考虑以下情况:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="246e" class="mf ky in mb b gy mg mh l mi mj">a = b + c</span></pre><p id="a4e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们遵循前面的左结合公式，我们就有了</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="25c0" class="mf ky in mb b gy mg mh l mi mj">(a = b) + c</span></pre><p id="e03d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是坚持住。这看起来很奇怪，我不是这个意思。如果我们想让这个表达式只使用左结合律，我们需要这样做:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="4a6a" class="mf ky in mb b gy mg mh l mi mj">a + b = c</span></pre><p id="680b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哪个变成了<code class="fe ml mm mn mb b">(a + b) = c</code>，或者更清楚地说，我们先做<code class="fe ml mm mn mb b">a + b</code>，然后将<code class="fe ml mm mn mb b">c</code>赋值给那个结果的值。</p><p id="0ec3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们必须这样思考，JavaScript会更加混乱，我们对不同操作数使用不同关联的原因是为了让代码更具可读性。当你阅读<code class="fe ml mm mn mb b">a = b + c</code>时，求值的顺序感觉很自然，即使在幕后有一些诡计在进行，并且左右两个关联操作数都被使用。</p><p id="3fe2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你现在可能已经注意到<code class="fe ml mm mn mb b">a = b + c</code>有一个结合性问题。由于两个操作具有不同的关联，您如何知道应该首先解析哪个表达式呢？答案是上一节中具有更高<strong class="jm io">运算符优先级</strong>的那个！在这种情况下,<code class="fe ml mm mn mb b">+</code>优先，所以它首先被评估。</p><p id="abef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mo">我已经在最后的注释中添加了更详细的解释，或者你可以</em> <a class="ae ki" href="http://Operator associativity" rel="noopener ugc nofollow" target="_blank"> <em class="mo">在这里阅读更多</em> </a> <em class="mo">。</em></p><h2 id="b875" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">理解我们的表达式树是如何计算的</h2><p id="0bf9" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">现在我们对这些概念有了一个概念，我们可以开始理解我们的问题了。有许多运营商在发挥作用，没有括号来澄清，当一切发生在我们弱小的人类思想。因此，让我们添加一些括号，列出所有使用的操作符，以及它们的优先级和结合性。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="1360" class="mf ky in mb b gy mg mh l mi mj"><strong class="mb io">(operator with variable x): (precedence) (associativity)</strong><br/>x++: 18 n/a<br/>x--: 18 n/a</span><span id="fe5c" class="mf ky in mb b gy mk mh l mi mj">++x: 17 r<br/>--x: 17 r</span><span id="48a1" class="mf ky in mb b gy mk mh l mi mj">+x: 17 r</span><span id="a4e6" class="mf ky in mb b gy mk mh l mi mj">*: 15 l</span><span id="3ca6" class="mf ky in mb b gy mk mh l mi mj">x + y: 14 l</span><span id="cd5c" class="mf ky in mb b gy mk mh l mi mj">= : 3 r</span></pre><h2 id="0436" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">括号</h2><p id="7844" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated"><em class="mo">这里值得一提的是，正确添加括号是很棘手的。我确保答案在每一点上都是正确的，但这并不保证我的括号总是正确的！如果有人知道自动添加括号的工具，请告诉我。</em></p><p id="a615" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们弄清楚事物被评估的顺序，并添加括号来显示。我将一步一步地展示我是如何得到最终结果的，简单地从优先级最高的操作符开始。</p><p id="9b2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">后缀</strong> <code class="fe ml mm mn mb b"><strong class="jm io">++</strong></code> <strong class="jm io">和</strong>后缀<code class="fe ml mm mn mb b"><strong class="jm io">--</strong></code></p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="7be3" class="mf ky in mb b gy mg mh l mi mj">const tree = ++d * d*b * <strong class="mb io">(b++)</strong> +<br/> + --d+ + +<strong class="mb io">(b--)</strong> +<br/> + +d*b+ +<br/> u</span></pre><p id="ed5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一元</strong> <code class="fe ml mm mn mb b"><strong class="jm io">+</strong></code> <strong class="jm io">，前缀</strong> <code class="fe ml mm mn mb b"><strong class="jm io">++</strong></code> <strong class="jm io">，前缀</strong> <code class="fe ml mm mn mb b"><strong class="jm io">--</strong></code></p><p id="65c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们有一个小问题，但是我将从评估一元<code class="fe ml mm mn mb b">+</code>操作符开始，直到我们到达问题点。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="38eb" class="mf ky in mb b gy mg mh l mi mj">const tree = ++d * d*b * (b++) +<br/> + --d+ <strong class="mb io">(+(+</strong>(b--)<strong class="mb io">))</strong> +<br/> <strong class="mb io">(+(+(</strong>d*b+ <strong class="mb io">(+<br/> u))))</strong></span></pre><p id="c07b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有一个棘手的问题。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="a9fb" class="mf ky in mb b gy mg mh l mi mj">const tree = ++d * d*b * (b++) +<br/><strong class="mb io"> + --d</strong>+ (+(+(b--))) +<br/> (+(+(d*b+ (+<br/> u))))</span></pre><p id="ac34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经突出显示了问题区域。<code class="fe ml mm mn mb b">--</code>和<code class="fe ml mm mn mb b"> +()</code>具有相同的优先级。那么我们如何知道按照哪个顺序进行评估呢？让我用更简单的方式来陈述这个问题</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="3139" class="mf ky in mb b gy mg mh l mi mj">let d = 10</span><span id="5399" class="mf ky in mb b gy mk mh l mi mj">const answer = + --d</span></pre><p id="cfcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住，这里的<code class="fe ml mm mn mb b">+</code>不是指加法，而是指一元加，或者正。就像你会想到<code class="fe ml mm mn mb b">-1</code>一样，只是它是<code class="fe ml mm mn mb b">+1</code>。</p><p id="3c96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">答案是我们从右向左求值，因为这个优先级的操作符是<strong class="jm io">右关联</strong>。</p><p id="d370" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们的表达式重写后变成了<code class="fe ml mm mn mb b">+ (--d).</code></p><p id="5a9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让你明白这一点，想象一下如果所有的操作员都是一样的。在这种情况下，<code class="fe ml mm mn mb b">+ +1</code>将与<code class="fe ml mm mn mb b">(+ (+1))</code>相同，遵循类似于<code class="fe ml mm mn mb b">1 — 1 — 1</code>与<code class="fe ml mm mn mb b">((1 — 1) — 1)</code>相同的逻辑。注意右关联运算符如何产生与左关联运算符相反的括号符号？</p><p id="2b4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将这个逻辑应用到我们表达式中的问题点，我们得到:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="b37d" class="mf ky in mb b gy mg mh l mi mj">const tree = ++d * d*b * (b++) +<br/><strong class="mb io"> (+ (--d)) </strong>+ (+(+(b--))) +<br/> (+(+(d*b+ (+<br/> u))))</span></pre><p id="494d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，填入最后一个<code class="fe ml mm mn mb b">++</code>的括号，我们得到:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="1e49" class="mf ky in mb b gy mg mh l mi mj">const tree = <strong class="mb io">(++d)</strong> * d*b * (b++) +<br/> (+ (--d)) + (+(+(b--))) +<br/> (+(+(d*b+ (+<br/> u))))</span></pre><p id="9c59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ml mm mn mb b"><strong class="jm io">Multiplication (*)</strong></code></p><p id="8bd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不得不再次处理结合律，但是这一次是用同一个操作符，并且都是左结合律。相比上一步，这应该是小菜一碟！</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="fe04" class="mf ky in mb b gy mg mh l mi mj">const tree = <strong class="mb io">((((++d) * d) * b) * </strong>(b++)<strong class="mb io">)</strong> +<br/> (+ (--d)) + (+(+(b--))) +<br/> (+(+(<strong class="mb io">(d*b)</strong> + (+u))))</span></pre><p id="0080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经到了可以开始真正评估事物的时候了。我们还可以为赋值操作符添加额外的括号，但是我认为这样会造成更多的混乱，所以我把它去掉了。注意，上面的表达式只是一个更复杂的<code class="fe ml mm mn mb b">x = a + b + c</code></p><p id="0678" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以取消一些一元操作符，但我现在将它们保留下来，以防它们很重要。</p><p id="de39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将表达式拆分成多个部分，我们可以理解各个求值步骤，并从那里开始。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="58c9" class="mf ky in mb b gy mg mh l mi mj">let b = 3, d = b, u = b;<br/> <br/>const treeA = ((((++d) * d) * b) * (b++))<br/>const treeB = (+ (--d)) + (+(+(b--)))<br/>const treeC = (+(+((d*b) + (+u))))</span><span id="1bbb" class="mf ky in mb b gy mk mh l mi mj">const tree = treeA + treeB + treeC</span></pre><p id="089d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经完成了这些，我们可以开始研究评估时的各种值。从treeA开始</p><h2 id="c583" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">TreeA</h2><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5236" class="mf ky in mb b gy mg mh l mi mj">let b = 3, d = b, u = b;</span><span id="8876" class="mf ky in mb b gy mk mh l mi mj">const treeA = (((++d) * d) * b) * (b++)</span></pre><p id="fe59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里首先要评估的是<code class="fe ml mm mn mb b">++d</code>，它将返回<code class="fe ml mm mn mb b">4</code>，并递增<code class="fe ml mm mn mb b">d</code></p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="4caa" class="mf ky in mb b gy mg mh l mi mj">// b = 3<br/>// d = 4</span><span id="0f1b" class="mf ky in mb b gy mk mh l mi mj">((4 * d) * b) * (b++)</span></pre><p id="c5e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，<code class="fe ml mm mn mb b">4*d</code>我们知道此时d是4，所以<code class="fe ml mm mn mb b">4*4</code>是16</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="3efc" class="mf ky in mb b gy mg mh l mi mj">// b = 3<br/>// d = 4</span><span id="e89d" class="mf ky in mb b gy mk mh l mi mj">(16 * b) * (b++)</span></pre><p id="a840" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时有趣的是，我们将在 b递增之前乘以b <strong class="jm io">，因为我们是从左到右求值的。<code class="fe ml mm mn mb b">16 * 3 = 48</code></strong></p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="1a20" class="mf ky in mb b gy mg mh l mi mj">// b = 3<br/>// d = 4</span><span id="c55b" class="mf ky in mb b gy mk mh l mi mj">48 * (b++)</span></pre><p id="6675" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前面我们谈到了<code class="fe ml mm mn mb b">++</code>如何比<code class="fe ml mm mn mb b">*</code>具有更高的运算符优先级，所以这可以写成<code class="fe ml mm mn mb b">48 * b++</code>，但是这里有更多的诡计，因为<code class="fe ml mm mn mb b">b++</code>的返回值是<strong class="jm io">pre-</strong>increment值，而不是post。因此，虽然b将以4结尾，但我们要乘以的值将是3。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="af8e" class="mf ky in mb b gy mg mh l mi mj">// b = 3<br/>// d = 4</span><span id="835e" class="mf ky in mb b gy mk mh l mi mj">48 * 3</span><span id="cbe6" class="mf ky in mb b gy mk mh l mi mj">// b = 4<br/>// d = 4</span></pre><p id="c969" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而<code class="fe ml mm mn mb b">48 * 3</code>是<code class="fe ml mm mn mb b">144</code>，所以一旦我们的第一部分被求值，b和d都是4，表达式结果是<code class="fe ml mm mn mb b">144</code></p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="0c57" class="mf ky in mb b gy mg mh l mi mj">let b = 4, d = 4, u = 3;<br/> <br/>const treeA = 144<br/>const treeB = (+ (--d)) + (+(+(b--)))<br/>const treeC = (+(+((d*b) + (+u))))</span><span id="65b4" class="mf ky in mb b gy mk mh l mi mj">const tree = treeA + treeB + treeC</span></pre><h2 id="e6c5" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">TreeB</h2><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="ed79" class="mf ky in mb b gy mg mh l mi mj">const treeB = (+ (--d)) + (+(+(b--)))</span></pre><p id="7373" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上，我可以看到一元操作符实际上没有做任何事情。如果我们把它们抵消掉，就可以大大简化表达式。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="fa49" class="mf ky in mb b gy mg mh l mi mj">// b = 4<br/>// d = 4</span><span id="42f9" class="mf ky in mb b gy mk mh l mi mj">const treeB = (--d) + (b--)</span></pre><p id="9eb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们以前见过这种把戏。<code class="fe ml mm mn mb b">--d</code>将返回给我们<code class="fe ml mm mn mb b">3</code>而<code class="fe ml mm mn mb b">b--</code>将返回给我们<code class="fe ml mm mn mb b">4</code>，在表达式求值时，这两个变量都将被赋值为3。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="3713" class="mf ky in mb b gy mg mh l mi mj">const treeB = 3 + 4</span><span id="15da" class="mf ky in mb b gy mk mh l mi mj">// b = 3<br/>// d = 3</span></pre><p id="3e5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在我们的问题看起来像这样:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="a012" class="mf ky in mb b gy mg mh l mi mj">let b = 3, d= 3, u = 3;<br/> <br/>const treeA = 144<br/>const treeB = 7<br/>const treeC = (+(+((d*b) + (+u))))</span><span id="04e3" class="mf ky in mb b gy mk mh l mi mj">const tree = treeA + treeB + treeC</span></pre><h2 id="2d8a" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">TreeC</h2><p id="f0c3" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">终于到了终点！</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="2dcc" class="mf ky in mb b gy mg mh l mi mj">// b = 3<br/>// d = 3<br/>// u = 3</span><span id="535a" class="mf ky in mb b gy mk mh l mi mj">const treeC = (+(+((d*b) + (+u))))</span></pre><p id="86be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从清除那些讨厌的一元操作符开始</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="533d" class="mf ky in mb b gy mg mh l mi mj">// b = 3<br/>// d = 3<br/>// u = 3</span><span id="20db" class="mf ky in mb b gy mk mh l mi mj">const treeC = (+(+((d*b) + u)))</span></pre><p id="d10f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个，但是我们必须小心括号等等</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="a559" class="mf ky in mb b gy mg mh l mi mj">// b = 3<br/>// d = 3<br/>// u = 3</span><span id="3f66" class="mf ky in mb b gy mk mh l mi mj">const treeC = (d*b) + u</span></pre><p id="fa5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上很容易。<code class="fe ml mm mn mb b">3 * 3</code>是<code class="fe ml mm mn mb b">9</code>，<code class="fe ml mm mn mb b">9 + 3</code>是<code class="fe ml mm mn mb b">12</code>，最后我们只剩下…</p><h1 id="ea1d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">答案！</h1><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="fc77" class="mf ky in mb b gy mg mh l mi mj">let b = 3, d= 3, u = 3;<br/> <br/>const treeA = 144<br/>const treeB = 7<br/>const treeC = 12</span><span id="e227" class="mf ky in mb b gy mk mh l mi mj">const tree = treeA + treeB + treeC</span></pre><p id="3b9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ml mm mn mb b">144 + 7 + 12</code>就是<code class="fe ml mm mn mb b">163</code>。答案是<code class="fe ml mm mn mb b">163</code>。</p><h1 id="1ee4" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="31ee" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">JavaScript可以给你带来许多奇怪而奇妙的方式。但是理解了语言是如何组合在一起的，你就能弄清楚事物为什么会这样。</p><p id="d910" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更一般地说，寻找解决方案的过程可能比答案更有启发性，你在这个过程中找到的小解决方案本身就是教学时刻。</p><p id="9228" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值得一提的是，我在使用浏览器控制台时检查了我的工作，并且更感兴趣的是逆向工程解决方案，而不是从基本原理解决它。</p><p id="1d09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使知道如何解决这个问题，在这个过程中仍然有许多语法歧义需要解决，我相信您在查看树时已经注意到了其中的许多歧义。我在下面提到了其中的一些，尽管每一个都值得写在自己的文章里！</p><p id="8c29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还想对https://twitter.com/AnthonyPAlicea,大声喊出来，没有他的课程，我永远也搞不清楚这些东西，还有https://twitter.com/tlakomy<a class="ae ki" href="https://twitter.com/tlakomy" rel="noopener ugc nofollow" target="_blank">首先提出这个问题。</a></p><h1 id="278c" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">笔记和奇怪的东西</h1><p id="d335" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">我把这个分开，试图保持整个问题解决流程的整洁，但是在这个过程中，我必须解决很多小问题。</p><h2 id="18d5" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">变量的顺序是如何被改变和使用的？</h2><p id="81a7" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">考虑一下这个</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="224f" class="mf ky in mb b gy mg mh l mi mj">let x = 10</span><span id="d739" class="mf ky in mb b gy mk mh l mi mj">console.log(x++ + x)</span></pre><p id="104e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有几个问题。控制台会记录什么，第二行的<code class="fe ml mm mn mb b">x</code>的值是什么？</p><p id="c07e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你的答案是一个数字，那么很抱歉，我骗了你。诀窍在于<code class="fe ml mm mn mb b">x++ + x</code>求值为<code class="fe ml mm mn mb b">(x++) + x</code>，JavaScript引擎求值左侧<code class="fe ml mm mn mb b">(x++)</code>时递增<code class="fe ml mm mn mb b">x</code>，所以到了<code class="fe ml mm mn mb b">+ x</code>，x的值是<code class="fe ml mm mn mb b">11</code>，而不是<code class="fe ml mm mn mb b">10</code>。</p><p id="ad0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更棘手的是，<code class="fe ml mm mn mb b">x++</code>返回什么值？</p><p id="4756" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经非常强烈地暗示了答案实际上是<code class="fe ml mm mn mb b">10</code>。*</p><p id="d744" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是<code class="fe ml mm mn mb b">x++</code>和<code class="fe ml mm mn mb b">++x</code>的区别。如果我们把操作符看作是它们的底层函数，它们看起来就像这样:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="ce8c" class="mf ky in mb b gy mg mh l mi mj">function ++x(x) {<br/>  const oldValue = x;<br/>  x = x + 1;<br/>  return oldValue;<br/>}</span><span id="d488" class="mf ky in mb b gy mk mh l mi mj">function x++(x) {<br/>  x = x + 1;<br/>  return x<br/>}</span></pre><p id="a9e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从这个角度来看，你可以理解</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="1cfe" class="mf ky in mb b gy mg mh l mi mj">let x = 10</span><span id="13a2" class="mf ky in mb b gy mk mh l mi mj">console.log(x++ + x)</span></pre><p id="381a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将意味着<code class="fe ml mm mn mb b">x++</code>返回<code class="fe ml mm mn mb b">10</code>，在<code class="fe ml mm mn mb b">+ x</code>被求值的点，它的值是<code class="fe ml mm mn mb b">11</code>。因此控制台将记录<code class="fe ml mm mn mb b">21</code>，x的值将是<code class="fe ml mm mn mb b">11</code>。</p><p id="db98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个相对简单的问题实际上指向了所有代码中的一个公共反模式，即当<strong class="jm io">表达式</strong>和<strong class="jm io">副作用</strong>混合时。<a class="ae ki" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p><p id="f9f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mo">*我正要说</em> <code class="fe ml mm mn mb b"><em class="mo">10</em></code> <em class="mo">！这里，但是有人会开一个析因玩笑，我已经在这件事上失去理智了)</em></p><h2 id="e4e1" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">你能让两个操作符有相同的优先级，但是有不同的关联吗？</h2><p id="0308" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">让我们一步一步来，忽略关联是否是一个真实的词。</p><p id="7a35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们就拿运算符<code class="fe ml mm mn mb b">+</code>和<code class="fe ml mm mn mb b">=</code>来概括一下吧。</p><p id="323b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在前一种情况下，<code class="fe ml mm mn mb b">a + b + c</code>被评估为<code class="fe ml mm mn mb b">(a + b) + c</code>，因为<code class="fe ml mm mn mb b">+</code>是左关联的。</p><p id="d53f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在后者中，<code class="fe ml mm mn mb b">a = b = c</code>被评估为<code class="fe ml mm mn mb b">a = (b = c)</code>，因为<code class="fe ml mm mn mb b">=</code>是右结合的。<em class="mo">注意</em> <code class="fe ml mm mn mb b"><em class="mo">=</em></code> <em class="mo">返回赋值变量的值，所以一旦表达式被求值，那么</em> <code class="fe ml mm mn mb b"><em class="mo">a</em></code> <em class="mo">将等于</em> <code class="fe ml mm mn mb b"><em class="mo">b</em></code> <em class="mo">的值。</em></p><p id="d9a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们用优先级替换操作数，</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="ed7f" class="mf ky in mb b gy mg mh l mi mj">a left b left c<!-- --> = <!-- -->(a left b) left c<br/>a right b right c = a right (b right c)</span><span id="60cb" class="mf ky in mb b gy mk mh l mi mj">but what about</span><span id="1f4f" class="mf ky in mb b gy mk mh l mi mj">a left b right c = ?<br/>a right b left c = ?</span></pre><p id="32bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看到第二个例子在逻辑上是不可能的了吗？<code class="fe ml mm mn mb b">a + b = c </code>之所以可能，只是因为<code class="fe ml mm mn mb b">+</code>优先于<code class="fe ml mm mn mb b">=</code>，所以解析器知道该做什么。如果两个操作符具有相同的优先级但不同的结合性，那么语法分析器就不可能决定做事情的顺序！</p><p id="cd98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以综上所述，没有。具有相同优先级的运算符不能有不同的关联度！</p><p id="4576" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有趣的是，你可以在F#中动态地改变一个函数的结合性，这就是为什么我能够谈论结合性而不会发疯！<a class="ae ki" href="https://fsharpforfunandprofit.com/posts/function-composition/" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p><p id="81df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注:我不会因为a离开b而感到难过。他们从一开始就是一对有毒的搭档。另一方面，c是一笔财富，不应该受到这样的伤害。</p><h2 id="b10b" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">一元运算符</h2><p id="2af5" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这里有一点很有趣，它来自于试图找出<code class="fe ml mm mn mb b">+n</code>和<code class="fe ml mm mn mb b">++n</code>的求值顺序。</p><p id="9567" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不能做<code class="fe ml mm mn mb b">-- -i</code>是因为<code class="fe ml mm mn mb b">—</code>返回一个数字，数字不能递增或递减，也不能做<code class="fe ml mm mn mb b">---i</code>是因为<code class="fe ml mm mn mb b">---</code>的含义不明确(是<code class="fe ml mm mn mb b">-- —</code>还是<code class="fe ml mm mn mb b">— --</code>？评论如下)但是你可以做:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="40b9" class="mf ky in mb b gy mg mh l mi mj">let i = 10</span><span id="ea95" class="mf ky in mb b gy mk mh l mi mj">console.log(-+-+-+-+-+--i)</span></pre><h2 id="daa3" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">非常令人困惑</h2><p id="857e" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">更棘手的问题之一是JavaScript中的<code class="fe ml mm mn mb b">+</code>的模糊性。相同的符号用于四种不同的功能，如下所示:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="2f06" class="mf ky in mb b gy mg mh l mi mj">let i = 10</span><span id="2669" class="mf ky in mb b gy mk mh l mi mj">console.log(i++ + + ++i)</span></pre><p id="bb21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个操作数都有自己的含义、运算符优先级和结合性。这让我想起了著名的字谜:</p><p id="e87a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo" rel="noopener ugc nofollow" target="_blank">水牛水牛水牛水牛水牛水牛水牛水牛水牛。</a></p><p id="505d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不会破坏答案，但我要说，我们的JavaScript等价物实际上更令人困惑一个数量级。</p><h2 id="59d5" class="mf ky in bd kz mp mq dn ld mr ms dp lh jv mt mu ll jz mv mw lp kd mx my lt mz bi translated">一元还是赋值？</h2><p id="9fa8" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated"><code class="fe ml mm mn mb b">+</code>既可以表示一元运算符，也可以表示赋值。初始问题在<code class="fe ml mm mn mb b">u</code>的情况下是哪个？像这样</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="5f90" class="mf ky in mb b gy mg mh l mi mj">... +<br/>u</span></pre><p id="8bd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，答案最终取决于…是什么。如果我们把它写成一行，</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="c1fb" class="mf ky in mb b gy mg mh l mi mj">... + u</span></pre><p id="92c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ml mm mn mb b">x + u</code>和<code class="fe ml mm mn mb b">x — + u</code>的答案是不同的。前者意味着加法，而后者意味着一元<code class="fe ml mm mn mb b">+</code>。弄清楚它的意思的唯一方法是弄清楚评估树的其余部分，直到只剩下一个操作符为止！</p></div></div>    
</body>
</html>