<html>
<head>
<title>Do strict equals do what we thought?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">严格的等号会做我们想的那样吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/do-strict-equals-do-what-we-thought-a818784a0be0?source=collection_archive---------8-----------------------#2020-08-17">https://javascript.plainenglish.io/do-strict-equals-do-what-we-thought-a818784a0be0?source=collection_archive---------8-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3590" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">将你的知识提升到高级水平！</h2><div class=""/><div class=""><h2 id="4619" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">松散的等式也检查你的类型</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ca229534d9ff7ef7dac7b3b853a6f458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9Eq61jxz1hB-HAwrI2LRA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@jstrippa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">James Harrison</a> on <a class="ae le" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="lf"><p id="280d" class="lg lh iq bd li lj lk ll lm ln lo lp dk translated">JavaScript将成为真正的函数式语言。</p><p id="9a96" class="lg lh iq bd li lj lq lr ls lt lu lp dk translated">— <em class="lv">道格拉斯·克洛克福特</em></p></blockquote><p id="31d2" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq lp ij bi translated">我在想如何开始这个故事，所以最后，我意识到道格拉斯是在明确地讲述JS的故事。他的预言似乎成真了。<strong class="ly ja"> JavaScript成为一种强大的函数式语言！</strong></p><p id="87a9" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">由于动态类型的强大，JS已经成功地应对了所有新的编程技术。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="faf3" class="nd ne iq bd nf ng nh ni nj nk nl nm nn kf no kg np ki nq kj nr kl ns km nt nu bi translated">双倍相等能解决我们的问题吗？</h1><p id="3bac" class="pw-post-body-paragraph lw lx iq ly b lz nv ka mb mc nw kd me mf nx mh mi mj ny ml mm mn nz mp mq lp ij bi translated">你有时可能会想，为什么算术运算符或条件语句没有问题，而equals却有问题。<strong class="ly ja">人们与之斗争的最大压力是平等检查。</strong></p><p id="5c97" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">在这个故事中，我想深入探讨一些与区分<strong class="ly ja">宽松</strong>和<strong class="ly ja">严格等于</strong>相关的问题。当我们比较' == '和' === '时，有一个大谎言:</p><blockquote class="lf"><p id="55e0" class="lg lh iq bd li lj lq lr ls lt lu lp dk translated">误区:' == '和' === '的区别在于' == '检查值(宽松相等)，而' === '检查类型中的值(严格相等)。</p></blockquote><p id="fbd2" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq lp ij bi translated">这种想法非常普遍。但很遗憾，这是不对的。如果你想理解这个过程以及为什么这是一个错误的断言，你必须理解你的代码。你必须开始像JavaScript那样思考。让我们来看看规格:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/f080d12e3bb3b4361317b6a0ffdf49e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9ht_Ox48Q5mnx167oLxhQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Abstract Equality Comparison (source: <a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" rel="noopener ugc nofollow" target="_blank">ECMAScript Standard</a>)</figcaption></figure><p id="8f21" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">这部分被称为<strong class="ly ja">抽象等式比较，</strong>它负责定义loose equals的工作方式。这是最可靠的证据，证明宽松的平等不仅检查价值。</p><p id="4418" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated"><strong class="ly ja">结论</strong>:第一条规则说，如果两个值具有相同的类型，那么它将执行严格的相等比较。</p><p id="d658" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">现在我们可以解开这个神话，这两个等式之间的区别是类型是否相同。不，那不是事实！他们都研究类型，但是使用这些知识的方式有点不同。</p><p id="e5a8" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">您必须记住，任何技术的第一个也是唯一的权威知识来源是文档。</p><p id="dfad" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">采用正确的思维模式是一件非常重要的事情。不要把时间浪费在看不靠谱的故事和双平等的书上。他们很少参考唯一可靠的来源- <strong class="ly ja">文献</strong>。</p><p id="771c" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">文档不难理解。这只是一堆条件语句，因为你是开发人员，所以你可以理解。下一个例子将把事实和谣言分开:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="53e1" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">在第一行，我们有一个由变量<code class="fe od oe of og b">person1</code>赋值的字符串<code class="fe od oe of og b">"Jamie"</code>。在下一行，我创建了第一个变量的副本。当我尝试宽松和严格的平等，它说，他们在两种情况下是平等的。事实证明，当类型匹配时，它们会执行三重相等。</p><p id="453e" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">结论:<strong class="ly ja">当类型匹配时，双等号和三等号是相同的。当类型匹配时，进行三重等于运算。</strong></p><p id="1475" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">尽可能将类型配对是一件极好的事情，但这并不意味着你不会有强制。强制是不可能避免的，但是你可以减少强制的次数。</p><p id="a2e4" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated"><strong class="ly ja">你必须设计清晰一致的代码。</strong>你写算法的时候要有感觉。对类型没有概念是不好的做法。即使你不知道，也不意味着它必须保持这种状态。在这种情况下，代码重新设计是最好的解决方案。</p><h1 id="1779" class="nd ne iq bd nf ng oh ni nj nk oi nm nn kf oj kg np ki ok kj nr kl ol km nt nu bi translated">三倍等于做一些优越的工作吗？</h1><p id="a177" class="pw-post-body-paragraph lw lx iq ly b lz nv ka mb mc nw kd me mf nx mh mi mj ny ml mm mn nz mp mq lp ij bi translated">你可能想知道三倍等于到底在做什么？它检查类型，就是这样。如果类型不同，值是什么时候并不重要。这是一种旁路，当类型不同时停止算法(返回<em class="om">假</em>)。</p><p id="f780" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">那么，两倍等于和三倍等于有什么区别呢？答案可能会让你大吃一惊:</p><blockquote class="lf"><p id="66d7" class="lg lh iq bd li lj lq lr ls lt lu lp dk translated">严格平等和宽松平等的真正区别在于我们是否会允许任何强制的发生。</p></blockquote><p id="ad16" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq lp ij bi translated">让我们来看一下文档，把事情弄清楚:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/8cf867dfb8e90da8f902fdb39c859948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_u29QMqHO8VmCHj6ioo8A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Strict Equality Comparison (source: <a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" rel="noopener ugc nofollow" target="_blank">ECMAScript Standard</a>)</figcaption></figure><p id="e634" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated"><strong class="ly ja">如果类型相同，严格相等比较做什么？它按照文档上说的做(上图)。例如:如果我们比较<em class="om"> NaN </em> s，它将返回<em class="om"> false </em>。下一个很好的例子是，如果我们比较零和负零，它将返回真值。</strong></p><p id="16d7" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">我们有一些需要考虑的注意事项(就像上面的两个例子)，但那只是在类型已经匹配的情况下。</p><p id="b0e2" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">结论:<strong class="ly ja">它们都检查类型，但是严格相等停止得更早。</strong></p><p id="3947" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">对于对象来说，情况有点不同。我举个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="46ee" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">我们有两个不同的对象。它们有什么不同，它们有什么相同的性质？它们不是相同的对象。</p><p id="4440" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">不要落入陷阱，不要被JS引擎所迷惑，它不是检查完整的对象(比较对象的结构)，而是比较变量指向的对象(引用)。我不确定任何一种语言除了身份比较之外还能做什么。</p><p id="44bb" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">如果<code class="fe od oe of og b">movie1</code>、<code class="fe od oe of og b">movie2</code>是同一物体的物体参照，则返回<em class="om">真</em>。在上面的例子中，情况并非如此，因为<strong class="ly ja">变量指向不同的对象</strong>。</p><p id="c0f0" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">在我们的示例中，结果是相同的。<strong class="ly ja">当类型不同时，宽松的等式将允许强制，而当类型相同时，严格的等式将禁止强制。</strong></p><h1 id="e08f" class="nd ne iq bd nf ng oh ni nj nk oi nm nn kf oj kg np ki ok kj nr kl ol km nt nu bi translated">澄清</h1><p id="b6eb" class="pw-post-body-paragraph lw lx iq ly b lz nv ka mb mc nw kd me mf nx mh mi mj ny ml mm mn nz mp mq lp ij bi translated">了解哪些机制参与了每个操作是至关重要的。问自己一个问题:我知道类型，我需要使用强制吗；有帮助吗？没有普遍的法律鼓励我们去判断是否使用强制手段。</p><p id="416e" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">有时，您必须考虑一些小问题，所以您可能会问自己:使用强制手段安全吗？你必须跳出思维定式。在我看来，在严格等同和宽松等同之间的选择关系到代码的可理解性和清洁性。</p><p id="56d8" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">使用triple equals表示您不知道在特定情况下使用哪种类型，使用triple equals是对潜在错误的一种保护。</p><p id="12bb" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated"><strong class="ly ja">我使用triple equals的唯一情况是在测试中，但作为一种临时解决方案。</strong>当我不确定哪种类型会起作用时，我会采取一种安全的方法，并使用三重等式来保护自己免受潜在的逻辑错误的影响。在我做了一些代码重构——解决了根问题之后，我回到测试，回到double equals。</p><p id="e63c" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated">了解您正在使用的类型通常是一种很好的做法，因为这样可以更好地理解代码，减少不可预测的情况。</p><p id="c828" class="pw-post-body-paragraph lw lx iq ly b lz mr ka mb mc ms kd me mf mt mh mi mj mu ml mm mn mv mp mq lp ij bi translated"><strong class="ly ja">结论:</strong>了解您在特定情况下使用的类型可获得更好的代码库。</p></div></div>    
</body>
</html>