<html>
<head>
<title>4 Object Methods You May Do Not Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能不知道的4个对象方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-object-methods-you-may-do-not-know-4c74721ef358?source=collection_archive---------12-----------------------#2020-12-02">https://javascript.plainenglish.io/4-object-methods-you-may-do-not-know-4c74721ef358?source=collection_archive---------12-----------------------#2020-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9901949d4c97f4ffc40b49f0bc2cedbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0LGOpi33Owie1OOk.jpeg"/></div></div></figure><h1 id="a0f2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">目标</h1><p id="906d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">JavaScript完全是关于对象的。类是JavaScript中最重要的数据类型。它通常用于存储各种键控集合和更复杂的实体。让我们找出4个有用但不为大多数人所知的对象方法</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="9066" class="jy jz iq bd ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv bi translated">1.Object.is()</h1><p id="5b36" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">EC6增加了一个叫做<code class="fe lu lv lw lx b">Object.is()</code>的辅助函数。<code class="fe lu lv lw lx b">Object.is()</code>方法确定两个值是否相同，与<code class="fe lu lv lw lx b">===</code>运算符略有不同</p><h2 id="5a8e" class="mk jz iq bd ka ml mm dn ke mn mo dp ki lh mp mq km ll mr ms kq lp mt mu ku mv bi translated"><strong class="ak"/><code class="fe lu lv lw lx b"><strong class="ak">===</strong></code><strong class="ak">和</strong> <code class="fe lu lv lw lx b"><strong class="ak">Object.is()</strong></code>的区别</h2><p id="62dc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">方法<code class="fe lu lv lw lx b">Object.is()</code>在几乎所有的意图和目的上与<code class="fe lu lv lw lx b">===</code>相同，只有两个关键的不同</p><p id="c075" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir"> 1_负0 </strong></p><p id="aa38" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">不寻常的JavaScript数字负零<code class="fe lu lv lw lx b">-0</code>通常被认为等于正零<code class="fe lu lv lw lx b">+0</code>，但它们在技术上是不同的值。<code class="fe lu lv lw lx b">Object.is()</code>可以区分它们，返回<code class="fe lu lv lw lx b">false</code>进行<code class="fe lu lv lw lx b">-0</code>和<code class="fe lu lv lw lx b">+0</code>的比较</p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="646e" class="mk jz iq lx b gy nj nk l nl nm">console.log(Object.is(-0, +0)) // false<br/>console.log(-0 === +0) // true</span></pre><p id="da17" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir"> 2_楠</strong></p><p id="f901" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">NaN表示“非数字”值，等效表示为<code class="fe lu lv lw lx b">NaN</code>或<code class="fe lu lv lw lx b">Number.NaN</code>。<code class="fe lu lv lw lx b"><strong class="ky ir">NaN</strong></code> <strong class="ky ir">是JavaScript </strong>中唯一不等于自身的数字，但使用<code class="fe lu lv lw lx b">Object.is()</code>时<code class="fe lu lv lw lx b">NaN</code>被认为是与自身相同的值</p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="e305" class="mk jz iq lx b gy nj nk l nl nm">console.log(Object.is(NaN, NaN)) // true</span><span id="0c66" class="mk jz iq lx b gy nn nk l nl nm">console.log(NaN === NaN) // false</span></pre><blockquote class="no"><p id="b1c9" class="np nq iq bd nr ns nt nu nv nw nx lt dk translated">有人会问这有用吗？？？</p></blockquote><h2 id="8c80" class="mk jz iq bd ka ml ny dn ke mn nz dp ki lh oa mq km ll ob ms kq lp oc mu ku mv bi translated"><code class="fe lu lv lw lx b">Object.is()</code>的真实例子</h2><p id="226c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir"> React代码</strong>使用<code class="fe lu lv lw lx b">Object.is</code>算法比较之前的状态和更新后的状态。所以…有用吧？</p><p id="9c48" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">我认为React代码使用了<code class="fe lu lv lw lx b">Object.is</code>,因为这可能会阻止React在给定一个<code class="fe lu lv lw lx b">NaN</code>值的情况下无限地重新呈现组件，而这个值使用<code class="fe lu lv lw lx b">===</code>永远不会等于它本身</p><h2 id="4d10" class="mk jz iq bd ka ml mm dn ke mn mo dp ki lh mp mq km ll mr ms kq lp mt mu ku mv bi translated">Object.is()的更多示例</h2><p id="ad6d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">test</code>和<code class="fe lu lv lw lx b">newTest</code>有相同的对象值，但引用不同；这就是为什么它是<code class="fe lu lv lw lx b">false</code>。鉴于，<code class="fe lu lv lw lx b">Object.is(test, cloneTest)</code>返回<code class="fe lu lv lw lx b">true</code>，因为<strong class="ky ir">值和参考值是相同的</strong></p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="72d0" class="mk jz iq lx b gy nj nk l nl nm">Object.is('objectis', 'objectis'); // true<br/>Object.is(0, -0); // false</span><span id="33d3" class="mk jz iq lx b gy nn nk l nl nm">const test = {a: 100};<br/>const cloneTest = test;<br/>const newTest = {a: 100};</span><span id="bb01" class="mk jz iq lx b gy nn nk l nl nm">console.log(Object.is(test, cloneTest)) // true;</span><span id="ab9c" class="mk jz iq lx b gy nn nk l nl nm">console.log(Object.is(test, newTest)) // false;</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="beff" class="jy jz iq bd ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv bi translated">2.Object.freeze()</h1><p id="dcdb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">Object.freeze()</code>方法<strong class="ky ir">冻结</strong>一个对象。<strong class="ky ir">一个被冻结的物体不能再被改变；</strong></p><p id="69eb" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">的好处</strong>的好处<code class="fe lu lv lw lx b"><strong class="ky ir">Object.freeze()</strong></code></p><p id="98a9" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">冻结对象</p><p id="990c" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">1_防止新属性被添加<strong class="ky ir">/<strong class="ky ir">或删除</strong></strong></p><p id="4482" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">2_防止更改现有属性的<strong class="ky ir">可枚举性、可配置性或可写性</strong></p><p id="1f00" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">3_防止现有属性的<strong class="ky ir">值</strong>被更改</p><p id="a642" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">4_防止其<strong class="ky ir">原型</strong>被更改</p><p id="96a2" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">与</strong>的比较<code class="fe lu lv lw lx b"><strong class="ky ir">Object.seal()</strong></code></p><p id="524e" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">用<code class="fe lu lv lw lx b">Object.seal()</code>密封的对象可以改变它们现有的属性。用<code class="fe lu lv lw lx b">Object.freeze()</code>冻结的对象中的现有属性被设为<strong class="ky ir">不可变</strong></p><p id="072e" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><code class="fe lu lv lw lx b"><strong class="ky ir">Object.freeze()</strong></code> <strong class="ky ir">例题</strong></p><p id="2202" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">尝试更改<code class="fe lu lv lw lx b">prop1</code>属性将会失败，我们将会得到以下错误<code class="fe lu lv lw lx b">Uncaught TypeError: Cannot assign to read only property prop1 of object #&lt;Object&gt;</code></p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="8e80" class="mk jz iq lx b gy nj nk l nl nm">const obj = {</span><span id="ce91" class="mk jz iq lx b gy nn nk l nl nm"> prop1: 'some string',</span><span id="bffb" class="mk jz iq lx b gy nn nk l nl nm"> prop2: 5,</span><span id="f5ae" class="mk jz iq lx b gy nn nk l nl nm">};</span><span id="6b2b" class="mk jz iq lx b gy nn nk l nl nm">const frozenObj = Object.freeze(obj);</span><span id="2b9e" class="mk jz iq lx b gy nn nk l nl nm">obj.prop1 = 'some other string' // uncaught TypeError</span></pre><p id="041f" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">检查物体是否冻结</strong></p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="211c" class="mk jz iq lx b gy nj nk l nl nm">const frozenObj = Object.freeze(obj);</span><span id="373b" class="mk jz iq lx b gy nn nk l nl nm">console.log(Object.isFrozen(frozenObj)) // true</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="42b6" class="jy jz iq bd ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv bi translated">3.Object.fromEntries()</h1><p id="6157" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是<code class="fe lu lv lw lx b">Object.entries</code>的反转。使用<code class="fe lu lv lw lx b">Object.fromEntries</code>，可以将<strong class="ky ir">数组</strong>转换为<strong class="ky ir">对象</strong></p><p id="a757" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><code class="fe lu lv lw lx b"><strong class="ky ir">Object.fromEntries()</strong></code> <strong class="ky ir">例题</strong></p><p id="64c4" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><code class="fe lu lv lw lx b">Object.fromEntries</code>将二维数组转换为对象；数组<code class="fe lu lv lw lx b">entries[i][0]</code>的第一个元素变成<code class="fe lu lv lw lx b">key</code>，数组<code class="fe lu lv lw lx b">entries[i][1]</code>的第二个元素变成一个值</p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="b6b6" class="mk jz iq lx b gy nj nk l nl nm">const entries = [</span><span id="7f0d" class="mk jz iq lx b gy nn nk l nl nm">   ['foo', 'bar'],</span><span id="72e4" class="mk jz iq lx b gy nn nk l nl nm">   ['baz', 42]</span><span id="1234" class="mk jz iq lx b gy nn nk l nl nm">];</span><span id="e558" class="mk jz iq lx b gy nn nk l nl nm">const obj = Object.fromEntries(entries);</span><span id="b2d4" class="mk jz iq lx b gy nn nk l nl nm">console.log(obj); //Object { foo: "bar", baz: 42 }</span></pre><p id="2ec1" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">数组作为一个值</strong></p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="5bd8" class="mk jz iq lx b gy nj nk l nl nm">const entries = [</span><span id="d567" class="mk jz iq lx b gy nn nk l nl nm">   ['foo', [1,2,3,4,5,6]],</span><span id="0af4" class="mk jz iq lx b gy nn nk l nl nm">   ['baz', 42]</span><span id="c96c" class="mk jz iq lx b gy nn nk l nl nm">];</span><span id="59fd" class="mk jz iq lx b gy nn nk l nl nm">const obj = Object.fromEntries(entries);</span><span id="7aea" class="mk jz iq lx b gy nn nk l nl nm">console.log(obj);// Object { foo: [ 1, 2, 3, 4, 5, 6 ], baz: 42 }</span></pre><p id="cb13" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">其他类型的类型错误</strong></p><p id="d75c" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><code class="fe lu lv lw lx b">Object.fromEntries()</code>的参数应该是可迭代的，如<strong class="ky ir">数组</strong>或<strong class="ky ir">映射。</strong>如果将其他数据类型传入<code class="fe lu lv lw lx b">Object.fromEntries</code>，将返回<strong class="ky ir">未捕获类型错误</strong></p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="4dd9" class="jy jz iq bd ka kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv bi translated">4.object . getownpropertydescriptors()</h1><p id="818a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">Object.getOwnPropertyNames()</code>方法返回在给定对象中直接找到的所有属性(包括不可枚举的属性)的数组</p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="2d0f" class="mk jz iq lx b gy nj nk l nl nm">const obj = {0: 'a', 1: 'b', 2: 'c'};<br/>const keys = Object.getOwnPropertyNames(obj);</span><span id="6dc2" class="mk jz iq lx b gy nn nk l nl nm">console.log(keys) // ['0', '1', '2']</span></pre><p id="684b" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">与</strong>的比较<code class="fe lu lv lw lx b"><strong class="ky ir">Object.keys()</strong></code></p><p id="60ab" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><code class="fe lu lv lw lx b">Object.getOwnPropertyNames(obj)</code></p><p id="2c9c" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">返回<strong class="ky ir">对象的所有属性</strong></p><p id="4ca1" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">鉴于<code class="fe lu lv lw lx b">Object.keys()</code></p><p id="894d" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">仅返回<strong class="ky ir">所有可枚举属性</strong></p><p id="1afe" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">换句话说，如果任何属性被设置为<code class="fe lu lv lw lx b">enumerable: false</code>，这两个方法将返回不同的输出</p><p id="e8a3" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">示例-当所有值都可以枚举时</strong></p><p id="ccdc" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">在这种情况下，输出将是相同的</p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="91e6" class="mk jz iq lx b gy nj nk l nl nm">const screen = { branch: 'Dell', size: '27inch' };</span><span id="99b9" class="mk jz iq lx b gy nn nk l nl nm">console.log(Object.getOwnPropertyNames(screen)); <br/>// ['branch', 'size']<br/>console.log(Object.keys(screen)); // ['branch', 'size']</span></pre><p id="5f06" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated"><strong class="ky ir">示例-当值不可枚举时</strong></p><p id="2fa2" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">让我们再定义一个名为<code class="fe lu lv lw lx b">resolution</code>的属性，并将其设置为<code class="fe lu lv lw lx b">enumerable: false</code></p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="b0bf" class="mk jz iq lx b gy nj nk l nl nm">Object.defineProperties(screen, { resolution: <br/>                         {enumerable: false,<br/>                          value: '2560 x 1440',<br/>                          },<br/>});</span></pre><p id="04ef" class="pw-post-body-paragraph kw kx iq ky b kz mw lb lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt ij bi translated">在这种情况下，由于<code class="fe lu lv lw lx b">resolution</code>具有<strong class="ky ir">enumerate:false，</strong>键“resolution”不会出现在<code class="fe lu lv lw lx b">Object.keys</code>方法中</p><pre class="nb nc nd ne gt nf lx ng nh aw ni bi"><span id="5880" class="mk jz iq lx b gy nj nk l nl nm">console.log(Object.getOwnPropertyNames(screen)); <br/>// ['branch', 'size', 'resolution']<br/>console.log(Object.keys(screen)); // ['branch', 'size']</span></pre><h1 id="d564" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="0e41" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您对JavaScript比较陌生，我建议您彻底学习对象数据类型。再说一遍，JavaScript是关于对象的，它们是JavaScript中最重要的数据类型。希望你喜欢JavaScript编码，如果你有任何问题，请留下评论。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/48dfdd7e39eab6c295b58acf64fe57cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ievzgIGK6JgKCJWo"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk">Photo by <a class="ae ok" href="https://unsplash.com/@mike_meyers?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mike Meyers</a> on <a class="ae ok" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>