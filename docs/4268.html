<html>
<head>
<title>The Simplicity Of Writing Pure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写纯函数的简单性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-pure-functions-af217690ce94?source=collection_archive---------12-----------------------#2020-11-29">https://javascript.plainenglish.io/writing-pure-functions-af217690ce94?source=collection_archive---------12-----------------------#2020-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="690b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript，React，Redux</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/0721b3ff262ab430e2353a27909e666f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNTgJiPVr1l6B8B7Y-Q9JQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@samaradoole?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Samara Doole</a> on <a class="ae ks" href="https://unsplash.com/s/photos/clear-water?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="942f" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">纯函数介绍</h2><p id="d151" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">纯函数由于其可预测性和重用的潜力，在函数式编程中作为构建块受到高度青睐。</p><p id="b29b" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">有几个特征将一个函数定义为“纯的”。</p><ol class=""><li id="788d" class="mn mo in lr b ls mi lv mj lc mp lg mq lk mr mh ms mt mu mv bi translated">如果给定相同的输入，你将得到相同的输出。</li><li id="7852" class="mn mo in lr b ls mw lv mx lc my lg mz lk na mh ms mt mu mv bi translated">没有副作用。</li></ol><h2 id="43f4" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">可预测的产量</h2><p id="822b" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">我们可以将一个参数传递给一个纯函数，并且知道无论我们运行这段代码多少次，我们都会得到相同的结果。请看下面这个例子。不管我们把x赋值给什么，我们都会把x的平方取回来。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="9095" class="kt ku in nc b gy ng nh l ni nj">function getSquare(x) {<br/> return x * x;<br/>}</span></pre><h2 id="ccfb" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">无副作用/独立</h2><p id="99ef" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">纯函数总是不可变的。他们不应该改变任何外部变量。考虑映射数组和返回新数组与使用。按()将新项目铲入现有数组。阶梯会改变原始数组，被认为是不纯的。改变共享状态的危险在于，另一个函数可能依赖于原始状态。现在它已经被改变了，这可能会引入一些可能难以追踪的错误。</p><h2 id="286f" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">纯度测试</h2><p id="3a26" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">让我们将这种洞察力付诸行动。<br/>这些例子哪个是纯的，哪个是不纯的？</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="8b2f" class="kt ku in nc b gy ng nh l ni nj">Option A:<br/>function double(x) {<br/>    return x + x;<br/>}<br/>function doubleAll(list) {<br/>    return list.map(double);<br/>}<!-- --> </span><span id="b1d7" class="kt ku in nc b gy nk nh l ni nj">Option B:<br/>function double(x) {<br/>    networkCall(x);<br/>    return x + x;<br/>}<br/><br/>function doubleAll(list) {<br/>    for (let i = 0; i &lt; list.length; i++) {<br/>        list[i] = double(list[i]);<br/>    }<br/>    return list;<br/>}</span></pre><p id="2fd3" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">答案:<br/>选项A是纯粹的！我们可以期望得到一个全新的数组，它是通过映射原始数组而创建的，但没有以任何方式改变它。</p><p id="d4c0" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">选项B是不纯的，因为它依赖于网络调用的输出，并且它循环遍历一个项目列表以返回一个改变的原始列表。如果任何其他函数依赖于该列表，这可能会导致我们的程序崩溃或不按我们预期的方式运行。</p><h2 id="8da4" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">反应和重复使用</h2><p id="8252" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">使用React时，您的应用程序可以由类组件和功能组件组合而成。不同之处在于，功能组件由纯功能组成，因此不包含任何状态。它们不应该改变任何外部或共享状态。尽可能实现功能组件是优化的首选，因为它们是最简单和最可重用的组件。同样值得注意的是，这些功能组件并不意味着包含生命周期方法。</p><p id="95d2" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">Redux的一个关键原则是，它需要纯函数来用任何传入的更改更新全局状态树。我们称这些纯函数为归约函数。它们采用前一个状态和我们提供的返回下一个状态的动作，保持前一个状态不变。</p><p id="ea0f" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在下图中，您可以看到我们如何在Redux中更新状态，而不改变原始状态。我们分派一个传递给reducer的动作。reducer获取当前状态的信息，并使用一个pure函数根据我们作为参数给出的动作用新状态更新存储。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/ed1f342d2d126f1c8af934edc9b20f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1svefYj4qCRCIDJeM3cj1w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="https://css-tricks.com/learning-react-redux/" rel="noopener ugc nofollow" target="_blank">Brad Westfall @ css-tricks.com</a></figcaption></figure><h2 id="b421" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">最后</h2><p id="2442" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated">根据Redux文档，“手工编写不可变的更新逻辑<em class="nm">是</em>困难的，并且在Redux用户中偶然改变状态是最常见的错误”。</p><p id="165f" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">有一个名为Immer的JavaScript库，它将我们的可变代码转换成可接受的纯函数。甚至有一种叫做createSlice的特殊方法，你可以使用它自动合并Immer。你可以在这里了解更多关于<a class="ae ks" href="https://redux.js.org/tutorials/essentials/part-2-app-structure" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="05d9" class="pw-post-body-paragraph lp lq in lr b ls mi jo lu lv mj jr lx lc mk lz ma lg ml mc md lk mm mf mg mh ig bi translated">在此之前，为了获得更优化、可重用的代码，在任何可能的地方熟悉识别和公式化纯函数都是值得的。</p><h2 id="aa1b" class="kt ku in bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">资源</h2><p id="adca" class="pw-post-body-paragraph lp lq in lr b ls lt jo lu lv lw jr lx lc ly lz ma lg mb mc md lk me mf mg mh ig bi translated"><a class="ae ks" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976" rel="noopener">什么是纯函数</a> <br/> <a class="ae ks" href="http://net-informations.com/js/iq/pure.htm" rel="noopener ugc nofollow" target="_blank">纯函数与不纯函数</a></p></div></div>    
</body>
</html>