<html>
<head>
<title>A Simple encryption library in Node.js with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中带有Typescript的简单加密库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-simple-encryption-library-in-node-js-with-typescript-d72c294998bf?source=collection_archive---------0-----------------------#2020-09-16">https://javascript.plainenglish.io/a-simple-encryption-library-in-node-js-with-typescript-d72c294998bf?source=collection_archive---------0-----------------------#2020-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6fca" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何对简单数据进行编码和加密</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ea15da77f9bf5ecd0603a41a5b751407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aTg3fjQ6uUQwHXRj"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@fifernando?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fidel Fernando</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c9a7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我不久前参与的一个项目中，我遇到了一个不是很独特的问题。它涉及到我们如何安全地传递可识别的用户信息，比如由Ruby中的第三方服务编码和加密的电话号码，以便解密和解码到我们的用户应用程序中。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="ac6f" class="lu lv in lq b gy lw lx l ly lz">//Link with encrypted token<br/>https://example.com?token=XXXXX</span></pre><p id="01ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Ruby使用<code class="fe ma mb mc lq b"><a class="ae ks" href="https://apidock.com/ruby/Array/pack" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">pack()</strong></a></code>和<code class="fe ma mb mc lq b"><a class="ae ks" href="https://apidock.com/ruby/String/unpack" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">unpack()</strong></a></code>方法访问底层的位和字节，为有符号和无符号的大端字节序提供了直接的处理。然而，Javascript存在不能正确处理大整数的问题，因为它只能存储最多53位的有符号或无符号整数。见<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" rel="noopener ugc nofollow" target="_blank">号。MAX_SAFE_INTEGER </a>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi md"><img src="../Images/d9b831b50d4742b4ccd0e8c47d8e0bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ykk7W3E9eCXEQuXw"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Austin Distel</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7763" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，我们共享同一个加密密钥，这个过程被称为对称加密。这意味着必须使用相同的加密密钥来解密数据。</p><p id="bd66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在该项目和某些应用中，我们希望对敏感数据进行编码和加密，我们还需要能够在需要时在应用中的任何地方对这些信息进行解码和解密，这样解密后的值就不会在确保数据完整性的过程中被更改。本质上:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="3f08" class="lu lv in lq b gy lw lx l ly lz">const value = 0123456789 // Initial value</span><span id="0578" class="lu lv in lq b gy me lx l ly lz">const token = encrypt(value) // Encrypted token</span><span id="4c9f" class="lu lv in lq b gy me lx l ly lz">const decryptedValue = decrypt(token) // Decrypted value</span><span id="554e" class="lu lv in lq b gy me lx l ly lz">value === decryptedValue // Must be TRUE</span></pre><p id="d2b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简单地使用<code class="fe ma mb mc lq b">Base64</code>编码，这将混淆和创建短令牌不是一个可靠的安全解决方案，因为<code class="fe ma mb mc lq b">Base64</code>字符串可以很容易地被解码。在这篇文章中，我将演示如何创建一个简单、安全和快速的对称加密解决方案来加密数据，并使用以下工具应用于任何应用程序，甚至作为简短、SEO友好的URL参数:-</p><ul class=""><li id="87f5" class="mf mg in kv b kw kx kz la lc mh lg mi lk mj lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a> —向JavaScript添加静态类型定义</li><li id="3b85" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" rel="noopener ugc nofollow" target="_blank">对称加密</a> —加密技术，使用相同的加密密钥对数据进行加密和解密</li><li id="9228" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://nodejs.org/api/crypto.html" rel="noopener ugc nofollow" target="_blank"> Crypto </a> —提供加密功能的内置Node.js模块</li><li id="9113" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://nodejs.org/api/buffer.html" rel="noopener ugc nofollow" target="_blank">Buffer</a>—JavaScript的<code class="fe ma mb mc lq b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">Uint8Array</strong></a></code>类的子类，用于字符编码和解码</li><li id="42ca" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated">使用<a class="ae ks" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>和<a class="ae ks" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>进行测试</li><li id="c6d6" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated">使用<a class="ae ks" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae ks" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>和<a class="ae ks" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>进行自动化测试、版本管理和软件包发布</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mt"><img src="../Images/ab88bb1c4487ad302fb32a77e028f6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*702OHWe79gL-thYX"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fotis Fotopoulos</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4e88" class="mu lv in bd mv mw mx my mz na nb nc nd jt ne ju nf jw ng jx nh jz ni ka nj nk bi translated">发展</h1><p id="91fb" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">你还需要在全球范围内安装<code class="fe ma mb mc lq b"><strong class="kv io">npm</strong></code>和/或<code class="fe ma mb mc lq b"><strong class="kv io">yarn</strong></code>。参见如何<a class="ae ks" href="https://classic.yarnpkg.com/en/docs/install/" rel="noopener ugc nofollow" target="_blank">安装纱线</a>和<a class="ae ks" href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm" rel="noopener ugc nofollow" target="_blank"> NPM </a>。我也更喜欢使用NVM来管理我的节点版本。</p><p id="22b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们创建项目文件夹并设置typescript:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="26fb" class="lu lv in lq b gy lw lx l ly lz">$ mkdir encrypt-decrypt-library<br/>$ cd encrypt-decrypt-library</span></pre><p id="c681" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为项目初始化<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="4c6d" class="lu lv in lq b gy lw lx l ly lz">$ yarn init -y</span></pre><p id="361b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要安装Typescript作为开发依赖项。这是因为我们将把我们的Typescript代码编译成JavaScript用于我们的产品构建。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="88f9" class="lu lv in lq b gy lw lx l ly lz">$ yarn add -D typescript</span></pre><p id="e2e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要安装<code class="fe ma mb mc lq b"><strong class="kv io">ts-node</strong></code>,使我们能够执行类型脚本文件，而不需要编译它们，还有<code class="fe ma mb mc lq b"><strong class="kv io">@types/node</strong></code>。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="f050" class="lu lv in lq b gy lw lx l ly lz">// TypeScript execution for node<br/>$ yarn add -D ts-node @types/node</span></pre><p id="8210" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要为我们的Typescript配置添加一个<code class="fe ma mb mc lq b"><strong class="kv io">tsconfig.json</strong></code>文件到项目的根目录。我们如下初始化一个<code class="fe ma mb mc lq b"><strong class="kv io">tsconfig.json</strong></code>文件:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="ff08" class="lu lv in lq b gy lw lx l ly lz">$ yarn tsc --init --rootDir src --outDir dist</span></pre><p id="e74b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将在项目的根目录下生成一个初始的<code class="fe ma mb mc lq b"><strong class="kv io">tsconfig.json</strong></code>文件，包含可能的配置选项，不重要的选项被注释掉。我已将此文件更新如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1a70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要为我们的库安装一些额外的包。注意，NPM的<a class="ae ks" href="https://www.npmjs.com/package/crypto" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> crypto </strong> </a>模块已经被弃用，因为它现在是一个内置的节点模块。这个模块为我们提供了加密功能，如OpenSSL的散列、加密、解密、签名、验证和HMAC函数。</p><p id="1193" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将使用<a class="ae ks" href="https://nodejs.org/api/buffer.html" rel="noopener ugc nofollow" target="_blank"> Buffer </a>类来读写无符号64位整数，因为JavaScript的最大安全整数<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" rel="noopener ugc nofollow" target="_blank">为53位，我们的库必须能够处理64位big endian，尤其是当我们需要加密和解密大整数(如电话号码)时。</a></p><p id="d506" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还需要安装<a class="ae ks" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>来将环境变量从<code class="fe ma mb mc lq b"><strong class="kv io">.env</strong></code>文件加载到<code class="fe ma mb mc lq b"><strong class="kv io">process.env</strong></code>中。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="4ed6" class="lu lv in lq b gy lw lx l ly lz">$ yarn add -D dotenv</span></pre><p id="3e81" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要创建我们的<code class="fe ma mb mc lq b"><strong class="kv io">src</strong></code>目录，然后我们的库文件如下:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="b382" class="lu lv in lq b gy lw lx l ly lz">$ mkdir src<br/>$ touch src/encryption.ts</span></pre><p id="2444" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还需要创建一个<code class="fe ma mb mc lq b"><strong class="kv io">.env</strong></code>文件来存储我们的环境变量和<code class="fe ma mb mc lq b"><a class="ae ks" href="https://gist.github.com/s-barrah/a85649c4660bf5adfc6b5ecb110661ad" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">.env.example</strong></a></code>文件来放置<code class="fe ma mb mc lq b"><a class="ae ks" href="https://gist.github.com/s-barrah/7503fd5bd92b182f62c549243da3656e" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">.env</strong></a></code>变量的所有键。出于安全原因，在<code class="fe ma mb mc lq b"><a class="ae ks" href="https://gist.github.com/s-barrah/333a4ea0c8e47e8f53bc0a99b9a3bb17" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">.gitignore</strong></a></code>文件中必须忽略<code class="fe ma mb mc lq b"><strong class="kv io">.env</strong></code>文件，以防止我们的环境变量进入源代码控制。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="e9f2" class="lu lv in lq b gy lw lx l ly lz">$ touch .env .env.example .gitignore</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Encryption Key as Hex value</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cc8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们通过更新<code class="fe ma mb mc lq b"><strong class="kv io">encryption.ts</strong></code>创建我们的加密类，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9760" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在浏览器上，Javascript提供了两个解码和编码base64字符串的函数，<code class="fe ma mb mc lq b"><strong class="kv io">btoa()</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">atob()</strong></code>，参见<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/Base64" rel="noopener ugc nofollow" target="_blank"> Base64 </a>。由于我们的代码在浏览器之外运行，并且由于与编码和解码UTF-16位<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMString" rel="noopener ugc nofollow" target="_blank"> DOMString </a>相关的问题，我们将使用<a class="ae ks" href="https://nodejs.org/api/buffer.html" rel="noopener ugc nofollow" target="_blank"> Buffer </a>类(包括<code class="fe ma mb mc lq b"><a class="ae ks" href="https://nodejs.org/api/buffer.html#buffer_buf_writebiguint64be_value_offset" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">writeBigUInt64BE()</strong></a></code>和<code class="fe ma mb mc lq b"><a class="ae ks" href="https://nodejs.org/api/buffer.html#buffer_buf_readbiguint64be_offset" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">readBigUInt64BE()</strong></a></code>方法)将64位大整数编码和解码为大端字节，反之亦然:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="8706" class="lu lv in lq b gy lw lx l ly lz"><em class="ns">// allocate Buffer instance</em><br/>const buf = Buffer.<em class="ns">allocUnsafe</em>(8);</span><span id="b728" class="lu lv in lq b gy me lx l ly lz"><em class="ns">// Write value to Buffer instance at the specified offset as big-endian.<br/></em>buf.writeBigUInt64BE(BigInt(value));</span><span id="143b" class="lu lv in lq b gy me lx l ly lz"><em class="ns">// Read an unsigned, big-endian 64-bit integer from the Buffer instance at the specified offset<br/>// and returns as a string<br/></em>buf.readBigUInt64BE(0).toString();</span></pre><p id="fea0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们还需要在我们的<code class="fe ma mb mc lq b"><strong class="kv io">encrypt()</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">decrypt()</strong></code>函数中实现加密功能。我已经更新了<strong class="kv io">加密</strong>类<strong class="kv io">T21如下:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d0f4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为此，我们使用内置节点<a class="ae ks" href="https://nodejs.org/api/crypto.html" rel="noopener ugc nofollow" target="_blank"> Crypto库</a>并实现<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">Crypto . createcipheriv()</strong></a>和<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv_options" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">Crypto . createdecipheriv()</strong></a>方法，分别使用以下参数创建并返回一个<code class="fe ma mb mc lq b"><strong class="kv io">Cipher</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">Decipher</strong></code>实例:</p><ul class=""><li id="1372" class="mf mg in kv b kw kx kz la lc mh lg mi lk mj lo mk ml mm mn bi translated"><code class="fe ma mb mc lq b"><strong class="kv io">algorithm</strong></code> —使用的底层算法，基于OpenSSL</li><li id="e505" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><code class="fe ma mb mc lq b"><strong class="kv io">key</strong></code> —算法使用的原始密钥</li><li id="3356" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><code class="fe ma mb mc lq b"><strong class="kv io">iv</strong></code> — <a class="ae ks" href="https://en.wikipedia.org/wiki/Initialization_vector" rel="noopener ugc nofollow" target="_blank">初始化向量</a></li></ul><p id="c90b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了加密数据，我们使用<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">crypto . createcipheriv()</strong></a>方法创建一个<code class="fe ma mb mc lq b"><strong class="kv io">Cipher</strong></code>实例，然后使用<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_cipher_update_data_inputencoding_outputencoding" rel="noopener ugc nofollow" target="_blank"> cipher.update() </a>和<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_cipher_final_outputencoding" rel="noopener ugc nofollow" target="_blank"> cipher.final() </a>方法生成加密的数据。为了解密数据，我们使用<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv_options" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">crypto . createdecipheriv()</strong></a>方法创建一个<code class="fe ma mb mc lq b"><strong class="kv io">Decipher</strong></code>实例，并使用<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_decipher_update_data_inputencoding_outputencoding" rel="noopener ugc nofollow" target="_blank"> decipher.update() </a>和<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_decipher_final_outputencoding" rel="noopener ugc nofollow" target="_blank"> decipher.final() </a>方法生成未加密的数据。关于<code class="fe ma mb mc lq b"><strong class="kv io">crypto</strong></code>方法和选项的更多信息，请参见<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options" rel="noopener ugc nofollow" target="_blank"> CreateCipherIV </a>和<a class="ae ks" href="https://nodejs.org/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv_options" rel="noopener ugc nofollow" target="_blank"> CreateDecipherIV </a>。</p><p id="f9ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的<code class="fe ma mb mc lq b"><strong class="kv io">encrypt()</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">decrypt()</strong></code>方法都使用<a class="ae ks" href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" rel="noopener ugc nofollow" target="_blank">对称加密</a>算法，确保用于加密数据的相同加密密钥必须用于解密数据。了解有关对称加密算法的更多信息。接下来，我们需要向我们的库添加一些测试。</p><h2 id="66d3" class="lu lv in bd mv nt nu dn mz nv nw dp nd lc nx ny nf lg nz oa nh lk ob oc nj od bi translated">试验</h2><p id="500e" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">为了向我们的库添加测试，我们需要安装一些依赖项，即<a class="ae ks" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>和<a class="ae ks" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> Chai </a>:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="a3a9" class="lu lv in lq b gy lw lx l ly lz">$ yarn add -D mocha @types/mocha chai @types/chai</span></pre><p id="56aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们需要为我们的<code class="fe ma mb mc lq b"><strong class="kv io">encrypt</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">decrypt</strong></code>方法添加一些测试。首先，我们需要在项目的根目录下创建一个<code class="fe ma mb mc lq b"><strong class="kv io">tests</strong></code>文件夹。这个文件夹将包含我们的测试文件。接下来，我们创建一个测试文件，<code class="fe ma mb mc lq b"><strong class="kv io">encryption.test.ts</strong></code>:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9059" class="lu lv in lq b gy lw lx l ly lz">$ mkdir tests<br/>$ touch tests/encryption.test.ts</span></pre><p id="fbd3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">更新<code class="fe ma mb mc lq b"><strong class="kv io">encryption.test.ts</strong></code>文件如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9446" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe ma mb mc lq b"><strong class="kv io">ALGORITHM</strong></code>、<code class="fe ma mb mc lq b"><strong class="kv io">ENCRYPTION_KEY</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">SALT</strong></code>是我们设置的环境变量。<code class="fe ma mb mc lq b">env</code>文件。</p><p id="43a9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要用我们的<code class="fe ma mb mc lq b"><strong class="kv io">test</strong></code>命令更新我们的<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>中的<code class="fe ma mb mc lq b"><strong class="kv io">scripts</strong></code>属性:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="51c3" class="lu lv in lq b gy lw lx l ly lz"><strong class="lq io">// </strong>package.json</span><span id="bf2a" class="lu lv in lq b gy me lx l ly lz"><strong class="lq io">"scripts": {<br/>  "test": "./node_modules/.bin/mocha \"tests/**/*.ts\" --require ts-node/register --require dotenv/config"<br/>},</strong></span></pre><p id="07a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们能够定义在我们的<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>文件的<code class="fe ma mb mc lq b"><strong class="kv io">scripts</strong></code>属性中运行的节点脚本。</p><p id="1de5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用节点CLI参数运行测试——Mocha需要<code class="fe ma mb mc lq b"><strong class="kv io">ts-node</strong></code>,这样我们就可以执行Typescript测试文件，而不需要编译它们。我们通过使用<code class="fe ma mb mc lq b"><strong class="kv io">ts-node/register</strong></code>注册<code class="fe ma mb mc lq b"><strong class="kv io">ts-node</strong></code>加载器。我们还指定了测试文件的路径。它将运行与模式匹配的<code class="fe ma mb mc lq b"><strong class="kv io">tests</strong></code>文件夹中的每个测试文件。它还需要<code class="fe ma mb mc lq b"><strong class="kv io">dotenv/config</strong></code>，这允许我们使用在<code class="fe ma mb mc lq b"><strong class="kv io">.env</strong></code>文件中设置的变量。</p><p id="74ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要开始测试，我们只需在命令行中运行<code class="fe ma mb mc lq b"><strong class="kv io">yarn run test</strong></code>。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="36f6" class="lu lv in lq b gy lw lx l ly lz">$ yarn run test</span><span id="75cb" class="lu lv in lq b gy me lx l ly lz"><strong class="lq io">yarn run v1.22.4</strong></span><span id="e24b" class="lu lv in lq b gy me lx l ly lz">$ ./node_modules/.bin/mocha "tests/**/*.ts" --require ts-node/register --require dotenv/config</span><span id="c0c1" class="lu lv in lq b gy me lx l ly lz">Encryption<br/>    Ensuring encrypting and decrypting of string and number<br/>      ✓ should encrypt and decrypt the string correctly<br/>      ✓ should encrypt and decrypt the number as a big integer correctly<br/>      ✓ should encrypt and decrypt the number as a string correctly<br/>    Ensure decrypting of Big Integer token into a valid number<br/>      ✓ should decrypt the encoded slug to a Big Integer correctly<br/>    Ensure decrypting of string token into a valid string or number<br/>      ✓ should decrypt the encoded slug to a valid string correctly<br/>    Ensure decrypting of an 8-byte Big integer token into a valid number<br/>      ✓ should decrypt the encoded slug to a Big Integer correctly<br/>    Ensure validation of encrypt or decrypt methods <br/>      ✓ should return an error message if encrypt has no value<br/>      ✓ should return an error message if decrypt has no value<br/>    Ensure validation of library with no configuration<br/>      ✓ should fail to encrypt the string correctly<br/>      ✓ should fail to decrypt the string correctly</span><span id="594c" class="lu lv in lq b gy me lx l ly lz">10 passing (25ms)</span></pre><h2 id="3c11" class="lu lv in bd mv nt nu dn mz nv nw dp nd lc nx ny nf lg nz oa nh lk ob oc nj od bi translated">林挺</h2><p id="377d" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">为了确保我们的库中有一个清晰一致的编码约定，添加林挺是很重要的。林挺通过强制执行代码风格、识别、报告和修复我们代码中的任何不一致和错误来帮助开发。对于我们的加密库，我选择了使用<a class="ae ks" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> ESLint </strong> </a>，因为它同时支持JavaScript和TypeScript。</p><p id="c16b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，安装所有必需的开发依赖项:</p><ul class=""><li id="ff59" class="mf mg in kv b kw kx kz la lc mh lg mi lk mj lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.npmjs.com/package/eslint" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">诚信通</strong> </a> —诚信通林挺图书馆</li><li id="6d7b" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.npmjs.com/package/@typescript-eslint/parser" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">@ typescript-ESLint/parser</strong></a>—ESLint的TypeScript解析器</li><li id="5f93" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.npmjs.com/package/@typescript-eslint/eslint-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">@ TypeScript-eslint/ESLint-plugin</strong></a>—具有类型脚本特定ESLint规则的插件</li></ul><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="5c5d" class="lu lv in lq b gy lw lx l ly lz">// Install ESLint and plugins<br/>$ yarn add -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin</span></pre><p id="2942" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还需要安装<a class="ae ks" href="https://www.npmjs.com/package/prettier" rel="noopener ugc nofollow" target="_blank">更漂亮的</a>，它与<a class="ae ks" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>配合得非常好，在处理代码格式化方面非常棒。</p><ul class=""><li id="df6b" class="mf mg in kv b kw kx kz la lc mh lg mi lk mj lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.npmjs.com/package/prettier" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"/></a>—核心漂亮库</li><li id="53f1" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.npmjs.com/package/eslint-config-prettier" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">eslint-config-appellister</strong></a><strong class="kv io"/>—禁用可能与appellister冲突的ESLint规则</li><li id="cb8c" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.npmjs.com/package/eslint-plugin-prettier" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">eslint-plugin-appellister</strong></a>—作为ESLint规则运行起来更漂亮</li></ul><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="248c" class="lu lv in lq b gy lw lx l ly lz">// Install Prettier and plugins<br/>$ yarn add -D prettier eslint-config-prettier eslint-plugin-prettier</span><span id="b8de" class="lu lv in lq b gy me lx l ly lz">// Installs husky and lint<br/>$ yarn add -D husky lint-staged</span></pre><p id="7441" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还安装了lint-staged<a class="ae ks" href="https://github.com/okonet/lint-staged#readme" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"/></a>，确保文件在提交前运行林挺。这确保了提交给GIT的所有文件没有任何林挺或格式错误。<a class="ae ks" href="https://github.com/typicode/husky#readme" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> Husky </strong> </a>与lint-staged结合使用，使我们能够在预提交时运行指定的林挺命令，并有助于使git挂钩更容易。你可以在这里阅读更多关于<a class="ae ks" href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" rel="noopener ugc nofollow" target="_blank"> Git钩子的内容。</a></p><p id="6990" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们需要为ESLint设置一个配置文件:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c585" class="lu lv in lq b gy lw lx l ly lz">$ npx eslint --init</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/e048a9dbdaf06ecfe8162212aa75e9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxOnxk-DN5hBQ_F2p8OrvQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">ESLint init</figcaption></figure><p id="1dfb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将生成一个配置文件<code class="fe ma mb mc lq b">.<strong class="kv io">eslintrc.js</strong></code>。我对我们的插件和规则做了一些修改:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7042" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，创建一个<code class="fe ma mb mc lq b">.<strong class="kv io">eslintignore</strong></code>文件，告诉ESLint要忽略的目录或文件，并添加以下内容:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="095f" class="lu lv in lq b gy lw lx l ly lz">node_modules<br/>dist<br/>tests<br/>coverage<br/>styleguide.config.js</span><span id="757f" class="lu lv in lq b gy me lx l ly lz">src/**/*.test.tsx<br/>src/**/*.md<br/>src/serviceWorker.ts</span></pre><p id="a2f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过将lint命令添加到<code class="fe ma mb mc lq b"><strong class="kv io">scripts</strong></code>属性来更新我们的<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="31ee" class="lu lv in lq b gy lw lx l ly lz">// <strong class="lq io">package.json</strong></span><span id="6e42" class="lu lv in lq b gy me lx l ly lz"><strong class="lq io">"scripts": {<br/>  ...<br/>  "lint": "eslint 'src/**/*.{js,ts}' --quiet --fix"<br/>},</strong></span></pre><p id="90cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上述脚本可以使用<code class="fe ma mb mc lq b"><strong class="kv io">npm run lint</strong></code>或<code class="fe ma mb mc lq b"><strong class="kv io">yarn lint</strong></code>从命令行运行。该命令将通过所有的<code class="fe ma mb mc lq b">.js</code>和<code class="fe ma mb mc lq b">.ts</code>文件运行ESLint。它将自动修复任何ESLint错误，但任何其他错误都将在命令行中打印出来。</p><p id="da26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了配置<code class="fe ma mb mc lq b"><strong class="kv io">lint-staged</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">husky</strong></code>，我们还向<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>添加了以下配置:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="1e24" class="lu lv in lq b gy lw lx l ly lz">// package.json</span><span id="6136" class="lu lv in lq b gy me lx l ly lz"><strong class="lq io">"husky": {<br/>  "hooks": {<br/>    "pre-commit": "lint-staged"<br/>  }<br/>},<br/>"lint-staged": {<br/>  "src/**/*.{js,ts}": [<br/>    "prettier --single-quote --write",<br/>    "eslint --fix"<br/>  ]<br/>},</strong></span></pre><p id="f4e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了上面的配置，每当对git进行提交时，<code class="fe ma mb mc lq b"><strong class="kv io">lint-staged</strong></code>将在任何具有匹配扩展名的暂存文件上运行得更漂亮和ESLint。它将自动修复任何可以修改的错误，并将它们添加到当前提交中。但是，如果存在无法自动修复的林挺错误，它将会失败。在尝试再次提交代码之前，需要手动修复这些错误。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/2a56f0141e8024b3e4b8ada7974b855a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozUqXJG8rsR2HI6HyzgKVA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Husky -pre-commit</figcaption></figure><h1 id="1eb4" class="mu lv in bd mv mw mx my mz na nb nc nd jt ne ju nf jw ng jx nh jz ni ka nj nk bi translated">生产</h1><p id="3989" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">要将我们的加密库用作NPM模块，我们需要导出我们的加密类，然后将我们的Typescript文件编译成JavaScript。</p><p id="44e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们在<code class="fe ma mb mc lq b"><strong class="kv io">src</strong></code>文件夹中创建导出文件<code class="fe ma mb mc lq b"><strong class="kv io">index.ts</strong></code>，如下所示:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="2cb7" class="lu lv in lq b gy lw lx l ly lz">$ touch src/index.ts</span></pre><p id="6c5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并导出我们的加密类，如下所示:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="82db" class="lu lv in lq b gy lw lx l ly lz">import Encryption from "./encryption";<br/><br/>export default Encryption;</span></pre><p id="4e18" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了生产，我们将一个<code class="fe ma mb mc lq b"><strong class="kv io">build</strong></code>脚本添加到我们的<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>的<code class="fe ma mb mc lq b"><strong class="kv io">scripts</strong></code>属性中:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="8953" class="lu lv in lq b gy lw lx l ly lz">// package.json</span><span id="e13a" class="lu lv in lq b gy me lx l ly lz"><strong class="lq io">"scripts": {<br/>  ...<br/>  "build": "NODE_ENV=production tsc"<br/>},</strong></span></pre><p id="60da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe ma mb mc lq b"><strong class="kv io">tsconfig.json</strong></code>文件中编译器选项的<code class="fe ma mb mc lq b"><strong class="kv io">rootDir</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">outDir</strong></code>属性指定了输入文件的根目录和编译后文件的输出目录。运行<code class="fe ma mb mc lq b"><strong class="kv io">yarn build</strong></code>会将TypeScript文件编译成JavaScript文件放在<code class="fe ma mb mc lq b"><strong class="kv io">dist</strong></code>文件夹中。</p><p id="bed5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还需要安装<code class="fe ma mb mc lq b"><a class="ae ks" href="https://www.npmjs.com/package/rimraf" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">rimraf</strong></a></code> dev依赖项，它的作用类似于<code class="fe ma mb mc lq b"><strong class="kv io">rm -rf</strong></code>命令。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="a61a" class="lu lv in lq b gy lw lx l ly lz">$ yarn add -D rimraf</span></pre><p id="b2c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们通过更新我们的<code class="fe ma mb mc lq b">build</code>脚本来更新<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>，并添加<code class="fe ma mb mc lq b"><strong class="kv io">main</strong></code>和<code class="fe ma mb mc lq b"><strong class="kv io">module</strong></code>属性来设置我们的库的入口点，这是我们编译的Javascript文件，而<code class="fe ma mb mc lq b"><strong class="kv io">types</strong></code>属性指向我们的Typescript声明入口文件:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c49d" class="lu lv in lq b gy lw lx l ly lz">// package.json</span><span id="e545" class="lu lv in lq b gy me lx l ly lz"><strong class="lq io">"scripts": {<br/>  ...<br/>  "build": "</strong><strong class="lq io">rimraf ./dist &amp;&amp; </strong><strong class="lq io">NODE_ENV=production tsc"<br/>},<br/>......<br/>"main": "dist/index.js",<br/>"module": "dist/index.js",<br/>"types": "dist/index.d.ts"</strong></span></pre><p id="002f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，当我们运行<code class="fe ma mb mc lq b"><strong class="kv io">yarn build</strong></code>时，<code class="fe ma mb mc lq b"><strong class="kv io">rimraf</strong></code>将在TypeScript编译器向<code class="fe ma mb mc lq b"><strong class="kv io">dist</strong></code>发出新代码之前删除我们旧的<code class="fe ma mb mc lq b"><strong class="kv io">dist</strong></code>文件夹。</p><h2 id="7b2d" class="lu lv in bd mv nt nu dn mz nv nw dp nd lc nx ny nf lg nz oa nh lk ob oc nj od bi translated">证明文件</h2><p id="7f16" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">包含可靠的文档来帮助我们跟踪应用程序的各个方面总是很重要的。它有助于提高代码的质量，并使其更易于进一步开发、维护和知识转移。</p><p id="8f72" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要在项目的根目录下创建一个<code class="fe ma mb mc lq b"><strong class="kv io">README.md</strong></code>文件:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9b00" class="lu lv in lq b gy lw lx l ly lz">$ touch README.md</span></pre><p id="b698" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并更新如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="462c" class="lu lv in bd mv nt nu dn mz nv nw dp nd lc nx ny nf lg nz oa nh lk ob oc nj od bi translated">出版</h2><p id="8c05" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">在发布我们的库之前，我们希望从最终的包中排除某些文件。我们将通过向我们的<code class="fe ma mb mc lq b"><strong class="kv io">package.json</strong></code>添加一个<code class="fe ma mb mc lq b"><strong class="kv io">files</strong></code>属性来实现这一点，该属性告诉<a class="ae ks" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>哪些<code class="fe ma mb mc lq b"><strong class="kv io">files</strong></code>和/或<code class="fe ma mb mc lq b"><strong class="kv io">directories</strong></code>要包含在我们的包中:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c13b" class="lu lv in lq b gy lw lx l ly lz">// package.json</span><span id="7743" class="lu lv in lq b gy me lx l ly lz"><strong class="lq io">"files": [ "dist" ],</strong></span></pre><p id="2996" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还在项目的根目录下创建了一个<code class="fe ma mb mc lq b">.<strong class="kv io">npmignore</strong></code>文件，它也指定了<a class="ae ks" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>要忽略的目录或文件:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="9165" class="lu lv in lq b gy lw lx l ly lz">// .<strong class="lq io">npmignore</strong></span><span id="36e0" class="lu lv in lq b gy me lx l ly lz">src<br/>node_modules<br/>tests<br/>.idea<br/>coverage</span></pre><p id="40fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们通过在命令行运行<code class="fe ma mb mc lq b"><strong class="kv io">npm publish</strong></code>将我们的包发布给<a class="ae ks" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>。您需要在<a class="ae ks" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>上拥有一个帐户，并且可能需要运行<code class="fe ma mb mc lq b"><strong class="kv io">npm login</strong></code>来登录您的<a class="ae ks" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>帐户，然后您才能发布。NPM的账户是免费的。NPM还要求您的包的名称是唯一的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/633dd64411f5b58394553fb1ad3bd811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LM7FvbNgHG2Nl2gyIv-XPQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">npm publish CLI</figcaption></figure><h2 id="c873" class="lu lv in bd mv nt nu dn mz nv nw dp nd lc nx ny nf lg nz oa nh lk ob oc nj od bi translated">自动化工作流程</h2><p id="81f0" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">我们将发布过程自动化是很重要的，因为这可以节省时间并提高代码质量。它允许我们能够自动化上面的各个步骤，例如安装依赖项、林挺、测试、版本控制和将我们的库发布到NPM。</p><p id="e32b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请参阅我的文章<a class="ae ks" href="https://medium.com/@sidneyb231/how-to-automate-continuous-integration-and-development-versioning-and-publishing-a7d4b3311f3" rel="noopener"> <strong class="kv io">如何自动化持续集成和开发、版本化和发布</strong> </a>以获得如何使用Github、CircleCI和Semantic Release设置CI/CD以自动化您的工作流的分步指南，包括测试自动化、林挺、版本化、部署和发布到NPM。</p><h2 id="60e8" class="lu lv in bd mv nt nu dn mz nv nw dp nd lc nx ny nf lg nz oa nh lk ob oc nj od bi translated">状态徽章</h2><p id="e076" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">我们可能需要在我们的项目中包含构建徽章，以提供对我们的包的构建状态的公共访问。状态徽章可以嵌入到项目自述文件的顶部。</p><p id="bee8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将在项目的自述文件顶部添加CircleCI和语义发布状态徽章。参见<a class="ae ks" href="https://circleci.com/docs/2.0/status-badges/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> CircleCI —添加状态徽章</strong> </a>。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="955d" class="lu lv in lq b gy lw lx l ly lz"># <strong class="lq io">CircleCI Template:</strong> <br/>[![CircleCI](https://circleci.com/&lt;VCS&gt;/&lt;ORG_NAME&gt;/&lt;PROJECT_NAME&gt;.svg?style=svg)](&lt;LINK&gt;)</span><span id="6417" class="lu lv in lq b gy me lx l ly lz"># <strong class="lq io">Semantic Release Template</strong>: <br/>[![semantic-release](https://badge.fury.io/js/&lt;PROJECT_NAME&gt;.svg?style=svg)](&lt;NPM-PACKAGE-LINK&gt;)</span><span id="d52b" class="lu lv in lq b gy me lx l ly lz">// <strong class="lq io">CircleCI Build Status</strong><br/>[![CircleCI](https://circleci.com/gh/s-barrah/encrypt-decrypt-library.svg?style=svg)](<em class="ns">https://app.circleci.com/pipelines/github/s-barrah/encrypt-decrypt-library</em>)</span><span id="aa27" class="lu lv in lq b gy me lx l ly lz">// <strong class="lq io">Semantic Release </strong><br/>[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](<em class="ns">https://github.com/semantic-release/semantic-release</em>)</span><span id="151f" class="lu lv in lq b gy me lx l ly lz">// <strong class="lq io">NPM Status</strong><br/>[![semantic-release](https://badge.fury.io/js/encrypt-decrypt-library.svg)](<em class="ns">https://www.npmjs.com/package/encrypt-decrypt-library</em>)</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/b5d5847b338c27667b2d4ace715b497e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAj7zj02vk_BUHOTD7tXpA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Status Badges</figcaption></figure><h2 id="9857" class="lu lv in bd mv nt nu dn mz nv nw dp nd lc nx ny nf lg nz oa nh lk ob oc nj od bi translated">使用</h2><p id="a4ac" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">要在任何项目中使用我们的库，请使用<code class="fe ma mb mc lq b">YARN</code>或<code class="fe ma mb mc lq b">NPM</code>进行安装:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="d5de" class="lu lv in lq b gy lw lx l ly lz">// Via Yarn<em class="ns"><br/></em>$ yarn add encrypt-decrypt-library</span><span id="3724" class="lu lv in lq b gy me lx l ly lz">// Via NPM<em class="ns"><br/></em>$ npm install --save encrypt-decrypt-library</span></pre><p id="99ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以在项目的任何地方导入和使用:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="8acc" class="lu lv in lq b gy lw lx l ly lz">import Encryption from "encrypt-decrypt-library";</span><span id="572f" class="lu lv in lq b gy me lx l ly lz">const config = {<br/>   algorithm: process.env.ALGORITHM,<br/>   encryptionKey: process.env.ENCRYPTION_KEY,<br/>   salt: process.env.SALT,<br/>} <br/>const encryption = new Encryption(config);</span><span id="5774" class="lu lv in lq b gy me lx l ly lz">// Encrypt a string<br/>encryption.encrypt('Hello world')</span><span id="5be1" class="lu lv in lq b gy me lx l ly lz">// Encrypted as an unsigned 64-bit Integer<br/>encryption.encrypt(123, true)</span><span id="a480" class="lu lv in lq b gy me lx l ly lz">// Encrypted as string<br/>encryption.decrypt('gmmBh17Q4QA=')<br/><br/>// Encrypted as an integer<br/>encryption.decrypt('NF1r855MimY=', true)</span></pre><h1 id="3e6b" class="mu lv in bd mv mw mx my mz na nb nc nd jt ne ju nf jw ng jx nh jz ni ka nj nk bi translated">结论</h1><p id="b2f3" class="pw-post-body-paragraph kt ku in kv b kw nl jo ky kz nm jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">我们需要加密和解密数据的原因有很多。我们可能希望将敏感信息作为URL参数传递，并希望用户对其进行混淆。Base64编码可以创建简短且SEO友好的URL令牌，在Node中，<code class="fe ma mb mc lq b"><a class="ae ks" href="https://www.npmjs.com/package/atob" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">atob</strong></a></code>和<code class="fe ma mb mc lq b"><a class="ae ks" href="https://www.npmjs.com/package/btoa" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">btoa</strong></a></code>等库可以模拟浏览器的功能，但是Base64编码并不安全。你可以阅读更多关于<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/Base64" rel="noopener ugc nofollow" target="_blank"> JavaScript Base64 </a>的内容。</p><p id="e226" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文的目的是演示如何创建一个简单易用的加密库，可以导入并在我们的任何项目中使用，将简单的字符串和数字编码和加密成简短、安全且SEO友好的URL参数。</p><p id="5f05" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有一些NPM图书馆提供加密和编码，比如<a class="ae ks" href="https://www.npmjs.com/package/crypto-js" rel="noopener ugc nofollow" target="_blank"> CryptoJS </a>。您还可以探索这个JavaScript加密库列表，并决定哪一个适合您的用例。</p><p id="47f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果对您有帮助，请随意克隆、派生或启动下面的我的简单加密库GitHub存储库:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/s-barrah/encrypt-decrypt-library" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd io gy z fp oq fr fs or fu fw im bi translated">s-barrah/加密-解密-库</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">多级加密库，用于将字符串和大整数加密成唯一的令牌，可安全用于URL路径…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz km ol"/></div></div></a></div><h1 id="09a3" class="mu lv in bd mv mw mx my mz na nb nc nd jt ne ju nf jw ng jx nh jz ni ka nj nk bi translated">进一步阅读</h1><ul class=""><li id="39c4" class="mf mg in kv b kw nl kz nm lc pa lg pb lk pc lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.cryptomathic.com/news-events/blog/symmetric-key-encryption-why-where-and-how-its-used-in-banking" rel="noopener ugc nofollow" target="_blank">对称密钥加密——在银行业中使用的原因、地点和方式</a></li><li id="7b96" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.cryptomathic.com/news-events/blog/differences-between-hash-functions-symmetric-asymmetric-algorithms" rel="noopener ugc nofollow" target="_blank">哈希函数之间的差异，对称&amp;非对称算法</a></li><li id="4a3f" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto" rel="noopener ugc nofollow" target="_blank">Crypto-Web API接口</a></li><li id="6ef0" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://github.com/typescript-eslint/typescript-eslint" rel="noopener ugc nofollow" target="_blank">打字稿ESLint </a></li><li id="a955" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://www.robertcooper.me/using-eslint-and-prettier-in-a-typescript-project" rel="noopener ugc nofollow" target="_blank">在TypeScript项目中使用ESLint和appearlier</a></li><li id="9a6b" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/DOMString/Binary" rel="noopener ugc nofollow" target="_blank">二进制字符串</a></li><li id="e3f4" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://blog.bigbinary.com/2011/07/20/ruby-pack-unpack.html" rel="noopener ugc nofollow" target="_blank">红宝石包装和解包</a></li><li id="e7a9" class="mf mg in kv b kw mo kz mp lc mq lg mr lk ms lo mk ml mm mn bi translated"><a class="ae ks" href="https://medium.com/sharenowtech/high-speed-public-key-cryptography-in-javascript-part-1-3eefb6f91f77" rel="noopener">JavaScript中的高速公钥加密</a></li></ul></div></div>    
</body>
</html>