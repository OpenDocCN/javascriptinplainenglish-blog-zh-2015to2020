<html>
<head>
<title>Writing Async Programs in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript编写异步程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-asynchronous-programs-in-javascript-9a292570b2a6?source=collection_archive---------1-----------------------#2018-12-05">https://javascript.plainenglish.io/writing-asynchronous-programs-in-javascript-9a292570b2a6?source=collection_archive---------1-----------------------#2018-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba6c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用promises和async/await编写异步程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/283221382b0962f0ca7ed262ca41bb24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqt37fvoWDb7iNFm1QXOTQ.png"/></div></div></figure><p id="7009" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">毫无疑问，尽管历史悠久，JavaScript已经成为当今最流行的编程语言之一。由于JavaScript的异步特性，它可能会给初学这门语言的人带来一些挑战。在本文中，我们将使用promises和async/await编写小型异步程序。通过这些例子，我们将确定一些简单的模式，你可以用在你自己的程序中。</p><p id="4c24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你是JavaScript新手，在阅读这篇文章之前，你可能想先看看我的另一篇文章。</p><blockquote class="lo lp lq"><p id="4c3c" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">本文中的所有代码示例都是为节点环境编写的。如果您没有安装Node，您可以查看附录1中的说明。即使所有的程序都是为Node编写的，您也可以将相同的原则应用于在浏览器中运行的脚本。此外，本文的所有代码示例都可以在<a class="ae ln" href="https://gitlab.com/aj_meyghani/manage-async" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上获得。</p></blockquote><h1 id="517a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">介绍</h1><p id="2b69" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">不管人们是否相信JavaScript是一种真正的编程语言，事实是它不会很快走向任何地方。如果你是一名网站开发者，你不妨花些时间了解它的好与坏。</p><p id="6bf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript是单线程的，支持非阻塞异步流。如果你是这门语言的新手，当事情没有按照你期望的方式运行时，它会变得非常令人沮丧。异步编程需要更多的耐心和不同于同步编程的不同思维。</p><p id="af98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在同步模式中，每件事都按顺序发生，一次一件。正因为如此，对程序进行推理变得更加容易。但是在异步模型中，操作可以在任何时间点以任何顺序开始或结束。因此，仅仅依靠一个序列是不够的。异步编程需要在程序流和设计方面进行更多的思考。</p><p id="3ea2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将探索几个简短的异步程序。我们将从简单的程序开始，逐步发展到更复杂的程序。下面是我们将要编写的脚本的概述:</p><ul class=""><li id="c709" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">将一个文件的内容写入另一个文件的脚本。</li><li id="86a8" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">将多个文件的内容写入新文件的脚本。</li><li id="c9d3" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">一个脚本，用于解析和格式化目录中的CSV文件，并将新的CSV文件输出到另一个文件夹。</li></ul><h1 id="664c" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">承诺和异步/等待</h1><p id="cfdd" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">让我们花点时间快速回顾一下承诺和异步/等待的基础知识。</p><p id="6008" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">承诺</strong></p><ul class=""><li id="6982" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">承诺是表示异步操作结果的对象。</li><li id="1317" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">承诺要么以“成功”值解决，要么以“失败”值拒绝。</li><li id="af4e" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">一般来说，解析的值是通过回调到<code class="fe ng nh ni nj b">then</code>块的参数来访问的。被拒绝的值可以通过回调的参数访问到一个<code class="fe ng nh ni nj b">catch</code>块。</li><li id="16e8" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在现代JavaScript环境中，您可以通过全局对象访问promise构造函数，如<code class="fe ng nh ni nj b">Promise</code>。</li><li id="8685" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">可以使用<code class="fe ng nh ni nj b">Promise</code>构造函数和<code class="fe ng nh ni nj b">new</code>关键字创建一个承诺。那就是:</li><li id="7539" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">const p = new Promise((r, j) =&gt; {});</code></li><li id="fcb6" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">r</code>回调用于解析带有值的承诺，而<code class="fe ng nh ni nj b">j</code>回调用于拒绝承诺。</li><li id="8886" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">Promise</code>构造函数有一些有用的静态方法，比如<code class="fe ng nh ni nj b">all</code>、<code class="fe ng nh ni nj b">race</code>、<code class="fe ng nh ni nj b">resolve</code>和<code class="fe ng nh ni nj b">reject</code>。<code class="fe ng nh ni nj b">all</code>方法接受一个承诺数组，并将尝试同时解析所有承诺，并返回一个解析为包含已解析值的数组的承诺。<code class="fe ng nh ni nj b">race</code>方法接受一个承诺数组，并解析或拒绝第一个完成的承诺。<code class="fe ng nh ni nj b">resolve</code>方法创建一个承诺，并将其解析为给定值。<code class="fe ng nh ni nj b">reject</code>方法创建一个承诺，并用给定的值拒绝它。</li></ul><p id="87e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">异步/等待</strong></p><ul class=""><li id="5507" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">async/await函数的目的是简化同步使用承诺的行为，并对一组承诺执行一些行为。<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">来自MDN </a></li><li id="b11a" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">正如承诺类似于结构化回调，async/await类似于组合生成器和承诺。<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">来自MDN </a></li><li id="9db5" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">可以用<code class="fe ng nh ni nj b">async</code>关键字将函数标记为异步函数。也就是:<code class="fe ng nh ni nj b">async function hello() {}</code>或者<code class="fe ng nh ni nj b">const hello = async() =&gt; {};</code>。</li><li id="bf4a" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">一个<code class="fe ng nh ni nj b">async</code>函数总是返回一个承诺。如果从<code class="fe ng nh ni nj b">async</code>函数返回一个值，它将被隐含地包装在一个承诺中。</li><li id="36f5" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">如果在一个<code class="fe ng nh ni nj b">async</code>函数中抛出了一个未被捕获的异常，那么返回的承诺将被异常拒绝。</li><li id="6281" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在返回承诺的语句之前，可以在<code class="fe ng nh ni nj b">async</code>函数中使用<code class="fe ng nh ni nj b">await</code>运算符。在这种情况下，函数的执行会“暂停”,直到承诺被解决或拒绝。</li><li id="efba" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">await</code>操作符只在<code class="fe ng nh ni nj b">async</code>函数中有效。</li></ul><h1 id="b323" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">读写单个文件</h1><p id="a943" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在本节中，我们将编写一个脚本来读取单个文件的内容，并将结果写入一个新文件。</p><blockquote class="lo lp lq"><p id="fc86" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">您可以在<a class="ae ln" href="https://gitlab.com/aj_meyghani/manage-async/tree/master/read-write-single-file" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上访问该部分的所有脚本。</p></blockquote><p id="108a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们将为程序的入口点创建一个<code class="fe ng nh ni nj b">async</code>函数:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="9480" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  // body goes here...<br/>}</span></pre><p id="a4aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们需要创建两个承诺，一个代表文件的内容。另一个表示将内容写入另一个文件的结果:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="f2ee" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  const fileContent = readFile("./file.txt", "utf-8");<br/>  const writeResult = writeFile("./file-copy.txt", fileContent);<br/>}</span></pre><p id="4790" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，<code class="fe ng nh ni nj b">readFile</code>和<code class="fe ng nh ni nj b">writeFile</code>都是异步的，它们都返回一个承诺。因此，首先我们需要确保我们<code class="fe ng nh ni nj b">await</code>了<code class="fe ng nh ni nj b">readFile</code>的结果，这样我们就可以在<code class="fe ng nh ni nj b">writeFile</code>中使用它:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="3132" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  const fileContent = <strong class="nj ir">await</strong> readFile("./file.txt", "utf-8");<br/>  const writeResult = writeFile("./file-copy.txt", fileContent);<br/>}</span></pre><p id="bb82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们可以决定从<code class="fe ng nh ni nj b">main</code>函数返回什么。这里我们将返回我们正在写入的新文件的名称。请注意，返回值将自动包装在承诺中。但是我们需要确保在点击函数的最后一行之前，对<code class="fe ng nh ni nj b">writeFile</code>的结果进行<code class="fe ng nh ni nj b">await</code>:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="5d08" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  const fileContent = <strong class="nj ir">await</strong> readFile("./file.txt", "utf-8");<br/>  const writeResult = <strong class="nj ir">await</strong> writeFile(<br/>  "./file-copy.txt", fileContent);<br/>  return "file-copy.txt";<br/>}</span></pre><p id="db81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以调用main函数，并将结果或任何未捕获的异常记录到控制台:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="fef6" class="no lw iq nj b gy np nq l nr ns">main()<br/>.then(r =&gt; console.log("Result:", r))<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="7155" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使程序完整，我们需要要求<code class="fe ng nh ni nj b">fs</code>模块并保证<code class="fe ng nh ni nj b">fs.readFile</code>和<code class="fe ng nh ni nj b">fs.writeFile</code>。完整的脚本如下所示:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="8329" class="no lw iq nj b gy np nq l nr ns">const util = require("util");<br/>const fs = require("fs");<br/>const readFile = util.promisify(fs.readFile);<br/>const writeFile = util.promisify(fs.writeFile);<br/><br/>async function main() {<br/>  const <strong class="nj ir">fileContent</strong> = <strong class="nj ir">await readFile(</strong>"./file.txt", "utf-8");<br/>  const writeResult = <strong class="nj ir">await writeFile</strong>(<br/>  "./file-copy.txt", <strong class="nj ir">fileContent</strong>);<br/>  return "file-copy.txt";<br/>}<br/><br/>main()<br/>.then(r =&gt; console.log("Result:", r))<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="def5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的片段中，我们承诺了<code class="fe ng nh ni nj b">fs.writeFile</code>和<code class="fe ng nh ni nj b">fs.readFile</code>。Promisify可以将任何回调样式的函数转变为基于承诺的函数，只要它们遵循节点约定。</p><p id="4a20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们来谈谈错误处理。有几种方法可以处理错误，这完全取决于你需要多少控制。例如，在上面的代码片段中，我们基本上捕捉到了任何可能发生在<code class="fe ng nh ni nj b">catch</code>块中的<code class="fe ng nh ni nj b">main</code>函数中的错误。这是因为在一个<code class="fe ng nh ni nj b">async</code>函数中，任何未被捕获的异常都会立即导致函数返回一个被异常拒绝的承诺。</p><p id="db5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，假设您需要更多的控制，并且希望根据每个异步操作可能出现的错误做不同的事情。在这种情况下，您可以在每个异步操作上使用try-catch块或者使用<code class="fe ng nh ni nj b">catch</code>块。首先，让我们看看如何使用try-catch块。</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="578d" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  let fileContent;<br/>  <strong class="nj ir">try {</strong><br/>    fileContent = <strong class="nj ir">await readFile</strong>("./files.txt", "utf-8");<br/>  <strong class="nj ir">} catch(err) {</strong><br/>    <strong class="nj ir">return</strong> {message: "Error while reading the file", error: err};<br/>  <strong class="nj ir">}</strong><br/><br/>  <strong class="nj ir">try {</strong><br/>    const writeResult = <strong class="nj ir">await writeFile</strong>(<br/>    "./file-copy.txt", fileContent);<br/>  <strong class="nj ir">} catch(err) {</strong><br/>    <strong class="nj ir">return</strong> {message: "Error while writing the file", error: err};<br/>  <strong class="nj ir">}</strong><br/><br/>  return "file-copy.txt";<br/>}</span></pre><p id="e4a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，我们添加了两个try-catch块。此外，我们在第一个块的外部创建了<code class="fe ng nh ni nj b">fileContent</code>变量，这样它在整个<code class="fe ng nh ni nj b">main</code>函数中都是可见的。请注意，在每个try-catch块中，如果有错误，我们将返回一个对象。错误对象包含一个消息字段和错误的详细信息。现在，如果发生任何错误，该函数将立即返回我们的自定义错误对象。请记住，返回的对象将自动包装在承诺中。我们可以像以前一样调用<code class="fe ng nh ni nj b">main</code>函数，但是这次我们可以在<code class="fe ng nh ni nj b">then</code>块中检查错误对象:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="6d52" class="no lw iq nj b gy np nq l nr ns">main()<br/>.<strong class="nj ir">then(r =&gt; {</strong><br/>  <strong class="nj ir">if(r.error) {</strong><br/>    return console.log(<br/>    "An error occurred, recover here. Details:", r);<br/>  }<br/>  return console.log("Done, no error. Result:", r);<br/>})<br/>.<strong class="nj ir">catch(err</strong> =&gt; console.log("An error occurred", err));</span></pre><p id="7882" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，在<code class="fe ng nh ni nj b">then</code>块中，我们正在检查被解析的对象是否有错误。如果有，我们就在那里处理。否则，我们只需将结果记录到控制台。另一个catch块将捕获任何运行时错误或任何其他程序没有处理的错误。</p><p id="4b0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了try-catch块，我们可以使用与每个承诺相关联的<code class="fe ng nh ni nj b">catch</code>块:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="6166" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  const fileContent = <strong class="nj ir">await readFile</strong>("./file.txt", "utf-8")<br/>  <strong class="nj ir">.catch(err =&gt; ({</strong><br/>    message: "Error while reading the file", error: err,<br/>  }));<br/><br/>  if (fileContent.error) {<br/>    return fileContent;<br/>  }<br/><br/>  const writeResult = <strong class="nj ir">await writeFile(</strong><br/>  "./file-copy.txt", fileContent)<br/>  .then(result =&gt; ({}))<br/>  <strong class="nj ir">.catch(err =&gt; ({</strong><br/>    message: "Error while writing the file", error: err,<br/>  }));<br/><br/>  if(writeResult.error) {<br/>    return writeResult;<br/>  }<br/><br/>  return "file-copy.txt";<br/>}</span></pre><p id="cd7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你注意到，我们为每个承诺调用了<code class="fe ng nh ni nj b">catch</code>方法，并且我们返回了一个定制的错误对象，类似于前面的例子。如果任何一步有错误，我们将简单地返回结果，其中只包含我们的自定义错误对象。</p><p id="235b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，对于第二个操作，如果写操作成功，我们将显式返回一个空对象。这是因为如果操作成功，<code class="fe ng nh ni nj b">writeFile</code>将解析为<code class="fe ng nh ni nj b">undefined</code>。因此，我们将无法访问<code class="fe ng nh ni nj b">undefined</code>值的<code class="fe ng nh ni nj b">error</code>字段。这就是为什么我们显式地返回一个承诺，如果写操作成功，它将解析为一个空对象。</p><p id="258a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以有选择地创建两个助手函数，以避免我们编写相同的样板代码:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="9f8c" class="no lw iq nj b gy np nq l nr ns">const call = (promise) =&gt;<br/>  promise.then(r =&gt; r == null ? ({result: r}): r)<br/>  .catch(error =&gt; ({error}));<br/><br/>const error = (result, msg) =&gt; ({error: result.error, message: msg});</span></pre><p id="88d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ng nh ni nj b">call</code>函数接受一个承诺并返回一个承诺，该承诺要么用一个空对象解析(如果结果为null或未定义),要么简单地解析为操作的结果。如果有错误，promise将解析为一个对象，该对象包含一个包含错误值的错误字段。</p><p id="ab35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ng nh ni nj b">error</code> helper函数接受一个结果和一条消息，它将返回一个包含结果错误和自定义可选消息的对象。添加了两个助手函数后，我们可以更新我们的<code class="fe ng nh ni nj b">main</code>函数:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="c316" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  const fileContent = <strong class="nj ir">await call</strong>(readFile("./file.txt", "utf-8"));<br/>  if(fileContent.error) {<br/>    return error(fileContent, "Error while reading the file");<br/>  }<br/><br/>  const writeResult = <strong class="nj ir">await call(</strong><br/>  writeFile("./file-copy.txt",  fileContent));<br/><br/>  if(writeResult.error) {<br/>    return error(writeResult, "Error while writing the file");<br/>  }<br/><br/>  return "file-copy.txt";<br/>}</span></pre><p id="c18e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们将每个操作传递给了<code class="fe ng nh ni nj b">call</code>函数。然后我们检查是否有错误。如果是这样，那么我们只需调用我们的<code class="fe ng nh ni nj b">error</code>函数来返回一个带有自定义错误消息的自定义错误。完整的代码片段如下所示:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="ee9b" class="no lw iq nj b gy np nq l nr ns">const util = require("util");<br/>const fs = require("fs");<br/>const readFile = util.promisify(fs.readFile);<br/>const writeFile = util.promisify(fs.writeFile);<br/><br/>const call = (promise) =&gt;<br/>  promise.then(r =&gt; r == null ? ({result: r}): r)<br/>  .catch(error =&gt; ({error}));<br/><br/>const error = (result, msg) =&gt; ({<br/>error: result.error, message: msg});<br/><br/>async function main() {<br/>  const fileContent = <strong class="nj ir">await call(</strong>readFile("./file.txt", "utf-8"));<br/>  if(fileContent.error) {<br/>    return error(fileContent, "Error while reading the file");<br/>  }<br/><br/>  const writeResult = <strong class="nj ir">await call(</strong><br/>  writeFile("./file-copy.txt", fileContent));<br/><br/>  if(writeResult.error) {<br/>    return error(writeResult, "Error while writing the file");<br/>  }<br/><br/>  return "file-copy.txt";<br/>}<br/><br/>main()<br/>.then(r =&gt; {<br/>  if(r.error) {<br/>    return console.log(<br/>    "An error occurred, recover here. Details:", r);<br/>  }<br/>  return console.log("Done, no error. Result:", r);<br/>})<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="fb88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了减少更多的样板文件，使事情更加模块化，我们可以做两件事:</p><ul class=""><li id="7bf6" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">我们可以使用<code class="fe ng nh ni nj b">fs-extra</code>并删除所有对<code class="fe ng nh ni nj b">util.promisify</code>的调用。</li><li id="dccc" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">我们还可以将这两个助手函数移动到它们自己的文件中。</li></ul><p id="d6d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，我们将有以下内容:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="52ff" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/>const {error, call} = require("../call");<br/><br/>async function main() {<br/>  const fileContent = <strong class="nj ir">await call(</strong><br/>  fs.readFile("./file.txt", "utf-8"));</span><span id="2360" class="no lw iq nj b gy nt nq l nr ns">  if(fileContent.error) {<br/>    <strong class="nj ir">return error</strong>(fileContent, "Error while reading the file");<br/>  }<br/><br/>  const writeResult = <strong class="nj ir">await call(</strong><br/>  fs.writeFile("./file-copy.txt", fileContent));<br/><br/>  if(writeResult.error) {<br/>    <strong class="nj ir">return error</strong>(writeResult, "Error while writing the file");<br/>  }<br/><br/>  return "file-copy.txt";<br/>}<br/><br/>main()<br/>.then(r =&gt; {<br/>  if(r.error) {<br/>    return console.log(<br/>    "An error occurred, recover here. Details:", r);<br/>  }<br/>  return console.log("Done, no error. Result:", r);<br/>})<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="4dcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，由于我们使用的是<code class="fe ng nh ni nj b">fs-extra</code>，如果我们不向方法传递回调，函数将默认返回一个承诺。这就是为什么我们删除了所有的promisify调用，并将所有的<code class="fe ng nh ni nj b">fs</code>调用直接转换到<code class="fe ng nh ni nj b">fs</code>变量上。此外，我们将两个助手函数移到了它们自己的名为<code class="fe ng nh ni nj b">call.js</code>的文件中。</p><h1 id="6b9b" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">读写多个文件</h1><p id="b6cc" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在本节中，我们将编写一个脚本来读取多个文件的内容，并将结果写入新文件。</p><blockquote class="lo lp lq"><p id="75d1" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">您可以在<a class="ae ln" href="https://gitlab.com/aj_meyghani/manage-async/tree/master/read-write-multiple" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上访问该部分的所有脚本。</p></blockquote><p id="8f7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本例的设置与前一个非常相似:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="0732" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/><br/>async function main() {<br/>  const files = ["files/file1.txt", "files/file2.txt"];<br/>  // ...<br/>}<br/><br/>main()<br/>.then(console.log)<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="38aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，首先我们需要拥有所有基于承诺版本的<code class="fe ng nh ni nj b">fs</code>方法的<code class="fe ng nh ni nj b">fs-extra</code>模块。然后，我们定义主<code class="fe ng nh ni nj b">async</code>函数作为程序的入口点。我们还定义了一个数组，其中包含我们将要读取的文件的硬编码路径。</p><p id="f2bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们将编写一个for循环，遍历文件路径并读取每个文件的内容:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="f84c" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/><br/>async function main() {<br/>  const files = ["files/file1.txt", "files/file2.txt"];<br/><br/>  <strong class="nj ir">for (const file of files) { </strong>// A<br/>    const content = <strong class="nj ir">await</strong> fs.readFile(file, "utf-8"); // B<br/>    console.log(content); // C<br/>  <strong class="nj ir">}</strong><br/>}<br/><br/>main()<br/>.then(console.log)<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="623b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在A行我们定义了for循环。在B行上，我们对<code class="fe ng nh ni nj b">fs.readFile</code>的结果进行<code class="fe ng nh ni nj b">await</code>，并将其赋给<code class="fe ng nh ni nj b">content</code>变量。最后，在C行，我们将内容记录到控制台。让我们用一个实际的写入文件操作来代替log语句:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="2ab3" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/><br/>async function main() {<br/>  const files = ["files/file1.txt", "files/file2.txt"];<br/><br/>  <strong class="nj ir">for (const file of files) {</strong><br/>    const content = <strong class="nj ir">await</strong> fs.readFile(file, "utf-8");<br/>    const path = file.replace(".txt", "-copy.txt"); // A<br/>    const writeResult = <strong class="nj ir">await</strong> fs.writeFile(path, content); // B<br/>  <strong class="nj ir">}</strong><br/><br/>  return files; // C<br/>}<br/><br/>main()<br/>.then(console.log)<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="9da5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，首先我们在a行定义了文件的路径。然后，在B行，我们将结果写入新的路径，并确保在它上面也有<code class="fe ng nh ni nj b">await</code>。我们需要在这里<code class="fe ng nh ni nj b">await</code>，因为我们想确保在我们移动到下一个文件之前写操作已经完成。最后在C行，我们返回输入文件路径。</p><p id="4308" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，上面的实现还可以，但是我们可以做得更好。在上面的实现中，我们一次处理一个文件。也就是说，我们等待每个文件的读写操作完成，然后再移动到下一个文件。我们实际上可以通过创建一个承诺数组来并发地运行每个读写进程，其中每个承诺代表一个文件上的读写操作。最后，我们可以使用<code class="fe ng nh ni nj b">Promise.all</code>同时处理所有的承诺:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="2b5f" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/><br/>async function main() {<br/>  const files = ["files/file1.txt", "files/file2.txt"];<br/><br/>  const <strong class="nj ir">readWrites</strong> = []; // A<br/><br/>  for (const file of files) { // B<br/>    <strong class="nj ir">readWrites.push((async() =&gt; {</strong> // C<br/>      const content = <strong class="nj ir">await</strong> fs.readFile(file, "utf-8"); // D<br/>      const path = file.replace(".txt", "-copy.txt"); // E<br/>      return <strong class="nj ir">await</strong> fs.writeFile(path, content); // F<br/>    <strong class="nj ir">})());</strong><br/>  }<br/><br/>  return <strong class="nj ir">await</strong> Promise.all(<strong class="nj ir">readWrites</strong>); // G<br/>}<br/><br/>main()<br/>.then(console.log)<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="f46c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，我们在A行定义了一个数组来保存读写承诺。在B行，我们开始遍历每个文件路径的for循环。在第C行，我们将一个自调用的<code class="fe ng nh ni nj b">async</code>函数推送到<code class="fe ng nh ni nj b">readWrites</code>数组。在每个<code class="fe ng nh ni nj b">async</code>函数体内，我们读取每个文件的内容并写入一个新文件。在F行，我们返回<code class="fe ng nh ni nj b">fs.writeFile</code>的结果，它是一个承诺对象。最后，在G行，我们使用<code class="fe ng nh ni nj b">Promise.all</code>来同时处理所有的承诺。我们还对结果进行了<code class="fe ng nh ni nj b">await</code>，它解析为保存写结果的单个数组。如果写操作成功，我们应该得到一个未定义值的数组。这是因为如果没有错误发生，写方法解析为<code class="fe ng nh ni nj b">undefined</code>。</p><p id="9127" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使上面的实现完成了工作，我们还可以做得更好一点。我们可以用一个<code class="fe ng nh ni nj b">async</code>函数在<code class="fe ng nh ni nj b">files</code>数组上使用map方法，并消除对自调用<code class="fe ng nh ni nj b">async</code>函数的需要。这也更容易理解:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="2453" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/><br/>async function main() {<br/>  const files = ["files/file1.txt", "files/file2.txt"];<br/><br/>  const readWrites = <strong class="nj ir">files.map(async file =&gt; { </strong>// A<br/>    const content = <strong class="nj ir">await fs.readFile</strong>(file, "utf-8"); // B<br/>    return <strong class="nj ir">await fs.writeFile</strong>(<br/>    file.replace(".txt", "-copy.txt"), content); // C<br/>  });<br/><br/>  return <strong class="nj ir">await Promise.all</strong>(readWrites); // D<br/>}<br/><br/>main()<br/>.then(console.log)<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="877a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，在第A行我们调用了<code class="fe ng nh ni nj b">files</code>数组上的<code class="fe ng nh ni nj b">map</code>,并给它传递了一个<code class="fe ng nh ni nj b">async</code>函数。在<code class="fe ng nh ni nj b">async</code>函数中，我们简单地执行读写操作。最后在D行，我们调用<code class="fe ng nh ni nj b">Promise.all</code>并传递<code class="fe ng nh ni nj b">readWrites</code>数组。<code class="fe ng nh ni nj b">readWrites</code>数组保存承诺，其中每个承诺代表每次读写的结果。</p><p id="052f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们扩展上面的例子。让我们创建一个文件夹，把所有的新文件放进去。我们将需要创建一个<code class="fe ng nh ni nj b">async</code>函数，它在我们进入读写操作之前为我们创建输出文件夹:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="8199" class="no lw iq nj b gy np nq l nr ns">async function prepare() {<br/>  <strong class="nj ir">await</strong> <strong class="nj ir">fs.remove</strong>("output"); // A<br/>  return <strong class="nj ir">await fs.mkdir</strong>("output"); // B<br/>}</span></pre><p id="9689" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码片段中，首先我们创建了一个名为<code class="fe ng nh ni nj b">prepare</code>的<code class="fe ng nh ni nj b">async</code>函数。在第A行，首先我们删除<code class="fe ng nh ni nj b">output</code>文件夹，如果它已经存在的话。我们也等待承诺得到解决，然后再移到B行。在B行，我们创建了<code class="fe ng nh ni nj b">output</code>文件夹，我们也等待它完成。现在，在开始读写操作之前，我们可以在<code class="fe ng nh ni nj b">main</code>函数中使用<code class="fe ng nh ni nj b">prepare</code>函数:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="8ad2" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/><br/>const files = ["files/file1.txt", "files/file2.txt"];<br/>const output = "output";<br/><br/>async function prepare() {<br/>  await fs.remove(output);<br/>  return await fs.mkdir(output);<br/>}<br/><br/>async function main() {<br/>  <strong class="nj ir">await prepare();</strong> // A<br/><br/>  const readWrites = files.map(async file =&gt; {<br/>    const content = await fs.readFile(file, "utf-8");<br/>    const path = file.replace("files", output); // B<br/>    return await fs.writeFile(path, content);<br/>  });<br/><br/>  return await Promise.all(readWrites);<br/>}<br/><br/>main()<br/>.then(console.log)<br/>.catch(err =&gt; console.log("An error occurred", err));</span></pre><p id="3601" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第A行，我们等待<code class="fe ng nh ni nj b">prepare</code>函数完成，然后继续读写操作。我们还更新了b行的输出文件路径。脚本的其余部分基本相同。我们还将<code class="fe ng nh ni nj b">files</code>和<code class="fe ng nh ni nj b">output</code>变量移出了主函数。如果您运行上面的脚本，您应该会看到一个包含每个输入文件副本的<code class="fe ng nh ni nj b">output</code>文件夹。</p><h1 id="8ef6" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">格式化CSV文件</h1><p id="f3ec" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在本节中，我们将编写一个脚本来读取几个CSV文件，格式化它们，并将结果写入另一个目录。</p><blockquote class="lo lp lq"><p id="86df" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">您可以在<a class="ae ln" href="https://gitlab.com/aj_meyghani/manage-async/tree/master/format-csv" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上访问该部分的所有脚本。</p></blockquote><p id="e264" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是脚本需要执行的每个任务的概述:</p><ul class=""><li id="269a" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">通过检查扩展名和文件统计信息来识别目录中的CSV文件(一级深度)。</li><li id="f33c" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">读取每个文件的内容，并使用CSV解析器解析内容。</li><li id="14c7" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">对每个文件执行基本格式化。</li><li id="934e" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">Stringify格式的结果，并将每个结果写入一个新的CSV文件，并将它们放在输出文件夹中。</li></ul><p id="316d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用上述任务，我们可以定义以下步骤:</p><ul class=""><li id="0778" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">如果输出文件夹不存在，首先创建一个输出文件夹。换句话说，无论如何都要删除输出目录，然后重新创建它。</li><li id="d548" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">然后，识别给定目录中的CSV文件。</li><li id="2467" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">然后，读取每个文件的内容，进行格式化，并将结果写入输出目录中的一个新文件。</li></ul><p id="a4c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用上面的流程，我们可以为每个步骤定义以下函数:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="e7a8" class="no lw iq nj b gy np nq l nr ns">async function setup() {}<br/><br/>async function csvFiles(inputFolder) {}<br/><br/>function format(content) {}<br/><br/>async function formatWrite() {}<br/><br/>async function main() {<br/>  const src = "input-folder";<br/>  const [output, files] = await Promise.all([ // A<br/>    setup(), csvFiles(src),<br/>  ]);<br/><br/>  return await Promise.all( // B<br/>    files.map(async file =&gt; formatWrite(file, output))<br/>  );<br/>}</span></pre><ul class=""><li id="b0f3" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated"><code class="fe ng nh ni nj b">setup</code>函数将处理输出目录的创建。它将返回一个解析为输出目录名称的承诺。</li><li id="2f3a" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">csvFiles</code>函数将查找给定输入文件夹中的所有CSV文件，并返回一个文件路径数组。</li><li id="198f" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">format</code>函数将对解析后的CSV文件的内容进行一些基本的格式化。</li><li id="8062" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">main</code>功能是程序的入口点。首先，我们将同时运行<code class="fe ng nh ni nj b">setup</code>和<code class="fe ng nh ni nj b">csvFiles</code>。但是我们会等他们两个都结束。之后，我们将创建一个承诺数组，每个承诺代表读取、格式化和写入每个文件。我们等待它结束，然后返回结果。</li></ul><p id="e65f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">先说<code class="fe ng nh ni nj b">setup</code>函数。<code class="fe ng nh ni nj b">setup</code>功能做的不多。它会删除输出文件夹，无论它是否存在。然后，它创建该文件夹，并返回该文件夹的名称:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="29a5" class="no lw iq nj b gy np nq l nr ns">async function setup() {<br/>  const output = "output";<br/>  <strong class="nj ir">await fs.remove</strong>(output);<br/>  <strong class="nj ir">await fs.mkdir</strong>(output);<br/>  return output;<br/>}</span></pre><p id="6a89" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们来看看<code class="fe ng nh ni nj b">csvFiles</code>函数。这个函数基本上是读取一个文件夹的内容，然后找出哪些是文件，然后过滤掉扩展名为<code class="fe ng nh ni nj b">.csv</code>的文件。它将只执行一个级别的深度:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="73d1" class="no lw iq nj b gy np nq l nr ns">async function csvFiles(inputFolder) {<br/>  const dirContent = <strong class="nj ir">await fs.readdir</strong>(inputFolder); // A<br/>  const paths = dirContent.map(c =&gt; path.join(inputFolder, c)); // B<br/><br/>  return <strong class="nj ir">await</strong> Promise.all(<strong class="nj ir">paths.map(async p =&gt; {</strong> // C<br/>    const isFileAndCSV = <br/>    ((<strong class="nj ir">await fs.stat(p)</strong>).isFile() &amp;&amp; /\.csv$/.test(p)); // D<br/>    return isFileAndCSV ? p : "";<br/>  }))<br/>  .then(paths =&gt; paths.filter(v =&gt; v)); // E<br/>}</span></pre><ul class=""><li id="822b" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">在第A行，我们调用<code class="fe ng nh ni nj b">fs.readdir</code>来读取输入文件夹的内容。然后我们等待结果返回，并将结果存储在<code class="fe ng nh ni nj b">dirContent</code>变量中。</li><li id="cf77" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在第B行，我们创建了一个完整路径的数组，从输入文件夹开始，以及上一步的结果。</li><li id="f156" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在C行，我们开始识别CSV文件。</li><li id="9a44" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">在第D行，首先我们调用<code class="fe ng nh ni nj b">fs.stat</code>来获取路径的状态。然后我们等待结果，并使用<code class="fe ng nh ni nj b">isFile</code>方法来识别给定的路径是否是一个文件。我们还使用正则表达式来检查给定文件的扩展名。</li><li id="acfa" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">一行E，我们过滤掉所有不为假的值。最后，结果是一个承诺数组，其中每个承诺都解析为一个CSV文件。我们使用<code class="fe ng nh ni nj b">Promise.all</code>来同时履行承诺，并返回已解析的文件数组。</li></ul><p id="7921" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们要看的下一个函数是<code class="fe ng nh ni nj b">formatWrite</code>函数。这个函数主要是读取每个文件的内容，用CSV解析器对其进行解析，然后将格式化后的内容写入一个新文件:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="05ba" class="no lw iq nj b gy np nq l nr ns">async function formatWrite(file, output) {<br/>  const content = <strong class="nj ir">await fs.readFile</strong>(file, "utf-8"); // A<br/>  const parsed = <strong class="nj ir">await csvParse</strong>(content); // B<br/>  const formatted = format(parsed); // C<br/>  const stringified = <strong class="nj ir">await csvStringify</strong>(formatted); // D<br/>  const outPath = path.join(<br/>  output, file.split("/").slice(-1)[0]); // E<br/>  <strong class="nj ir">await fs.writeFile</strong>(outPath, stringified); // F<br/>  return file;<br/>}</span></pre><ul class=""><li id="47bd" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">第一行A，我们读取给定文件的内容，等待结果，并将其存储在<code class="fe ng nh ni nj b">content</code>变量中。</li><li id="340f" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">第B行，我们解析上一步的结果并等待它完成。然后，我们将结果存储在<code class="fe ng nh ni nj b">parsed</code>变量中。</li><li id="d7f5" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">第C行，我们对上一步的结果调用一个简单的<code class="fe ng nh ni nj b">format</code>函数，并将它存储在<code class="fe ng nh ni nj b">formatted</code>变量中。</li><li id="6d79" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">一行D，我们对格式化的内容调用<code class="fe ng nh ni nj b">csvStringify</code>函数，然后等待它完成。然后，我们将结果存储在<code class="fe ng nh ni nj b">stringified</code>变量中。</li><li id="7b65" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">一行E，我们通过将输出路径与文件名连接起来来定义输出文件的路径。</li><li id="a35c" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">第F行，我们把字符串化的内容写到上一行的路径中，然后等待它完成。</li><li id="9393" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">最后，我们返回我们处理过的输入文件的名称。</li></ul><p id="24c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">真的是这样。以下是完整的程序，包括所有要求的语句和<code class="fe ng nh ni nj b">format</code>功能的实现:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="0f96" class="no lw iq nj b gy np nq l nr ns">const fs = require("fs-extra");<br/>const util = require("util");<br/>const path = require("path");<br/>const csvParse = util.promisify(require("csv-parse"));<br/>const csvStringify = util.promisify(require("csv-stringify"));<br/><br/>async function setup() {<br/>  const output = "output";<br/>  await fs.remove(output);<br/>  await fs.mkdir(output);<br/>  return output;<br/>}<br/><br/>async function csvFiles(inputFolder) {<br/>  const dirContent = await fs.readdir(inputFolder);<br/>  const paths = dirContent.map(c =&gt; path.join(inputFolder, c));<br/><br/>  return await Promise.all(paths.map(async p =&gt; {<br/>    const isFileAndCSV = <br/>    ((await fs.stat(p)).isFile() &amp;&amp; /\.csv$/.test(p));<br/>    return isFileAndCSV ? p : "";<br/>  }))<br/>  .then(paths =&gt; paths.filter(v =&gt; v));<br/>}<br/><br/>function format(content) {<br/>  return content.map((v, i) =&gt; {<br/>    if(i === 0) {<br/>      return v.map(h =&gt; h.toUpperCase());<br/>    }<br/>    return v;<br/>  });<br/>}<br/><br/>async function formatWrite (file, output) {<br/>  const content = await fs.readFile(file, "utf-8");<br/>  const parsed = await csvParse(content);<br/>  const formatted = format(parsed);<br/>  const stringified = await csvStringify(formatted);<br/>  const outPath = path.join(output, file.split("/").slice(-1)[0]);<br/>  await fs.writeFile(outPath, stringified);<br/>  return file;<br/>}<br/><br/>async function main() {<br/>  const src = "input-folder";<br/>  const [output, files] = await Promise.all([<br/>    setup(), csvFiles(src),<br/>  ]);<br/><br/>  return await Promise.all(<br/>    files.map(async file =&gt; formatWrite(file, output))<br/>  );<br/>}<br/><br/>main()<br/>.then(console.log)<br/>.catch(console.log);</span></pre><p id="8beb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们需要并发处理大量文件，我们可以限制一次处理的文件数量。为此，我们可以使用类似于<code class="fe ng nh ni nj b">p-limit</code>的模块。在我们需要它之后，我们可以更新main函数，将并发任务限制为一次两个承诺:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="4867" class="no lw iq nj b gy np nq l nr ns">async function main() {<br/>  const src = "input-folder";<br/>  const [output, files] = await Promise.all([<br/>    setup(), csvFiles(src),<br/>  ]);<br/><br/>  /* limit concurrent tasks to 2 */<br/><strong class="nj ir">  const limit = pLimit(2); // A<br/></strong>  return await Promise.all(<br/>    files.map(file =&gt; <strong class="nj ir">limit(() =&gt; formatWrite(file, output))</strong>) // B<br/>  );<br/>}</span></pre><p id="164a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第A行，我们从<code class="fe ng nh ni nj b">pLimit</code>创建了一个限制函数，并指定我们希望一次运行多少个并发任务。在第B行，我们用<code class="fe ng nh ni nj b">limit</code>包装了我们的<code class="fe ng nh ni nj b">formatWrite</code>函数，它会处理剩下的事情。你可以在<a class="ae ln" href="https://gitlab.com/aj_meyghani/manage-async/blob/master/format-csv/main2.js" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上看到完整的脚本。</p><h1 id="54a3" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="9668" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">JavaScript无疑已经取得了长足的进步，并且随着async/await的出现，编写更好的异步程序变得更加容易。既然我们已经到了文章的结尾，让我们回顾一些重要的要点:</p><ul class=""><li id="7ab9" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">我们可以将异步任务分为并发流和顺序流。我们可以捕获承诺中的流程，并决定程序的哪些部分应该并发运行，哪些部分应该顺序运行。</li><li id="ac8c" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">我们可以使用数组的<code class="fe ng nh ni nj b">Promise.all</code>和<code class="fe ng nh ni nj b">map</code>方法来创建承诺并同时处理它们。我们还可以在<code class="fe ng nh ni nj b">Promise.all</code>之前使用<code class="fe ng nh ni nj b">await</code>操作符来等待所有承诺被解析。那就是:</li><li id="8a0a" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated"><code class="fe ng nh ni nj b">await Promise.all(inputs.map(async v =&gt; {}));</code></li><li id="75fb" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">如果我们想在<code class="fe ng nh ni nj b">async</code>函数中使用try-catch块，我们需要在任何承诺值或返回承诺的函数之前使用<code class="fe ng nh ni nj b">await</code>操作符。</li><li id="d936" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">如果系统资源是一个问题，或者如果我们正在处理大量输入，限制并发任务通常是一个好主意。我们可以使用像<code class="fe ng nh ni nj b"><a class="ae ln" href="https://github.com/sindresorhus/p-limit" rel="noopener ugc nofollow" target="_blank">p-limit</a></code>这样的包来限制同时运行的任务数量。</li></ul><h1 id="d970" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">附录1:安装节点</h1><p id="6f0c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">安装Node最简单和最一致的方式是通过版本管理器，如<a class="ae ln" href="https://github.com/creationix/nvm" rel="noopener ugc nofollow" target="_blank"> NVM </a>。首先，使用以下内容安装NVM:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="936f" class="no lw iq nj b gy np nq l nr ns">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span></pre><p id="eb3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后检查您的“profile”文件，查看是否添加了以下条目:</p><pre class="kg kh ki kj gt nk nj nl nm aw nn bi"><span id="13f6" class="no lw iq nj b gy np nq l nr ns">export NVM_DIR="$HOME/.nvm"<br/>[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh"  # This loads nvm<br/>[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion</span></pre><p id="2b8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后重启您的终端，确保您可以获得<code class="fe ng nh ni nj b">nvm --version</code>的输出。之后，只需运行<code class="fe ng nh ni nj b">nvm install 8</code>来安装最新的节点8。之后，运行<code class="fe ng nh ni nj b">node -v</code>和<code class="fe ng nh ni nj b">npm -v</code>来验证节点和Npm都可用。</p></div></div>    
</body>
</html>