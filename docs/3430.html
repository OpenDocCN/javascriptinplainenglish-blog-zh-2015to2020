<html>
<head>
<title>Testing in React, Part 6: Real-World Testing with React Testing Library, Jest, Enzyme and Cypress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的测试，第6部分:React测试库、Jest、Enzyme和Cypress的真实测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-in-react-part-6-real-world-testing-with-react-testing-library-jest-enzyme-and-cypress-9c73436d95d8?source=collection_archive---------4-----------------------#2020-09-28">https://javascript.plainenglish.io/testing-in-react-part-6-real-world-testing-with-react-testing-library-jest-enzyme-and-cypress-9c73436d95d8?source=collection_archive---------4-----------------------#2020-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f9e94e1a7d7ed067db848c4e5a38f935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Me7phaslhZ2vlN70XDqS4g.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@safesolvent?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Martin Reisch</a> on <a class="ae jd" href="https://unsplash.com/s/photos/circle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="20fd" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本文是React中测试系列的一部分:</p><p id="cbc4" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-1-types-tools-244107abf0c6" rel="noopener">React中的测试，第1部分:类型&amp;工具</a></p><p id="f074" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-2-react-testing-library-f32432b93c6c" rel="noopener">React中的测试，第2部分:React测试库</a></p><p id="0cf8" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-3-jest-jest-dom-7a8a03ae60b" rel="noopener">React中的测试，第3部分:Jest &amp; Jest-Dom </a></p><p id="2beb" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-4-enzyme-9b030ad616ae" rel="noopener">React中的测试，第4部分:酶</a></p><p id="dbd9" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-5-end-to-end-testing-with-cypress-bd2bf8d3385f" rel="noopener">React中的测试，第5部分:使用Cypress的端到端测试</a></p><p id="1462" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">React中的测试，第6部分:React测试库、Jest、Enzyme和Cypress的真实测试</strong></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="f556" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">到目前为止，我希望您对不同的工具、它们所扮演的角色、测试类型之间的差异以及全面的测试基础设施的重要性有了较高的理解。现在有趣的部分来了——利用我们所学的，并实际将其集成到应用程序中。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="ce6b" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">该应用程序</h1><p id="dfc1" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">我将使用一个我用React开发的名为Propertii的应用程序，它允许建筑管理员和租户连接并管理建筑维修。请随意使用下面的链接来克隆这个项目，或者使用您自己的链接。</p><blockquote class="kk kl km"><p id="bcdc" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://github.com/bbennett7/properti-web-app" rel="noopener ugc nofollow" target="_blank"><strong class="kq jh">【proper tii】前端</strong></a><strong class="kq jh">——</strong><a class="ae jd" href="https://github.com/bbennett7/properti-server" rel="noopener ugc nofollow" target="_blank"><strong class="kq jh">proper tii后端</strong></a><strong class="kq jh">——</strong><a class="ae jd" href="https://properti-web-app.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kq jh">proper tii直播现场</strong> </a></p></blockquote><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ms"><img src="../Images/1f92acbd36a677ac7b8283869b4601eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyuN-bXYXcygWCYfCxxgDw.png"/></div></div></figure><p id="8d80" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">无论您选择什么样的repo，都要通过运行<code class="fe mx my mz na b">yarn add react-testing-library enzyme cypress —-dev</code>来安装所需的依赖项。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="e47c" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">用Jest &amp; React测试库进行单元测试</h1><p id="54dc" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">您可能还记得，单元测试是最快、最低级的测试形式。通俗地说，单元测试测试一个代码单元(通常是一个函数)在给定特定输入的情况下是否返回预期值。无论这个函数是<em class="kp">实际上</em>接收您期望它在应用程序中接收的内容，还是正确地呈现到DOM，都超出了范围。这里我们想知道的是，对于方程<code class="fe mx my mz na b">a + b = c</code>，给定<code class="fe mx my mz na b">a = 1</code>和<code class="fe mx my mz na b"> b = 2</code>，那么<code class="fe mx my mz na b">c = 3</code>？</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/efd7ecc3ff74addd378231e88370506b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-a2S9vTw8tKSNvTqn3hMYQ.png"/></div></div></figure><p id="9abe" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">首先，导航到<code class="fe mx my mz na b">src/components/Button</code>。在这个目录中，创建一个<code class="fe mx my mz na b">Button.test.js</code>文件，我们将在这里为<code class="fe mx my mz na b">Button.js</code>中的代码编写测试。你会在<code class="fe mx my mz na b">Button.js</code>中看到我们有一个组件来呈现一个按钮，然而这个按钮的<code class="fe mx my mz na b">jsx</code>是以它的<code class="fe mx my mz na b">props</code>为条件的。这对RTL和杰斯特的测试来说是完美的。首先将下面的导入添加到您的测试文件中:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="fc54" class="ng lq jg na b gy nh ni l nj nk">import React from ‘react’;<br/>import { render, fireEvent, screen } from ‘@testing-library/react’;<br/>import Button from './Button';</span></pre><p id="20bf" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">接下来，我们问自己，我们想测试什么？这对测试套件的可读性和可维护性很重要。我们想要测试组件的条件(在本例中，是有还是没有<code class="fe mx my mz na b">path prop</code>)，所以我们将从测试条件的一个状态开始:</p><p id="3299" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated"><strong class="kq jh"> <em class="kp">注</em> </strong> <em class="kp">:我把便于复制粘贴的文字，以及文件的截图全部包含进去，看它凑在一起。</em></p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="bddb" class="ng lq jg na b gy nh ni l nj nk">test(‘renders a link when path prop is present’, () =&gt; {</span><span id="909e" class="ng lq jg na b gy nl ni l nj nk">})</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/8090744ecfa04efe8bce84ced4fcee6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZRyzUoWJID2tHAnSHGLCA.png"/></div></div></figure><p id="7af1" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">使用React测试库，我们将呈现<code class="fe mx my mz na b">Button</code>组件，并为其查询RTL <code class="fe mx my mz na b">screen</code>:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="82a2" class="ng lq jg na b gy nh ni l nj nk">const pathProp = '/test-path';<br/>const textProp = 'Test Page Name';</span><span id="575c" class="ng lq jg na b gy nl ni l nj nk">// React-Testing-Library<br/>render(&lt;Button path={pathProp} text={textProp} /&gt;);<br/>const btn = screen.getByText(textProp);</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/82053c3b904990b96e7df2299e721fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnJMI2-ftXR8GPNVrET26Q.png"/></div></div></figure><p id="4151" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">使用Jest，我们现在可以断言关于使用RTL查询的元素的期望:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="453d" class="ng lq jg na b gy nh ni l nj nk">// Jest<br/>expect(btn).toHaveProperty('href');</span></pre><p id="7951" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">此时，如果您使用<code class="fe mx my mz na b">yarn test</code>运行您的测试，您将会看到它失败了:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/822aace91f919f455ed7d39b23f1cd93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQpytWjYEz5Jl88WbF74DA.png"/></div></div></figure><p id="46bf" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">这是因为我们测试的<em class="kp">只是作为<code class="fe mx my mz na b">Button</code>组件的</em>单元，所以测试不知道在应用程序的更高级别使用的<code class="fe mx my mz na b">Router</code>。为了模拟这一点，我们必须将<code class="fe mx my mz na b">BrowserRouter</code>导入到测试文件中，并将呈现的组件包装在其中:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="2d7e" class="ng lq jg na b gy nh ni l nj nk">// Add to imports:<br/>import { BrowserRouter as Router } from 'react-router-dom';</span><span id="56f4" class="ng lq jg na b gy nl ni l nj nk"><br/>// Replace existing render:<br/>render(<br/>  &lt;Router&gt;<br/>    &lt;Button path={pathProp} text={textProp} /&gt;<br/>  &lt;/Router&gt;<br/>);</span></pre><p id="1c33" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">现在，当测试运行时，您会看到它通过了。当<code class="fe mx my mz na b">path prop</code>出现时，我们知道<code class="fe mx my mz na b">Link</code>被渲染。这太棒了。现在，为了增加覆盖率，让我们确保链接指向我们传入的路径:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="f15b" class="ng lq jg na b gy nh ni l nj nk">expect(btn.href).toContain(pathProp);</span></pre><p id="5725" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">测试再次运行，仍然通过。此时，您的测试文件应该如下所示:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/86a83d89e88491bc07eae73b01221df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1SbCruWyxLVTjVEf9pyog.png"/></div></div></figure><p id="f905" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">现在让我们也测试一下，以确保当一个<code class="fe mx my mz na b">path prop</code>被<em class="kp">而不是</em>传递时，一个<code class="fe mx my mz na b">button</code>元素被呈现。我们想要为此创建一个单独的测试，但是由于它与初始测试相关，我们将把它们都包装在一个<code class="fe mx my mz na b">describe</code>块中。</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="43bc" class="ng lq jg na b gy nh ni l nj nk">describe('button component', () =&gt; {</span><span id="6576" class="ng lq jg na b gy nl ni l nj nk">}</span></pre><p id="8276" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">在这个<code class="fe mx my mz na b">describe</code>块中，在初始测试之后，我们将添加下一个测试。这一次，我们将渲染没有的<code class="fe mx my mz na b">Button</code>组件<em class="kp">。既然不应该是渲染一个<code class="fe mx my mz na b">Link</code>，我们就不需要把它包在<code class="fe mx my mz na b">Router</code>里。我们将断言现在存在<em class="kp">而不是</em>和<code class="fe mx my mz na b">href</code>属性，并且存在的HTML元素是一个<code class="fe mx my mz na b">button</code>。为了做出第二个断言，我们将使用Jest Dom matcher。首先，我们需要通过在命令行中运行以下命令来更新Jest Dom的最新版本:</em></p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="1b2c" class="ng lq jg na b gy nh ni l nj nk">yarn add --dev @testing-library/jest-dom</span></pre><p id="79c1" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">将新的导入添加到文件的顶部:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="4c14" class="ng lq jg na b gy nh ni l nj nk">import '@testing-library/jest-dom';</span></pre><p id="3d97" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">最后，编写测试:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="a4f2" class="ng lq jg na b gy nh ni l nj nk">test('renders a button element when path prop is absent', () =&gt; {<br/>  const btnText = 'Test Button';<br/>  <br/>  // React-Testing-Library<br/>  render( &lt;Button text={btnText} /&gt;);</span><span id="b184" class="ng lq jg na b gy nl ni l nj nk">  const btn = screen.getByText(btnText);</span><span id="54b2" class="ng lq jg na b gy nl ni l nj nk">  // Jest<br/>  expect(btn).not.toHaveProperty('href');</span><span id="b692" class="ng lq jg na b gy nl ni l nj nk">  // Jest-DOM<br/>  expect(btn).toContainHTML('&lt;button ')<br/>})</span></pre><p id="3153" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">对于您的<code class="fe mx my mz na b">Button</code>组件，您现在应该有两个通过的测试，每个都有两个断言。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/004434edfd09d163570feeefb781b70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3Y4Be9fofoQacQ2axh32w.png"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="f940" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">用Jest &amp; Enzyme进行单元测试</h1><p id="fe44" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">在进入集成测试之前，我想深入研究一下用酶进行的单元测试，因为它的操作与RTL非常不同。酶允许你操纵和测试状态，这在React中有时是必要的。然而，这意味着我们测试的是代码的<em class="kp">实现</em>，而不是UX，因此应该牢记这一点。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="1988" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">导航到<code class="fe mx my mz na b">src/containers/MgmtHome</code>，并在目录中创建一个<code class="fe mx my mz na b">MgmtHome.test.js</code>文件。将我们的导入添加到文件的顶部:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="d0f5" class="ng lq jg na b gy nh ni l nj nk">import React from 'react';<br/>import { mount } from 'enzyme';<br/>import MgmtHome from './MgmtHome';</span></pre><p id="7356" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">你会在一开始就看到酶抛出了一个错误:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/ae75352d7e53d114aadb486367014e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5aW7bX31MiLBNJIfLc80w.png"/></div></div></figure><p id="cc80" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">因为我们正在用Enzyme测试代码的实现，我们需要更加完整地充实测试环境。首先添加两个额外的开发依赖项:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="61ca" class="ng lq jg na b gy nh ni l nj nk">yarn add enzyme-adapter-react-16 jest-canvas-mock —-dev</span></pre><p id="44d9" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">在您的<code class="fe mx my mz na b">src</code>目录中，创建一个名为<code class="fe mx my mz na b">setupTests.js</code>的新文件。将以下代码复制并粘贴到该文件中:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="be4e" class="ng lq jg na b gy nh ni l nj nk">import { configure } from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';<br/>import 'jest-canvas-mock';</span><span id="1a59" class="ng lq jg na b gy nl ni l nj nk">configure({ adapter: new Adapter() });</span></pre><p id="f1ca" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">再次启动您的测试，您将看到您不再得到先前的错误。相反，我们得到一个错误，因为我们没有在文件中运行测试。回到<code class="fe mx my mz na b">MgmtHome.test.js</code>，让我们开始编写测试。我们将测试利用状态的扩展任务切换。</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="fb3d" class="ng lq jg na b gy nh ni l nj nk">describe('MgmtHome', () =&gt; {<br/>  it('toggles rendering expanded task info in state', () =&gt; {</span><span id="8991" class="ng lq jg na b gy nl ni l nj nk">  })</span><span id="596f" class="ng lq jg na b gy nl ni l nj nk">  it('toggles hiding expanded task info in state', () =&gt; {</span><span id="5fd4" class="ng lq jg na b gy nl ni l nj nk">  })<br/>})</span></pre><p id="b4f9" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">这个应用程序调用数据库获取任务列表，并将它们设置为state。对于我们的测试，我们需要模拟这些任务。这可以通过模仿实际的API调用或者仅仅是模仿对象来实现。因为我们没有测试API功能，所以我们不会在这里模拟它。我们将创建几个模拟的任务对象，我们可以在测试中设置它们的状态:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="5267" class="ng lq jg na b gy nh ni l nj nk">// Add mock tasks<br/>  const mockTasks = [<br/>    {<br/>      id: 1,<br/>      urgency_level: 'High',<br/>      task: {<br/>        name: 'First Task',<br/>        notes: 'This is the first task.',<br/>        status: 'Open'<br/>      },<br/>      resident: {<br/>        first_name: 'Joe',<br/>        last_name: 'Smith',<br/>        email: '<a class="ae jd" href="mailto:joe@example.com" rel="noopener ugc nofollow" target="_blank">joe@example.com</a>',<br/>        unit: 1<br/>      }, <br/>      property : {<br/>        id: 1,<br/>        name: 'First Property'<br/>      }<br/>    },<br/>    {<br/>      id: 2,<br/>      urgency_level: 'Low',<br/>      task: {<br/>        name: 'Second Task',<br/>        notes: 'This is the second task.',<br/>        status: 'Open'<br/>      },<br/>      resident: {<br/>        first_name: 'Jane',<br/>        last_name: 'Doe',<br/>        email: '<a class="ae jd" href="mailto:jane@example.com" rel="noopener ugc nofollow" target="_blank">jane@example.com</a>',<br/>        unit: 2<br/>      }, <br/>      property : {<br/>        id: 2,<br/>        name: 'Second Property'<br/>      }<br/>    }<br/>  ]</span><span id="015d" class="ng lq jg na b gy nl ni l nj nk">  // Set mock tasks to state<br/>  const wrapper = mount(&lt;MgmtHome /&gt;);</span><span id="f708" class="ng lq jg na b gy nl ni l nj nk">  wrapper.setState({<br/>    openTasks: [...mockTasks],<br/>    expandedTask: '',<br/>    activeUpdate: false,<br/>    activeUpdateId: '',<br/>    loading: false<br/>  })</span></pre><p id="bef2" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">然后我们需要找到要点击的<code class="fe mx my mz na b">svg</code>元素(在本例中，任务的<code class="fe mx my mz na b">id</code>为2)，检查状态，再次点击，然后再次检查状态:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="314f" class="ng lq jg na b gy nh ni l nj nk">const secondTaskToggle = wrapper.find('svg').findWhere(s =&gt; s.props().id === 2)</span><span id="f4a0" class="ng lq jg na b gy nl ni l nj nk">it('toggles rendering expanded task info in state', () =&gt; {<br/>  secondTaskToggle.simulate('click');</span><span id="75ef" class="ng lq jg na b gy nl ni l nj nk">  expect(wrapper.state().expandedTask).toEqual('2');<br/>})</span><span id="8ba8" class="ng lq jg na b gy nl ni l nj nk">it('toggles hiding expanded task info in state', () =&gt; {<br/>  secondTaskToggle.simulate('click');<br/>    <br/>  expect(wrapper.state().expandedTask).toEqual('');<br/>})</span></pre><p id="db0c" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">下面是我们最后的测试文件，我们通过了所有的测试。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/02c154ed3870b0d67b52feda243f7e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7MTQY5onOSs3G5fcjLRlw.png"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="5bd6" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Jest &amp; Enzyme集成测试</h1><p id="6189" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">这不是一个非常复杂的应用程序，所以集成测试的机会是有限的。但是我们有用于各种容器的<code class="fe mx my mz na b">Button</code>组件。所以我们要测试这个。请记住，集成测试比单元测试更高级，因为它测试的是一组组件，而不是单个的功能或组件。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="b394" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">在<code class="fe mx my mz na b">src/pages/Landing</code>目录中，创建一个名为<code class="fe mx my mz na b">Landing.test.js</code>的新文件，并将您的导入添加到顶部:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="5600" class="ng lq jg na b gy nh ni l nj nk">import React from 'react';<br/>import { BrowserRouter as Router } from 'react-router-dom';<br/>import { mount } from 'enzyme';<br/>import Landing from './Landing';</span></pre><p id="2d33" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">我们将简单地测试登录页面是否正确地呈现了<code class="fe mx my mz na b">Button</code>组件，或者与该组件集成。我们将<code class="fe mx my mz na b">props</code>向下传递给<code class="fe mx my mz na b">Button</code>组件，并需要确保它按照预期呈现。</p><p id="3b89" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">应该有两个按钮——一个用于注册，一个用于登录。我们将从<code class="fe mx my mz na b">Landing</code>容器中获取文本和<code class="fe mx my mz na b">path props</code>，并使用它们来做出我们的断言:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="ad1e" class="ng lq jg na b gy nh ni l nj nk">describe('Landing page', () =&gt; {<br/>  const wrapper = mount((<br/>    &lt;Router&gt;<br/>      &lt;Landing /&gt;<br/>    &lt;/Router&gt;<br/>  ));</span><span id="de2f" class="ng lq jg na b gy nl ni l nj nk">const authButtons = wrapper.find('a.button');</span><span id="c09b" class="ng lq jg na b gy nl ni l nj nk">it('properly renders the sign up button', () =&gt; {<br/>    const signUp = authButtons.at(0);</span><span id="a5d2" class="ng lq jg na b gy nl ni l nj nk">    expect(signUp.props().href).toEqual('/signup')<br/>    expect(signUp.html()).toContain('Sign Up')<br/>  })</span><span id="2adc" class="ng lq jg na b gy nl ni l nj nk">it('properly renders the sign in button', () =&gt; {<br/>    const signIn = authButtons.at(1);</span><span id="abd5" class="ng lq jg na b gy nl ni l nj nk">    expect(signIn.props().href).toEqual('/signin')<br/>    expect(signIn.html()).toContain('Sign In')<br/>  })<br/>})</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/5174254575a5a31e37421a90acbcd395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ww_q-IQbSRHt-YXNx2TmNg.png"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="7381" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用Cypress进行端到端测试</h1><p id="9fcd" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">在端到端测试中，我们在浏览器中测试用户流<em class="kp">。这是事情变得真正有趣的地方。在继续之前，我建议您退出Jest测试运行程序，并在您的终端中运行<code class="fe mx my mz na b">yarn run cypress open</code>。Cypress将在您的计算机上打开，并将向项目中添加一套示例测试文件，这对了解Cypress测试是什么样子非常有帮助。</em></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="5892" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">我们将使用Cypress测试用户登录流。在<code class="fe mx my mz na b">cypress/integration</code>目录中，创建一个名为<code class="fe mx my mz na b">login.spec.js</code>的新文件。在这个新文件中，我们将开始编写测试。我们将它包装在一个<code class="fe mx my mz na b">describe</code>块中，并声明<code class="fe mx my mz na b">it</code>将做什么:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="b161" class="ng lq jg na b gy nh ni l nj nk">describe('Login', () =&gt; {<br/>  it('authenticates a user', () =&gt; {<br/><br/>  });<br/>});</span></pre><p id="53e1" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">现在我们可以开始编写测试代码了。Cypress测试将从实际访问浏览器中的网页开始。该应用程序设置为在开发中使用<code class="fe mx my mz na b">port 3000</code>上的<code class="fe mx my mz na b">localhost</code>，因此我们的访问方法如下所示:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="6ba4" class="ng lq jg na b gy nh ni l nj nk">cy.visit('http://localhost:3000/');</span></pre><p id="48b3" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">对于我的样式表，我总是使用CSS的动态扩展语言<a class="ae jd" href="https://levelup.gitconnected.com/5-features-of-sass-that-will-make-you-love-css-25e707253ea5" rel="noopener ugc nofollow" target="_blank"> Sass </a>。动态特性对于造型来说很好，但是对于测试来说就不那么好了。我们将使用<code class="fe mx my mz na b">data-test-id</code>约定在需要的地方添加测试选择器。导航到<code class="fe mx my mz na b">src/pages/Landing/Landing</code>，在<code class="fe mx my mz na b">Button</code>的标志上添加<code class="fe mx my mz na b">dataTestId={‘signIn’}</code>作为道具:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/25c3b6a708fdaa2a4b004606b1834a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cp_0RHPgG_c0l6NNZXrqqg.png"/></div></div></figure><p id="445c" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">然后导航到<code class="fe mx my mz na b">src/components/Button/Button</code>，在这里我们将把<code class="fe mx my mz na b">dataTestId</code>添加到我们的<code class="fe mx my mz na b">props</code>析构中，并将它作为值赋给<code class="fe mx my mz na b">Button</code>上的一个<code class="fe mx my mz na b">data-test-id</code>属性。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/056442ad6aedbbe49e6de0c121247a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7oM4ODZjdHLliHFSGNNZw.png"/></div></div></figure><p id="9410" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">接下来，在<code class="fe mx my mz na b">src/pages/Home/Home</code>中，我们将把<code class="fe mx my mz na b">data-test-id=“header”</code>添加到标题<code class="fe mx my mz na b">div</code>中:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/e96c190e7b6dbc52698bef019d9eb8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8z8yN6boaLyGy4T0jbDig.png"/></div></div></figure><p id="902e" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">现在，回到编写测试…</p><p id="3768" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">在告诉Cypress访问浏览器中的页面后，我们将使用我们添加的第一个<code class="fe mx my mz na b">data-test-id</code>来选择<code class="fe mx my mz na b">Button</code>中的标志并单击它:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="8065" class="ng lq jg na b gy nh ni l nj nk">cy.get('[data-test-id="signIn"]').contains('Sign In').click();</span></pre><p id="9daa" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">这应该会将我们带到登录页面。我有用于测试该应用程序的虚拟帐户，因此我们将使用其中一个帐户登录。我们将选择电子邮件输入，模拟键入虚拟帐户电子邮件地址，然后对密码输入进行同样的操作。</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="8aa4" class="ng lq jg na b gy nh ni l nj nk">const emailInput = cy.get('input[name=email');<br/>emailInput.type('<a class="ae jd" href="mailto:Alex@Hamilton.com" rel="noopener ugc nofollow" target="_blank">Alex@Hamilton.com</a>');</span><span id="e00a" class="ng lq jg na b gy nl ni l nj nk">const passwordInput = cy.get('input[name=password');<br/>passwordInput.type('Password1');</span></pre><p id="71b3" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">如果您以前没有使用过Cypress，请观看在Cypress中运行的测试。第一次看到自动化是非常酷的。接下来，我们将找到提交<code class="fe mx my mz na b">button</code>并点击它。这个页面上只有一个<code class="fe mx my mz na b">button</code>元素，所以我们可以使用:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="e71b" class="ng lq jg na b gy nh ni l nj nk">cy.get('button').click();</span></pre><p id="0f61" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">最后，我们将做出我们的断言。我们知道这个帐户是一个有效的虚拟帐户，所以在这个流中，我们希望用户被验证并登录。我们将通过断言我们已经被重定向到用户的主页来检查这一点:</p><pre class="mt mu mv mw gt nc na nd ne aw nf bi"><span id="5c64" class="ng lq jg na b gy nh ni l nj nk">cy.get('[data-test-id="header"]').should('contain', 'Home');</span></pre><p id="0413" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">仅此而已。简单得令人难以置信。您的<code class="fe mx my mz na b">login.spec.js</code>文件现在应该看起来像下面这样。作为一个额外的挑战，通过注销用户来结束测试——这样，当您再次运行测试时，您不会从主页上的登录用户开始(该应用程序基于用户的身份验证状态利用重定向)。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/223579e0478da8164ab13903dc7b1a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkGegcqLLClHAOPPz5dD9g.png"/></div></div></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="e4d8" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">对于新开发人员来说，前端测试可能是一个令人生畏的开始过程，但是一旦你投入进去，它真的非常简单。有了这个项目或你一直在跟进的任何项目中已经建立的基础设施，现在花一些时间继续尝试——这是最好的学习方式。您可以在<a class="ae jd" href="https://github.com/bbennett7/properti-web-app/tree/testing" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中查看包含所有测试和配置的分支。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="cfa5" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">之前的</strong>:<a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-5-end-to-end-testing-with-cypress-bd2bf8d3385f" rel="noopener">React中的测试，第5部分:与Cypress的端到端测试</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="cbdf" class="ng lq jg bd lr nx ny dn lv nz oa dp lz lm ob oc md ln od oe mh lo of og ml oh bi translated"><strong class="ak">资源</strong></h2><ul class=""><li id="c09f" class="oi oj jg kq b kr mn kv mo lm ok ln ol lo om ll on oo op oq bi translated"><a class="ae jd" href="https://jestjs.io/docs/en/getting-started" rel="noopener ugc nofollow" target="_blank"> Jest文档</a></li><li id="2637" class="oi oj jg kq b kr or kv os lm ot ln ou lo ov ll on oo op oq bi translated"><a class="ae jd" href="https://github.com/testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank"> Jest Dom文档</a></li><li id="5796" class="oi oj jg kq b kr or kv os lm ot ln ou lo ov ll on oo op oq bi translated"><a class="ae jd" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank"> React测试库文档</a></li><li id="2ef7" class="oi oj jg kq b kr or kv os lm ot ln ou lo ov ll on oo op oq bi translated"><a class="ae jd" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶文档</a></li><li id="01a0" class="oi oj jg kq b kr or kv os lm ot ln ou lo ov ll on oo op oq bi translated"><a class="ae jd" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank">柏树文档</a></li></ul></div></div>    
</body>
</html>