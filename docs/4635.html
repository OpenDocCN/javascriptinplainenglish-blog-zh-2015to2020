<html>
<head>
<title>Implementing a Linked List in ES6 JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ES6 JavaScript中实现链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-a-linked-list-in-es6-javascript-be896ed51d5f?source=collection_archive---------5-----------------------#2020-12-27">https://javascript.plainenglish.io/implementing-a-linked-list-in-es6-javascript-be896ed51d5f?source=collection_archive---------5-----------------------#2020-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/319d9d40045eb9f55330404d5d32a579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J52kyHZLhYka_W-y"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@daniel_von_appen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel von Appen</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1eff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">链表是一种线性数据结构。数据结构是一个计算机科学术语，用来指数据存储、组织和管理的方法。JavaScript中您可能已经熟悉的一些数据结构是数组和对象。类似于不同的算法，不同的数据结构有独特的优点、缺点和用例。让我们看看如何使用JavaScript ES6类实现一个链表。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="458d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是链表？</h1><p id="ec30" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">链表是由节点组成的数据结构。每个节点至少有两个组件，它保存的数据和对列表中下一个节点的引用(称为指针)。链表中的第一个节点叫做<em class="mi">头</em>，链表中的最后一个节点叫做<em class="mi">尾。</em>链表有几种。单向链表只包含一个指向其后节点的指针，双向链表包含一个指向前后节点的指针，而在循环链表中，尾部指向列表中较早的一个节点(通常是头部),作为后面的节点，这就形成了一个循环。</p><h2 id="1566" class="mj lg in bd lh mk ml dn ll mm mn dp lp kl mo mp lt kp mq mr lx kt ms mt mb mu bi translated">数组与链表</h2><p id="252e" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">数组占用内存中的连续空间。也就是说，在物理内存中，数组的每个元素都与该数组的其他元素相邻。数组还为它的每个元素留出相同数量的内存。因此，很容易对数组中的元素执行随机查找。如果我们知道数组的第一个元素在内存中的位置，并且每个元素占用相同的空间，并且紧挨着前面的元素，我们就可以计算出数组中任何元素的内存地址。另一方面，链表的节点在内存中并不相邻，这就是为什么我们有一个指向链表中下一个节点的引用。然而，正因为如此，每个节点只需要占用存储其数据和指向其他节点的指针所需的空间。</p><h1 id="e9fe" class="lf lg in bd lh li mv lk ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc bi translated">利弊</h1><h2 id="9f61" class="mj lg in bd lh mk ml dn ll mm mn dp lp kl mo mp lt kp mq mr lx kt ms mt mb mu bi translated">赞成的意见</h2><ul class=""><li id="030e" class="na nb in kc b kd md kh me kl nc kp nd kt ne kx nf ng nh ni bi translated"><strong class="kc io">不浪费内存</strong>。如前所述，链表中的每个节点只占用存储数据和指针所需的内存。</li><li id="63b1" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><strong class="kc io">轻松插入新节点</strong>。在一个数组中，当你添加一个元素时，你必须移动它后面出现的每个元素，这样它们仍然保留在连续的内存中。在链表中，新的节点可以放在内存中任何有空闲空间的地方，你只需要改变指针。</li><li id="21d6" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><strong class="kc io">轻松删除节点</strong>。类似于插入，当从链表中删除一个节点时，你需要做的就是告诉它前面的节点指向它后面的节点。那么没有一个节点会指向你想删除的节点，它也不再是链表的一部分。</li><li id="a4e6" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><strong class="kc io">动态尺寸</strong>。在某些语言中，当初始化一个数组时，你需要明确说明它将包含多少元素，以及这些元素是什么类型的。您不需要在JavaScript中这样做，但是，当一个数组变得太大而不适合内存中的连续空间时，每个元素都必须复制到一个有足够空间的新位置。所有这些都是在幕后进行的，很容易不去想。这在链表中是不会发生的，所以只要有足够的内存来存储它们各自的数据和指针，你就可以继续添加节点。</li></ul><h2 id="9d16" class="mj lg in bd lh mk ml dn ll mm mn dp lp kl mo mp lt kp mq mr lx kt ms mt mb mu bi translated">骗局</h2><ul class=""><li id="08a8" class="na nb in kc b kd md kh me kl nc kp nd kt ne kx nf ng nh ni bi translated"><strong class="kc io">每个节点占用更多内存</strong>。因为我们必须存储数据和指针。</li><li id="fb1a" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><strong class="kc io">无随机存取</strong>。在链表中查找后续节点的唯一方法是跟随指针。</li><li id="648b" class="na nb in kc b kd nj kh nk kl nl kp nm kt nn kx nf ng nh ni bi translated"><strong class="kc io">反向穿越困难</strong>。在一个单独的链表中很难回溯，因为只有一个指向下一个节点的指针。在双链表中更容易，但是额外的指针会消耗更多的内存。</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="9dc6" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用JavaScript编写单链表</h1><p id="14b7" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">编写链表的第一步是创建一个<code class="fe no np nq nr b">ListNode</code>类。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="8f27" class="mj lg in nr b gy oa ob l oc od">class ListNode {<br/>  constructor(data) {<br/>    this.data = data;<br/>    this.next = null;<br/>  }<br/>}</span></pre><p id="de79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个简单的类如上所述。它保存着我们的数据(可以是字符串、整数、对象、数组，甚至其他节点)，并且它有一个对下一个节点的引用。在你的终端里，你可以尝试一下。制作几个这样的节点:</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="f7f2" class="mj lg in nr b gy oa ob l oc od">let node1 = new ListNode(1);<br/>let node2 = new ListNode(2);<br/>node1.next = node2;</span></pre><p id="a7fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后如果你检查<code class="fe no np nq nr b">node1.next</code>你会看到它返回<code class="fe no np nq nr b">node2</code>。您可以继续这个过程，事实上，您可以通过这样做来创建一个链表。然而，在另一个类中封装该功能和更多功能会很好。</p><p id="90c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以这正是我们要做的。让我们上<code class="fe no np nq nr b">LinkedList</code>课吧。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="dbc7" class="mj lg in nr b gy oa ob l oc od">class LinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>    this.size = 0;<br/>  }<br/>}</span></pre><p id="55e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个链表都需要跟踪它的<code class="fe no np nq nr b">head</code>和<code class="fe no np nq nr b">size</code>。</p><p id="508f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从现在开始，其余的方法将在我们的<code class="fe no np nq nr b">LinkedList</code>类中。</p><p id="52b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们接下来需要的是向我们的<code class="fe no np nq nr b">LinkedList</code>添加一个新节点的功能。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="645a" class="mj lg in nr b gy oa ob l oc od">add(data) {<br/>  let newNode = new ListNode(data);</span><span id="a842" class="mj lg in nr b gy oe ob l oc od">  if (this.head === null) {<br/>    this.head = newNode;<br/>  } else {<br/>    let currentNode = this.head;<br/>    while (!!currentNode.next) {<br/>      currentNode = currentNode.next;<br/>    }</span><span id="aeec" class="mj lg in nr b gy oe ob l oc od">    currentNode.next = newNode;<br/>  }<br/>  this.size++;<br/>}</span></pre><p id="d1bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe no np nq nr b">add</code>方法接收新节点的数据。从那里，它初始化一个<code class="fe no np nq nr b">ListNode</code>的新实例。我们检查我们的链表是否有一个头节点，如果没有，我们把我们的新节点指定为链表的头。否则，我们创建一个while循环来遍历链表，从<code class="fe no np nq nr b">head</code>节点开始，直到找到一个没有<code class="fe no np nq nr b">next</code>指针的节点。一旦我们找到那个节点，我们知道我们已经到达了我们的单链表的尾部，所以我们把我们的<code class="fe no np nq nr b">newNode</code>赋值给<code class="fe no np nq nr b">next</code>值，把它添加到链表中(新的节点现在是链表的尾部)。做完所有这些后，我们增加链表的<code class="fe no np nq nr b">size</code>。</p><p id="0743" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以添加一个节点，接下来我们可能要做的是检索一个节点。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="fd8b" class="mj lg in nr b gy oa ob l oc od">getNodeAt(index) {<br/>    if (index &lt; 0 || index &gt; this.size - 1) {<br/>      return undefined;<br/>    } else {<br/>      let currentNode = this.head;<br/>    for (let i = 0; i &lt; index; i++) {<br/>      currentNode = currentNode.next;<br/>    }<br/>    return currentNode;<br/>  }<br/>}</span></pre><p id="f7c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的链表将被索引。如果有人传入一个负数，或者一个大于链表中索引数的数(比我们的<code class="fe no np nq nr b">size</code>少一个)，我们将返回<code class="fe no np nq nr b">undefined</code>。否则，我们需要遍历链表，直到到达所需索引处的节点。因为我们将<code class="fe no np nq nr b">currentNode</code>分配给列表中的下一个节点<em class="mi">，所以我们将在距离索引1处停止。一旦我们脱离了<code class="fe no np nq nr b">while</code>循环，我们只需要返回<code class="fe no np nq nr b">currentNode</code>。</em></p><p id="fafa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以添加和检索节点，是时候弄清楚如何删除它们了。首先，让我们按索引删除。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="aacb" class="mj lg in nr b gy oa ob l oc od">removeFrom(index) {<br/>    if (index &lt; 0 || index &gt; this.size - 1) {<br/>      return undefined;<br/>    } else {<br/>      let currentNode = this.head;</span><span id="6436" class="mj lg in nr b gy oe ob l oc od">      if (index === 0) {<br/>        this.head = currentNode.next;<br/>      } else {<br/>        let previousNode;<br/>        for (let i = 0; i &lt; index; i++) {<br/>          previousNode = currentNode;<br/>          currentNode = currentNode.next;<br/>        }<br/>        previousNode.next = currentNode.next;<br/>      }<br/>      this.size--;<br/>      return currentNode.data;<br/>    }<br/>  }</span></pre><p id="4c82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们在我们的<code class="fe no np nq nr b">removeFrom</code>方法的开始执行一个类似的检查，以确保传入的索引是有效的。之后，我们将<code class="fe no np nq nr b">currentNode</code>赋给头部，如果<code class="fe no np nq nr b">index</code>为0，我们知道我们想要移除头部节点。我们可以通过简单地将链表的头分配给它后面的节点来实现。</p><p id="2e07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">否则，我们需要开始遍历链表，跟踪<code class="fe no np nq nr b">previousNode</code>。对于链表中的每个循环，我们将把<code class="fe no np nq nr b">previousNode</code>分配给旧的<code class="fe no np nq nr b">currentNode</code>，并把<code class="fe no np nq nr b">currentNode</code>重新分配给它后面的节点。一旦我们在我们的索引，<code class="fe no np nq nr b">currentNode</code>是我们想要删除的节点。所以，我们需要做的是让<code class="fe no np nq nr b">previousNode</code>指向 <code class="fe no np nq nr b">currentNode</code>之后的节点<em class="mi">。因此，我们告诉<code class="fe no np nq nr b">previousNode</code>指向<code class="fe no np nq nr b">currentNode</code>当前指向的任何东西。现在我们的链表中没有一个节点指向<code class="fe no np nq nr b">currentNode</code>！从那里我们只需要减少<code class="fe no np nq nr b">size</code>。</em></p><p id="98e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果我们不知道要删除的节点的索引呢？让我们创建一个方法，根据存储的数据删除一个节点。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="2e0e" class="mj lg in nr b gy oa ob l oc od">removeNode(data) {<br/>    let currentNode = this.head;<br/>    let previousNode;<br/>    while (!!currentNode) {<br/>      if (currentNode.data === data) {<br/>        if (previousNode) {<br/>          previousNode.next = currentNode.next;<br/>        } else {<br/>          this.head = currentNode.next;<br/>        }<br/>        this.size--;<br/>        return currentNode.data;<br/>      }<br/>      previousNode = currentNode;<br/>      currentNode = currentNode.next;<br/>    }<br/>    return undefined;<br/>}</span></pre><p id="7c14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像之前我们需要遍历链表一样，从头部开始。我们还需要存储之前的节点。我们的<code class="fe no np nq nr b">while</code>循环正在检查以确保<code class="fe no np nq nr b">currentNode</code>存在，因为一旦我们通过了尾部<code class="fe no np nq nr b">currentNode</code>就会是<code class="fe no np nq nr b">null</code>。因此，在每次迭代中，我们检查由<code class="fe no np nq nr b">currentNode</code>存储的数据是否等于我们希望移除的节点的数据。如果是，我们检查<code class="fe no np nq nr b">previousNode</code>是否存在。如果是，我们做与上面相同的事情，并使<code class="fe no np nq nr b">previousNode</code>指向<code class="fe no np nq nr b">currentNode</code>之后的节点。如果<code class="fe no np nq nr b">previousNode</code>未定义，那么我们知道数据存储在头节点，所以我们将头节点重新分配给下一个节点，将其从链表中移除。之后，我们减少大小并返回，中断while循环。如果我们遍历整个链表，没有找到保存数据的节点，我们将返回<code class="fe no np nq nr b">undefined</code>。</p><p id="8954" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以添加、检索和删除元素。我们需要创建它，这样我们就可以在链表中插入一个新的节点，而不仅仅是添加到末尾。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="a6a1" class="mj lg in nr b gy oa ob l oc od">insertAt(index, data) {<br/>    if (index &lt; 0 || index &gt; this.size - 1) {<br/>      return undefined;<br/>    } else {<br/>      let newNode = new ListNode(data);<br/>      if (index === 0) {<br/>        newNode.next = this.head;<br/>        this.head = newNode;<br/>      } else {<br/>        let currentNode = this.head;<br/>        let previousNode;<br/>        for (let i = 0; i &lt; index; i++) {<br/>          previousNode = currentNode;<br/>          currentNode = currentNode.next;<br/>        }</span><span id="69b7" class="mj lg in nr b gy oe ob l oc od">        previousNode.next = newNode;<br/>        newNode.next = currentNode;<br/>      }</span><span id="9b07" class="mj lg in nr b gy oe ob l oc od">      this.size++;<br/>    }<br/>} </span></pre><p id="e620" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们检查以确保我们的索引是有效的。如果是，我们初始化一个新的节点。如果<code class="fe no np nq nr b">index</code>为0，我们将向列表中添加一个新的头。因此，我们将<code class="fe no np nq nr b">newNode</code>的下一个指针赋给当前的头，然后将链表的头重新赋给<code class="fe no np nq nr b">newNode</code>。否则，我们需要遍历链表。类似于我们移除节点时的操作。一旦我们找到了想要插入的索引之前的节点，以及当前驻留在那里的节点，我们就将<code class="fe no np nq nr b">previousNode</code>的下一个指针分配给我们的<code class="fe no np nq nr b">newNode</code>，然后将<code class="fe no np nq nr b">newNode</code>的指针分配给<code class="fe no np nq nr b">currentNode</code>(曾经在该索引处的节点)。</p><p id="5c5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的下一个方法将返回保存一些数据的节点的索引。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="c1cb" class="mj lg in nr b gy oa ob l oc od">indexOf(data) {<br/>  let currentNode = this.head;<br/>  let index = 0;<br/>  while (!!currentNode) {<br/>   if (currentNode.data === data) {<br/>     return index;<br/>    } else {<br/>     currentNode = currentNode.next;<br/>    index++;<br/>   }<br/> }<br/> return -1;<br/>}</span></pre><p id="faaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们只是遍历链表，跟踪索引，如果找到保存数据的节点，就返回那个索引。如果我们的链表没有包含该数据的节点，我们将返回-1。这复制了JavaScript内置的<code class="fe no np nq nr b">indexOf</code>函数在字符串或数组上的功能。</p><p id="eba9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想清除我们的链表呢？嗯，过程其实很简单。</p><pre class="ns nt nu nv gt nw nr nx ny aw nz bi"><span id="1375" class="mj lg in nr b gy oa ob l oc od">clear() {<br/>  this.head = null;<br/>  this.size = 0;<br/>}</span></pre><p id="9db2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果没有对头部的引用，我们的链表也会丢失对其余节点的引用，然后我们只需将大小重置为0。</p><p id="6064" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些方法将提供链表的基本功能。当然，根据您需要的功能，您还可以添加更多的方法。我们可以添加、插入、删除和查找所有节点，也可以完全清空列表。</p><h1 id="d87d" class="lf lg in bd lh li mv lk ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc bi translated">最后</h1><p id="7b5a" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">链表是一种简单的数据结构，但是习惯使用指针和顺序遍历可能需要很大的调整。这篇博客中的所有代码都可以在GitHub repo 中找到<a class="ae jz" href="https://github.com/ReginaF2012/JavaScript_LinkedList" rel="noopener ugc nofollow" target="_blank">。链表的优势实际上来自于它的动态内存，以及从链表的开始和中间添加和删除节点的便利性。当你需要频繁地前进和后退时，可以使用双向链表(比如浏览网页，撤销和重做文本/图像编辑器，或者遍历音乐播放列表)。理解链表也有助于理解其他带有指针的数据结构，比如树和图。</a></p></div></div>    
</body>
</html>