<html>
<head>
<title>Nuxt.js — Error Pages, Async, and Request Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt.js —错误页面、异步和请求数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nuxt-js-error-pages-async-and-request-data-cc58452c8a8c?source=collection_archive---------3-----------------------#2020-12-26">https://javascript.plainenglish.io/nuxt-js-error-pages-async-and-request-data-cc58452c8a8c?source=collection_archive---------3-----------------------#2020-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6a471833600e96d99d9ae8e38aaa646b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2uQjjnE8L6uSvPJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aniket940518?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aniket Bhattacharya</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bae2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Nuxt.js是一个基于Vue.js的应用框架。</p><p id="28fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来创建服务器端渲染应用和静态站点。</p><p id="392c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用Nuxt.js添加错误页面、获取异步数据以及获取请求数据。</p><h1 id="2b0f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">错误页面</h1><p id="caf7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将pages文件放在<code class="fe me mf mg mh b">layouts</code>文件夹中，向Nuxt应用程序添加一个错误页面。</p><p id="ab67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想在得到404错误时显示一个页面，我们添加一个<code class="fe me mf mg mh b">layouts/error.js</code>文件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d798" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;h1 v-if="error.statusCode === 404"&gt;Page not found&lt;/h1&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="cf3a" class="mq lc iq mh b gy mv ms l mt mu">&lt;script&gt;<br/>export default {<br/>  props: ["error"],<br/>};<br/>&lt;/script&gt;</span></pre><p id="ce1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个<code class="fe me mf mg mh b">error</code>属性，我们可以检查<code class="fe me mf mg mh b">statusCode</code>属性以获得错误状态代码。</p><h1 id="7e76" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">页</h1><p id="e28b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">页面具有特殊的属性和功能，使我们的通用应用程序的开发。</p><p id="9437" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们的页面可能看起来像:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="128a" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div&gt;hello {{ name }}&lt;/div&gt;<br/>&lt;/template&gt;</span><span id="3515" class="mq lc iq mh b gy mv ms l mt mu">&lt;script&gt;<br/>export default {<br/>  asyncData(context) {<br/>    return { name: "world" };<br/>  },<br/>  fetch() {<br/>    //...<br/>  },<br/>  head() {<br/>    return { foo: "bar" };<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="ab17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">asyncData</code>方法让我们在加载组件之前设置状态。</p><p id="5ac2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回的对象将与我们的数据对象合并。</p><p id="2a74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fetch</code>方法让我们在呈现页面之前填充存储。</p><p id="21a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为页面设置元标签。</p><p id="19c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">loading</code>防止页面在我们进入时自动调用<code class="fe me mf mg mh b">this.$nuxt.$loading.finish()</code>，在我们离开时自动调用<code class="fe me mf mg mh b">this.$nuxt.$loading.start()</code>。</p><p id="ebb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以手动控制行为。</p><p id="dbc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">transition</code>为页面定义一个特定的过渡。</p><p id="a176" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">scrollToTop</code>是一个布尔值，它指定我们是否要在呈现页面之前滚动到顶部。</p><p id="57e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">validate</code>是动态路线的验证器功能。</p><p id="8d23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">middleware</code>定义页面的中间件。</p><h1 id="e87f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步数据</h1><p id="94ff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">asyncData</code>方法获取数据。</p><p id="f87e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在代码中使用Axios拦截器，那么我们必须首先创建它的一个实例。</p><p id="f4d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de3b" class="mq lc iq mh b gy mr ms l mt mu">import axios from 'axios'<br/>const myAxios = axios.create({<br/>  // ...<br/>})<br/>myAxios.interceptors.response.use(<br/>  function (response) {<br/>    return response.data<br/>  },<br/>  function (error) {<br/>    // ...<br/>  }<br/>)</span></pre><p id="c225" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe me mf mg mh b">asyncData</code>方法中，我们可以用它来返回一个承诺。</p><p id="d5d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de28" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div&gt;{{ title }}&lt;/div&gt;<br/>&lt;/template&gt;</span><span id="171d" class="mq lc iq mh b gy mv ms l mt mu">&lt;script&gt;<br/>import axios from "axios";</span><span id="9fe7" class="mq lc iq mh b gy mv ms l mt mu">export default {<br/>  async asyncData({ params }) {<br/>    const { data } = await axios.get(<br/>      `https://jsonplaceholder.typicode.com/posts/${params.id}`<br/>    );<br/>    return { title: data.title };<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="2579" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe me mf mg mh b">asyncData</code>方法，它接受一个具有<code class="fe me mf mg mh b">params</code>属性的对象。</p><p id="ca0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有我们页面的URL参数。</p><p id="7105" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">axios</code>来获取我们想要的数据并返回解析后的值。</p><p id="450f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以从我们的组件中检索解析的对象。</p><h1 id="0beb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">背景</h1><p id="5c20" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">asyncData</code>的上下文参数也具有<code class="fe me mf mg mh b">req</code>和<code class="fe me mf mg mh b">res</code>属性。</p><p id="8155" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">req</code>有请求对象。</p><p id="c8ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">res</code>有了回应。</p><p id="74bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用请求数据之前，我们使用<code class="fe me mf mg mh b">process.server</code>检查页面是否是服务器端呈现的。</p><p id="bddf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><p id="b932" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pages/hello.vue</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac2b" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div class="container"&gt;{{host}}&lt;/div&gt;<br/>&lt;/template&gt;</span><span id="d651" class="mq lc iq mh b gy mv ms l mt mu">&lt;script&gt;<br/>export default {<br/>  async asyncData({ req, res }) {<br/>    if (process.server) {<br/>      return { host: req.headers.host };<br/>    }<br/>    return {};<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="0167" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">process.server</code>是<code class="fe me mf mg mh b">true</code>，那么我们就可以使用<code class="fe me mf mg mh b">req</code>对象来获取请求数据。</p><h1 id="8581" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="19c5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在我们的页面中使用Nuxt获取请求数据。</p><p id="4f77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们还可以创建自己的错误页。</p><p id="ead4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用异步数据初始化我们的页面。</p><p id="5303" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样的话，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">就能获得更多类似的内容！</strong></p></div></div>    
</body>
</html>