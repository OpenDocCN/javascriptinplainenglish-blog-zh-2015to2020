<html>
<head>
<title>Pancake Sorting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的煎饼排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/pancake-sorting-in-javascript-ecc1486e7e33?source=collection_archive---------4-----------------------#2020-07-12">https://javascript.plainenglish.io/pancake-sorting-in-javascript-ecc1486e7e33?source=collection_archive---------4-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c4ed" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">你可能想知道，煎饼排序是什么？🧐</h2></div><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="8ead" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><a class="ae lf" href="https://en.wikipedia.org/wiki/Pancake_sorting" rel="noopener ugc nofollow" target="_blank"> <strong class="kl io">煎饼分拣</strong> </a> <strong class="kl io">，</strong>顾名思义，类似于用锅铲分拣盘子里的煎饼，在这里你只能用锅铲翻动盘子里一些最上面的煎饼。如图所示，抹刀正在翻转最上面的三个煎饼，结果如下所示。与传统的排序算法不同，传统的排序算法以尽可能少的比较进行排序，目标是以尽可能少的反转对序列进行排序。</p><figure class="kc kd ke kf gt kg gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/1e96caa7d5c1c9e69b7d73e15f02f8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*Mrt8VwvryQxyK9BapQsJlA.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Demonstration of pancake sorting</figcaption></figure><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="ln ki l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Visualization of Pancake sorting</figcaption></figure><p id="8f67" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">对于排序一个未排序的数组，类似于选择排序，我们一个接一个地将最大元素放在最后，并将当前数组的大小减少一。</p><p id="a86b" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如何在JavaScript中实现煎饼排序？让我们来看一个例子(这个例子出自<a class="ae lf" href="https://www.pramp.com/#/" rel="noopener ugc nofollow" target="_blank"><strong class="kl io">Pramp.com</strong></a>)。</p><h1 id="c6e7" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">煎饼排序</h1><p id="ad30" class="pw-post-body-paragraph kj kk in kl b km mg jo ko kp mh jr kr ks mi ku kv kw mj ky kz la mk lc ld le ig bi translated">给定一个整数数组<code class="fe ml mm mn mo b">arr</code>:</p><ol class=""><li id="1c61" class="mp mq in kl b km kn kp kq ks mr kw ms la mt le mu mv mw mx bi translated">编写一个函数<code class="fe ml mm mn mo b">flip(arr, k)</code>，它反转数组<code class="fe ml mm mn mo b">arr</code>中第一个<code class="fe ml mm mn mo b">k</code>元素的顺序。</li><li id="7ff2" class="mp mq in kl b km my kp mz ks na kw nb la nc le mu mv mw mx bi translated">写一个函数<code class="fe ml mm mn mo b">pancakeSort(arr)</code>，排序并返回输入数组。您只允许使用您在第一步中编写的函数<code class="fe ml mm mn mo b">flip</code>来修改数组。</li></ol><p id="2e8d" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">示例:</strong></p><pre class="kc kd ke kf gt nd mo ne nf aw ng bi"><span id="3ce8" class="nh lp in mo b gy ni nj l nk nl">input:  arr = [1, 5, 4, 3, 2]<br/>output: [1, 2, 3, 4, 5]   <em class="nm"># to clarify, this is pancakeSort's output</em></span></pre><p id="4c1c" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">分析解决方案的时间和空间复杂性。</p><p id="c677" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">约束:</strong></p><ul class=""><li id="1a09" class="mp mq in kl b km kn kp kq ks mr kw ms la mt le nn mv mw mx bi translated">【时限】5000ms</li><li id="88f2" class="mp mq in kl b km my kp mz ks na kw nb la nc le nn mv mw mx bi translated">[输入] array.integer <code class="fe ml mm mn mo b">arr</code></li><li id="0ce0" class="mp mq in kl b km my kp mz ks na kw nb la nc le nn mv mw mx bi translated">【输入】整数<code class="fe ml mm mn mo b">k</code></li><li id="f665" class="mp mq in kl b km my kp mz ks na kw nb la nc le nn mv mw mx bi translated">0 ≤ k</li><li id="c0a2" class="mp mq in kl b km my kp mz ks na kw nb la nc le nn mv mw mx bi translated">[输出] array.integer</li></ul><p id="a2a6" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">第一部分，flip()是pancakeSort()中的辅助函数。像任何其他排序算法一样，该算法的关键部分是通过迭代逐步对数组进行排序。我们设计了一种算法，将最大元素发送到数组的最后一个位置，并以此作为迭代步骤。为了找到最大元素索引，我们实现了另一个辅助函数findMaxIndex()。</p><p id="f3b9" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">翻转()</strong></p><p id="d42b" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">给定一个数组和一个整数k，我们翻转第一个k元素，这将是从0到k的元素，并颠倒顺序。</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae lf" href="https://gist.github.com/GAierken/68f8cd27b8fc2ae3b15af9ba70d11191" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/68f8cd27b8fc2ae3b15af9ba70d11191</a></figcaption></figure><p id="c9b9" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io"> findMaxIndex() </strong></p><p id="02f0" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">为了找到max元素的位置，我们用最小值声明一个max变量，索引从0开始。我们遍历arr，返回最大索引。</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div></figure><p id="b98a" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io"> pancakeSort() </strong></p><p id="3294" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">从等于arr.length的当前大小开始，当当前大小大于1时，将当前大小减1。设当前大小为“I”。对每个“我”做以下事情。</p><ol class=""><li id="cb81" class="mp mq in kl b km kn kp kq ks mr kw ms la mt le mu mv mw mx bi translated">查找arr[0]中最大元素的索引..i-1]。设索引为' maxIndex '</li><li id="1a89" class="mp mq in kl b km my kp mz ks na kw nb la nc le mu mv mw mx bi translated">呼叫翻转(arr，maxIndex)</li><li id="ca01" class="mp mq in kl b km my kp mz ks na kw nb la nc le mu mv mw mx bi translated">呼叫翻转(arr，i-1)</li></ol><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae lf" href="https://gist.github.com/GAierken/2d787ac6952053ca943dff75eeb89530" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/2d787ac6952053ca943dff75eeb89530</a></figcaption></figure></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><p id="17f8" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kl io">最终解决方案</strong>将如下所示。</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="kh ki l"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk"><a class="ae lf" href="https://gist.github.com/GAierken/a9f34b1006a6205151621e35a84cf45c" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/a9f34b1006a6205151621e35a84cf45c</a></figcaption></figure><p id="f375" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">整体时间复杂度为<strong class="kl io"> O(n ) </strong>。</p><p id="d0cd" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这是操场的链接。希望这有所帮助。</p><figure class="kc kd ke kf gt kg"><div class="bz fp l di"><div class="ln ki l"/></div></figure><p id="cd63" class="pw-post-body-paragraph kj kk in kl b km kn jo ko kp kq jr kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="nm">参考文献:</em></p><div class="nv nw gp gr nx ny"><a href="https://en.wikipedia.org/wiki/Pancake_sorting" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd io gy z fp od fr fs oe fu fw im bi translated">煎饼分类</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">煎饼排序是对一堆杂乱的煎饼进行排序的数学问题的通俗说法</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">en.wikipedia.org</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om lh ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://www.geeksforgeeks.org/pancake-sorting/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd io gy z fp od fr fs oe fu fw im bi translated">煎饼分类- GeeksforGeeks</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">给定一个未排序的数组，对给定的数组进行排序。您只能对数组执行以下操作。翻转(arr，i)…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="oh l"><div class="on l oj ok ol oh om lh ny"/></div></div></a></div></div></div>    
</body>
</html>