<html>
<head>
<title>Improve your coding style using Module Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模块模式改进您的编码风格</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improve-your-coding-style-using-module-pattern-25543264e5f3?source=collection_archive---------5-----------------------#2020-10-15">https://javascript.plainenglish.io/improve-your-coding-style-using-module-pattern-25543264e5f3?source=collection_archive---------5-----------------------#2020-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3041cf06874a5c87cec1c826b56a6f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6eeOICa8FtV2zc31"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alexacea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexandru Acea</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1d68" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">设计模式</h1><p id="9158" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">设计模式通常用于解决软件开发中常见的问题。有人可能想知道为什么我们甚至需要设计模式？解决问题的方法有一百万种，但是既然问题已经解决了，我们为什么还要考虑去解决它呢？设计模式建立了解决问题的标准结构方法，这些方法已经被证明是有效的。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="df9d" class="kd ke iq bd kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la bi translated">设计模式的类型</h1><p id="d3a4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">根据模式解决的问题类型，它们被分为三类:</p><h2 id="b6ec" class="ml ke iq bd kf mm mn dn kj mo mp dp kn lm mq mr kr lq ms mt kv lu mu mv kz mw bi translated">创造模式</h2><p id="4aa1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在实例化一个类时，也就是在创建一个对象的过程中，它处理不同的机制。</p><h2 id="05ce" class="ml ke iq bd kf mm mn dn kj mo mp dp kn lm mq mr kr lq ms mt kv lu mu mv kz mw bi translated">结构模式</h2><p id="b441" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在处理大型应用程序时，它处理多个类和对象的组织，以保持可伸缩性和效率。</p><h2 id="7c87" class="ml ke iq bd kf mm mn dn kj mo mp dp kn lm mq mr kr lq ms mt kv lu mu mv kz mw bi translated">行为模式</h2><p id="2a6f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">它处理任何两个对象之间通信过程中涉及的问题。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="4991" class="kd ke iq bd kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la bi translated">模块模式</h1><p id="48bc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">模块模式是一种结构模式，它将相关的函数、类或单体组合成一个实体。它是最常用的Javascript模式之一，非常强大，因为它有助于构建通用代码。</p><p id="7b33" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">模块模式定义了如何定义对象，以及如何在各自的作用域之外访问特定于某个类的函数。通过将一个方法定义为public或private，我们可以控制它如何在范围之外公开，并且通过这样做，数据隐藏和数据抽象也可以在这个模式中实现。</p><p id="e2bf" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">下面是模块模式的一个简单实现:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="5ac2" class="ml ke iq nh b gy nl nm l nn no">function CarDetails() {<br/>  var name = 'Chiron';<br/>  var manufacturer = 'Bugatti';<br/>  return {<br/>    name: name,<br/>    manufacturer: manufacturer<br/>  }<br/>}<br/>var newCar = CarDetails();<br/>var carName = newCar.name; // Chiron<br/>var manufacturer = newCar.manufacturer; // Bugatti</span></pre><p id="d490" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">上面的代码描述了汽车的细节是如何包装在一个函数中的。与新车相关的属性，如<code class="fe np nq nr nh b">name</code>或<code class="fe np nq nr nh b">manufacturer</code>，可以通过为该类创建一个对象来访问，因为它们都是公开的。在这里，与汽车相关的所有属性都被打包到一个名为<code class="fe np nq nr nh b">CarDetails</code>的模块中。</p><h1 id="2770" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">模块模式中的数据隐藏</h1><p id="6bdc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">检查下面的代码，它对外界隐藏了属性<code class="fe np nq nr nh b">price</code>和<code class="fe np nq nr nh b">tax</code>:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f79c" class="ml ke iq nh b gy nl nm l nn no">function CarDetails() {<br/>  var name = 'Chiron';<br/>  var manufacturer = 'Bugatti';<br/>  var price = 190000000;<br/>  var tax = 10;<br/>  var totalPrice = function() {<br/>    return price + (price * tax)/100;<br/>  }<br/>  return {<br/>    name: name,<br/>    manufacturer: manufacturer,<br/>    totalPrice: totalPrice<br/>  }<br/>}<br/>var newCar = CarDetails();<br/>var carName = newCar.name; //Chiron<br/>var manufacturer = newCar.manufacturer; // Bugatti<br/>var totalPrice = newCar.totalPrice(); // 209000000<br/>var tax = newCar.tax; // undefined</span></pre><p id="d410" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">函数<code class="fe np nq nr nh b">totalPrice</code>帮助执行私有变量<code class="fe np nq nr nh b">price</code>和<code class="fe np nq nr nh b">tax</code>的操作，使它们保持私有，并且只在类<code class="fe np nq nr nh b">CarDetails</code>的范围内。这样我们可以防止私有对象和函数被公开。</p><h2 id="9d76" class="ml ke iq bd kf mm mn dn kj mo mp dp kn lm mq mr kr lq ms mt kv lu mu mv kz mw bi translated">立即调用函数表达式</h2><p id="bb69" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">实现模块模式最常见的方法之一是使用<strong class="ld ir">life</strong>(立即调用函数表达式)。它基本上是一个Javascript函数，一旦被定义就自动执行。</p><p id="9023" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">上述方法也可以写成:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f81e" class="ml ke iq nh b gy nl nm l nn no">var newCar = function CarDetails() {<br/>  var name = 'Chiron';<br/>  var manufacturer = 'Bugatti';<br/>  var price = 190000000;<br/>  var tax = 10;<br/>  var totalPrice = function() {<br/>    return price + (price * tax)/100;<br/>  }<br/>  return {<br/>    name: name,<br/>    manufacturer: manufacturer,<br/>    totalPrice: totalPrice<br/>  }<br/>}()<br/>var carName = newCar.name; // Chiron<br/>var manufacturer = newCar.manufacturer; // Bugatti<br/>var totalPrice = newCar.totalPrice(); // 209000000</span></pre><p id="ee38" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这里，我们不是为<code class="fe np nq nr nh b">CarDetails</code>创建一个对象，而是自己调用一个函数定义，并将返回的对象保存为<code class="fe np nq nr nh b">newCar</code>。即使在这种情况下，与<code class="fe np nq nr nh b">CarDetails</code>相关的属性也可以通过返回的对象来访问。</p><h1 id="fb0f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">模块模式变化</strong></h1><h2 id="d8e7" class="ml ke iq bd kf mm mn dn kj mo mp dp kn lm mq mr kr lq ms mt kv lu mu mv kz mw bi translated">导入混合</h2><p id="c18f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在Javascript中，可以将一个全局对象传递给一个匿名函数，让我们匿名传递全局参数，并以我们选择的名字使用它们。</p><p id="d37c" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">下面是这种模块模式变体的实现示例:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="0b96" class="ml ke iq nh b gy nl nm l nn no">var module = (function (_) {<br/>  function privateMethod() {<br/>    return _.isNumeric(1);<br/>  }<br/>  return{<br/>    publicMethod: function(){<br/>      return privateMethod();<br/>    }<br/>  };<br/>})(jQuery);<br/>module.publicMethod(); // true</span></pre><h2 id="3f3d" class="ml ke iq bd kf mm mn dn kj mo mp dp kn lm mq mr kr lq ms mt kv lu mu mv kz mw bi translated">柔道训练学校</h2><p id="03eb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这种模块模式的变体帮助我们用方法<code class="fe np nq nr nh b">dojo.setObject</code>更好地处理对象。使用<code class="fe np nq nr nh b">setObject()</code>,我们可以设置在路径中创建了一个中间对象的子对象的值，如果它不存在，就作为参数传递。</p><p id="f20e" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">这里有一个描述<code class="fe np nq nr nh b">setObject</code>用法的例子:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f778" class="ml ke iq nh b gy nl nm l nn no">require(['dojo/_base/lang'], function(lang){<br/>  lang.setObject('parent.child.prop', 'some value', obj);<br/>});</span></pre><h2 id="f85f" class="ml ke iq bd kf mm mn dn kj mo mp dp kn lm mq mr kr lq ms mt kv lu mu mv kz mw bi translated">出口</h2><p id="3dbc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">模块模式基本上意味着<strong class="ld ir"> <em class="ns">将代码分割成不同的模块</em> </strong>。在<code class="fe np nq nr nh b">export</code>的帮助下，我们可以定义某个功能并将其导出，如果需要，还可以将其导入其他模块。</p><p id="840b" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">考虑下面的例子，我们导出汽车列表:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="a597" class="ml ke iq nh b gy nl nm l nn no">const cars = ['VW', 'Bugatti', 'Maserati'];<br/>const getCars = () =&gt; cars;<br/>export { getCars };</span></pre><p id="1003" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">每当需要汽车列表时，可以使用<code class="fe np nq nr nh b">import</code>导入导出的模块，如下所示:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="5b43" class="ml ke iq nh b gy nl nm l nn no">import { getCars } from '..'; // from the other file</span><span id="59ef" class="ml ke iq nh b gy nt nm l nn no">console.log(getCars()); // ['VW', 'Bugatti', 'Maserati']</span></pre><h1 id="e2c7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">优势</h1><p id="c3cb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果他们正在寻找以下内容，应该选择这种模式:</p><ol class=""><li id="a04c" class="nu nv iq ld b le mx li my lm nw lq nx lu ny ly nz oa ob oc bi translated">干净的代码</li><li id="d218" class="nu nv iq ld b le od li oe lm of lq og lu oh ly nz oa ob oc bi translated">数据隐私</li><li id="02da" class="nu nv iq ld b le od li oe lm of lq og lu oh ly nz oa ob oc bi translated">显式定义的公共方法和变量。</li><li id="8e7b" class="nu nv iq ld b le od li oe lm of lq og lu oh ly nz oa ob oc bi translated">通过闭包实现函数和变量的本地化。</li><li id="0418" class="nu nv iq ld b le od li oe lm of lq og lu oh ly nz oa ob oc bi translated">它提供了结构</li><li id="e7cb" class="nu nv iq ld b le od li oe lm of lq og lu oh ly nz oa ob oc bi translated">避免污染全球范围</li></ol><h1 id="11f4" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="330e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">模块基本上是一个自我维持的代码块，可以独立工作。我们可以轻松地控制任何对象的公开性，这使得模块模式成为JavaScript中最强大的模式。当我们导入CSS文件或任何其他JavaScript文件时，可以在使用<code class="fe np nq nr nh b">import</code>或<code class="fe np nq nr nh b">require</code>甚至使用<code class="fe np nq nr nh b">&lt;script&gt;</code>标签时找到模块模式的另一种常见用法。对于每个开发人员来说，理解模块模式是如何工作的是绝对重要的，因为这个模式涵盖了OOPS的两个主要原则——抽象和封装。模块模式无疑是帮助维护干净代码的最强有力的模式之一。它还促进了代码的重用和维护适当的结构。如果您的应用程序处理多个函数，最好采用这种模式，因为这将有助于降低复杂性。</p><p id="89fd" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated"><strong class="ld ir"> <em class="ns">参考:</em> <br/>【学习JavaScript设计模式】</strong><em class="ns">Addy Osmani</em>著</p><p id="3fc0" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">感谢您的阅读！</p><p id="b9a9" class="pw-post-body-paragraph lb lc iq ld b le mx lg lh li my lk ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ld ir">！</strong></p></div></div>    
</body>
</html>