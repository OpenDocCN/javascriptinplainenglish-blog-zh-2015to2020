# JavaScript:检查原始和非原始数据类型

> 原文：<https://javascript.plainenglish.io/javascript-reviewing-primitive-and-non-primitive-data-types-5bc4ca68c3de?source=collection_archive---------2----------------------->

## JS 价值观与参考文献简评

![](img/72ea0491a6f3f8b8b62456044fd3820d.png)

在这篇博客中，我将回顾我对两种不同数据类型的理解:**原语**和**非原语**。

它们代表了数据在内存中存储的两种不同方式。

> 如果你对这个话题足够熟悉，你可以跳到博客结尾的结论。

# 什么是数据类型？

如果您对代码有一点点了解，您应该知道有各种不同的数据“类型”。

某些函数可能只适用于特定的数据类型。

例如:

```
// The following is possible:5 * 3 // 15
"ha" + "ppy" // "happy"// The following is not possible:"ben" * 2 // NaN You cannot multiply a string
"hope" - "o" // NaN You cannot subtract a string from another string
```

同时，不同的数据类型以不同的方式存储在计算机的内存中。

# 原始与非原始

在我讨论数据类型的两个类别之前，我将列出哪些数据类型属于哪个类别。

## 原始的

1.  数字
2.  用线串
3.  布尔运算
4.  不明确的
5.  空

## 非原语(统称为对象)

1.  目标
2.  数组
3.  功能

这两个类别代表了这些数据类型存储到内存中的两种不同方式。图元由**值**存储，而非图元(对象)由**引用**存储。

让我们看一个如何存储**原语**的例子:

```
let a = 5
let b = a
console.log(a) // 5
console.log(b) // 5
console.log(a === b) // truea = 10
console.log(a) // 10
console.log(b) // 5
console.log(a === b) // false
```

这里发生了什么？

> 我们设置两个不同的变量: **a** 和**b**。
> 
> **一个** 被设置为等于 5。
> 
> **b** 被设置为等于 ***a*** 。
> 
> 然后我们把 **a** 的值改成等于 10。
> 
> 然而不知何故， **b** 的值还是 5！

这是因为原语是按值存储的。

这意味着，每当我们决定使用原始数据类型声明一个新变量时，我们就在内存中为该值创建了一个新地址。

让我们回头看看我们的例子:

```
let a = 5
let b = a
```

**a** 的数据类型是一个原始数据类型的数字。它的*值*为 5。

**b** 的数据类型也是数字。它的值为 **a** 。

但是，变量 **b** 存储的不是变量 **a** 本身，而是变量的值。

**a** 的值为 5，因此 **b** 将 5 存储到其地址中。

稍后，即使我们决定改变 **a** 的值，这也不会影响已经存储在 **b** 中的值。

这也是为什么现在我们比较两者的时候，两者不再等同。

现在我们来看看**非原语(对象)**:

```
let a = [10]
let b = a
console.log(a === b) // truea.push(10)
console.log(a) // [10, 10]
console.log(a === b) // true
```

> 我们设置两个不同的变量: **a** 和 **b** 。
> 
> **一个**被设置为等于一个保存单个值的数组:10。
> 
> **b** 被设置为等于 **a** 。
> 
> 比较 **a** 和 **b** 返回**真值**。
> 
> 接下来我们修改了 **a** 中的数据。
> 
> 然而，再次比较这两个变量，我们仍然返回 **true** 。

其原因是由于非原语(对象)是通过引用存储的。

这么看吧:

```
let a = [10]
let b = a// the variable a is referencing the address of the array object [10]
// the variable b is referencing the address of the variable a which is pointing to the address of [10]
```

基本上，当处理非原始数据类型时，我们总是存储指向一个地址的指针。

既然是这样，如果我们修改指向相同地址的任何变量，我们将改变存储在地址本身内的值。

```
let a = []
let b = a
let c = ba.push(1)
console.log(a) // [1]
console.log(b) // [1]
console.log(c) // [1]b.push(2)
console.log(a) // [1, 2]
console.log(b) // [1, 2]
console.log(c) // [1, 2]
```

让我们从另一个角度来看这个问题:

```
console.log([10] === [10])
```

你认为上面那行代码的结果是什么？

想想吧…

![](img/cf0aa374812b530ab19af423ed8084e3.png)

在那一行代码中，我们到底在比较什么？

他们指向同一个地址吗？

答案？

**假的！**

为什么会这样呢？

从表面上看，它们都包含相同的值，都是数组，都包含一个具有相同值(10)的元素。

但是，您比较的不是值，而是地址。

左边的**【10】**与左边的**【10】**在内存中的地址不同。

相等运算符(===)检查它们是否指向同一个地址，这就是结果为假的原因。

# 结论

原始数据类型由**值**存储。非原始数据类型由**引用**存储。当声明一个变量时，你通常会创建一个潜在的新地址。

在存储原语的情况下，该变量指向该原语值的新地址。当存储一个原始值(即使它只是一个被设置为值的变量)时，您是在将一个值本身存储到一个新地址中。

在非基本对象的情况下，变量保存对对象的引用。它不是为一个值创建一个新的地址，只是一个指向对象的指针。如果你修改一个指向地址的变量，你实际上是在修改存储在地址中的数据。