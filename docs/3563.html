<html>
<head>
<title>I Built the Same API With Fastify, Express &amp; Bare Node.js. Here are the differences.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用Fastify，Express &amp; Bare Node.js构建了相同的API，区别如下。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fastify-express-benchmark-4c4aebb726d6?source=collection_archive---------0-----------------------#2020-10-09">https://javascript.plainenglish.io/fastify-express-benchmark-4c4aebb726d6?source=collection_archive---------0-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们看看Fastify快了多少</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/92b2096a807ccd283232453d13f1d986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSMq1cB2ozs4eak-o18iAQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="46af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Fastify </strong> —名字就是座右铭。至少这是Node.js框架想要代表的——<strong class="kx ir">速度</strong>。</p><p id="8c84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上一篇文章中我们已经注意到bare Node.js明显不如Express之后，我问自己这个问题，不使用节点自己的HTTP模块，还有什么可以用来开发快速web服务器。</p><p id="0efa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想到了Fastify——所以我又写了三次同样的API用pure Node.js，用Express.js，用Fastify。现在让我向您展示Fastify在竞争中的表现。</p><p id="a439" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从编写API开始。</p><h2 id="f084" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">让我们先安装Fastify</h2><p id="9181" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">像往常一样，我们这样对待NPM: <code class="fe mp mq mr ms b">npm install fastify</code></p><p id="9344" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以编写Fastify服务器了。在这个框架中有两种开发web应用程序的方法。首先，可以构建一个用于输入和输出验证的模式。在Fastify的官方网站上，你可以很好地看到这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/833f189ec24fe05dc354653cbdc9355e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AYiR9Axg69po3O7QgHjsg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae mu" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank">Fastify</a></figcaption></figure><p id="ca84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在这里您可以定义想要接收的内容，例如作为查询参数，并且您还可以使用一个<em class="mv">前置处理程序</em>函数，它的工作方式有点像中间件——它会在每个请求上执行。</p><p id="10c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个选项不太复杂，更像Express.js。我将它用于基准测试，因为在理论上，模式变体甚至更慢，这取决于它的复杂性。</p><p id="30ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，不要被上面显示的代码吓跑，这里是我们的Fastify API:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="077b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有三个api都响应<em class="mv"> api </em>路由上的请求。它们将名和姓作为查询参数，并在响应中返回这两个参数。</p><p id="e985" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我对基准的要求是:<code class="fe mp mq mr ms b">localhost:4000/api?name=john&amp;lastname=doe</code>。</p><h2 id="6d03" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">Express.js API</h2><p id="394d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一点也不复杂。这里是Express.js API，看起来几乎一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7030" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注释:</strong>使用<em class="mv"> app.disable </em>我停用了头中的两个内容，在响应之前，我将<em class="mv"> content-type </em>头设置为<em class="mv">text/plain</em>——在Fastify中这是默认设置。通过这些设置，我们可以在所有三个API中获得几乎相同的头。</p><h2 id="5a25" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">Native / Bare Node.js API</h2><p id="ddd5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">最后但并非最不重要的是裸Node.js服务器，完全没有任何框架。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="986e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">点评:</strong>在bare Node.js中没有res.send，我加了if-语句是为了公平起见——毕竟另外两个API在请求时检查路由。如果没有if语句，这个节点服务器将回答每个请求。对于<em class="mv">内容类型</em>，我必须手动指定<em class="mv"> utf-8 </em>。使用Express和Fastfiy，这将自动出现在标题中。所以所有的标题都有相同的大小。</p><h1 id="df9b" class="my ls iq bd lt mz na nb lw nc nd ne lz jw nf jx mc jz ng ka mf kc nh kd mi ni bi translated">基准</h1><p id="4866" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">对于基准测试，我使用的是MacBook Pro 13英寸2018，采用4核英特尔i5处理器。我确保所有的测试都是在相同的条件下进行。每台服务器都被单独测试，除了负载测试工具之外的所有其他请求源都被关闭。</p><p id="5152" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Node.js版本是14.2.0。我只是用node命令执行了API，没有使用PM2或nodemon。</p><h2 id="f32a" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">负载测试器</h2><p id="6430" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">上一篇文章，我用的是<strong class="kx ir"> <em class="mv">阿帕奇板凳</em> </strong>。但是因为HTTP版本，Fastify有问题，而且AB也很旧了。因此我决定用<strong class="kx ir"> <em class="mv"> wrk </em> </strong>。<br/>在macOS上，可以用<code class="fe mp mq mr ms b">brew install wrk</code>安装。在Linux上，可以用<code class="fe mp mq mr ms b">sudo apt-get install wrk</code>安装。</p><p id="994a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我为每个API使用的命令:<br/> <code class="fe mp mq mr ms b">wrk -t12 -c400 -d10s http://localhost:4000/api?name=john&amp;lastname=doe</code></p><p id="98fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">12是我们使用的线程数，400是并发连接数。整个过程持续了10秒钟。</p><h1 id="61df" class="my ls iq bd lt mz na nb lw nc nd ne lz jw nf jx mc jz ng ka mf kc nh kd mi ni bi translated">结果呢</h1><p id="d388" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当然，我已经用负载测试器轰击了每个API几次——这里是最平均的结果。</p><p id="429d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Express.js </strong></p><pre class="kg kh ki kj gt nj ms nk nl aw nm bi"><span id="a9ec" class="lr ls iq ms b gy nn no l np nq">Thread Stats Avg Stdev Max +/- Stdev<br/> Latency 17.03ms 4.10ms 109.13ms 90.16%<br/> Req/Sec 1.86k 353.95 2.89k 88.92%<br/> 222514 requests in 10.02s, 32.47MB read<br/> Socket errors: connect 0, read 248, write 0, timeout 0<br/>Requests/sec: 22207.75<br/>Transfer/sec: 3.24MB</span></pre><p id="373f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">裸露/原生</strong></p><pre class="kg kh ki kj gt nj ms nk nl aw nm bi"><span id="88e2" class="lr ls iq ms b gy nn no l np nq">Thread Stats Avg Stdev Max +/- Stdev<br/> Latency 11.03ms 3.09ms 77.64ms 85.72%<br/> Req/Sec 2.77k 542.65 4.38k 86.17%<br/> 331028 requests in 10.01s, 48.62MB read<br/> Socket errors: connect 0, read 257, write 0, timeout 0<br/>Requests/sec: 33067.32<br/>Transfer/sec: 4.86MB</span></pre><p id="6f07" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">加速</strong></p><pre class="kg kh ki kj gt nj ms nk nl aw nm bi"><span id="e842" class="lr ls iq ms b gy nn no l np nq">Thread Stats Avg Stdev Max +/- Stdev<br/> Latency 9.75ms 3.17ms 79.39ms 87.88%<br/> Req/Sec 3.13k 729.47 11.94k 87.78%<br/> 375177 requests in 10.10s, 54.74MB read<br/> Socket errors: connect 0, read 263, write 0, timeout 0<br/>Requests/sec: 37147.37<br/>Transfer/sec: 5.42MB</span></pre><p id="65d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果很明显——Fastify比Express.js快，甚至比Bare Node.js还快，尤其是后者已经让我大吃一惊。但我也在其他基准测试中读到过，尤其是在Fastify的官方网站上。它似乎是Node.js世界中最快的web框架。</p><h1 id="2980" class="my ls iq bd lt mz na nb lw nc nd ne lz jw nf jx mc jz ng ka mf kc nh kd mi ni bi translated">总结</h1><p id="132b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">性能方面，Fastify更胜一筹。</p><p id="903b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">公平地说，显示这种性能差异的基准通常是非常不现实的情况——实际上，几乎没有任何web服务器会同时受到这么多请求的轰炸。</p><p id="e715" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尤其是因为系统的硬件也起着决定性的作用。尽管Fastify的性能优越，但我将主要使用Express。对我和许多其他人来说，Express提供的已经足够了。</p><p id="c1e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整个生态系统配置更好，表达的资源也更多。这使得它特别适合初学者。</p><p id="1a0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，对于许多目的来说，框架之间的差异并不大——特别是对于单个API，或者服务于静态资产，迁移到另一个框架是很容易的。</p><p id="7675" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mu" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kx ir">！</strong></p><p id="271b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">更多关于Express.js: </strong></p><div class="nr ns gp gr nt nu"><a href="https://medium.com/javascript-in-plain-english/3-express-js-features-you-need-to-know-8f78b0035f33" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">你需要知道的3个Express.js特性</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">几乎所有主要的Node.js应用都依赖于Express.js框架，这里有一些你应该知道的重要特性。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><p id="990a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae mu" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">和我保持联系</strong> </a></p></div></div>    
</body>
</html>