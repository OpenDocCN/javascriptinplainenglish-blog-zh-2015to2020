<html>
<head>
<title>The essential JavaScript concepts that you should understand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该理解的基本JavaScript概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-essential-javascript-concepts-that-you-should-understand-ff2b8546c868?source=collection_archive---------8-----------------------#2020-05-05">https://javascript.plainenglish.io/the-essential-javascript-concepts-that-you-should-understand-ff2b8546c868?source=collection_archive---------8-----------------------#2020-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4cfd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为了成功发展和通过工作面试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da79f80252047191bbeeb22527f6414e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugrnOlXo2Q6Wfqrkjycx2Q.jpeg"/></div></div></figure><p id="af6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为任何级别的JavaScript开发人员，您都需要理解它的基本概念和一些帮助我们开发代码的新想法。在本文中，我们将回顾16个基本概念。所以事不宜迟，让我们开始吧。</p><h2 id="f1fd" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">索引</h2><p id="b995" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">核心概念</p><ul class=""><li id="1d38" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">动态的</li><li id="deda" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">参考值与值</li><li id="46bb" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">相等运算符(==)与相同运算符(===)</li><li id="0ec0" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">范围</li><li id="fbc3" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">提升</li><li id="23b4" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">关闭</li><li id="d44d" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">IIEF</li><li id="bfff" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">复试</li><li id="b4e8" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">高阶函数</li></ul><p id="635a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ES6+</p><ul class=""><li id="3802" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">扩展语法</li><li id="f6b4" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">解构</li><li id="3e27" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">Rest语法</li><li id="9184" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">班级</li><li id="6349" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">承诺</li><li id="1607" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">异步等待</li><li id="a154" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">箭头功能</li></ul></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="3824" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">核心概念</h2><h2 id="e6d8" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">动态的</h2><p id="74aa" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们认为JavaScript是一种动态语言，因为它有动态的方面。在JavaScript中，几乎所有东西都是动态的，例如，所有变量都是动态的，甚至代码也是动态的。动态类型化意味着变量的类型是在运行时确定的，不需要在使用变量之前显式声明变量。在JavaSCript中，你也可以在运行时用eval()函数创建新的变量。但是，eval()是一个危险的函数，完全不鼓励使用。</p><h2 id="36fa" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">参考与价值</h2><p id="ad9b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在JS中，我们有对象(函数、数组)和原始数据类型(字符串、数字、布尔、空和未定义)。基本数据类型总是通过值传递，对象通过引用传递。</p><p id="c5d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原始值是不可变的，这意味着一旦创建，它们就不能被修改，我们创建了原始对象的副本。相反，通过引用，我们创建了一个到原文的链接。</p><p id="48c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">阅读更多关于不变性的重要性:<a class="ae ng" href="https://medium.com/javascript-in-plain-english/understanding-immutability-in-javascript-b10b0345086e" rel="noopener">理解JavaScript中的不变性</a>。</p><p id="83e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按值:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="9f4d" class="ln lo iq ni b gy nm nn l no np">const value= 'Hello world!';<br/>value[0] = 'P';</span><span id="8d08" class="ln lo iq ni b gy nq nn l no np">console.log(value); <br/>//Hello world, not Pello world!</span></pre><p id="2cec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过引用:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="ac5a" class="ln lo iq ni b gy nm nn l no np">const car1 = {<br/>  brand: 'Ford',<br/>  model: 'Mustang W-Code'<br/>}</span><span id="e509" class="ln lo iq ni b gy nq nn l no np"><strong class="ni ir">const car2 = car1;</strong></span><span id="71d6" class="ln lo iq ni b gy nq nn l no np">car2.model= '<strong class="ni ir">Thunderbird</strong>';</span><span id="77e2" class="ln lo iq ni b gy nq nn l no np">console.log(car1 === car2); <br/>//true</span><span id="c2c9" class="ln lo iq ni b gy nq nn l no np">console.log(car1);<br/>//{brand: 'Ford', model: '<strong class="ni ir">Thunderbird</strong>'}</span></pre><h2 id="eb41" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">相等运算符(==)与相同运算符(===)</h2><p id="b62a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">“==”和“===”运算符之间的主要区别在于，“==”通过类型强制来比较变量，而===使用严格相等来比较变量，并且我们比较的类型和值必须相同。</p><p id="0e5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例子</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="61cb" class="ln lo iq ni b gy nm nn l no np">10 === 10<br/>//true</span><span id="55bf" class="ln lo iq ni b gy nq nn l no np">10 == "10"<br/>//true (Although 10 is a number and the "10" a string)</span></pre><h2 id="a05a" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">范围</h2><p id="03ac" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这个概念是许多新开发人员最难理解的概念之一。几乎所有编程语言最基本的范例之一是在变量中存储值的能力。</p><p id="b77d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这些变量存在于哪里呢？它们存放在哪里？我们的程序如何得到它们？最后，什么是范围？</p><p id="e3d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“范围”是我们代码中标识符有效的区域。</p><p id="49f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中，我们有四种类型的作用域:</p><ul class=""><li id="aa65" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">全局范围范围:对所有对象可见(变量)</li><li id="4b99" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">函数作用域:在函数中可见(var)</li><li id="533b" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">块范围(ES6+):在块内可见(let，const)</li><li id="cc0d" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">模块(ES6+):在模块内可见</li></ul><h2 id="d978" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">提升</h2><p id="4281" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">提升是一种机制，其中变量和函数声明在代码执行之前被移动到它们的“作用域”的顶部，因此，变量可能在它们的声明之前实际上是可用的。</p><p id="de87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="3eb8" class="ln lo iq ni b gy nm nn l no np">a = 10; <br/>//Assign 10 to "a"</span><span id="497f" class="ln lo iq ni b gy nq nn l no np">console.log(a);<br/>//10</span><span id="5d9d" class="ln lo iq ni b gy nq nn l no np">var a;<br/>//Declare the "a" variable</span></pre><h2 id="a256" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">关闭</h2><p id="1163" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">闭包是一个函数的混合体，它被捆绑在一起(封闭在一起),并引用其周围的状态，这使您可以从内部函数访问外部函数的作用域。</p><p id="b0d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="5a55" class="ln lo iq ni b gy nm nn l no np">function foo() {<br/>  let myVar = 'Hello!!'; <br/>  //myVar is a local variable created by foo<br/>  function alertMyVar() { <br/>    //alertMyVar() is the closure<br/>    alert(name); <br/>    //Alert use the variable declared in the parent function<br/>  }<br/>  alertMyVar();<br/>}<br/>foo();</span></pre><p id="85e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">foo()函数创建一个名为myVar的局部变量和一个名为alertMyVar()的函数。alertMyVar()函数是一个<strong class="kt ir">内部函数</strong>，它定义在foo()函数内部，并且只在foo()函数体中可用。alertMyVar() <strong class="kt ir">可以访问外部函数</strong>的变量，所以alertMyVar()可以访问父函数中声明的变量MyVar。</p><h2 id="96c4" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">生活</h2><p id="b371" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">立即调用的函数表达式(IIFE)是一个在函数创建后立即运行函数的过程。IIFEs非常有用，因为它们防止污染全局环境，允许公共访问方法，同时维护函数内部定义的变量的隐私。</p><p id="342c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="94d3" class="ln lo iq ni b gy nm nn l no np">(function() {<br/>   let name= "Hello world!";<br/>   alert(name);<br/>  }<br/>)();</span><span id="28dc" class="ln lo iq ni b gy nq nn l no np">//Hello world!</span></pre><p id="d6f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总之，我们使用生命主要是因为隐私。在IIFE函数中声明的任何变量都不能从外界获得。</p><h2 id="7ac7" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">复试</h2><p id="ae96" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在JavaScript中，回调是作为参数传递给其他函数的函数，然后在外部函数中调用。回调也是闭包，传递给它的函数是在另一个函数内部执行的函数，就好像回调是在包含函数中定义的一样。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="52ef" class="ln lo iq ni b gy nm nn l no np">function runAsyncFunction(param1, callback) {<br/>  //Do some stuff, <br/>  //for example download<br/>  //data for a externan URL.<br/>  //After a while...<br/>  result = 100;<br/>  callback(result);<br/>}</span><span id="a160" class="ln lo iq ni b gy nq nn l no np">runAsyncFunction(10, (r) =&gt; {...}));</span><span id="c775" class="ln lo iq ni b gy nq nn l no np">//..<br/>//Execute other tasks<br/>//while the runAsyncFunction<br/>//is running asynchronously.</span></pre><p id="79e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回调的问题是代码有很多回调，很难直观地得到正确的结果，代码最终看起来如下例所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/139fff1ed1351a2117418518d70e0b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_rQDSJTe1gn5_p1lUzlgA.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk">Callbacks-Hell</figcaption></figure><h2 id="adcb" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">高阶函数</h2><p id="8d51" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">高阶函数是接收其他函数作为参数或返回函数作为结果的函数。它们在JavaScript中被广泛使用，如。filter()，。map()，。减少()或。forEach()函数。</p><p id="9f9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑下面的例子:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="662e" class="ln lo iq ni b gy nm nn l no np">const myArray = [1,2,3,4];<br/>const myMultiplyFuncion = (n) =&gt; n*2;</span><span id="79da" class="ln lo iq ni b gy nq nn l no np">newArray = myArray.map(myMultiplyFuncion);<br/>console.log(newArray);<br/>//[2, 4, 6, 8]</span></pre><p id="561a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">这里的高阶函数是。map( </strong> ) <strong class="kt ir">函数</strong>接受myMultiplyFuncion并返回一个新数组，其中的值乘以2。</p><p id="0868" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，JavaScript允许函数返回其他函数作为结果。记住函数只是简单的对象，它们可以像任何附加值一样被返回。</p><p id="6e8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这个例子有点傻，因为您可以直接使用str.toUpperCase()，但它展示了一个函数如何返回另一个函数:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="6ccb" class="ln lo iq ni b gy nm nn l no np">const myToUpperCasse = function(str) {<br/>  return str.toUpperCase();<br/>};</span><span id="61d7" class="ln lo iq ni b gy nq nn l no np">console.log(myToUpperCasse("hello world!"));<br/>//HELLO WORLD!</span></pre><h2 id="99f3" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">ES6+</h2><h2 id="33cc" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">扩展语法</h2><p id="45a3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们使用扩展操作符“…”将单个元素从数组中取出。</p><p id="b9db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">语法:some function(…iterable obj)；</p><p id="545d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑下一个例子:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="6b20" class="ln lo iq ni b gy nm nn l no np">const myArray = [1,2,3,4,5,6,7,8];<br/>const min = Math.min(...myArray);<br/>console.log(min);<br/>//1</span></pre><p id="dbd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不能用myArray直接应用Math.min，因为它不接受数组作为参数；它将单个元素作为参数。使用spread语法，我们可以这样做。</p><p id="9a07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一个示例中，我们使用数组元素作为函数的参数:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="27f2" class="ln lo iq ni b gy nm nn l no np">function sum(a, b, c) {<br/>  return a + b + c;<br/>}</span><span id="08c0" class="ln lo iq ni b gy nq nn l no np">const numbers = [1, 2, 3];</span><span id="edc4" class="ln lo iq ni b gy nq nn l no np">console.log(sum(...numbers));<br/>//6</span></pre><p id="2323" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">串联数组:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="ca38" class="ln lo iq ni b gy nm nn l no np">let myArray1 = [1, 2, 3];<br/>let myArray2 = [4, 5, 6];</span><span id="c5c6" class="ln lo iq ni b gy nq nn l no np">concatenatedArray = [...arr1, ...arr2];<br/>console.log(concatenatedArray);<br/>//[1,2,3,4,5,6]</span></pre><p id="5bf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组合对象:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="b7d8" class="ln lo iq ni b gy nm nn l no np">const myObj1= { name: "Rick" };<br/>const myObj2= { age:40, year: 1980 };</span><span id="6e61" class="ln lo iq ni b gy nq nn l no np">const mergedObj = { ...myObj1, ...myObj2 };</span><span id="f50e" class="ln lo iq ni b gy nq nn l no np">console.log(mergedObj);<br/>//{name: "Rick", age: 40, year: 1980}</span></pre><h2 id="59c0" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">解构</h2><p id="5241" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">析构是一个JavaScript表达式，它可以将对象或数组中的值属性提取到不同的变量中:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="4f2d" class="ln lo iq ni b gy nm nn l no np">let var1, var2;<br/>[var1, var2] = [1, 2];</span><span id="5b55" class="ln lo iq ni b gy nq nn l no np">console.log(var1);<br/>//1</span><span id="6e18" class="ln lo iq ni b gy nq nn l no np">console.log(var2);<br/>//2</span><span id="fdc8" class="ln lo iq ni b gy nq nn l no np">...</span><span id="7d71" class="ln lo iq ni b gy nq nn l no np">const myConst= ['1', '2', '3'];<br/>const [n1, n2, n3] = myConst;</span><span id="df1d" class="ln lo iq ni b gy nq nn l no np">console.log(n1); <br/>//"1"<br/>console.log(n2);<br/>//"2"<br/>console.log(n3);<br/>//"3"</span></pre><p id="c07d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也可以很容易地交换变量:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="e2bf" class="ln lo iq ni b gy nm nn l no np">let var1 = 1;<br/>let var2 = 2;</span><span id="99ef" class="ln lo iq ni b gy nq nn l no np">[var1, var2] = [var2, var1];<br/>console.log(var1); <br/>//3<br/>console.log(var2); <br/>//1</span></pre><h2 id="4f16" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">Rest语法</h2><p id="bebb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">rest语法允许我们将几个参数表示为一个数组。</p><p id="7ae6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">语法:function f(a，b，…theArgs){<br/>//做一些事情。<br/> }</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="22bc" class="ln lo iq ni b gy nm nn l no np">function sum(...theArgs) {<br/>  return theArgs[0] + theArgs[5];<br/>}</span><span id="b49d" class="ln lo iq ni b gy nq nn l no np">sum(<strong class="ni ir">1</strong>, 2, 3, 4, 5, <strong class="ni ir">6</strong>);<br/>//7</span></pre><p id="2b04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只有最后一个参数可以是“rest参数”:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="853b" class="ln lo iq ni b gy nm nn l no np">function sum(a, b, ...theArgs) {<br/>  console.log(a);//1 <br/>  console.log(b);//2</span><span id="cfa1" class="ln lo iq ni b gy nq nn l no np">return theArgs[0] + theArgs[3];<br/>}</span><span id="da6b" class="ln lo iq ni b gy nq nn l no np">sum(1<strong class="ni ir">, </strong>2, 3, 4, 5, 6);</span><span id="87d7" class="ln lo iq ni b gy nq nn l no np">//a:1,b:2<br/>//9 -&gt; (theArgs[0]:3 + theArgs[3]:6)</span></pre><h2 id="3541" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">班级</h2><p id="f9a1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Javascript类是现有的基于原型的继承和构造函数之上的<strong class="kt ir">语法糖</strong>。</p><p id="8aa0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用构造器模式:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="796f" class="ln lo iq ni b gy nm nn l no np">function ConstructorCar (brand, model) {<br/>    this.brand = brand;<br/>    this.model = model;<br/>}</span><span id="b4ef" class="ln lo iq ni b gy nq nn l no np">ConstructorCar.prototype.isFord = function (brand) {   <br/>   return this.brand === "Ford";<br/>};</span><span id="31ed" class="ln lo iq ni b gy nq nn l no np">myCar = new ConstructorCar("Ford", "Sierra");<br/>console.log(myCar.isFord("Ford"));<br/>//true</span></pre><p id="c17a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用isBMW()方法扩展我们的构造函数:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="a76e" class="ln lo iq ni b gy nm nn l no np">ConstructorCar.<strong class="ni ir">prototype</strong>.isBMW = function (brand) {   <br/>   return this.brand === "BMW";<br/>};</span><span id="baf2" class="ln lo iq ni b gy nq nn l no np">myCarBWM = new ConstructorCar("BMW", "505");<br/>console.log(myCarBWM.isBMW("BMW"));<br/>//true</span></pre><p id="8502" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用类别语法的对等用法:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="8d7c" class="ln lo iq ni b gy nm nn l no np">class Car {<br/>  constructor(brand, model) {<br/>    this.brand = brand;<br/>    this.model = model;<br/>  }</span><span id="1189" class="ln lo iq ni b gy nq nn l no np">isFord(brand){<br/>    return this.brand === "Ford";<br/>  }</span><span id="996b" class="ln lo iq ni b gy nq nn l no np">}</span><span id="271b" class="ln lo iq ni b gy nq nn l no np">myCar = new Car("Ford", "Sierra");<br/>console.log(myCar.isFord("Ford"));<br/>//true</span></pre><p id="3837" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用isBmw()方法扩展该类:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="35d4" class="ln lo iq ni b gy nm nn l no np">class CarBMW <strong class="ni ir">extends </strong>Car{<br/>  constructor(brand, model) {<br/>     super(brand,model);<br/>  }<br/>  isBMW(brand){<br/>    return this.brand === brand;<br/> }<br/>}</span><span id="539d" class="ln lo iq ni b gy nq nn l no np">myCar1 = new CarBMW("Ford", "Sierra");<br/>console.log(myCar1.isFord("Ford"));<br/>//true</span><span id="b10f" class="ln lo iq ni b gy nq nn l no np">myCar2 = new CarBMW("BMW", "505");<br/>console.log(myCar2.isBMW("BMW"));<br/>//true</span></pre><h2 id="740e" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">承诺</h2><p id="5878" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">承诺是一个值的代理，代表解决或拒绝的未来操作的结果。它允许您将处理程序与异步操作相关联，并且是避免使用回调的替代方法。</p><p id="d3c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Promises立即返回一个promise对象，您使用“Then”方法传递异步函数完成时要采取的操作。</p><p id="14b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用他们的<then>方法，承诺可以被连锁。每个链接的函数返回一个新的承诺，表示链中另一个异步步骤的完成。</then></p><p id="f9e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">承诺总是处于这些状态之一:</p><ul class=""><li id="6c2c" class="ml mm iq kt b ku kv kx ky la mn le mo li mp lm mq mr ms mt bi translated">“待定”:初始状态。</li><li id="8a0b" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">“已完成”:表示操作成功完成。</li><li id="2ecf" class="ml mm iq kt b ku mu kx mv la mw le mx li my lm mq mr ms mt bi translated">“拒绝”:表示操作失败。</li></ul><p id="42b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与我们使用承诺回调的例子一样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/88b42d72a638d9df3523dff401d28c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IARLH2EWSB9dds5Yqf46cw.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk">Promises example image</figcaption></figure><h2 id="33eb" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">异步等待</h2><p id="d561" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Async/Await是ES2017中的新功能，它可以帮助我们为异步任务编写完全同步的代码。</p><p id="b19e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与promises相比，它的主要优点是带有“异步函数”的代码的语法和结构与使用标准同步函数相似，并且与我们顺序思考的方式相当。</p><p id="0c30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">异步函数可以包含<awaits>表达式，用于暂停异步函数的执行，并等待传递的承诺的解析。当承诺被解析后，将恢复异步函数的执行并返回结果值。</awaits></p><p id="30f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相同的promises示例，但是使用了Async/await:</p><p id="f980" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:您需要将包含它的函数定义为async。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/bdac91f1a7eed34c8f14ee48a9c7aa37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mARomkjgeOIjJZTgu8USA.png"/></div></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk">Async/await example image.</figcaption></figure><p id="eef7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Promises和Async/Await实现了同样的事情，但是Async/Await使得处理异步代码更加自然。两者都消除了回调的需要和著名的回调地狱。</p><p id="c7d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以阅读我的关于JavaScript异步代码的完整文章，见:“<a class="ae ng" href="https://medium.com/javascript-in-plain-english/javascript-a-fast-trip-for-dummies-from-callbacks-to-es6-async-await-a61b0a4b0bed" rel="noopener">JavaScript中从回调到异步等待的旅程。</a>”</p><h2 id="a36a" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">箭头功能</h2><p id="e726" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">箭头函数在语法上是常规函数的紧凑替代物；与常规函数不同，箭头函数不绑定“this”对象。相反,“this”对象是词汇绑定的，保持其原始上下文。<br/>注意，箭头函数表达式不适合作为方法，它们不能用作构造函数或递归函数，但在map()、reduce()或filter()等函数中非常有用</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="7e16" class="ln lo iq ni b gy nm nn l no np">const sum = function(a, b){<br/>   return a + b;<br/>}</span><span id="dd4c" class="ln lo iq ni b gy nq nn l no np">Equivalent arrow function:</span><span id="7702" class="ln lo iq ni b gy nq nn l no np">const sum = (a,b) =&gt; a+b;</span></pre><p id="9baf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">具有过滤功能:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="0ec6" class="ln lo iq ni b gy nm nn l no np">let array = [1,2,3,4,5]<br/>let newArray = array.filter( e =&gt; e &gt; 2);<br/>//[3,5,5]</span></pre><h2 id="eab4" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">结论</h2><p id="a657" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在本文中，我们已经看到了我认为的JavaScript的一些基本部分。我们仍然需要讨论“这个”对象或者原型和继承，但是考虑到它的复杂性，我将把它留到另一篇文章中，在那里我将详细解释它们。</p><p id="9dc5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这篇文章。非常感谢你阅读我！</p><h2 id="c141" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">简明英语笔记</h2><p id="f12a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae ng" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kt ir">JavaScript in Plain English</strong></a><a class="ae ng" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kt ir">AI in Plain English</strong></a><a class="ae ng" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kt ir">UX in Plain English</strong></a><a class="ae ng" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kt ir">Python in Plain English</strong></a><strong class="kt ir"/>—谢谢，继续学习！</p><p id="1eac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ng" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">submissions @ plain English . io</strong></a><strong class="kt ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>