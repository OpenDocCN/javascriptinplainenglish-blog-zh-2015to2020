<html>
<head>
<title>The Little React Quirk I Wish I’d Known Sooner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望我能早点知道这个小小的反应怪癖</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-wish-you-knew-this-little-reactjs-quirk-f021d8375dbe?source=collection_archive---------3-----------------------#2020-10-16">https://javascript.plainenglish.io/you-wish-you-knew-this-little-reactjs-quirk-f021d8375dbe?source=collection_archive---------3-----------------------#2020-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6b88" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我是吃了苦头才知道的，所以你们不必…</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/7d6ffd40d3895fec54a0787a407f4dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vilnpOMIEoCj8UX2"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7cd8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大约6年前，我开始使用React，从那时起，我就开始宣传React在开发人员体验方面的优越性。然而，需要考虑的一件重要事情是，React绝不是一个放之四海而皆准的解决方案，如果你试图用React构建一个简单的静态网站，你可能会意识到你已经把自己复杂化成了不必要的复杂概念。但是如果你已经决定React适合你的下一个项目，你也可以充分利用React的力量。</p><p id="089f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正是出于这个目的，建议更深入地理解React性能优势背后的核心原则之一——虚拟DOM。了解内部可能不是构建React应用程序的必要条件，但是通过理解底层概念，您应该能够编写更好、更健壮的React应用程序。</p><p id="b9a8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">ReactJS使用一种启发式算法，该算法使用一种差分机制来计算DOM结构中的变化，这种差分机制使用DOM的内存版本来计算变化。通过利用这一点，React可以只更新页面中已经更改的部分，而不是重新呈现整个页面。反应过来的作者称之为<a class="ae ks" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"><strong class="kv io"><em class="lp"/></strong></a>。</p><p id="0339" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意到启发式这个词了吗？这改变了大多数人对虚拟DOM的看法，呈现性能&amp;最糟糕的是——视图中的数据不正确(是的，这可能发生！).React在区分变化时使用某些假设，如果你不小心，算法可能会出现失败。</p><p id="4657" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在遍历列表时使用索引作为键是一种很常见的做法。但是在大多数情况下，使用数组索引作为键可以被认为是一种反模式。原因如下—</p><blockquote class="lq"><p id="22ef" class="lr ls in bd lt lu lv lw lx ly lz lo dk translated">常见的实践并不总是理想的实践</p></blockquote><pre class="ma mb mc md me mf mg mh mi aw mj bi"><span id="cbb8" class="mk ml in mg b gy mm mn l mo mp">Each child in an array should have a unique "key" prop.</span></pre><p id="d9de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了消除这个警告，通常将数组的索引传递给数组迭代返回的元素。您知道这可能会导致不正确的应用程序状态吗？尽管看起来很安全，但在某些常见的用例中，这种做法可能非常糟糕。例如，让我们考虑使用React呈现的输入列表:</p><pre class="kd ke kf kg gt mf mg mh mi aw mj bi"><span id="096d" class="mk ml in mg b gy mm mn l mo mp">{<br/>  list.map((item, i) =&gt; (<br/>    &lt;div&gt;<br/>      &lt;label&gt;item.name&lt;/label&gt;<br/>      &lt;input key={i} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b334" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这段代码显示了一个输入列表。只要列表没有被<em class="lp">改变</em>(没有重新排序、拼接或过滤)，它就能正常工作。猜猜当你在列表中添加一个项目时会发生什么？您将看到一个新的文本输入被呈现，但是输入中的值没有被重新呈现！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/978975b7443bb08cda74552fc2b47eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iOfRKzEFhHx2A0c568kvRg.gif"/></div></div></figure><p id="1a9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不久前，当我试图呈现一个不受控制的输入列表时，我遇到了这种奇怪的行为。当时，我甚至不知道使用索引作为键不是一种推荐的方法，所以我想我应该使用受控输入。这在技术上是可行的，但是有一个性能上的权衡。</p><p id="8476" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过使用正在渲染的项目的<code class="fe mr ms mt mg b">id</code>或列表中唯一的任何其他标识符，这个问题很容易解决。当使用的钥匙是<code class="fe mr ms mt mg b">id</code>而不是<code class="fe mr ms mt mg b">index</code>时，是这样的</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/730e277a787860a7c271013f981a90d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rp9uOzdWdOP_0wUB34u8_g.gif"/></div></div></figure><p id="51f9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">查看React的高级指南文档页面中的这2个Codepen示例，您可以自己进行尝试:</p><p id="28d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://react js . org/redirect-to-code pen/对账/index-use-as-key</em></a></p><p id="717d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://react js . org/重定向至code pen/对账/无索引用作密钥</em> </a></p></div></div>    
</body>
</html>