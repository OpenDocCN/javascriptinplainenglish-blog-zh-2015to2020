<html>
<head>
<title>Airbnb Coding Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb编码面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/airbnb-coding-interview-questions-4818501a7c80?source=collection_archive---------3-----------------------#2020-04-01">https://javascript.plainenglish.io/airbnb-coding-interview-questions-4818501a7c80?source=collection_archive---------3-----------------------#2020-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="476d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过每天解决一个问题，变得非常擅长编写面试代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4231897496e2e98fa7a0ffb2434eb119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDkndWzMug7s-yrAvm6E6A.jpeg"/></div></div></figure><p id="564c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">(2020年4月6日更新)</em></p><h1 id="c73c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">日常编码问题</h1><p id="a3cb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">它们是受真实编程面试启发的各种各样的问题，带有深入的解决方案，清晰地带您了解每个核心概念。</p><blockquote class="ml"><p id="a290" class="mm mn iq bd mo mp mq mr ms mt mu lm dk translated">通过每天解决一个问题，变得格外擅长编写面试代码。</p></blockquote><p id="3601" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我们将一起使用JavaScript解决这些问题。</p><h1 id="89fb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#1</h1><h2 id="e2d9" class="na lp iq bd lq nb nc dn lu nd ne dp ly la nf ng ma le nh ni mc li nj nk me nl bi translated">问题</h2><p id="af6f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">给定一个整数列表，写一个函数，返回非相邻数的最大和。数字可以是0或负数。例如，<code class="fe nm nn no np b">[2, 4, 6, 2, 5]</code>应该返回<code class="fe nm nn no np b">13</code>，因为我们选择了2，6，而<code class="fe nm nn no np b">[5, 1, 1, 5]</code>应该返回<code class="fe nm nn no np b">10</code>，因为我们选择了5和5。</p><p id="be1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能在O(N)时间和常数空间做到这一点吗？</p><h2 id="43b2" class="na lp iq bd lq nb nc dn lu nd ne dp ly la nf ng ma le nh ni mc li nj nk me nl bi translated">解决办法</h2><p id="3419" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">以下是我的解决方案。这对任何人来说都很容易理解。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="2637" class="na lp iq np b gy nu nv l nw nx">const i1 = [2, 4, 6, 2, 5];<br/>const i2 = [5, 1, 1, 5];<br/><br/>const nonAdjSum = (input) =&gt; {<br/>  let incl = 0;<br/>  let excl = 0;<br/>  let new_excl;<br/>  input.forEach( (el) =&gt; {<br/>    new_excl = excl &gt; incl ? excl : incl;<br/>    incl = excl + el;<br/>    excl = new_excl;<br/>  })<br/><br/>  return excl &gt; incl ? excl : incl;<br/><br/>}<br/><br/>nonAdjSum(i1)<br/>&lt;&lt; <strong class="np ir">13</strong></span><span id="d008" class="na lp iq np b gy ny nv l nw nx">nonAdjSum(i2)<br/>&lt;&lt; <strong class="np ir">10</strong></span></pre><h1 id="cd4b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#2</h1><h2 id="3e04" class="na lp iq bd lq nb nc dn lu nd ne dp ly la nf ng ma le nh ni mc li nj nk me nl bi translated">问题</h2><p id="550a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">柯拉茨猜想的这些规则。</p><ul class=""><li id="a2b8" class="nz oa iq kt b ku kv kx ky la ob le oc li od lm oe of og oh bi translated">如果一个数是奇数，下一个变换是3*n+1</li><li id="1db2" class="nz oa iq kt b ku oi kx oj la ok le ol li om lm oe of og oh bi translated">如果一个数是偶数，下一个变换是n/2</li><li id="9040" class="nz oa iq kt b ku oi kx oj la ok le ol li om lm oe of og oh bi translated">这个数字最终被转换成1。</li><li id="f3c6" class="nz oa iq kt b ku oi kx oj la ok le ol li om lm oe of og oh bi translated">步骤是一个数变成1需要多少次变换。</li></ul><p id="cf74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">给定一个整数n，输出将[1，n]中的数变换为1的最大步骤。</p><h2 id="864b" class="na lp iq bd lq nb nc dn lu nd ne dp ly la nf ng ma le nh ni mc li nj nk me nl bi translated">解决办法</h2><p id="bdb5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">首先，我们编写<code class="fe nm nn no np b">findSteps(num)</code>函数。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="1f1f" class="na lp iq np b gy nu nv l nw nx">const findSteps = function (num) {<br/>    if (num &lt;= 1) return 1<br/>    if (num % 2 == 0)<br/>        return 1 + findSteps(num / 2)<br/>    return 1 + findSteps(3 * num + 1)<br/>}</span></pre><p id="20d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们通过实现<code class="fe nm nn no np b">findLongestSteps(num)</code>函数找到要转换的最大步骤。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="ec73" class="na lp iq np b gy nu nv l nw nx">const findLongestSteps = function (num) {<br/><br/>    if (num &lt; 1) return 0<br/><br/>    var res = 0<br/>    for (let i = 1; i &lt;= num; i++) {<br/>        t = findSteps(i)<br/>        res = Math.max(res, t)<br/>    }<br/><br/>    return res<br/>}</span></pre><p id="1a8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们尝试测试这个解决方案。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="7b0a" class="na lp iq np b gy nu nv l nw nx">console.log(findLongestSteps(37))<br/>&lt;&lt; <strong class="np ir">112</strong></span><span id="9a61" class="na lp iq np b gy ny nv l nw nx">console.log(findLongestSteps(101))<br/>&lt;&lt; <strong class="np ir">119</strong></span></pre><h1 id="9951" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">问题#3</h1><h2 id="1830" class="na lp iq bd lq nb nc dn lu nd ne dp ly la nf ng ma le nh ni mc li nj nk me nl bi translated">问题</h2><p id="7ad0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">用多个数组实现一个队列，其中每个数组都有固定的大小，<code class="fe nm nn no np b">MAX_QUEUE_SIZE</code>。</p><h2 id="29bd" class="na lp iq bd lq nb nc dn lu nd ne dp ly la nf ng ma le nh ni mc li nj nk me nl bi translated">解决办法</h2><p id="20a5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">从队列的一般描述中，我们知道我们至少需要:</p><ul class=""><li id="5d41" class="nz oa iq kt b ku kv kx ky la ob le oc li od lm oe of og oh bi translated"><code class="fe nm nn no np b">offer(num)</code>功能</li><li id="6ebd" class="nz oa iq kt b ku oi kx oj la ok le ol li om lm oe of og oh bi translated"><code class="fe nm nn no np b">poll()</code>功能。</li><li id="3e8c" class="nz oa iq kt b ku oi kx oj la ok le ol li om lm oe of og oh bi translated"><code class="fe nm nn no np b">isEmpty()</code>和<code class="fe nm nn no np b">isFull()</code>功能。</li></ul><p id="0e84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单队列的数组实现所需的数据片段是:一个<code class="fe nm nn no np b">array</code>和一个<code class="fe nm nn no np b">count</code>。这些东西够了吗？让我们看一个例子来找出答案。我们将从一个包含3个元素的队列开始。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="ea0f" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents' and 'count')<br/>-----------------   -----<br/>| a | b | c |   |   | 3 |<br/>-----------------   -----<br/>  0   1   2   3     count<br/>contents</span></pre><p id="cdda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中<code class="fe nm nn no np b">a</code>在<code class="fe nm nn no np b">front</code>处<code class="fe nm nn no np b">c</code>在<code class="fe nm nn no np b">rear</code>处。现在，我们用<code class="fe nm nn no np b">queue.offer('e')</code>添加一个新元素。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="21ef" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents' and 'count')<br/>-----------------   -----<br/>| a | b | c | d |   | 4 |<br/>-----------------   -----<br/>  0   1   2   3     count<br/>contents</span></pre><p id="687b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一切似乎都很好。如果我们用<code class="fe nm nn no np b">queue.poll()</code>去掉一个元素呢？</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="39f6" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents' and 'count')<br/>-----------------   -----   -----<br/>|   | b | c | d |   | 3 |   | a |<br/>-----------------   -----   -----<br/>  0   1   2   3     count    ch<br/>contents</span></pre><p id="aa18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，我们有一个问题，因为队列的<code class="fe nm nn no np b">front</code>不再位于数组位置0。一种解决方案是将所有元素下移一位，给出。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="c6ab" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents' and 'count')<br/>-----------------   -----<br/>| b | c | d |   |   | 3 |<br/>-----------------   -----<br/>  0   1   2   3     count<br/>contents</span></pre><p id="32a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是我们拒绝了这种解决方案，因为每次删除一个元素时将所有内容都下移太昂贵了。相反，我们是否可以使用额外的信息来跟踪前方？</p><p id="4b85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是啊！我们可以使用前面元素的索引，给出。</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="1c11" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents', 'front' and 'count')<br/>-----------------   -----   -----<br/>|   | b | c | d |   | 1 |   | 3 |<br/>-----------------   -----   -----<br/>  0   1   2   3     front   count<br/>contents</span></pre><p id="489a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们输入另一个元素:<code class="fe nm nn no np b">queue.offer('e')</code>？目前，队列的尾部保存着<code class="fe nm nn no np b">'d'</code>，位于数组的末尾。我们将把<code class="fe nm nn no np b">'e'</code>放在哪里？我们已经说过把所有东西都搬下来太贵了。另一种方法是在<code class="fe nm nn no np b">circular fashion</code>中使用数组。换句话说，当我们到达数组的末尾时，我们绕回并使用开头。现在，选择输入<code class="fe nm nn no np b">'e'</code>，字段看起来像这样:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="e40b" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents', 'front' and 'count')<br/>-----------------   -----   -----<br/>| e | b | c | d |   | 1 |   | 4 |<br/>-----------------   -----   -----<br/>  0   1   2   3     front   count<br/>contents</span></pre><p id="b715" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，之后会是什么样子:<code class="fe nm nn no np b">queue.poll()</code>？</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="1d1d" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents', 'front' and 'count')<br/>-----------------   -----   -----   -----<br/>| e |   | c | d |   | 2 |   | 3 |   | b |<br/>-----------------   -----   -----   -----<br/>  0   1   2   3     front   count    ch<br/>contents</span></pre><p id="3a10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所见，队列所需数据集的一个选择是:一个<code class="fe nm nn no np b">array</code>、一个<code class="fe nm nn no np b">front index</code>和一个<code class="fe nm nn no np b">count</code>。</p><p id="e8b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一种可能。相反，我们可以用车尾的位置来代替计数，这样就可以使用以下数据:an <code class="fe nm nn no np b">array</code>，a <code class="fe nm nn no np b">front index</code>，a <code class="fe nm nn no np b">rear index</code>。</p><p id="649b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，这些数据将以如下方式反映队列的状态…从一个有4个元素的队列开始…</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="d20e" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents', 'front' and 'rear')<br/>-----------------   -----   -----<br/>| a | b | c | d |   | 0 |   | 3 |<br/>-----------------   -----   -----<br/>  0   1   2   3     front   rear<br/>contents</span></pre><p id="70dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，用<code class="fe nm nn no np b">queue.poll()</code>移除一个，给出:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="d4ba" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents', 'front' and 'rear')<br/>-----------------   -----   -----<br/>|   | b | c | d |   | 1 |   | 3 |<br/>-----------------   -----   -----<br/>  0   1   2   3     front   rear<br/>contents</span></pre><p id="4b4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，添加一个带有<code class="fe nm nn no np b">queue.offer('e')</code>的，给出:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="12c7" class="na lp iq np b gy nu nv l nw nx">queue (made up of 'contents', 'front' and 'rear')<br/>-----------------   -----   -----<br/>| e | b | c | d |   | 1 |   | 0 |<br/>-----------------   -----   -----<br/>  0   1   2   3     front   rear<br/>contents</span></pre><p id="101e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以用JavaScript实现这个算法吗？</p><p id="14a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很简单，对吧？</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="b1e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我会更新Airbnb在这篇文章中提出的新问题🔖它重新阅读并获得最新的问题和解决方案。</p><p id="bc05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读😘</p><h2 id="74df" class="na lp iq bd lq nb nc dn lu nd ne dp ly la nf ng ma le nh ni mc li nj nk me nl bi translated"><strong class="ak">用简单英语写的JavaScript的注释:</strong></h2><p id="a992" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的Medium用户名给我们发邮件到<a class="ae ou" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>，我们会把你添加为作者。</p></div></div>    
</body>
</html>