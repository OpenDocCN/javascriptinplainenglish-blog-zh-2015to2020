<html>
<head>
<title>JavaScript Async/Await and Promises: Explained like you’re five years old.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Async/Await和Promises:像你五岁时一样解释。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-async-await-and-promises-explained-like-youre-five-years-old-61733751e9a5?source=collection_archive---------0-----------------------#2019-09-04">https://javascript.plainenglish.io/javascript-async-await-and-promises-explained-like-youre-five-years-old-61733751e9a5?source=collection_archive---------0-----------------------#2019-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b0cb88446d52a09c9b50722a3e2e5099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5r2Hf1hKFt8sTGD5TLqFOw.png"/></div></figure><p id="f95e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何自称为JavaScript开发人员的人都不得不使用回调函数、Promises或最近的Async/Await语法。如果你已经在这个游戏中呆了足够长的时间，那么你可能已经看到了嵌套回调是执行异步JavaScript的唯一方式的时代的转变。</p><p id="f6dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我第一次开始学习和编写JavaScript时，已经有十亿本指南和教程在解释如何使用它们。然而，他们中的许多人只是解释了如何在回调到承诺，或者承诺到异步/等待之间转换。不可否认，对于许多人来说，这对他们相处和编写代码来说已经足够了。</p><p id="9d92" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，如果你像我一样，并且<em class="ks">真的</em>想要理解异步编程(而不仅仅是JavaScript语法！)，那么您可能会同意我的观点，即缺乏从头开始解释异步编程的内容。</p><h1 id="9602" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">“异步”是什么意思？</h1><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/60868c2c8236762a6689f210dc4f543f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*3ZTh50C7DeOtxNJ0NNcf9A.jpeg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">The face of many when dealing with async</figcaption></figure><p id="2369" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一般来说，通过问这个问题，你会得到如下的答案:</p><ul class=""><li id="b0f9" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">多个线程同时执行代码</li><li id="aa2e" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">一次运行多位代码</li><li id="ed97" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">并发(？)</li></ul><p id="37b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些都是<em class="ks">某种程度上</em>沿着正确的路线。但是我不会给你一个你可能以后会忘记的技术定义，我会给你<strong class="jw ir">一个五岁小孩能理解的例子</strong>。</p><h1 id="0f20" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个更人性化的类比</h1><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/e7d22ec26c6ab5904dabf51d79401ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjQ0RjCIgZnJS0_am9GNOg.jpeg"/></div></div></figure><p id="9820" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">想象你正在煮一些蔬菜汤。为了一个简单的类比，让我们假设所说的蔬菜汤只包含洋葱和胡萝卜。这种汤的配方可能如下:</p><ol class=""><li id="30f1" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mt mg mh mi bi translated">切一些胡萝卜。</li><li id="a668" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">切一些洋葱。</li><li id="ead6" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">往锅里加水，打开炉子，等水烧开。</li><li id="42c8" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">将胡萝卜放入锅中，煮5分钟。</li><li id="2b85" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">将洋葱放入锅中，再煮10分钟。</li></ol><p id="fc94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些说明简单明了，但是如果你们中的任何人真的在阅读这篇文章，你会意识到这种<strong class="jw ir">并不是最省时的烹饪方式。对于那些没有经验的厨师来说，原因如下:</strong></p><ul class=""><li id="0abf" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">步骤3、4和5<strong class="jw ir"><em class="ks"/></strong>除了看锅和记时间，实际上不需要你作为厨师做任何事情。</li><li id="368d" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated"><strong class="jw ir">步骤1和步骤2<em class="ks">做</em> </strong>需要你主动去做一些事情。</li></ul><p id="e358" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，一个更熟练的厨师可能会这样做:</p><ol class=""><li id="20fe" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mt mg mh mi bi translated">开始烧一壶水</li><li id="6b2d" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">在等锅里的水烧开的时候，开始切一些胡萝卜。</li><li id="c65a" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">当你完成切胡萝卜的时候，水应该已经开了，所以加入胡萝卜。</li><li id="affd" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">当胡萝卜在锅里煮的时候，把洋葱切碎。</li><li id="c125" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mt mg mh mi bi translated">加入洋葱，然后再煮10分钟。</li></ol><p id="7d85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然还有同样多的事情要做，但你可以希望看到这样会更快更有效率。这是与异步编程完全相同的核心概念:<strong class="jw ir">你永远不会想无所事事地纯粹等待<em class="ks">某事，而有其他事情你可以花精力去做。</em></strong></p><p id="c6f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们都知道在编程中，<strong class="jw ir">等待</strong>经常发生——无论是等待来自服务器、文件系统I/O等的HTTP响应。但是你的CPU的执行周期是宝贵的，应该<strong class="jw ir">总是</strong>积极地<em class="ks">做一些事情</em> <strong class="jw ir"> <em class="ks">，</em> </strong> <em class="ks"> </em>而不是等待:因此，<strong class="jw ir">异步编程</strong>。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="5d9d" class="kt ku iq bd kv kw nb ky kz la nc lc ld le nd lg lh li ne lk ll lm nf lo lp lq bi translated">现在，让我们开始真正的JavaScript，好吗？</h1><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ng"><img src="../Images/467792e9999de296a8b5a19f17d32431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXptADWmZcG0wWqPUcHz0Q.jpeg"/></div></div></figure><p id="6f38" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好了，还是以蔬菜汤为例，我要定义几个函数来表示上面的动作。</p><p id="d9a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，让我们定义正常的同步函数，这些函数表示根本不需要等待的任务。这些是您的优秀的普通JavaScript函数——尽管请注意，我通过让它们进行一些昂贵的计算，模拟了需要积极处理(并花费时间)的任务<code class="fe nh ni nj nk b">chopCarrots</code>和<code class="fe nh ni nj nk b">chopOnions</code>。我已经注释掉了实际的实现，因为它们并不重要，但是它们可以在脚注中找到。</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Synchronous functions</figcaption></figure><p id="0299" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">至于异步函数，首先我将快速解释JavaScript的类型系统如何处理异步性:基本上，<strong class="jw ir">异步操作的所有结果(包括空结果)都必须包装在Promise类型中。</strong></p><p id="c37f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了让函数返回承诺，您可以</p><ul class=""><li id="aa06" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">明确返回承诺，即<strong class="jw ir">返回新的承诺(…..);</strong></li><li id="5639" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">在函数签名中添加<code class="fe nh ni nj nk b">async</code></li><li id="0d29" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated"><em class="ks">或两者皆有。</em></li></ul><p id="edbb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">出于我不打算深入本文的原因，您应该<strong class="jw ir"> <em class="ks">总是</em> </strong>在异步函数上使用<code class="fe nh ni nj nk b">async</code>关键字。</p><p id="50f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，对于我们的异步函数(代表制作蔬菜汤的步骤3–5):</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Our async functions representing tasks that eventually require waiting of some sort</figcaption></figure><p id="56e6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样，我已经删除了实现的细节，但是如果你想看的话，我会把它们贴在最后。</p><p id="6f56" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样需要知道的是，为了等待承诺的结果，你可以用它来做一些事情，你可以简单地使用<code class="fe nh ni nj nk b">await</code>关键字:</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Most basic example of Async/Await syntax</figcaption></figure><p id="8311" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以现在，我们只需要把这些放在一起:</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6c14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是等等！没用！你会得到一个<code class="fe nh ni nj nk b">SyntaxError: await is only valid in async functions</code>。为什么？因为，如果你没有声明一个函数为<code class="fe nh ni nj nk b">async</code>，那么默认情况下JavaScript认为它是一个<em class="ks">同步</em> <strong class="jw ir"> <em class="ks"> </em> </strong>函数——同步意味着没有等待！(这也意味着你根本不能在函数之外的顶层脚本中使用<code class="fe nh ni nj nk b">await</code>)。</p><p id="91a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们简单地将<code class="fe nh ni nj nk b">async</code>关键字添加到<code class="fe nh ni nj nk b">makeSoup</code>函数中:</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">This should work!</figcaption></figure><p id="ffc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">瞧啊。注意，在第2行，我调用了不带关键字<code class="fe nh ni nj nk b">await</code>的异步<code class="fe nh ni nj nk b">boilPot()</code>函数，因为我们实际上不想等到锅烧开了才开始切胡萝卜。在我们需要把胡萝卜放进锅里之前，我们只需要遵守诺言，因为我们不想在水开之前这么做。</p><p id="e686" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe nh ni nj nk b">await</code>通话过程中会发生什么？嗯，没什么…..有点…</p><p id="6784" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe nh ni nj nk b">makeSoup</code>函数的上下文中，你可以简单地把它想象成你在等待某事发生(或者等待<em class="ks">最终返回</em>的结果)。</p><p id="eb7a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，请记住:你(中央处理器)永远不会想坐在那里纯粹等待某事，而有其他事情你可以花精力去做。</p><p id="eba5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，如果我们不只是做汤，而是做这个:</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Multiple tasks at once</figcaption></figure><p id="d504" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，当我们在做<code class="fe nh ni nj nk b">await</code> -ing <code class="fe nh ni nj nk b">letPotKeepBoiling</code>的时候，我们实际上也可以做意大利面。</p><p id="6ad4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看到了吗？一旦你理解了Async/Await，它实际上很容易使用，不是吗？</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="36b4" class="kt ku iq bd kv kw nb ky kz la nc lc ld le nd lg lh li ne lk ll lm nf lo lp lq bi translated">明确的承诺呢？</h1><p id="fcac" class="pw-post-body-paragraph ju jv iq jw b jx nn jz ka kb no kd ke kf np kh ki kj nq kl km kn nr kp kq kr ij bi translated">好吧，如果你坚持的话，我也会明确地使用承诺。记住，async/await方法<strong class="jw ir">是基于承诺本身的，因此这两种方法是完全兼容的。</strong></p><p id="0128" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我看来，显式承诺是在使用旧式回调和新的性感的async/await语法之间的折中。或者，你也可以把性感的async/await语法看作仅仅是<em class="ks">隐含的</em>承诺。毕竟，async/await是在承诺之后出现的，而承诺本身是在回调之后出现的。</p><p id="e5c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，请乘坐我们的时间机器进行一次短暂的访问，回电hell⁴:</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4107" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我不想撒谎，我是在写这篇文章的时候匆忙写的，花了我不愿意承认的时间。你们中的许多人根本不知道发生了什么。亲爱的主啊，那些试镜不都很糟糕吗？让这成为一个教训，永远不要再碰回调... </p><p id="81ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">而且，像承诺的那样(<em class="ks">呵呵</em>)，用明确的承诺:</p><figure class="ls lt lu lv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">Using Promises explicitly with .then callbacks</figcaption></figure><p id="5f85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如你所看到的，承诺的某些方面仍然很难实现。</p><p id="1cb4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我就不细说了，基本上:</p><ul class=""><li id="f7b2" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated"><code class="fe nh ni nj nk b">.then</code>是一个关于承诺的方法，它获取承诺的结果并将其传递给参数函数(本质上是一个回调函数……)</li><li id="de3c" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">你永远不能在<code class="fe nh ni nj nk b">.then</code>的上下文之外打开承诺的结果。⁵本质上，<code class="fe nh ni nj nk b">.then</code>就像一个<code class="fe nh ni nj nk b">async</code>块，它将<code class="fe nh ni nj nk b">await</code>的结果传递给回调函数。</li><li id="35bd" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">还有用于处理错误的<code class="fe nh ni nj nk b">reject</code>回调和用于处理错误的<code class="fe nh ni nj nk b">.catch</code>承诺方法，但我不会深入讨论，因为还有数十亿个其他承诺教程。</li></ul><h1 id="92fd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="030a" class="pw-post-body-paragraph ju jv iq jw b jx nn jz ka kb no kd ke kf np kh ki kj nq kl km kn nr kp kq kr ij bi translated">我真的希望你从这篇文章中对承诺和异步编程有所了解，或者至少学会了一种向别人解释的好方法。</p><p id="3a41" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">那么，应该用哪个呢？明确承诺还是异步/等待</strong>？答案完全取决于你——我认为混合使用它们也没什么不好，因为它们彼此完全兼容。</p><p id="ca26" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">也就是说，就我个人而言，我100%支持Async/Await阵营，对我来说，代码更清晰，更能反映异步编程真正的多任务特性。</p><p id="76c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你是哪一个？在评论里发帖！</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="44bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">【1】</strong>:此处有完整的源代码<a class="ae ns" href="https://gist.github.com/jackel119/b0599ff78e2a14b07439dd251dad464c#file-complete-js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e4a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">【2】:</strong>见此处<a class="ae ns" href="https://dev.to/mywebstuff_hq/async-function-vs-a-function-that-returns-a-promise-3lpo" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="16a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">【3】</strong>:你可能会说JavaScript可以通过函数体和递归检查来推断async/await类型，但是JavaScript并不关心编译时的静态类型安全，更不用说让开发人员能够显式地看到更方便了。</p><p id="b5be" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">【4】</strong>:我编写“异步”函数时，假设它们与<code class="fe nh ni nj nk b">setTimeout</code>在同一个回调接口下工作。请注意，回调与承诺是不兼容的，反之亦然。</p><p id="0837" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对你们这些功能怪胎来说，承诺就是一个单子！</p></div></div>    
</body>
</html>