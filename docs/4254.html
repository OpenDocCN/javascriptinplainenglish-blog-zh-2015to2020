<html>
<head>
<title>Let’s Build a Simple Bulletin Board React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个简单的公告板React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-simple-bulletin-board-react-app-fc02d9b83070?source=collection_archive---------9-----------------------#2020-11-28">https://javascript.plainenglish.io/lets-build-a-simple-bulletin-board-react-app-fc02d9b83070?source=collection_archive---------9-----------------------#2020-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ccc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我写的一篇关于在React 中制作可拖动组件的文章中，一位读者请求分享我是如何构建<a class="ae kl" href="https://victoria-lo.github.io/bulletin-board/" rel="noopener ugc nofollow" target="_blank">公告牌应用</a>的，这是一个简单的演示应用，用来展示React中的可拖动组件。</p><p id="78f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将一步步展示我是如何制作这个简单的应用程序的，它非常适合React初学者学习如何在他们的项目中实现可拖动的组件。我们开始吧！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7347ed470869d62416e926626ef551ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRymJFKttr5JUZPTRmzptA.png"/></div></div></figure><h1 id="985e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">该应用程序</h1><p id="db09" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">该应用程序可以执行以下操作:</p><ol class=""><li id="325f" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">允许用户在输入中键入一些内容，然后按ENTER键生成一个随机颜色的注释。</li><li id="4e4b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">允许用户将便笺拖动到任何地方。即使在用户退出应用程序后，它的位置、颜色和内容也会被保存。</li><li id="74c2" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">允许用户通过点击右上角的“X”按钮来删除注释。</li></ol><p id="7d44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们根据它的3个用例来构建应用程序。</p><h1 id="c0d6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤1:安装和导入软件包</h1><p id="701d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">通过运行以下命令初始化新的Create React应用程序:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="5856" class="mu kz iq mq b gy mv mw l mx my">npx create-react-app my-bulletin-board-app</span></pre><p id="405e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在项目的根文件夹中，安装我们需要的以下包:</p><ol class=""><li id="6df0" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><code class="fe mz na nb mq b">react-draggable</code>:实现票据的可拖动特性</li><li id="8edc" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><code class="fe mz na nb mq b">randomcolor</code>:允许生成随机颜色的纸币</li><li id="9139" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><code class="fe mz na nb mq b">uuid</code>:为每张票据生成唯一标识符</li></ol><p id="8661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用命令安装:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="42dd" class="mu kz iq mq b gy mv mw l mx my">npm install react-draggable randomcolor uuid</span></pre><p id="1b43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mz na nb mq b">App.js</code>中，导入包并反应<code class="fe mz na nb mq b">useEffect</code>和<code class="fe mz na nb mq b">useState</code>钩子。</p><h1 id="c9b4" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤2:初始化状态</h1><p id="d929" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们需要使用<code class="fe mz na nb mq b">useState</code>钩子创建并初始化两个状态。</p><ol class=""><li id="43a5" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><code class="fe mz na nb mq b">item</code>:这是输入字段的值。初始化为空字符串。</li><li id="a0a8" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><code class="fe mz na nb mq b">items</code>:这是一个数组，包含所有生成的笔记，保存到localStorage。如果localStorage没有保存<code class="fe mz na nb mq b">items</code>，则初始化为空数组。</li></ol><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="9d6b" class="mu kz iq mq b gy mv mw l mx my">const [item, setItem] = useState("");<br/>const [items, setItems] = useState(<br/>    JSON.parse(localStorage.getItem("items")) || []<br/>  );</span></pre><h1 id="45fa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步骤3:创建输入元素</h1><p id="9508" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们可以在<code class="fe mz na nb mq b">App.js</code>的返回函数中创建HTML输入和按钮元素，如下所示:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="037a" class="mu kz iq mq b gy mv mw l mx my">&lt;input<br/>    value={item}<br/>    onChange={(e) =&gt; setItem(e.target.value)}<br/>    placeholder="Enter something..."<br/>    onKeyPress={(e) =&gt; keyPress(e)}<br/>/&gt;<br/>&lt;button onClick={newitem}&gt;ENTER&lt;/button&gt;</span></pre><p id="f1f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它看起来像这样:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nc"><img src="../Images/bd38276eeff1c517defac2aec3e39010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kXu1ccuf4B-BeY5S"/></div></div></figure><p id="1b9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb mq b">&lt;input&gt;</code>具有以下属性:</p><ul class=""><li id="544f" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">value</code>:设定为<code class="fe mz na nb mq b">item</code>状态的值</li><li id="4699" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">onChange</code>:每次输入值发生变化时，更新<code class="fe mz na nb mq b">item</code>状态</li><li id="3ea7" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">placeholder</code>:输入栏无内容时的描述</li><li id="fe73" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">onKeyPress</code>:调用<code class="fe mz na nb mq b">keyPress</code>函数检查按下的键是否为ENTER，调用<code class="fe mz na nb mq b">newitem</code>函数。</li></ul><p id="cbb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按键函数是这样写的:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="d034" class="mu kz iq mq b gy mv mw l mx my">const keyPress = (event) =&gt; {<br/>    var code = event.keyCode || event.which;<br/>    if (code === 13) {<br/>      newitem();<br/>    }<br/>  };</span></pre><p id="f9f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，用户可以在输入字段中键入一些内容，然后按ENTER键或单击ENTER按钮在屏幕上生成一个新的注释。</p><p id="c56e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于ENTER按钮，当用户点击它时，就会调用<code class="fe mz na nb mq b">newitem</code>函数。接下来我们来写这个函数。</p><h1 id="363d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第四步:新项目</h1><p id="f8af" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">该功能使用用户输入的字符串在屏幕上生成一个新的注释(即<code class="fe mz na nb mq b">item</code>)。注释是具有以下属性的对象:</p><ul class=""><li id="717e" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">id</code>:使用uuidv4()生成的唯一标识符</li><li id="81fb" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">item</code>:注释的字符串内容，是状态<code class="fe mz na nb mq b">item</code>的值</li><li id="7a64" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">color</code>:票据的背景颜色，用<code class="fe mz na nb mq b">randomColor({luminosity: "light",})</code>生成</li><li id="343e" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">defaultPos</code>:音符的x和y坐标。初始化为<code class="fe mz na nb mq b">{x:100, y:0}</code>。</li></ul><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="722b" class="mu kz iq mq b gy mv mw l mx my">const newitem = () =&gt; {<br/>    if (item.trim() !== "") {<br/>     //if input is not blank, create a new item object<br/>      const newitem = {<br/>        id: uuidv4(),<br/>        item: item,<br/>        color: randomColor({luminosity: "light",}),<br/>        defaultPos: { x: 100, y: 0 },<br/>      };<br/>      //add this new item object to the items array<br/>      setItems((items) =&gt; [...items, newitem]);<br/>      //reset item value to empty string<br/>      setItem("");<br/>    } else {<br/>      alert("Enter a item");<br/>      setItem("");<br/>    }<br/>};</span></pre><p id="883b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们在每次更新我们的<code class="fe mz na nb mq b">items</code>数组时更新我们的localStorage。我们可以使用<code class="fe mz na nb mq b">useEffect</code>挂钩来实现这一点:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="400b" class="mu kz iq mq b gy mv mw l mx my">useEffect(() =&gt; {<br/>    localStorage.setItem("items", JSON.stringify(items));<br/>  }, [items]);</span></pre><p id="6853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们应该在屏幕上显示我们的<code class="fe mz na nb mq b">items</code>数组中的笔记对象。</p><h1 id="c9ee" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第五步:展示物品</h1><p id="bcd7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我们的返回函数中，在我们的输入和按钮元素下面，我们可以使用<code class="fe mz na nb mq b">map</code>数组方法显示我们的注释:</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="7554" class="mu kz iq mq b gy mv mw l mx my">{items.map((item, index) =&gt; {<br/>        return (<br/>          &lt;Draggable<br/>            key={item.id}<br/>            defaultPosition={item.defaultPos}<br/>            onStop={(e, data) =&gt; {<br/>              updatePos(data, index);<br/>            }}<br/>          &gt;<br/>            &lt;div style={{ backgroundColor: item.color }} className="box"&gt;<br/>              {`${item.item}`}<br/>              &lt;button id="delete" onClick={(e) =&gt; deleteNote(item.id)}&gt;<br/>                X<br/>              &lt;/button&gt;<br/>            &lt;/div&gt;<br/>          &lt;/Draggable&gt;<br/>        );<br/>      })}</span></pre><p id="cc7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe mz na nb mq b">items</code>数组中的每个note对象，我们将创建一个<code class="fe mz na nb mq b">&lt;Draggable&gt;</code>组件，其中:</p><ul class=""><li id="6b25" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk nd mh mi mj bi translated">对象的<code class="fe mz na nb mq b">key</code>属性= <code class="fe mz na nb mq b">id</code>。</li><li id="add4" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">defaultPosition</code>的成分= <code class="fe mz na nb mq b">defaultPos</code>的对象。</li><li id="02a4" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><code class="fe mz na nb mq b">onStop</code>，当用户停止拖动屏幕上的音符时，将调用<code class="fe mz na nb mq b">updatePos</code>函数。</li></ul><p id="9614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mz na nb mq b">&lt;Draggable&gt;</code>组件中，我们有<code class="fe mz na nb mq b">&lt;div&gt;</code>，它将在带有注释的<code class="fe mz na nb mq b">colour</code>属性的背景上呈现注释的<code class="fe mz na nb mq b">item</code>属性。最后，我们有一个“X”按钮，单击它将调用<code class="fe mz na nb mq b">deleteNote</code>功能。</p><p id="36c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们应该能够在每次输入内容并按回车键时，在屏幕上生成一个新的随机颜色的注释。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ne"><img src="../Images/4180067119753cb67f8f9ba3fc9af7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y22MSPyAKifAdwV8R0mcgw.png"/></div></div></figure><p id="52b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果我们拖动注释并重新加载页面，注释的位置将不会被保存，因为我们还没有编写我们的<code class="fe mz na nb mq b">updatePos</code>函数。接下来让我们编写这个函数。</p><h1 id="09b2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第六步:更新位置</h1><p id="8891" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每次我们停止拖动便笺时，都会调用这个函数。这样，我们可以将注释的最终位置保存到localStorage中的<code class="fe mz na nb mq b">items</code>数组中。</p><p id="df58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次我们访问该页面时，应用程序会记住笔记的最后位置。它不会一直重置为<code class="fe mz na nb mq b">{x:</code> 100，y:0} `的。</p><p id="3d6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数的工作原理如下:</p><ol class=""><li id="248d" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">我们将<code class="fe mz na nb mq b">data</code>作为函数的第一个参数传递。它包含我们的笔记的x和y坐标。</li><li id="9802" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">将我们的<code class="fe mz na nb mq b">items</code>数组克隆成一个名为<code class="fe mz na nb mq b">newArr</code>的新数组。</li><li id="dc6e" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">从第二个参数<code class="fe mz na nb mq b">index</code>中获取我们想要更新的数组中音符的索引。</li><li id="ad86" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">在其<code class="fe mz na nb mq b">defaultPos</code>属性中设置注释的新坐标值。</li><li id="e8f1" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">将<code class="fe mz na nb mq b">items</code>设置为<code class="fe mz na nb mq b">newArr</code>的值。</li></ol><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="0e21" class="mu kz iq mq b gy mv mw l mx my">const updatePos = (data, index) =&gt; {<br/>    let newArr = [...items];<br/>    newArr[index].defaultPos = { x: data.x, y: data.y };<br/>    setItems(newArr);<br/> };</span></pre><p id="e59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在，任何笔记的位置都会更新并保存到localStorage。下面我们来看最后一个函数:<code class="fe mz na nb mq b">deleteNote</code>。</p><h1 id="3185" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第七步:删除注释</h1><p id="f0eb" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在该功能中，注释将从屏幕上和本地存储器的<code class="fe mz na nb mq b">items</code>数组中删除。</p><p id="4590" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数非常简单。我们可以简单地使用<code class="fe mz na nb mq b">filter</code>数组方法来删除其<code class="fe mz na nb mq b">id</code>属性与函数的<code class="fe mz na nb mq b">id</code>参数相匹配的注释。</p><pre class="kn ko kp kq gt mp mq mr ms aw mt bi"><span id="63ef" class="mu kz iq mq b gy mv mw l mx my">const deleteNote = (id) =&gt; {<br/>    setItems(items.filter((item) =&gt; item.id !== id));<br/> };</span></pre><h1 id="969c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">就是这样！</h1><p id="804d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们现在应该有一个简单的工作公告板应用程序，如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/24cd4e392886f96f98dcb996a639bc25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaWeJLe4VOy1V6AS0GsqFQ.png"/></div></div></figure><p id="86d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。我希望这有助于在您的项目中实现React Draggable。关于React Draggable的更多细节，请随意查看我的文章<a class="ae kl" href="https://medium.com/javascript-in-plain-english/making-draggable-components-in-react-4c6d4d1df95f?sk=1a6316505828cb9ddf921aa806256674" rel="noopener">在React中制作可拖动组件。</a></p><p id="06e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这篇文章有帮助，请喜欢并分享，并在下面的评论中留下任何问题。查看该应用的<a class="ae kl" href="https://victoria-lo.github.io/bulletin-board/" rel="noopener ugc nofollow" target="_blank">演示</a>或<a class="ae kl" href="https://github.com/victoria-lo/bulletin-board/" rel="noopener ugc nofollow" target="_blank">回购</a>。有关我们用来构建这个应用程序的包的更多信息，请随意阅读下面的部分。</p><p id="cb19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别感谢<a class="ae kl" href="https://hashnode.com/@Mg_Garg" rel="noopener ugc nofollow" target="_blank"> Manas Garg </a>请求本文。抱歉，过了这么久才最终发表。谢谢，干杯！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="ed6a" class="ky kz iq bd la lb nn ld le lf no lh li lj np ll lm ln nq lp lq lr nr lt lu lv bi translated">请参见</h1><ul class=""><li id="4ada" class="mb mc iq jp b jq lw ju lx jy ns kc nt kg nu kk nd mh mi mj bi translated"><a class="ae kl" href="https://github.com/STRML/react-draggable/" rel="noopener ugc nofollow" target="_blank">反应——可拖动</a></li><li id="aa39" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><a class="ae kl" href="https://www.npmjs.com/package/randomcolor" rel="noopener ugc nofollow" target="_blank"> randomcolor </a></li><li id="6a33" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk nd mh mi mj bi translated"><a class="ae kl" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a></li></ul></div></div>    
</body>
</html>