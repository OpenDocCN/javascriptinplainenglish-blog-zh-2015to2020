<html>
<head>
<title>Why We Should All Use the JavaScript Spread Operator?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们都应该使用JavaScript Spread运算符？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-we-should-all-use-the-javascript-spread-operator-b9e277a38689?source=collection_archive---------8-----------------------#2020-04-06">https://javascript.plainenglish.io/why-we-should-all-use-the-javascript-spread-operator-b9e277a38689?source=collection_archive---------8-----------------------#2020-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4c323f081b7be29d09d9c11185b720eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QuG1jsZb_eZ5oyme"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thevernon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vernon Raineil Cenzon</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3685" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript spread操作符对于许多我们可能不知道它能做的事情非常有用。</p><p id="67c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看它为什么有用。</p><h1 id="d5d3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">传播函数调用</h1><p id="8446" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">spread运算符可用于将一组对象和值扩展到参数中。</p><p id="6032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1af3" class="mn lc iq mj b gy mo mp l mq mr">const min = Math.min(...[1, 2, 2, 3, 5]);</span></pre><p id="05e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从数组中找出最小的数。</p><p id="562e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比使用<code class="fe ms mt mu mj b">apply</code>做同样的事情要好得多，因为我们不必将<code class="fe ms mt mu mj b">this</code>的值作为第一个参数传入。</p><h1 id="93fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复制数组</h1><p id="f1f0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用spread操作符将一个数组浅层复制到另一个数组中。</p><p id="a980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7d11" class="mn lc iq mj b gy mo mp l mq mr">const arr = [1, 2, 3];<br/>const arrCopy = [...arr];</span></pre><p id="fe0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们记录两者的值时，我们会看到它们具有相同的值，但是当我们记录以下值时:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8dc9" class="mn lc iq mj b gy mo mp l mq mr">arr === arrCopy</span></pre><p id="4034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到它是<code class="fe ms mt mu mj b">false</code>。因此，我们知道它们引用的不是同一个数组。</p><h1 id="3810" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">串联数组</h1><p id="d121" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将spread运算符应用于多个数组来将多个数组连接起来。</p><p id="ed2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="269e" class="mn lc iq mj b gy mo mp l mq mr">const arr1 = [0, 1, 2];<br/>const arr2 = [3, 4, 5];<br/>const arr = [...arr1, ...arr2];</span></pre><p id="254e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们得到<code class="fe ms mt mu mj b">arr</code>的值是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2496" class="mn lc iq mj b gy mo mp l mq mr">[0, 1, 2, 3, 4, 5]</span></pre><p id="c1ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比使用<code class="fe ms mt mu mj b">concat</code>方法将两个数组连接在一起要容易得多。</p><h1 id="de8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复制对象</h1><p id="db02" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们也可以使用spread操作符来复制对象。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ccea" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};<br/>const objCopy = {<br/>  ...obj<br/>};</span></pre><p id="fd56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们记录两者的值时，我们会得到相同的值。</p><p id="0de8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们记录以下值时:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="584a" class="mn lc iq mj b gy mo mp l mq mr">obj === objCopy</span></pre><p id="d10c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会看到<code class="fe ms mt mu mj b">false</code>日志。这意味着<code class="fe ms mt mu mj b">obj</code>和<code class="fe ms mt mu mj b">objCopy</code>没有引用同一个对象，但是有相同的内容。</p><h1 id="d8fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">合并对象</h1><p id="1e1f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用spread运算符将对象合并为一个。如果一个属性在多个对象中具有相同的名称，则最后一个对象的值将覆盖之前的值。</p><p id="7534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写下如下，那么我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2cf5" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="0494" class="mn lc iq mj b gy mv mp l mq mr">const obj2 = {<br/>  a: 3,<br/>  c: 2<br/>};<br/>const mergedObj = {<br/>  ...obj,<br/>  ...obj2<br/>};</span></pre><p id="3835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到的<code class="fe ms mt mu mj b">mergedObj</code>的值是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="60c2" class="mn lc iq mj b gy mo mp l mq mr">{a: 3, b: 2, c: 2}</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/71dc8a17c3e94d03bccecbcc55dc1826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QymDkJYno0ButWHF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Louis Hansel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="93c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将类似数组的对象转换为数组</h1><p id="4025" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用spread操作符将类似数组的对象转换成数组。</p><p id="0ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似数组的对象包括像<code class="fe ms mt mu mj b">Set</code>、<code class="fe ms mt mu mj b">Map</code>、<code class="fe ms mt mu mj b">arguments</code>对象、节点列表和其他任何有<code class="fe ms mt mu mj b">Symbol.iterator</code>方法的对象。</p><p id="1a96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用它将一个节点列表转换成DOM nodes对象的数组，如下所示。</p><p id="7a0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有下面的HTML:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5889" class="mn lc iq mj b gy mo mp l mq mr">&lt;div&gt;<br/>  foo<br/>&lt;/div&gt;<br/>&lt;div&gt;<br/>  bar<br/>&lt;/div&gt;</span></pre><p id="d6ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以找到内部带有文本“bar”的<code class="fe ms mt mu mj b">div</code>,如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7184" class="mn lc iq mj b gy mo mp l mq mr">const divs = [...document.querySelectorAll('div')];<br/>const barDiv = divs.find(div =&gt; div.innerText === 'bar');</span></pre><p id="2225" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们用spread操作符转换了由<code class="fe ms mt mu mj b">querySelectorAll</code>返回的节点列表，我们就可以使用任何像<code class="fe ms mt mu mj b">find</code>这样的数组方法来做我们想做的事情。</p><p id="9ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">节点列表没有任何数组方法，但是它们可以通过循环来循环，有一个<code class="fe ms mt mu mj b">length</code>属性，每个条目有一个索引。</p><p id="533c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以将<code class="fe ms mt mu mj b">Set</code>转换成数组，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f971" class="mn lc iq mj b gy mo mp l mq mr">const arr = [...new Set([1, 2, 3, 3])];</span></pre><p id="4de9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们得到<code class="fe ms mt mu mj b">arr</code>的值是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8c48" class="mn lc iq mj b gy mo mp l mq mr">[1, 2, 3]</span></pre><p id="c15b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对其他类型的类似数组的对象做同样的事情。</p><h1 id="95df" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">集合操作</h1><p id="ffab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">由于数组有许多过滤数据的方法，我们可以使用这些方法来做普通的集合操作，这些操作不能用<code class="fe ms mt mu mj b">Set</code>实例本身来做，因为它们没有方法来做这些事情。</p><p id="aa36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过将集合转换为数组来做集合并和交集这样的事情，然后用数组方法做运算，然后我们可以将数组结果转换回集合。</p><p id="59c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想找到两个集合的交集，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1d5e" class="mn lc iq mj b gy mo mp l mq mr">const setA = new Set([1, 2, 3]);<br/>const setB = new Set([3, 4, 5]);<br/>const intersection = [...setA, ...setB].filter(el =&gt; [...setA].includes(el) &amp;&amp; [...setB].includes(el));<br/>console.log(new Set(intersection));</span></pre><p id="dcee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe ms mt mu mj b">intsection</code>中只有元素3，因为3在<code class="fe ms mt mu mj b">setA</code>和<code class="fe ms mt mu mj b">setB</code>中都存在。</p><p id="aa2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的是将<code class="fe ms mt mu mj b">setA</code>和<code class="fe ms mt mu mj b">setB</code>转换成数组，然后在合并后的数组上调用<code class="fe ms mt mu mj b">filter</code>，将两个集合扩展成一个大数组。</p><p id="484a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用谓词调用数组上的<code class="fe ms mt mu mj b">filter</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2f2d" class="mn lc iq mj b gy mo mp l mq mr">[...setA].includes(el) &amp;&amp; [...setB].includes(el)</span></pre><p id="0158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">找出两个集合中的元素。</p><p id="44d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们通过在<code class="fe ms mt mu mj b">Set</code>构造函数中传递将结果数组转换回集合。</p><h1 id="8e11" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="16a3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">spread运算符对于浅层复制数组和对象很有用。</p><p id="d37a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还可以用于合并数组和对象。</p><p id="3771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以用它很容易地将类似数组的对象转换成数组，这样我们就可以在它上面调用类似数组的对象上没有的数组方法。</p><p id="5b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得在其中查找内容和使用集合进行操作变得更加容易。</p><p id="552f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【JavaScript用简单英语写的一句话:我们总是对帮助推广优质内容感兴趣。如果你有一篇文章想用简单的英语提交给JavaScript，用你的Medium用户名给我们发邮件到<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>，我们会把你添加为作者。</p></div></div>    
</body>
</html>