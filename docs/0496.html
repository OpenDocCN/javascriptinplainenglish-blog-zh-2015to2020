<html>
<head>
<title>Replacing React HOCs with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用反应钩替换反应钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replacing-react-hocs-with-react-hooks-b0b0a616f759?source=collection_archive---------6-----------------------#2019-10-28">https://javascript.plainenglish.io/replacing-react-hocs-with-react-hooks-b0b0a616f759?source=collection_archive---------6-----------------------#2019-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a612ebf82d253174a1b5fcbdf8f0f0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9compzepG1gmq3-vfvE3w.jpeg"/></div></div></figure><p id="e18f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你没有玩过<a class="ae kt" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React Hooks </a>，你绝对应该花些时间回顾一下这个概念，并尝试一下。</p><p id="725b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们假设你已经知道React钩子是怎么回事了。我想展示如何用一个定制的React钩子替换一个<a class="ae kt" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> React HOC </a>。</p><p id="7ddc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">是的，我们将回顾一些React挂钩，但我们也将创建一个自定义挂钩，所以喝杯咖啡，为这一集做好准备。</strong></p><h1 id="e099" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我们的HOC将被替换</h1><p id="c173" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们将采用React文档中提供的特定示例，如果您还没有看到它，<a class="ae kt" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">请查看</a>。</p><p id="f073" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是特设的签名:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0399" class="mg kv in mc b gy mh mi l mj mk">function withSubscription(WrappedComponent, selectData)</span></pre><h1 id="5362" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">对HOC的简要描述(如果您知道它的作用，可以跳过这一部分)</h1><p id="9218" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所以，这个带订阅的<em class="ml">要做的是:</em></p><ol class=""><li id="919f" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">包装另一个组件(<em class="ml"> WrappedComponent </em></li><li id="b806" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">给它添加一些逻辑(<em class="ml"> selectData </em>)</li></ol><p id="c78e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你为什么要这么做？这是一种在组件之间共享公共逻辑的策略。<em class="ml">with subscription</em>function(HOC)<strong class="jx io">将创建一个全新的组件(理解这一点很重要)</strong>，其中它将使用<em class="ml"> selectData </em>参数从某处选择一些数据，并将这些数据作为属性注入到<em class="ml"> WrappedComponent </em>中。</p><p id="06ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，无论何时底层数据发生变化，它都会更新由<em class="ml"> withSubscription </em>函数创建的组件的状态，并自动刷新<em class="ml"> WrappedComponent </em>。</p><p id="83fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你使用那个HOC的方法如文件所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="59c3" class="mg kv in mc b gy mh mi l mj mk">const CommentListWithSubscription = withSubscription(<br/>  CommentList,<br/>  (DataSource) =&gt; DataSource.getComments()<br/>);</span></pre><p id="9c8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，<em class="ml"> CommentList </em>是要包装的组件，而<em class="ml">data source . get comments()</em>是要执行的从数据源检索一些数据的函数。你看到好处了吗？您将能够订阅/取消订阅数据源，并从其中获取一些数据，而不需要您想要的组件上隐含的实际逻辑，只需用<em class="ml"> withSubscription </em>函数包装它。</p><h1 id="b8bc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">从一个特设转移到一个反应钩，为什么？</h1><p id="d454" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">但是为什么从一个特设，而不是使用反应钩？嗯，我不是假装说hoc不好，但是我确实认为<em class="ml">它们是你的项目中包装器地狱的一个很好的来源，特别是在调试和测试</em>的时候。</p><p id="eb0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我个人的看法。但不管怎样，如果你不同意我的观点，那也没关系。我仍然认为你会发现这很有趣。</p><h1 id="069a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">临时实施</h1><p id="f333" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了让大家更好地理解我们正在做的事情，我整理了一些东西:</p><ol class=""><li id="7eab" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">虚假数据源:</li></ol><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">DataSource.js</figcaption></figure><p id="3b07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.特设的完整版本:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">withSubscription.js</figcaption></figure><p id="5cb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.使用HOC的两个组件:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">BlogPost.js</figcaption></figure><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">CommentList.js</figcaption></figure><p id="5ee4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，这种方法有一些很大的好处:</p><ul class=""><li id="80e2" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks ng ms mt mu bi translated">我们在特设委员会内部有一些共同的逻辑。周围没有重复的代码。</li><li id="2346" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks ng ms mt mu bi translated">我们的组件看起来非常干净。我们甚至不需要在BlogPost和CommentList组件上实现<em class="ml"> componentDidMount </em>或<em class="ml"> componentWillUnmount </em>。</li></ul><p id="29fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，这很好。我们在任何与我们的特定实现相匹配的组件之间共享一些逻辑。</p><p id="8627" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是我们可以在这个实现上做一些改进:<strong class="jx io">我们可以利用React钩子来代替HOC，这样我们就可以通过移除每个组件的包装器和移除类的使用而从中受益(这是钩子的原始动机，正如在</strong><a class="ae kt" href="https://reactjs.org/docs/hooks-intro.html#motivation" rel="noopener ugc nofollow" target="_blank"/>https://reactjs.org/docs/hooks-intro.html#motivation的文档中所述)。</p><h1 id="9779" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍我们的自定义<em class="nh"> useSubscription </em>挂钩</h1><p id="5a97" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">每当我试图创造新的东西时，我总是从想象我想要的解决方案开始:它应该是什么样子的？</p><p id="f20c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我想到这个的第一件事:</p><p id="8e78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ml">使用订阅(myFunctionToSelectData) </em></p><p id="3f9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想用一个简单的调用来想象BlogPost组件，这个调用使用<em class="ml">(ds)=&gt;ds . get post(id)</em>作为参数。应该就是这样了，定制钩子应该负责:</p><ol class=""><li id="a20a" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">从数据源进行订阅/取消订阅</li><li id="1d8f" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">存储我的<em class="ml"> selectData </em>函数的结果，在本例中是<em class="ml"> ds.getPost(id) </em></li></ol><p id="5ba6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">表演时间！让我们从定制挂钩开始:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Initial custom hook idea</figcaption></figure><p id="7a83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按照React团队的规则，我们需要在开头用“use”来命名我们的定制钩子，这就是为什么我称它为<em class="ml"> useSubscription </em>。我们唯一需要返回的是由<em class="ml"> selectData </em>函数产生的实际数据。所以这是我目前唯一能做的事情:签名和返回数据(我仍然需要定义)。</p><h1 id="01ab" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">引入React useState挂钩</h1><p id="f118" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">花些时间查看<a class="ae kt" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">反应使用状态</a>的文档。我们将使用该钩子来存储我们的<em class="ml"> selectData </em>函数的结果:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2cca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这非常简单，我们使用React.useState来存储选择器的结果。React.useState返回两件事:我们存储的当前值和修改该值的函数。在我们的例子中，<em class="ml">数据</em>保存着我们选择器的结果，而<em class="ml"> setData </em>函数将被用来更新它，这是我们目前没有的，我们没有在任何地方更新我们的<em class="ml">数据</em>状态变量。</p><p id="f687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">信不信由你，这个简单的实现将部分工作。我们缺少的是将更改发送到组件的方法，因为现在，我们最初是在解析我们的选择器，但是如果底层数据在将来发生了变化，该怎么办呢？我们需要意识到这些变化。让我们开始吧。</p><h1 id="6282" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">引入React useEffect挂钩</h1><p id="19d6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">同样，你应该花点时间回顾一下<a class="ae kt" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> React useEffect </a> hook上的文档。我们将使用React.useEffect钩子来处理依赖于我们的定制钩子的组件上的订阅/取消订阅事件。检查实施情况:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c383" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<em class="ml"> React.useEffect </em>钩子来订阅/取消订阅数据源上的更改。这样，当使用<em class="ml"> useSubscription </em>钩子的组件被挂载时，它将订阅数据源更改，当它被卸载时，它将被取消订阅。</p><p id="a50a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，在<em class="ml"> useEffect </em>钩子上，我们再次执行<em class="ml"> selectData </em>函数，以便每当数据源指示有更改时，在特定时刻检索底层数据。这就是我们的组件与数据源同步的方式。</p><p id="0247" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对<em class="ml"> useEffect </em>如何工作有疑问，请查看文档，这样你就能了解实际发生了什么。</p><h1 id="d6ff" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">重构我们的组件。</h1><p id="ea86" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们现在需要做的是在我们的组件上实现我们的定制钩子。查看它们:</p><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">BlogPost.js using our hook</figcaption></figure><figure class="lx ly lz ma gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">CommentList.js using our hook</figcaption></figure><p id="be27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你怎么想呢?花点时间思考一下这些变化及其影响。以下是我看到的好处:</p><ol class=""><li id="0d7b" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">没有包装纸了。我们的React树会更干净，因为我们不会看到使用自定义钩子的组件的包装器。</li><li id="cc66" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">不再上课了。你看到那些漂亮的功能组件了吗？它使我们的组件更简单、更干净。</li><li id="f515" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">我们仍然在组件间重用逻辑。</li><li id="d8fb" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">使用HOCs，如果我们必须共享更多的逻辑，我们将需要在我们的组件上添加另一个包装器，但是使用React Hooks，只需要在我们的组件内部调用这个新的钩子。</li></ol><p id="20f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你在你的项目中使用HOCs吗？为什么不试着为其中一个创建一个定制的钩子替换物呢？</p><p id="940f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读，请让我知道你对此的想法。</p></div></div>    
</body>
</html>