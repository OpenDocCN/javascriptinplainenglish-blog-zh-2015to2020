<html>
<head>
<title>The Ultimate Guide to Array methods in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中数组方法的终极指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-you-need-to-know-about-array-methods-in-javascript-97899e85163c?source=collection_archive---------12-----------------------#2020-05-09">https://javascript.plainenglish.io/everything-you-need-to-know-about-array-methods-in-javascript-97899e85163c?source=collection_archive---------12-----------------------#2020-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5c83" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">可以添加到收藏夹中的代码指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a6097ee1cfd3183a06f3db6f2286ec6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qQnBK7E-wFMtb3Sg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paweł Czerwiński</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4bf2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">数组是JavaScript中最重要的数据结构之一。您可以在数组上执行的操作(迭代、插入项、删除项等)数量很大。数组对象提供了大量有用的方法，比如<code class="fe lp lq lr ls b">array.forEach()</code>、<code class="fe lp lq lr ls b">array.map()</code>等等。</p><p id="9946" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我经常发现自己被数组上可能的操作数量和相应的实现所淹没。你可能也会遇到同样的情况。</p><p id="6cc3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我总结了相关知识点，希望这能对你我有所帮助。</p><h2 id="4af9" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">目录</h2><ol class=""><li id="2072" class="mm mn in kv b kw mo kz mp lc mq lg mr lk ms lo mt mu mv mw bi translated">重复</li><li id="ad28" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">地图</li><li id="16e0" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">减少</li><li id="296f" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">串联</li><li id="5b36" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">薄片</li><li id="5afe" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">克隆</li><li id="7d92" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">搜索</li><li id="5812" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">询问</li><li id="c6ae" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">过滤器</li><li id="ef7e" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">插入</li><li id="3706" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">去除</li><li id="ed4c" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">空的</li><li id="9ede" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">充满</li><li id="a97c" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">变平</li><li id="968d" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">分类</li></ol><h1 id="f923" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">1:迭代</h1><p id="2ddd" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">遍历数组可能是我们对数组做的最多的操作。你知道有多少种方法可以循环数组吗？</p><h2 id="acd2" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">1.1:对于..关于</h2><p id="cf92" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">for(const item of items)</code>循环迭代数组项。</p><p id="1dab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们遍历一个<code class="fe lp lq lr ls b">colors</code>列表:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="13d5" class="lt lu in ls b gy nu nv l nw nx">const colors = ['blue', 'green', 'white'];</span><span id="7e9e" class="lt lu in ls b gy ny nv l nw nx">for (const color of colors) {<br/>  console.log(color);<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/86557d31677dc9212c377bf60cc89ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3Cay_ivh3MXM_ivsCzTxQ.png"/></div></div></figure><p id="e1a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每次迭代中，变量<code class="fe lp lq lr ls b">color</code>被赋予迭代项。</p><p id="dffa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="d69b" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">您可以使用<code class="fe lp lq lr ls b">break</code>语句随时停止迭代。</li></ul><h2 id="05a4" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">1.2:用于循环</h2><p id="3b98" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">for(let i; i &lt; array.length; i++)</code>使用递增的索引变量循环遍历数组项。</p><p id="b0d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">for</code>通常需要在每个周期递增的<code class="fe lp lq lr ls b">index</code>变量:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="7434" class="lt lu in ls b gy nu nv l nw nx">const colors = ['blue', 'green', 'white'];</span><span id="f990" class="lt lu in ls b gy ny nv l nw nx">for (let index = 0; index &lt; colors.length; index++) {<br/>  const color = colors[index];<br/>  console.log(color);<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/4e6f8f64026ac40e44ebb6ad5ac2a3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5N-Hb6oRHrlQY-KfpbTo7Q.png"/></div></div></figure><p id="a566" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">index</code>变量从<code class="fe lp lq lr ls b">0</code>到<code class="fe lp lq lr ls b">colors.length - 1</code>递增。该变量用于通过索引访问项目:<code class="fe lp lq lr ls b">colors[index]</code>。</p><p id="6017" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="ddcf" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">您可以使用<code class="fe lp lq lr ls b">break</code>语句随时停止迭代。</li></ul><h2 id="4b36" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">1.3: array.forEach()方法</h2><p id="91b0" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.forEach(callback)</code>方法通过在每个数组项上调用<code class="fe lp lq lr ls b">callback</code>函数来迭代数组项。</p><p id="b5d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每次迭代中，使用参数调用<code class="fe lp lq lr ls b">callback(item [, index [, array]])</code>:迭代项、索引和数组本身。</p><p id="192c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们迭代<code class="fe lp lq lr ls b">colors</code>数组:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="15e1" class="lt lu in ls b gy nu nv l nw nx">const colors = ['blue', 'green', 'white'];</span><span id="af19" class="lt lu in ls b gy ny nv l nw nx">colors.forEach(function callback(value, index) {<br/>  console.log(value, index);<br/>});</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/27e68e436051df32646e97ceff103841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcV-SYNEUlAafVhoKKe0iA.png"/></div></div></figure><p id="9eb6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.forEach(callback)</code>对数组中的每一项调用<code class="fe lp lq lr ls b">callback</code> 3次:<code class="fe lp lq lr ls b">'blue'</code>、<code class="fe lp lq lr ls b">'green'</code>和<code class="fe lp lq lr ls b">'white'</code>。</p><p id="4722" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="e857" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">您不能中断<code class="fe lp lq lr ls b">array.forEach()</code>迭代。</li></ul><h1 id="eb4e" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">2:地图</h1><h2 id="1bad" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">2.1: array.map()方法</h2><p id="24d3" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.map(callback)</code>方法通过对每个数组项使用<code class="fe lp lq lr ls b">callback</code>调用结果来创建一个新数组。</p><p id="0b75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每次迭代中，<code class="fe lp lq lr ls b">callback(item[, index[, array]])</code>被带参数调用:当前项，<code class="fe lp lq lr ls b">index</code>和数组本身。它应该返回新的项目。</p><p id="e5c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们递增数组的编号:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="f157" class="lt lu in ls b gy nu nv l nw nx">const numbers = [0, 2, 4];</span><span id="b073" class="lt lu in ls b gy ny nv l nw nx">const newNumbers = numbers.map(function increment(number) {<br/>  return number + 1;<br/>});</span><span id="55b9" class="lt lu in ls b gy ny nv l nw nx">console.log(newNumbers);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/96f58d6d41863d9f778ca6dfaa8ef107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLGFYR7dj-Vzv_p4qK_jdw.png"/></div></div></figure><p id="559b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">numbers.map(increment)</code>通过递增每个数组项从<code class="fe lp lq lr ls b">numbers</code>创建一个新数组。</p><p id="c77e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="c8ab" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">创建一个新的映射数组，不改变原来的数组。</li></ul><h2 id="3988" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">2.2: Array.from()函数</h2><p id="a19e" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">Array.from(arrayLike[, callback])</code>方法通过对每个数组项使用<code class="fe lp lq lr ls b">callback</code>调用结果来创建一个新数组。</p><p id="7b30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每一次迭代中，<code class="fe lp lq lr ls b">callback(item[, index[, array]])</code>被调用，并带有参数:当前项、索引和数组本身。它应该返回新的项目。</p><p id="280c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们递增数组的编号:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="596f" class="lt lu in ls b gy nu nv l nw nx">const numbers = [0, 2, 4];</span><span id="d5fc" class="lt lu in ls b gy ny nv l nw nx">const newNumbers = Array.from(numbers,<br/>  function increment(number) {<br/>    return number + 1;<br/>  }<br/>);</span><span id="131e" class="lt lu in ls b gy ny nv l nw nx">console.log(newNumbers);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/a3835e26294301a4f004c4b077275992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxQc6eQVjvDmMf-rYgnDEg.png"/></div></div></figure><p id="052b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">Array.from(numbers, increment)</code>通过递增每个数组项，从<code class="fe lp lq lr ls b">numbers</code>创建一个新数组。</p><p id="a9e4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="4c1a" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">Array.from()</code>创建新的映射数组，而不改变原始数组</li><li id="7732" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">Array.from()</code>更适合从<a class="ae ks" href="https://dmitripavlutin.com/javascript-array-from-applications/#2-transform-array-like-into-an-array" rel="noopener ugc nofollow" target="_blank">阵列状物体</a>映射。</li></ul><h1 id="d920" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">3:减少</h1><h2 id="5b5d" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">3.1: array.reduce()方法</h2><p id="c67a" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.reduce(callback[, initialValue])</code>通过调用<code class="fe lp lq lr ls b">callback</code>函数作为缩减器，将数组缩减为一个值。</p><p id="3634" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每一次迭代中，<code class="fe lp lq lr ls b">callback(accumulator, item[, index[, array]])</code>被带参数调用:累加器、当前项、索引和数组本身。它应该返回累加器。</p><p id="1d06" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">经典的例子是对一组数字求和:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="42bb" class="lt lu in ls b gy nu nv l nw nx">const numbers = [2, 0, 4];</span><span id="a9aa" class="lt lu in ls b gy ny nv l nw nx">function summarize(accumulator, number) {<br/>  return accumulator + number;<br/>}</span><span id="bd73" class="lt lu in ls b gy ny nv l nw nx">const sum = numbers.reduce(summarize, 0);</span><span id="f4d2" class="lt lu in ls b gy ny nv l nw nx">console.log(sum);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/2d16ba58bca168a66b7dfc9181508d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MirDcI578CCfRhAuKqbew.png"/></div></div></figure><p id="c80d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在第一步<code class="fe lp lq lr ls b">accumulator</code>用<code class="fe lp lq lr ls b">0</code>初始化。然后在每个数组项上调用<code class="fe lp lq lr ls b">summarize</code>函数，累加数字的和。</p><p id="f81b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="5795" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">如果跳过<code class="fe lp lq lr ls b">initialValue</code>参数，第一个数组项将成为初始值。</li></ul><h1 id="c341" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">4:串联</h1><h2 id="e77c" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">4.1: array.concat()方法</h2><p id="af2f" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.concat(array1[, array2, ...])</code>将一个或多个数组连接到原始数组。</p><p id="52f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们连接两个名称数组:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="082d" class="lt lu in ls b gy nu nv l nw nx">const heroes = ['Batman', 'Robin'];<br/>const villains = ['Joker', 'Bane'];</span><span id="d021" class="lt lu in ls b gy ny nv l nw nx">const everyone = heroes.concat(villains);</span><span id="212b" class="lt lu in ls b gy ny nv l nw nx">console.log(everyone);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/7c40fdd57928a301bca0fa3528bda3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5niXKbEBbNPpLB7vxLbtIg.png"/></div></div></figure><p id="41c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">heroes.concat(villains)</code>通过连接<code class="fe lp lq lr ls b">heroes</code>和<code class="fe lp lq lr ls b">villains</code>数组创建一个新数组。</p><p id="d9bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="04c5" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">创建一个新数组，而不改变原来的数组</li><li id="373d" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.concat(array1[, array2, ...])</code>接受多个数组进行连接。</li></ul><h2 id="9134" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">4.2:扩展运算符</h2><p id="8bed" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">您可以使用带有数组文字的spread运算符来连接数组:<code class="fe lp lq lr ls b">[...array1, ...array2]</code>。</p><p id="616c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们连接两个名称数组:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="3487" class="lt lu in ls b gy nu nv l nw nx">const heroes = ['Batman', 'Catwoman'];<br/>const villains = ['Joker', 'Bane'];</span><span id="2438" class="lt lu in ls b gy ny nv l nw nx">const names = [...heroes, ...villains];</span><span id="6fb2" class="lt lu in ls b gy ny nv l nw nx">console.log(names);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ok"><img src="../Images/6fc4ea39de77d58211b8f71a7d33773e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJC0o3GrBrp-Q1uhqUTL0A.png"/></div></div></figure><p id="7fad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">[...heroes, ...villains]</code>展开<code class="fe lp lq lr ls b">heroes</code>和<code class="fe lp lq lr ls b">villains</code>项，然后创建一个包含所有展开项的新数组。</p><ul class=""><li id="d223" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">使用spread运算符，您可以连接任意数量的数组。</li></ul><h1 id="fa3c" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">5:切片</h1><h2 id="ffcf" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">5.1: array.slice()方法</h2><p id="08b9" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.slice([fromIndex[, toIndex]])</code>返回从<code class="fe lp lq lr ls b">fromIndex</code>开始到<code class="fe lp lq lr ls b">toIndex</code>结束的数组切片(不包括<code class="fe lp lq lr ls b">toIndex</code>本身)。<code class="fe lp lq lr ls b">fromIndex</code>可选参数默认为<code class="fe lp lq lr ls b">0</code>，<code class="fe lp lq lr ls b">toIndex</code>可选参数默认为<code class="fe lp lq lr ls b">array.length</code>。</p><p id="a031" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们来看一些数组切片:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="1b47" class="lt lu in ls b gy nu nv l nw nx">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="c2f7" class="lt lu in ls b gy ny nv l nw nx">const heroes = names.slice(0, 2);<br/>const villains = names.slice(2);</span><span id="a2f6" class="lt lu in ls b gy ny nv l nw nx">console.log(heroes);<br/>console.log(villains);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ol"><img src="../Images/75e4e50e7a4676e57432bbed0228cf69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlhBXFfr34sOpurSqTW3oA.png"/></div></div></figure><p id="e471" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">names.slice(0, 2)</code>从<code class="fe lp lq lr ls b">names</code>数组返回2个项目的切片。</p><p id="4a9d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">names.slice(2)</code>返回2个项目的切片。<code class="fe lp lq lr ls b">end</code>参数默认为<code class="fe lp lq lr ls b">names.length</code>。</p><p id="572d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="1687" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">创建一个新数组，而不改变原来的数组。</li></ul><h1 id="8515" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">6:克隆</h1><h2 id="fd94" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">6.1:扩展运算符</h2><p id="1c06" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">克隆数组的一个简单方法是使用spread操作符:<code class="fe lp lq lr ls b">const clone = [...array]</code>；</p><p id="b5fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们克隆一个数组<code class="fe lp lq lr ls b">colors</code>:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="74ca" class="lt lu in ls b gy nu nv l nw nx">const colors = ['white', 'black', 'gray'];</span><span id="3fc7" class="lt lu in ls b gy ny nv l nw nx">const clone = [...colors];</span><span id="cbc2" class="lt lu in ls b gy ny nv l nw nx">console.log(clone); <br/>console.log(colors === clone);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi om"><img src="../Images/f4076b374f6fc5a9e87ef6dbe5f041a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoC3CqAn65In4f1c1BagRQ.png"/></div></div></figure><p id="3271" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">[...colors]</code>创建一个<code class="fe lp lq lr ls b">colors</code>数组的克隆。</p><p id="6edf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="2bd7" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">创建一个浅拷贝。</li></ul><h2 id="f0f6" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">6.2: array.concat()方法</h2><p id="4e58" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">[].concat(array)</code>是关于如何克隆<code class="fe lp lq lr ls b">array</code>的另一种方法。</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="ebe8" class="lt lu in ls b gy nu nv l nw nx">const colors = ['white', 'black', 'gray'];</span><span id="76b2" class="lt lu in ls b gy ny nv l nw nx">const clone = [].concat(colors);</span><span id="76ac" class="lt lu in ls b gy ny nv l nw nx">console.log(clone); <br/>console.log(colors === clone);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi on"><img src="../Images/7c404b3338483b5d1f82bad3ec3af733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5VYBuBJtlBNkRwSQJnSMQ.png"/></div></div></figure><p id="ef67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">[].concat(colors)</code>创建<code class="fe lp lq lr ls b">colors</code>数组的克隆。</p><p id="711a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="84e6" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">创建一个浅拷贝。</li></ul><h2 id="a2e1" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">6.3: array.slice()方法</h2><p id="dd87" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.slice()</code>是关于如何克隆<code class="fe lp lq lr ls b">array</code>的另一种方法。</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="fd48" class="lt lu in ls b gy nu nv l nw nx">const colors = ['white', 'black', 'gray'];</span><span id="fd2a" class="lt lu in ls b gy ny nv l nw nx">const clone = colors.slice();</span><span id="d1b6" class="lt lu in ls b gy ny nv l nw nx">console.log(clone); <br/>console.log(colors === clone);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oo"><img src="../Images/d4f98903c88e232adf8f62df806c923b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r8at3lpQJmGq_K4VJ7W08w.png"/></div></div></figure><p id="96fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">colors.slice()</code>创建一个<code class="fe lp lq lr ls b">colors</code>数组的克隆。</p><p id="9cef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="1d3c" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">colors.slice()</code>创建一个肤浅的副本。</li></ul><h1 id="60e2" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">7:搜索</h1><h2 id="0cce" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">7.1: array.includes()方法</h2><p id="6d60" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.includes(itemToSearch[, fromIndex])</code>返回一个布尔值<code class="fe lp lq lr ls b">array</code>是否包含<code class="fe lp lq lr ls b">itemToSearch</code>。可选参数<code class="fe lp lq lr ls b">fromIndex</code>，默认为<code class="fe lp lq lr ls b">0</code>，指示开始搜索的索引。</p><p id="8011" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们确定<code class="fe lp lq lr ls b">2</code>和<code class="fe lp lq lr ls b">99</code>是否存在于数字数组中:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="6959" class="lt lu in ls b gy nu nv l nw nx">const numbers = [1, 2, 3, 4, 5];</span><span id="c8b6" class="lt lu in ls b gy ny nv l nw nx">numbers.includes(2);<br/>numbers.includes(99);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi op"><img src="../Images/3cbff0f3f7b7f65bc1ed2b448cc271cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgYM41-Kw_tajA3Dh1Y5hA.png"/></div></div></figure><p id="b637" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">numbers.includes(2)</code>返回<code class="fe lp lq lr ls b">true</code>，因为<code class="fe lp lq lr ls b">2</code>存在于<code class="fe lp lq lr ls b">numbers</code>数组中。</p><p id="211e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而<code class="fe lp lq lr ls b">numbers.includes(99)</code>是<code class="fe lp lq lr ls b">false</code>，因为<code class="fe lp lq lr ls b">numbers</code>不包含<code class="fe lp lq lr ls b">99</code>。</p><h2 id="b3bf" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">7.2: array.find()方法</h2><p id="c230" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.find(predicate)</code>方法返回满足<code class="fe lp lq lr ls b">predicate</code>函数的第一个数组项。</p><p id="8890" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每一次迭代中，调用函数的参数是:迭代项、索引和数组本身。</p><p id="fb17" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，让我们找到第一个偶数:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="c92b" class="lt lu in ls b gy nu nv l nw nx">const numbers = [1, 2, 3, 4, 5];</span><span id="a74b" class="lt lu in ls b gy ny nv l nw nx">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="c5a6" class="lt lu in ls b gy ny nv l nw nx">const evenNumber = numbers.find(isEven);</span><span id="f862" class="lt lu in ls b gy ny nv l nw nx">console.log(evenNumber);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oq"><img src="../Images/2b4e544dca64e5cc2dd660e634fa9f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEvurA5BV-D0N7xTGyrlkw.png"/></div></div></figure><p id="92e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">numbers.find(isEven)</code>返回<code class="fe lp lq lr ls b">numbers</code>内的第一个偶数，即<code class="fe lp lq lr ls b">2</code>。</p><p id="d44c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="aa18" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">如果没有项目满足谓词，则<code class="fe lp lq lr ls b">array.find()</code>返回<code class="fe lp lq lr ls b">undefined</code>。</li></ul><h2 id="fcea" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">7.3: array.indexOf()方法</h2><p id="e96e" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.indexOf(itemToSearch[, fromIndex])</code>返回<code class="fe lp lq lr ls b">array</code>中第一次出现<code class="fe lp lq lr ls b">itemToSearch</code>的索引。可选参数<code class="fe lp lq lr ls b">fromIndex</code>，默认为<code class="fe lp lq lr ls b">0</code>，是开始搜索的索引。</p><p id="5abc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们找到<code class="fe lp lq lr ls b">'Joker'</code>的索引:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="a7aa" class="lt lu in ls b gy nu nv l nw nx">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="9119" class="lt lu in ls b gy ny nv l nw nx">const index = names.indexOf('Joker');</span><span id="dd7c" class="lt lu in ls b gy ny nv l nw nx">console.log(index);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi or"><img src="../Images/0dcc81b798b7b3852da41bab42509e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NMWW8cU7g16PeNFX92_Vw.png"/></div></div></figure><p id="5573" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">names</code>内<code class="fe lp lq lr ls b">'Joker'</code>的索引为<code class="fe lp lq lr ls b">2</code>。</p><p id="5696" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="7fcd" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.indexOf(itemToSearch)</code>如果没有找到物品，返回<code class="fe lp lq lr ls b">-1</code></li><li id="d2a7" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.findIndex(predicate)</code>是使用谓词函数查找索引的替代方法。</li></ul><h1 id="2c87" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">8:查询</h1><h2 id="8b55" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">8.1: array.every()方法</h2><p id="a6ab" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">如果每一项都通过了<code class="fe lp lq lr ls b">predicate</code>检查，则<code class="fe lp lq lr ls b">array.every(predicate)</code>方法返回<code class="fe lp lq lr ls b">true</code>。</p><p id="d76a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每次迭代<code class="fe lp lq lr ls b">predicate(item[, index[, array]])</code>中，谓词函数通过参数调用:迭代项、索引和数组本身。</p><p id="731f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们确定数组<code class="fe lp lq lr ls b">evens</code>和<code class="fe lp lq lr ls b">mix</code>是否只包含偶数:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="2fa7" class="lt lu in ls b gy nu nv l nw nx">const evens = [0, 2, 4, 6];<br/>const numbers = [0, 1, 4, 6];</span><span id="237b" class="lt lu in ls b gy ny nv l nw nx">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="ff2b" class="lt lu in ls b gy ny nv l nw nx">evens.every(isEven);<br/>numbers.every(isEven);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi os"><img src="../Images/0e3e90690ae886645afcf6945e61f47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gUFULn6xgh_P5NGub27KQ.png"/></div></div></figure><p id="f254" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">evens.every(isEven)</code>之所以是<code class="fe lp lq lr ls b">true</code>是因为<code class="fe lp lq lr ls b">evens</code>中的<em class="ot">都是偶数。</em></p><p id="a02d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，<code class="fe lp lq lr ls b">numbers.every(isEven)</code>评估为<code class="fe lp lq lr ls b">false</code>，因为<code class="fe lp lq lr ls b">numbers</code>包含奇数<code class="fe lp lq lr ls b">1</code>。</p><h2 id="ba03" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">8.2: array.some()方法</h2><p id="fe62" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">如果至少有一个项目通过了<code class="fe lp lq lr ls b">predicate</code>检查，则<code class="fe lp lq lr ls b">array.some(predicate)</code>方法返回<code class="fe lp lq lr ls b">true</code>。<br/>在每次迭代中<code class="fe lp lq lr ls b">predicate(item[, index[, array]])</code>函数被参数调用:迭代项、索引和数组本身。</p><p id="5a7f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们确定数组是否包含至少一个偶数:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="a3c2" class="lt lu in ls b gy nu nv l nw nx">const numbers = [1, 5, 7, 10];<br/>const odds = [1, 3, 3, 3];</span><span id="4acf" class="lt lu in ls b gy ny nv l nw nx">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="0c96" class="lt lu in ls b gy ny nv l nw nx">numbers.some(isEven); // =&gt; true<br/>odds.some(isEven);   // =&gt; false</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ou"><img src="../Images/1ed0810f07e3cbac67d2bca0d3e3554d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGvLYykajnuKFh43pC70Cw.png"/></div></div></figure><p id="4cf3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">numbers.some(isEven)</code>是<code class="fe lp lq lr ls b">true</code>，因为<code class="fe lp lq lr ls b">numbers</code>中至少存在一个偶数<code class="fe lp lq lr ls b">10</code>。</p><p id="b770" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是<code class="fe lp lq lr ls b">odds.some(isEven)</code>是<code class="fe lp lq lr ls b">false</code>，因为<code class="fe lp lq lr ls b">odds</code>只包含奇数。</p><h1 id="aeb1" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">9:过滤器</h1><h2 id="4ae9" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">9.1: array.filter()</h2><p id="cfb3" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.filter(predicate)</code>方法返回一个包含通过<code class="fe lp lq lr ls b">predicate</code>检查的项目的新数组。</p><p id="c023" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在每一次迭代中，函数被参数调用:迭代项、索引和数组本身。</p><p id="d11d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们过滤一个只有偶数的数组:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="59fb" class="lt lu in ls b gy nu nv l nw nx">const numbers = [1, 5, 7, 10];</span><span id="ee7a" class="lt lu in ls b gy ny nv l nw nx">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="36d4" class="lt lu in ls b gy ny nv l nw nx">const evens = numbers.filter(isEven);</span><span id="3c25" class="lt lu in ls b gy ny nv l nw nx">evens; // =&gt; [10]</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/48eb047a37c4e691e952e6d96763cbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCEIgCgZPnfAzOANs-Ft1g.png"/></div></div></figure><p id="451c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">numbers.filter(isEven)</code>通过过滤<code class="fe lp lq lr ls b">numbers</code>创建一个新的数组<code class="fe lp lq lr ls b">evens</code>，使其只包含偶数。</p><p id="4630" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="afe0" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated">创建一个新数组，而不改变原来的数组。</li></ul><h1 id="2fbe" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">10:插入</h1><h2 id="0750" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">10.1: array.push()方法</h2><p id="c22d" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.push(item1[..., itemN])</code>方法将一个或多个项追加到数组的末尾，返回新的长度。</p><p id="ffd2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们将<code class="fe lp lq lr ls b">'Joker'</code>追加到<code class="fe lp lq lr ls b">names</code>数组的末尾:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="9897" class="lt lu in ls b gy nu nv l nw nx">const names = ['Batman'];</span><span id="918e" class="lt lu in ls b gy ny nv l nw nx">names.push('Joker');</span><span id="e7ce" class="lt lu in ls b gy ny nv l nw nx">names; // ['Batman', 'Joker']</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/09776e6d9014c5f49679f8e5a59203eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeIJTgmHH0R0ViyevcBDJg.png"/></div></div></figure><p id="9e75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">names.push('Joker')</code>在<code class="fe lp lq lr ls b">names</code>数组的末尾插入一个新项目<code class="fe lp lq lr ls b">'Joker'</code>。</p><p id="60fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="c3a3" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.push()</code>原地变异阵列</li><li id="f4b5" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.push(item1, item2, ..., itemN)</code>可以推送多个项目。</li></ul><h2 id="8710" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">10.2: array.unshift()方法</h2><p id="c7c6" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">方法将一个或多个项目追加到数组的开头，返回数组的新长度。</p><p id="84e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们在<code class="fe lp lq lr ls b">names</code>数组的开头追加<code class="fe lp lq lr ls b">'Catwoman'</code>:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="179b" class="lt lu in ls b gy nu nv l nw nx">const names = ['Batman'];</span><span id="f6b1" class="lt lu in ls b gy ny nv l nw nx">names.unshift('Catwoman');</span><span id="7e43" class="lt lu in ls b gy ny nv l nw nx">names; // ['Catwoman', 'Batman']</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/6b9d61c72a3003da0ee4cce63451aded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LXdVpyrz7weDp-UTF7ihQ.png"/></div></div></figure><p id="95be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">names.unshift('Catwoman')</code>在<code class="fe lp lq lr ls b">names</code>数组的开头插入一个新项目<code class="fe lp lq lr ls b">'Catwoman'</code>。</p><p id="7418" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="82a9" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.unshift()</code>就地变异数组。</li><li id="fdc4" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.unshift(item1, item2, ..., itemN)</code>可以插入多个项目。</li></ul><h2 id="79f6" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">10.3:扩展运算符</h2><p id="999c" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">通过将spread运算符与数组文字相结合，可以以不可变的方式在数组中插入项。</p><p id="c3c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在数组的<em class="ot">末端追加一个项目:</em></p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="10cb" class="lt lu in ls b gy nu nv l nw nx">const names = ['Joker', 'Bane'];</span><span id="f552" class="lt lu in ls b gy ny nv l nw nx">const names2 = [<br/>  ...names,<br/>  'Batman',<br/>];</span><span id="5055" class="lt lu in ls b gy ny nv l nw nx">names2; // =&gt; ['Joker', 'Bane', 'Batman'];</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/8349f7b4cbb32985bbfc3bfdfbf46dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzEpw4JgyDg0ml8uvwQI2A.png"/></div></div></figure><p id="0e3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在数组的<em class="ot">开头追加一个项目:</em></p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="c018" class="lt lu in ls b gy nu nv l nw nx">const names = ['Joker', 'Bane'];</span><span id="84e2" class="lt lu in ls b gy ny nv l nw nx">const names2 = [<br/>  'Batman',<br/>  ...names<br/>];</span><span id="3eb6" class="lt lu in ls b gy ny nv l nw nx">names2; // =&gt; ['Batman', 'Joker', 'Bane'];</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/8349f7b4cbb32985bbfc3bfdfbf46dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzEpw4JgyDg0ml8uvwQI2A.png"/></div></div></figure><p id="9b74" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在任一索引处插入一个项目<em class="ot">:</em></p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="8f92" class="lt lu in ls b gy nu nv l nw nx">const names = ['Joker', 'Bane'];<br/>const indexToInsert = 1;</span><span id="3f27" class="lt lu in ls b gy ny nv l nw nx">const names2 = [<br/>  ...names.slice(0, indexToInsert),<br/>  'Batman',<br/>  ...names.slice(indexToInsert)<br/>];</span><span id="5eec" class="lt lu in ls b gy ny nv l nw nx">names2; // =&gt; ['Joker', 'Batman', 'Bane'];</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oz"><img src="../Images/b6ae435f1f1ec8051e096d8f8239c5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nop86N6o5pLwRQqU2X0L-w.png"/></div></div></figure><h1 id="e1e1" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">11:移除</h1><h2 id="b062" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">11.1: array.pop()方法</h2><p id="288e" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.pop()</code>方法从数组中移除最后一项，然后返回该项。</p><p id="ad83" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，让我们删除<code class="fe lp lq lr ls b">colors</code>数组的最后一个元素:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="3a0c" class="lt lu in ls b gy nu nv l nw nx">const colors = ['blue', 'green', 'black'];</span><span id="3d1b" class="lt lu in ls b gy ny nv l nw nx">const lastColor = colors.pop();</span><span id="145c" class="lt lu in ls b gy ny nv l nw nx">console.log(lastColor);<br/>console.log(colors);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/b98cc0e722020cf7e25b9266fe718007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWfgorn1_sFM7DJSsEq6-A.png"/></div></div></figure><p id="4617" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">colors.pop()</code>删除<code class="fe lp lq lr ls b">colors</code>的最后一个元素并返回。</p><p id="ce78" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="aab9" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.pop()</code>就地变异数组。</li></ul><h2 id="2690" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">11.2: array.shift()方法</h2><p id="4b07" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.shift()</code>方法从数组中移除第一项，然后返回该项。</p><p id="de11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，让我们删除<code class="fe lp lq lr ls b">colors</code>数组的第一个元素:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="0378" class="lt lu in ls b gy nu nv l nw nx">const colors = ['blue', 'green', 'black'];</span><span id="268d" class="lt lu in ls b gy ny nv l nw nx">const firstColor = colors.shift();</span><span id="ee96" class="lt lu in ls b gy ny nv l nw nx">console.log(firstColor);<br/>console.log(colors);</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pa"><img src="../Images/6f5297c2686862feada7d8d974d52007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lk5sJBqrK_Zm_LRsN1tT0w.png"/></div></div></figure><p id="75dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">colors.shift()</code>删除<code class="fe lp lq lr ls b">colors</code>的第一个元素<code class="fe lp lq lr ls b">'blue'</code>并返回。</p><p id="7cf7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="fbe5" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.shift()</code>原地变异阵列</li><li id="577d" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.shift()</code>具有O(n)复杂度。</li></ul><h2 id="bbaa" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">11.3: array.splice()方法</h2><p id="e449" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">从数组中删除项目，并插入新项目。</p><p id="1505" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，让我们从索引<code class="fe lp lq lr ls b">1</code>中删除2项:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="aa4b" class="lt lu in ls b gy nu nv l nw nx">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="85bf" class="lt lu in ls b gy ny nv l nw nx">names.splice(1, 2);</span><span id="4864" class="lt lu in ls b gy ny nv l nw nx">names; // =&gt; ['Batman', 'Bane']</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pb"><img src="../Images/f77dac45bb7c280bfb86b735c3049950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ysm63DQD43ChE-SR_RV1uQ.png"/></div></div></figure><p id="fef7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">names.splice(1, 2)</code>删除<code class="fe lp lq lr ls b">'Catwoman'</code>和<code class="fe lp lq lr ls b">'Joker'</code>元素。</p><p id="b809" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">names.splice()</code>可以插入新的项目来代替已删除的项目。让我们替换索引<code class="fe lp lq lr ls b">1</code>中的2个项目，并插入一个新项目<code class="fe lp lq lr ls b">'Alfred'</code>:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="dba1" class="lt lu in ls b gy nu nv l nw nx">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="fc49" class="lt lu in ls b gy ny nv l nw nx">names.splice(1, 2, 'Alfred');</span><span id="3217" class="lt lu in ls b gy ny nv l nw nx">names; // =&gt; ['Batman', 'Alfred' ,'Bane']</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pc"><img src="../Images/a0e9634c3b61dbdb63e590408fb1766a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTcO7LRSSrU7GJQmtwi3Kg.png"/></div></div></figure><p id="55df" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="8ca4" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.splice()</code>就地变异阵列。</li></ul><h2 id="863c" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">11.4:扩展运算符</h2><p id="4421" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">通过将spread运算符与数组文字相结合，可以以不可变的方式从数组中移除项。</p><p id="0b9d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们删除一些项目:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="6a00" class="lt lu in ls b gy nu nv l nw nx">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];<br/>const fromIndex = 1;<br/>const removeCount = 2;</span><span id="bb81" class="lt lu in ls b gy ny nv l nw nx">const newNames = [<br/>  ...names.slice(0, fromIndex),<br/>  ...names.slice(fromIndex + removeCount)<br/>];</span><span id="d0f3" class="lt lu in ls b gy ny nv l nw nx">newNames; // =&gt; ['Batman', 'Bane']</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pd"><img src="../Images/c5489dabe647800df03234231e11759b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5OwBKjnwFdwd5-OfcMIRHg.png"/></div></div></figure><p id="da70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">newNames</code>包含<code class="fe lp lq lr ls b">names</code>的项目，但没有被删除的2个。</p><h1 id="1024" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">12:空</h1><h2 id="7146" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">12.1:数组长度属性</h2><p id="db7e" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.length</code>是保存数组长度的属性。不止如此，<code class="fe lp lq lr ls b">array.length</code>是可写的。</p><p id="02db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你写一个小于当前长度的<code class="fe lp lq lr ls b">array.length = newLength</code>，多余的元素将从数组中移除。</p><p id="0984" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们使用<code class="fe lp lq lr ls b">array.length = 0</code>来移除数组中的所有元素:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="58a4" class="lt lu in ls b gy nu nv l nw nx">const colors = ['blue', 'green', 'black'];</span><span id="0108" class="lt lu in ls b gy ny nv l nw nx">colors.length = 0;</span><span id="f54e" class="lt lu in ls b gy ny nv l nw nx">colors; // []</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pe"><img src="../Images/863028beee85d256194c62e507c62876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czRUtatwgccJG9eO8E7PBA.png"/></div></div></figure><p id="c8d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">colors.length = 0</code>从<code class="fe lp lq lr ls b">colors</code>数组中删除所有项目。</p><h2 id="6fcd" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">12.2: array.splice()方法</h2><p id="8201" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.splice(fromIndex[, removeCount[, item1[, item2[, ...]]]])</code>从数组中删除项目并插入新项目。</p><p id="9349" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果省略了<code class="fe lp lq lr ls b">removeCount</code>参数，那么<code class="fe lp lq lr ls b">array.splice()</code>将删除从<code class="fe lp lq lr ls b">fromIndex</code>开始的数组的所有元素。</p><p id="5878" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用它来删除数组中的所有元素:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="efbc" class="lt lu in ls b gy nu nv l nw nx">const colors = ['blue', 'green', 'black'];</span><span id="f7eb" class="lt lu in ls b gy ny nv l nw nx">colors.splice(0);</span><span id="f16c" class="lt lu in ls b gy ny nv l nw nx">colors; // []</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pf"><img src="../Images/60b2cf92601da640ed025a9f6f9da421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERoUDDz2SgK9y86XHYPZag.png"/></div></div></figure><p id="4cba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">colors.splice(0)</code>删除<code class="fe lp lq lr ls b">colors</code>数组的所有元素。</p><h1 id="1094" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">13:填充</h1><h2 id="11fe" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">13.1: array.fill()方法</h2><p id="b5a5" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.fill(value[, fromIndex[, toIndex]])</code>用<code class="fe lp lq lr ls b">value</code>填充数组，从<code class="fe lp lq lr ls b">fromIndex</code>开始直到<code class="fe lp lq lr ls b">toIndex</code>(不包括<code class="fe lp lq lr ls b">toIndex</code>本身)。<code class="fe lp lq lr ls b">fromIndex</code>可选参数默认为<code class="fe lp lq lr ls b">0</code>，<code class="fe lp lq lr ls b">toIndex</code>可选参数默认为<code class="fe lp lq lr ls b">array.length</code>。</p><p id="5280" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，让我们用零值填充一个数组:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="c085" class="lt lu in ls b gy nu nv l nw nx">const numbers = [1, 2, 3, 4];</span><span id="94be" class="lt lu in ls b gy ny nv l nw nx">numbers.fill(0);</span><span id="888a" class="lt lu in ls b gy ny nv l nw nx">numbers; // =&gt; [0, 0, 0, 0]</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pg"><img src="../Images/6953f25657c07bef5fe7937ea7cc980d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k822kbiRP7xFsyZ_tqz80A.png"/></div></div></figure><p id="ebff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用零填充数组。</p><p id="079e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不仅如此，您还可以使用<code class="fe lp lq lr ls b">Array(length).fill(initial)</code>初始化特定长度和初始值的数组:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="5112" class="lt lu in ls b gy nu nv l nw nx">const length = 3;<br/>const zeros = Array(length).fill(0);</span><span id="5ca3" class="lt lu in ls b gy ny nv l nw nx">zeros; // [0, 0, 0]</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ph"><img src="../Images/db3f78cb4a285c247b253c7819be7de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hysgP6bKDngGLjPYfXlx1g.png"/></div></div></figure><p id="8f0d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">创建一个由3个零组成的数组。</p><p id="3a21" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">小贴士:</p><ul class=""><li id="4a77" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.fill()</code>原地变异阵列。</li></ul><h2 id="0fe0" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">13.2: Array.from()函数</h2><p id="2caa" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">Array.from()</code>用对象初始化一定长度的数组非常有用:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="385d" class="lt lu in ls b gy nu nv l nw nx">const length = 4;<br/>const emptyObjects = Array.from(Array(length), function() {<br/>  return {};<br/>});</span><span id="ffd5" class="lt lu in ls b gy ny nv l nw nx">emptyObjects; // [{}, {}, {}, {}]</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pi"><img src="../Images/365555baafbd1b1ba3ab4445b649dd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OV6mrdAg84auT00Xo7jOQ.png"/></div></div></figure><p id="5ad3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">emptyObjects</code>是用空对象的不同实例初始化的数组。</p><h1 id="871c" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">14:拉平</h1><h2 id="4c52" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">14.1: array.flat()方法</h2><p id="92d0" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.flat([depth])</code>通过递归展开数组中的项目来创建一个新的数组，直到确定<code class="fe lp lq lr ls b">depth</code>。<code class="fe lp lq lr ls b">depth</code>可选参数默认为<code class="fe lp lq lr ls b">1</code>。</p><p id="220c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们展平一组数组:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="2396" class="lt lu in ls b gy nu nv l nw nx">const arrays = [0, [1, 3, 5], [2, 4, 6]];</span><span id="62a2" class="lt lu in ls b gy ny nv l nw nx">const flatArray = arrays.flat();</span><span id="4138" class="lt lu in ls b gy ny nv l nw nx">flatArray; // [0, 1, 3, 5, 2, 4, 6]</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pj"><img src="../Images/95ad756f34005049f02568119f99ef3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrofW2gcuFhBRVjQ5di8hQ.png"/></div></div></figure><p id="d235" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">arrays</code>包含数字和数字数组的混合。<code class="fe lp lq lr ls b">arrays.flat()</code>平铺数组，使其只包含数字。</p><p id="0900" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">提示:</p><ul class=""><li id="2c72" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.flat()</code>创建新数组，不改变原数组。</li></ul><h1 id="1239" class="nc lu in bd lv nd ne nf ly ng nh ni mb jt nj ju me jw nk jx mh jz nl ka mk nm bi translated">15:排序</h1><h2 id="a800" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">15.1: array.sort()方法</h2><p id="4432" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated"><code class="fe lp lq lr ls b">array.sort([compare])</code>方法对数组中的项目进行排序。当省略compare函数时，该方法将项目转换为字符串，然后按UTF-16代码单位值升序排列。</p><p id="a705" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可选参数<code class="fe lp lq lr ls b">compare(item1, item2)</code>是一个定制项目顺序的回调函数。如果<code class="fe lp lq lr ls b">compare(item1, item2)</code>返回:</p><ul class=""><li id="28d4" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">-1</code>则<code class="fe lp lq lr ls b">item1</code>将跟随在<code class="fe lp lq lr ls b">item2</code>之后</li><li id="592b" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">1</code>则<code class="fe lp lq lr ls b">item2</code>将跟随在<code class="fe lp lq lr ls b">item1</code>之后</li><li id="4faa" class="mm mn in kv b kw mx kz my lc mz lg na lk nb lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">0</code>则项目的位置不变</li></ul><p id="eef2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们对一系列字母进行排序:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="5292" class="lt lu in ls b gy nu nv l nw nx">const letters = ['B', 'C', 'A'];</span><span id="9244" class="lt lu in ls b gy ny nv l nw nx">letters.sort();</span><span id="168b" class="lt lu in ls b gy ny nv l nw nx">letters; // =&gt; ['A', 'B', 'C']</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pk"><img src="../Images/8b2b5a657c486abc269feb02a1b0bb9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1BFRFFf5jDUdlNul1bIeA.png"/></div></div></figure><p id="c487" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">letters.sort()</code>将字母按升序排列。</p><p id="aaf3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们使用compare函数，使偶数后跟奇数:</p><pre class="kd ke kf kg gt nq ls nr ns aw nt bi"><span id="d19e" class="lt lu in ls b gy nu nv l nw nx">const numbers = [4, 3, 1, 2];</span><span id="624f" class="lt lu in ls b gy ny nv l nw nx">function compare(n1, n2) {<br/>  if (n1 % 2 === 0 &amp;&amp; n2 % 2 !== 0) {<br/>    return -1;<br/>  }<br/>  if (n1 % 2 !== 0 &amp;&amp; n2 % 2 === 0) {<br/>    return -1;<br/>  }<br/>  return 0;<br/>}</span><span id="88f2" class="lt lu in ls b gy ny nv l nw nx">numbers.sort(compare);</span><span id="f57d" class="lt lu in ls b gy ny nv l nw nx">numbers;</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pl"><img src="../Images/00798816ae195488b97aa369a2d97b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*504NEXbTaPBbQlXED7cnZg.png"/></div></div></figure><p id="08ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe lp lq lr ls b">numbers.sort(compare)</code>使用自定义比较函数，先对偶数进行排序。</p><p id="a698" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">提示:</p><ul class=""><li id="f787" class="mm mn in kv b kw kx kz la lc oa lg ob lk oc lo od mu mv mw bi translated"><code class="fe lp lq lr ls b">array.sort()</code>变异阵就位。</li></ul><h2 id="e1ef" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated"><strong class="ak">简明英语团队备注</strong></h2><p id="f14f" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc nn le lf lg no li lj lk np lm ln lo ig bi translated">你知道我们有四种出版物吗？给他们一句话来表达爱意:JavaScript简单明了 、<a class="ae ks" href="https://medium.com/ai-in-plain-english" rel="noopener">、<strong class="kv io"> AI简单明了</strong>、</a>、<a class="ae ks" href="https://medium.com/ux-in-plain-english" rel="noopener">、<strong class="kv io"> UX简单明了</strong>、</a>、<a class="ae ks" href="https://medium.com/python-in-plain-english" rel="noopener">、<strong class="kv io"> Python简单明了</strong>、</a>、<strong class="kv io">、</strong>——谢谢你，继续学习吧！</p><p id="ebf3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ks" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">submissions @ plain English . io</strong></a><strong class="kv io"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>