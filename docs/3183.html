<html>
<head>
<title>Increase Node.js Performance with Libuv Thread Pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Libuv线程池提高Node.js性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/increase-node-js-performance-with-libuv-thread-pool-ac893b7a748e?source=collection_archive---------7-----------------------#2020-09-07">https://javascript.plainenglish.io/increase-node-js-performance-with-libuv-thread-pool-ac893b7a748e?source=collection_archive---------7-----------------------#2020-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/993a9f587a4d89b0149dca9fc0ed6769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0h1UgE-NDblN4BOzveU4Q.jpeg"/></div></div></figure><p id="9643" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的“<a class="ae kw" href="https://www.youtube.com/watch?v=ol56smloW2Q&amp;list=PLISqeoHsXJYAIfu4-mgNY0tloWz2uut1t" rel="noopener ugc nofollow" target="_blank"> Node.js性能优化</a>”系列的第5部分中，我将向您展示如何通过线程池管理来提高<a class="ae kw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的性能。我们通过理解<a class="ae kw" href="https://libuv.org/" rel="noopener ugc nofollow" target="_blank"> Libuv </a>如何工作、线程池如何工作以及如何根据您的机器规格配置线程数量来实现这一点。</p><p id="9131" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您是一名Node.js开发人员，还不熟悉Node.js的内部工作方式吗？如果是这样的话，您可能正在使用自安装Node.js以来就存在的一些默认配置来部署生产应用程序。在本文中，我将介绍一种鲜为人知的配置，它很可能会使您的应用程序的一些操作的性能翻倍。这将取决于许多因素，但很有可能这对很多人来说都是一个胜利。</p><h1 id="d7ba" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在YouTube上观看视频</h1><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="367f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Node.js运行时环境</h1><p id="4b03" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">Node.js运行时环境由几个移动部分组成。我们都应该熟悉<a class="ae kw" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> Google V8引擎</a>，它负责执行我们的<a class="ae kw" href="https://javascript.info/" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>逻辑。然而，有一个不太为人所知的库叫做<a class="ae kw" href="https://libuv.org/" rel="noopener ugc nofollow" target="_blank"> Libuv </a>，它负责管理异步I/O操作。</p><p id="a3b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些I/O操作也被称为与操作系统相关的“重型任务”。文件和文件夹管理、TCP/UDP事务、压缩、加密等任务。是通过Libuv处理的。</p><p id="2280" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，虽然这些操作中的大多数在设计上是异步的，但也有一些是同步的，如果处理不当，可能会导致我们的应用程序被阻塞。正是由于这个原因，Libuv拥有了所谓的“线程池”。</p><h1 id="91fc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Libuv线程池</h1><p id="faad" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">Libuv启动一个由4个线程组成的线程池，用于将同步操作卸载到。这样做，Libuv确保我们的应用程序不会被同步任务不必要地阻塞。</p><p id="7ec3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们将利用一个设置来更好地适应我们的计算机或我们的应用程序将部署到的虚拟机的规格。这是因为我们可以将4个线程的默认值更改为最多1024个线程。我们通过设置<a class="ae kw" href="https://nodejs.org/api/cli.html#cli_uv_threadpool_size_size" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">UV _ thread pool _ SIZE</strong></a>节点变量来实现这一点。</p><h1 id="e583" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">物理与逻辑CPU内核</h1><p id="a643" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">为了更好地理解将UV_THREADPOOL_SIZE设置为什么，我们需要首先了解我们的机器正在运行多少个逻辑内核。如果我们以我的MacBook Pro为例，它运行6个物理CPU内核(英特尔)。</p><p id="16fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，这些内核具有超线程功能，这意味着每个内核可以同时运行2个操作。因此，我们将1个支持超线程的物理内核视为2个逻辑内核。在我的情况下，我的MacBook Pro运行12个逻辑核心。</p><h1 id="b594" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何提高节点JS性能</h1><p id="e56b" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">建议将<strong class="ka ir"> UV_THREADPOOL_SIZE </strong>设置为您的机器正在运行的逻辑核心数。在我的例子中，我将线程池大小设置为12。</p><p id="9ecd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将大小设置为超过硬件运行的逻辑核心是没有意义的，实际上可能会导致更差的性能。</p><h1 id="408d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何检查逻辑核心</h1><p id="b4f9" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">当涉及到部署时，您最不想做的事情就是手动设置<strong class="ka ir"> UV_THREADPOOL_SIZE </strong>，因为您的应用程序可能会在具有不同机器规格的多个环境中运行。因此，我们需要一种在相关环境中启动应用程序时动态设置线程池大小的方法。</p><p id="ba78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好消息是这很简单，但是必须小心处理。为此，将以下代码添加到节点应用程序的根JS文件的顶部:</p><pre class="lv lw lx ly gt mg mh mi mj aw mk bi"><span id="451c" class="ml ky iq mh b gy mm mn l mo mp">const OS = require('os')<br/>process.env.UV_THREADPOOL_SIZE = OS.cpus().length</span></pre><p id="42d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://nodejs.org/api/os.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> OS </strong> </a>模块是Node JS原生的。它有一个函数<a class="ae kw" href="https://nodejs.org/api/os.html#os_os_cpus" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">CPU()</strong></a>，返回你的机器正在运行的逻辑核心的总量。更好的是，如果您的cpu内核没有超线程，这个函数将返回物理CPU内核的数量，这是完美的。</p><h1 id="e2e3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="5683" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我相信这篇文章证明是有价值的。我建议观看嵌入式视频，并在GitHub上查看我的<a class="ae kw" href="https://github.com/bleedingcode/nodejs-performance-optimizations" rel="noopener ugc nofollow" target="_blank">源代码报告</a>，其中有这里提到的所有内容的代码示例。</p><p id="57f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下次见，干杯</p><p id="be7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mq">更多内容看</em> <a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mq">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>