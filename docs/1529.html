<html>
<head>
<title>Grasp RxJs: Observable vs Subject vs BehaviorSubject in UI components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抓住RxJs:UI组件中的可观察对象vs主体vs行为主体</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/grasp-rxjs-observable-vs-subject-vs-behaviorsubject-in-ui-components-d34b95761814?source=collection_archive---------7-----------------------#2020-03-27">https://javascript.plainenglish.io/grasp-rxjs-observable-vs-subject-vs-behaviorsubject-in-ui-components-d34b95761814?source=collection_archive---------7-----------------------#2020-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/25c483947c2db8a27a6a5574c02ee57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QqD-xMJWq7g75peu"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@blakeweyland?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Blake Weyland</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4aec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当习惯于RxJs时，理解使用哪种风格的Observable有时会有点棘手。今天我们将专注于UI组件，以及你应该为哪种行为使用哪种风格。</p><p id="ebe2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，虽然还有其他风格的observable，如RelaySubject、AsyncSubject和ReplaySubject，但我发现Observable、Subject和BehaviorSubject几乎构成了UI组件中使用的所有可观察流，所以我将重点介绍这三种。</p><p id="5f90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们先简单介绍一下每种类型。因为我们在这里着眼于实际应用，所以我们不会深入研究它们是如何工作的。已经有许多文章深入解释了它们的行为。</p><h1 id="7aef" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍口味</h1><h2 id="3ac0" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">可观察量</h2><p id="0eb8" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">可观察类型是RxJs中可用的可观察流中最简单的一种。将它与主体及其子类型区分开来的是这样一个事实:可观察物通常是由一个创造函数创造出来的，如<code class="fe mn mo mp mq b">of</code>、<code class="fe mn mo mp mq b">range</code>、<code class="fe mn mo mp mq b">interval</code>等。或者在已经存在的可观察流上使用<code class="fe mn mo mp mq b">.pipe()</code>。虽然<code class="fe mn mo mp mq b">new Observable() </code>也是可能的，但我发现它不太常用。</p><p id="1c6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个重要的区别是，Observable不像Subject那样公开<code class="fe mn mo mp mq b">.next()</code>函数。<code class="fe mn mo mp mq b">.next()</code>允许以参数<code class="fe mn mo mp mq b">next</code>为值手动触发发射。</p><p id="13ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着开发者通常可以通过查看它的声明来看到一个可观察对象的所有可能的发射。本质上没有“隐藏的”排放，相反，只要看看它是如何产生的，就可以对整个潜在排放进行审查。</p><p id="15a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，当管道连接到对象时，通常会产生可观测量，在这种情况下，理解来源的排放并不简单，但是如果您以“假设来源排放……”开始推理，您可以通过例如查看管道中的运算符来推理给定可观测量中所有可能的排放。</p><h2 id="5602" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">科目</h2><p id="948d" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">主体扩展了可观察范围，但行为完全不同。主题是使用<code class="fe mn mo mp mq b">new Subject()</code>创建的，声明中完全没有提到它可能会或不会发出什么。如果您使用TypeScript(您希望这样做),您可以推断出发射的类型，但是没有办法通过简单地查看它的声明来推断出它将在何时以及在什么情况下发射。</p><p id="eb4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原因是受试者暴露了<code class="fe mn mo mp mq b">.next()</code>，这是一种手动推送排放的方法。这意味着您可以通过编程方式声明其排放量。这是一个非常强大的功能，同时也很容易被滥用。</p><p id="9ac7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般来说，如果您订阅了一个可观察到的，以某个东西被推给一个主题结束的。<code class="fe mn mo mp mq b">next()</code>，你可能做错了什么。通常，您只想将可观测值写成纯反应。</p><p id="71c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">受试者在创作时不持有任何排放权，并且依赖<code class="fe mn mo mp mq b">.next()</code>进行排放。因此，默认情况下，任何主题上的订阅都将异步运行。</p><h2 id="4a1c" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">行为主体</h2><p id="5174" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">行为主体是主体的另一种风格，它改变了一件(非常)重要的事情:它将最新的排放保持在内部状态变量中。与此相关的是，行为主体的两个方面与主体的行为有点不同:</p><ol class=""><li id="3a8a" class="mr ms in kc b kd ke kh ki kl mt kp mu kt mv kx mw mx my mz bi translated">当使用新的行为主体时，它在创建时需要一个初始值，这意味着内部状态变量永远不能以某种方式声明</li><li id="7e33" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">它公开了<code class="fe mn mo mp mq b">.getValue()</code>，一个同步返回内部状态变量的方法</li></ol><p id="1576" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，每当对行为主体调用<code class="fe mn mo mp mq b">.next()</code>时，它会做两件事:用输入覆盖内部保存的变量，并将该值发送给订阅者。</p><p id="f6ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这也意味着行为主体上的任何订阅都会立即以同步方式接收内部保存的变量作为发射。任何随后的发射异步进行，就像它是一个常规受试者一样。</p><p id="b72b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些都是非常显著的差异！这意味着，例如，如果您在BehaviorSubject上使用带有<code class="fe mn mo mp mq b">.take(1)</code>的订阅，当管道被激活时，您保证会有同步的反应。这也意味着您可以使用<code class="fe mn mo mp mq b">.getValue()</code>在管道和订阅之外的任何地方同步获取当前值。</p><p id="2ced" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这使得行为主体成为数据持有人的自然选择，无论是对于反应流还是更普通的javascript过程。</p><h1 id="151a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">哪种味道在什么情况下</h1><p id="db99" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">因此，基于对这些行为的理解，您应该在什么时候使用它们？</p><p id="8845" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">可观察</strong>应该用在你写纯反应的时候。这些应该只是描述当某些事件发生时你想发生什么。</p><p id="ff9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">受试者应以</strong>为信号源。对于UI组件来说尤其如此，其中一个按钮可以有一个侦听器，该侦听器只需在处理输入事件的主题上调用<code class="fe mn mo mp mq b">.next()</code>。</p><p id="4e38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">行为主题</strong>应在组件中使用内部状态时使用，用于在初始化和反应时也需要反应的数据字段。</p><p id="3a96" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">举个简单的例子，假设我们有一个同意页面，页面上有一个包含三个元素的文本框:</p><ol class=""><li id="6dd7" class="mr ms in kc b kd ke kh ki kl mt kp mu kt mv kx mw mx my mz bi translated">在用户可以访问下一页之前，必须滚动到底部的同意说明框</li><li id="e61f" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">需要用户键入<em class="nf"> yes </em>才能访问下一页的文本输入</li><li id="d1af" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx mw mx my mz bi translated">当用户无法访问下一页时，用于访问下一页的按钮应被禁用</li></ol><p id="3356" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用各种各样的可观测量来解决这个问题的一种方法如下:</p><ul class=""><li id="caee" class="mr ms in kc b kd ke kh ki kl mt kp mu kt mv kx ng mx my mz bi translated"><code class="fe mn mo mp mq b">userInput$: BehaviorSubject&lt;string&gt;</code>保存当前用户输入</li><li id="9151" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx ng mx my mz bi translated">当用户滚动到文本框底部时发出true。</li><li id="8183" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx ng mx my mz bi translated"><code class="fe mn mo mp mq b">hasGivenConsent$: Observable&lt;boolean&gt;</code>通过<code class="fe mn mo mp mq b">map</code>发送<code class="fe mn mo mp mq b">userInput$</code>，当发送值为<em class="nf">是</em>时，返回<code class="fe mn mo mp mq b">true</code>，否则返回<code class="fe mn mo mp mq b">false</code></li><li id="d5d0" class="mr ms in kc b kd na kh nb kl nc kp nd kt ne kx ng mx my mz bi translated"><code class="fe mn mo mp mq b">canProceed$: Observable&lt;boolean&gt;</code>使用<code class="fe mn mo mp mq b">hasScrolledText$</code>和<code class="fe mn mo mp mq b">hasGivenConsent$</code>上的<code class="fe mn mo mp mq b">combineLatest</code>，如果两个输入发射都是<code class="fe mn mo mp mq b">true</code>，则映射到<code class="fe mn mo mp mq b">true</code>，否则映射到<code class="fe mn mo mp mq b">false</code>。</li></ul><p id="075d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，下一页按钮的<code class="fe mn mo mp mq b">disabled</code>字段订阅与<code class="fe mn mo mp mq b">canProceed$</code>相反的内容。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="2f70" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天的文章在技术上可能没有以前的文章那么详细，老实说，更多的是我对在UI组件中使用Observables的最佳实践的看法。由于这个话题更多的是基于观点而不是事实，我很乐意看到任何对我的观点有争议的评论！</p><p id="8686" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和往常一样，保持你的成功之路！</p></div></div>    
</body>
</html>