<html>
<head>
<title>How to transfer blobs from a Chrome Extension (with Gotchas)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从Chrome扩展中传输blobs</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-transfer-blobs-from-a-chrome-extension-with-gotchas-8ed541a1a4e8?source=collection_archive---------4-----------------------#2020-07-02">https://javascript.plainenglish.io/how-to-transfer-blobs-from-a-chrome-extension-with-gotchas-8ed541a1a4e8?source=collection_archive---------4-----------------------#2020-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/61f9788380f96a1b2e9f3159d9de95fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wXzB0-WM_UolLBy76Us7g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Passing blobs from one window to another</figcaption></figure><h2 id="a069" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">你是否曾经构建了一个chrome扩展并上传了一张照片，然后想要将数据传输到你的网站进行进一步处理？</h2><p id="5ca8" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">我做了，该死的，花了一段时间才弄明白！下面是怎么做的。在这里，我将以图片上传为例进行演示。</p><h2 id="d04f" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">逮到1️了</strong></h2><p id="2957" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">设置/获取blob的iframe方法——不！那不靠谱。</p><h2 id="70aa" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">逮到2️了</strong></h2><p id="5c9c" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">一位<a class="ae lt" href="https://medium.com/u/8fddfbb38b7a" rel="noopener">好朋友</a>告诉我，我们实际上可以使用<code class="fe lu lv lw lx b">chrome.postMessage()</code>将blob作为消息发送到web应用程序，但后来我们发现这是不可能的，因为postMessage将blob字符串化，而字符串化blob将会撕裂所有底层的方法和数据，所以无论我们做什么，最终都会得到一个空对象。那不是很糟糕吗？</p><h1 id="b8b2" class="ly kd iq bd ke lz ma mb kh mc md me kk mf mg mh ko mi mj mk ks ml mm mn kw mo bi translated">解决方案</h1><p id="c830" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">最后，在<strong class="la ir"> content-scripts </strong>和<strong class="la ir"> background.js. </strong>的帮助下，我终于将我数周的谷歌搜索收集到的所有信息整合在一起，最终找到了正确的方法。</p><h2 id="4fc6" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">场景:</strong></h2><ol class=""><li id="5d1a" class="mp mq iq la b lb lc lf lg kl mr kp ms kt mt ls mu mv mw mx bi translated">用户从chrome应用商店安装我的chrome扩展并上传原始照片。</li><li id="5468" class="mp mq iq la b lb my lf mz kl na kp nb kt nc ls mu mv mw mx bi translated">点击“上传”，在<strong class="la ir"> background.js </strong>文件上生成一个blob。</li><li id="9086" class="mp mq iq la b lb my lf mz kl na kp nb kt nc ls mu mv mw mx bi translated">我们需要通过<strong class="la ir">内容脚本</strong>在新标签页打开应用程序后，将这个blob传递给web应用程序。</li><li id="16cf" class="mp mq iq la b lb my lf mz kl na kp nb kt nc ls mu mv mw mx bi translated">Blob在web应用程序处被接收并被进一步处理。</li></ol><p id="3957" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">“<strong class="la ir">选择照片</strong>”和“<strong class="la ir">上传</strong>”是几次点击，所以我想我可以方便地跳过它们！</p><p id="dc44" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">也就是说，在背景页面上，让我们捕获blob并从中创建一个ObjectURL:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Creating the Blob URL after selecting the File</figcaption></figure><blockquote class="no np nq"><p id="e00d" class="ky kz nr la b lb nd ld le lf ne lh li ns nf lk ll nt ng ln lo nu nh lq lr ls ij bi translated"><code class="fe lu lv lw lx b"><em class="iq">window.URL.createObjectURL(blob)</em></code>基本上会返回一个类似blob的URL:chrome-extension://&lt;ext . id&gt;/&lt;uniqueId&gt;。此blob url只能在扩展的上下文中查看。您可以将此链接复制粘贴到一个新的选项卡上，它将失败，并显示一个禁止的错误。</p></blockquote><p id="ff82" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">现在我们需要使用<code class="fe lu lv lw lx b">chrome.tabs</code> API来创建一个新的选项卡。<code class="fe lu lv lw lx b">chrome.tabs</code> API让您可以访问窗口中的选项卡，要使用它，您需要在<code class="fe lu lv lw lx b">manifest.json</code>文件中允许访问所需的chrome API(在我们的例子中为“activeTab”):</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Providing access to activeTab for chrome.tabs API to work</figcaption></figure><h2 id="f85d" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">太好了，现在我们已经允许使用<code class="fe lu lv lw lx b">chrome.tabs</code>，让我们让它工作吧</h2><p id="a882" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">我们将使用两套标签API检查功能:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Using chrome.tabs API to create and inject content scripts</figcaption></figure><p id="349b" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">这里需要注意的是，我们首先看一下<code class="fe lu lv lw lx b">chrome.tabs.create</code>。它以一个配置对象作为参数，最重要的部分是你想在新标签中打开的url。对于其他配置选项，您可以查看<a class="ae lt" href="https://developer.chrome.com/extensions/tabs#method-create" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="2af5" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">默认情况下，Created选项卡是焦点，一旦我们在页面上，我们需要运行我们的下一段代码——内容脚本。</p><p id="f36a" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated"><em class="nr">每个</em> <code class="fe lu lv lw lx b"><em class="nr">chrome.tabs</em></code> <em class="nr"> API都会返回一个带有相关数据的回调，我们必须用这个来链接事件。</em></p><p id="bf04" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated"><code class="fe lu lv lw lx b">chrome.tabs.create()</code>方法会给你一个回调，你可以在其中访问标签数据。一旦创建了新的选项卡，就会触发此回调。我们现在要做的是将blob url注入到活动选项卡的窗口中。为此，我们可以使用chrome API <code class="fe lu lv lw lx b">chrome.tabs.executeScript()</code>。这将在选项卡的窗口中执行您的脚本。</p><p id="5fcd" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">正如上面图像中的<code class="fe lu lv lw lx b">line 9</code>所写，让我们将第一步创建的blob url作为全局变量注入。这又会在脚本成功运行后触发回调。</p><p id="efca" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated"><em class="nr">在这种情况下，一旦JS完成了对您的代码的执行，回调就会被触发。</em> <strong class="la ir"> <em class="nr">不是</em> </strong> <em class="nr">是不是意味着等待返回语句/完成？如果您有一个setTimeout，它将不会在触发回调之前等待超时内的代码执行。所以记住要准确计算你的行为。</em></p><p id="8a73" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">存储blobURL后，我们现在可以准备将URL发送到应用程序。为此，我们选择使用XHR请求“获取”blob，并使用我们的web应用程序上下文(https://domain.com)创建一个blob。这基本上是我们在上面第二次executeScript调用中作为自执行函数传递的“<strong class="la ir"> sendFile </strong>”函数中要做的。</p><p id="5646" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">我知道这可能有点令人困惑，所以让我给你看看代码——</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Sending the file through content scripts</figcaption></figure><p id="9cbb" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">在这个函数中，如您所见，我们现在可以毫无问题地从内容脚本中获取blob:chrome-extension://了，然后通过将它传递给<code class="fe lu lv lw lx b">window.createObjectURL()</code>来创建另一个ObjectUrl。这将创建一个blob，其Url类似于<strong class="la ir">blob:https://domain . com/&lt;unique id&gt;</strong>。</p><p id="e85a" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">这个blob可以在一个新的标签中播放，我现在可以在本地存储中设置URL。</p><p id="8734" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">我用<code class="fe lu lv lw lx b">window.onload</code>触发下一部分的原因是，我的blob文件可能很大，因为它是一个图像blob。这只是确保当我的blob可以上传时，按钮被点击！您可以选择省略这一部分，继续您的需求。</p><p id="b025" class="pw-post-body-paragraph ky kz iq la b lb nd ld le lf ne lh li kl nf lk ll kp ng ln lo kt nh lq lr ls ij bi translated">就这样，你成功地将你的blob——不管有多大——传递到你的web应用程序。</p><h2 id="0718" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">我希望你喜欢这篇文章，它在某种程度上帮助了你。</h2><p id="3558" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">我总是乐于接受改进和改变，所以请随时在下面留言。查看我在普通JavaScript 中关于<a class="ae lt" href="https://medium.com/@chakravarthy1165/content-diff-view-in-vanilla-javascript-105a00abd7ce" rel="noopener">内容差异视图的文章。到那时，“<em class="nr">愿代码与你同在。”</em>👾</a></p></div></div>    
</body>
</html>