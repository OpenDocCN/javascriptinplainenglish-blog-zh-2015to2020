<html>
<head>
<title>Creating Scenes in PixiJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在PixiJS中创建场景</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/scenes-in-pixijs-1ee4b0af5116?source=collection_archive---------2-----------------------#2019-12-04">https://javascript.plainenglish.io/scenes-in-pixijs-1ee4b0af5116?source=collection_archive---------2-----------------------#2019-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/733a21ea06bcf84ae4b52f43c3c092ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5iWCcdIevd2eX7ZD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kyleunderscorehead?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kyle Head</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f8b9" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="7085" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">PixiJS 是一个在HTML5中处理2D渲染的极好的库。它速度很快，公开了一个简单的API，可以在多种设备上运行——台式机、笔记本电脑、手机、平板电脑等等。</p><p id="4cda" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">应该也适用于你的智能冰箱。天哪，现在我希望我有一个。</p><p id="71d2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">作为一个渲染引擎，它可以用来创建任何类型的图形体验，它不像游戏引擎那样面向特定的用例，让我们来看看一个简单的设置:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9f9d" class="mn ke iq mj b gy mo mp l mq mr">import * as PIXI from "pixi.js";<br/>import "./resources/css/styles.css";</span><span id="5915" class="mn ke iq mj b gy ms mp l mq mr">const MELON = require("./resources/images/watermelon.png");</span><span id="4c32" class="mn ke iq mj b gy ms mp l mq mr">// Load resources<br/>const Loader: PIXI.Loader = PIXI.Loader.shared;<br/>Loader.add(MELON).load(setup);</span><span id="a993" class="mn ke iq mj b gy ms mp l mq mr">const app = new PIXI.Application({<br/>    antialias: true<br/>});</span><span id="481a" class="mn ke iq mj b gy ms mp l mq mr">app.stage.interactive = true;</span><span id="1e9f" class="mn ke iq mj b gy ms mp l mq mr">document.body.appendChild(app.view);</span><span id="d119" class="mn ke iq mj b gy ms mp l mq mr">function setup() {<br/>    // create base container<br/>    const sceneContainer = new PIXI.Container();<br/>    app.stage.addChild(sceneContainer);</span><span id="40a0" class="mn ke iq mj b gy ms mp l mq mr">    // create the sprite<br/>    const melonSprite = new PIXI.Sprite(<br/>        Loader.resources[MELON].texture<br/>    );</span><span id="8685" class="mn ke iq mj b gy ms mp l mq mr">    // Move the anchor to the center<br/>    melonSprite.anchor.x = 0.5;<br/>    melonSprite.anchor.y = 0.5;</span><span id="7501" class="mn ke iq mj b gy ms mp l mq mr">    // position the sprite<br/>    melonSprite.x = app.renderer.width / 2;<br/>    melonSprite.y = app.renderer.height / 2;</span><span id="2eb9" class="mn ke iq mj b gy ms mp l mq mr">    sceneContainer.addChild(melonSprite);</span><span id="fc6c" class="mn ke iq mj b gy ms mp l mq mr">    // render loop<br/>    app.ticker.add(delta =&gt; {<br/>        // rotate the sprite every frame        <br/>        melonSprite.rotation += 0.1 * delta;<br/>    });<br/>}</span></pre><p id="4ec5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">PixiJS API提供了一个名为<code class="fe mt mu mv mj b">setup</code>的回调函数，在这个函数中我们创建了自己的精灵，修改了它们的属性，并且可以选择在应用程序ticker中对它们做一些事情——我们控制了渲染循环。</p><p id="eba6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于小的交互式演示来说，它很好地满足了目的，但是很明显，如果我们想要很多对象，一些代码分割对于保持功能精简是必要的。</p><p id="abda" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果我们想做一个游戏呢？对于flappy-bird之类的游戏或其他简单的游戏来说，用一些功能来设置和更新实体就可以了，不需要把事情复杂化，尽管如果我们想要一些稍微复杂一点的，有多个层次的东西，那么“场景”就开始有意义了。</p><p id="9498" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mw">简单的设置资源库可以在</em> <a class="ae kc" href="https://github.com/MustSeeMelons/pixijs-typescript-starter" rel="noopener ugc nofollow" target="_blank"> <em class="mw">这里找到</em> </a> <em class="mw">。</em></p><h1 id="1637" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">会是什么场景？</h1><p id="5e9c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在视频游戏的世界中，它将服务于创建和更新其实体的目的，这是应用程序的一个自包含部分——它将是一个游戏级别。也可以认为是戏剧界的一种行为。</p><p id="8c91" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">还有一件事是必需的——管理场景的东西，我们称之为引擎，流程如下所示:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d096a0fe4e610db76f86b755900316d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*JOa1TGh7Mq43Kr0TQZVb4A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">logic flow</figcaption></figure><p id="aaac" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">从<code class="fe mt mu mv mj b">setup</code>函数中，我们现在将只实例化引擎，传入我们希望使用的场景配置。</p><p id="ebe2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">是时候把手弄脏了。</p><h1 id="73b5" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">创造抽象</h1><p id="85fb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们将使用<code class="fe mt mu mv mj b">Typescript</code>,因为这将使我们的抽象更加清晰和精确。我们还会在场景之间添加过渡，让引擎看起来更加花哨！</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7186" class="mn ke iq mj b gy mo mp l mq mr">export interface SceneTransition {<br/>    init(<br/>      app: PIXI.Application,<br/>      type: TransitionType, <br/>      sceneContainer: PIXI.Container<br/>    ): void;</span><span id="d808" class="mn ke iq mj b gy ms mp l mq mr">    update(delta: number, callback: () =&gt; void): void;<br/>}</span><span id="d932" class="mn ke iq mj b gy ms mp l mq mr">export interface SceneSettings {<br/>    index: number;<br/>    name?: string,<br/>    gameScene: AbstractGameScene;<br/>    fadeInTransition: SceneTransition;<br/>    fadeOutTransition: SceneTransition;<br/>}</span><span id="ebc1" class="mn ke iq mj b gy ms mp l mq mr">export class Engine {<br/>    private sceneSettings: SceneSettings[];<br/>    private app: PIXI.Application;<br/>    private currentScene: SceneSettings;</span><span id="882c" class="mn ke iq mj b gy ms mp l mq mr">    constructor(<br/>      app: PIXI.Application,<br/>      scenes: SceneSettings[]<br/>    ) {<br/>        this.app = app;<br/>        this.sceneSettings = scenes;<br/>        this.sceneSettings.forEach(<br/>          (sceneSettings: SceneSettings) =&gt; {<br/>            sceneSettings.gameScene.init(<br/>              this.app,<br/>              this.sceneSwitcher<br/>          );<br/>        });</span><span id="ca85" class="mn ke iq mj b gy ms mp l mq mr">        // Finding the scene with the lowest index<br/>        this.currentScene = scenes.reduce((prev, curr) =&gt; {<br/>            if (prev === undefined) {<br/>                return curr;<br/>            } else {<br/>                return prev.index &gt; curr.index ? curr : prev;<br/>            }<br/>        }, undefined);</span><span id="3d29" class="mn ke iq mj b gy ms mp l mq mr">        this.setupScene(this.currentScene);<br/>    }</span><span id="c3e3" class="mn ke iq mj b gy ms mp l mq mr">    sceneSwitcher = (sceneName: string) =&gt; {<br/>        this.currentScene.gameScene.setFinalizing(() =&gt; {<br/>            const scene = this.sceneSettings.find(<br/>              (sceneSettings) =&gt; {<br/>                return sceneSettings.name === sceneName;<br/>              }<br/>            );</span><span id="8f0b" class="mn ke iq mj b gy ms mp l mq mr">            if (scene) {<br/>            this.setupScene(scene);<br/>                this.currentScene = scene;<br/>            } else {<br/>                console.error("SCENE NOT FOUND: " + sceneName);<br/>            }<br/>        });<br/>    }</span><span id="1121" class="mn ke iq mj b gy ms mp l mq mr">    setupScene(sceneSettings: SceneSettings) {<br/>        this.app.stage.removeChildren();<br/>        const sceneContainer = new PIXI.Container();<br/>        this.app.stage.addChild(sceneContainer);</span><span id="1abb" class="mn ke iq mj b gy ms mp l mq mr">        const gameScene: AbstractGameScene =    sceneSettings.gameScene;</span><span id="4186" class="mn ke iq mj b gy ms mp l mq mr">        gameScene.setup(sceneContainer);</span><span id="1a28" class="mn ke iq mj b gy ms mp l mq mr">        sceneSettings.fadeInTransition.init(this.app, TransitionType.FADE_IN, sceneContainer);</span><span id="d42a" class="mn ke iq mj b gy ms mp l mq mr">        sceneSettings.fadeOutTransition.init(this.app, TransitionType.FADE_OUT, sceneContainer);</span><span id="2e66" class="mn ke iq mj b gy ms mp l mq mr">        gameScene.fadeInTransition = sceneSettings.fadeOutTransition;</span><span id="23de" class="mn ke iq mj b gy ms mp l mq mr">        gameScene.fadeOutTransition = sceneSettings.fadeInTransition;<br/>    }</span><span id="903c" class="mn ke iq mj b gy ms mp l mq mr">    update(delta: number) {<br/>        this.currentScene.gameScene.update(delta);<br/>    }</span><span id="8672" class="mn ke iq mj b gy ms mp l mq mr">}</span></pre><p id="1079" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们的引擎接受一系列游戏场景设置，这些设置稍后用于设置场景本身，它还提供了在场景之间切换的功能。在<code class="fe mt mu mv mj b">PixiJS</code>跑马灯中会调用<code class="fe mt mu mv mj b">update</code>方法，然后引擎会将调用委托给活动场景。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="820b" class="mn ke iq mj b gy mo mp l mq mr">export enum SceneState {<br/>    LOAD,<br/>    PROCESS,<br/>    FINALIZE,<br/>    DONE<br/>}<br/>export interface GameScene {<br/>    sceneUpdate(delta: number): void;<br/>}</span><span id="2335" class="mn ke iq mj b gy ms mp l mq mr">export abstract class AbstractGameScene implements GameScene {<br/>    protected sceneState: SceneState;<br/>    protected app: PIXI.Application;<br/>    protected sceneSwitcher: (sceneName: string) =&gt; void;<br/>    protected fadeInSceneTransition: SceneTransition;<br/>    protected fadeOutSceneTransition: SceneTransition;<br/>    protected sceneContainer: PIXI.Container;<br/>    private onDone: () =&gt; void;</span><span id="8bff" class="mn ke iq mj b gy ms mp l mq mr">    set fadeInTransition(fadeInSceneTransition: SceneTransition) {<br/>        this.fadeInSceneTransition = fadeInSceneTransition;<br/>    }</span><span id="b08f" class="mn ke iq mj b gy ms mp l mq mr">    set fadeOutTransition(fadeOutSceneTransition: SceneTransition) {<br/>        this.fadeOutSceneTransition = fadeOutSceneTransition;<br/>    }</span><span id="56d7" class="mn ke iq mj b gy ms mp l mq mr">    init(<br/>      app: PIXI.Application,<br/>      sceneSwitcher: (sceneName: string) =&gt; void): void {<br/>        this.app = app;<br/>        this.sceneSwitcher = sceneSwitcher;<br/>    }</span><span id="c6f3" class="mn ke iq mj b gy ms mp l mq mr">    abstract setup(sceneContainer: PIXI.Container): void;<br/>    abstract preTransitionUpdate(delta: number): void;<br/>    abstract sceneUpdate(delta: number): void;</span><span id="823a" class="mn ke iq mj b gy ms mp l mq mr">    update(delta: number): void {<br/>        switch (this.sceneState) {<br/>            case SceneState.LOAD:<br/>                this.fadeInSceneTransition.update(delta, () =&gt; {<br/>                    this.sceneState = SceneState.PROCESS;<br/>                });<br/>                this.preTransitionUpdate(delta);<br/>                break;<br/>            case SceneState.PROCESS:<br/>                this.sceneUpdate(delta);<br/>                break;<br/>            case SceneState.FINALIZE:<br/>                this.fadeOutSceneTransition.update(delta, () =&gt; {<br/>                    this.sceneState = SceneState.DONE;<br/>                    if (this.onDone) {<br/>                        this.onDone();<br/>                    }<br/>                });<br/>                break;<br/>        }<br/>    }</span><span id="983c" class="mn ke iq mj b gy ms mp l mq mr">    setFinalizing(onDone: () =&gt; void) {<br/>        this.onDone = onDone;<br/>        this.sceneState = SceneState.FINALIZE;<br/>    }<br/>}</span></pre><p id="7f9d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">场景本身有一个让它运行的核心方法——<code class="fe mt mu mv mj b">update</code>，用<code class="fe mt mu mv mj b">update</code>方法表示。</p><p id="2401" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">创建一个抽象类来实现场景生命周期:加载、处理、最终确定,“真实”场景将扩展这个类并提供所有抽象方法的实现:</p><ul class=""><li id="279a" class="my mz iq ld b le lz li ma lm na lq nb lu nc ly nd ne nf ng bi translated"><code class="fe mt mu mv mj b">setup </code> —设置时由引擎调用</li><li id="9b9e" class="my mz iq ld b le nh li ni lm nj lq nk lu nl ly nd ne nf ng bi translated"><code class="fe mt mu mv mj b">preTransitionUpdate </code> —当转换正在进行时调用</li><li id="0212" class="my mz iq ld b le nh li ni lm nj lq nk lu nl ly nd ne nf ng bi translated"><code class="fe mt mu mv mj b">sceneUpdate </code> —当场景处于活动状态时调用</li></ul><p id="e772" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">该类被标记为abstract，以避免该类的实例化，因为它只提供了部分实现—没有创建精灵，这将在具体的类中完成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f399" class="mn ke iq mj b gy mo mp l mq mr">const MELON = require("../../resources/images/watermelon.png");</span><span id="b594" class="mn ke iq mj b gy ms mp l mq mr">const Loader: PIXI.Loader = PIXI.Loader.shared;</span><span id="5786" class="mn ke iq mj b gy ms mp l mq mr">export class ClockwiseScene extends AbstractGameScene {<br/>    private melon: PIXI.Sprite;</span><span id="b90e" class="mn ke iq mj b gy ms mp l mq mr">    setup(sceneContainer: PIXI.Container) {<br/>        this.sceneState = SceneState.LOAD;<br/>        this.melon = new PIXI.Sprite(<br/>          Loader.resources[MELON].texture<br/>        );<br/>        this.melon.anchor.x = 0.5;<br/>        this.melon.anchor.y = 0.5;</span><span id="b290" class="mn ke iq mj b gy ms mp l mq mr">        this.melon.x = this.app.renderer.width / 2;<br/>        this.melon.y = this.app.renderer.height / 2;</span><span id="9f7d" class="mn ke iq mj b gy ms mp l mq mr">        this.melon.interactive = true;<br/>        this.melon.addListener("pointerup", () =&gt; {<br/>            this.sceneSwitcher("counterClockwise");<br/>        });</span><span id="1e91" class="mn ke iq mj b gy ms mp l mq mr">        sceneContainer.addChild(this.melon);<br/>    }</span><span id="1414" class="mn ke iq mj b gy ms mp l mq mr">    preTransitionUpdate(delta: number) {<br/>        this.melon.rotation += 0.1 * delta;<br/>    }</span><span id="bc3f" class="mn ke iq mj b gy ms mp l mq mr">    sceneUpdate(delta: number) {<br/>        this.melon.rotation += 0.1 * delta;<br/>    }<br/>}</span></pre><p id="d68c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">具体的类负责添加对象和相关的逻辑，比如点击监听器和框架更新。有了这一切，我们钟爱的Pixi本身的<code class="fe mt mu mv mj b">setup</code>函数现在看起来非常精简:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fd94" class="mn ke iq mj b gy mo mp l mq mr">function setup() {<br/>    const engine: Engine = new Engine(app, [<br/>        {<br/>            index: 0,<br/>            name: "clockwise",<br/>            gameScene: new ClockwiseScene(),<br/>            fadeInTransition: new SimpleFadeTransition(0.1),<br/>            fadeOutTransition: new SimpleFadeTransition()<br/>        },<br/>        {<br/>            index: 1,<br/>            name: "counterClockwise",<br/>            gameScene: new CounterClockwiseScene(),<br/>            fadeInTransition: new SimpleFadeTransition(0.1),<br/>            fadeOutTransition: new SimpleFadeTransition()<br/>        }]);</span><span id="f157" class="mn ke iq mj b gy ms mp l mq mr">    app.ticker.add(delta =&gt; {<br/>        engine.update(delta);<br/>    });<br/>}</span></pre><p id="f9fc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们创建场景，加上一些配置，将它们传递给引擎。必要时，引擎将设置正确的场景。</p><p id="33eb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mw">注意:设置功能必须清除任何先前的状态。</em></p><p id="27a5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">添加了一个额外的场景，一个向相反方向旋转甜瓜的场景，结果可以在下面的<code class="fe mt mu mv mj b">gif</code>中看到(抱歉，这不是一个完美的循环):</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/27150a6d4f23a342d3383ffbed80d9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Eewi4qM1mlWY41ZK1hAHYg.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">a beautiful, rotating melon</figcaption></figure><h1 id="48c7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="a441" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通过一些抽象，我们创建了基础架构，通过将责任划分给不同的对象来管理更复杂的Pixi项目。</p><p id="5e0e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">有几件事可以改进:</p><ul class=""><li id="696d" class="my mz iq ld b le lz li ma lm na lq nb lu nc ly nd ne nf ng bi translated">场景共享——不需要每次都重新设置场景，如果我们经常在它们之间切换的话，比如RPG中的房间</li><li id="20a3" class="my mz iq ld b le nh li ni lm nj lq nk lu nl ly nd ne nf ng bi translated">可重复使用的过渡-目前他们重新创建，有一个淡入，淡出，将是一个很好的优化</li><li id="004b" class="my mz iq ld b le nh li ni lm nj lq nk lu nl ly nd ne nf ng bi translated">更多的生命周期挂钩——当我们淡出当前场景时的过渡后更新(将非常类似于前挂钩)</li></ul><p id="4e54" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mw">成品库可以在</em> <a class="ae kc" href="https://github.com/MustSeeMelons/pixi-scene" rel="noopener ugc nofollow" target="_blank"> <em class="mw">这里找到</em> </a> <em class="mw">，干杯。</em></p><p id="28a6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mw">对不起我叫西瓜瓜。</em></p></div></div>    
</body>
</html>