<html>
<head>
<title>Functional Programming: Immutability in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:TypeScript中的不变性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-immutability-in-functional-programming-6b307ee8641?source=collection_archive---------4-----------------------#2020-02-01">https://javascript.plainenglish.io/what-is-immutability-in-functional-programming-6b307ee8641?source=collection_archive---------4-----------------------#2020-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9152e27343389b5e59b3142a90841578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XX5bIcGpqMwFhOxR34V8Yg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Do not mutate the state!</figcaption></figure><div class=""/><div class=""><h2 id="6a75" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">什么是不变性和不可变数据，如何在Java、JavaScript库、React.js、React Native中使用它，为什么要使用它</h2></div><p id="2354" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在面向对象和函数式编程中，如果一个对象在创建后不能被修改，就称为不可变。</p><p id="d186" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">那么，这为什么如此重要呢？</strong></p><h1 id="d163" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">我在掩盖什么</h1><p id="0c3f" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">在动机一节中，我提到了回答这个问题的一些原因，接下来我用一个例子解释了如何不改变JavaScript中的数据(这很简单)，最后，我用一些众所周知的事实证明了Java、C#和React.js等JavaScript库的不变性。</p><h1 id="1c01" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="bcb2" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg">什么是不变性？</strong></p><p id="f82e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你不能改变一个不可变的数据，你只需要复制它，然后更新新的数据。</p><p id="d3d2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">不变性就是一切。</p><p id="9d2a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">函数式编程通常避免使用<code class="fe mn mo mp mq b">mutable</code>状态。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="be4b" class="lq lr jf bd ls lt my lv lw lx mz lz ma kl na km mc ko nb kp me kr nc ks mg mh bi translated">动机</h1><p id="b68e" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg">为什么在函数式编程中使用不变性很重要？</strong></p><p id="6e66" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">这里是不变性给你的主要优势:</strong></p><h2 id="4019" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated"><strong class="ak">时间旅行调试</strong></h2><p id="2f6f" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">TTD是通过代码回溯时间的过程，不变性增强了这个过程中的状态推理，</p><h2 id="a61f" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated"><strong class="ak">性能提升</strong></h2><p id="e71c" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">如果你有一个对象，改变了它的一个属性，javascript需要很长时间才能意识到属性已经被改变，它需要检查所有的对象属性，通过不变性，它已经知道应用了什么更新，通过状态版本之间更便宜的比较，</p><blockquote class="np nq nr"><p id="dd8f" class="ku kv ns kw b kx ky kg kz la lb kj lc nt le lf lg nu li lj lk nv lm ln lo lp ij bi translated"><strong class="kw jg">隔离失败</strong></p><p id="2a55" class="ku kv ns kw b kx ky kg kz la lb kj lc nt le lf lg nu li lj lk nv lm ln lo lp ij bi translated">你有一个线程运行在一个临界区，访问共享状态，如果出错了会发生什么？您需要终止所有访问共享内存的线程，因为您不知道终止的进程在共享内存中留下了什么状态，所以基本上您会丢失那里的所有内容。在不可变状态下，如果你丢失了某个进程，你只是丢失了那个特定进程的状态，其他所有进程都不会受到影响。</p><p id="f4a7" class="ku kv ns kw b kx ky kg kz la lb kj lc nt le lf lg nu li lj lk nv lm ln lo lp ij bi translated"><strong class="kw jg">可变性的局部性问题</strong></p><p id="c61d" class="ku kv ns kw b kx ky kg kz la lb kj lc nt le lf lg nu li lj lk nv lm ln lo lp ij bi translated">你在哪里定位你的可变状态，你有一个在诺丁汉运行的进程和一个在伦敦运行的进程，它们需要共享内存，你在哪里共享内存？假设你在莱斯特有你的共享内存，如果网络瘫痪会发生什么，但是不变性，每个都有自己的副本，当网络备份时，你只需要再次同步数据。</p><p id="293b" class="ku kv ns kw b kx ky kg kz la lb kj lc nt le lf lg nu li lj lk nv lm ln lo lp ij bi translated"><a class="ae nw" href="https://www.youtube.com/watch?v=8Sf6ToPNiA4" rel="noopener ugc nofollow" target="_blank"> <em class="jf"> Francesco Cesarini，Erlang Solutions的技术总监</em> </a></p></blockquote></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="3e10" class="lq lr jf bd ls lt my lv lw lx mz lz ma kl na km mc ko nb kp me kr nc ks mg mh bi translated">走查</h1><h2 id="4dfd" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated"><strong class="ak">什么是不变性，如何使用它？</strong></h2><p id="698b" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><strong class="kw jg">在JavaScript </strong>中，有些内置类型(数字、字符串)是不可变的，但是自定义对象一般是可变的。</p><p id="fe09" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">考虑一下这个:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="2f09" class="nd lr jf mq b gy of og l oh oi">let <strong class="mq jg"><em class="ns">immutableString</em></strong> = "I'm an Immutable value";</span></pre><p id="51a6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">这是否意味着一个新值不能赋给一个不可变的对象？</strong></p><p id="6d4a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这要视情况而定，但在这个例子中，它绝对是一个字符串，它可以被赋给一个新值，但一个新的内存引用将被分配给它。</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="f5cb" class="nd lr jf mq b gy of og l oh oi">let <strong class="mq jg"><em class="ns">immutableString</em></strong> = "I'm an Immutable value";<br/>console.log(<strong class="mq jg"><em class="ns">immutableString</em></strong>); // I'm an Immutable value<br/>let <strong class="mq jg"><em class="ns">newImmutableString</em></strong> = <strong class="mq jg"><em class="ns">immutableString</em></strong>.replace("an Immutable", "a Mutable");<br/>console.log(<strong class="mq jg"><em class="ns">immutableString</em></strong>); // I'm an Immutable value</span></pre><p id="536d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="ns">可以看出</em> <code class="fe mn mo mp mq b">immutableString</code> <em class="ns">之所以不变是因为顾名思义是不可变的。(这里我用了</em> <code class="fe mn mo mp mq b">let</code> <em class="ns">来说明，如果我用</em> <code class="fe mn mo mp mq b">const</code> <em class="ns">也不妨碍它是可变的，所以用</em> <code class="fe mn mo mp mq b">const</code> <em class="ns">来代替)</em></p><p id="42bd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果JavaScript中的字符串是可变的，它会有不同的行为，我使用了<a class="ae nw" href="https://github.com/christophehurpeau/mutable-string" rel="noopener ugc nofollow" target="_blank">可变字符串</a>库，它会给你可变字符串，下面是演示:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="14ef" class="nd lr jf mq b gy of og l oh oi">const MutableString = require('mutable-string');<br/>let <strong class="mq jg"><em class="ns">mutableString</em></strong> = new MutableString("I'm an Immutable value");<br/>console.log(<strong class="mq jg"><em class="ns">mutableString</em></strong>.toString());  // I'm an Immutable value<br/>let newMutableString = <strong class="mq jg"><em class="ns">mutableString</em></strong>.replace('an Immutable', new MutableString("a Mutable"));<br/>console.log(<strong class="mq jg"><em class="ns">mutableString</em></strong>.toString());  // I'm a Mutable value</span></pre><p id="3523" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">与JavaScript中的字符串相反,<code class="fe mn mo mp mq b">mutableString</code>被就地改变。</p><p id="b2bd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是对于JavaScript中的对象和数组来说，对对象/数组进行更改将通过引用传递它们，而不是复制它们:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="4ded" class="nd lr jf mq b gy of og l oh oi">let <strong class="mq jg"><em class="ns">mutableArray </em></strong>= [1, 2, 3, 4, 5];<br/>console.log(<strong class="mq jg"><em class="ns">mutableArray</em></strong>); // [ 1, 2, 3, 4, 5 ]<br/>let <strong class="mq jg"><em class="ns">updateMutableArray </em></strong>= <strong class="mq jg"><em class="ns">mutableArray</em></strong>.push(6);<br/>console.log(<strong class="mq jg"><em class="ns">mutableArray</em></strong>); // [ 1, 2, 3, 4, 5, 6 ]</span></pre><p id="fa3b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="ns">当我们把一个新值推送到</em> <code class="fe mn mo mp mq b">mutableArray</code> <em class="ns">时，它会被就地更新，而不是被新的复制。</em></p><p id="67e6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你想让它不变呢？</p><p id="6577" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你可以通过使用一个不可变数组来使它不可变，例如来自<a class="ae nw" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank"> immutable.js </a>的List。</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="94c0" class="nd lr jf mq b gy of og l oh oi">const {List} = require('immutable');</span><span id="644b" class="nd lr jf mq b gy oj og l oh oi">let <strong class="mq jg"><em class="ns">immutableList</em></strong> = List([1, 2, 3, 4, 5]);<br/>console.log(<strong class="mq jg"><em class="ns">immutableList</em></strong>.toArray()); // [ 1, 2, 3, 4, 5 ]<br/>let <strong class="mq jg"><em class="ns">newImmutableList</em></strong> = <strong class="mq jg"><em class="ns">immutableList</em></strong>.push(6);<br/>console.log(<strong class="mq jg"><em class="ns">immutableList</em></strong>.toArray()); // [ 1, 2, 3, 4, 5 ]</span></pre><p id="4d85" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="ns">当我们将一个新值推送到</em> <code class="fe mn mo mp mq b">immutableList</code> <em class="ns">时，它不会原地改变，而会为此创建一个新的更新引用。</em></p><p id="e5c8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你不想使用不可变的列表或数组呢？</p><p id="7cbb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你不想使用一个不可变的列表，你就不应该在JavaScript中使用破坏性的函数，而是使用非破坏性的函数来完成你的工作。我们可以这样更新我们的<code class="fe mn mo mp mq b">mutableArray</code>示例:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="2c09" class="nd lr jf mq b gy of og l oh oi">let <strong class="mq jg"><em class="ns">mutableArray</em></strong> = [1, 2, 3, 4, 5];<br/>console.log(<strong class="mq jg"><em class="ns">mutableArray</em></strong>); // [ 1, 2, 3, 4, 5 ]<br/>let <strong class="mq jg"><em class="ns">updatedMutableArray</em></strong> = [...<strong class="mq jg"><em class="ns">mutableArray</em></strong>, 6];<br/>console.log(<strong class="mq jg"><em class="ns">mutableArray</em></strong>); // [ 1, 2, 3, 4, 5 ]</span></pre><p id="099e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="ns">这种方式下</em> <code class="fe mn mo mp mq b">mutableArray</code> <em class="ns">不在原地变化。</em></p><p id="5897" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是不变性并不总是一个好的选择，考虑这个例子:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="4ad9" class="nd lr jf mq b gy of og l oh oi">const <strong class="mq jg"><em class="ns">a </em></strong>= [1, 2, 3, 4, 5];<br/>let <strong class="mq jg"><em class="ns">immutableSum </em></strong>= 0;<br/>for (let <strong class="mq jg"><em class="ns">i </em></strong>= 0; <strong class="mq jg"><em class="ns">i </em></strong>&lt; <strong class="mq jg"><em class="ns">a</em></strong>.length; <strong class="mq jg"><em class="ns">i </em></strong>+= 1) {<br/>  <strong class="mq jg"><em class="ns">immutableSum </em></strong>+= <strong class="mq jg"><em class="ns">a</em></strong>[<strong class="mq jg"><em class="ns">i</em></strong>];<br/>  console.log(<strong class="mq jg"><em class="ns">immutableSum</em></strong>);<br/>}</span></pre><p id="5680" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是输出:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="2549" class="nd lr jf mq b gy of og l oh oi">1<br/>3<br/>6<br/>10<br/>15</span></pre><p id="cd88" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="ns">随着循环的进行，每个循环创建一个immutableSum的新副本，如果这个数组包含1000个项，则创建了1000个副本。所以要确定你想从他们那里得到什么样的行为。</em></p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="2115" class="lq lr jf bd ls lt my lv lw lx mz lz ma kl na km mc ko nb kp me kr nc ks mg mh bi translated">其他演示</h1><p id="77c8" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">如果您对其他语言(如Java)的实现以及React.js和React Native等框架或库不感兴趣，您可以直接跳到众所周知的事实。</p><h1 id="b622" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h1><p id="5a32" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">在Java中<code class="fe mn mo mp mq b">String</code>类是不可变的:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="52d6" class="nd lr jf mq b gy of og l oh oi">String <strong class="mq jg"><em class="ns">immutableString</em></strong> = "I'm an Immutable Java String";<br/><strong class="mq jg"><em class="ns">immutableString</em></strong>.toLowerCase();</span></pre><p id="26db" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这之后，方法<code class="fe mn mo mp mq b">toLowerCase()</code>调用<code class="fe mn mo mp mq b">immutableString</code>仍然和以前一样。</p><p id="7d14" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">Java的可变版本<code class="fe mn mo mp mq b">String</code>是<code class="fe mn mo mp mq b">StringBuffer</code>和<code class="fe mn mo mp mq b">StringBuilder</code>。</p><p id="a636" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">原始类型变量(<code class="fe mn mo mp mq b">int</code>，<code class="fe mn mo mp mq b">long</code>，<code class="fe mn mo mp mq b">short</code>，...)可以在定义后重新分配。用关键字<code class="fe mn mo mp mq b">final</code>你可以防止它们被重新分配(以某种方式使它们对变异安全)。</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="a195" class="nd lr jf mq b gy of og l oh oi">int <strong class="mq jg"><em class="ns">primitiveInt</em></strong> = 0;<br/><strong class="mq jg"><em class="ns">primitiveInt</em></strong> = 1;</span><span id="e218" class="nd lr jf mq b gy oj og l oh oi"><strong class="mq jg">final</strong> int <strong class="mq jg"><em class="ns">finalPrimitiveInt</em></strong> = 0;<br/><strong class="mq jg"><em class="ns">finalPrimitiveInt</em></strong> = 1; <em class="ns">// can't be reassigned</em></span></pre><p id="6f1c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是它不能阻止对象的属性被重新分配。</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="64e8" class="nd lr jf mq b gy of og l oh oi"><strong class="mq jg">final</strong> MyObject <strong class="mq jg"><em class="ns">myObject</em></strong> = <strong class="mq jg">new</strong> MyObject();<br/><strong class="mq jg"><em class="ns">myObject.property</em></strong> = 0;  <em class="ns">// myObject is mutable</em><br/><strong class="mq jg"><em class="ns">myObject</em></strong> = <strong class="mq jg">new</strong> MyObject();  <em class="ns">// can't be reassigned</em></span></pre><p id="74f8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">原始包装器(<code class="fe mn mo mp mq b">Integer</code>、<code class="fe mn mo mp mq b">Long</code>、<code class="fe mn mo mp mq b">Short</code>、<code class="fe mn mo mp mq b">Double</code>、<code class="fe mn mo mp mq b">Float</code>、<code class="fe mn mo mp mq b">Character</code>、<code class="fe mn mo mp mq b">Byte</code>、<code class="fe mn mo mp mq b">Boolean</code>)也都是不可变的。</p><h1 id="82f6" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">React.js和React Native</h1><p id="1cec" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">React允许您使用任何想要的数据管理风格，包括突变。react和react native中的不变性是通过前面提到的<code class="fe mn mo mp mq b">immutable.js</code>、<code class="fe mn mo mp mq b">mori</code>和<code class="fe mn mo mp mq b">immutability-helper</code>等库实现的。下面是最后一个例子的演示:</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="fb68" class="nd lr jf mq b gy of og l oh oi">import update from 'immutability-helper';</span><span id="f0b3" class="nd lr jf mq b gy oj og l oh oi">const immutableArray = [1, 2, 3, 4, 5];<br/>console.log(immutableArray);  // [1, 2, 3, 4, 5]<br/>const immutableArray2 = update(immutableArray, {$push: [6]});<br/>console.log(immutableArray);  // [1, 2, 3, 4, 5]</span></pre><p id="a3fd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe mn mo mp mq b">immutableArray</code>保持不变。</p><p id="0b96" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这就是它的工作原理。以<code class="fe mn mo mp mq b">$</code>为前缀的按键被称为<em class="ns">命令</em>。他们正在“变异”的数据结构被称为<em class="ns">目标</em>。</p><h2 id="38c7" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated">可用命令</h2><ul class=""><li id="ed72" class="ok ol jf kw b kx mi la mj ld om lh on ll oo lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$push: array}</code> <code class="fe mn mo mp mq b">push()</code>目标上<code class="fe mn mo mp mq b">array</code>中的所有项目。</li><li id="c8a2" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$unshift: array}</code> <code class="fe mn mo mp mq b">unshift()</code>目标上<code class="fe mn mo mp mq b">array</code>中的所有项目。</li><li id="dabd" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$splice: array of arrays}</code>对于<code class="fe mn mo mp mq b">arrays</code>中的每一项，用该项提供的参数调用目标上的<code class="fe mn mo mp mq b">splice()</code>。<em class="ns">注意:数组中的项目是按顺序应用的，所以顺序很重要。在操作过程中，目标的指数可能会发生变化。</em></li><li id="b239" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$set: any}</code>完全更换目标。</li><li id="7f74" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$toggle: array of strings}</code>切换目标对象的布尔字段列表。</li><li id="4ff0" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$unset: array of strings}</code>从目标对象中删除<code class="fe mn mo mp mq b">array</code>中的键列表。</li><li id="2849" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$merge: object}</code>将<code class="fe mn mo mp mq b">object</code>的按键与目标合并。</li><li id="9289" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$apply: function}</code>将当前值传递给函数，并用新的返回值更新它。</li><li id="6629" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$add: array of objects}</code>给<code class="fe mn mo mp mq b">Map</code>或<code class="fe mn mo mp mq b">Set</code>加一个值。当添加到一个<code class="fe mn mo mp mq b">Set</code>时，你传入一个要添加的对象数组，当添加到一个地图时，你传入<code class="fe mn mo mp mq b">[key, value]</code>数组，像这样:<code class="fe mn mo mp mq b">update(myMap, {$add: [['foo', 'bar'], ['baz', 'boo']]})</code></li><li id="0b37" class="ok ol jf kw b kx ot la ou ld ov lh ow ll ox lp op oq or os bi translated"><code class="fe mn mo mp mq b">{$remove: array of strings}</code>从<code class="fe mn mo mp mq b">Map</code>或<code class="fe mn mo mp mq b">Set</code>中删除数组中的键列表。</li></ul><p id="b186" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果您在应用程序的性能关键部分使用不可变数据，您可以从<code class="fe mn mo mp mq b">ShouldComponentUpdate()</code>或其他性能优化中受益，以加速您的应用程序。</p><h1 id="a5a3" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">C#</h1><p id="39b8" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">在C#中，你可以用<code class="fe mn mo mp mq b">readonly</code>语句来强制一个类的字段的不变性。通过将所有字段强制为不可变的，您获得了不可变的类型。</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="a2f9" class="nd lr jf mq b gy of og l oh oi"><strong class="mq jg">class</strong> <strong class="mq jg">AnImmutableType</strong><br/>{<br/>    <strong class="mq jg">public</strong> <strong class="mq jg">readonly</strong> double _value;<br/>    <strong class="mq jg">public</strong> AnImmutableType(double x) <br/>    { <br/>        _value = x; <br/>    }<br/>    <strong class="mq jg">public</strong> AnImmutableType Square() <br/>    { <br/>        <strong class="mq jg">return</strong> <strong class="mq jg">new</strong> AnImmutableType(_value * _value); <br/>    }<br/>}</span></pre></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="d087" class="lq lr jf bd ls lt my lv lw lx mz lz ma kl na km mc ko nb kp me kr nc ks mg mh bi translated">众所周知的事实</h1><h2 id="a481" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated">JavaScript中的只读(类型脚本)</h2><p id="8d59" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">为了模拟对象的不变性，可以将属性定义为只读(writable: false)。</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="3f96" class="nd lr jf mq b gy of og l oh oi"><strong class="mq jg">var</strong> obj = {foo: ''};<br/>Object.defineProperty(obj, ‘foo’, { value: ‘bar’, writable: <strong class="mq jg">false </strong>});<br/>obj.foo = ‘bar2’;  <em class="ns">// silently ignored</em></span></pre><p id="a3ec" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然而，上面的方法仍然允许添加新的属性。或者，可以使用Object.freeze使现有对象不可变。</p><pre class="nx ny nz oa gt ob mq oc od aw oe bi"><span id="3e7e" class="nd lr jf mq b gy of og l oh oi"><strong class="mq jg">var</strong> obj = { foo: ‘bar’ };<br/>Object.freeze(obj);<br/>obj.foo = ‘bars’; <em class="ns">// cannot edit property, silently ignored</em></span></pre><p id="1927" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在来自<code class="fe mn mo mp mq b">defineProperty</code>方法或<code class="fe mn mo mp mq b">freeze</code>的React中，它引发了一个TypeError，并且不能赋给只读属性。</p><h2 id="52c5" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated"><strong class="ak">不可变变量</strong></h2><p id="3bed" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">常量和只读字段是不可变的变量。</p><h2 id="8885" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated"><strong class="ak">弱对强的不变性</strong></h2><p id="5f40" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">如果一个对象状态的一些字段不可改变并且是不可变的，那么其他可以改变的字段称为<em class="ns">弱不可变的。</em>如果所有字段都是不可变的，那么对象也是不可变的。如果整个对象不能被另一个类扩展，这个对象被称为<em class="ns">强不可变。</em></p><h2 id="6bb9" class="nd lr jf bd ls ne nf dn lw ng nh dp ma ld ni nj mc lh nk nl me ll nm nn mg no bi translated"><strong class="ak">线程安全</strong></h2><p id="c892" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">在多线程应用程序中，每个线程都可以处理由不可变对象表示的数据，而不用担心数据被其他线程更改。因此，不可变对象被称为线程安全的。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="4413" class="lq lr jf bd ls lt my lv lw lx mz lz ma kl na km mc ko nb kp me kr nc ks mg mh bi translated">摘要</h1><p id="f50b" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">为了让代码更可预测，推理起来更安全，你必须使用不变性而不是可变性，例如，你有一个数组<code class="fe mn mo mp mq b">[1, 2, 3, 4, 5]</code>，有人用破坏性的<code class="fe mn mo mp mq b">push(6)</code>推给它，突然你的数组发生了变异，所以你不能确定你的状态是否安全。通过使用不可变的数组，比如来自immutable.js的<code class="fe mn mo mp mq b">List([1, 2, 3, 4, 5])</code>,如果有人想用库的<code class="fe mn mo mp mq b">push(6)</code>方法推它，他/她会制作数组的副本，你的数组仍然是安全的。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="4add" class="lq lr jf bd ls lt my lv lw lx mz lz ma kl na km mc ko nb kp me kr nc ks mg mh bi translated">进一步阅读</h1><p id="5fcd" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">如果你对函数式编程感兴趣，并希望<strong class="kw jg">让你的代码更简洁、更可组合、更适合测试</strong>，我有另一篇关于函数式编程的文章<a class="ae nw" href="https://medium.com/@zareanmasoud/devmade-curry-ing-powder-recipe-in-functional-programming-c6e0e45cfbae" rel="noopener">。</a></p></div></div>    
</body>
</html>