<html>
<head>
<title>How to handle routing and navigation in React JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React JS中处理路由和导航</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/routing-and-navigation-in-react-cffc26e8a389?source=collection_archive---------0-----------------------#2019-09-19">https://javascript.plainenglish.io/routing-and-navigation-in-react-cffc26e8a389?source=collection_archive---------0-----------------------#2019-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><div class=""/><p id="e70b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React应用程序的开始阶段，我认为应该遵循两个步骤来提高生产率:</p><ol class=""><li id="7fe6" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka jc">用ESLint、appellizer、EditorConfig、Jest、Reactotron等工具配置app基础</strong>。</li><li id="20a3" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka jc">配置路线和导航</strong>以控制用户将访问的路线。</li></ol><p id="f42e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将向你展示我是如何处理第二个项目，让我们的应用程序变得井井有条！</p><p id="7202" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我假设您已经配置了react应用程序。如果没有，就按照这里的步骤:<a class="ae lk" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/create-react-app</a></p><figure class="ll lm ln lo gt is"><div class="bz fp l di"><div class="lp lq l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="79d4" class="ly lz jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">装置</h1><p id="17f1" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">第一步是安装<strong class="ka jc"> react-router-dom </strong> lib，它将负责为我们处理它:</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="7a06" class="ng lz jb nc b gy nh ni l nj nk">yarn add react-router-dom</span></pre><p id="9866" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装完成后，我们将创建文件夹<code class="fe nl nm nn nc b">./src/routes</code>来添加我们的路由配置。在这个文件夹中，我们将有两个文件:</p><ul class=""><li id="f218" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv no lc ld le bi translated"><strong class="ka jc"> index.js </strong> →负责返回用户告知路线对应的页面。它将像路由器一样为我们的应用程序工作。</li><li id="26c1" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv no lc ld le bi translated"><strong class="ka jc"> Route.js </strong> →该组件将负责根据用户的权限重定向用户。例如，当用户试图访问需要认证的路由时，我们将使用它将用户重定向到登录页面。</li></ul></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="1583" class="ly lz jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">配置路线</h1><p id="bfbb" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">先说<code class="fe nl nm nn nc b">index.js</code>。在这个文件中，我们将从<strong class="ka jc"> react-router-dom </strong>导入两个组件:</p><ul class=""><li id="b0b0" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv no lc ld le bi translated"><strong class="ka jc">开关</strong></li><li id="c3ca" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv no lc ld le bi translated"><strong class="ka jc">路线</strong></li></ul><p id="1cd5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后我们将用我们自己的组件替换这条路线，但现在我们不必担心它。</p><p id="5927" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将进口我们所有的页面(来自<code class="fe nl nm nn nc b">./src/pages/COMPONENT_NAME/index.js</code>)。它们将在每条路线中返回，在这里我们将链接到每条路线的期望路径。</p><p id="d673" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意，我们正在传递一个名为<code class="fe nl nm nn nc b">isPrivate</code>的属性，这个属性现在没有影响，但是稍后会帮助我们根据用户在应用程序中的权限重定向用户。</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="d2ba" class="ng lz jb nc b gy nh ni l nj nk">import React from 'react';<br/>import { Switch, Route } from 'react-router-dom';</span><span id="fb77" class="ng lz jb nc b gy np ni l nj nk">import SignIn from '../pages/SignIn';<br/>import SignUp from '../pages/SignUp';<br/>import Dashboard from '../pages/Dashboard';</span><span id="4379" class="ng lz jb nc b gy np ni l nj nk">export default function Routes() {<br/>  return (<br/>    &lt;Switch&gt;<br/>      &lt;Route path="/" exact component={SignIn} /&gt;<br/>      &lt;Route path="/register" component={SignUp} /&gt;</span><span id="08e4" class="ng lz jb nc b gy np ni l nj nk">      &lt;Route path="/dashboard" component={Dashboard} isPrivate /&gt;</span><span id="2ce6" class="ng lz jb nc b gy np ni l nj nk">      {/* redirect user to SignIn page if route does not exist and user is not authenticated */}<br/>      &lt;Route component={SignIn} /&gt;<br/>    &lt;/Switch&gt;<br/>  );<br/>}</span></pre><p id="594c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Switch按照路径在组件中的排列顺序检查路径，并总是返回包含路径值的第一个路由作为子字符串。因为我们有一个带有“/”的路径和另一个带有“/register”的路径，所以第二个路径永远不会被调用，因为第一个路径总是被选择。为了解决这个问题，我们需要添加<code class="fe nl nm nn nc b">exact</code>属性，所以如果路由正好是“/”，它将返回登录组件。</p><p id="184c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意，我们需要在这个文件中导入React，因为我们使用的是JSX。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="2349" class="ly lz jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">配置历史记录</h1><p id="0576" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">我们希望能够根据一些事件在我们的应用程序中自动重定向我们的用户，例如，如果他按下注销按钮，就让他返回到登录页面。为了处理这个问题，我们将使用一个名为<strong class="ka jc"> history </strong>的库。</p><p id="0d20" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步是安装它:</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="212f" class="ng lz jb nc b gy nh ni l nj nk">yarn add history</span></pre><p id="fcea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将创建文件<code class="fe nl nm nn nc b">./src/services/history.js</code>:</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="f719" class="ng lz jb nc b gy nh ni l nj nk">import { createBrowserHistory } from 'history';</span><span id="f176" class="ng lz jb nc b gy np ni l nj nk">const history = createBrowserHistory();</span><span id="eaf8" class="ng lz jb nc b gy np ni l nj nk">export default history;</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="ec2d" class="ly lz jb bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">配置路由器</h1><p id="a045" class="pw-post-body-paragraph jy jz jb ka b kb mw kd ke kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv ij bi translated">现在我们需要配置我们的路由器，我们在<code class="fe nl nm nn nc b">./src/App.js</code>里面。我们将导入三个文件:</p><ul class=""><li id="352c" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv no lc ld le bi translated"><strong class="ka jc">路由器</strong> →该组件将执行重定向。</li><li id="05d5" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv no lc ld le bi translated"><strong class="ka jc">历史</strong> →将负责允许我们在应用程序中进行重定向，而无需用户在浏览器中键入路径。</li><li id="39fa" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv no lc ld le bi translated"><strong class="ka jc"> Routes </strong> →我们的Routes文件将根据我们通知的路径返回其中一页。</li></ul><p id="4719" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们只需要将路由器放在Routes组件周围，我们的应用程序导航就可以工作了！</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="de36" class="ng lz jb nc b gy nh ni l nj nk">import React from 'react';<br/>import { Router } from 'react-router-dom';</span><span id="972d" class="ng lz jb nc b gy np ni l nj nk">import history from './services/history';<br/>import Routes from './routes';</span><span id="b980" class="ng lz jb nc b gy np ni l nj nk">function App() {<br/>  return (<br/>    &lt;Router history={history}&gt;<br/>      &lt;Routes /&gt;<br/>    &lt;/Router&gt;<br/>  );<br/>}</span><span id="a63a" class="ng lz jb nc b gy np ni l nj nk">export default App;</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="6a7c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的应用程序中有一些我们不想在用户登录之前访问的路径是很常见的，这样我们就可以检索他的信息。到目前为止，我们所做的让用户访问他想要的任何路线，因为他输入了正确的路径。</p><p id="81a2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是创建我们自己的路由组件的时候了，这是我们在本文开头提到的。</p><p id="5db0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个文件中，我们将有一个名为RouteWrapper的功能组件(这个名字不是Route，因为我们将使用来自<strong class="ka jc"> react-router-dom的<code class="fe nl nm nn nc b">Route</code>和<code class="fe nl nm nn nc b">Redirect</code>。</strong></p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="d3e3" class="ng lz jb nc b gy nh ni l nj nk">import React from 'react';<br/>import { Route, Redirect } from 'react-router-dom';</span><span id="61d0" class="ng lz jb nc b gy np ni l nj nk">export default function RouteWrapper() {}</span></pre><p id="db2a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是向我们的新组件导入一些属性:</p><ul class=""><li id="bba9" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv no lc ld le bi translated"><strong class="ka jc">组件</strong> →这里我们将接收我们想要呈现的页面，由我们的文件索引发送。</li><li id="665d" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv no lc ld le bi translated"><strong class="ka jc"> isPrivate </strong> →该属性将用于指示该路由是否可以在没有认证的情况下被访问。</li><li id="cbf4" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv no lc ld le bi translated"><strong class="ka jc"> …rest </strong> →这里我们将使用spread操作符将组件收到的所有其他参数传递给rest变量。</li></ul><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="4251" class="ng lz jb nc b gy nh ni l nj nk">import React from ‘react’; <br/>import { Route, Redirect } from ‘react-router-dom’; </span><span id="4595" class="ng lz jb nc b gy np ni l nj nk">export default function RouteWrapper({ <br/>  component: Component, <br/>  isPrivate, <br/>  …rest <br/>}) {}</span></pre><p id="598d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经导入了所有必要的道具，我们需要添加重定向逻辑。我们将有一个名为<code class="fe nl nm nn nc b">signed</code>的变量，它将指示用户是否登录到系统(这个变量现在将有一个常量值，但是以后<strong class="ka jc"> redux </strong>可以用来存储这个状态)。</p><p id="b3af" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">业务逻辑将是:</p><ol class=""><li id="6d63" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">如果路由是私有的，并且用户没有登录，那么我们将把他送回登录页面。</li><li id="30d5" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果路由不是私有的，但是用户已经登录，那么我们把他发送到主页面，在我们的例子中就是仪表板页面。</li><li id="3290" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果他不满足上述任何条件，那么我们从<strong class="ka jc"> react-router-dom </strong>返回一个<code class="fe nl nm nn nc b">ROute</code>，传递组件和所有其他参数。</li></ol><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="e036" class="ng lz jb nc b gy nh ni l nj nk">import React from 'react'; <br/>import { Route, Redirect } from 'react-router-dom';  </span><span id="e21c" class="ng lz jb nc b gy np ni l nj nk">export default function RouteWrapper({   <br/>  component: Component,   <br/>  isPrivate,   <br/>  ...rest <br/>}) {   <br/>  const signed = true;    <br/>  <br/>  /**    <br/>  * Redirect user to SignIn page if he tries to access a private      route<br/>  * without authentication.    <br/>  */   <br/>  if (isPrivate &amp;&amp; !signed) {     <br/>    return &lt;Redirect to="/" /&gt;;   <br/>  }    </span><span id="b825" class="ng lz jb nc b gy np ni l nj nk">  /**    <br/>  * Redirect user to Main page if he tries to access a non private route    <br/>  * (SignIn or SignUp) after being authenticated.    <br/>  */   <br/>  if (!isPrivate &amp;&amp; signed) {     <br/>    return &lt;Redirect to="/dashboard" /&gt;;   <br/>  }    <br/>  <br/>  /**    <br/>  * If not included on both previous cases, redirect user to the desired route.    <br/>  */   <br/>  return &lt;Route {...rest} component={Component} /&gt;; <br/>}</span></pre><p id="0a2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成我们的组件，我们需要添加PropTypes验证。第一步是安装库:</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="ff02" class="ng lz jb nc b gy nh ni l nj nk">yarn add prop-types</span></pre><p id="148b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们只需要导入并进行必要的验证。我们的组件将是这样的:</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="6ee0" class="ng lz jb nc b gy nh ni l nj nk">import React from 'react';<br/>import PropTypes from 'prop-types';<br/>import { Route, Redirect } from 'react-router-dom';</span><span id="060d" class="ng lz jb nc b gy np ni l nj nk">export default function RouteWrapper({<br/>  component: Component,<br/>  isPrivate,<br/>  ...rest<br/>}) {<br/>  const signed = true;</span><span id="7bc5" class="ng lz jb nc b gy np ni l nj nk">  /**<br/>   * Redirect user to SignIn page if he tries to access a private route<br/>   * without authentication.<br/>   */<br/>  if (isPrivate &amp;&amp; !signed) {<br/>    return &lt;Redirect to="/" /&gt;;<br/>  }</span><span id="6c2e" class="ng lz jb nc b gy np ni l nj nk">  /**<br/>   * Redirect user to Main page if he tries to access a non private route<br/>   * (SignIn or SignUp) after being authenticated.<br/>   */<br/>  if (!isPrivate &amp;&amp; signed) {<br/>    return &lt;Redirect to="/dashboard" /&gt;;<br/>  }</span><span id="eba4" class="ng lz jb nc b gy np ni l nj nk">  /**<br/>   * If not included on both previous cases, redirect user to the desired route.<br/>   */<br/>  return &lt;Route {...rest} component={Component} /&gt;;<br/>}</span><span id="0ac2" class="ng lz jb nc b gy np ni l nj nk">RouteWrapper.propTypes = {<br/>  isPrivate: PropTypes.bool,<br/>  component: PropTypes.oneOfType([PropTypes.element, PropTypes.func])<br/>    .isRequired,<br/>};</span><span id="3ea7" class="ng lz jb nc b gy np ni l nj nk">RouteWrapper.defaultProps = {<br/>  isPrivate: false,<br/>};</span></pre><p id="d03a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是更改我们在<code class="fe nl nm nn nc b">./src/routes/index.js</code>中使用的路由组件，以便它使用我们的组件，而不是来自<strong class="ka jc"> react-router-dom </strong>的组件:</p><pre class="ll lm ln lo gt nb nc nd ne aw nf bi"><span id="e2a2" class="ng lz jb nc b gy nh ni l nj nk">import React from 'react';<br/>// import { Switch, Route } from 'react-router-dom';<br/>import { Switch } from 'react-router-dom';<br/>import Route from './Route';<br/></span><span id="6ff2" class="ng lz jb nc b gy np ni l nj nk">// rest of the code ommitted.</span></pre><p id="6bcd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！如果你遵循所有这些步骤，你应该有非常模块化的代码，可以很容易地扩展，如果你继续使用相同的模式。</p><p id="6509" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，认证仍然是手动的，我们将在以后的文章中介绍这部分的自动化。</p><p id="0338" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在codesandbox上查看完整的实现！</p><figure class="ll lm ln lo gt is"><div class="bz fp l di"><div class="nq lq l"/></div></figure><p id="e5e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我有另一个帖子，我继续这个应用程序添加可重复使用的布局。如果你想把它添加到你的项目中，勾选这个<a class="ae lk" href="https://medium.com/@giovanniantonaccio/how-to-build-reusable-layouts-in-react-js-daf8adcbca79" rel="noopener">链接</a>。</p><p id="728f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇教程能对你的项目有所帮助！感谢阅读！</p></div></div>    
</body>
</html>