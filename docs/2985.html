<html>
<head>
<title>Node.js Best Practices — Profile, Watch, and Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—配置文件、观察器和请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-best-practices-profile-watch-and-requests-4f657b02c2ec?source=collection_archive---------1-----------------------#2020-08-15">https://javascript.plainenglish.io/node-js-best-practices-profile-watch-and-requests-4f657b02c2ec?source=collection_archive---------1-----------------------#2020-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ad607433c013793a27e580c4a37db8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zjLyWfBI4pLlYTiA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@johntorcasio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">John Torcasio</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="51ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="6a28" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用节点的内置分析器</h1><p id="fbe5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Node自带分析器，让我们可以观察应用程序的性能。</p><p id="0040" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们只需在运行应用程序时添加<code class="fe me mf mg mh b">--prof</code>选项:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="820a" class="mq lc iq mh b gy mr ms l mt mu">node --prof app.js</span></pre><p id="0747" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过运行以下命令来处理由此输出的tick文件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d941" class="mq lc iq mh b gy mr ms l mt mu">node --prof-process isolate-0x???????-v8.log</span></pre><p id="484e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以读取tick文件的处理结果。</p><p id="5f65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个<code class="fe me mf mg mh b">[Summary]</code>部分包含来自概要分析的数据。</p><p id="2478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包括运行哪种代码，如库代码和非库代码。</p><p id="dea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还显示了代码是用什么语言编写的。</p><h1 id="5974" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用代码更改监视器自动重启节点应用程序</h1><p id="d8f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了使开发节点应用程序更容易，我们应该使用代码更改监视器。</p><p id="d34f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了它们，当我们更改代码文件时，应用程序会重新启动。</p><p id="507f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个软件包可以做到这一点。</p><p id="4cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中一个是Nodemon。</p><p id="ee7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4483" class="mq lc iq mh b gy mr ms l mt mu">npm install -g nodemon</span></pre><p id="1474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">nodemon</code>而不是<code class="fe me mf mg mh b">node</code>来运行我们的应用程序。</p><p id="6623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个实现这个功能的包是Forever。</p><p id="f087" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de54" class="mq lc iq mh b gy mr ms l mt mu">npm install -g forever</span></pre><p id="f1fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们开始运行我们的应用程序:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9500" class="mq lc iq mh b gy mr ms l mt mu">forever start app.js</span></pre><p id="6f7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一些选项，比如将日志附加到文件而不是stdout，将进程ID保存到文件，等等。</p><p id="3e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Node-supervisor是我们可以使用的另一个包。</p><p id="507c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="05b1" class="mq lc iq mh b gy mr ms l mt mu">npm install -g supervisor</span></pre><p id="792a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有几个选项来改变它的行为，比如出错时不重启，等等。</p><h1 id="d565" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正确使用Node.js中的日志记录</h1><p id="b9f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">console.log</code>有几个问题。</p><p id="8527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们建立了我们的应用程序，我们必须删除它们，以避免污染我们的日志文件。</p><p id="76de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们没有过滤它们的选项。</p><p id="e980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的替代方法是使用<code class="fe me mf mg mh b">debug</code>模块进行记录。</p><p id="45f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们需要通过编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c4a5" class="mq lc iq mh b gy mr ms l mt mu">const debug = require('debug')('my-app');</span></pre><p id="6d54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">'my-app'</code>是我们的应用程序名称。</p><p id="e395" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">debug</code>函数记录事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a9c9" class="mq lc iq mh b gy mr ms l mt mu">debug("hello world", someVar, someOtherVar);</span></pre><p id="3f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将任何想要的东西传递给函数来记录它们。</p><p id="37a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在运行应用程序时打开调试消息，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3c17" class="mq lc iq mh b gy mr ms l mt mu">DEBUG=my-app node app.js</span></pre><p id="b834" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们需要时，<code class="fe me mf mg mh b">DEBUG</code>的值应该匹配我们传入的名字。</p><p id="0c48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序实例的名称也可以有命名空间:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="511f" class="mq lc iq mh b gy mr ms l mt mu">const debug = require("debug")("my-app:startup");</span></pre><p id="a029" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以精确地区分每个级别的调试。</p><p id="261e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c909" class="mq lc iq mh b gy mr ms l mt mu">DEBUG=my-app:startup node app.js</span></pre><p id="9fb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录启动消息和:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6872" class="mq lc iq mh b gy mr ms l mt mu">DEBUG=my-app:* node app.js</span></pre><p id="a504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录命名空间中的所有消息。</p><h1 id="8485" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正确使用承诺</h1><p id="cea0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该避免每次提出要求时都做出新的承诺。</p><p id="9d0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以将它放在一个函数中并重用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="83a0" class="mq lc iq mh b gy mr ms l mt mu">const axios = require('axios');</span><span id="693e" class="mq lc iq mh b gy mv ms l mt mu">const makeRequest = (options) =&gt; {<br/>  return axios(options)<br/>};</span><span id="9577" class="mq lc iq mh b gy mv ms l mt mu">const getRequest = (url) =&gt; {<br/>  const options = {<br/>    method: "GET",<br/>    url<br/>  };<br/>  return makeRequest(options);<br/>};</span><span id="4adf" class="mq lc iq mh b gy mv ms l mt mu">const getProfile = (profileId) =&gt; {<br/>  return getRequest(`/profile/${profileId}`);<br/>};</span></pre><p id="4382" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向Axios发出请求，它返回一个承诺。</p><p id="1e05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以为所有请求重用通用请求代码。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/17731fce32e4b7a6edd85bbae2f294f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N7RiatBidUAlSZVr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bradleyziffer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bradley Ziffer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7c84" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2eaf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用内置的分析器来分析我们的应用程序。</p><p id="e8fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，当代码发生变化时，我们可以使用包来重启我们的应用程序。</p><p id="0965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">debug</code>模块适合记录调试消息。</p><p id="c174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建一个公共函数来处理所有的HTTP请求。</p><h2 id="3c5e" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="2d8a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>