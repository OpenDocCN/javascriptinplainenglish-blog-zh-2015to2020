<html>
<head>
<title>Escape Loading State Hell In Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Redux中逃离加载状态地狱</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/escape-loading-hell-in-redux-dce0ac67191d?source=collection_archive---------1-----------------------#2020-11-26">https://javascript.plainenglish.io/escape-loading-hell-in-redux-dce0ac67191d?source=collection_archive---------1-----------------------#2020-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ffc55a499c3f01d51293ff0c8b071705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F_actFBYSBi6ZnKm"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@alexandar_todov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexandar Todov</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8dc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名使用API的React开发人员，您可能必须处理请求的加载和错误状态。在处理较小的应用程序时，处理加载状态不是一个大问题。然而，对于较大的应用程序，事情会变得很复杂。迟早您的Redux存储可能会变成加载状态地狱，这可能非常难以维护。在参与了几个大型项目之后，我提出了一个健壮的加载和错误状态处理机制，可能对您有用。</p><h1 id="e746" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">加载和错误状态的最简单方法</h1><p id="cf8c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">当你设计你的减速器时，你想要处理装载状态，你很可能会得到这样的代码。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fdbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码非常简单。只有三个动作。一个通常在请求开始时分派，另外两个在请求结束时分派。成功或出错。<strong class="kc io">当您想要在同一个reducer中处理多个请求动作时，这种方法的问题就开始出现了。</strong>为了演示这个问题，让我们继续尝试给我们的减速器添加更多的动作。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1f4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你能看出这段代码的问题吗？想象一个场景，其中<em class="mh"> get todos </em>请求被启动，并且动作<code class="fe mi mj mk ml b">GET_TODOS_STARTED </code>被分派。加载状态被设置为<code class="fe mi mj mk ml b">true</code>，我们的UI可能会显示一个加载微调器。现在假设这个请求需要一些时间来完成。在此期间，您希望向列表中添加另一个待办事项，因此您启动<em class="mh"> create todo </em> request <em class="mh">，</em>和action <code class="fe mi mj mk ml b">CREATE_TODO_STARTED </code>将被调度，UI将显示另一个加载微调器。现在我们有了两个依赖于单个加载状态的加载微调器，加载状态由两个请求控制。如果其中一个完成，两个加载微调器都会消失，我们的UI将处于不一致的状态。正如我已经提到的，问题在于多个请求共享的加载状态。这个问题的一个可能的解决方案是为每个请求创建一个新的加载状态。通过这样做，您的代码可以如下所示。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="47cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能已经注意到了，我们不能用这种方法走很远。随着需要处理的请求动作越来越多，我们的reducer将会因负载状态而变得臃肿。为了处理这个问题，我们必须想出一个更稳健的解决方案。</p><h1 id="445e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">加载和错误状态地狱的更健壮的解决方案</h1><p id="8626" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们知道，我们想要一个更好的解决方案，理想情况下，我们不想用加载状态代码污染我们的减压器。我们要做的第一件事是创建一个单独的减速器来管理装载的东西。正如我们已经知道的，我们希望每个请求都有一个单独的状态，因此，我们自然可以将这些加载状态存储在数组中。这个数组将代表我们应用程序中的所有活动请求。在这种情况下，活动请求是处于加载状态或错误状态的请求。如果请求以错误结束，我们将此请求视为活动请求，并将其存储在数组中，直到我们处理此错误。请求处理缩减器可能是这样的。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="16fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查看这段代码，您可能会注意到，我们在这个缩减器中处理的动作与我们在第一个版本的<code class="fe mi mj mk ml b">TodoReducer</code>中看到的非常相似。他们的名字只是更一般化。他们的处理方式也非常相似。我们还不知道数组中的哪个加载状态属于哪个请求。为了解决这个问题，我们可以在应用程序中为每个请求指定一个唯一的名称。例如，如果我们有一个请求<code class="fe mi mj mk ml b">GET /api/todos</code>我们将其命名为<code class="fe mi mj mk ml b">getTodos</code>。我们可以将所有这些请求名称存储在类似于enum的结构中，代码如下所示。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7999" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们有了一个解决方案来识别我们的请求。让我们重温一下我们的<code class="fe mi mj mk ml b">RequestReducer</code>并实现动作处理。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7b21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mi mj mk ml b">REQUEST_FINISHED</code>处理行动相当简单。如果一个请求完成，我们将按其名称从请求数组中删除该请求。<br/>当我们处理动作<code class="fe mi mj mk ml b">REQUEST_STARTED</code>时，我们必须检查活动请求数组中是否有同名的请求。如果是这样，我们只需要用正确的加载状态更新这个请求，并且清除它的错误状态。如果请求不在数组中，我们只需将其添加到数组中。<br/>最后，在处理<code class="fe mi mj mk ml b">REQUEST_FAILED</code>时，我们想更新活动请求数组中的请求状态，所以我们改变了它的加载状态和错误状态。<br/>现在我们已经完成了要求的减速器。然而，要在UI中使用请求状态，我们需要知道如何解释这个缩减器状态的选择器。我们需要三个选择器。一个用于获取特定请求的加载状态，一个用于同时获取多个请求的加载状态，一个用于获取错误状态。这是我们的三个选择器。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="086e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将加载机制集成到应用程序的其余部分</h1><p id="8d0c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在我们有了可以集成到新的或现有的应用程序中的工作的Redux代码。在下一节中，我将向您展示如何这样做。<br/>让我们从助手函数开始，它将处理调度请求动作。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="cee5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数只是处理请求动作流的一个例子。例如，您可以在异步thunk中使用这个helper函数。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="69e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步，我们需要实现动作创建器，所以让我们开始吧。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6472" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，让我们在React组件中使用Redux代码来演示这种加载和错误处理机制是如何工作的。在这个例子中，我使用react-redux库的connect API，但是您也可以使用hooks API。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="fff0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="a15e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本教程中，我们为加载和错误状态处理创建了一个健壮的Redux机制。我们从一个非常简单的解决方案开始，我们将其重构为一个更易于使用和扩展的解决方案。如果你对如何改进这个解决方案有任何问题或建议，请在评论区告诉我。对我来说，这是一个非常重要的话题，所以如果你也分享你的建议或解决方案，我会很高兴。</p></div></div>    
</body>
</html>