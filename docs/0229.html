<html>
<head>
<title>The only introduction to Redux (and React-Redux) you’ll ever need</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要的关于Redux(和React-Redux)的唯一介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-only-introduction-to-redux-and-react-redux-youll-ever-need-8ce5da9e53c6?source=collection_archive---------0-----------------------#2019-08-30">https://javascript.plainenglish.io/the-only-introduction-to-redux-and-react-redux-youll-ever-need-8ce5da9e53c6?source=collection_archive---------0-----------------------#2019-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f159ca951fe65833fdf6917c22e3b03c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81uqJUFs_dNwijDAUtAo1A.png"/></div></div></figure><p id="6158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文旨在通过构建三个非常简单的应用程序，通过理论和示例尽可能简单明了地解释Redux和React Redux的基本概念。<br/>它分为三部分——单独Redux、类组件的React-Redux和功能组件的React-Redux:</p><ol class=""><li id="1bc7" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在第一部分中，我们将看看动作、Reducers和Redux中的存储。然后，我们将在一个简单的普通JavaScript应用程序中实现Redux。<br/>最后，我们将讨论初始化我们的应用程序状态，以及用Redux DevTools浏览器扩展连接我们的应用程序。</li><li id="d986" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在第二部分中，我们将使用类组件在React中实现相同的Redux应用程序，并了解React-Redux，这个包允许我们从React组件连接Redux。</li><li id="137c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在第三部分中，我们将做与第二部分相同的实现，但是使用功能组件，利用React-Redux包提供的钩子。这一部分中构建的应用程序作为Git分支添加到第二个应用程序中。</li><li id="9ec3" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后，有一个额外的部分讨论了Redux中中间件和异步操作的概念。但是，在那里编写的代码不会包含在两个GitHub项目中的任何一个中。</li></ol><p id="edad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub链接到这两个项目:</p><ul class=""><li id="7e85" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated"><a class="ae ll" href="https://github.com/hstevanoski/redux-notes-app" rel="noopener ugc nofollow" target="_blank">首次申请(用香草JS还原)</a></li><li id="4290" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated"><a class="ae ll" href="https://github.com/hstevanoski/react-redux-notes-app" rel="noopener ugc nofollow" target="_blank">带有类组件的第二个应用程序(与Redux反应)</a></li><li id="3f0e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated"><a class="ae ll" href="https://github.com/hstevanoski/react-redux-notes-app/tree/hooks" rel="noopener ugc nofollow" target="_blank">第三个应用(与Redux反应)带有功能组件</a></li></ul><p id="3a23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注:</strong></p><ul class=""><li id="e295" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">在这三个部分中，我将假设您对JavaScript和EcmaScript 6+有很好的理解</li><li id="7c01" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">在整个第一部分中，我将假设您以前使用过NodeJS(并且在您的计算机上安装了NodeJS和NPM ),并且至少知道什么是Webpack和Babel。</li><li id="5aa4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">在整个第二部分中，我将假设您习惯于在React中构建比ToDo应用程序更复杂的应用程序，并且知道什么是<a class="ae ll" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">hoc(高阶组件)</a>。</li><li id="e373" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">在整个第三部分中，我将假设您至少理解React钩子的概念。如果你不做，<a class="ae ll" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">让</a>确定<a class="ae ll" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank">你做</a>。</li><li id="0952" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">为了使一切尽可能简单，我们将不写任何样式。我知道当有人毫无理由地一次扔给你一堆不必要的东西，让你感到困惑的时候是什么感觉。<br/>然而，在应用二和应用三中提供了一个<em class="lm"> src/index.css </em>。所以，如果你想让你的应用看起来更漂亮，取消<em class="lm"> index.js </em>中相应行的注释来包含它。</li><li id="7284" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">我不会强制使用任何Redux浏览器扩展。我们将在文章第一部分的末尾简要介绍一下Redux DevTools扩展，但是我强烈建议您更加熟悉它，因为您将会希望在几乎所有的项目中使用它。</li><li id="25ca" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">我不会拿Redux和Flux之类的类似库做比较。如果你对这类话题感兴趣，可以考虑自己研究一下。</li></ul><p id="370f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我不希望这是另一个ToDo教程(我自己也厌倦了ToDo教程，它就像Hello World v2.0)，所以我们将制作一个写笔记的应用程序，用户可以在其中为每个笔记指定标题和内容。</p><p id="5d33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事不宜迟，让我们开始学习吧！</p><h1 id="c626" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第一部分— Redux</h1><p id="af3c" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">Redux是一个流行的JavaScript库，用于管理应用程序的状态。这很常见，如果你正在使用React，很可能你已经听说过了。</p><p id="e089" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于那些不知道什么是应用程序状态的人来说:它就像一个全局对象，保存着您在应用程序中稍后用于各种目的的信息(例如，决定呈现哪些组件以及何时呈现，呈现存储的数据等)。</p><p id="a57d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们经常遇到的一个例子是在页面加载时显示一个加载指示器。在这种情况下，如果我们仅将存储用于该目的，则状态对象将存储一个布尔字段，表示页面是否已加载，我们将使用该字段来切换加载指示器的显示。</p><p id="3146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子是——如果我们要构建一个社交媒体应用程序，我们将在应用程序状态中存储几个对象和数组——当前用户信息、HTTP状态、toast消息、用户将收到的通知，以及是否要在整个应用程序的多个位置呈现——用户关注的个人资料中的当前帖子和故事，等等。</p><p id="c9ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于哪些数据应该保存在Redux中，没有任何规则，所以，这完全取决于您。但是，请记住始终只存储<a class="ae ll" href="https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state" rel="noopener ugc nofollow" target="_blank">可串行化数据</a>。</p><p id="e9e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大型应用程序有大型应用程序状态，随着应用程序的增长，管理它们变得越来越不方便。此外，您可能有使用相同数据的组件，但是它们被随机放置在DOM树中。这就是为什么我们需要像Redux这样的状态管理库。</p><p id="bb77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux的工作方式令人着迷，但又如此简单。它的模式非常直观，它的函数名不言自明。相信我，你会爱上它的！</p><p id="bea5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们深入研究Redux之前，我想提一下Redux遵循的两个重要模式(我强烈建议您在编写Redux应用程序时始终牢记这些信息！):</p><p id="a4f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux遵循的一种模式被称为“真实的单一来源”，这意味着我们只有一个地方(称为Store)来存储整个应用程序的唯一状态。换句话说，一个应用——一个商店——一个状态。</p><p id="b144" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，React或其他框架中的组件也可以自由地包含它们自己的内部状态。通常，你不会想把所有东西都放在应用程序状态中。</p><p id="fa3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux遵循的另一个模式叫做“不变性”。你会经常在其他框架和库中发现这个术语。<br/>简而言之，不变性就是我们不直接改变状态对象及其属性。相反，我们创建一个新对象，重新计算新的应用程序状态，并用新创建的对象更新它。我们想让旧的状态对象保持不变。</p><h2 id="ccf7" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">Redux的三个组成部分</h2><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/b10497de449b6992c379421fb438bb2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyLgf2qDp28sM6lr5g0q8Q.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The three building blocks of Redux — Actions, Reducers and Store</figcaption></figure><p id="8f19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux有3个主要部分:</p><ol class=""><li id="f01b" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">行动</li><li id="9e05" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">还原剂</li><li id="7b97" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">商店</li></ol><h2 id="bac2" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated"><strong class="ak">商店</strong></h2><p id="38d3" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">正如您已经猜到的，存储保存了应用程序的状态。<br/>商店实际上是一个对象，而不是一个类，尽管一开始可能感觉像一个类。除了应用程序的状态之外，它还包含一些额外的东西(比如函数和其他对象)。</p><p id="2d22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管从理论上讲，创建多个存储是可能的，但这违背了Redux遵循的模式。<br/>请记住，我们只为每个应用程序创建一个商店！</p><p id="d784" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以订阅在商店更新时收听事件。例如，在非React应用程序中，我们可以使用该订阅来更新UI，就像我们在应用程序中将要做的那样。</p><p id="ad09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux中的状态是JavaScript对象的形式，通常被称为“状态树”。你可以把你想存储的任何值放在里面，你可以根据需要嵌套它们。</p><h2 id="f29d" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated"><strong class="ak">动作</strong></h2><p id="327b" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">动作是普通的JavaScript对象，描述<strong class="ka ir">发生了什么</strong>发生了什么，但是不描述应用状态如何变化。</p><p id="768c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我们想要更新应用程序的状态时，我们只需将它们分派(发送)到我们的store实例。其余的由减速器处理，我们一会儿就会熟悉它。</p><p id="d96b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要记住的一件重要事情是，Redux要求我们的动作对象包含一个类型字段。该字段用于描述我们正在调度的操作类型，它通常应该是一个从文件中导出的常量。<br/>动作对象中的所有其他字段都是可选的，由您决定。</p><p id="99f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:在我们将要构建的应用程序中，每当用户点击“添加注释”按钮时，我们将向我们的商店发送类似于以下操作的内容:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="308c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们不处理任何关于存储如何变化的逻辑。我们只是通知商店，我们想用提供的标题和内容添加一个新注释。<br/>标题和内容字段是可选的。类型字段也是必需的。</p><p id="cffe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你经常会遇到的另一个术语是<strong class="ka ir">动作创作者</strong>。它们基本上是生成并返回普通JavaScript对象的函数。使用它们是为了让我们可以在动作中“插入”动态数据(或者用动态数据生成动作)。在我们的例子中——我们有一个接受两个参数的函数——title和content，它将返回一个包含我们提供的信息的普通JavaScript对象。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">An action creator example</figcaption></figure><h2 id="0fe5" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated"><strong class="ak">减速器</strong></h2><p id="9e50" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">Reducers是<strong class="ka ir">纯</strong>函数，它定义了<strong class="ka ir">app状态如何变化。换句话说，它们用于重新计算新的应用程序状态，或者至少是它的一部分。</strong></p><p id="2711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我们向我们的商店发送一个动作时，这个动作就会被传递给reducer。<br/>reducer函数接受两个参数:前一个应用程序状态、正在调度的动作，并返回新的应用程序状态。</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="fd5f" class="mq lo iq no b gy ns nt l nu nv">(previousState, action) =&gt; newState</span></pre><p id="8cfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，reducer将根据我们调度的动作(及其类型)来计算我们的应用程序的新状态。</p><p id="173c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在实际应用中，你的reducers很可能会变得非常复杂。为了处理reducer的复杂性，我们将它们分成多个更简单的reducer，然后，我们将它们与一个名为<code class="fe nw nx ny no b">combineReducers</code>的Redux辅助函数结合起来。</p><p id="0467" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主减速器习惯上称为“根部减速器”。</p><h2 id="effe" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">数据流</h2><p id="3aa6" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">虽然一开始看起来有点复杂，但Redux中的数据流实际上非常简单。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/e3a4e15b17ea99b678dc182e496e32c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZQ8FPvJWhRBXOEd3n9Yhw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Data flow in Redux</figcaption></figure><p id="a097" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设用户触发了一个事件(例如，点击“添加注释”按钮)，应用状态更新(即，新的注释被插入到应用状态中)。下面是引擎盖下发生的事情:</p><ol class=""><li id="f440" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">按钮点击处理函数<em class="lm">用<code class="fe nw nx ny no b">store.dispatch()</code>方法向商店发送</em>动作</li><li id="adb9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">Redux将分派的动作传递给reducer</li><li id="beba" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">存储保存由缩减器返回的新状态</li><li id="6d70" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">由于我们已经向商店<em class="lm">订阅了</em>，我们提供的函数将被调用，它将相应地更新UI(即，在笔记列表中添加新的笔记)</li></ol><h2 id="91f8" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">设置我们的应用程序</h2><p id="fd19" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">现在让我们开始创建我们的第一个应用程序。</p><ul class=""><li id="9491" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">如果你在Linux或Mac上，只需导航到你的项目目录并粘贴到终端中。它将省去您手动创建所有必要文件和文件夹的麻烦:</li></ul><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="59b6" class="mq lo iq no b gy ns nt l nu nv">mkdir -p redux-notes-app/{dist,src/{actions,reducers,store}} &amp;&amp; cd redux-notes-app &amp;&amp; touch {index.html,.babelrc,webpack.config.js,src/{actions/actions.js,reducers/reducers.js,store/store.js,main.js}}</span></pre><ul class=""><li id="24f3" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">如果您使用的是Windows，请手动创建必要的文件和文件夹，并确保您的文件夹结构与我的相同:</li></ul><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b2995f7549c697c85ec55e01e3902153.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*Eec7SVfNpcMSOKo6yUNhIQ.png"/></div></figure><ul class=""><li id="9e67" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">在新项目的目录中运行以下命令:</li></ul><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="3237" class="mq lo iq no b gy ns nt l nu nv">npm init -y</span><span id="552f" class="mq lo iq no b gy oa nt l nu nv">npm i redux webpack webpack-cli @babel/core babel-loader @babel/preset-env --save-dev</span><span id="a7fa" class="mq lo iq no b gy oa nt l nu nv">// --- Yarn alternative --- //</span><span id="f92d" class="mq lo iq no b gy oa nt l nu nv">yarn init -y</span><span id="3631" class="mq lo iq no b gy oa nt l nu nv">yarn add redux webpack webpack-cli @babel/core babel-loader @babel/preset-env --dev</span></pre><ul class=""><li id="9ddf" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">在<code class="fe nw nx ny no b">webpack.config.js</code>文件里面插入以下内容</li></ul><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The webpack.config.js file</figcaption></figure><ul class=""><li id="3dfd" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">在<code class="fe nw nx ny no b">.babelrc</code>文件中，添加以下内容</li></ul><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The .babelrc file</figcaption></figure><ul class=""><li id="e371" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">在<code class="fe nw nx ny no b">package.json</code>文件中，在脚本对象中添加下面一行</li></ul><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="ad44" class="mq lo iq no b gy ns nt l nu nv">"dev": "webpack --watch --mode=development"</span></pre><ul class=""><li id="1727" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">最后，跑</li></ul><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="99a8" class="mq lo iq no b gy ns nt l nu nv">npm run dev<br/>// or, yarn run dev</span></pre><p id="72ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们言归正传！</p><h2 id="4ce3" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">定义我们的应用状态</h2><p id="3fe2" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在你开始写代码之前，最好拿一张纸，写下你的应用程序的所有特性，画出所有东西是如何相互连接的，并试着找出你在应用程序状态中需要什么，以及应用程序状态最终应该是什么样子。</p><p id="ce9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，不要直接写代码，而是做一些计划！</p><blockquote class="ob oc od"><p id="f393" class="jy jz lm ka b kb kc kd ke kf kg kh ki oe kk kl km of ko kp kq og ks kt ku kv ij bi translated">“你花在计划上的每一分钟，在执行上就节省了10分钟；这给了你1000%的能量回报！”—布莱恩·特雷西</p></blockquote><p id="c859" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们假设我们的应用程序状态如下所示:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="0708" class="mq lo iq no b gy ns nt l nu nv">{<br/>  notes: [<br/>    {<br/>      title: 'Note 1 Title',<br/>      content: 'Note 1 Content'<br/>    },<br/>    {<br/>      title: 'Note 2 Title',<br/>      content: 'Note 2 Content'<br/>    },</span><span id="a738" class="mq lo iq no b gy oa nt l nu nv">    ...<br/>    <br/>    {<br/>      title: 'Note N Title',<br/>      content: 'Note N Content'<br/>    }<br/>  ]<br/>}</span></pre><p id="a5b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">notes数组中的每个对象代表一个音符。</p><p id="9539" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，我们的应用程序状态将是一个非常简单的对象，只包含一个属性notes，它将是一个对象数组(单个的notes)。<br/>由于我们没有使用API，我们将假设注释的ID将是它们在数组中的索引——因此在最终的注释格式中缺少ID字段。</p><h2 id="0c78" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">初始代码</h2><p id="fc38" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我已经准备了一些我们的应用程序需要的初始代码。在您的<code class="fe nw nx ny no b">index.html</code>文件中插入以下代码:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">index.html</figcaption></figure><p id="06a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在将这段代码插入到您的<code class="fe nw nx ny no b">src/main.js</code>文件中:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">stc/main.js</figcaption></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/97689833c7af405a394751258e0615e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*NWOmsT2_4MoRuUevioicqg.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Result (our initial index page)</figcaption></figure><p id="2bc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们有一个非常简单的表单，只有标题和内容字段。<br/>此表将用于添加新注释。</p><p id="e18d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nw nx ny no b">ul#notes</code>是我们将所有笔记作为列表项呈现的地方。<br/>有一个硬编码的列表项作为我们笔记的模板，我们将立即从代码中删除它。</p><p id="0b24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将让用户通过按下笔记标题右侧的按钮来删除他们的笔记。按钮上的<code class="fe nw nx ny no b">data-id</code>属性将帮助我们获得将要删除的笔记的id(索引),从而让我们知道应该删除哪个笔记。</p><h2 id="3fa7" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">行动</h2><p id="cbf4" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">现在我们知道了要做什么，让我们开始创建一个添加注释的动作。<br/>在<code class="fe nw nx ny no b">actions.js</code>中，我们将添加我们的初始代码:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/actions/actions.js</figcaption></figure><p id="c518" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我一行一行地解释这是怎么回事:</p><ol class=""><li id="835a" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我们正在导出一个常量ADD_NOTE，因为我们以后会在几个地方需要它。<br/>是的，我们可以到处都写字符串‘ADD _ NOTE ’,但这是很糟糕的做法！想象一下，你的项目变得越来越大，突然你的老板说:“将ADD_NOTE操作重命名为ADD_NEW_NOTE”。明白我的意思了吗？</li><li id="1ea4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们正在导出函数<code class="fe nw nx ny no b">addNote</code>。正如我们前面所发现的，这个函数是一个动作创建器，这意味着它的工作只是返回一个普通的对象。注意，它没有任何逻辑。它只是返回一个对象。因为，正如我们之前所说，行动决定了改变了什么，而不是如何改变！</li></ol><p id="f775" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Redux关于动作的约定。<br/>这看起来可能有点奇怪，但是相信我，导出常量和动作创建器是最合理的方法。</p><h2 id="3d31" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">还原剂</h2><p id="0aaf" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在我们创建存储和开始调度操作之前，让我们首先创建我们的主(根)缩减器:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/reducers/reducers.js</figcaption></figure><p id="352c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们为我们的reducer声明了一个初始状态对象，在这个例子中，它变成了整个应用程序的状态，因为它是我们应用程序中唯一的reducer。</p><p id="9a4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像我们之前说过的，reducers接收两个参数——之前的状态和被调度的动作。我们正在检查动作类型，根据它的值，我们将返回新的状态。</p><p id="21a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住，我们<strong class="ka ir">从不</strong>直接修改状态！我们希望所有的reducers保持不变！<br/>注意，在我们所有的案例都用尽之后，我们简单地返回我们的应用程序状态(稍后会详细介绍，但这与Redux初始化有关)。</p><p id="1b1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注:</strong></p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="8913" class="mq lo iq no b gy ns nt l nu nv">case ADD_NOTE:<br/>  return {<br/>    notes: [<br/>      ...state.notes,<br/>      {<br/>        title: action.title,<br/>        content: action.content<br/>      }<br/>    ]<br/>  };</span></pre><p id="192a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们返回应用程序的整个新状态对象，我们<strong class="ka ir">假设</strong>notes属性是我们新状态的唯一<strong class="ka ir">属性。如果我们在先前的状态中有其他属性，它们将会丢失，因为我们没有保留它们。</strong></p><p id="3d49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您有其他属性，并且不希望它们被排除在新状态之外，请在notes属性之前或之后使用spread运算符:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="2f4d" class="mq lo iq no b gy ns nt l nu nv">case ADD_NOTE:<br/>  return {<br/>    <strong class="no ir">...state, // &lt;- like so<br/></strong>    notes: [<br/>      ...state.notes,<br/>      {<br/>        title: action.title,<br/>        content: action.content<br/>      }<br/>    ]<br/>  };</span></pre><p id="957d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一点:如果switch语句伤害了你的眼睛，你也可以使用if语句！然而，通常情况下，你会接触到switch语句，随着时间的推移，你会慢慢喜欢上它。</p><h2 id="e819" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">商店</h2><p id="aaaf" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">让我们现在创建我们的应用程序商店！</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/store/store.js</figcaption></figure><p id="7577" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux有这个<code class="fe nw nx ny no b">createStore</code>函数，它非常简单，一目了然——它用于创建应用程序商店。<br/>它接受<a class="ae ll" href="https://redux.js.org/api/store" rel="noopener ugc nofollow" target="_blank"> 3个参数</a>(后两个是可选的)，但是现在，我们将只使用第一个，它接受您的应用程序的根缩减器。</p><p id="02ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将把商店导入到我们的<code class="fe nw nx ny no b">main.js</code>文件中，并分派一些动作来查看我们的状态在添加一些注释前后的样子。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/main.js</figcaption></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4f0846ef312dd559498b43e27fa5603b.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*X98aunelHCCSvQPaKm6LwA.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Chrome DevTools console</figcaption></figure><h2 id="5303" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">添加注释</h2><p id="84ed" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">要添加新注释，我们只需在表单事件处理程序中添加3行:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/main.js</figcaption></figure><p id="c001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们所做的只是向我们的商店发送一个动作！我们的action creator对象返回一个对象，其中包含我们提供给它的标题和内容值，事实上这些内容是我们放入表单字段的内容。就是这样！</p><h2 id="a6e6" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">(重新)渲染注释</h2><p id="50dd" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">正如我们前面提到的，Redux中的store是一个对象。它有一个名为<code class="fe nw nx ny no b">subscribe</code>的函数，我们可以用它来订阅对状态树所做的更改，也就是说，每当我们向存储库发送一个动作时。<br/>我们将使用subscribe方法，并使用订阅来重新呈现我们的笔记。</p><p id="85ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>我们将简单地重新呈现无序列表中的所有音符。<br/>相反，如果你使用React、Angular或Vue这样的框架/库，可能会有一些优化的<a class="ae ll" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"> diffing算法</a>来计算需要更新的内容，让你不必像我们一样自己动手甚至完全重新渲染DOM中的内容。</p><p id="8e86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先要更新我们的<code class="fe nw nx ny no b">renderNotes</code>函数:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/main.js</figcaption></figure><p id="2520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在要订阅商店:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/main.js</figcaption></figure><p id="b971" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，回到你的页面，尝试添加一个新的笔记！感觉像魔术一样，不是吗？！</p><h2 id="a19e" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated"><strong class="ak">退订店铺</strong></h2><p id="3d00" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">如果你出于某种原因想要从商店退订，<code class="fe nw nx ny no b">store.subscribe</code>函数返回一个函数。因此，通过调用该函数，我们取消了对商店的订阅:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="2192" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">删除注释</h2><p id="87a6" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">首先，我们将转到我们的<code class="fe nw nx ny no b">actions.js</code>文件，添加一个新的常量和一个新的动作创建者。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/actions/actions.js</figcaption></figure><p id="66a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将转到我们的<code class="fe nw nx ny no b">reducers.js</code>文件，并向我们的switch语句添加一个新的case(记住还要导入<code class="fe nw nx ny no b">REMOVE_NOTE</code>)。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/reducers/reducers.js</figcaption></figure><p id="5724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将更新<code class="fe nw nx ny no b">main.js</code>中的<code class="fe nw nx ny no b">deleteNote</code>函数。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/main.js</figcaption></figure><p id="e46a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧啊。现在我们的用户可以删除笔记了。容易得很。</p><h2 id="c3ea" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">初始化状态</h2><p id="bc34" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在我们开始初始化我们的应用程序状态之前，明智的做法是再看一眼reducers并真正理解发生了什么:</p><p id="cdb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1) </strong>每个减压器都有自己的状态，可能与app状态不同(例如，您可能有多个减压器)。<br/>现在，因为我们只有一个归约器(根归约器)，它最终成为我们应用程序的状态。</p><p id="9b5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2) </strong>当Redux初始化我们的app时，它会在switch语句中发送一个不会满足我们任何cases的动作。<br/>事实上，如果我们在控制台中记录操作类型，这就是我们第一次访问页面时得到的结果:</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2aefe9e67a57c4b96d01c5431225a942.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*CDr1pSKCLU3M5CauF4ZIWQ.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Chrome DevTools console</figcaption></figure><p id="9ea2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们没有提供应用程序的初始状态，所以状态是未定义的，所以它默认为我们的<code class="fe nw nx ny no b">initialState</code>对象。</p><p id="b1db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你的应用程序很可能有不止一个缩减器，因为它们远比一个简单的笔记/待办事项应用程序复杂。<br/>在这种情况下，你会想要写多个reducers。</p><p id="69e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux提供了一个名为<code class="fe nw nx ny no b"><a class="ae ll" href="https://redux.js.org/api/combinereducers" rel="noopener ugc nofollow" target="_blank">combineReducers</a></code>的函数，它让我们可以组合多个减速器，并将它们传递给<code class="fe nw nx ny no b">createStore</code>函数，就像它们是一个减速器一样。</p><p id="a1ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的地方就在这里:<br/>在<code class="fe nw nx ny no b">combineReducers</code>函数内部，我们传递了一个reducers的对象。每个reducer处理它自己的应用程序状态部分(reducer现在不关心整个应用程序的状态)。Redux然后从对象的所有键和值构建应用程序的状态。</p><p id="0923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将在<code class="fe nw nx ny no b">src/reducers</code>目录中创建一个新文件<code class="fe nw nx ny no b">notesReducer.js</code>，我们将把<code class="fe nw nx ny no b">src/reducers/reducers.js</code>文件中的代码移动到该文件中，并对其进行一些修改:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/reducers/notesReducer.js</figcaption></figure><p id="aab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>我已经将第一个参数从state改为notes。由于我们的reducer将只管理notes，它将总是返回一个数组。其他任何一块状态都不会在减速器里传承！</p><p id="7398" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将添加另一个减速器。姑且称之为<code class="fe nw nx ny no b">visibilityFilter</code>。它将通过可见性处理过滤笔记。<br/> <strong class="ka ir">注意:</strong>因为这篇文章越来越大，我们不会为这部分写UI或者扩展可见性过滤器特性。那是你的家庭作业！<br/> <strong class="ka ir">提示:</strong>要利用可见性过滤器，一个选项是在您的注释对象中添加一个<code class="fe nw nx ny no b">tags</code>字段。然后，您可以添加几个标签(例如存档的和重要的)，并添加更改单个便笺标签的操作。最后，添加一个<em class="lm"> select </em>元素，该元素将有助于只显示标有存档、重要或所有笔记的笔记。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/reducers/visibilityFilter.js</figcaption></figure><p id="6b8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们只处理状态的可见性部分，我们对应用程序状态的注释部分和整个应用程序状态都不感兴趣。所以Redux才这么厉害，这么牛逼！</p><p id="d619" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe nw nx ny no b">actions.js</code>文件中，插入以下内容:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Excerpt from src/actions/actions.js</figcaption></figure><p id="af98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在将在<code class="fe nw nx ny no b">reducers.js</code>文件中合并减速器。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/reducers/reducers.js</figcaption></figure><p id="3eed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们重写<code class="fe nw nx ny no b">store.js</code>文件，使其更具描述性:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/store/store.js</figcaption></figure><p id="61c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在尝试在我们的<code class="fe nw nx ny no b">main.js</code>文件中记录我们的状态应用程序，我们将得到如下结果:</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6c94cb17906d4068bb3359a23158ffa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*3j1CncWMX1M6FvrgUeW5Ew.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Chrome DevTools console</figcaption></figure><p id="781a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到了吗？我们的状态最终成为一个对象，带有我们在<code class="fe nw nx ny no b">combineReducers</code>函数中提供的键，我们的每个reducers管理它自己的状态。漂亮！</p><p id="c848" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4) </strong>作为<code class="fe nw nx ny no b">createStore</code>函数的第二个参数，我们可以提供应用程序的初始状态。这将覆盖我们减速器中的任何默认值。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/737ab3cd3ef3265950676663f988d8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm5zmq1J3PHqTa4iqwC04A.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Our application’s initial state after being logged in Chrome’s DevTools console</figcaption></figure><p id="af63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果我们在<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">本地存储</a>中保存了我们之前的应用程序状态的副本，我们将在提供它作为第二个参数之前获取它的值。然而，请确保您只输入第二个参数同步数据(本地存储API是同步的，所以没有问题！).</p><p id="7dde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"好吧，但是如果我想从一个API加载我的初始状态呢？"。<br/> -那么，在这种情况下，最简单的解决方法是在某个组件(例如，根组件)第一次呈现时加载数据，并在API数据到达时根据需要调度尽可能多的动作。<br/>当然，这意味着当您的API数据到达时，Redux将完成初始化，您仍将拥有初始状态下的默认reducer数据，但这并没有错。一个简单的加载指示器不会伤害你的用户！</p><h2 id="8920" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">用Redux DevTools浏览器扩展连接我们的应用</h2><p id="0972" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">Redux DevTools扩展是一个非常强大的工具。在您准备好之前，我不想强迫您使用它，因为我确信在本文开始时，您会感到有些不知所措。</p><p id="7eb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，添加这一行作为<code class="fe nw nx ny no b">createStore</code>函数的第三个参数:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="da5b" class="mq lo iq no b gy ns nt l nu nv">window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()</span></pre><p id="b2ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的<code class="fe nw nx ny no b">store.js</code>文件现在应该是这样的:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/store/store.js</figcaption></figure><p id="62cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您没有提供应用程序的初始状态，只需将<em class="lm"> undefined </em>作为第二个参数传递就可以了。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/65ea2af2a90db0dfa8897136a340c2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6H95WqZuf9_fkrWaOEIJuQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Feel free to explore the Redux DevTools extension on your own</figcaption></figure><p id="6553" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，对于更复杂的应用程序，一定要检查一下<a class="ae ll" href="https://github.com/zalmoxisus/redux-devtools-extension" rel="noopener ugc nofollow" target="_blank"> Redux DevTools扩展文档</a>。</p><p id="a515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nw nx ny no b">createStore</code>函数中的第三个参数是我们在Redux中放置增强器的地方，比如中间件。请务必查看文章末尾的奖金部分，了解这些概念！</p><p id="0a0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们的第一个项目。你可以在GitHub <a class="ae ll" href="https://github.com/hstevanoski/redux-notes-app" rel="noopener ugc nofollow" target="_blank">这里</a>找到它。</p><h1 id="95cd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第二部分和第三部分先决条件</h1><p id="a66b" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">如前所述，第二部分和第三部分的两个应用程序都将包含在同一个GitHub项目中。您可以在<em class="lm">主</em>分支的第二部分找到申请，而<em class="lm">分支的第三部分钩住</em>分支。<br/>我们将使用<a class="ae ll" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>来创建两个应用程序。</p><p id="6ab8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个叫做<a class="ae ll" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank">reaction-redux</a>的包，我们用它将我们的reaction组件与Redux连接起来。我们将在本文的第二、第三部分使用这个包。</p><p id="d583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过打开reactor项目目录中的终端窗口并执行以下命令来安装Redux和reactor-Redux软件包:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="a2e1" class="mq lo iq no b gy ns nt l nu nv">npm i redux react-redux<br/>// or, yarn add redux react-redux</span></pre><p id="f341" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>为了使这个例子尽可能简单，我们不会在这个项目中实现可见性过滤器。</p><p id="dc4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于reaction-Redux，我们需要了解两件事:</p><p id="bedc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1) </strong> React-Redux提供了一个名为Provider的React组件，它使我们的应用程序存储在整个应用程序中可用。<br/>这是通过在我们的<code class="fe nw nx ny no b">index.js</code>文件中用提供者组件包围应用程序，并将存储作为属性传递给提供者组件来实现的。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Using the Provider component</figcaption></figure><p id="63e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论我们使用的是基于类的组件还是功能性组件，我们都会这样做。<br/>这家店是普通的Redux店，就像我们之前创建的那家一样。</p><p id="e9b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2) </strong> React Redux提供了一个<code class="fe nw nx ny no b">connect</code>函数，我们只对基于类的组件使用该函数。但是，对于功能组件，我们使用由React Redux包提供的钩子。</p><h1 id="b3b7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第二部分—用于基于类的组件的reactor-Redux</h1><p id="5bbd" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">每当我们想将一个组件“连接”到Redux时，我们就使用<code class="fe nw nx ny no b">connect</code>功能，即让一个React组件与我们的Redux商店交互。<br/>我们几乎从来没有直接去过商店。我们只是激发动作创建者，所有的逻辑稍后都由<code class="fe nw nx ny no b">connect</code>功能自动处理。</p><p id="51c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nw nx ny no b">connect</code>函数实际上是一个高阶分量。<br/>它返回一个函数，我们为该函数提供了我们组件的类名(注意后面例子中<code class="fe nw nx ny no b">connect</code>函数后面的多余括号)。<br/>它还接受两个可选参数:<em class="lm">mapstatetorops</em>和<em class="lm">mapdispatchtops</em>。</p><p id="ef42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个参数，<em class="lm"> mapStateToProps </em>，通过在组件的属性中映射存储值来订阅存储。<br/>如果我们想要订阅商店，我们提供一个非空的第一个参数。否则，如果我们不想订阅商店，我们提供<code class="fe nw nx ny no b">null</code>作为第一个参数。</p><p id="cea7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个参数，<em class="lm"> mapDispatchToProps </em>，与在组件的属性中注入动作创建者有关。如果我们根本不想注入任何动作创建者，我们也提供<code class="fe nw nx ny no b">null</code>作为第二个参数。</p><h2 id="33bd" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">mapStateToProps</h2><p id="e20b" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">这是<code class="fe nw nx ny no b">connect</code>函数的第一个参数。顾名思义，我们将应用程序状态的一部分映射到组件的实际属性中。</p><p id="4151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm"> mapStateToProps </em>实际上是一个函数，它将我们应用程序的整个状态作为其第一个参数，并返回我们组件将需要的数据对象，即第一个参数相当于<code class="fe nw nx ny no b">store.getState()</code>。</p><p id="ccee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数有一个可选的第二个参数，它允许您使用一些组件属性。当我们需要来自组件属性的附加信息来从存储中检索数据时，这可能会很有用。</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="bf5e" class="mq lo iq no b gy ns nt l nu nv">(state, ownProps?) =&gt; stateProps</span></pre><p id="a72b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm"> mapStateToProps </em>在每次我们的应用程序状态改变(<code class="fe nw nx ny no b">state</code>参数)或<code class="fe nw nx ny no b">ownProps</code>对象的任何字段改变时被调用。<br/>此外，当<code class="fe nw nx ny no b">ownProps</code>或<code class="fe nw nx ny no b">stateProps</code>不同时，我们的组件将重新呈现，这意味着我们将总是从状态中获取最近的值。</p><h2 id="9297" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">mapDispatchToProps</h2><p id="8e75" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">正如我们前面提到的，这个参数用于将动作创建者映射(注入)到组件的道具。</p><p id="af41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm"> mapDispatchToProps </em>实际上可以是一个对象，也可以是一个函数。React Redux官方文档建议将其作为一个对象，老实说，大多数情况下这就是你要做的。</p><p id="3ccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在它是一个对象的情况下，键将被映射到组件的道具。从那里，我们可以调用action creator函数将新的注释保存到状态中。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">mapDispatchToProps use case</figcaption></figure><p id="e570" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，请注意，正如我们之前提到的，在React中，我们不直接访问商店，因此，我们从不调用<code class="fe nw nx ny no b">store.dispatch()</code>。我们只需调用我们的动作创建者，其余的由<code class="fe nw nx ny no b">connect</code>函数神奇地处理。</p><p id="7158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“如果<em class="lm"> mapDispatchToProps </em>是一个函数，而不是一个对象呢？我什么时候会想把它作为一种功能来使用呢？”我将引用React-Redux文档中的这段话，因为它非常简单:</p><blockquote class="ob oc od"><p id="6872" class="jy jz lm ka b kb kc kd ke kf kg kh ki oe kk kl km of ko kp kq og ks kt ku kv ij bi translated">"将mapDispatchToProps定义为一个函数，可以让您最灵活地自定义组件接收的函数，以及它们如何调度操作。你可以使用派遣和自己的道具。您可以利用这个机会编写自定义函数，供您连接的组件调用。”</p></blockquote><p id="8161" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nw nx ny no b">dispatch</code>和<code class="fe nw nx ny no b">store.dispatch</code>实际上是同一个东西，而<code class="fe nw nx ny no b">ownProps</code>，正如我们已经知道的，是在创建组件时被传递的组件道具。</p><p id="390c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于<em class="lm"> mapDispatchToProps </em>还有一点我想强调的是:<br/>如果您没有在<code class="fe nw nx ny no b">connect</code>函数中提供第二个参数，或者您从<em class="lm"> mapDispatchToProps </em>函数返回的对象返回了一个分派字段，那么分派函数在您的组件中将是现成可用的。欲了解更多信息，请访问React Redux文档中的<a class="ae ll" href="https://react-redux.js.org/using-react-redux/connect-mapdispatch#why-is-my-component-not-receiving-dispatch" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h2 id="a878" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">用基于类的组件在React中重新创建我们的Notes应用程序</h2><p id="a93b" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我重写了App组件，简单地返回了我们的Notes组件。<br/>Notes组件呈现另外两个组件——Notes form和AllNotes。</p><p id="7e72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把我们的<code class="fe nw nx ny no b">Notes</code>、<code class="fe nw nx ny no b">AllNotes</code>和<code class="fe nw nx ny no b">NotesForm</code>组件保存在我们的<code class="fe nw nx ny no b">src/Notes</code>文件夹中。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/App.js</figcaption></figure><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/Notes/Notes.js</figcaption></figure><h2 id="3a37" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated"><strong class="ak">通知表单</strong></h2><p id="dcc3" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">这个组件与添加注释的表单有关。这个组件所做的只是向商店发送一个添加新注释的动作。由于我们不关心应用程序的状态，也不打算订阅它，所以我们提供<code class="fe nw nx ny no b">null</code>作为第一个参数(<em class="lm"> mapStateToProps </em>)。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/Notes/NotesForm.js</figcaption></figure><p id="39e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，对于第二个参数(<em class="lm"> mapDispatchToProps </em>，我们提供了一个对象，通过该对象我们映射了从<code class="fe nw nx ny no b">actions.js</code>文件导入的<code class="fe nw nx ny no b">addNote</code> action creator函数。</p><p id="2078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nw nx ny no b">connect</code>函数发挥了它的魔力，只需在我们的组件中调用<code class="fe nw nx ny no b">this.props.addNote()</code>,我们就可以将添加注释动作发送到商店。</p><h2 id="e0ec" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated"><strong class="ak">所有笔记</strong></h2><p id="daab" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们将使用这个组件来呈现所有的注释，这些注释存储在我们的Redux状态中。同样，我们将需要调度一个删除状态的操作。<br/>换句话说，我们必须填写<code class="fe nw nx ny no b">connect</code>函数中的两个参数。</p><p id="a661" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单地说，我们必须订阅应用程序的状态(因为我们希望在状态中添加或删除注释时立即显示),并将<code class="fe nw nx ny no b">deleteNote</code>动作映射到组件的道具，因为我们将需要它来调度删除注释的动作。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">src/Notes/AllNotes.js</figcaption></figure><p id="fa31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的第二个项目也是如此。你可以在GitHub <a class="ae ll" href="https://github.com/hstevanoski/react-redux-notes-app" rel="noopener ugc nofollow" target="_blank">这里</a>找到它。</p><h1 id="7438" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第三部分—功能组件的反应-还原</h1><p id="86b5" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">与类组件不同，功能组件不使用Redux <code class="fe nw nx ny no b">connect</code> HOC来连接到商店，我们也不会将任何Redux东西注入到组件的道具中。<br/>相反，react-redux包提供了我们在为功能组件编写redux代码时使用的钩子:</p><p id="2e4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1) useSelector <br/> </strong>这个钩子，是对<code class="fe nw nx ny no b">connect</code>函数的<em class="lm"> mapStateToProps </em>参数的替换(粗略地说)。<br/>它接受两个参数——一个选择器函数和一个等式函数。</p><p id="a11b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选择器函数的目的是返回存储的一部分。这是通过它唯一的参数应用程序的存储来实现的。<br/>例如，假设我们想要获得应用程序存储的注释，并将它们存储在组件的一个常量中。<br/>这是我们的代码的样子:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="6e5f" class="mq lo iq no b gy ns nt l nu nv">const notes = useSelector((store) =&gt; store.notes);</span></pre><p id="587c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm"> useSelector </em>钩子使用<code class="fe nw nx ny no b">===</code>(也称为严格的引用相等检查)来检查先前从存储中获取的值是否与我们当前正在获取的值相同。如果不是这样，组件会重新呈现。</p><p id="1723" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于只返回Redux存储的一部分的简单选择器，可以省略这个钩子中的第二个参数。然而，当钩子每次运行都返回一个新对象时(例如，你在选择器函数中进行一些计算，或者从存储的多个值中构建一个新对象)，那么你应该利用Redux的<code class="fe nw nx ny no b">shallowEqual</code>函数。如果这还不够，试试<a class="ae ll" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>或者尝试用<a class="ae ll" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">使用备忘录</a>包装你的组件。</p><p id="b7e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们看一下<code class="fe nw nx ny no b">shallowEqual</code>的<a class="ae ll" href="https://github.com/reduxjs/react-redux/blob/master/src/utils/shallowEqual.js" rel="noopener ugc nofollow" target="_blank">源代码</a>，我们将很快理解这个函数的作用——它检查先前和当前的值是否通过引用相等，或者如果它们是对象，它检查它们是否包含相同的属性，同样，它们必须通过引用相等。</p><p id="308f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2)使用Dispatch </strong></p><p id="580d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个钩子从Redux存储中返回对调度函数的引用。<br/>分派动作非常简单——我们只需将动作(或动作创建者函数)传递给分派函数，就像在非React应用程序中一样:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="4b10" class="mq lo iq no b gy ns nt l nu nv">const dispatch = useDispatch();<br/>dispatch(addNote('Title', 'Content'));</span></pre><p id="fde1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3)使用商店</strong></p><p id="a43f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个钩子也非常简单。它返回对Redux store对象的引用:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="f0cb" class="mq lo iq no b gy ns nt l nu nv">const store = useStore();<br/>console.log(store.getState());</span></pre><h2 id="a0ba" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">在React with function组件中重新创建我们的Notes应用程序</h2><p id="8e37" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">我们只需更改<em class="lm">所有注释</em>、<em class="lm">注释</em>和<em class="lm">注释表单</em>组件。我们首先从<code class="fe nw nx ny no b">connect</code>函数中展开每个组件，并将它们转换成功能组件。</p><h2 id="d3a6" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">笔记</h2><p id="99f6" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">因为我们不使用任何Redux数据，所以我们简单地将组件转换成功能组件。</p><h2 id="9080" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">NotesForm表单</h2><p id="2194" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在这里，我们利用了<em class="lm">使用的Dispatch </em>钩子。我们从React Redux导入它，然后将它存储在组件内部的一个常量中。然后，在<code class="fe nw nx ny no b">handleSubmission</code>函数中，我们用之前存储的<code class="fe nw nx ny no b">dispatch</code>函数包装<code class="fe nw nx ny no b">addNote</code>函数。</p><h2 id="97db" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">所有笔记</h2><p id="0da8" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">这里，我们同时使用了<em class="lm">使用选择器</em>和<em class="lm">使用分配器</em>挂钩。我们使用前一个钩子将笔记存储在一个名为<code class="fe nw nx ny no b">notes</code>的常量中，而后者的使用就像在<em class="lm"> NotesForm </em>组件中一样。在这个特定的场景中，<code class="fe nw nx ny no b">shallowEqual</code>函数根本没有用，因为每次组件更新时，我们都会从存储中收到相同的对象，但是我编写它只是为了演示。</p><p id="cf34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不使用<em class="lm"> useStore </em>钩子，因为在这个场景中没有它的用例。老实说，你很少会伸手去拿。</p><p id="1c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是第三个项目的全部内容。你可以在GitHub <a class="ae ll" href="https://github.com/hstevanoski/react-redux-notes-app/tree/hooks" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="9dfd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">额外收获:中间件、异步操作和Redux Thunk</h1><h2 id="4c66" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">储存增强剂</h2><p id="eeff" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">存储增强器基本上是高阶函数，通过添加一些额外的功能(如中间件)来增强存储。Redux附带的唯一存储增强器是<code class="fe nw nx ny no b">applyMiddleware</code>函数，用于提供中间件。</p><h2 id="5661" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">中间件</h2><p id="4b36" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">您可能熟悉其他库/框架，如<a class="ae ll" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express.js </a>，其中存在一个称为中间件的概念，它实际上是位于请求和响应之间的一层。它在每次请求时执行，通常用于身份验证目的(在执行某些代码之前检查用户是否登录)。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/c51b9452e6c95014d8c3d3698676f009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdCK3JxiJjuFM-cowFEI1g.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">The concept of middleware</figcaption></figure><p id="9a13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，Redux中间件在每个被分派的动作到达reducer之前被执行。Redux中的中间件可以用于许多目的。最简单也是最无害的例子是记录您在每个派单上的操作。最高级的例子之一是构建一个用于调试目的的DevTools扩展。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/f31f63e07890ac76e792c25b70955b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQekLGztIIm69j9Ey1P5sA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Middleware in Redux</figcaption></figure><p id="80a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux允许通过向<code class="fe nw nx ny no b">applyMiddleware</code>函数提供一组中间件来实现中间件:</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="5d43" class="mq lo iq no b gy ns nt l nu nv">applyMiddleware(...middleware)</span></pre><p id="7036" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为<code class="fe nw nx ny no b">createStore</code>函数中的第三个参数，我们提供了想要使用的存储增强器。正如我们之前提到的，Redux附带的唯一存储增强器是<code class="fe nw nx ny no b">applyMiddleware</code>函数。</p><p id="2ef0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux附带了一个<code class="fe nw nx ny no b">compose</code>功能，可以帮助你对商店应用多种商店增强剂。它涉及到<a class="ae ll" href="https://en.wikipedia.org/wiki/Function_composition_(computer_science)" rel="noopener ugc nofollow" target="_blank">函数组合</a>，这是函数式编程中一个众所周知的模式。Redux DevTools扩展也附带了这样的函数，用于其内部目的。</p><p id="228e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将<code class="fe nw nx ny no b">applyMiddleware</code>函数包装在Redux DevTools的<code class="fe nw nx ny no b">connect</code>函数中，或者作为后备(当用户没有安装Redux DevTools扩展时)，包装在Redux的<code class="fe nw nx ny no b">compose</code>函数中:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Redux’s compose and applyMiddleware function example</figcaption></figure><h2 id="212a" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">通过Redux-Thunk的异步操作</h2><p id="ca0a" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">到目前为止，我们一直在Redux中处理同步动作。然而，异步动作也是存在的，根据项目的不同，可能会有大量的异步动作。然而，不要不知所措，因为它们也很容易理解:</p><p id="bee4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">异步操作意味着以异步方式将操作分派给存储。就是这样。</p><p id="0b2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个例子，假设我们也有一个API来帮助我们在笔记上进行<a class="ae ll" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD </a>操作，也许同样也提供登录和注册功能。我们可以向API发送一个HTTP请求，并在收到响应时分派一些动作。虽然这种方法没什么问题，但还有另一种方法——通过调度异步动作，为此存在大量的库:<em class="lm"> redux-thunk </em>、<em class="lm"> redux-promise </em>、<em class="lm"> redux-promise-middleware </em>、<em class="lm"> redux-observable </em>、<em class="lm"> redux-saga </em>和<em class="lm"> redux-pack </em>等等。顾名思义，所有人都使用不同的技术来达到相同的结果——思考、承诺或观察。</p><p id="ee7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将介绍redux-thunk，因为它是最受欢迎的一个，非常容易理解，并且它使用thunks，这只是一个包装在另一个函数中的函数的花哨词。要安装它，请运行</p><pre class="nd ne nf ng gt nn no np nq aw nr bi"><span id="349e" class="mq lo iq no b gy ns nt l nu nv">npm i redux-thunk<br/>// or, yarn add redux-thunk</span></pre><p id="c065" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">redux-thunk中的异步操作具有以下模式:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Redux Thunk syntax</figcaption></figure><p id="6c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数不是一个对象创建者并返回一个普通对象，而是返回另一个接受两个参数的函数——商店的<code class="fe nw nx ny no b">dispatch</code>和<code class="fe nw nx ny no b">getState</code>函数，从而允许延迟调度所需的操作。</p><p id="e271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了展示redux-thunk的实际例子，我们将编写以下操作:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Redux Thunk async actions example</figcaption></figure><p id="0655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>我们不会实现这些，因为我们没有API，但我希望你能明白要点。</p><h1 id="4b5e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="8b10" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">恭喜你学会了Redux和React Redux！</p><p id="71fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为你的下一步，我强烈建议你访问一下这些技术的官方文档。<br/>您可能还想考虑以下额外资源，我认为这些资源可能会让您更深入地了解Redux和React Redux:</p><h2 id="3b11" class="mq lo iq bd lp mr ms dn lt mt mu dp lx kj mv mw mb kn mx my mf kr mz na mj nb bi translated">要考虑的资源</h2><ol class=""><li id="f993" class="kw kx iq ka b kb ml kf mm kj op kn oq kr or kv lb lc ld le bi translated"><a class="ae ll" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Docs </a></li><li id="fb7d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae ll" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> React-Redux Docs </a></li><li id="cacc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="os ot ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----8ce5da9e53c6--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>的<a class="ae ll" href="https://egghead.io/courses/building-react-applications-with-idiomatic-redux" rel="noopener ugc nofollow" target="_blank">关于理论家的课程</a></li><li id="6b77" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">来自<a class="ae ll" href="https://www.youtube.com/playlist?list=PL55RiY5tL51rrC3sh8qLiYHqUV3twEYU_" rel="noopener ugc nofollow" target="_blank">学院</a>、<a class="ae ll" href="https://www.youtube.com/playlist?list=PL4cUxeGkcC9ij8CfkAY2RAGb-tmkNwQHG" rel="noopener ugc nofollow" target="_blank">网络忍者</a>和<a class="ae ll" href="https://www.youtube.com/watch?v=93p3LxR9xfM" rel="noopener ugc nofollow" target="_blank">旅行媒体</a>的重复相关视频</li><li id="ef22" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果你正在使用Angular，检查一下<a class="ae ll" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>和<a class="ae ll" href="https://www.ngxs.io/" rel="noopener ugc nofollow" target="_blank"> NGXS </a></li></ol><p id="f7c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你发现任何有助于你更好地理解Redux的额外资源，请在下面的评论中提供，这样其他人也可以从中受益。</p><p id="d5fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你喜欢这篇文章，并且它至少帮助你对Redux和React Redux有了更清楚的了解。<br/>作为对您的挑战，尝试通过以下方式扩展该项目:</p><ul class=""><li id="86c7" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lk lc ld le bi translated">添加编辑注释的功能</li><li id="457d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">为应用程序添加一个赏心悦目的设计，并使其具有响应性</li><li id="389d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">提高应用程序的UX。考虑添加一个表单验证，强制用户提供内容，但不一定是要保存到商店的新笔记的标题。</li><li id="80ba" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">向注释添加标签并扩展可见性过滤器，该过滤器将根据标签过滤要显示的注释</li><li id="e80a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">添加一个归档功能和一个归档部分，所有归档的笔记都将在这里呈现</li><li id="1e21" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">将根归约器分割成多个子归约器</li><li id="11bc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">创建单独的注释组件</li><li id="6a83" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">将此应用程序连接到云上，或者考虑用您最喜欢的编程语言创建一个API(如果您对后端开发感兴趣)</li><li id="09fd" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lk lc ld le bi translated">跳出框框，发挥你自己的创造力，在一个完全不同的主题上创造一个令人敬畏的项目！</li></ul><p id="27b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">祝你在进一步精通Redux的旅途中好运！</p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><p id="7d8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm">更多内容敬请关注</em><a class="ae ll" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="lm">plain English . io</em></strong></a><strong class="ka ir"><em class="lm"/></strong><em class="lm">和上</em><strong class="ka ir"><em class="lm"/></strong><strong class="ka ir">我们的YouTube频道</strong>  <strong class="ka ir">！</strong></p><div class="pb pc gp gr pd pe"><a href="https://newsletter.plainenglish.io/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd ir gy z fp pj fr fs pk fu fw ip bi translated">上周简明英语杂志</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">《上周简明英语》——科技世界的每周综述，包含我们认为你会…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">时事通讯. plainenglish.io</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps jw pe"/></div></div></a></div></div></div>    
</body>
</html>