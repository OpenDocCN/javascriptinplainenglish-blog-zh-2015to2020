<html>
<head>
<title>4 Practices to Help You Understand array.reduce()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4种帮助您理解阵列的做法。减少()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-practices-to-help-you-understand-array-reduce-f3138cfef095?source=collection_archive---------1-----------------------#2020-02-18">https://javascript.plainenglish.io/4-practices-to-help-you-understand-array-reduce-f3138cfef095?source=collection_archive---------1-----------------------#2020-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bec6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在JavaScript中，您应该了解这个数组方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/394946849f670fcaa686a1e9583e735d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZtpfiGCdW32m3DWH"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@angarav?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Antonio Garcia</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4aba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Array.prototype.reduce()</code>是数组中最强大的方法之一，也是JavaScript函数式编程中一个吸引人的特性。但是不幸的是，我发现许多朋友不习惯使用它。让我详细介绍一下这个方法，希望能对你有所帮助。</p><p id="3164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是<code class="fe ls lt lu lv b">reduce</code>的一个基本用法:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="440e" class="ma mb iq lv b gy mc md l me mf">var arr = [1, 2, 3];</span><span id="bea0" class="ma mb iq lv b gy mg md l me mf">function reducer(parmar1, parmar2){<br/>}</span><span id="3e9a" class="ma mb iq lv b gy mg md l me mf">arr.reduce(reducer)</span></pre><p id="877b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">reduce</code>是一种对数组原型对象进行操作的方法，可以帮助我们操作数组。它将以另一个函数作为它的参数，这个函数可以叫做<code class="fe ls lt lu lv b">reducer</code>。</p><p id="9b6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">reducer</code>取两个参数。第一个参数param1是最后一次减速器运行的结果。如果这是第一次运行<code class="fe ls lt lu lv b">reducer</code>，则param1的默认值是数组第一个元素的值。</p><p id="56c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">reduce方法循环遍历数组中的每个元素，就像for循环一样。回路中的电流值取为参数2。</p><p id="7b93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遍历数组后，reduce将返回最后一次reduce计算的结果。</p><p id="5cf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个详细的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/abc26258dc3068b69f8e613c5f4f2dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tY-KHYDobojk-L645RYi6Q.png"/></div></div></figure><p id="a9bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们探索如何执行上述代码。</p><p id="d1fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本规范中<code class="fe ls lt lu lv b">reducer</code>为<code class="fe ls lt lu lv b">add</code>。</p><p id="682a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，因为我们是第一次执行<code class="fe ls lt lu lv b">add</code>，数组中的第一个元素<code class="fe ls lt lu lv b">'a'</code>将被视为<code class="fe ls lt lu lv b">add</code>的第一个参数，然后循环从数组的第二个元素<code class="fe ls lt lu lv b">'b'</code>开始。此时<code class="fe ls lt lu lv b">'b'</code>是<code class="fe ls lt lu lv b">add</code>的第二个参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/c0303abaff68d1b0d6c5c8d413583e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qgj185-S_CaGbm69K5MaaA.png"/></div></div></figure><p id="b456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过第一次计算，得到结果<code class="fe ls lt lu lv b">'ab'</code>。该结果将被缓存，并在下一次<code class="fe ls lt lu lv b">add</code>计算中作为参数1使用。同时，数组中的第三个参数<code class="fe ls lt lu lv b">'c'</code>将作为<code class="fe ls lt lu lv b">add</code>的参数2。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/e4e2a39d7bab37e4e27d5279b551c033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwIyZNKZIuphD3zT4YAwiQ.png"/></div></div></figure><p id="41a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，<code class="fe ls lt lu lv b">reduce</code>将继续遍历数组中的元素，运行<code class="fe ls lt lu lv b">'abc'</code>和<code class="fe ls lt lu lv b">'d'</code>作为<code class="fe ls lt lu lv b">add</code>的参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/df24c1adf66df8d4fd9c68209a999460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ElWQx1xeXOKo0fsZCKnGA.png"/></div></div></figure><p id="9ae1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，遍历数组中的最后一个元素后，将返回计算结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/a05cfdd52730dfaf3c1f85ad98a517ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZU9d6He725ZrWfe6jnWTA.png"/></div></div></figure><p id="1f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了结果:<code class="fe ls lt lu lv b">'abcde'</code>。</p><p id="35fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们可以看到<code class="fe ls lt lu lv b">reduce</code>也是一种遍历数组的方式！它依次取数组中每个元素的值，执行<code class="fe ls lt lu lv b">reducer</code>函数。</p><p id="be7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们可以看到上面的循环并没有那种和谐的美感。因为我们取数组中的第一个元素，也就是<code class="fe ls lt lu lv b">'a'</code>，作为初始param1，然后从数组中的第二个元素开始循环得到param2。</p><p id="3ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，我们可以将<code class="fe ls lt lu lv b">reduce</code>中的第二个参数指定为<code class="fe ls lt lu lv b">reducer</code>函数的param1的初始值，所以param2将从数组中的第一个元素开始循环得到。</p><p id="11ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/8553afcf585f06329a1c7dd33d87b401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSEo3IAL1F_3gpqhMWRakg.png"/></div></div></figure><p id="e4eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这次我们在第一次调用<code class="fe ls lt lu lv b">reducer</code>的时候把<code class="fe ls lt lu lv b">'s'</code>作为param1，然后从第一个元素开始依次遍历数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/25cbffc5458693c21c93f23aca15beda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R54kJpnlyDq0BP5n8b9MNg.png"/></div></div></figure><p id="3416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以用这个语法来重写我们的第一段代码。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="25d8" class="ma mb iq lv b gy mc md l me mf">var arr = ['a', 'b', 'c', 'd', 'e'];</span><span id="fba0" class="ma mb iq lv b gy mg md l me mf">function add(x, y) {<br/>    return x + y;<br/>}</span><span id="996a" class="ma mb iq lv b gy mg md l me mf">arr.reduce(add, '')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/a65c88197da836804c24e81ccfa443c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yId5e1WGbVEhEyGiADNFDQ.png"/></div></div></figure><p id="fd44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将进入实际编码的章节，来体验一下<code class="fe ls lt lu lv b">reduce</code>的强大威力。</p><h1 id="9b5e" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">1.累积和累积乘法</h1><p id="0346" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">如果我们想得到数组中所有元素的和，你会怎么做？</p><p id="c932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，你可以这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3f52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，你可以有其他的写法，但是只要你使用for循环，代码就会显得多余。</p><p id="fa12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后让我们看看上面的累加函数是做什么的:</p><ul class=""><li id="52e1" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">将初始<code class="fe ls lt lu lv b">sum</code>设置为零</li><li id="bb5c" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">取出数组中的第一个元素并求和</li><li id="11ff" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">在<code class="fe ls lt lu lv b">sum</code>中缓存上一步的结果</li><li id="c2b1" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">依次取出数组中的其他元素，执行上述操作</li><li id="11a6" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">返回最终结果</li></ul><p id="75a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，当我们用文字描述上述步骤时，很明显符合<code class="fe ls lt lu lv b">reduce</code>的使用。所以我们可以用<code class="fe ls lt lu lv b">reduce</code>重写上面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您习惯使用箭头函数，上面的代码看起来会更简洁:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有代码都在一行中！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/44d75280b5604aaefe0dcfc7582ca086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZHpFnTqCJZtYph9fvDkBw.png"/></div></div></figure><p id="9cfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，累积乘法和累加是完全一样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/475d84991c46e9a9e8ae0a44cc2f0964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3WggCuoR0PEFrpmJTfpBg.png"/></div></div></figure><p id="72a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多时候我们在总结的时候需要加一个砝码，这样更能体现出<code class="fe ls lt lu lv b">reduce</code>的优雅。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="73e2" class="ma mb iq lv b gy mc md l me mf">const scores = [<br/>  { score: 90, subject: "HTML", weight: 0.2 },<br/>  { score: 95, subject: "CSS", weight: 0.3 },<br/>  { score: 85, subject: "JavaScript", weight: 0.5 }<br/>];</span><span id="e891" class="ma mb iq lv b gy mg md l me mf">const result = scores.reduce((x, y) =&gt; x + y.score * y.weight, 0); // 89</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/996476a0ab1c1a64b585d21538f935d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKcu6SbPmRQIhJ6MQoRK0A.png"/></div></div></figure><h1 id="7c7a" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">2.获取数组的最大值和最小值</h1><p id="409b" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">如果你想得到一个数组的最大值和最小值，你可以这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ef02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样。如果我们使用<code class="fe ls lt lu lv b">reduce</code>，我们可以在一行代码中完成。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7cc4" class="ma mb iq lv b gy mc md l me mf">let arr = [3.24, 2.78, 999];</span><span id="fc4f" class="ma mb iq lv b gy mg md l me mf">arr.reduce((x, y) =&gt; Math.max(x, y));</span><span id="db2e" class="ma mb iq lv b gy mg md l me mf">arr.reduce((x, y) =&gt; Math.min(x, y));</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/3b60f4bcaf9d316ad94bf6ab590d3e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNp6iFaCgaZPHzLXPaJkYw.png"/></div></div></figure><h1 id="26d6" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">3.计算数组中元素的频率</h1><p id="5374" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">我们经常需要计算数组中每个元素出现的次数。<code class="fe ls lt lu lv b">reduce</code>方法可以帮助我们实现这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="0110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们使用map对象而不是object来存储统计后的频率，因为数组中的元素可能是object类型，而object的key只能是string或symbol类型。</p><p id="a28b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有两个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/13fc58e86a897781c3ba73a5362e39b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqgvI-sOi-OFcZUP6TSzuA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/e462c5212a9344acd2ab459a25693eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfjIIj9EVDXx9h1FQqjDnw.png"/></div></div></figure><p id="2383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，如果要统计字符串中每个字符的出现频率，可以先将字符串转换为字符数组，然后按照上面的方法进行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/dbe4d8c730fcb8214810e46d6be5f8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5nNkMput6T_q3j5ufB9rEQ.png"/></div></div></figure><p id="6290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为字符类型可以用作对象的键，所以我们在这里不使用Map。</p><h1 id="76d3" class="mr mb iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">4.多个阵列的扁平化</h1><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9909" class="ma mb iq lv b gy mc md l me mf">function Flat(arr = []) {<br/>    return arr.reduce((t, v) =&gt; t.concat(Array.isArray(v) ? Flat(v) : v), [])<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/c650797e018ec7a3cb05c5081447a9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sthg3loD8BAWNy76eUS0w.png"/></div></div></figure><p id="f4b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过<code class="fe ls lt lu lv b">reduce</code>依次访问数组中的每个元素。如果我们发现元素仍然是一个数组，递归调用flat方法。</p></div></div>    
</body>
</html>