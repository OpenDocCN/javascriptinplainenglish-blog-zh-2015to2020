<html>
<head>
<title>Functional JavaScript — Piping and Functors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能性JavaScript——管道和函子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-javascript-piping-and-functors-b2040605348a?source=collection_archive---------14-----------------------#2020-11-20">https://javascript.plainenglish.io/functional-javascript-piping-and-functors-b2040605348a?source=collection_archive---------14-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7f4a61adaaaeb9a7059a1450145a6a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z-QZ2BzaaXj0y7Nc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@spacexuan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Crystal Kwok</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4675" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript在一定程度上是一种功能性语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的功能部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何用JavaScript传递函数和函子。</p><h1 id="9bfe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">管</h1><p id="8706" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建一个以函数数组作为参数的函数来创建<code class="fe me mf mg mh b">pipe</code>函数。</p><p id="9f1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个接受一个值的函数，我们用这个函数调用<code class="fe me mf mg mh b">reduce</code>，用<code class="fe me mf mg mh b">acc</code>调用<code class="fe me mf mg mh b">fn</code>。</p><p id="7784" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9505" class="mq lc iq mh b gy mr ms l mt mu">const compose = (...fns) =&gt;<br/>  (value) =&gt;<br/>  fns.reduceRight((acc, fn) =&gt; fn(acc), value)</span></pre><p id="8384" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别是我们使用了<code class="fe me mf mg mh b">reduceRight</code>代替<code class="fe me mf mg mh b">reduce</code>，所以我们不需要调用<code class="fe me mf mg mh b">reverse</code>来应用所有的函数。</p><h1 id="a699" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">作文是联想的</h1><p id="79a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">组合是关联的，这意味着我们可以重新排列操作的括号</p><p id="5a7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2414" class="mq lc iq mh b gy mr ms l mt mu">compose(f, compose(g, h)) == compose(compose(f, g), h)</span></pre><p id="8c37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe me mf mg mh b">true</code>。</p><h1 id="d6cc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函子</h1><p id="8541" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函子是一个简单的对象，它在运行River每个值以产生一个新对象的同时实现函数<code class="fe me mf mg mh b">map</code>。</p><p id="d1d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函子是一个容器，其中包含一些值。</p><p id="567d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7f5d" class="mq lc iq mh b gy mr ms l mt mu">const Container = function(val) {<br/>  this.value = val;<br/>}</span></pre><p id="2710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来创建我们的容器。</p><p id="2115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">new</code>调用<code class="fe me mf mg mh b">Container</code>构造函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac1f" class="mq lc iq mh b gy mr ms l mt mu">let foo = new Container(3);</span></pre><p id="a25b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建<code class="fe me mf mg mh b">Container.of</code>属性来添加一个容器，让我们返回一个<code class="fe me mf mg mh b">Container</code>实例:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="843c" class="mq lc iq mh b gy mr ms l mt mu">const Container = function(val) {<br/>  this.value = val;<br/>}</span><span id="0796" class="mq lc iq mh b gy mv ms l mt mu">Container.of = function(value) {<br/>  return new Container(value);<br/>}</span></pre><p id="83c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们增加了<code class="fe me mf mg mh b">of</code>静态方法来返回一个<code class="fe me mf mg mh b">Container</code>实例。</p><p id="84f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">of</code>方法只是给了我们一个使用<code class="fe me mf mg mh b">new</code>运算符创建<code class="fe me mf mg mh b">Container</code>实例的替代方法。</p><p id="130f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">of</code>方法创建一个<code class="fe me mf mg mh b">Container</code>实例:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="75bb" class="mq lc iq mh b gy mr ms l mt mu">const nested = Container.of(Container.of(1));</span></pre><p id="77e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将看到嵌套的<code class="fe me mf mg mh b">Container</code>实例。</p><h1 id="9944" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函子实现称为映射的方法</h1><p id="903d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函子执行<code class="fe me mf mg mh b">map</code>方法。</p><p id="6c9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将其添加到<code class="fe me mf mg mh b">prototype</code>属性中，作为实例方法添加:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c6f0" class="mq lc iq mh b gy mr ms l mt mu">const Container = function(val) {<br/>  this.value = val;<br/>}</span><span id="0914" class="mq lc iq mh b gy mv ms l mt mu">Container.of = function(value) {<br/>  return new Container(value);<br/>}</span><span id="6706" class="mq lc iq mh b gy mv ms l mt mu">Container.prototype.map = function(fn) {<br/>  return Container.of(fn(this.value));<br/>}</span></pre><p id="67b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建<code class="fe me mf mg mh b">Container</code>实例后，可以使用<code class="fe me mf mg mh b">map</code>方法。</p><p id="cd50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过书写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7bc" class="mq lc iq mh b gy mr ms l mt mu">const squared = Container.of(3).map(a =&gt; a ** 2);</span></pre><p id="e8fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">则<code class="fe me mf mg mh b">squared</code>为<code class="fe me mf mg mh b">Container</code>实例，且<code class="fe me mf mg mh b">value</code>为9。</p><p id="b5c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们反复调用<code class="fe me mf mg mh b">map</code>重复一次手术。</p><p id="6e0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3f08" class="mq lc iq mh b gy mr ms l mt mu">const squared = Container.of(3)<br/>  .map(square)<br/>  .map(square)<br/>  .map(square);</span></pre><p id="389a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">squared</code>就是一个<code class="fe me mf mg mh b">Container</code>实例，其中<code class="fe me mf mg mh b">value</code>为6561。</p><p id="680b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Functor只是一个实现了<code class="fe me mf mg mh b">map</code>方法的对象。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/db93129c702590ff088023c9f1166a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3FDFqaFcG-xxVCqU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@samthewam24?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Samuel Sianipar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c493" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d855" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函子是有值的普通对象。</p><p id="99d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该对象有一个<code class="fe me mf mg mh b">map</code>方法。</p><p id="4aa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过管道函数来调用多个函数，并获得返回值。</p><p id="936e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组合是关联的，所以我们可以重新排列操作的括号。</p><p id="429c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>