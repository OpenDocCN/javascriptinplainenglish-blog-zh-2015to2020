<html>
<head>
<title>I created the exact same app in Vue and Svelte. Here are the differences.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在Vue和Svelte中创建了完全相同的应用程序。以下是不同之处。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-created-the-exact-same-app-in-vue-and-svelte-here-are-the-differences-c649f8d4ce0a?source=collection_archive---------0-----------------------#2019-11-23">https://javascript.plainenglish.io/i-created-the-exact-same-app-in-vue-and-svelte-here-are-the-differences-c649f8d4ce0a?source=collection_archive---------0-----------------------#2019-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="167a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Vue vs苗条。最后一个并列代码对比！因为你已经听到了关于苗条的大惊小怪，现在你想知道炒作是怎么回事。</h2></div><p id="c4b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在工作中使用过Vue之后，我对它有了相当扎实的理解。我最近听说了Svelte——一种新的JavaScript框架，最近开始在web开发领域获得关注。作为一名好奇的Web开发人员，我一直很想知道栅栏另一边的草是什么样的——在这个场景中的草是细长的。</p><p id="0bb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我读了苗条的医生，看了几个视频，虽然它们很有用，但我真正想知道的是苗条和Vue有什么不同。我说的<em class="lb">【不同】</em>，并不是指诸如Svelte是否使用了虚拟DOM或者它如何渲染页面之类的事情。我希望有人花时间解释一下，如果我用苗条的身材写了同样的东西，我的Vue代码会是什么样子！我想找一篇花时间解释这一点的文章，以便刚接触Vue或Svelte(或整个Web开发)的人能够更好地理解两者之间的差异。</p><p id="329b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，我找不到任何解决这个问题的方法。所以我意识到，我必须自己动手建造它，才能看到相似之处和不同之处。在这样做的时候，我想我应该把整个过程记录下来，这样一篇关于这个的文章就会最终存在。</p><p id="76d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定尝试构建一个相当标准的待办事项应用程序，允许用户在列表中添加和删除项目。这两款应用都是使用CLIs构建的(<code class="fe lc ld le lf b">@vue/cli</code>用于Vue，<code class="fe lc ld le lf b">sveltejs/template</code>用于Svelte)。</p><p id="acb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下,<em class="lb"> CLI代表命令行界面。🤓</em></p><h1 id="9c4a" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">无论如何，这个介绍已经比我预期的要长了。让我们先来快速了解一下这两款应用的外观:</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/90ec320d863ff05579fbbe1775ed6715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjqzfXYgUfXqvov5lfGjPQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Vue vs Svelte: A new challenger approaches!</figcaption></figure><p id="df7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个应用程序的CSS代码完全相同，但是它们的位置不同。记住这一点，接下来让我们看看这两个应用程序的文件结构:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mo"><img src="../Images/066c9385618ee4a8be4e399ebb2125dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPax7GNw5gIdGN59yGfrQg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Vue on the left. Svelte on the right.</figcaption></figure><p id="41f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会看到它们的结构在这里有很大的不同。</p><p id="96f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue在<strong class="kh ir"> src </strong>文件夹中有所有的组件、样式和资产，而Svelte要求资产直接位于<strong class="kh ir"> public </strong>文件夹中。两者都没有任何<strong class="kh ir">。css </strong>文件作为样式在实际的<strong class="kh ir">中定义。vue </strong>和<strong class="kh ir">。纤细的</strong>文件。</p><p id="bba6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还会注意到——对于Svelte——有一些用于汇总的<strong class="kh ir">配置</strong>文件。对于那些不知道的人，Rollup基本上是一个Webpack等价物，Svelte选择使用它。</p><p id="0cff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，你会注意到在<strong class="kh ir">公共</strong>文件夹中已经有一些<strong class="kh ir">包</strong>文件。这些是我在我的本地主机上试着提供苗条的ToDo应用程序后创建的。与Vue不同，Svelte的CLI会在您尝试启动本地服务器时自动生成这些文件。这些实际上是提供给你的文件，是来自<strong class="kh ir">的所有代码的编译。苗条的</strong>文件。</p><p id="3d34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是Svelte与Vue不同的一个关键点。在Vue中，如果你要编译你的代码以便准备好发送到生产并在线发布，你通常会在你的<strong class="kh ir">公共</strong>文件中结束类似的结构，但是在开发时，如果你要将你的Vue ToDo应用程序提供给本地服务器，你不会看到这些<strong class="kh ir">捆绑包</strong>文件， 当你的代码被Webpack编译，然后在你的本地主机上提供给你——并且有效地位于缓存中的某个地方，而Rollup编译苗条的代码并使它在<strong class="kh ir"> public </strong>文件夹中对你可见。 这里引起的另一个不同是，Vue的Webpack设置允许热模块重载(这基本上意味着，当您在开发期间进行更新时，代码将在您的浏览器中非常快速地更新。在Svelte的Rollup设置中，这在默认情况下是不可能的，因为那些<strong class="kh ir">捆绑包</strong>文件实际上正在被重新编译，尽管很快，每次你点击保存按钮来更新你的代码。如果需要的话，有一些软件包可以帮助你实现热模块的重新加载，但是在我写这篇文章的时候，这些软件包还没有“开箱即用”。</p><p id="914d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，文件结构和编译方法实现了同样的事情，只是方式不同。</p><h2 id="7258" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">在我们继续之前，让我们快速看一下典型的Vue和苗条组件是什么样子的:</h2><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nb"><img src="../Images/ce59b271cbb37452529869b709e1ab9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-biaWShCzVxYvOt4nHvAQ.png"/></div></div></figure><p id="1cab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们进入本质的细节！</p><h1 id="5286" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">创建新的应用程序</h1><h2 id="40f4" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">某视频剪辑软件</h2><p id="fb52" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">使用npm，在您的终端/命令行中运行以下命令来安装Vue CLI:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="76de" class="mp lh iq lf b gy nl nm l nn no">npm install -g @vue/cli</span></pre><p id="c943" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装后，您可以运行:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="fab6" class="mp lh iq lf b gy nl nm l nn no">vue create vue-todo</span></pre><p id="f7e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为您创建一个名为“vue-todo”的项目，其中包含您开始所需的一切。我们对为本文创建的应用程序使用了相同的过程。</p><h2 id="a5d7" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">苗条的</h2><p id="a1b0" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">使用npm，在您的终端/命令行中运行以下命令:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="9871" class="mp lh iq lf b gy nl nm l nn no">npx degit your-name/template svelte-todo</span></pre><p id="d25f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为您创建一个名为“svelte-todo”的项目，其中包含您开始所需的一切。我们对为本文创建的应用程序使用了相同的过程。</p><h1 id="c7b8" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们如何改变数据？[从这里继续]</h1><p id="761c" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">但是首先，我们所说的“变异数据”是什么意思？听起来有点专业，不是吗？它基本上只是意味着改变我们已经存储的数据。所以，如果我们想把一个人的名字从约翰改成马克，我们就要“改变数据”。Vue和Svelte以相同的方式处理突变，本质上允许数据自由更新(例如，我们可以将项目推入数据数组，重新分配我们的数据等)。</p><p id="8a9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看下图中两者的设置，然后我们将解释接下来会发生什么:</p><div class="lz ma mb mc gt ab cb"><figure class="np md nq nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><img src="../Images/af950710dce945e7a6a9c89004bf055c.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*w9opXLE7txxbp-cBXBZVAg.png"/></div></figure><figure class="np md nv nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><img src="../Images/e2fe456bf69de98768f52e90ae4009fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*yxIe0z3yfbR3Tne1fBNhSQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk nw di nx ny">Vue on the left. Svelte on the right.</figcaption></figure></div><p id="d42e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，您可以看到，我们将相同的数据传递给了两者，但结构略有不同。</p><p id="57a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Vue中，您通常会将组件的所有可变数据放在一个<code class="fe lc ld le lf b">data()</code>函数中，该函数返回一个包含您的数据的对象。</p><p id="0928" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用Svelte，你会注意到我们有两个变量要输出。这些文件位于我们的<strong class="kh ir"> ToDo.svelte </strong>文件中，但是如果我们愿意，也可以放在route <strong class="kh ir"> App.svelte </strong>文件中更高的位置。</p><p id="606b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，让我们再看一看它们，然后我们会解释这是怎么回事:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="2bbd" class="mp lh iq lf b gy nl nm l nn no">export let todo = "";<br/>export let list = [<br/>  { id: 1, text: "clean the house" },<br/>  { id: 2, text: "buy eggs" }<br/>];</span></pre><p id="04e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以对于Svelte，如果我们想在我们的文件中引用像<code class="fe lc ld le lf b">todo</code>和<code class="fe lc ld le lf b">list</code>这样的东西，我们需要在同一个文件的某个地方创建一个对它们的引用。</p><p id="f009" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与Vue或大多数其他JavaScript没有什么不同，无论是通过创建变量、导入变量，还是将变量作为道具传递给组件。这里的不同之处在于，我们实际上是在创建新的变量(<em class="lb">与</em> <code class="fe lc ld le lf b"><em class="lb">let</em></code> <em class="lb">，而不是</em> <code class="fe lc ld le lf b"><em class="lb">const</em></code> <em class="lb">，因为那样会阻止我们对它进行变异——或者如果我们想从技术上了解</em> <code class="fe lc ld le lf b"><em class="lb">const</em></code> <em class="lb">如何工作</em>，就重新分配它)。我之所以提到我们必须创建新的变量，是因为你稍后会注意到，我们必须在我们想要引用它们的每个文件中这样做，即使它们已经作为道具传递了。基本上，Svelte会将值传递给那些新创建的变量。如果你感到困惑，就继续读下去，当我们以后再次提到它的时候，你会看到它是如何工作的。</p><h2 id="5416" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">那么我们如何在Vue和Svelte应用中引用可变数据呢？</h2><p id="d431" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">好吧，假设我们有一些名为<code class="fe lc ld le lf b">name</code>的数据，它被赋予了一个值<code class="fe lc ld le lf b">‘Sunil<strong class="kh ir">’</strong></code>。</p><p id="02a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Vue中，它将位于<code class="fe lc ld le lf b">data()</code>对象的内部，并被称为<code class="fe lc ld le lf b">name: ‘Sunil'</code>。在我们的应用程序中，我们将通过调用<strong class="kh ir"> </strong> <code class="fe lc ld le lf b">this.name</code>来引用它。我们也可以通过调用<code class="fe lc ld le lf b">this.name = ‘John’</code>来更新它。这会把我的名字改成约翰。我不确定我被叫做约翰是什么感觉，但是嘿，事情发生了！😅</p><p id="8e1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单来说，这个<code class="fe lc ld le lf b">let name = Sunil</code>，要么在一个组件中被创建并作为道具传递给另一个组件，要么在创建它的组件内部被使用。不管我们如何使用<code class="fe lc ld le lf b">name</code>，我们都可以通过简单地重新分配<code class="fe lc ld le lf b">name</code>来更新它。所以我可以写<code class="fe lc ld le lf b">name = ‘John'</code>，我们可以在UI的屏幕上看到更新。</p><p id="601d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经有了一些变化，让我们看看如何在我们的待办事项应用程序中添加新的项目，从而进入本质。</p><h1 id="5411" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们如何创建新的待办事项？</h1><h2 id="a2aa" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">Vue:</h2><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="0ae6" class="mp lh iq lf b gy nl nm l nn no"><strong class="lf ir">createNewToDoItem() {</strong></span><span id="4ae9" class="mp lh iq lf b gy nz nm l nn no">  const newId = this.list.length ? <br/>                Math.max.apply(null, this.list.map(t =&gt; t.id)) + 1 :<br/>                1;<br/>  <br/>  this.list.push({ id: newId, text: this.todo });<br/>  this.todo = "";</span><span id="59b4" class="mp lh iq lf b gy nz nm l nn no"><strong class="lf ir">}</strong></span></pre><h2 id="f191" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">Vue是怎么做到的？</h2><p id="792c" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在Vue中，我们的<strong class="kh ir">输入</strong>字段上有一个名为<strong class="kh ir"> v-model </strong>的句柄。这允许我们做一些被称为<strong class="kh ir">双向绑定</strong>的事情。让我们快速查看一下我们的输入字段，然后我们将解释这是怎么回事:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="b140" class="mp lh iq lf b gy nl nm l nn no">&lt;input type="text" v-model="todo"/&gt;</span></pre><p id="0dbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">V-Model将这个字段的输入与我们的数据对象toDoItem中的一个键联系起来。当页面加载时，我们必须将toDoItem设置为一个空字符串，如下:<strong class="kh ir"> todo: '' </strong>。如果这里已经有一些数据，比如<strong class="kh ir"> todo:“在这里添加一些文本”</strong>，我们的输入字段将加载已经在输入字段内的<em class="lb">在这里添加一些文本</em>。无论如何，回到空字符串，我们在输入字段中输入的任何文本都会绑定到<strong class="kh ir"> todo </strong>的值。这实际上是双向绑定(输入字段可以更新数据对象，数据对象可以更新输入字段)。</p><p id="f11f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以回头看看前面的<strong class="kh ir">createnewdoitem()</strong>代码块，我们看到我们将<strong class="kh ir"> todo </strong>的内容推入<strong class="kh ir"> list </strong> array <strong class="kh ir"> </strong>，然后将<strong class="kh ir"> todo </strong>更新为空字符串。</p><h2 id="d376" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">苗条:</h2><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="9dd4" class="mp lh iq lf b gy nl nm l nn no"><strong class="lf ir">createNewToDoItem() {</strong></span><span id="d924" class="mp lh iq lf b gy nz nm l nn no">  const newId = list.length ? <br/>                Math.max.apply(null, list.map(t =&gt; t.id)) + 1 :<br/>                1;<br/> <br/>  list.push({ id: newId, text: todo });<br/>  todo = "";</span><span id="d871" class="mp lh iq lf b gy nz nm l nn no"><strong class="lf ir">}</strong></span></pre><h2 id="ad51" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">斯维尔特是怎么做到的？</h2><p id="d50d" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在Svelte中，我们的<strong class="kh ir">输入</strong>字段有一个句柄，名为<strong class="kh ir"> bind:value </strong>。这允许我们做一些被称为<strong class="kh ir">双向绑定</strong>的事情。让我们快速查看一下我们的输入字段，然后我们将解释这是怎么回事:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="94a4" class="mp lh iq lf b gy nl nm l nn no">&lt;input type="text" bind:value={todo} /&gt;</span></pre><p id="b0d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> bind:value </strong>将该字段的输入绑定到一个我们称为<code class="fe lc ld le lf b">todo</code>的变量。当页面加载时，我们将<code class="fe lc ld le lf b">todo</code>设置为一个空字符串，比如:<code class="fe lc ld le lf b">let todo = ‘’</code>。如果这里已经有了一些数据，比如<code class="fe lc ld le lf b">let todo = ‘add some text here’</code><strong class="kh ir"/>我们的输入字段将会加载一些文本<strong class="kh ir"> <em class="lb">这里</em> </strong>已经在输入字段里面了。无论如何，回到空字符串，我们在输入字段中输入的任何文本都会绑定到<code class="fe lc ld le lf b">todo</code>的值。这实际上是双向绑定(输入字段可以更新<code class="fe lc ld le lf b">todo</code>，而<code class="fe lc ld le lf b">todo</code>可以更新输入字段)。</p><p id="1b38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以回头看看前面的<strong class="kh ir">createnewdoitem()</strong>代码块，我们看到我们将<code class="fe lc ld le lf b">todo</code> <strong class="kh ir"> </strong>的内容推入<code class="fe lc ld le lf b">list</code> <strong class="kh ir"> </strong>数组<strong class="kh ir"> </strong>，然后将<code class="fe lc ld le lf b">todo</code> <strong class="kh ir"> </strong>更新为空字符串。</p><p id="2d62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还使用了与Vue示例中相同的<code class="fe lc ld le lf b">newId()</code>函数。</p><h2 id="9fdc" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">那个newId变量是什么？</h2><p id="2bd9" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">本质上，<code class="fe lc ld le lf b">newId</code>变量被分配给一个函数的结果，这个函数基本上是创建一个新的ID，我们将把这个ID赋予新的<code class="fe lc ld le lf b">toDo</code>项。我们对Vue和Svelte使用了相同的函数。</p><h1 id="bce1" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们如何从列表中删除？</h1><h2 id="9ddf" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">Vue:</h2><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="1c58" class="mp lh iq lf b gy nl nm l nn no">onDeleteItem(id){<br/>  <strong class="lf ir">this</strong>.list = <strong class="lf ir">this</strong>.list.filter(todo =&gt; todo.id !== id);<br/>}</span></pre><h2 id="0e5d" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">Vue是怎么做到的？</h2><p id="1062" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在Vue中需要一种稍微不同的方法。我们必须做三件事:</p><p id="8fe4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在我们想要调用函数的元素上:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="021a" class="mp lh iq lf b gy nl nm l nn no">&lt;div class=”ToDoItem-Delete” @click=”deleteItem(item)”&gt;-&lt;/div&gt;</span></pre><p id="97ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们必须创建一个emit函数作为子组件(在本例中是<strong class="kh ir"> ToDoItem.vue </strong>)内部的方法，如下所示:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="3200" class="mp lh iq lf b gy nl nm l nn no">deleteItem(id) {<br/>    <strong class="lf ir">this</strong>.$emit('delete', id)<br/>}</span></pre><p id="a5f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与此同时，你会注意到当我们在<strong class="kh ir"> ToDo.vue </strong>内添加<strong class="kh ir"> ToDoItem.vue </strong>时，我们实际上引用了一个<strong class="kh ir">函数</strong>:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="1590" class="mp lh iq lf b gy nl nm l nn no">&lt;ToDoItem v-for="todo in list" <br/>          :todo="todo" <br/>          <strong class="lf ir">@delete="onDeleteItem" //</strong> &lt;-- this :)<br/>          :key="todo.id" /&gt;</span></pre><p id="35d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是所谓的自定义事件侦听器。它监听任何使用字符串“delete”触发发出的情况。如果它听到这个消息，就会触发一个名为<strong class="kh ir"> onDeleteItem </strong>的函数。该函数位于<strong class="kh ir"> ToDo.vue，</strong>内，而不是<strong class="kh ir"> ToDoItem.vue </strong>内。这个函数，如前所述，简单地过滤<strong class="kh ir"/><strong class="kh ir">数据对象</strong>中的<strong class="kh ir"> todo数组</strong>，以移除被点击的项目。</p><p id="63ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里还值得注意的是，在Vue示例中，我可以简单地在<strong class="kh ir"> @click </strong>侦听器中编写<strong class="kh ir"> $emit </strong>部分，如下所示:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="5957" class="mp lh iq lf b gy nl nm l nn no">&lt;div class=”ToDoItem-Delete” @click=”$emit(‘delete’, item)”&gt;-&lt;/div&gt;</span></pre><p id="b300" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会将步骤数从3个减少到2个，这完全取决于个人偏好。</p><h2 id="7600" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">苗条:</h2><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="6309" class="mp lh iq lf b gy nl nm l nn no">const deleteItem = event =&gt; {<br/>  const { id } = event.detail;<br/>  list = list.filter(item =&gt; item.id !== id);<br/>};</span></pre><h2 id="3f48" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">斯维尔特是怎么做到的？</h2><p id="a1c9" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">苗条身材也需要类似的方法。我们必须做三件事:</p><p id="2bb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们从上往下开始，首先是你刚才看到的<code class="fe lc ld le lf b">deleteItem</code>函数。这位于<strong class="kh ir"> ToDo.svelte </strong>的内部。如你所见，我们析构了<code class="fe lc ld le lf b">event</code>对象，将<code class="fe lc ld le lf b">event.detail.id</code>传递给<code class="fe lc ld le lf b">const id</code>。您可以将这部分看作是试图从输入字段中获取<code class="fe lc ld le lf b">event.target.value</code>。这里的不同之处在于当调用<code class="fe lc ld le lf b">deleteItem</code>函数时，<code class="fe lc ld le lf b">event</code>是作为参数(或有效载荷/数据)传入的。但是这个<code class="fe lc ld le lf b">deleteItem</code>是在<strong class="kh ir"> ToDoItem.svelte </strong>中调用的。那么，我们是如何做到这一点的呢？</p><p id="d888" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们把我们的<code class="fe lc ld le lf b">deleteItem</code>函数作为道具传递下去，就像这样:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="e239" class="mp lh iq lf b gy nl nm l nn no">&lt;ToDoItem {item} on:deleteItem={deleteItem} /&gt;</span></pre><p id="557f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在<strong class="kh ir"> ToDoItem.svelte </strong>内部，我们不能只是简单的调用<code class="fe lc ld le lf b">deleteItem</code>。您可能已经注意到，在上面的代码块中，我们没有使用相同的属性名传递我们的<code class="fe lc ld le lf b">deleteItem</code>函数，而是将它作为一个名为<code class="fe lc ld le lf b">on:deleteItem</code>的属性来传递。这基本上创建了一个名为<code class="fe lc ld le lf b">deleteItem</code>的事件监听器。因此，为了调用它，我们现在需要将一个调用“分派”回<code class="fe lc ld le lf b">deleteItem</code>，此时，如果需要，我们还可以传递一个有效载荷(一些数据)。那么我们该怎么做呢？</p><p id="78b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir"> ToDoItem.svelte </strong>内部，我们必须首先从svelte导入<code class="fe lc ld le lf b">createEventDispatcher</code>，就像这样:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="7338" class="mp lh iq lf b gy nl nm l nn no">import { createEventDispatcher } from "svelte";</span></pre><p id="a136" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建一个<code class="fe lc ld le lf b">const dispatch</code>并将其分配给<code class="fe lc ld le lf b">createEventDispatcher()</code>，如下所示:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="c41b" class="mp lh iq lf b gy nl nm l nn no">const dispatch = createEventDispatcher();</span></pre><p id="a97f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以创建一个函数来调用我们新创建的<code class="fe lc ld le lf b">dispatch</code>函数，就像这样:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="3e42" class="mp lh iq lf b gy nl nm l nn no"><strong class="lf ir">const handleDelete = id =&gt; {</strong><br/>  dispatch("deleteItem", { id });<br/><strong class="lf ir">};</strong></span></pre><p id="0a6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以从“删除”按钮调用我们的<code class="fe lc ld le lf b">handleDelete</code>函数，就像这样:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="3f6c" class="mp lh iq lf b gy nl nm l nn no">&lt;button class="ToDoItem-Delete" <br/>        on:click={() =&gt; handleDelete(item.id)}&gt; <br/>- <br/>&lt;/button&gt;</span></pre><p id="520d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们愿意，我们可以通过编写以下代码跳过创建<code class="fe lc ld le lf b">handleDelete</code>函数:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="b00b" class="mp lh iq lf b gy nl nm l nn no">&lt;button class="ToDoItem-Delete" <br/>        on:click={() =&gt; dispatch("deleteItem", { item.id })}&gt; <br/>- <br/>&lt;/button&gt;</span></pre><p id="3fb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这完全取决于个人喜好。</p><p id="ac7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，Vue和Svelte中的子组件可以以几乎相同的方式访问父组件。区别只是语义上的，Vue称之为“发射”数据，而Svelte称之为“调度”数据。</p><p id="b53b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Svelte，我们有另一种方法可以将函数作为道具传递下去，这与React采用的类似方法类似。然而，出于本教程的目的，我们选择使其类似于Vue。</p><h1 id="c1b9" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们如何传递DOM事件侦听器？</h1><h2 id="beac" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">Vue:</h2><p id="8791" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在Vue中，这是非常直接的。我们简单地使用<strong class="kh ir"> @ </strong>符号，然后是我们想要做的事件监听器的类型。例如，要添加一个点击事件监听器，我们可以编写如下代码:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="c539" class="mp lh iq lf b gy nl nm l nn no">&lt;button class=”ToDo-Add” @click=”createNewToDoItem()”&gt;+&lt;/div&gt;</span></pre><p id="691d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注:<strong class="kh ir"> @click </strong>其实是简写<strong class="kh ir"> v-on:click </strong>。Vue事件侦听器最酷的一点是，您还可以将许多东西链接到它们上面，比如。once防止事件侦听器被触发多次。在编写处理击键的特定事件侦听器时，也有许多快捷方式。在Vue中，我可以简单地写下:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="1425" class="mp lh iq lf b gy nl nm l nn no">&lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&gt;Svelte:</span></pre><p id="3ba7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在苗条的时候，它也是非常直截了当的。我们简单地在:句柄上使用<strong class="kh ir">，然后使用我们想要的事件监听器的类型。例如，要添加一个点击事件监听器，我们可以写<strong class="kh ir"> on:click </strong>，如下例所示:</strong></p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="5f12" class="mp lh iq lf b gy nl nm l nn no">&lt;button class="ToDo-Add" on:click={createNewToDoItem}&gt;+&lt;/button&gt;</span></pre><p id="ee6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条事件监听器的一个很酷的事情是，你也可以把一堆东西链接到它们上面，比如<strong class="kh ir"> once </strong>防止事件监听器被触发不止一次。</p><h1 id="3b1d" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们如何将数据/道具传递给子组件？</h1><h2 id="8c4f" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">Vue:</h2><p id="7f16" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在Vue中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="d59e" class="mp lh iq lf b gy nl nm l nn no">&lt;ToDoItem v-for="item in list" <br/>  :item="item" <br/>  @delete="onDeleteItem" <br/>  :key="item.id" /&gt;</span></pre><p id="2307" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我们将它们传递给子组件中的props数组，如下:<strong class="kh ir"> props: [ 'todo' ] </strong>。然后可以在孩子中通过它们的名字引用它们——所以在我们的例子中，是<strong class="kh ir">‘todo</strong>’。</p><h2 id="3e84" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">苗条:</h2><p id="1636" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">苗条的话，差不多也是这样:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="f2b5" class="mp lh iq lf b gy nl nm l nn no">&lt;ToDoItem {item} on:deleteItem={deleteItem} /&gt;</span></pre><p id="c131" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的一个不同之处是，我们不需要向我们的<strong class="kh ir"> ToDoItem </strong>传递一个密钥，但是先不要急着这么想，我们稍后会谈到这一点。</p><p id="c8eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个区别是，我们可以通过简单地编写<code class="fe lc ld le lf b">{item}</code>来传递<code class="fe lc ld le lf b">item</code>。这是因为道具名称和实际道具具有相同的名称。写<code class="fe lc ld le lf b">item={item}</code>也是一样的，但是我的苗条设置自动将其修改为简单的<code class="fe lc ld le lf b">{item}</code>。</p><p id="f06a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦完成，我们必须在我们的<strong class="kh ir"> ToDoItem.svelte </strong>文件中创建一个名为<code class="fe lc ld le lf b">item</code>的变量，方法是将<code class="fe lc ld le lf b">export let item;</code>写到文件的<strong class="kh ir"> &lt;脚本&gt; </strong>部分的顶部。这样我们可以在文件中引用<code class="fe lc ld le lf b">item</code>,而不会因为试图引用一个不存在的变量而出错。这里你要记住的是，在编译过程中，Svelte会检查我们的<strong class="kh ir"> ToDoItem </strong>是否被传递了一个名为<code class="fe lc ld le lf b">item</code>的道具。在我们的例子中，它有，所以作为道具传递的<code class="fe lc ld le lf b">item</code>的值将被分配给我们的<code class="fe lc ld le lf b">export let item;</code>。这使得我们的应用程序能够像我们期望的那样工作。然后可以在孩子中通过它们的名字引用它们——所以在我们的例子中，是<strong class="kh ir">‘todo</strong>’。</p><h1 id="197b" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们如何将数据发送回父组件？</h1><h2 id="c58c" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">Vue:</h2><p id="3f12" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在我们的子组件中，我们只需编写一个函数，将值发送回父函数。在我们的父组件中，我们编写了一个函数来监听何时发出该值，然后触发一个函数调用。我们可以在<em class="lb">“如何从列表中删除”一节中看到整个过程的示例。</em></p><h2 id="a649" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">苗条:</h2><p id="6d48" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在我们的子组件中，我们简单地编写了一个分派函数，它将一个值发送回父函数。在我们的父组件中，我们编写了一个函数来监听何时发出该值，然后触发一个函数调用。我们可以在“如何从列表中删除”一节中看到整个过程的示例。</p><h1 id="eb17" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们如何在组件内部循环数据？</h1><h2 id="ff17" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">某视频剪辑软件</h2><p id="0c7c" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在Vue中我们用的是<code class="fe lc ld le lf b">v-for</code>，这是Vue特有的。这是一种循环数据的方法。你可以在这里看到，由于我们只是循环通过我们的数据来输出多个<strong class="kh ir">到数据项</strong>，我们实际上可以直接在<code class="fe lc ld le lf b">&lt;ToDoItem/&gt;</code>组件上使用<code class="fe lc ld le lf b">v-for</code>。这是我们在代码中实现它的方式:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="5438" class="mp lh iq lf b gy nl nm l nn no">&lt;ToDoItem v-for="item in list" <br/>          :item="item" @delete="onDeleteItem" <br/>          :key="item.id" /&gt;</span></pre><h2 id="9456" class="mp lh iq bd li mq mr dn lm ms mt dp lq ko mu mv ls ks mw mx lu kw my mz lw na bi translated">苗条的</h2><p id="a65e" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">在Svelte中，我们用的是<code class="fe lc ld le lf b">#each</code>，专门针对Svelte的。这是一种循环数据的方法。这是我们在代码中实现它的方式:</p><pre class="lz ma mb mc gt nh lf ni nj aw nk bi"><span id="3b64" class="mp lh iq lf b gy nl nm l nn no"><strong class="lf ir">{#each list as item, i (item.id)}</strong><br/>  &lt;ToDoItem {item} on:deleteItem={deleteItem} /&gt;<br/><strong class="lf ir">{/each}</strong></span></pre><p id="c6b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会注意到，然后我们取我们的<code class="fe lc ld le lf b">list</code>变量，并在它后面跟随<code class="fe lc ld le lf b">as item</code>。这基本上就是说，以我们的<code class="fe lc ld le lf b">list</code>为例，把它分解成我们称之为<code class="fe lc ld le lf b">item</code>的单个项目。然后我们给每个<code class="fe lc ld le lf b">item</code>一个我们称之为<code class="fe lc ld le lf b">i</code>的索引，然后在我们想要使用的索引后面的括号中写下，在这种情况下，就是我们的<code class="fe lc ld le lf b">item.id</code>。你还会注意到，我们不需要在这里传递一个<code class="fe lc ld le lf b">key</code>给我们的<code class="fe lc ld le lf b">&lt;ToDoItem/&gt;</code>，因为Svelte无论如何都会分配它。</p><h1 id="13f0" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">我们做到了！🎉</h1><p id="dc8d" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">我们已经了解了如何添加、删除和更改数据，如何以props的形式将数据从父节点传递到子节点，以及如何以事件侦听器的形式将数据从子节点发送到父节点。当然，Vue和Svelte之间还有许多其他的小差异和怪癖，但是希望这篇文章的内容有助于为理解它们如何处理事情提供一点基础。</p><p id="e113" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对本文中使用的样式感兴趣，并想制作您自己的等效作品，请随时这样做！👍</p><h1 id="3005" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">Github链接到两个应用程序:</h1><p id="25bc" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">https://github.com/sunil-sandhu/vue-todo-2019</p><p id="8479" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的托多:<a class="ae oa" href="https://github.com/sunil-sandhu/svelte-todo" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/svelte-todo</a></p><h1 id="dc3b" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">但是反应呢？！</h1><p id="c995" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">很高兴你问了！以下是我们的对比产品:</p><p id="d79e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">React vs Vue:</strong><a class="ae oa" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56" rel="noopener">https://medium . com/JavaScript-in-plain-English/I-created-the-exact-same-app-in-React-and-Vue-here-are-the-differences-2019-edition-42 ba 2 cab 9 e 56</a></p><p id="bacd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">React vs Svelte:</strong><a class="ae oa" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-svelte-here-are-the-differences-c0bd2cc9b3f8" rel="noopener">https://medium . com/JavaScript-in-plain-English/I-created-the-exact-same-app-in-React-and-Svelte-here-is-the-differences-c 0 BD 2c C9 B3 f 8</a></p></div></div>    
</body>
</html>