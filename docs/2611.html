<html>
<head>
<title>Practical Examples to Explain forkJoin, zip, withLatestFrom, and combineLatest Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释forkJoin、zip、withLatestFrom和combineLatest运算符的实际示例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/practical-examples-to-explain-forkjoin-zip-withlatestfrom-and-combinelatest-operators-2a1a9cd862cf?source=collection_archive---------2-----------------------#2020-07-09">https://javascript.plainenglish.io/practical-examples-to-explain-forkjoin-zip-withlatestfrom-and-combinelatest-operators-2a1a9cd862cf?source=collection_archive---------2-----------------------#2020-07-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="16c6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用实例解释四种RXJS组合运算符。</h2></div><p id="34ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我一直觉得这4个RXJS组合运算符非常令人困惑。如果理解清楚，它们是非常有用的。</p><ol class=""><li id="3436" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">为了理解这一点，让我们举一个长度转换应用程序的例子。</li></ol><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="58f6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个有3个窗体控件的简单窗体。用户输入一个数字，可以将它从米转换成厘米，反之亦然。我想注意两点:</p><p id="5bb6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;当用户第一次输入时，我们不需要答案，直到输入和转换字段都已填写完毕。</p><p id="a70b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;下次用户更改数字或转换时，答案应该会更新。要更新答案，两个字段都不需要填写。</p><p id="7c9b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看combineLatest如何帮助我们。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="52b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有两个使用<strong class="ke io"> valueChanges属性</strong>创建的可观察对象，可用于反应式表单中的每个表单控件。每当控件的值改变时，操作符返回一个发出控件的更新值的可观察值。该valueChanges属性已被添加到<strong class="ke io">动作</strong>和<strong class="ke io">输入数量</strong>表单控件中。</p><p id="759d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将这两个可观测量作为参数传递给combineLatest操作符。现在让我们理解这个操作符在这个场景中的行为。</p><p id="7873" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;用户在输入字段中输入数字1200。触发一个变化，1200是第二个可观测值发出的值。没有观察到输出场的变化。</p><p id="917f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;用户选择转换为“厘米到米”。触发变化，并且“m”是由第一个可观测值发出的值。<strong class="ke io">当两个观察值都发出至少1个值时，combineLatest操作符将发出一个数组，该数组包含观察值发出的值</strong>，格式如下:<strong class="ke io"> ["m "，" 1200"] </strong></p><p id="1ada" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">订阅触发，我们正在执行计算以确定输出。请注意，我们已经编写了[action，number],而不是简单地编写x或y或数据，以便我们能够将“m”映射到action，将“1200”映射到number。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="0679" class="lt lu in lp b gy lv lw l lx ly">subscribe(([action, number]) =&gt; {<br/>action === 'cm'<br/>? this.lengthConvForm.get('answer').setValue(number * 100)<br/>: this.lengthConvForm.get('answer').setValue(number / 100);<br/>});</span></pre><p id="e397" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;下一次，用户将输入更改为12，combineLatest操作符将发出输出["m "，" 12"]。它不会等待两个可观测量都发出值。<strong class="ke io">发出一个值的一个或两个观察值足以让操作员触发一个值。</strong></p><p id="870f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以看看下面的例子。</p><div class="lz ma gp gr mb mc"><a href="https://stackblitz.com/edit/angular-rixeug?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd io gy z fp mh fr fs mi fu fw im bi translated">角形(叉形)堆叠</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">一个基于rxjs，tslib，core-js，zone.js，@angular/core，@angular/forms，@angular/common的angular-cli项目…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">stackblitz.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq mr mc"/></div></div></a></div><p id="db37" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我总结一下。</p><p id="40f9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;第一次尝试时，combineLatest运算符将等待所有可观测值发出至少1个值后再触发。所有的观察者都像团队一样工作。</p><p id="f227" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;在随后的尝试中，当任何可观测量发出一个值时，操作符将触发。没有必要让所有的观测值都发出一个值。combineLatest操作员第一次开火后，观察对象之间没有协同工作。</p><p id="b462" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">=&gt; <strong class="ke io">当操作符触发时，它会发出一个数组，该数组包含所有观察对象在发出时发出的值。</strong></p><p id="d9cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;如果其中一个观察完成，操作员不会停止，而是继续发射，直到所有观察都完成。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="9e22" class="lt lu in lp b gy lv lw l lx ly"><strong class="lp io">combineLatest</strong>(<br/>interval(1000).pipe(take(3)),<br/>interval(1000).pipe(take(4)),<br/>interval(1000).pipe(take(5)).subscribe(x=&gt;console.log(x))</span></pre><p id="e6fb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们有3个将在不同时间完成的可观测量。发出0，1，2后，第一个可观测值完成。第二个可观察值在发出0，1，2，3后完成，第三个可观察值在发出0，1，2，3，4后完成。</p><p id="c6cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个可观察到的首先完成。但是当其他两个观察值发出值时，操作符继续触发，如下图所示。</p><p id="3dd5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个数组由3个可观测量发出的3个值组成。还要注意，当第一个可观察对象完成时，数组的第一个值仍然是2，即操作符考虑第一个可观察对象完成后发出的最后一个值。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/f3a03aeae4596007ac2114b6a78c681a.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*7hxkaRHA_ug-5GOvtB7mqg.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">combineLatest</figcaption></figure><p id="d31f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.<strong class="ke io"> zip </strong> : zip操作符类似于combineLatest，略有不同。</p><p id="865d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> Zip运算符仅在所有可观察对象在任何尝试中发出至少1个值时触发。你可以认为观察者总是像一个团队一样工作。</strong></p><p id="08b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一个可观测量完成，那么即使其它可观测量没有完成，操作者也停止输出任何值。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="f3d9" class="lt lu in lp b gy lv lw l lx ly"><strong class="lp io">zip</strong>(<br/>interval(1000).pipe(take(3)),<br/>interval(1000).pipe(take(4)),<br/>interval(1000).pipe(take(5))).subscribe(x=&gt;console.log(x));</span></pre><p id="fe01" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，第一个可观测值将在发射0、1和2后首先完成。zip操作符将在此之后停止触发，即使其他2个观察点发出值，如下所示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi my"><img src="../Images/611b15d10cbe380207df49b54aeeedc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*KsGlfnTk5NnsLFjbRgKX_w.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">zip</figcaption></figure><p id="97f9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个例子，当你想计算点击一个按钮的时间。这是一个非常不寻常的用例，但是为了简单起见，我已经考虑过了。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="792c" class="lt lu in lp b gy lv lw l lx ly">&lt;button id=”button”&gt;Click Me!&lt;/button&gt;</span></pre><p id="c541" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我只需要一个按钮:)</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="0547" class="lt lu in lp b gy lv lw l lx ly"><strong class="lp io">ngOnInit(){</strong><br/><strong class="lp io">zip</strong>(<br/><strong class="lp io">fromEvent</strong>(document.querySelector(‘button#button’),’<strong class="lp io">mousedown</strong>’).pipe(map(x=&gt;x.timeStamp)),</span><span id="a11c" class="lt lu in lp b gy mz lw l lx ly"><strong class="lp io">fromEvent</strong>(document.querySelector(‘button#button’),’<strong class="lp io">mouseup</strong>’).pipe(<br/>map(x=&gt;x.timeStamp)))<br/>.subscribe(([down,up])=&gt;console.log((up-down)/1000 +”sec”))<br/>}</span></pre><p id="7ecd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个简单的逻辑。我们正在考虑两个显著的问题。第一个可观察对象是在我点击按钮时创建的，我还没有释放它。触发了一个<strong class="ke io">鼠标按下</strong>事件。</p><p id="870b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我释放按钮点击时，一个<strong class="ke io"> mouseup </strong>事件将被触发，第二个可观察到的事件将被创建。</p><p id="b060" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将两个观察对象发出的事件对象映射到事件的时间戳。因此，两个可观察对象现在都将发出它们各自事件的时间戳。</p><p id="09cc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">只有在两个observables发出时间戳值后，zip操作符才会触发。</strong>计算花费的时间依赖于两个可观测量发出的值，因此zip运算符在这种情况下非常有用。</p><p id="e76d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.<strong class="ke io"> forkJoin: </strong>该操作符仅在所有可观察对象完成时触发，它发出一个对象，该对象由每个可观察对象发出的所有<strong class="ke io">最后一个值组成。</strong></p><p id="0830" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您希望多个HTTP请求并行执行时，这非常有用。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="8df2" class="lt lu in lp b gy lv lw l lx ly"><strong class="lp io">//Example 1<br/>forkJoin</strong>({<br/>users:this.http.get(‘<a class="ae na" href="https://jsonplaceholder.typicode.com/users'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users'</a>),<br/>comments:this.http.get(‘<a class="ae na" href="https://jsonplaceholder.typicode.com/comments'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/comments'</a>),<br/>todos:this.http.get(‘<a class="ae na" href="https://jsonplaceholder.typicode.com/todos'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos'</a>)<br/> }).subscribe(x=&gt;console.log(x));</span></pre><p id="49b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将返回一个由3个名为users、comments和todos的数组组成的对象。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="5c18" class="lt lu in lp b gy lv lw l lx ly"><strong class="lp io">//Example 2</strong></span><span id="6192" class="lt lu in lp b gy mz lw l lx ly"><strong class="lp io">forkJoin</strong>({ <br/>int1:interval(1000).pipe(take(5)),<br/> int2:interval(1000).pipe(take(4)),<br/> int3:interval(1000).pipe(take(2)),<br/> }).subscribe(x=&gt;console.log(x));</span></pre><p id="fddd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述代码的输出将是<strong class="ke io"> {int1: 4，int2: 3，int3: 1} </strong></p><p id="e71d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.<strong class="ke io"> withLatestFrom </strong>:让我们来看一个场景，我想计算每两秒钟我点击一个按钮的次数。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="8d04" class="lt lu in lp b gy lv lw l lx ly">&lt;button id=”button”&gt;Click Me!&lt;/button&gt;</span></pre><p id="0320" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们只需要一个简单的按钮。</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="bf71" class="lt lu in lp b gy lv lw l lx ly"><strong class="lp io">ngOnInit()</strong>{<br/>const clickEvent=<strong class="lp io">fromEvent</strong>(document.querySelector(‘button#button’),’click’).pipe(<br/><strong class="lp io">mapTo</strong>(1),<br/><strong class="lp io">scan</strong>((acc,curr)=&gt;acc+curr,0));</span><span id="2b97" class="lt lu in lp b gy mz lw l lx ly">clickEvent.pipe(<strong class="lp io">withLatestFrom</strong>(interval(2000))).subscribe(([click,time])=&gt;{<br/>console.log(“You have clicked”+click+” times in”+time+ “ secs”);<br/>});<br/>}</span></pre><p id="35ac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里有两个观察点。每当单击按钮时，第一个observable就会发出一个事件对象。我们正在映射事件对象，每次点击按钮都映射到一个常量1。这对于计算点击量是很重要的。</p><p id="abb3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">扫描运算符用于执行此操作。acc的初始值为0，curr的初始值为1。随着每一次点击，货币被添加到acc中以给出新的累积值。</p><p id="c6a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个可观察值是由间隔运算符创建的，它每2秒钟发出一个从0开始的数字。</p><p id="ac28" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次单击按钮时，我们都会检查由interval运算符创建的observable发出的最新秒数，以打印在此期间按钮被单击的次数，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/717bd626e88c471055d056d5bf4b5120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*YN05Qmd0SsEdDyU-7EQlqw.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">withLatestFrom</figcaption></figure><p id="f555" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">LatestFrom函数的用法如下:</p><p id="ff71" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;第一次单击按钮时，withLatestFrom运算符仅在interval运算符创建的observable发出值后触发。</p><p id="acb9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">= &gt;在随后的时间里，操作者不会等待可观测区间发出新值。每当单击按钮时，它就会触发，并考虑可观察间隔发出的最新值。</p><p id="5da3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nc">更多内容看</em> <a class="ae na" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nc">说白了就是</em> </strong> </a> <em class="nc">。报名参加我们的</em> <a class="ae na" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nc">免费周报</em> </strong> </a> <em class="nc">。关注我们关于</em><a class="ae na" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nc">Twitter</em></strong></a><em class="nc">和</em><a class="ae na" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io"><em class="nc">LinkedIn</em></strong></a><em class="nc">。加入我们的</em> <a class="ae na" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> <em class="nc">社区</em> </strong> </a> <em class="nc">。</em></p></div></div>    
</body>
</html>