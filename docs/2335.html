<html>
<head>
<title>Create a Full Stack Banking Application using React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React创建全栈银行应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-full-stack-banking-application-using-react-23d0ef2f5bd2?source=collection_archive---------2-----------------------#2020-06-14">https://javascript.plainenglish.io/create-a-full-stack-banking-application-using-react-23d0ef2f5bd2?source=collection_archive---------2-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0219" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分:通过避免使用本地存储来存储JWT令牌，使应用程序免受XSS和CSRF攻击</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/90c9af1e67420864f7fd907154695683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*og7yv2F6xaclT_Bd"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@johnschno?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">John Schnobrich</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ad85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是构建全栈银行应用程序系列的第三部分。<br/>你可以在这里查看第一部分<a class="ae kv" href="https://medium.com/javascript-in-plain-english/create-a-fullstack-banking-application-using-react-e8c96d74cd39?source=friends_link&amp;sk=5038dbe0d06acec7fdeed694690cb91a" rel="noopener">，在这里</a>查看第二部分<a class="ae kv" href="https://medium.com/javascript-in-plain-english/create-a-full-stack-banking-application-using-react-part-2-6fb21200613a?source=friends_link&amp;sk=0394e9bb66379594d2ebc7bffdfbfea5" rel="noopener"/></p><p id="1235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将了解如何避免在本地存储中存储JWT令牌，以使应用程序更加安全，并防止XSS和CSRF攻击</p><h2 id="57bd" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">我们开始吧</h2><p id="3604" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">从这里的<a class="ae kv" href="https://github.com/myogeshchavan97/fullstack_banking_app" rel="noopener ugc nofollow" target="_blank">克隆初始存储库代码</a>，它是我们在本系列的第一部分<a class="ae kv" href="https://medium.com/javascript-in-plain-english/create-a-fullstack-banking-application-using-react-e8c96d74cd39" rel="noopener">本文</a>中创建的</p><p id="6838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过运行以下命令启动应用程序</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="0703" class="ls lt iq mr b gy mv mw l mx my">cd server<br/>yarn install<br/>yarn start</span></pre><p id="d96a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将启动<code class="fe mz na nb mr b">Express</code>服务器。</p><p id="716a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在同一个项目文件夹中打开另一个终端，并执行以下命令</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8738" class="ls lt iq mr b gy mv mw l mx my">yarn install<br/>yarn start</span></pre><p id="e0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将启动<code class="fe mz na nb mr b">React</code>应用程序。</p><p id="0805" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以在<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>访问应用程序</p><p id="a3a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还记得，我们将JWT令牌存储在登录时生成的本地存储中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/c94d42df8f361fa447ffec2a33126cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJl8LmQDNmQS0ymuaulk6Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">adding token to local storage</figcaption></figure><p id="cd1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且使用本地存储中的这个JWT令牌，我们在<code class="fe mz na nb mr b">src/utils/common.js</code>文件中的<code class="fe mz na nb mr b">maintainSession</code>函数中维护会话。</p><p id="221e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在本地存储中存储会话是不安全的，因为任何人都可以通过读取本地存储数据来窃取你的JWT令牌。在这里阅读这将如何产生安全问题。</p><p id="d49b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以要解决这个问题，我们需要使用由服务器创建的<code class="fe mz na nb mr b">HttpOnly</code> cookie，当我们使用<code class="fe mz na nb mr b">document.cookie</code>访问cookie时，它是不可访问的。</p><p id="1718" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们用<code class="fe mz na nb mr b">HttpOnly</code> cookie替换本地存储功能。</p><p id="d9f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mz na nb mr b">server/routes/auth.js</code>，在将令牌添加到<code class="fe mz na nb mr b">/signin</code> route中的用户对象之前，通过添加以下代码创建一个cookie:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a5d5" class="ls lt iq mr b gy mv mw l mx my">res.cookie('token', token, {<br/> httpOnly: true<br/>});</span></pre><p id="16ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">cookie函数接受以下参数:</p><ul class=""><li id="196e" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">cookie的名称</li><li id="0643" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">要存储在cookie中的值</li><li id="003e" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">附加选项</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/2cbc4b62febd215295ad1c4ea60e0bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o45SXRTI4upBGNDkQvHSCA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">sign in route code</figcaption></figure><p id="654f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，重新启动服务器，注销并重新登录到应用程序。登录后，您将在<code class="fe mz na nb mr b">/signin</code>路由的响应头中看到<code class="fe mz na nb mr b">set-cookie</code>头。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e46f3c8b2facac2d079a5385f6fa6cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqBQDZhJgAE-8OBQEzHXCg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Set-Cookie header added in response</figcaption></figure><p id="e4d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你检查chrome开发者工具上的应用程序标签，你会看到cookie没有显示在我们的应用程序的<code class="fe mz na nb mr b">cookie</code>部分，我们的应用程序运行在<a class="ae kv" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/7e332256b835f1d96d572e782e37c8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LWdQmf-AU3B5-onl1pEbA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">List of cookies</figcaption></figure><p id="3d7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们的<code class="fe mz na nb mr b">Express</code>服务器运行在端口<code class="fe mz na nb mr b">5000</code>上，你可以在<code class="fe mz na nb mr b">server/index.js</code>文件中验证，我们的<code class="fe mz na nb mr b">React</code>应用程序运行在端口<code class="fe mz na nb mr b">3000</code>上。检查下面的API <code class="fe mz na nb mr b">Request URL</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/44a765d9fefe7610e35f02b9e02983f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7tP-zD4-t4Sp3iLUgIgKQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Server APIs running on port 5000</figcaption></figure><p id="c1ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">cookies是<code class="fe mz na nb mr b">domain and port specific</code>的，所以如果它们是在端口<code class="fe mz na nb mr b">3000</code>上创建的，它们只在端口<code class="fe mz na nb mr b">3000</code>上可用，在<code class="fe mz na nb mr b">5000</code>上不可用。</p><p id="74bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何解决这个问题呢？</p><p id="e06c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb mr b">Create-react-app</code>提供了解决这个问题的简单方法。</p><p id="f70c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开我们的<code class="fe mz na nb mr b">React</code>应用程序的主<code class="fe mz na nb mr b">package.json</code>文件，并在文件末尾添加另一个带有关键字<code class="fe mz na nb mr b">proxy</code>的属性:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="55b4" class="ls lt iq mr b gy mv mw l mx my">"proxy": "http://localhost:5000/"</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bee3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，打开<code class="fe mz na nb mr b">src/utils/constants.js</code>文件并更改:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5748" class="ls lt iq mr b gy mv mw l mx my">export const BASE_API_URL = 'http://localhost:5000';</span></pre><p id="5c2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">收件人:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d21a" class="ls lt iq mr b gy mv mw l mx my">export const BASE_API_URL = '';</span></pre><p id="5e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在将<code class="fe mz na nb mr b">app.use(cors())</code>从<code class="fe mz na nb mr b">server/index.js</code>中移除，因为不再需要它，现在通过再次运行<code class="fe mz na nb mr b">yarn start</code>命令重启<code class="fe mz na nb mr b">Express</code>服务器和<code class="fe mz na nb mr b">React</code>应用程序，这样这些更改就会生效。</p><p id="9cba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在注销并重新登录到您的应用程序，这一次，您将看到cookie令牌值显示在<code class="fe mz na nb mr b">application</code>选项卡中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/0fe93ca3345a3ed4db033faaf08a17b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xz5C5tnzYZpOZvqxgrJoHQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">token in cookie</figcaption></figure><p id="180e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还会看到<code class="fe mz na nb mr b">HttpOnly</code>列的复选标记，指明它是<code class="fe mz na nb mr b">HttpOnly</code>并且不能通过<code class="fe mz na nb mr b">document.cookie.</code>访问，因此我们的jwt令牌现在是安全的。</p><p id="3582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，如果您现在查看服务器API的请求URL，它是<a class="ae kv" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>和<strong class="ky ir">而不是</strong><a class="ae kv" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/8da2d4716b7b47b60a9c0f3d78b67e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eoxr5XINlk6nEexCVkaxLg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Server APIs running served on port 3000</figcaption></figure><p id="03cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此<code class="fe mz na nb mr b">React</code>充当服务器的代理，并在端口<code class="fe mz na nb mr b">3000</code>上路由我们所有的应用编程接口请求，所以服务器上的cookie是在端口<code class="fe mz na nb mr b">3000</code>上创建的，并且可以在同样在端口<code class="fe mz na nb mr b">3000</code>上运行的<code class="fe mz na nb mr b">React</code>应用程序中访问。所以我们可以走了。</p><p id="9ff5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如前所述，我们已经在<code class="fe mz na nb mr b">/signin</code>路由内的cookie中添加了令牌，但是为了在<code class="fe mz na nb mr b">auth middleware</code>中获取该令牌以便验证身份验证，我们需要安装<code class="fe mz na nb mr b">cookie-parser</code> npm包。</p><p id="2d42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从<code class="fe mz na nb mr b">server</code>文件夹安装<code class="fe mz na nb mr b">cookie-parser</code> npm包:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f730" class="ls lt iq mr b gy mv mw l mx my">yarn add cookie-parser@1.4.5</span></pre><p id="1ffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将配置<code class="fe mz na nb mr b">Express</code>服务器来使用这个中间件。</p><p id="bc9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mz na nb mr b">server/index.js</code>并在<code class="fe mz na nb mr b">app.use(express.json());</code>语句后增加另一个<code class="fe mz na nb mr b">app.use</code>调用:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2bb4" class="ls lt iq mr b gy mv mw l mx my">app.use(cookieParser());</span></pre><p id="a085" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，导入顶部的<code class="fe mz na nb mr b">cookie-parser</code>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="05da" class="ls lt iq mr b gy mv mw l mx my">const cookieParser = require('cookie-parser');</span></pre><p id="86bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的<code class="fe mz na nb mr b">index.js</code>现在会变成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将使用<code class="fe mz na nb mr b">cookie</code>而不是<code class="fe mz na nb mr b">local storage</code>的令牌来维护会话。</p><p id="3fbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mz na nb mr b">server/middleware/auth.js</code>，出现以下代码:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2e30" class="ls lt iq mr b gy mv mw l mx my">const token = req.header('Authorization').split(' ')[1];</span></pre><p id="59f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加以下代码:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9037" class="ls lt iq mr b gy mv mw l mx my">const token = req.cookies.token;</span></pre><p id="30dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>该令牌在<code class="fe mz na nb mr b">request.cookies</code>才有，因为我们在<code class="fe mz na nb mr b">server/index.js</code>文件中增加了<code class="fe mz na nb mr b">cookie-parser</code>，在增加回复的同时将其命名为<code class="fe mz na nb mr b">token</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4d26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，重新启动服务器，注销并重新登录应用程序。登录后，您会在<code class="fe mz na nb mr b">/signin</code>路由的响应报头中看到<code class="fe mz na nb mr b">set-cookie</code>报头，也可以在<code class="fe mz na nb mr b">cookie</code>报头中的请求报头中看到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/d23f947251e8f16d59aa38b1fb87efd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3x0ns6PxtrjqpQLjp9WgIw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Profile page</figcaption></figure><p id="d0e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此<code class="fe mz na nb mr b">Express</code>正确地发送回了cookie中的令牌值，并且它也作为请求的一部分在每个服务器API中发送，因为我们登录了该API，并且我们的配置文件信息也被显示出来。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e46f3c8b2facac2d079a5385f6fa6cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqBQDZhJgAE-8OBQEzHXCg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Cookie in response header</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/8a23f1e59183e47a2823931c0e7d8cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fI1JctU_ezaPKJUA6nofXw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Cookie in request header</figcaption></figure><p id="7fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当您刷新页面时，您将退出应用程序。</p><p id="3f29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们需要添加代码来维护我们的<code class="fe mz na nb mr b">React</code>应用程序中的会话。</p><p id="e3f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以打开<code class="fe mz na nb mr b">actions/auth.js</code>文件和里面的<code class="fe mz na nb mr b">initiateLogin</code>功能，替换:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7ee8" class="ls lt iq mr b gy mv mw l mx my">localStorage.setItem('user_token', user.token);</span></pre><p id="0e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4a43" class="ls lt iq mr b gy mv mw l mx my">user.isAuthenticated = true;</span></pre><p id="619f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是有一个标志，所以我们可以使用它来识别任何文件是否登录。</p><p id="b25a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在<code class="fe mz na nb mr b">src/router</code>文件夹中创建一个新文件<code class="fe mz na nb mr b">PrivateRoute.js</code>，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mz na nb mr b">src/router</code>文件夹中新建一个文件<code class="fe mz na nb mr b">PublicRoute.js</code>，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="43cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<code class="fe mz na nb mr b">router/AppRouter.js</code>替换为以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c8d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用以下内容替换<code class="fe mz na nb mr b">utils/api.js</code>的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e96f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们通过调度一个动作将redux状态的auth对象中的<code class="fe mz na nb mr b">isAuthenticated</code>设置为true，这样我们就可以限制对页面的公共访问，这些页面只有在登录后才能访问。</p><p id="6566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在<code class="fe mz na nb mr b">src/actions/auth.js</code>内部，用<code class="fe mz na nb mr b">post</code>替换<code class="fe mz na nb mr b">axios.post</code>的所有引用，并将<code class="fe mz na nb mr b">initiateLogout</code>功能代码更改为以下代码:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1ba9" class="ls lt iq mr b gy mv mw l mx my">export const initiateLogout = () =&gt; {<br/>  return async (dispatch) =&gt; {<br/>    try {<br/>      await post(`${BASE_API_URL}/logout`);<br/>      return dispatch(signOut());<br/>    } catch (error) {<br/>      error.response &amp;&amp; dispatch(getErrors(error.response.data));<br/>    }<br/>  };<br/>};</span></pre><p id="7de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，用以下代码替换<code class="fe mz na nb mr b">src/utils/common.js</code>中的<code class="fe mz na nb mr b">maintainSession</code>功能:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1ad7" class="ls lt iq mr b gy mv mw l mx my">export const maintainSession = () =&gt; {<br/>  const currentPath = window.location.pathname;<br/>  if (currentPath === '/profile') {<br/>    store.dispatch(initiateGetProfile());<br/>  }<br/>};</span></pre><p id="261c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，移除定义在<code class="fe mz na nb mr b">maintainSession</code>功能下的<code class="fe mz na nb mr b">updateStore</code>功能。您也可以从<code class="fe mz na nb mr b">common.js</code>文件中删除<code class="fe mz na nb mr b">removeAuthHeader</code>功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="243f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，通过运行<code class="fe mz na nb mr b">yarn start</code>重启<code class="fe mz na nb mr b">Express</code>服务器和<code class="fe mz na nb mr b">React</code>应用程序，您可以看到应用程序工作正常，我们只使用<code class="fe mz na nb mr b">HttpOnly</code> cookie来存储令牌。因此，本地存储的安全问题现在已经解决。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/efb7249ff1363fa08d4df0fb6fdb7205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*22jqfY2b3-ttMAhF_KNFDQ.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Application</figcaption></figure><p id="3d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到Github的源代码直到这个点<a class="ae kv" href="https://github.com/myogeshchavan97/jwt-authentication-security/tree/using-httponly-cookie" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="77a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在，使用<code class="fe mz na nb mr b">HttpOnly</code> cookie我们已经保护了我们的应用免受<code class="fe mz na nb mr b">XSS(Cross Site Scripting)</code>攻击，但是我们的应用仍然不是完全安全的，因为<code class="fe mz na nb mr b">HttpOnly</code>cookie仍然容易受到<code class="fe mz na nb mr b">CSRF(Cross Site Request Forgery)</code>攻击。</p><p id="5b74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们也为CSRF增加安全保障。</p><p id="7c99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从<code class="fe mz na nb mr b">server</code>文件夹安装<code class="fe mz na nb mr b">csurf</code> npm包:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2fca" class="ls lt iq mr b gy mv mw l mx my">yarn add csurf@1.11.0</span></pre><p id="282a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe mz na nb mr b">server/index.js</code>文件，进行如下修改:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6e03" class="ls lt iq mr b gy mv mw l mx my">const csrf = require('csurf');<br/>const csrfProtection = csrf({ cookie: true });</span><span id="c5b4" class="ls lt iq mr b gy oj mw l mx my">// before all the middlewares in app.use add following middleware<br/>app.use(csrfProtection);</span><span id="4b5f" class="ls lt iq mr b gy oj mw l mx my">app.get('/csrf-token', (req, res) =&gt; {<br/>  res.send({ csrfToken: req.csrfToken() });<br/>});</span></pre><p id="0c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们通过设置<code class="fe mz na nb mr b">cookie: true</code>启用了<code class="fe mz na nb mr b">csrf</code>保护，然后添加了<code class="fe mz na nb mr b">csrf</code>保护作为中间件。</p><p id="a97c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ok">注意:请确保在所有其他路由之前添加</em> <code class="fe mz na nb mr b"><em class="ok">csrfProtection</em></code> <em class="ok">中间件，否则将无法正常工作。</em></p><p id="b355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们创建了一个<code class="fe mz na nb mr b">/csrf-token</code>路由，它发送回一个通过调用<code class="fe mz na nb mr b">csrfToken</code>函数生成的<code class="fe mz na nb mr b">csrf</code>令牌。</p><p id="d8b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的<code class="fe mz na nb mr b">index.js</code>文件将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8a55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，通过运行<code class="fe mz na nb mr b">yarn start</code>重启<code class="fe mz na nb mr b">Express</code>服务器和<code class="fe mz na nb mr b">React</code>应用程序，并尝试再次登录。</p><p id="4026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将得到如下所示的<code class="fe mz na nb mr b">forbidden</code>错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/23ab1abb8711c39060992df45ddd9daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G55Nu53Wgz5LAGKvI2L50A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">403 Forbidden error</figcaption></figure><p id="778e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您检查响应中的错误，您将看到<code class="fe mz na nb mr b">“invalid csrf token”</code>错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/3889b9c68dc82f3bbae3c714dc39639f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EM6t6zy4hhoLGuwyWH_HOw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Invalid csrf token error</figcaption></figure><p id="74c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们已经添加了CSRF保护，对于每个<code class="fe mz na nb mr b">not-get</code>请求，如<code class="fe mz na nb mr b">post</code>、<code class="fe mz na nb mr b">patch</code>、<code class="fe mz na nb mr b">delete</code>等，<code class="fe mz na nb mr b">csurf</code>库将期望为每个传入服务器的请求提供一个<code class="fe mz na nb mr b">_csrf</code> cookie。因此，我们需要确保对服务器的每个请求都添加了<code class="fe mz na nb mr b">_csrf</code> cookie。</p><p id="c5d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，在<code class="fe mz na nb mr b">src/utils/common.js</code>文件中添加一个新函数<code class="fe mz na nb mr b">addCSRFToken</code>:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="98ef" class="ls lt iq mr b gy mv mw l mx my">export const addCSRFToken = async () =&gt; {<br/>  try {<br/>    const result = await axios.get(`${BASE_API_URL}/csrf-token`);<br/>    return result.data.csrfToken;<br/>  } catch (error) {<br/>    console.log(error);<br/>  }<br/>};</span></pre><p id="a65f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并用以下代码替换<code class="fe mz na nb mr b">utils/api.js</code>的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里所做的是，对于我们发送到服务器的每个请求，我们都添加了一个<code class="fe mz na nb mr b">X-CSRF-Token</code>头以及包含从<code class="fe mz na nb mr b">server/index.js</code>文件的<code class="fe mz na nb mr b">/csrf-token</code>路由生成的<code class="fe mz na nb mr b">csrf</code>令牌的请求。</p><p id="67e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在，如果您重启<code class="fe mz na nb mr b">Express</code>服务器和<code class="fe mz na nb mr b">React</code>应用程序并尝试登录，您将会看到，所有的API都在工作，我们的应用程序也在增加了<code class="fe mz na nb mr b">CSRF</code>安全性的情况下工作得很好。</p><p id="66ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以在Chrome开发者工具的<code class="fe mz na nb mr b">applications</code>标签中看到<code class="fe mz na nb mr b">_csrf</code> cookie:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/81240c895a1c2867a27b7c6eb3a92bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m83n7hBbFxO0ideYRgSI6Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">_csrf cookie</figcaption></figure><p id="5e1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经完成了保护我们的应用程序所需的更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/efb7249ff1363fa08d4df0fb6fdb7205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*22jqfY2b3-ttMAhF_KNFDQ.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Working app with CSRF security</figcaption></figure><p id="8dbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以找到Github的源代码，直到此时<a class="ae kv" href="https://github.com/myogeshchavan97/jwt-authentication-security/tree/adding-csrf-security" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="c82b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。我希望你学到了新东西。</p><p id="dd59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">别忘了直接在你的收件箱</strong> <a class="ae kv" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我的每周简讯，里面有惊人的技巧、窍门和文章。</strong>T9】</a></p></div></div>    
</body>
</html>