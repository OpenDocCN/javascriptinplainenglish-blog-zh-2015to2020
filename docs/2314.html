<html>
<head>
<title>Good Parts of JavaScript — Function Invocation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的优点——函数调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/good-parts-of-javascript-function-invocation-e8369f2bfc54?source=collection_archive---------6-----------------------#2020-06-11">https://javascript.plainenglish.io/good-parts-of-javascript-function-invocation-e8369f2bfc54?source=collection_archive---------6-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd98b421c33b8089a37dfb2c3531733a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ju4OFOxT_5l-BtLj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Annie Spratt</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7b6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是世界上最流行的编程语言之一。它可以做很多事情，并且有一些领先于许多其他语言的功能。</p><p id="d034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看JavaScript函数的一些好的部分。</p><h1 id="68b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数调用</h1><p id="ac85" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数必须被调用来做一些事情。</p><p id="8118" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可能会被调用，也可能不会被调用。除了我们传入的参数，还有<code class="fe me mf mg mh b">this</code>和<code class="fe me mf mg mh b">arguments</code>值。</p><p id="f483" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">this</code>是函数驻留的对象或者构造函数的实例。</p><p id="1519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以是它所在的函数。</p><p id="d955" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用操作符是一对括号，参数之间用逗号分隔。</p><p id="8025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果参数太多，多余的参数将被忽略。</p><p id="223c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着函数的签名不必与传入的参数匹配。</p><p id="3283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参数值没有类型检查。这意味着我们可以传递任何东西。</p><p id="f0a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们向函数传递参数时应该小心。</p><h1 id="8d61" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">方法调用模式</h1><p id="143f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当一个函数存储在一个对象中时，这个函数就叫做方法。</p><p id="331e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个方法被调用时，<code class="fe me mf mg mh b">this</code>被绑定到对象上。</p><p id="c9b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用点符号或括号符号来调用方法。</p><p id="62bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，给定以下对象:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="16d0" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  value: 0,<br/>  increment(val) {<br/>    this.value += val;<br/>  }<br/>};</span></pre><p id="e7af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d747" class="mq lc iq mh b gy mr ms l mt mu">obj.increment(2);</span></pre><p id="2cd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">obj.value</code>将增加2，因为在<code class="fe me mf mg mh b">increment</code>方法中<code class="fe me mf mg mh b">this</code>被设置为<code class="fe me mf mg mh b">obj</code>。</p><p id="3cae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">this</code>的对象上下文中的方法被称为公共方法。</p><h1 id="ec8b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数调用模式</h1><p id="ec8e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript函数可以是独立的函数。</p><p id="84bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建如下函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="116b" class="mq lc iq mh b gy mr ms l mt mu">const add = (a, b) =&gt; {<br/>  return a + b;<br/>}</span></pre><p id="0db3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="43cb" class="mq lc iq mh b gy mr ms l mt mu">add(1, 2);</span></pre><p id="6132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传统函数被绑定到全局对象，所以顶层传统函数的<code class="fe me mf mg mh b">this</code>在浏览器中是<code class="fe me mf mg mh b">window</code>。</p><p id="f294" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，箭头函数没有绑定到<code class="fe me mf mg mh b">this</code>，所以它将是顶层的<code class="fe me mf mg mh b">undefined</code>。</p><p id="5e55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该尽可能多地使用箭头函数，以便<code class="fe me mf mg mh b">this</code>的值与外部的值相同。</p><p id="5801" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="baf2" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  val: 0,<br/>  foo() {<br/>    const helper = () =&gt; {<br/>      this.val = 1;<br/>    }<br/>  }<br/>}</span></pre><p id="2d6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在嵌套函数中访问<code class="fe me mf mg mh b">this.val</code>。</p><p id="da32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">this</code>仍在<code class="fe me mf mg mh b">helper</code>箭头功能内<code class="fe me mf mg mh b">obj</code>。</p><p id="cfd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用一个传统来定义<code class="fe me mf mg mh b">helper</code>，我们可以写成:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="357a" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  val: 0,<br/>  foo() {<br/>    const that = this;<br/>    const helper = function() {<br/>      that.val = 1;<br/>    }<br/>  }<br/>}</span></pre><p id="1113" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须将<code class="fe me mf mg mh b">this</code>分配给<code class="fe me mf mg mh b">that</code>，这样<code class="fe me mf mg mh b">this</code>将成为<code class="fe me mf mg mh b">obj</code>而不是<code class="fe me mf mg mh b">helper</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/f11c59e2cd9df81bd6d23c247f5f7164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B8FYPKrjUw4pCvQw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mygmag?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrés Yves</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="15b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造函数调用模式</h1><p id="bb2d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript是一种典型的继承语言。对象可以直接从其他对象继承属性。</p><p id="f097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript中没有类。类只是语法糖。</p><p id="305c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript的原型继承会让来自具有经典继承的语言的人感到困惑。</p><p id="9185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript和其他面向对象语言一样有<code class="fe me mf mg mh b">new</code>操作符。</p><p id="7514" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它只是用来以一种特殊的方式调用一个函数。</p><p id="fdf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它创建了一个指向构造函数的<code class="fe me mf mg mh b">prototype</code>成员值的隐藏链接。</p><p id="b96e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前缀<code class="fe me mf mg mh b">new</code>修改了<code class="fe me mf mg mh b">return</code>语句的行为。</p><p id="0c64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前缀为<code class="fe me mf mg mh b">new</code>的函数被称为构造函数。</p><p id="bbe8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们保存在名字大写的变量中。</p><p id="9f39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用一个没有前缀<code class="fe me mf mg mh b">new</code>的构造函数，我们会遇到问题，因为<code class="fe me mf mg mh b">this</code>的值不是我们所期望的。</p><p id="4b76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了意外行为之外，我们没有得到任何关于此的警告，所以我们需要小心。</p><p id="a47f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要定义一个构造函数，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0389" class="mq lc iq mh b gy mr ms l mt mu">const Foo = function(string) {<br/>  this.status = string;<br/>};</span></pre><p id="debb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码是最基本的构造函数。它只接受一个<code class="fe me mf mg mh b">string</code>参数并将<code class="fe me mf mg mh b">string</code>设置为<code class="fe me mf mg mh b">this.status</code>。</p><p id="ab88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容来调用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9ac0" class="mq lc iq mh b gy mr ms l mt mu">const foo = new Foo('good');</span></pre><p id="0653" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">foo.status</code>就是<code class="fe me mf mg mh b">'good'</code>。</p><p id="1f78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要添加实例方法，我们可以编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f749" class="mq lc iq mh b gy mr ms l mt mu">const Foo = function(string) {<br/>  this.status = string;<br/>};</span><span id="5994" class="mq lc iq mh b gy mw ms l mt mu">Foo.prototype.getStatus = function() {<br/>  return this.status;<br/>};</span></pre><p id="8bf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">foo.getStatus()</code>返回<code class="fe me mf mg mh b">'good'</code>。</p><h1 id="2a55" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2d10" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript中有多种调用函数的方法。</p><p id="4988" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法是对象中的函数。我们可以用点或括号符号来称呼它。</p><p id="6f88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">function</code>关键字创建一个构造函数。</p><p id="8b30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要定义实例方法，我们可以将其添加到函数的<code class="fe me mf mg mh b">prototype</code>属性中。</p></div></div>    
</body>
</html>