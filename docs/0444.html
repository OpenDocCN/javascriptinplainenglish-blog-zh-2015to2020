<html>
<head>
<title>How the JavaScript engine works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript引擎如何工作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/js-engine-and-optimization-dac1f7fcb87d?source=collection_archive---------3-----------------------#2019-10-16">https://javascript.plainenglish.io/js-engine-and-optimization-dac1f7fcb87d?source=collection_archive---------3-----------------------#2019-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/708ce98ee6f5f43c493f198c96e1b41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eDFt53dktSnJ2u5T"/></div></div></figure><div class=""/><div class=""><h2 id="a635" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">以及它执行了哪些优化</h2></div><p id="f9a4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">JavaScript可以在各种设备上运行——手机、笔记本电脑、电视甚至物联网设备。JavaScript引擎可用的资源可以有很大不同。</p><p id="bb8e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">JavaScript引擎执行以下任务:</p><p id="1037" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">1-编译器优化</p><p id="9085" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">2-垃圾收集</p><p id="09bc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">3-热门代码管理</p><p id="5cc5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">4-缓存</p><p id="afb3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">5-程序的其他运行时方面</p><p id="fc3f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">每当任何设备加载js时，它都会加载、解析并执行脚本中的JS代码。JS代码的执行由<strong class="kp iz"> Javascript引擎处理。</strong> Javascript代码被解析成一个<strong class="kp iz">抽象语法树(AST) </strong>，然后移交给编译器工具链。内部编译器工具链，1个或多个优化编译器产生高效的低级代码。</p><p id="4dd7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">Javascript源代码进入Javascript源代码解析器，然后解析器获取代码并将其转换为抽象语法树表示。少数已知的解析器有<strong class="kp iz"> acron、esprima、cheroot等。</strong>创建AST是为了让我们可以将它输入到执行的第一阶段，即解释器。</p><p id="29f7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">v8中的解释器叫做<strong class="kp iz">点火</strong>。解释器生成字节码。这对于只需要运行一次的代码来说很好。字节码在JavaScript引擎内部运行。解释的代码更容易运行，但是速度有点慢。</p><p id="f2be" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">有时，代码经常重复。JavaScript编译器运行反馈，并为正在执行的代码收集分析数据。如果遇到每次都用相同类型的参数调用的函数，并且已经调用了多次，那么这段代码将经过优化编译器。优化编译器生成高度优化的机器级代码，直接在CPU上运行热代码。优化编译器仅在JS引擎检测到代码<strong class="kp iz">变热</strong>时才启动。当一个代码经常运行、在循环中运行等时，它就是热的。编译后的代码有直接的CPU指令，速度相当快。生成机器码需要一点时间。确切的CPU指令是按机器产生的，如下。V8中优化编译器是<strong class="kp iz">涡轮风扇。</strong></p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/c3b75e9decd33525e8160442313d675a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*LFPvZjEHhcWC0OqP2N_wGg.jpeg"/></div></figure><p id="a7cd" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz"><em class="lo">JS引擎优化</em> </strong></p><p id="22af" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz">使用对象形状的优化</strong></p><p id="7228" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">JavaScript引擎实现JS对象模型，并使用它们来加速访问JS对象的属性。当任何对象被创建时，关于该对象的大量信息被存储在存储器中。诸如对象是否可写、可枚举、可配置等信息。对应于一个对象被存储。一次又一次地存储同类型对象的冗余信息将是对内存的浪费。因此，这些信息是分开存储的，对象只存储值。这有助于优化内存很多。</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lp"><img src="../Images/8f440395ed6567d1c164f421b8db2a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2eidUZtdE_8o_GDuzp58kQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Properties of JS objects</figcaption></figure><p id="56f3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz">阵列优化</strong></p><p id="c9d3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">数组也遵循同样的规则。数组被标记，因为它仅由整数、双精度数、对象等组成。每当我们在数组上使用<strong class="kp iz"> map、find </strong>等时，它首先检查标签并基于此生成优化的代码。</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lu"><img src="../Images/6a3167aa8f6e41bffeab10d4590770ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfE_gTQVbH_KSWcncDanNg.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Properties of JS array</figcaption></figure><p id="47fe" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz">内嵌缓存</strong></p><p id="50b9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">形状背后的主要动机是内联缓存或IC的概念。ICs是让JavaScript快速运行的关键因素！JavaScript引擎使用ICs来记忆在哪里可以找到对象属性的信息，以减少昂贵的查找次数。</p><figure class="lk ll lm ln gt ip gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/004bf6abe005709c93442df7cd0bbf55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XGVdNL0Fad50vdyjgXiClA.jpeg"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk">Inline caching by Mathias</figcaption></figure><p id="eae0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在上面的例子中，当我们试图得到x的值时，未优化的代码将分配一个新的变量，给x赋值，计算偏移量，然后返回值。但是如果编译器知道这个函数被一次又一次地用相同类型的参数调用，它只会检查传递的参数的形状，并返回重新计算的偏移量。</p><p id="b886" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这篇文章的灵感来自马蒂亚斯·拜恩斯的会议</p></div></div>    
</body>
</html>