<html>
<head>
<title>Server-Side Rendering a React App Using Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express.js在服务器端呈现React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/back-to-basics-server-side-rendering-a-react-app-using-express-js-6fab99db5770?source=collection_archive---------0-----------------------#2020-11-22">https://javascript.plainenglish.io/back-to-basics-server-side-rendering-a-react-app-using-express-js-6fab99db5770?source=collection_archive---------0-----------------------#2020-11-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dcd2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何通过服务器端渲染使用Express.js为React应用提供服务</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5955fdab2f20c9c37df344c5d714a689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4kn3-DnANy6N8_Sp"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Science in HD</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4746" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您已经设置并创建了react应用程序(使用create-react-app、其他样板文件，甚至从头开始创建)。现在你正试图把它放到网上，这样人们就可以体验你的应用了。当然，为了便于部署和最小化设置，您可以使用已经建立的平台，如Netlify、Heroku、Firebase Hosting、Github Pages或许多其他平台。然而，这篇文章不是关于这个的。这篇文章是关于使用good ol' Express.js设置你自己的服务器和部署你的站点/应用的。</p><p id="30f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可能会问，为什么？当然是为了学习。了解服务器如何交付你的应用/站点对你的编程基础是有益的。它还可以帮助您将来部署(和配置)您的站点。</p><p id="ff14" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我将重点介绍服务器端渲染如何使用Express.js服务react应用程序。我将首先解释概念，然后深入研究示例项目代码。为了获得更好的理解，您还应该检查客户端渲染作为比较是如何工作的。这样，您将对每种方法的工作原理有一个更清晰的理解，并获得客户端和服务器端渲染解决方案的整体视图。我写过一篇关于客户端渲染的文章。所以来看看吧:</p><div class="lp lq gp gr lr ls"><a href="https://medium.com/javascript-in-plain-english/back-to-basics-client-side-rendering-a-react-app-using-express-js-c828e3664b88" rel="noopener follow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">回归基础:使用Express.js在客户端呈现React应用程序</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">如何通过实现客户端渲染解决方案，使用Express.js服务react app。</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">medium.com</p></div></div><div class="mb l"><div class="mc l md me mf mb mg km ls"/></div></div></a></div><p id="152a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，您应该清楚地了解什么是服务器端渲染，以及如何使用Express.js应用服务器端渲染解决方案。除此之外，您还应该大致了解服务器如何工作以及站点/应用程序如何部署到服务器。</p><h1 id="b1e8" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">服务器端渲染</h1><p id="0a04" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">与客户端呈现相反，服务器端呈现在将react组件发送到客户端之前，在服务器中呈现react组件<strong class="kv io">。在服务器端渲染过程中，从最初的请求到应用程序可用于交互的步骤如下:</strong></p><ol class=""><li id="b0e3" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">对页面的请求从客户端发送到服务器。</li><li id="323f" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">服务器通过在发送到客户端之前在服务器中呈现react组件来做出响应。</li><li id="c291" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">客户端接收html(带有react组件)并在浏览器中显示它。</li><li id="90fb" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">客户端还下载所需的JavaScript文件(包含react应用程序)。</li><li id="e4c0" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">下载JavaScript文件后，它将从JavaScript文件中重新组合当前显示在react应用程序中的html。</li></ol><p id="b88a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，在第二步中，react组件在被发送到客户机之前在服务器<strong class="kv io">中呈现。因此，当等待下载所有需要的JavaScript文件时，将不会出现“白页”，这通常发生在客户端渲染过程中。</strong></p><p id="a264" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在服务器中有一个预渲染的React应用程序的最大好处是SEO(搜索引擎优化)。当一个典型的搜索引擎抓取一个网站时，它会从它抓取的每个URL索引html响应。搜索引擎爬虫通常跳过JavaScript代码或文件。这就是为什么客户端渲染React应用程序可能会损害SEO。</p><p id="6d7b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在撰写本文时，已知只有Google搜索引擎能够抓取、解析和索引JavaScript(有局限性)。根据2017年moz.com的一篇<a class="ae ks" href="https://moz.com/blog/search-engines-ready-for-javascript-crawling" rel="noopener ugc nofollow" target="_blank">文章</a>，几个搜索引擎的JavaScript索引性能如下:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/e08908f99c772735e7e99cc56cf85fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kz_3mNjIKOFaL11ZTHTQww.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">source: <a class="ae ks" href="https://moz.com/blog/search-engines-ready-for-javascript-crawling" rel="noopener ugc nofollow" target="_blank">https://moz.com/blog/search-engines-ready-for-javascript-crawling</a></figcaption></figure><h1 id="3857" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">该项目</h1><p id="ece5" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">如果你已经有一个react应用，你可以使用现有的React应用，或者你可以使用create-react-app创建一个新的应用，并保留<code class="fe nt nu nv nw b">src</code>目录中的主要代码(因为我们关注的是后端)。然而，我建议你尝试从头开始创建一个React应用程序，这可以增强你对React应用程序内部的点点滴滴的理解。</p><p id="a4cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要了解React应用程序是如何从头开始构建的，您可以点击下面的链接，阅读我之前的文章:</p><div class="lp lq gp gr lr ls"><a href="https://medium.com/swlh/back-to-basics-how-to-set-up-a-react-app-from-scratch-2020-134908e17490" rel="noopener follow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd io gy z fp lx fr fs ly fu fw im bi translated">回归基础:如何从零开始设置React应用程序2020</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">使用最新的Webpack和Babel从空目录构建React应用程序。</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">medium.com</p></div></div><div class="mb l"><div class="nx l md me mf mb mg km ls"/></div></div></a></div><p id="3a70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将使用上面文章中从头开始创建React应用程序的代码。如果您已经完成了，那么您的项目目录应该至少包含以下文件夹结构和文件:</p><pre class="kd ke kf kg gt ny nw nz oa aw ob bi"><span id="7d57" class="oc mi in nw b gy od oe l of og">react-app/<br/>|--public/<br/>|  |--index.html<br/>|  |--bundle.js<br/>|--src/<br/>|  |--app.js<br/>|--babel.config.js<br/>|--package-lock.json<br/>|--package.json<br/>|--webpack.config.js</span></pre><p id="41dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文将假设您已经对JavaScript、Node.js、Webpack、Babel和React有了基本的了解。如果没有，对于基本设置(有Node、Webpack、Babel和React)，我建议你(再次)按照上面的链接从头开始创建一个React应用。</p><h1 id="60c4" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">Webpack配置</h1><p id="9421" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">我们将首先编辑和配置现有的<code class="fe nt nu nv nw b">webpack.config.js</code>文件。在该文件中，定义了一个带有关键字<code class="fe nt nu nv nw b">entry</code>、<code class="fe nt nu nv nw b">output</code>、<code class="fe nt nu nv nw b">module</code>和<code class="fe nt nu nv nw b">devServer</code>的对象，并将其导出为webpack配置。然而，这个webpack配置专门用于配置、转换和捆绑我们的客户端React文件，使其可以由浏览器呈现。</p><p id="e1a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于服务器端渲染，我们还需要配置、转换和捆绑我们的服务器文件，因为它使用最新的es语法和React JSX。因此，我们将导出两个对象，而不是导出一个对象作为我们的webpack配置。一个用于服务器文件配置，另一个用于客户端文件配置。在这两个对象中，我们将保持<code class="fe nt nu nv nw b">entry</code>、<code class="fe nt nu nv nw b">output</code>和<code class="fe nt nu nv nw b">module</code>配置或多或少的相同。</p><h2 id="d5ca" class="oc mi in bd mj oh oi dn mn oj ok dp mr lc ol om mt lg on oo mv lk op oq mx or bi translated">客户端配置</h2><p id="00c7" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">这个项目中用于webpack编译的客户端配置应该与我们的<a class="ae ks" href="https://medium.com/swlh/back-to-basics-how-to-set-up-a-react-app-from-scratch-2020-134908e17490" rel="noopener">“从头开始创建React应用程序”文章</a>中指定的默认React web配置相同。在那里，您应该可以找到设置React webpack配置的说明。在这个项目中，我们将配置包装在一个名为<code class="fe nt nu nv nw b">clientConfig</code>的对象中:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi os"><img src="../Images/53a03702912c0301566c0614ca0ac792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*lcfOYWrUImeigdP_4B7aRw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">client configuration</figcaption></figure><h2 id="7711" class="oc mi in bd mj oh oi dn mn oj ok dp mr lc ol om mt lg on oo mv lk op oq mx or bi translated">服务器配置</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ot"><img src="../Images/0cc8fda340298107bf0b5591e07f054d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQoqniitrs1VdrzLwgPvdg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">server configuration</figcaption></figure><p id="5f7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如我承诺的那样，<code class="fe nt nu nv nw b">entry</code>、<code class="fe nt nu nv nw b">output</code>和<code class="fe nt nu nv nw b">module</code>的配置大致相同。但是，我们需要更改入口和输出文件。我们将入口文件指向<code class="fe nt nu nv nw b">./server/index.js</code>，将输出文件指向<code class="fe nt nu nv nw b">./dist/index.js</code>。您可能会注意到，我们还没有一个包含<code class="fe nt nu nv nw b">index.js</code>文件的<code class="fe nt nu nv nw b">server</code>目录。我们稍后将创建它。</p><p id="7e92" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">除了<code class="fe nt nu nv nw b">entry</code>、<code class="fe nt nu nv nw b">output</code>和<code class="fe nt nu nv nw b">module</code>键，我们还需要定义<code class="fe nt nu nv nw b">target</code>、<code class="fe nt nu nv nw b">externals</code>和<code class="fe nt nu nv nw b">node</code>键。<code class="fe nt nu nv nw b">target</code>键指定我们的文件将被编译到的目标环境。在我们的例子中，因为它是一个服务器文件，所以我们将目标环境设置为<code class="fe nt nu nv nw b">node</code>。这样，webpack将编译文件以便在节点环境(我们的后端)中使用。编译时，不会触及任何内置模块(如<code class="fe nt nu nv nw b">fs</code>或<code class="fe nt nu nv nw b">path</code>)。</p><p id="5a0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nt nu nv nw b">externals</code>键提供了一种方法来排除我们不希望包含在输出包中的任何依赖项。为什么？因为尺寸问题。相反，输出包依赖于消费者(任何最终用户应用程序)环境中存在的依赖性。在我们的例子中，我们指定外部为<code class="fe nt nu nv nw b">webpack-node-externals</code>库。这个库创建了一个排除所有<code class="fe nt nu nv nw b">node_modules</code>依赖的外部函数。</p><p id="61d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们需要指定的最后一个键是<code class="fe nt nu nv nw b">node</code>键。<code class="fe nt nu nv nw b">node</code>键指定某些节点全局变量的配置。在这种情况下，我们配置<code class="fe nt nu nv nw b">__dirname</code>变量。将它设置为false将确保dirname在节点环境中正常工作(也就是它将返回输出文件的绝对路径)。</p><h2 id="c304" class="oc mi in bd mj oh oi dn mn oj ok dp mr lc ol om mt lg on oo mv lk op oq mx or bi translated">导出webpack配置</h2><p id="427d" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">在指定了服务器和客户端webpack配置之后，我们按如下方式导出了这两个对象:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/6e08743d7a7a12cf96e07a57ad419d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*XtKjbSb86IbDljeWbZltlQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">configurations export</figcaption></figure><h1 id="52f2" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">反应代码</h1><p id="906b" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">从我们之前的<a class="ae ks" href="https://medium.com/javascript-in-plain-english/back-to-basics-client-side-rendering-a-react-app-using-express-js-c828e3664b88" rel="noopener">项目</a>中，我们的反应代码只有一个文件:<code class="fe nt nu nv nw b">src/app.js</code>。在该文件中，我们指定了组件(<code class="fe nt nu nv nw b">App</code>)以及该<code class="fe nt nu nv nw b">App</code>组件的渲染:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/badce00fcaea1dec895135845a466d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOvFVSMIJoxc5xy2ljhrKQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">src/app.js</figcaption></figure><p id="6b6e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们现在将把组件和渲染分成两个独立的文件。第一个文件(<code class="fe nt nu nv nw b">src/hello.js</code>)包含<code class="fe nt nu nv nw b">&lt;Hello /&gt;</code>组件，而第二个文件(<code class="fe nt nu nv nw b">src/app.js</code>)只包含我们的React组件的渲染(<code class="fe nt nu nv nw b">&lt;Hello /&gt;</code>)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ow"><img src="../Images/4843a8f341dccd045d258e892af102a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XVb-ZUDQjZAMMAYsyRpgA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">src/hello.js</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/286567065896bdd8b2d425f6e5c00a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77E4MhLes_ycfZzqC2NNGQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">src/app.js</figcaption></figure><p id="1ab6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，我们使用<code class="fe nt nu nv nw b">ReactDOM.hydrate(…)</code>代替了<code class="fe nt nu nv nw b">ReactDOM.render(...)</code>。<code class="fe nt nu nv nw b">hydrate</code>方法与<code class="fe nt nu nv nw b">render</code>相同，但用于在服务器中对其HTML内容由<code class="fe nt nu nv nw b">ReactDOMServer</code>呈现的容器进行水合(稍后解释)。使用<code class="fe nt nu nv nw b">render</code>方法对服务器生成的容器进行水合(而非<code class="fe nt nu nv nw b">hydrate</code>方法)可能比较慢，将在反应17中移除。</p><h1 id="edc3" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">使用Express.js的服务器代码</h1><p id="93bd" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">现在，我们将使用Express.js在一个名为<code class="fe nt nu nv nw b">server/index.js</code>的文件中创建后端服务器代码。Express.js将自己塑造成“快速、无约束、极简的web框架”。如果您正在为您的项目构建一个后端，Express就是一个现成的JavaScript框架。要安装Express.js，请运行以下命令:</p><pre class="kd ke kf kg gt ny nw nz oa aw ob bi"><span id="751c" class="oc mi in nw b gy od oe l of og">npm install express</span></pre><p id="cb38" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">安装Express后，在项目根目录下新建一个目录，命名为<code class="fe nt nu nv nw b">server</code>。</p><pre class="kd ke kf kg gt ny nw nz oa aw ob bi"><span id="5ab5" class="oc mi in nw b gy od oe l of og">mkdir server</span></pre><p id="595e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将在该目录下设置Express后端。到目前为止，您至少应该在根目录下有三个目录，分别叫做<code class="fe nt nu nv nw b">public</code>、<code class="fe nt nu nv nw b">src</code>和<code class="fe nt nu nv nw b">server</code>。</p><p id="6ef7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe nt nu nv nw b">server</code>目录下，创建一个名为<code class="fe nt nu nv nw b">index.js</code>的文件:</p><pre class="kd ke kf kg gt ny nw nz oa aw ob bi"><span id="8694" class="oc mi in nw b gy od oe l of og">touch server/index.js</span></pre><p id="7d38" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您的服务器目录现在应该如下所示:</p><pre class="kd ke kf kg gt ny nw nz oa aw ob bi"><span id="46a0" class="oc mi in nw b gy od oe l of og">react-app<br/>|-server<br/>|  |-index.js<br/>|...</span></pre><p id="bef7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe nt nu nv nw b">server/index.js</code>中，增加如下代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oy"><img src="../Images/d4f9659d97805d0112172cc8fd65867b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CZFuc516dL8b6pWy.png"/></div></div></figure><p id="374f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">服务器/索引. js</p><ol class=""><li id="61c3" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated">我们需要express模块并调用top express函数<code class="fe nt nu nv nw b">express()</code>。我们还设置了所需的端口号，即3000。</li><li id="15ff" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated">我们指示express启动服务器并监听我们设置的端口。控制台将输出“服务器现在正在监听<a class="ae ks" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000。</a></li></ol><p id="8ab9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我们Express服务器的基本设置。为了在将React应用程序发送到客户端之前将其呈现给服务器，我们在全局变量赋值(<code class="fe nt nu nv nw b">const port = 3000</code>)和<code class="fe nt nu nv nw b">app.listen(…)</code>之间添加了以下代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oz"><img src="../Images/e83a79229db1cb178c0f24dc2e4a8aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_z8gk5bedC_7hT3BlCnz4A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Server code inside server/index.js</figcaption></figure><p id="5f2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe nt nu nv nw b">port</code>变量定义和<code class="fe nt nu nv nw b">app.listen()</code>之间，我们需要编写实际的请求处理程序和服务器发送的响应。</p><p id="880b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们需要进一步请求并导入几个全局变量:<code class="fe nt nu nv nw b">path</code>、<code class="fe nt nu nv nw b">ReactDOMServer</code>、<code class="fe nt nu nv nw b">React</code>和<code class="fe nt nu nv nw b">Hello</code>组件。<code class="fe nt nu nv nw b">path</code>是一个内置的节点模块，用于处理文件和目录路径，<code class="fe nt nu nv nw b">ReactDOMServer</code>是一个React对象，用于将组件呈现为通常在节点服务器中使用的静态标记，<code class="fe nt nu nv nw b">React</code>是默认的React JavaScript库，最后，<code class="fe nt nu nv nw b">Hello</code>组件是要在服务器中呈现的组件，我们之前在<code class="fe nt nu nv nw b">src</code>目录中创建了该组件。</p><p id="9f0f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里需要强调的两件事是在我们的后端服务器代码中使用React组件和ES6导入的能力。两者都受支持，因为这个服务器文件也将使用webpack和babel转换和编译成一个可以在节点环境中读取的JavaScript文件。我们之前已经设置了webpack配置。</p><p id="0441" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个Express.js应用程序基本上是一系列中间件和路由功能。中间件函数告诉Express.js如何处理传入的请求。是转换请求数据、发回响应，还是将其传递给下一个中间件。<code class="fe nt nu nv nw b">express().static</code>中间件指示express提供来自指定目录的静态文件。这里，我们指定了<code class="fe nt nu nv nw b">/static</code>路径来服务来自<code class="fe nt nu nv nw b">public</code>目录的静态文件。<code class="fe nt nu nv nw b">public</code>目录是webpack编译和转换的客户端React文件所在的位置。</p><p id="e834" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们指定home ('/')路径，服务器将在该路径上发送回包装在分配给<code class="fe nt nu nv nw b">html</code>变量的基本html模板中的服务器呈现的<code class="fe nt nu nv nw b">Hello</code>组件。在<code class="fe nt nu nv nw b">Hello</code>组件被导入后，使用<code class="fe nt nu nv nw b">ReactDOMServer</code>的<code class="fe nt nu nv nw b">renderToString()</code>方法将其呈现为一个html字符串。然后将<code class="fe nt nu nv nw b">Hello</code>组件字符串插入到基本html模板中。这样，服务器不仅返回基本的html模板(与客户端呈现一样)，还返回已经在服务器中呈现的React组件(因此称为“服务器端呈现”)。</p><p id="7719" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一件要注意的事情是html模板中的脚本标签。该脚本引用了我们之前定义为静态文件路径的“/static”路径中的文件。因为脚本标签是从客户端浏览器调用的，所以它不能直接访问服务器内部的文件系统。相反，它只能通过我们在服务器中定义的有效路径来访问文件。</p><h1 id="0a8c" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">Nodemon</h1><p id="cf0d" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">Nodemon是一个开发基于节点的应用程序的工具，当检测到目录中的文件改变时，它帮助自动重启所述应用程序。这样，我们就不必在每次想要查看我们所做的更改是如何发生的时候，手动取消并重启我们的express服务器。通过键入以下命令全局安装Nodemon(推荐):</p><pre class="kd ke kf kg gt ny nw nz oa aw ob bi"><span id="9922" class="oc mi in nw b gy od oe l of og">npm install -g nodemon</span></pre><p id="e104" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您现在可以在您机器上的其他项目中使用Nodemon，因为它是全局安装的。</p><h1 id="10a5" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">NPM剧本</h1><p id="deed" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">为了使我们的开发更容易，我们需要定义几个npm脚本。Npm脚本是在项目文件夹的根目录下的<code class="fe nt nu nv nw b">package.jsone</code>中定义的。我们已经拥有的现有脚本如下:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/e7762946e4e124ebdae555ed8d4bcd92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*3dbDldMlVvfjhAmIfQD1mw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">existing scripts</figcaption></figure><p id="4cfc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们添加另一个脚本来启动名为“serve”的express服务器。该脚本将使用nodemon启动我们的服务器。我们不会直接使用来自<code class="fe nt nu nv nw b">server</code>目录的服务器文件，因为它包含不能在节点环境中运行的React和ES6代码。相反，我们将使用使用webpack和babel转换和编译的服务器文件。该文件位于<code class="fe nt nu nv nw b">dist</code>目录中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/c319f6f33b0045ca4b476597785ad767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*UDDnIlPrPo0UGkeHCmOq0Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">edited scripts</figcaption></figure><h1 id="6fa3" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">运行服务器</h1><p id="2968" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">在运行服务器之前，我们应该构建和编译我们的服务器和客户端代码(分别从<code class="fe nt nu nv nw b">src</code>和<code class="fe nt nu nv nw b">server</code>目录到<code class="fe nt nu nv nw b">public</code>和<code class="fe nt nu nv nw b">dist</code>目录)。要编译，在终端中键入<code class="fe nt nu nv nw b">npm run build</code>命令。运行该命令后，我们的文件夹结构应该如下所示:</p><pre class="kd ke kf kg gt ny nw nz oa aw ob bi"><span id="72ca" class="oc mi in nw b gy od oe l of og">react-app/<br/>|--public/<br/>|  |--bundle.js <br/>|--dist/<br/>|  |--index.js<br/>|--server/<br/>|  |--index.js<br/>|--src/<br/>|  |--app.js<br/>|  |--hello.js<br/>|--node_modules/<br/>|--babel.config.js<br/>|--package-lock.json<br/>|--package.json<br/>|--webpack.config.js</span></pre><p id="7d9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，要运行服务器，我们在终端中键入<code class="fe nt nu nv nw b">npm run serve</code>命令。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/2dff1e7d30d3d93f510b0451d39f1876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*WJ7Kq7UiDe58RJaCHU6vSA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">npm run serve</figcaption></figure><p id="8ffb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">打开浏览器并转到“http://localhost:3000”，</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pd"><img src="../Images/7073030d886036bb35a8ad5f77fcfb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gt6UiByCcs73pAoaalZhQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">localhost:3000</figcaption></figure><p id="0a5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">瞧啊。我们的React应用程序应该会出现。我们如何知道我们的应用程序正在服务器端呈现？要找到答案，请打开浏览器开发工具。如果你使用的是chrome，按键盘上的<code class="fe nt nu nv nw b">ctrl</code> + <code class="fe nt nu nv nw b">shift</code> + <code class="fe nt nu nv nw b">I</code>打开chrome开发工具。点击<code class="fe nt nu nv nw b">sources</code>标签。在左侧，点击<code class="fe nt nu nv nw b">(index)</code>打开我们主页的源html(http://localhost:3000/)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pe"><img src="../Images/13d83e1e1463c7c5328410d5588b7afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRmRotfbok6rgHsfse9RMA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">home (‘/’) source html for server-side rendered app</figcaption></figure><p id="7ec8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，我们的<code class="fe nt nu nv nw b">Hello</code>组件(带下划线)存在于服务器发送的html代码中！这与客户端呈现的应用程序不同，在客户端呈现的应用程序中，从服务器发送的html仅包含容器元素(在我们的示例中是id为<code class="fe nt nu nv nw b">root</code>的<code class="fe nt nu nv nw b">div</code>元素)。只有在下载完所有捆绑的React代码后，客户端浏览器才会呈现<code class="fe nt nu nv nw b">root</code>容器中的组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pf"><img src="../Images/ff7ba3d548c4f209c77e4a763a9cb338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUbiJccmuTNHwQ31MjCwdw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">home (‘/’) source html for client-side rendered app</figcaption></figure><h1 id="a1bd" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">摘要</h1><p id="3a5b" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">在本文中，我给出了一些关于服务器端渲染的背景知识，并深入实际的React和Express.js项目代码来解释服务器端渲染过程。在发送回html响应之前，React组件在服务器中呈现为html。我们通过使用<code class="fe nt nu nv nw b">ReactDOMServer</code>的<code class="fe nt nu nv nw b">renderToString</code>方法来做到这一点。</p><p id="a538" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在客户端，下载完所有需要的JavaScript文件(包含我们的React代码)后，渲染过程将开始。然而，我们没有使用<code class="fe nt nu nv nw b">ReactDOM.render()</code>，而是使用<code class="fe nt nu nv nw b">ReactDOM.hydrate()</code>来重新水合html代码。</p></div></div>    
</body>
</html>