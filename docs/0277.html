<html>
<head>
<title>Angular ViewChild and ViewChildren</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度视图子视图和视图子视图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-viewchild-and-viewchildren-fde2d252b9ab?source=collection_archive---------0-----------------------#2019-09-11">https://javascript.plainenglish.io/angular-viewchild-and-viewchildren-fde2d252b9ab?source=collection_archive---------0-----------------------#2019-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9143" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于ViewChild和ViewChildren您需要知道的一切</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/172e99fca1fa8f9149b047ac95da1990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rv62Wh4plO6s-A-2TV0yjg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Working with ViewChild and ViewChildren</figcaption></figure><p id="b854" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">TechnoFunnel发表了另一篇文章，介绍如何理解角度组件中的<strong class="kx ir"> @ViewChild和@ViewChildren </strong>的用法。我们将看看如何有效地使用这些功能来实现您想要的结果。</p><p id="f437" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">组件可以获得对元素或指令的引用，因此我们可以直接访问它。该指令可以是Angular自己的，也可以是用户定义的自定义指令。我们有时可能需要直接访问元素或组件，并操纵组件或元素的属性。这在某种程度上等同于使用JavaScript获取DOM元素并更新DOM元素的属性和行为。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="6578" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">使用Angular的ViewChild</h1><p id="5e82" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated"><strong class="kx ir"> @ViewChild可以用来获取角度组件内部渲染的DOM元素的引用。</strong>我们可以使用DOM元素的引用来操纵元素属性。要获取组件，我们需要指定选择器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Access this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/3b9c5cd65490de5d8bef0b93953583a7" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="404e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面给出了使用普通JavaScript或Angular的<strong class="kx ir"> @ViewChild </strong>访问DOM元素的代码。使用JavaScript，我们可以使用一个选择器来提取组件。根据下面的语句，我们尝试使用元素ID来访问元素。</p><p id="d9d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe my mz na nb b">&lt;div id=”someElement”&gt;Sample Code&lt;/div&gt;</code></p><p id="45f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面给出了一个<code class="fe my mz na nb b">div</code>元素，它的模板引用被标记为<code class="fe my mz na nb b">someElement</code>。模板引用以#开头。在Angular的情况下，我们可以使用这些模板引用来访问元素。可以通过使用<strong class="kx ir"> @ViewChild </strong>和为其指定的模板引用变量来检索元素引用。让我们来看看实际情况。</p><p id="3776" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe my mz na nb b">&lt;div #someElement&gt;Sample Code&lt;/div&gt;</code></p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="29a9" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">什么时候可以引用这个ViewChild变量？</h1><p id="9bb7" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">一旦<code class="fe my mz na nb b">View</code>被初始化，对<strong class="kx ir"> @ViewChild </strong>变量的引用就被赋值。Angular提供了一个名为<code class="fe my mz na nb b">ngAfterViewInit</code>的生命周期钩子，一旦<code class="fe my mz na nb b">View</code>被初始化，这个钩子就会被调用。一旦<code class="fe my mz na nb b">View</code>被初始化和呈现，<strong class="kx ir"> @ViewChild </strong>就可以使用模板引用访问元素。它为我们提供了对元素/指令的访问。</p><p id="6e6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Access this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/703891c75a2d7ac5a569ddc1efe0ea76" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="10f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，需要考虑以下几点:</p><ol class=""><li id="9845" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">我们可以使用<strong class="kx ir"> @ViewChild </strong>来访问具有模板引用变量<code class="fe my mz na nb b">“someElement”</code>的输入元素。</li><li id="4953" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">ViewChild元素<code class="fe my mz na nb b">domReference</code>只有在DOM元素被渲染后才能访问它。一旦呈现了组件，就会调用一个名为<code class="fe my mz na nb b">ngAfterViewInit</code>的生命周期事件。因此，我们可以在这个生命周期事件或以后的生命周期事件中引用该元素。</li><li id="e549" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><strong class="kx ir"> @ViewChild </strong>可以让用户访问呈现的<code class="fe my mz na nb b">View</code>的原生DOM元素。使用这个DOM引用，我们可以访问和修改DOM属性，比如操作样式、内部文本、值和其他与引用的元素相关的属性。</li><li id="d3d1" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">我们直接访问DOM，所以我们与浏览器紧密耦合。因此，我们可能无法使用服务器端渲染来使用这些引用，这也可能带来安全威胁。</li></ol></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="e290" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">使用角度方向访问元素</h1><p id="e22d" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们可以使用类似<code class="fe my mz na nb b">NgModel </code>的角度指令和<strong class="kx ir"> @ViewChild </strong>。让我们寻找使用<strong class="kx ir"> @ViewChild </strong>访问角度指令的需求和用例场景。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Access this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/db14a303c3f94ee2c85b89b1992ace9e" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="4851" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以访问<strong class="kx ir"> @ViewChild </strong>中的<code class="fe my mz na nb b">NgModel</code>指令，并订阅值的变化。上面给出的是代码，我们试图使用角度指令<code class="fe my mz na nb b">NgModel</code>访问一个元素。ID为<code class="fe my mz na nb b">userName</code>的元素被添加了指令<code class="fe my mz na nb b">NgModel</code>。使用<strong class="kx ir"> @ViewChild </strong>，我们将跟踪输入元素中任何值更新的变化。</p><p id="47b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们获取对输入元素的<code class="fe my mz na nb b">NgModel</code>数据结构的引用，通过引用，我们可以访问它的状态信息，比如它是否被修改过，或者值是否有效。</p><p id="8f89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以在<code class="fe my mz na nb b">ngAfterViewInit</code>生命周期内访问它。我们可以接触到所有的国家信息。它还提供有关属性的任何更新的信息。此引用是只读的。它给了我们访问可观察对象的权限，我们可以用这个可观察对象来订阅<code class="fe my mz na nb b">valueChanges</code>可观察对象。</p><p id="826d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当值被更新时，与之相关联的回调函数被触发，我们可以添加定制逻辑来响应更新。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="ee22" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">使用Angular的视图子对象</h1><p id="c5d8" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">使用<strong class="kx ir"> @ViewChildren </strong>与<strong class="kx ir"> @ViewChild </strong>类似，但两者的区别在于<strong class="kx ir"> @ViewChildren </strong>提供了元素引用的列表，而不是返回单个引用。它用于引用多个元素。然后，我们可以迭代该变量引用的元素列表。</p><p id="1bfd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下选择器可以与<strong class="kx ir"> @ViewChildren </strong>一起使用:</p><h2 id="ee56" class="nq lz iq bd ma nr ns dn me nt nu dp mi le nv nw mk li nx ny mm lm nz oa mo ob bi translated">1.我们可以使用带有角度指令的ViewChildren，比如<code class="fe my mz na nb b">NgModel</code></h2><p id="05a5" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们可以在ViewChild中使用像<code class="fe my mz na nb b">NgModel</code>这样的内置指令。它将给出所有附加了指令<code class="fe my mz na nb b">NgModel</code>的元素的列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">View this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/3c1f83f52957e46801f7e8981d701315" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="5fb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面给出的是使用角度指令<code class="fe my mz na nb b">NgModel</code>提取元素的代码。可以检索包含指定角度方向的所有组件，并对其进行进一步评估。</p><h2 id="ff52" class="nq lz iq bd ma nr ns dn me nt nu dp mi le nv nw mk li nx ny mm lm nz oa mo ob bi translated">2.使用子组件访问元素</h2><p id="320c" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">类似于使用带有<strong class="kx ir"> @ViewChild </strong>的指令，我们可以使用子组件名来访问使用<strong class="kx ir"> @ViewChildren </strong>的元素。这就需要我们在主组件中有一些子组件(例如，<code class="fe my mz na nb b">user-details</code>)。让我们用一个例子来看看下面的场景。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">View this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/e75b17c94b7fa34486913a353a451cb9" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="6145" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码获取了父组件中包含的所有子组件引用的列表。</p><p id="7ebb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以使用这些引用来完成定制逻辑。然后，开发人员可以使用该列表来完成进一步的任务。</p><h2 id="63fc" class="nq lz iq bd ma nr ns dn me nt nu dp mi le nv nw mk li nx ny mm lm nz oa mo ob bi translated"><strong class="ak"> 3。使用模板参考变量</strong></h2><p id="234a" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">元素中的多个组件可以包含相同的模板引用。如果我们在多个地方使用一个模板引用，我们会收到模板中同一个模板引用变量所引用的所有组件的引用列表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">View this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/88bfd250bffba72a1de745f94bb8cec0" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="9b10" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码包含多个具有相同模板引用变量的组件。<strong class="kx ir"> @ViewChildren </strong>将使用户能够访问引用模板引用<code class="fe my mz na nb b">applicationInfo</code>的所有组件。</p><h2 id="ebb1" class="nq lz iq bd ma nr ns dn me nt nu dp mi le nv nw mk li nx ny mm lm nz oa mo ob bi translated">4.<strong class="ak">访问多个模板参考变量</strong></h2><p id="32d7" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">选择器可以是一组模板引用。我们可以指定多个模板引用。从组件中检索包含列表中指定的模板引用的所有组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">View this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/86cc2ea1000605e7e04edb6d1b365969" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="ba21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们在<strong class="kx ir"> @ViewChild </strong>中添加了模板引用变量列表。包含列表中包含的元素引用的所有组件都将被检索，并且可以使用变量名进行访问。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="da1f" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">使用ViewChild和子组件</h1><p id="e14a" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">ViewChild和ViewChildren可用于访问子组件的属性和方法。使用<strong class="kx ir"> @ViewChildren </strong>和<strong class="kx ir"> @ViewChild </strong>，我们可以获得子组件的引用，这进一步给出了对所有属性和方法的访问。这可以使父组件访问子组件，并在它们之间实现通信。</p><p id="7892" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一下代码，以便更好地理解这个概念:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">View this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/5385ef1d09e83214bdfbb8ae7802b674" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="8b99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码包含一个简单的子组件，它有属性<code class="fe my mz na nb b">userName</code>和函数<code class="fe my mz na nb b">updateUserName</code>，规定用来更新组件的<code class="fe my mz na nb b">userName</code>属性。</p><p id="5c40" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们添加一个新组件，它将作为上述<code class="fe my mz na nb b">ChildComponent</code>的父组件。我们将研究使用<code class="fe my mz na nb b">@ViewChild</code>从父组件访问子组件的属性和方法的代码。让我们看看下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">View this code <a class="ae mx" href="https://gist.github.com/Mayankgupta688/444608affbdb56530a0399130c8c2ca0" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="1b83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码代表一个父组件。在为父组件指定的模板中，我们添加了一个子组件。</p><p id="0f2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">子组件用模板引用变量标记。我们可以使用这个模板引用来访问子组件的属性和变量。</p><p id="8a0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe my mz na nb b">@ViewChild(“userInformation”) childComponentReference: any;</code></p><p id="8634" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> @ViewChild </strong>可用于访问具有模板引用<code class="fe my mz na nb b">userInformation</code>的子组件，模板引用代表子组件。使用这个<code class="fe my mz na nb b">childComponentReference</code>，我们可以进一步访问属性并调用子组件的功能，如上所述。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="3057" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="35a1" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我希望这篇文章对你有益。欢迎在下方留言评论。</p><p id="e281" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="oc">更多内容请看</em><a class="ae mx" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="oc">plain English . io</em></strong></a></p></div></div>    
</body>
</html>