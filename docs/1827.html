<html>
<head>
<title>Create an Auto Saving React Input Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自动保存反应输入组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-an-auto-saving-react-input-component-in-10-minutes-2359d84dc29b?source=collection_archive---------1-----------------------#2020-04-27">https://javascript.plainenglish.io/create-an-auto-saving-react-input-component-in-10-minutes-2359d84dc29b?source=collection_archive---------1-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/934b043f2e18cef40cd219940f227860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S81MH0_t0zM6p_gWPZhe2w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">A better UX without too much heavy lifting</figcaption></figure><p id="49c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在处理长表单(比如医疗表单、档案等)时，允许字段在用户填写时自动保存是UX的一大进步。</p><p id="94df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">模糊时自动保存字段听起来像是在一个提交按钮上做了很多额外的工作，嗯？</p><p id="854f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">别担心，我们将使用<a class="ae la" href="https://semantic-ui.com/" rel="noopener ugc nofollow" target="_blank">语义UI React组件库</a>在10分钟内构建一个。</p><p id="08e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您想完全跳过这篇文章，下面是代码沙箱:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The field will save on blur</figcaption></figure><h1 id="b396" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">我们的基本文本字段</h1><p id="d439" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">好了，在我们考虑自动保存之前，让我们先创建我们的基本文本字段组件，或者换句话说，通过语义UI 使用<a class="ae la" href="https://react.semantic-ui.com/elements/input/" rel="noopener ugc nofollow" target="_blank">输入组件来节省时间:</a></p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mk lg l"/></div></figure><p id="e6eb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">语义UI有一堆图标，我们可以按名称传入，这将使显示我们的保存/已保存/错误状态容易得多。</p><p id="4f3a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于上下文，下面是主要的应用程序代码:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mk lg l"/></div></figure><p id="b565" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里只有两件事值得注意:</p><ol class=""><li id="2109" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mq mr ms mt bi translated">我们创建了一个模拟保存函数，它只是一个承诺，用新值在2秒内解决</li><li id="f662" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">除了<code class="fe mz na nb nc b">onSave</code>之外的每个道具都是输入组件的<a class="ae la" href="https://react.semantic-ui.com/elements/input/" rel="noopener ugc nofollow" target="_blank">语义UI API的一部分，没有任何定制。我们稍后会用到<code class="fe mz na nb nc b">onSave</code>。</a></li></ol><h1 id="a3f4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">我们需要追踪什么？</h1><p id="c3aa" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">保存单个字段时，需要跟踪更多内容。以下是最重要的问题:</p><ol class=""><li id="6c01" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mq mr ms mt bi translated">我们如何进行实际的节约？</li><li id="cf83" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">我们如何指示字段正在保存？</li><li id="3b01" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">我们如何表明保存成功/失败？</li></ol><h1 id="0c00" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">我们如何进行实际的节约？</h1><p id="c93f" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">我们可能想保留侠影的领域。我们可以传递一个负责“保存”细节的异步<code class="fe mz na nb nc b">onSave</code>函数，但是我们的组件并不真正关心数据是如何保存的，只关心数据正在保存的事实。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mk lg l"/></div></figure><p id="5550" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然看起来代码很多，但一切都很简单:</p><ol class=""><li id="6a97" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mq mr ms mt bi translated">我们使用<code class="fe mz na nb nc b">useState</code>来跟踪我们是否在存钱</li><li id="5928" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">我们维护一个对最后输入值的引用，这样我们就可以将它与当前值进行比较。如果是一样的，就没必要保存了。</li><li id="a387" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">为了回答我们的<strong class="ke ir">“我们如何指示一个字段正在保存？”</strong>问题:语义用户界面已经成为我们可以利用的加载指标。当字段已经被手动传递了一个“加载”属性，或者我们当前正在保存字段时，我们显示它。</li><li id="fe4c" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">自动保存字段的问题是，用户输入的数据保存后会被覆盖，输入字段会用保存的数据刷新。为了避免这种情况，我们只需在加载时禁用该字段。</li><li id="7e5d" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">这就是奇迹发生的地方。我们给<code class="fe mz na nb nc b">onBlur</code>附加了一个异步处理程序。在处理程序中，我们首先检查值是否已经改变。如果有，我们将“saving”状态更新为true，如果我们被传递了一个<code class="fe mz na nb nc b">onSave</code>函数，我们将尝试保存。一旦<code class="fe mz na nb nc b">onSave</code>承诺兑现，我们就更新最后保存的值并重置我们的保存状态。</li></ol><h1 id="6b07" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">我们如何表明保存成功/失败？</h1><p id="f92d" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">因此，我们也许能够显示一个领域是否在节约，但这还不够。我们希望显示一个字段已成功保存(或未能保存)。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="mk lg l"/></div></figure><p id="bad8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以这几乎是我们的全部组件！以下是我们添加的内容:</p><ol class=""><li id="9d9f" class="ml mm iq ke b kf kg kj kk kn mn kr mo kv mp kz mq mr ms mt bi translated">引入了新的状态来跟踪何时保存字段，以及何时出现保存错误</li><li id="d796" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">为了获得更好的UX，当我们成功保存时，我们将我们的图标替换为绿色复选标记，当保存失败时，替换为红色警告。</li><li id="55a3" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">语义UI为我们提供了手动设置图标颜色的灵活性，因此我们更改了颜色以适应当前的保存状态。</li><li id="276a" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">既然我们处理的不仅仅是字段验证错误，我们手动传递常规的错误属性(从父级传递给我们的组件)，或者我们内部调节的<code class="fe mz na nb nc b">saveError</code>变量，如果存在的话。</li><li id="24c5" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">UX的另一个改进是确保我们在用户修改输入时移除成功图标。这样他们就知道当前的更改还没有保存。</li><li id="93ec" class="ml mm iq ke b kf mu kj mv kn mw kr mx kv my kz mq mr ms mt bi translated">当我们遇到调用<code class="fe mz na nb nc b">onSave</code>的错误时(如果保存失败，我们假设它抛出承诺拒绝)，我们只需更新我们的<code class="fe mz na nb nc b">saveError</code>状态。这里可以更加灵活(比如从API传递实际的消息)，我在这个例子中保持简单。</li></ol><h1 id="26d9" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">这个故事的寓意</h1><p id="b122" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">很明显，这个组件有很多地方可以改进，但是就快速启动和运行而言，由于语义UI React，这可能在10到20分钟内就可以完成。</p><p id="6077" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以使用任何其他组件库(Material UI，Ant等)。关键是在这种情况下，使用组件库可能会节省您的开发时间。我们能够显示图标、加载指示器、禁用和错误状态，以及更多仅仅通过传递简单的道具。</p><h1 id="79ef" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">来自作者的信息</h1><p id="524d" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">嘿你…是你。我知道时局艰难。</p><p id="078b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无聊？压力大？在家发疯了？想更深入地了解React吗？有朋友想学习React &amp; UI开发的新知识吗？</p><p id="420d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我为你和你的朋友们准备了很多文章。请随意分享和关注，因为…嗯…除了检查我的中等统计和狂欢之外，我没什么可做的。</p><h2 id="4bd0" class="nd li iq bd lj ne nf dn ln ng nh dp lr kn ni nj lv kr nk nl lz kv nm nn md no bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="cff7" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae la" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ke ir">AI in Plain English</strong></a><a class="ae la" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ke ir">UX in Plain English</strong></a><a class="ae la" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ke ir">Python in Plain English</strong></a><strong class="ke ir"/>——谢谢，继续学习！</p><p id="1eca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae la" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">submissions @ plain English . io</strong></a><strong class="ke ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>