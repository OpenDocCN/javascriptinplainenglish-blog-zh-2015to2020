<html>
<head>
<title>Introduction to GraphQL Schemas and Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL模式和类型介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-graphql-schemas-and-types-940e254cb72d?source=collection_archive---------2-----------------------#2020-03-22">https://javascript.plainenglish.io/introduction-to-graphql-schemas-and-types-940e254cb72d?source=collection_archive---------2-----------------------#2020-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dc414a019048bac6c60d583c9ab91033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qJ8CoNyDTnJ4CEVL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aggriffith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adam Griffith</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="74f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL是我们的API的一种查询语言，也是一个服务器端运行时，通过使用数据的类型系统来运行查询。</p><p id="6327" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究GraphQL类型系统，以及它如何描述可以查询哪些数据。</p><h1 id="0c12" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模式和类型</h1><p id="be8c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">GraphQL请求是关于在对象上选择字段的。</p><p id="11d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个查询中，我们有一个根对象，然后我们从该对象中选择一个字段，如果它一直存在于底层，则选择该层以下的字段。</p><p id="5518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下查询:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4258" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  person {<br/>    name<br/>  }<br/>}</span></pre><p id="721a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到这样的结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="daf4" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "person": {<br/>      "name": "Jane"<br/>    }<br/>  }<br/>}</span></pre><p id="b348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为回应。</p><p id="bb8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL查询与结果非常匹配，因此我们可以预测查询将返回什么，而不需要知道太多关于服务器的信息。</p><p id="0f1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是对我们需要的数据有一个准确的描述仍然是有用的。</p><p id="f74c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是显式类型有用的地方。</p><h1 id="c91f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型语言</h1><p id="527b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">GraphQL服务可以用任何语言编写。因此，类型必须以与语言无关的方式定义。</p><h1 id="5f6a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象类型和字段</h1><p id="b386" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以如下定义GraphQL数据类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a4d" class="mn lc iq mj b gy mo mp l mq mr">type Person {<br/>  name: String!<br/>  addresses: [Address!]!<br/>}</span></pre><p id="b51e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用关键字<code class="fe ms mt mu mj b">type</code>创建了一个新的类型。在类型中，我们有<code class="fe ms mt mu mj b">name</code>字段，它是<code class="fe ms mt mu mj b">String</code>，还有<code class="fe ms mt mu mj b">addresses </code>，它是<code class="fe ms mt mu mj b">Address</code> es的数组，这是另一种类型。</p><p id="a618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">String</code>是内置的标量类型。感叹号表示该字段不可为空。因此，<code class="fe ms mt mu mj b">String!</code>是一个不可空的字符串。</p><p id="0259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">[Address!]!</code>是<code class="fe ms mt mu mj b">Address</code>对象的数组。它也是不可空的，所以当我们查询<code class="fe ms mt mu mj b">addresses</code>时，我们总是可以期待一个包含零个或更多项的数组。由于<code class="fe ms mt mu mj b">Address!</code>也是不可空的，我们总是可以期望数组的每一项都是一个<code class="fe ms mt mu mj b">Address</code>对象。</p><h1 id="36cc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">争论</h1><p id="c609" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">GraphQL对象类型的每个字段可以有零个或多个参数。</p><p id="ba99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d450" class="mn lc iq mj b gy mo mp l mq mr">type Person {<br/>  name: String!<br/>  height(unit: HeightUnit = METER): Float<br/>}</span></pre><p id="06a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，<code class="fe ms mt mu mj b">Person</code>中的<code class="fe ms mt mu mj b">height</code>字段将<code class="fe ms mt mu mj b">unit</code>作为参数。<code class="fe ms mt mu mj b">unit</code>属于<code class="fe ms mt mu mj b">HeightUnit</code>类型，默认设置为<code class="fe ms mt mu mj b">METER</code>。</p><p id="8625" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">height</code>返回一个浮点数。</p><h1 id="6b57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">查询和变异类型</h1><p id="8726" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">模式中有两种特殊的类型。他们是<code class="fe ms mt mu mj b">Query</code>和<code class="fe ms mt mu mj b">Mutation</code>。</p><p id="e4a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个GraphQL服务都有一个<code class="fe ms mt mu mj b">query</code>类型，可能有也可能没有<code class="fe ms mt mu mj b">mutation</code>类型。</p><p id="56f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些类型与任何其他对象类型相同，但它们很特殊，因为它们定义了每个GraphQL查询的入口点。</p><p id="a396" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有如下的查询:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8064" class="mn lc iq mj b gy mo mp l mq mr">query {<br/>  person {<br/>    name<br/>  }<br/>  robot(id: "2000") {<br/>    name<br/>  }<br/>}</span></pre><p id="07ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，GraphQL服务需要具有带<code class="fe ms mt mu mj b">person</code>和<code class="fe ms mt mu mj b">robot</code>字段的查询类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9958" class="mn lc iq mj b gy mo mp l mq mr">type Query {<br/>  person(name: String): Person<br/>  robot(id: ID!): Robot<br/>}</span></pre><p id="5ed9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用同样的方式定义突变类型。我们在<code class="fe ms mt mu mj b">Mutation</code>类型上定义字段，这些字段可以作为我们可以在查询中调用的根突变字段。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d3649e18401adb85155807f84bd0ba8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i9-sRy0L_TdkrL9d"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sarandywestfall_photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">sarandy westfall</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5101" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">标量类型</h1><p id="95d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">标量字段是所有对象类型最终包含的内容。它们是最基本的字段类型。</p><p id="7244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL自带以下标量类型:</p><ul class=""><li id="a26d" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><code class="fe ms mt mu mj b">Int</code> —一个有符号的32位整数</li><li id="20d6" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu mj b">Float</code> —有符号的双精度浮点值</li><li id="0015" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu mj b">String</code>—UTF-8字符序列</li><li id="7498" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu mj b">Boolean</code> — <code class="fe ms mt mu mj b">true</code>或<code class="fe ms mt mu mj b">false</code></li><li id="c502" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe ms mt mu mj b">ID</code> —用于获取对象或作为缓存关键字的唯一标识符。它的序列化方式与字符串相同，但它不适合人类阅读</li></ul><p id="f740" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数GraphQL服务实现也允许我们指定定制的标量类型。</p><p id="d251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以定义如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5c4d" class="mn lc iq mj b gy mo mp l mq mr">scalar Date</span></pre><p id="2501" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后由使用来决定如何序列化、反序列化和验证它们。</p><h1 id="2eb5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">枚举类型</h1><p id="1ebb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">枚举类型是标量的特殊类型，仅限于一组特定的允许值。</p><p id="b4fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它让我们验证该类型的任何参数都是允许的值之一。</p><p id="3f3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它通过类型系统传达一个字段总是有限的一组值中的一个。</p><p id="d2bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下定义枚举:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ced4" class="mn lc iq mj b gy mo mp l mq mr">enum Fruit {<br/>  APPLE<br/>  ORANGE<br/>  GRAPE<br/>}</span></pre><p id="b64b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们有<code class="fe ms mt mu mj b">Fruit</code>，我们期望它是<code class="fe ms mt mu mj b">APPLE</code>、<code class="fe ms mt mu mj b">ORANGE </code>或者<code class="fe ms mt mu mj b">GRAPE</code>。</p><h1 id="946b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="daf2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以定义类型，以便验证提交给GraphQL服务器的数据。</p><p id="945f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，如果是对象类型，我们用<code class="fe ms mt mu mj b">type</code>关键字创建一个类型。</p><p id="7ed9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以创建标量类型，这是最基本的类型，可以包含在其他类型中或直接引用。我们可以用关键字<code class="fe ms mt mu mj b">scalar</code>来定义它们。</p><p id="5584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了定义一个具有固定值的类型，我们可以定义一个具有几个可能的常数值的<code class="fe ms mt mu mj b">enum</code>类型。</p><p id="f95e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感叹号表示类型不可为空。</p></div></div>    
</body>
</html>