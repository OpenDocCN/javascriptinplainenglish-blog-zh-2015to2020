<html>
<head>
<title>Top Performance Tips for React App 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应应用2019的顶级性能提示</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-performance-tips-for-react-app-c688fc4942dd?source=collection_archive---------8-----------------------#2019-11-25">https://javascript.plainenglish.io/top-performance-tips-for-react-app-c688fc4942dd?source=collection_archive---------8-----------------------#2019-11-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/944eb2c749677391ce9eb284773f1fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*APTQs1OrRw4FoU2ijZu-aA.jpeg"/></div></figure><p id="67d9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">想象一下:你必须提高你的反应应用的性能。为了获得更好的性能，在开发和部署应用程序时，您应该注意哪些措施？</p><p id="5bae" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">就性能而言，React做得很好，但是，如果您有一个复杂的应用程序，您可能会发现它有问题。您仍然可以做一些事情来提高它的性能，具体分类如下:</p><ol class=""><li id="0fce" class="kp kq in jt b ju jv jy jz kc kr kg ks kk kt ko ku kv kw kx bi translated">发育</li><li id="42ee" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko ku kv kw kx bi translated">部署</li></ol><h1 id="6860" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">开发过程提示</h1><h2 id="d915" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">1.避免和测量渲染时间</h2><p id="f20f" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">首先，我们必须避免在没有任何要求的情况下重新渲染我们的组件。我们还需要计算渲染时间，以便减少渲染时间。一种简单的方法是使用<a class="ae ms" href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" rel="noopener ugc nofollow" target="_blank"> Use-Timing-API </a>。此外，您可以使用以下选项在浏览器中检查反应渲染。</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mt"><img src="../Images/abd618097af33143706f0aa59b06d525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViH5rFBOkmt0zK43T2k63Q.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">React rendering updates</figcaption></figure><h2 id="37ed" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">2.使用纯组分</h2><p id="538e" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">为了避免反应的协调过程，我们必须使用纯组件，因为,<code class="fe ng nh ni nj b">shouldComponentUpdate()</code>已经有了一个默认实现，只是简单的道具和状态比较。因此，纯组件是仅在<code class="fe ng nh ni nj b">props/state</code>不同于先前的<em class="nk">道具</em>和<em class="nk">状态</em>时才重新渲染的组件。</p><h2 id="8ea0" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">3.动态加载长列表</h2><p id="7a4a" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">如果你有一长串你想在页面上呈现的项目，那么把它分解成更小的列表，并在滚动或任何其他事件监听器上呈现。您可以通过<a class="ae ms" href="https://react-window.now.sh/#/examples/list/fixed-size" rel="noopener ugc nofollow" target="_blank">反应-窗口</a> &amp; <a class="ae ms" href="https://bvaughn.github.io/react-virtualized/#/components/List" rel="noopener ugc nofollow" target="_blank">反应-虚拟化</a>来完成。</p><h2 id="f124" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">4.反应并发模式</h2><p id="18b8" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">如果性能在你的反应应用中是最重要的，那么你必须选择反应并发模式。实现并发的最简单的方法之一是对组件进行反应暂挂和惰性加载。</p><h2 id="e076" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">5.使用骨架用户界面</h2><p id="fe94" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">我已经写了一篇关于这一点的文章，请查收:<a class="ae ms" href="https://medium.com/javascript-in-plain-english/speed-up-your-react-ux-with-skeleton-screens-f7b5831ef635" rel="noopener">反应骨架界面</a></p><h2 id="629e" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">6.使用挂钩</h2><p id="eb0f" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">反作用挂钩大大减少了应用程序中的代码。如果你不太熟悉反作用生命周期方法，尽可能多地尝试钩子。你也可以在<a class="ae ms" href="https://medium.com/javascript-in-plain-english/react-hooks-usestate-useeffect-useref-usememo-926fc2a86a6a?source=your_stories_page---------------------------" rel="noopener">反作用钩</a>上找到我的文章。</p><h2 id="fa99" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">7.构建渐进式应用程序</h2><p id="29cc" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">尝试构建渐进式应用程序，以便它可以在客户端浏览器上加载大量静态内容，从而实现平稳运行。</p><h2 id="c58d" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">8.删除失效代码</h2><p id="1fac" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">您可以使用SonarQube删除您的死代码<a class="ae ms" href="https://blog.sonarsource.com/detect-dead-code-and-calls-to-deprecated-methods-with-sonar-squid/" rel="noopener ugc nofollow" target="_blank">检查</a>。你也可以通过记录应用程序的重新渲染来检查你的代码覆盖率。</p><h2 id="402e" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">9.使用React上下文API</h2><p id="2ef1" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">不要使用任何状态管理库，如redux或mobx，使你的应用程序变得复杂。</p><h1 id="e689" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">部署流程提示</h1><h2 id="de97" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">10.使用生产版本</h2><p id="3ecc" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">React最小化react和react-dom的文件大小。这意味着我们用户的浏览器需要下载、解析和执行更少的东西，因此我们的页面加载更快。</p><p id="9233" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">例如，对于React 16.5.1，这些是我得到的大小:</p><ul class=""><li id="1189" class="kp kq in jt b ju jv jy jz kc kr kg ks kk kt ko nl kv kw kx bi translated">652K <code class="fe ng nh ni nj b">react-dom.development.js</code></li><li id="8f8e" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko nl kv kw kx bi translated">92K <code class="fe ng nh ni nj b">react-dom.production.min.js</code></li><li id="5ff0" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko nl kv kw kx bi translated">85K <code class="fe ng nh ni nj b">react.development.js</code></li><li id="5581" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko nl kv kw kx bi translated">9.5K <code class="fe ng nh ni nj b">react.production.min.js</code></li></ul><p id="9444" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是一个显著的差异！</p><h2 id="1498" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">11.使用Preact</h2><p id="1a3e" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">Preact是react的轻量级版本。如果您喜欢使用react构建视图，但性能、速度和大小是您的优先考虑事项，您可能更喜欢使用Preact作为轻量级替代方案，例如，在移动web应用程序或渐进式web应用程序的情况下。</p><p id="85a2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">React和Preact之间有许多不同之处，我们可以总结为三点:</p><ul class=""><li id="606c" class="kp kq in jt b ju jv jy jz kc kr kg ks kk kt ko nl kv kw kx bi translated"><strong class="jt io">特性和API </strong> : Preact只包含react API的一个子集，而不是React中所有可用的特性。</li><li id="6d38" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko nl kv kw kx bi translated"><strong class="jt io">大小</strong> : Preact比react小很多。</li><li id="1099" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko nl kv kw kx bi translated"><strong class="jt io">性能</strong> : Preact比react快。</li></ul><h2 id="c1f1" class="mb le in bd lf mc md dn lj me mf dp ln kc mg mh lr kg mi mj lv kk mk ml lz mm bi translated">12.配置Webpack包以最小化js文件。</h2><p id="9016" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">有几种方法可以做到这一点，但最简单的是更新webpack配置，将某些模块的任何导入别名化到该模块的概要版本。有两个这样的模块:</p><ul class=""><li id="6607" class="kp kq in jt b ju jv jy jz kc kr kg ks kk kt ko nl kv kw kx bi translated"><code class="fe ng nh ni nj b">react-dom</code>-&gt;-<code class="fe ng nh ni nj b">react-dom/profiling</code></li><li id="8f48" class="kp kq in jt b ju ky jy kz kc la kg lb kk lc ko nl kv kw kx bi translated"><code class="fe ng nh ni nj b">scheduler/tracing</code>-&gt;-T7】</li></ul><p id="3c57" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这些是我的顶级绩效构建技巧，希望你喜欢并学到了一些东西。</p></div></div>    
</body>
</html>