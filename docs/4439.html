<html>
<head>
<title>How to Build a Node.js Application with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Docker构建Node.js应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-a-node-js-application-with-docker-4a0164fdc9ca?source=collection_archive---------9-----------------------#2020-12-11">https://javascript.plainenglish.io/how-to-build-a-node-js-application-with-docker-4a0164fdc9ca?source=collection_archive---------9-----------------------#2020-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ffd9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过快速、全面地概述Docker容器以及如何在Node.js中使用它们，启动并运行Node.js应用程序</h2></div><p id="4f14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您已经找到了这篇文章，那就意味着您的任务是设置一个应用程序并在Docker容器中运行它。到本文结束时，您将能够做到这一点。</p><p id="e58b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在深入必要的代码之前，理解容器和Docker解决的底层问题是很重要的。幸运的是，这个问题很容易理解，并且会使我们的代码更容易理解。</p><blockquote class="lb lc ld"><p id="fc0e" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">对于已经熟悉Docker及其用例的读者，请滚动阅读下一部分。</p></blockquote><h1 id="eecd" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">容器解决的问题是什么？</h1><p id="c314" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">大多数开发人员都与下面的场景有关，这个场景很好地说明了容器的用途。一位同事要求您克隆他们的GitHub存储库，以帮助他们调试问题。在您克隆了它并安装了必要的依赖项之后，您发现应用程序将无法运行。它抛出各种各样的错误，没有一个是你的同事请求帮助的问题。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/baec07161ed7a8cf4519bfc7d188830a.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*fyElPtQLGfcb2e-L_KBm7g.png"/></div></figure><p id="48f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你们两个刚刚遇到的问题是在不同环境的不同机器上运行应用程序。没有两个开发者拥有相同的机器。仅仅因为一个开发者的应用可以在他们的机器上运行，并不意味着它也可以在你的机器上运行，因为你的机器在他们各自的环境中可能有许多不同的属性，比如:</p><ul class=""><li id="2da9" class="mn mo iq kh b ki kj kl km ko mp ks mq kw mr la ms mt mu mv bi translated">操作系统；</li><li id="8f61" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">软件版本；</li><li id="f56b" class="mn mo iq kh b ki mw kl mx ko my ks mz kw na la ms mt mu mv bi translated">已安装的依赖项；</li></ul><p id="52e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同之处不胜枚举！这个问题的解决方法是什么？</p><p id="ba6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<strong class="kh ir">集装箱</strong>解决方案的地方。通过将代码和<strong class="kh ir">及其所有</strong>依赖项打包到一个隔离的容器中，开发人员可以在任何机器上运行该容器并获得可预测的结果，因为<strong class="kh ir">应用程序运行</strong>所需的一切都包含在该容器中。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/972600b85cfdd9496d043c89b26e8cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*Kk1ORnsTLHpMH5aDl-G5lw.png"/></div></figure><p id="fd7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦应用程序被容器化，它就可以在任何机器上共享和运行。因此，前面提到的开发环境不兼容的问题得到了解决。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/f06df49728a784cd43226f4a36fc98c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*wwsKbz9ccCybIbUSRqnpOA.png"/></div></figure><p id="faf4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经得到了容器的定义:<strong class="kh ir">容器</strong>是一个软件单元，它打包了代码和所有代码的依赖项，因此它可以在任何机器上运行。</p><p id="e209" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们把这个定义翻译成Node.js应用程序；打包代码及其依赖项的过程会是什么样的？</p><p id="ed6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，运行应用程序的主机将需要Node.js运行时，因此应该包括它。接下来，我们需要组成应用程序的实际代码，比如<code class="fe nc nd ne nf b">index.js</code>，以及组成应用程序的所有其他文件。我们还需要<code class="fe nc nd ne nf b">package.json</code>，因为该文件为应用程序定义了必要的<strong class="kh ir">依赖关系</strong>。</p><p id="0a9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们需要定义实际运行应用程序所需的命令。</p><p id="8f50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经看到了Docker容器解决的问题，让我们实际上为Node.js应用程序创建一个。</p><h1 id="f9c3" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">定义Dockerfile文件</h1><p id="28c4" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">转到一个新目录并运行<code class="fe nc nd ne nf b">npm init</code>。这将创建一个新的<code class="fe nc nd ne nf b">package.json</code>文件，用于定义应用程序及其依赖项。</p><p id="c884" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们添加一个依赖:运行<code class="fe nc nd ne nf b">npm i express</code>来安装<strong class="kh ir"> express </strong>作为一个依赖。我们将使用这个包来创建一个服务器。</p><p id="bcc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，为应用程序创建入口点文件。它的名称将是您在<code class="fe nc nd ne nf b">init</code>设置期间定义的名称。在我的机器上，它是<code class="fe nc nd ne nf b">index.js</code>，所以我将运行<code class="fe nc nd ne nf b">touch index.js</code>。</p><p id="b54d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开<code class="fe nc nd ne nf b">index.js</code>并粘贴以下代码:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9cb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nc nd ne nf b">index.js</code>只是指定一个<strong class="kh ir">主机和端口</strong>的组合来监听请求。当我们访问根节点<code class="fe nc nd ne nf b">/</code>时，我们将在代码的第11行收到响应。</p><p id="f6b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些代码足以编写和测试Docker容器。</p><p id="3e11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了启动Docker容器，我们首先需要编写一个<strong class="kh ir"> Dockerfile </strong>，它定义了应用程序、它的依赖项以及应用程序运行所需执行的任何命令。运行命令<code class="fe nc nd ne nf b">touch Dockerfile</code>并在文本编辑器中打开它。</p><p id="6f57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要定义基本的<strong class="kh ir">图像</strong>，它将被用来构建这个容器。</p><p id="0446" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kh ir">图像</strong>被用来构建一个Docker容器。映像提供了在其中作为容器运行特定应用程序或软件的必要环境。在我们的例子中，我们运行的是Node.js应用程序，因此我们需要从Node.js映像构建，以便为我们的应用程序提供Node.js运行时。为此，模仿以下docker文件:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><blockquote class="lb lc ld"><p id="4bb6" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">我们选择了Node.js提供的某张图片，有很多不同的选项；在这种情况下，我们选择了它的一个小图像。</p></blockquote><p id="ab6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们定义容器内部的工作目录。这个目录将存放我们的应用程序代码。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8714" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是将<code class="fe nc nd ne nf b">package.json</code>文件从我们机器上的当前目录复制到镜像中，并运行<code class="fe nc nd ne nf b">npm install</code>来安装<code class="fe nc nd ne nf b">package.json</code>中定义的依赖项。因为我们已经使用了Node.js的基本映像，所以NPM已经安装好了，可以在容器内部运行。</p><p id="fa4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将使用命令<strong class="kh ir">复制</strong>和<strong class="kh ir">运行</strong>。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><blockquote class="lb lc ld"><p id="3841" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><code class="fe nc nd ne nf b">COPY package.json .</code>会将我们<strong class="kh ir">当前目录</strong>中的<code class="fe nc nd ne nf b">package.json</code>复制到工作目录<code class="fe nc nd ne nf b">/usr/src/app/package.json</code>。</p></blockquote><p id="0f5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们几乎完成了——现在，我们需要复制应用程序的其余源代码；在这种情况下，它只是<code class="fe nc nd ne nf b">index.js</code>。为当前目录定义另一个<strong class="kh ir"> COPY </strong>命令。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1802" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在需要使用一个新的命令，即<strong class="kh ir"> EXPOSE </strong>。该命令告诉Docker容器在运行时监听哪个端口。在我们的例子中，我们的应用程序监听3000，所以在容器中公开相同的端口。除了暴露容器的3000端口之外，运行最终命令来启动应用程序:<code class="fe nc nd ne nf b">node index.js</code>。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="96d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在实际构建此映像并运行容器之前，创建一个<code class="fe nc nd ne nf b">.dockerignore</code>文件来定义构建映像时应该忽略当前目录中的哪些文件。该文件应与文件存在于<strong class="kh ir">相同的目录中。</strong></p><p id="8509" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，整个目录正被复制到图像中的工作目录中，包括节点模块。</p><p id="fac4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个目录可能很大。我们不想包含<code class="fe nc nd ne nf b">node_modules</code>，所以将其添加到<code class="fe nc nd ne nf b">.dockerignore</code>。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="509f" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">塑造形象</h1><p id="658b" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Dockerfile已经定义，但是我们还没有建立图像。为了在容器中运行这个应用程序，我们需要运行代表应用程序的图像。所以，让我们从Dockerfile构建我们的图像，然后将图像作为一个容器运行。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4426dd6ebe4605dc21786de549ef5e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*Q88fN6VpeLZ7w-1T45xCqA.png"/></div></figure><p id="8899" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在当前目录下，运行<code class="fe nc nd ne nf b">docker build -t &lt;your_name&gt;/node_app .</code>。末尾的<code class="fe nc nd ne nf b">.</code>指定检查当前目录是否有文件，而<code class="fe nc nd ne nf b">-t &lt;your_name&gt;/node_app</code>给图像一个<strong class="kh ir">标签</strong>，您可以简洁地指定运行图像。</p><p id="6b15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在成功构建之后，就可以将图像作为一个容器运行了。运行以下命令:<code class="fe nc nd ne nf b">docker run -p 5000:3000 -d &lt;your_name&gt;/node_app</code>。</p><p id="34d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nc nd ne nf b">-p</code>指定机器上的公共端口，以映射到Docker容器中的内部端口。在这种情况下，我们映射到端口3000，因此在5000处对我们的机器<strong class="kh ir"/>的请求将被路由到码头工人集装箱的3000端口。<code class="fe nc nd ne nf b">-d</code>指示Docker将该容器作为后台进程运行，以便您可以继续在终端中操作。</p><p id="1cba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在浏览器中访问<code class="fe nc nd ne nf b">localhost:5000</code>，出现消息“正在Docker上运行！”应该在场。</p><h1 id="bff0" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">结论</h1><p id="2aa9" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">可以看到，Docker容器通过确保我们可以在任何机器上运行任何应用程序，给了开发人员巨大的能力。</p><p id="b78c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们只接触到了Docker的一小部分权力。对于任何想要额外工作的读者，尝试下面的练习。</p><p id="ab16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个以某种方式使用<strong class="kh ir"> Redis </strong>实例的应用程序。然后，定义一个<code class="fe nc nd ne nf b">docker-compose</code>文件，该文件可以无缝地运行应用程序和Redis，并允许它们通过共享网络进行通信。</p><p id="40f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你好运，编码快乐！</p></div></div>    
</body>
</html>