<html>
<head>
<title>Split Your Jest Test Suite Into Multiple Parallel Jobs With Jenkins and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jenkins和Kubernetes将您的Jest测试套件分成多个并行作业</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/splitting-a-jest-node-js-test-suite-into-multiple-parallel-jobs-on-jenkins-kubernetes-dabf48567f50?source=collection_archive---------2-----------------------#2020-07-29">https://javascript.plainenglish.io/splitting-a-jest-node-js-test-suite-into-multiple-parallel-jobs-on-jenkins-kubernetes-dabf48567f50?source=collection_archive---------2-----------------------#2020-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/91c07d6963be600ebfba3869dd761076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UybJ6knZcCt5_05y"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@christianem?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christian Englmeier</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6bc3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">速度是一个让人渴望的目标……不知何故，当你走在去某个地方的高速公路上时，更快地到达那里是你的目标，实现这个目标会让你比同一条高速公路上的其他人感觉“更好”。</p><p id="2a60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我热爱速度，并不断努力在房间里跑得最快…但有些问题最好通过将赛道切成两半来解决。如果你能承担额外的工作，同时做多件事可以让你更上一层楼。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="bede" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是可以接受的？</h1><p id="41c9" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我记得有一次我在读一篇非常不值得回忆的博客帖子，但是我记得的是，帖子中说他们公司花了一整天<strong class="kc io">的时间</strong>来运行他们的端到端测试套件，并且等待这些测试很麻烦。我坐在这里阅读和思考…嗯，是的，一天是一个非常长的反馈循环。虽然这个轶事不是100%相关，因为这个博客是关于服务器单元/集成测试而不是e2e测试的，但是它很好地传达了测试套件经常在缺乏关注的情况下增长。</p><p id="21e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">人们增加保险是因为增加保险很容易。维护测试套件周围的区域经常被忽视或者不习惯。持续集成管道周转时间的微小增长可以为开发团队节省大量时间，并加快发布新功能和关键错误修复的部署周期。这两样东西是无价的。</p><p id="4f0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不管节省时间还是潜在的好处，作为开发人员，我们应该追求工作的质量和效率。我们不能让花园里的杂草失去控制。永远记得问自己这样一个问题……如果某件事让你等得很麻烦，那真的可以接受吗？</p><h1 id="5f4a" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">我们的世界</h1><p id="3ffe" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在Galley Solutions，我们最近完成了一些出色的工作，将我们的e2e测试运行时间从大约35分钟减少到大约13分钟，节省了大量时间！</p><p id="c437" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这很棒，但这并不意味着我们的CI渠道在整体上节省了大量时间。我们有一个Node.js API测试套件，运行约30分钟，在e2e优化后，API测试成为新的速率限制步骤。对于准备对给定的特性或PR低头的开发人员来说，及时收到分支测试的反馈是至关重要的。我们决定是时候利用我们的基础设施中的一些现有优势，并创建多个并行执行阶段，每个阶段执行测试套件的一个给定部分。</p><h1 id="93c6" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">成功的步骤</h1><p id="3dcf" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们需要执行以下三个步骤。</p><ol class=""><li id="8a67" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">我们需要能够运行一个命令，对他们自己的数据库执行一组特定的测试文件。</li><li id="ec7d" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">我们需要一些代码，这些代码将接受一个常量<code class="fe nb nc nd ne b">NUM_PARALLEL_STEPS</code>并生成一组文件，每个文件都包含要在给定步骤中运行的文件。</li><li id="976c" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">最后，我们需要一些基于<code class="fe nb nc nd ne b">NUM_PARALLEL_STEPS</code>常量动态生成每个API阶段的代码，这些代码将使用上面步骤2中的文件调用步骤1中的命令。</li></ol><h1 id="9909" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">假设和依赖性</h1><p id="1988" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">好的，在我们开始之前，让我们陈述一些我们正在处理的依赖和约束…</p><ol class=""><li id="8652" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">我们的大多数测试都是集成测试，所以需要一个数据库</li><li id="f743" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">在Kubernetes上运行的Jenkins(或能够执行工人作业)</li><li id="83b2" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">脚本化的Jenkinsfile语法(不是必需的，但这是代码示例的语法)</li><li id="ded7" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">带有Typescript和/或的Jest和Node.js。js文件</li><li id="2b2d" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">Sequelize/Postgres作为ORM/DB(不是必需的，但这是示例所针对的)</li></ol><p id="94fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想我们准备好了。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="d314" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第一步。测试命令</h1><p id="9a6a" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们将首先设置我们的sequelize配置来读取一个<code class="fe nb nc nd ne b">DATABASE_URL</code>环境变量。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="1327" class="nn lg in ne b gy no np l nq nr">module.exports = {<br/>  "test-parallel": {<br/>    use_env_variable: "DATABASE_URL",<br/>    dialect: "postgres",<br/>    logging: false<br/>  }<br/>}</span></pre><p id="7419" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上例中的<code class="fe nb nc nd ne b">test-parallel</code>指的是我们的<code class="fe nb nc nd ne b">NODE_ENV</code>。相应的<code class="fe nb nc nd ne b">sequelize.ts</code>初始化文件看起来会像这样…</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="9bf3" class="nn lg in ne b gy no np l nq nr">import { Sequelize } from "sequelize";</span><span id="6272" class="nn lg in ne b gy ns np l nq nr">const env = process.env.NODE_ENV!;</span><span id="7fd2" class="nn lg in ne b gy ns np l nq nr">const { use_env_variable, ...config } = require("./config")[env];</span><span id="54e4" class="nn lg in ne b gy ns np l nq nr">const sequelize = new Sequelize(process.env[use_env_variable]!, config)</span><span id="ae77" class="nn lg in ne b gy ns np l nq nr">export default sequelize;</span></pre><p id="2231" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可能看起来有点过分，但我们通常在配置中有更多的环境。这里真正重要的是<code class="fe nb nc nd ne b">new Sequelize("DATABASE_URL", {dialect: "postgres", logging: false})</code>被实例化，并在第一个参数中被告知寻找<code class="fe nb nc nd ne b">DATABASE_URL</code>。</p><p id="61bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在没有实际数据库的情况下进行顺序配置对我们没有好处。当我们构建postgres容器时，我们没有数据库，需要一些东西来处理数据库的创建和迁移。shell脚本就可以了。</p><p id="027c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">db_rebuild.sh</code>看起来会像这样…</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="25d4" class="nn lg in ne b gy no np l nq nr">NODE_ENV=test-parallel yarn sequelize db:create 2&gt; /dev/null || :</span><span id="69cd" class="nn lg in ne b gy ns np l nq nr">m=`NODE_ENV=test-parallel yarn sequelize db:migrate:status | grep ^down | wc -l`</span><span id="5777" class="nn lg in ne b gy ns np l nq nr">if [ $m -gt 0 ]<br/>then<br/>    echo RECREATING DATABASE<br/>    NODE_ENV=test-parallel yarn sequelize db:drop<br/>    NODE_ENV=test-parallel yarn sequelize db:create<br/>  else<br/>    echo MIGRATING DATABASE<br/>  fi<br/>  NODE_ENV=test-parallel NODE_PATH=./src yarn sequelize db:migrate<br/>else<br/>  echo DATABASE IS UP TO DATE<br/>fi</span></pre><p id="6f75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nt">功劳归于</em> <a class="nu nv ep" href="https://medium.com/u/c479a67cd754?source=post_page-----dabf48567f50--------------------------------" rel="noopener" target="_blank"> <em class="nt">凯尔·轩尼诗</em> </a> <em class="nt">以上为</em></p><p id="1781" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一行将创建数据库或给我们一些控制台输出，第二个命令将询问有多少迁移没有被应用。如果尚未应用的迁移数大于0，我们将删除并重新创建数据库，然后执行迁移。</p><p id="0e8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了一个已经存在并完全迁移的数据库。接下来，我们将需要处理我们的测试命令，将这些部分组合在一起。</p><p id="1b5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的package.json中(我们使用yarn)，在脚本部分我们需要一个命令。我们希望在ci中这样做，该命令的不同之处在于它执行测试时会查看文件的输出，因此我们可以将其命名为类似于<code class="fe nb nc nd ne b">test:ci:parallel</code>的名称。这个命令需要调用我们的db脚本并执行我们的测试命令。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="2068" class="nn lg in ne b gy no np l nq nr">"scripts": {<br/>  "test:ci:parallel": "./&lt;PATH_TO&gt;/dbrebuild.sh &amp;&amp; NODE_ENV=test-parallel yarn run jest --ci --runInBand"<br/>}</span></pre><p id="c587" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以测试这个了！</p><p id="8b4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用测试套件中的两个测试名创建一个文件。</p><p id="cec6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">touch my_tests &amp;&amp; vi my_tests</code></p><p id="d419" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">粘贴文件名并保存，然后</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="5a3b" class="nn lg in ne b gy no np l nq nr">export DATABASE_URL=postgres://&lt;USER_NAME&gt;:&lt;PASSWORD&gt;<a class="ae jz" href="http://twitter.com/localhost" rel="noopener ugc nofollow" target="_blank">@localhost</a>:5432/&lt;DB_NAME&gt;</span></pre><p id="fbd9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用随机的东西替换user_name、password和db_name，但最终这个变量将是在给定Node.js容器的env上定义的变量。</p><p id="adc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，让我们使用cat…调用带有文件输出的命令</p><p id="68eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">yarn test:ci:parallel $(cat my_tests)</code></p><p id="2bc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Jest应该针对上面给出的任何<code class="fe nb nc nd ne b">DB_NAME</code>执行两个测试(基于模式匹配)。</p><p id="1ff1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题？请在下面留下回答，我们可以进行故障排除。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="4b86" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第二步。生成测试清单文件</h1><p id="06bd" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们第二步的目标是创建一段代码，这段代码将采用<code class="fe nb nc nd ne b">NUM_PARALLEL_STEPS</code>，并将我们的测试套件分成与并行步骤一样多的文件。我们可以在Jenkinsfile中使用groovy做到这一点，但是在探索了一点之后，我发现走不同的路线更容易……这意味着它即将变得脆弱。</p><p id="fb9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>为了简化事情，我们可以采用一个更复杂的命令，并将所需的行为片段分解成更小的块。将所有较小的命令串在一起将得到我们想要的全局输出。</p><h2 id="2d89" class="nn lg in bd lh nw nx dn ll ny nz dp lp kl oa ob lt kp oc od lx kt oe of mb og bi translated">用Globbing列出所有文件</h2><p id="6a25" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们从简单地列出所有测试文件开始，为此我们利用<a class="ae jz" href="https://linuxhint.com/bash_globbing_tutorial/" rel="noopener ugc nofollow" target="_blank"> globbing </a>。</p><p id="4fa4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们在项目根目录中，并且我们所有的代码和测试都在<code class="fe nb nc nd ne b">./src </code>子目录中，我们可以像这样…</p><p id="7869" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">苹果电脑:</strong></p><p id="bebe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">./ls src/**/*.spec.js src/**/*.spec.ts</code></p><p id="6391" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Debian: </strong>(我们使用的jenkins映像的linux版本)</p><p id="6f8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">find ./src -printf ‘%f\n’ | grep .spec</code></p><h2 id="7155" class="nn lg in bd lh nw nx dn ll ny nz dp lp kl oa ob lt kp oc od lx kt oe of mb og bi translated">将输出分割成文件</h2><p id="a1fb" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">太好了！现在我们有了一个测试文件字符串的列表，我们如何将一定数量的字符串放入文件清单中呢？假设我的列表中有10个文件字符串，我希望一个文件中有5个，另一个文件中有5个。</p><p id="6a1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以利用<code class="fe nb nc nd ne b">split</code>和这些选项……<br/><code class="fe nb nc nd ne b">split -a 1 -d -l 5 — api_</code></p><p id="5904" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">-a</code>选项指定附加后缀的长度，<code class="fe nb nc nd ne b">-d</code>指定数字后缀，<code class="fe nb nc nd ne b">-l</code>是每个文件的行数，<code class="fe nb nc nd ne b">api_</code>是我们要给每个文件的前缀。所以这个命令会把一个10行的文件分成两个5行的文件，分别叫做<code class="fe nb nc nd ne b">api_0</code>和<code class="fe nb nc nd ne b">api_1</code>。</p><p id="bd55" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您所要做的就是将第一个命令的输出通过管道传递给split命令。</p><p id="3c81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> MacOS: </strong></p><p id="28cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">./ls src/**/*.spec.js src/**/*.spec.ts | split -a 1 -d -l 5 — api_</code></p><p id="f570" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Debian: </strong>(我们使用的jenkins映像的linux版本)</p><p id="5c59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">find ./src -printf ‘%f\n’ | grep .spec | split -a 1 -d -l 5 — api_</code></p><p id="7dab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完美！</p><h2 id="e88f" class="nn lg in bd lh nw nx dn ll ny nz dp lp kl oa ob lt kp oc od lx kt oe of mb og bi translated">计算每个清单中的文件数量</h2><p id="734f" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">最后一部分是在split命令中为<code class="fe nb nc nd ne b">-l</code>动态创建数字。随着我们测试套件的增长，每个文件的测试数量需要增长，因为<code class="fe nb nc nd ne b">NUM_PARALLEL_STEPS</code>是不变的。</p><p id="dfd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们使用<code class="fe nb nc nd ne b">wc -l</code>作为<code class="fe nb nc nd ne b">NUM_TESTS</code>从测试中获取行数，然后用<code class="fe nb nc nd ne b">NUM_TESTS</code>除以<code class="fe nb nc nd ne b">NUM_PARALLEL_STEPS + 1</code>(处理奇数情况)，我们将得到每个文件的行数。</p><p id="8da2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> MacOS: </strong></p><p id="339d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">echo $(($(./ls src/**/*.spec.js src/**/*.spec.ts | wc -l)/3+1))</code></p><p id="1cdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Debian: (我们使用的jenkins映像的linux版本)</p><p id="63e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">echo $(($(find ./src -printf ‘%f\n’ | grep .spec | wc -l)/3+1))</code></p><p id="0ac0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">恭喜你。这是第二步。到最后一个…</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="63c9" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第三步。平行詹金斯阶段</h1><p id="7f0b" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这就是我们把所有东西都集中在一起的地方。詹金斯档案。游戏时间。没有囚犯。自由。眼睛盯着奖品…</p><figure class="nf ng nh ni gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/c1f401e114524f7aadb30709181c63af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BZdHcBNmrl6cBBJo"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@japhethmast?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Japheth Mast</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3a56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的构建阶段，我们将使用步骤2中的命令，因为当我们生成并运行并行阶段时，我们需要测试清单文件存在。我们可以利用for循环和我们的<code class="fe nb nc nd ne b">NUM_PARALLEL_STEPS</code>常量在一个<code class="fe nb nc nd ne b">tests</code>对象中添加阶段，我们将在Jenkinsfile中用<code class="fe nb nc nd ne b">parallel</code>命令调用这个对象。</p><p id="3d4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">走吧。</p><h2 id="9e6a" class="nn lg in bd lh nw nx dn ll ny nz dp lp kl oa ob lt kp oc od lx kt oe of mb og bi translated">确保数据库设置正确</h2><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="2499" class="nn lg in ne b gy no np l nq nr">containerTemplate(<br/>            name: 'api-db',<br/>            image: 'postgres:11.2-alpine',                 ttyEnabled: true,<br/>            envVars: [<br/>                envVar(key: 'POSTGRES_USER', value: '&lt;USER_NAME&gt;'),<br/>                envVar(key: 'POSTGRES_DB', value: 'default'),<br/>                envVar(key: 'POSTGRES_PASSWORD', value: '&lt;PASSWORD&gt;')<br/>            ],</span><span id="66c1" class="nn lg in ne b gy ns np l nq nr">)</span></pre><p id="8ec3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的<code class="fe nb nc nd ne b">api-db</code>容器中，让我们为<code class="fe nb nc nd ne b">USER_NAME</code>和<code class="fe nb nc nd ne b">PASSWORD.</code>指定一个环境变量。你可以在那里放一个随机的名字。</p><p id="d55f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用的另一个容器是<code class="fe nb nc nd ne b">node</code>容器。</p><h2 id="b05f" class="nn lg in bd lh nw nx dn ll ny nz dp lp kl oa ob lt kp oc od lx kt oe of mb og bi translated">构建阶段</h2><p id="88fb" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">假设我们的构建阶段看起来像…</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="54dd" class="nn lg in ne b gy no np l nq nr">stage('Build Dependencies'){<br/>                container('node') {<br/>                    try {<br/>                        sh "yarn install --frozen-lockfile"<br/>                        sh "cd api &amp;&amp; yarn build:test"<br/>                    } catch (Exception e) {<br/>                        notifySomethingErrored()<br/>                        throw e<br/>                    }<br/>                }<br/>        }</span></pre><p id="9272" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们安装我们的依赖项，然后从我们的<code class="fe nb nc nd ne b">./src</code>目录开始构建。如果发生错误，我们会通知。</p><p id="32d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>在我们的例子中，我们针对我们的构建目录运行测试，所以这些命令的其余部分将只引用<code class="fe nb nc nd ne b">.spec.js</code>文件，但是您可以轻松地针对<code class="fe nb nc nd ne b">./src</code>运行测试，并在您的命令中包含<code class="fe nb nc nd ne b">.spec.ts</code>。</p><p id="c765" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们运行完<code class="fe nb nc nd ne b">yarn build:test</code>之后，我们想要计算我们的<code class="fe nb nc nd ne b">numAPISpecsPerStage</code>。为此，我们可以从步骤2中提取命令，并将STDOUT输出到<code class="fe nb nc nd ne b">numAPISpecsPerStage</code>。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="d929" class="nn lg in ne b gy no np l nq nr">def numAPISpecsPerStage = sh(<br/>        script: "cd packages/api &amp;&amp; echo \$((\$(find ./build -printf '%f\n' | grep .spec.js\$ | wc -l)/${NUM_PARALLEL_STEPS}+1))",<br/>        returnStdout: true<br/>).trim()</span></pre><p id="74f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意:</strong>在groovy中执行bash命令时，如果我们希望bash解释任何<code class="fe nb nc nd ne b">$</code>字符，我们需要对其进行转义，否则，groovy会试图将它们解释为变量。</p><p id="fb58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将使用上面的变量来构建我们的清单文件</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="3e9c" class="nn lg in ne b gy no np l nq nr">sh "cd packages/api &amp;&amp; find ./build -printf '%f\n' | grep .spec.js\$ | split -a 1 -d -l ${numAPISpecsPerStage} - api_"</span></pre><p id="1135" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，让我们调用一个随机函数，<code class="fe nb nc nd ne b">buildApiStages()</code>，我们还没有写。</p><p id="ddb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将这些插入到<code class="fe nb nc nd ne b">build</code>级产生，</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="12ed" class="nn lg in ne b gy no np l nq nr">stage('Build Dependencies'){<br/>                container('node') {<br/>                    try {<br/>                        sh "yarn install --frozen-lockfile"<br/>                        sh "cd api &amp;&amp; yarn build:test"<br/>                        def numAPISpecsPerStage = sh(<br/>                            script: "cd packages/api &amp;&amp; echo \$((\$(find ./build -printf '%f\n' | grep .spec.js\$ | wc -l)/${NUM_PARALLEL_API_STAGES}+1))",<br/>                            returnStdout: true<br/>                         ).trim()<br/>                        sh "cd packages/api &amp;&amp; find ./build -printf '%f\n' | grep .spec.js\$ | split -a 1 -d -l ${numAPISpecsPerStage} - api_"<br/>                        buildAPIStages()<br/>                    } catch (Exception e) {<br/>                        notifySomethingErrored()<br/>                        throw e<br/>                    }<br/>                }<br/>        }</span></pre><p id="dd0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是的，我们完全可以将我们的文件列表输出提取到一个变量中，我们用管道<code class="fe nb nc nd ne b">echo</code>和<code class="fe nb nc nd ne b">wc</code>和<code class="fe nb nc nd ne b">split</code>进行清理。</p><h2 id="74db" class="nn lg in bd lh nw nx dn ll ny nz dp lp kl oa ob lt kp oc od lx kt oe of mb og bi translated">API阶段</h2><p id="6ac0" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">接下来，我们可以充实<code class="fe nb nc nd ne b">buildApiStages()</code>函数。在文件的顶部附近，或者任何你想定义函数的地方，让我们复制当前的API测试阶段代码。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="44ad" class="nn lg in ne b gy no np l nq nr">"api": {<br/>            timeout(time: 40, unit: 'MINUTES') {<br/>                container('node') {<br/>                        try {<br/>                            sh "cd api &amp;&amp; yarn test:ci"<br/>                        } catch (Exception e) {<br/>                            notifySomethingErrored()<br/>                            throw e<br/>                        }<br/>                }<br/>            }<br/>        }</span></pre><p id="efcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当前代码执行测试或通知失败。让我们修改一下，首先将我们关心的环境变量暴露给容器。</p><p id="4760" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe nb nc nd ne b">try</code>的正上方，我们将利用<code class="fe nb nc nd ne b">withEnv</code>包装器。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="e511" class="nn lg in ne b gy no np l nq nr">withEnv([“DATABASE_URL=$DATABASE_URL”, “NODE_ENV=test-parallel”, “NODE_PATH=./build”]){<br/> …code<br/>}</span></pre><p id="1eca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们公开一个<code class="fe nb nc nd ne b">$DATABASE_URL</code>并将其设置为一个我们还没有构建的变量。然后，我们将我们的env设置为<code class="fe nb nc nd ne b">test-parallel</code>，并将我们的<code class="fe nb nc nd ne b">NODE_PATH</code>指向<code class="fe nb nc nd ne b">./build</code>(如果您正在运行源代码，您可以指定<code class="fe nb nc nd ne b">./src</code>)。</p><p id="1487" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们可以在步骤1中添加我们的测试命令，对于我们想要<code class="fe nb nc nd ne b">cat</code>出来的文件，让我们使用一个我们还没有构建的变量，比如<code class="fe nb nc nd ne b">UNIT_TEST_FILE_NAME</code>。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="1ca0" class="nn lg in ne b gy no np l nq nr">sh "cd packages/api &amp;&amp; yarn test:ci:parallel \$(cat ${UNIT_TEST_FILE_NAME})"</span></pre><p id="1cc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这给了我们一个API阶段，看起来像…</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="0c3f" class="nn lg in ne b gy no np l nq nr">"api": {<br/>          timeout(time: 40, unit: 'MINUTES') {<br/>            container('node') {<br/>              withEnv(["DATABASE_URL=$DATABASE_URL", "NODE_ENV=test-parallel", "NODE_PATH=./build"]){<br/>                try {<br/>                  sh "cd api &amp;&amp; yarn test:ci:parallel \$(cat ${UNIT_TEST_FILE_NAME})"<br/>                } catch (Exception e) {<br/>                  notifySomethingErrored()<br/>                  throw e<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }</span></pre><h2 id="73e2" class="nn lg in bd lh nw nx dn ll ny nz dp lp kl oa ob lt kp oc od lx kt oe of mb og bi translated">多个API阶段</h2><p id="178b" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">如果你注意到，<code class="fe nb nc nd ne b">“api”</code>只是一个键，我们把那个键设置成一个对象(我们的stage)。为此，我们可以实例化一个<code class="fe nb nc nd ne b">tests</code>映射，然后利用一个For循环来设置几个不同的键，使其等于多个阶段。</p><p id="89ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">tests = [:]</code></p><p id="a3e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们定义我们的变量<code class="fe nb nc nd ne b">NUM_PARALLEL_API_STAGES=2</code>并开始我们的函数和循环。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="4b21" class="nn lg in ne b gy no np l nq nr">def buildAPIStages(){<br/> for(int i = 0; i&lt;NUM_PARALLEL_API_STAGES; i++) {<br/>  ...code<br/> }</span></pre><p id="7650" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们还需要在循环的上下文中定义一些变量。</p><p id="0697" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nb nc nd ne b">def UNIT_TEST_FILE_NAME = “api_${i}”</code></p><p id="58ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将把它作为<code class="fe nb nc nd ne b">tests</code>地图中的关键。该变量与<code class="fe nb nc nd ne b">split</code>命令的文件名相关联。<code class="fe nb nc nd ne b">split</code>给了我们<code class="fe nb nc nd ne b">api_0</code>、<code class="fe nb nc nd ne b">api_1</code>等…所以每个阶段都会根据loops索引调用一个特定的清单文件。</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="8d11" class="nn lg in ne b gy no np l nq nr">def DATABASE_URL = “postgres://&lt;USER_NAME&gt;:&lt;PASSWORD&gt;<a class="ae jz" href="http://twitter.com/localhost" rel="noopener ugc nofollow" target="_blank">@localhost</a>:5432/$UNIT_TEST_FILE_NAME”`</span></pre><p id="a950" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">填写<code class="fe nb nc nd ne b">&lt;PASSWORD&gt;</code>和<code class="fe nb nc nd ne b">&lt;USER_NAME&gt;</code>对应于<code class="fe nb nc nd ne b">api_db</code>后缀容器上定义的变量。</p><p id="0382" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，对于最后一部分，让我们将测试映射中的键设置为api stage对象。给我们最后一个功能…</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="788a" class="nn lg in ne b gy no np l nq nr">def buildAPIStages(){<br/>    for(int i = 0; i&lt;NUM_PARALLEL_API_STAGES; i++) {<br/>        def UNIT_TEST_FILE_NAME = "api_${i}"<br/>        def DATABASE_URL = "postgres://&lt;USER_NAME&gt;:&lt;PASSWORD&gt;@localhost:5432/$UNIT_TEST_FILE_NAME"<br/>        tests["${UNIT_TEST_FILE_NAME}"] = {<br/>            timeout(time: 40, unit: 'MINUTES') {<br/>                container('node') {<br/>                    withEnv(["DATABASE_URL=$DATABASE_URL", "NODE_ENV=test-parallel", "NODE_PATH=./build"]){<br/>                        try {<br/>                            sh "cd api &amp;&amp; yarn test:ci:parallel \$(cat ${UNIT_TEST_FILE_NAME})"<br/>                        } catch (Exception e) {<br/>                            notifySomethingErrored()<br/>                            throw e<br/>                        }<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="0b3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们很快就要完成了。在<code class="fe nb nc nd ne b">build</code>阶段，我们建立了我们的文件并建立了我们的动态阶段，现在我们只需要告诉Jenkins并行执行它们。</p><p id="6a56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了这个功能…</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="de58" class="nn lg in ne b gy no np l nq nr">def doParallelStages(){<br/> parallel tests<br/>}</span></pre><p id="ab32" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而这个阶段，放置在<code class="fe nb nc nd ne b">build</code>阶段之后…</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="990a" class="nn lg in ne b gy no np l nq nr">stage(‘Run Tests’){<br/> doParallelStages()<br/>}</span></pre><h1 id="2d56" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">鳍状物</h1><p id="e162" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们的世界现在是并行的。问题、议题、如何做得更好的想法，在回复中给我写一行字，我将很乐意向您学习或提供帮助。</p><p id="63e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这类工作真正酷的地方在于，您真的为整个组织节省了这么多时间。它让工作生活(也许还有个人生活？？)对你的同事和队友来说更容易、更有效率。有时，这可能看起来并不紧迫或必要，但当您花时间提高组织的效率时，开发人员的幸福感和工作效率将飙升。</p><p id="7707" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结果，我们的总测试时间从大约30分钟缩短到20分钟。对我来说，这并不真实，需要一些调查。我本以为测试时间会是15分钟。我们正在共享资源，因此在同一节点上运行更多的并行作业可能会对性能造成轻微影响。但是，我会接受10分钟的节省:-)。</p><p id="a2f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在CI/CD方面有更多的工作要做，所以请继续关注未来一些关于创建最佳CI/CD管道的新技术和方法的帖子。</p><p id="a724" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在那之前，干杯，快乐发展。</p></div></div>    
</body>
</html>