<html>
<head>
<title>Going BIG with JavaScript: Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript做大:数字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/going-big-with-javascript-numbers-71616cac8e44?source=collection_archive---------4-----------------------#2020-02-02">https://javascript.plainenglish.io/going-big-with-javascript-numbers-71616cac8e44?source=collection_archive---------4-----------------------#2020-02-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/624a10baad11bd1e2ee030eacd07c3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UC7WEr__qEkUjOD6Xk2rLg.png"/></div></div></figure><p id="02c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像所有事情一样，JavaScript也有局限性。有趣的是，有人为的限制，也有物理的限制。我将探索这些极限，并尽可能地将它们推向真正的极限。</p><p id="de01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在JavaScript中，<a class="ae kt" href="https://www.w3schools.com/js/js_numbers.asp" rel="noopener ugc nofollow" target="_blank">w3schools.com</a>将数字定义为:</p><blockquote class="ku kv kw"><p id="7788" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">与许多其他编程语言不同，JavaScript没有定义不同类型的数字，如整数、短整型、长整型、浮点型等。</p><p id="d261" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">遵循国际IEEE 754标准，JavaScript数字总是存储为双精度浮点数。</p><p id="e96a" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">这种格式以64位存储数字，其中数字(分数)存储在0至51位，指数存储在52至62位，符号存储在63位</p></blockquote><p id="9b98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这实际上意味着什么？在JavaScript中，可以存储的最大可能数是1.7976931348623157e+308，或者使用<strong class="jx io">数。MAX _ VALUE</strong></p><p id="2fcc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们试图超越这一点时，事情开始变得奇怪。我试着运行下面的代码，期望得到“无穷大”。这并没有发生。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0bbd" class="lk ll in lg b gy lm ln l lo lp">console.log(Number.MAX_VALUE+1);</span><span id="9ef2" class="lk ll in lg b gy lq ln l lo lp"><em class="kx">1.7976931348623157e+308</em></span></pre><p id="cded" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这与<a class="ae kt" href="https://www.w3schools.com/jsref/jsref_max_value.asp" rel="noopener ugc nofollow" target="_blank">文档</a>所说的“大于MAX_VALUE的数字表示为无穷大”不一致</p><p id="7323" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kx">边注:以下测试是使用谷歌Chrome控制台完成的，因此其他JS解释器可能会产生不同的结果。</em></p><p id="ae57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我找到了一个不是无穷大的最大数。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="086e" class="lk ll in lg b gy lm ln l lo lp">console.log(Number.MAX_VALUE+999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999);</span><span id="0a4a" class="lk ll in lg b gy lq ln l lo lp"><em class="kx">1.7976931348623157e+308</em></span></pre><p id="55e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们添加一个额外的“1”，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a4ca" class="lk ll in lg b gy lm ln l lo lp">console.log(Number.MAX_VALUE+999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999<strong class="lg io">1</strong>);</span><span id="6c3f" class="lk ll in lg b gy lq ln l lo lp"><em class="kx">Infinity</em></span></pre><p id="7235" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在得到无穷大。那么发生了什么？</p><p id="1505" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在来谈谈<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" rel="noopener ugc nofollow" target="_blank">号。MAX_SAFE_INTEGER </a>，其定义为:</p><blockquote class="ku kv kw"><p id="7270" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">Number.MAX_SAFE_INTEGER</code>常量代表JavaScript (2⁵ -1)中的最大安全整数。</p></blockquote><p id="606e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个实际的解释是，超过这个限制，JavaScript解释器就不再对操作负责。</p><p id="b361" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看下面的代码:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ff73" class="lk ll in lg b gy lm ln l lo lp">console.log(Number.MAX_SAFE_INTEGER);<br/><em class="kx">900719925474099</em><strong class="lg io"><em class="kx">1</em></strong></span><span id="f656" class="lk ll in lg b gy lq ln l lo lp">console.log(Number.MAX_SAFE_INTEGER<strong class="lg io">+1</strong>);<br/><em class="kx">900719925474099</em><strong class="lg io"><em class="kx">2</em></strong></span><span id="a202" class="lk ll in lg b gy lq ln l lo lp">let a = Number.MAX_SAFE_INTEGER+1;<br/>let b = Number.MAX_SAFE_INTEGER+2;<br/>console.log(a === b);<br/><em class="kx">true</em></span></pre><p id="f8de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从上面的结果我们看到，我们绝对可以在“MAX_SAFE_INTEGER”上面走，但是任何从实用的角度想做的事情都不再起作用了。当我们知道a和b不相等时，它们被认为是相等的。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="082a" class="mb ll in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">如果我们想超越MAX_SAFE_INTEGER怎么办？</h1><p id="597e" class="pw-post-body-paragraph jv jw in jx b jy my ka kb kc mz ke kf kg na ki kj kk nb km kn ko nc kq kr ks ig bi translated">JavaScript有一个原生函数叫做<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> BigInt </strong> </a>。正如它的名字所描述的，它处理大数字。激活起来也极其简单。在数字的末尾加一个“n ”,它会立即被转换。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="105f" class="lk ll in lg b gy lm ln l lo lp">const theBiggestInt = 9007199254740991n;<br/>typeof theBiggestInt;<br/><em class="kx">"bigint"</em></span></pre><p id="b378" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么为什么不一直使用“BigInt”<strong class="jx io"/>呢？你可以很容易地做“1n ”,现在它是一个BigInt，你有一个更大的数量限制。有什么问题吗？<strong class="jx io"> BigInt不能处理小数。</strong></p><p id="cc4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着，如果您从一个数字转换到一个BigInt，然后再反向转换，您可能会失去精度。还有一个兼容性问题，只有现代浏览器支持它。这不是一个真正的问题，因为它很可能只在NodeJS中需要，这是受支持的。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="3da8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在将尝试我们之前有问题的MAX_VALUE，并将结果<strong class="jx io">包装在</strong> BigInt:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4a1a" class="lk ll in lg b gy lm ln l lo lp">console.log(BigInt(Number.MAX_VALUE));<br/><em class="kx">17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955863276687817154045895351438246423432132688946418276846754670353751698604991057655128207624549009038932894407586850845513394230458323690322294816580855933212334827479782620414472316873817718091929988125040402618412485836</em><strong class="lg io"><em class="kx">8</em></strong><em class="kx">n</em></span><span id="119f" class="lk ll in lg b gy lq ln l lo lp">console.log(BigInt(Number.MAX_VALUE<strong class="lg io">+1</strong>));<br/><em class="kx">17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955863276687817154045895351438246423432132688946418276846754670353751698604991057655128207624549009038932894407586850845513394230458323690322294816580855933212334827479782620414472316873817718091929988125040402618412485836</em><strong class="lg io"><em class="kx">8</em></strong><em class="kx">n</em></span></pre><p id="641d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的例子说明了这是怎么回事。当我们增加更多的数字时。MAX_VALUE，那就干脆忽略。这两个方程得出相同的答案。为什么？我不知道，这取决于JavaScript解释器。</p><p id="a36f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在可以做的是使用BigInt使<strong class="jx io">超过</strong>数。MAX_VALUE。这一次，我们将针对MAX_VALUE的BigInt值使用增量，而不是MAX_VALUE的结果。<strong class="jx io">在下面，注意括号中的“+1n”相对于上面代码的位置。</strong></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8a4b" class="lk ll in lg b gy lm ln l lo lp">console.log(BigInt(Number.MAX_VALUE)<strong class="lg io">+1n</strong>);<br/><em class="kx">17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955863276687817154045895351438246423432132688946418276846754670353751698604991057655128207624549009038932894407586850845513394230458323690322294816580855933212334827479782620414472316873817718091929988125040402618412485836</em><strong class="lg io"><em class="kx">9</em></strong><em class="kx">n</em></span></pre><p id="ec36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们在上面看到的，我们的最终数字从“8”增加到了“9”。所以BigInt <strong class="jx io">确实如</strong>所描述的那样工作。让我们试试我们的比较:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e3d9" class="lk ll in lg b gy lm ln l lo lp">let ab = BigInt(Number.MAX_VALUE);<br/>let bb = BigInt(Number.MAX_VALUE)<strong class="lg io">+1n</strong>;<br/>console.log(ab === bb);<br/><em class="kx">false</em></span></pre><p id="ac97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，我们能够做高于这个数字的比较。MAX_VALUE限制，缺点是不能使用小数位。</p><p id="d72f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">BigInt确实有限制，但是没有任何上限的“硬限制”，甚至没有任何“软限制”。文档中没有提到它。根据其他人在StackOverflow上的经验，似乎这些限制是由JavaScript解释器和设备的内存限制决定的。当达到非常大的数字时，性能也会受到明显的影响。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="c186" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，在极少数需要的情况下，超越JavaScripts的本地数量限制是可能的。一个例子是，如果你想找到质数，因为这些不需要小数位。</p><p id="39fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然在大多数情况下你不需要使用BigInt，但是你会想要通过检查<strong class="jx io">数字来确保你没有超出本地限制。MAX_SAFE_INTEGER </strong>如果你知道你可能达到那个数字。</p></div></div>    
</body>
</html>