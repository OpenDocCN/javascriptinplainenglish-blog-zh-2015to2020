<html>
<head>
<title>Let’s spin the event loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们旋转事件循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-spin-the-event-loop-by-ashish-mishra-8ec4d1412376?source=collection_archive---------5-----------------------#2020-04-26">https://javascript.plainenglish.io/lets-spin-the-event-loop-by-ashish-mishra-8ec4d1412376?source=collection_archive---------5-----------------------#2020-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c92e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">深入探究事件循环工作的内部及其古怪之处。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/baa126667f6e97e2ba16aaeef4b9559f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_shUfxgcMhfVlwM1zBFJQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lysanderyuen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Lysander Yuen</a> on <a class="ae ks" href="https://unsplash.com/s/photos/loop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7ece" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们知道，事件循环是javascript运行时环境提供的一种机制，用于使用JS引擎处理代码块的执行。</p><p id="730d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">理解事件循环的工作方式对于优化很重要，有时对于正确的架构也很重要。</p><h1 id="415b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">用例</h1><p id="1316" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">尝试预测以下用例的输出顺序:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mo"><img src="../Images/b2cce95923ab4f48106e7f959033f264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVPDnpnk6BUVRzvqEVniTw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">output order</figcaption></figure><p id="8cc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">乍一看，输出顺序似乎令人困惑，因为承诺在setTimeout之前执行，而且两者都是异步的。</p><p id="6ce9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">似乎事件循环并没有以同样的方式对待每个异步任务。我们稍后将访问这个用例以获得详细的解释，但是让我们深入挖掘以找到这个行为背后的原因。</p><h1 id="b680" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">宏观和微观任务</h1><p id="adf5" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">事件循环有多个任务队列，一个用于<strong class="kv io"> <em class="mp">任务/宏任务</em> </strong>(术语可互换使用)，一个用于<strong class="kv io"> <em class="mp">微任务、</em> </strong>现在明显的问题是如何将任务识别为这些类型之一。</p><p id="92b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据规范<code class="fe mq mr ms mt b">parser</code>、<code class="fe mq mr ms mt b">events</code>、<code class="fe mq mr ms mt b">callbacks</code>、<code class="fe mq mr ms mt b">resource fetching</code>、<code class="fe mq mr ms mt b">DOM manipulation</code>被认为是宏任务，作为任务队列进行管理。其中as <code class="fe mq mr ms mt b">promises</code>、<code class="fe mq mr ms mt b">mutation observers</code>、<code class="fe mq mr ms mt b">intersection observers</code>被视为微任务，由微任务队列管理。</p><p id="829d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事件循环使用不同类型的队列来隔离基于类型的任务，这决定了它们的优先级和执行顺序，这就是事件循环如何进行优化。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/87b476bab2fcc00e2110b71a98de34a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Noox731-OSUBmhWvLRbgJA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">event loop (representational image)</figcaption></figure><h1 id="2fa2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">事件循环及其执行步骤</h1><p id="70b1" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了便于理解，我们来看看事件循环的大致实现。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Rough implementation of event loop</figcaption></figure><p id="d9b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事件循环旋转时采取的步骤-</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Steps of execution</figcaption></figure><ul class=""><li id="d88c" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">任务队列是为不同类型的任务创建的，运行时环境可以决定队列和它们的优先级，这就是为什么输出的顺序有时会在不同的环境中有所不同，但我们将遵循这里的规范。</li><li id="ddc9" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">为微任务维护一个队列。</li><li id="24a4" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">首先执行下一个宏任务(只有一个)。</li><li id="e733" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">之后，所有存在的微任务被执行。</li></ul><blockquote class="nj nk nl"><p id="d225" class="kt ku mp kv b kw kx jo ky kz la jr lb nm ld le lf nn lh li lj no ll lm ln lo ig bi translated">这里要注意的是，一个微任务可以触发另一个微任务被添加到队列中，并且这个过程一直持续到微任务队列被耗尽。</p></blockquote><ul class=""><li id="e717" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">执行循环的渲染部分，并按以下顺序调度事件-</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Render events orders</figcaption></figure><ul class=""><li id="9297" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">并且循环继续。</li></ul><h1 id="b10f" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">回到这个例子</h1><p id="d5d1" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在，在看到执行步骤后，您可能会认为setTimeout是一个宏任务，应该首先执行，是的，您是对的，但是调度回调本身被认为是一个任务。因此，当事件循环开始循环时，它会找到一个应该放在任务队列中的setTimeout任务，然后继续调度和执行微任务，参见步骤:</p><p id="2d75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">第1周期- </strong></p><ul class=""><li id="2971" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">setTimeout计划为一项任务。</li><li id="0aed" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">承诺按微距询问计划。</li><li id="5c74" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">调用堆栈现在是空的，微任务被执行。</li></ul><p id="d6b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">第2周期- </strong></p><ul class=""><li id="8f4f" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">执行计划的setTimeout回调。</li></ul><blockquote class="nj nk nl"><p id="882e" class="kt ku mp kv b kw kx jo ky kz la jr lb nm ld le lf nn lh li lj no ll lm ln lo ig bi translated">请记住一点，一个微任务可能会触发另一个微任务，该微任务应在同一周期内执行。<br/>所以，如果我们考虑创建&amp;将微任务调度为微任务本身，那么为什么承诺(微任务)会在调度之后被选择和执行，而不是setTimeout(宏任务)，这是有道理的。</p></blockquote><blockquote class="np"><p id="b7b7" class="nq nr in bd ns nt nu nv nw nx ny lo dk translated">现在尝试获取此用例的顺序，并对您的答案进行评论。</p></blockquote><figure class="nz oa ob oc od kh"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">This looks intimidating 😰</figcaption></figure><h1 id="323a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">更好地理解任务的重要性！</h1><blockquote class="nj nk nl"><p id="60b9" class="kt ku mp kv b kw kx jo ky kz la jr lb nm ld le lf nn lh li lj no ll lm ln lo ig bi translated">因为您的代码运行在同一个线程中，使用同一个事件循环，作为浏览器的用户界面，如果您的代码阻塞或进入一个无限循环，浏览器本身将会停止。即使是缓慢的性能，无论是由bug还是由您的代码完成的复杂工作引起的，都可能导致用户遭受缓慢的浏览器——MDN。</p></blockquote><p id="cc79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">到目前为止，我们已经知道这两种类型的任务对浏览器来说都是渲染阻塞的，所以如果你在像setTimeout这样的异步调用中执行繁重的计算/ CPU消耗任务，直到任务执行，浏览器将不再响应用户事件(这就是为什么浏览器给出的页面不响应警告会持续更长时间)，</p><p id="4a6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了克服这个问题，我们可以将任务分成多个块，这样浏览器就不会长时间阻塞用户事件。</p><p id="a2de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有其他的选择，比如<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank">网络工作者</a>就是其中之一，我不会在这里详细讨论，因为我们正在探索事件循环。但这里重要的一点是，web工作人员有自己的事件循环，称为<strong class="kv io"> <em class="mp">工作人员事件循环</em> </strong>不同于浏览器用于活动窗口及其子窗口的<strong class="kv io"> <em class="mp">窗口事件循环— </em> </strong>事件循环。</p><h2 id="d6cd" class="oe lq in bd lr of og dn lv oh oi dp lz lc oj ok mb lg ol om md lk on oo mf op bi translated"><strong class="ak"> <em class="oq">排队微询问</em> </strong></h2><p id="fa14" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated"><strong class="kv io"><em class="mp">queueMicrotask()</em></strong>API<strong class="kv io"><em class="mp"/></strong>由窗口或工作器<strong class="kv io"> <em class="mp"> </em> </strong>顾名思义提供，可用于将微任务排队，即在当前任务完成其工作后，当没有其他代码等待运行时，将执行上下文的控制权返回到事件循环中。</p><p id="606d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将微任务入队也有其他技巧，例如通过创建一个可以立即解决的承诺，但是创建和销毁承诺需要额外的时间和内存开销，而将微任务正确入队的函数可以避免这些开销。</p><p id="043b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">怎么了？</strong></p><pre class="kd ke kf kg gt or mt os ot aw ou bi"><span id="28c9" class="oe lq in mt b gy ov ow l ox oy">queueMicrotask(() =&gt; {<br/>  /* code to run in the microtask here */<br/>});</span></pre><p id="a0a0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">什么时候？<br/> </strong>它在JavaScript执行上下文的主体退出之后，但在任何事件处理程序、超时和间隔或其他回调被处理之前运行，如事件循环算法所示。</p><ul class=""><li id="df0c" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">可以使用微任务的一个场景是，如果异步任务创建是有条件的，在这种情况下，操作的顺序可以变化，那么一个示例可以更好地解释这一点。</li></ul><pre class="kd ke kf kg gt or mt os ot aw ou bi"><span id="c652" class="oe lq in mt b gy ov ow l ox oy">customElement.prototype.getData = url =&gt; {<br/> if (this.cache[url]) {<br/>    this.data = this.cache[url];<br/>    this.dispatchEvent(new Event("load"));<br/> } else {<br/>    fetch(url).then(result =&gt; result.arrayBuffer()).then(data =&gt; {<br/>      this.cache[url] = data;<br/>      this.data = data;<br/>      this.dispatchEvent(new Event("load"));<br/>    });<br/> }<br/>}</span><span id="0f6f" class="oe lq in mt b gy oz ow l ox oy">// execute<br/>element.addEventListener("load", () =&gt; console.log("Loaded data"));<br/>console.log("Fetching data...");<br/>element.getData();<br/>console.log("Data fetched");</span><span id="f33a" class="oe lq in mt b gy oz ow l ox oy">// Order when data is present in cache | // when its fetched async<br/>1. Fetching data...              | 1. Fetching data...          <br/>2. Loaded data.                  | 2. Data fetched<br/>3. Data fetched                  | 3. Loaded data</span></pre><p id="2935" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">操作和事件的顺序根据数据是否存在于缓存中而变化，为了确保顺序的一致性，我们可以使用queueMicrotask()将出现在<em class="mp"> if </em>块中的任务包装起来。</p><pre class="kd ke kf kg gt or mt os ot aw ou bi"><span id="d807" class="oe lq in mt b gy ov ow l ox oy">customElement.prototype.getData = url =&gt; {<br/> if (this.cache[url]) {<br/>  queueMicrotask(() =&gt; {<br/>  this.data = this.cache[url];<br/>    this.dispatchEvent(new Event("load"));<br/>  });<br/> } else {<br/>    fetch(url).then(result =&gt; result.arrayBuffer()).then(data =&gt; {<br/>      this.cache[url] = data;<br/>      this.data = data;<br/>      this.dispatchEvent(new Event("load"));<br/>    });<br/> }<br/>}</span></pre><blockquote class="nj nk nl"><p id="b056" class="kt ku mp kv b kw kx jo ky kz la jr lb nm ld le lf nn lh li lj no ll lm ln lo ig bi translated">这个特性是现代基于浏览器的JavaScript开发提供的专门特性，允许您调度代码在一长串等待发生的事情中跳到其他事情的前面。滥用这种能力会导致性能问题。</p></blockquote><h1 id="53f9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="f697" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我希望这篇文章能帮助你了解事件循环的工作原理及其细节，现在你理解并能更好地使用这些概念。在这里，我们还探索了<strong class="kv io">微任务</strong>，并了解了如何使用<strong class="kv io"> queueMicrotask API </strong>将<strong class="kv io">微任务</strong>排队，以及它是如何有用的。</p></div><div class="ab cl pa pb hr pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="ig ih ii ij ik"><p id="5c1a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在medium上，我试着根据我的学习和经验写一些关于web开发的文章，所以如果你想在未来读到一些令人惊奇的东西，你可以在Medium上关注我。</p><p id="40b8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">欢迎评论您对本文的想法、反馈和建议，再见！</p><h2 id="02f6" class="oe lq in bd lr of og dn lv oh oi dp lz lc oj ok mb lg ol om md lk on oo mf op bi translated">用简单英语写的JavaScript的注释</h2><p id="2d41" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的喜爱:<a class="ae ks" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kv io">AI in Plain English</strong></a>，<a class="ae ks" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kv io">UX in Plain English</strong></a>，<a class="ae ks" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kv io">Python in Plain English</strong></a><strong class="kv io"/>——谢谢，继续学习！</p><p id="b742" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ks" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">submissions @ plain English . io</strong></a><strong class="kv io"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p><h2 id="6bad" class="oe lq in bd lr of og dn lv oh oi dp lz lc oj ok mb lg ol om md lk on oo mf op bi translated">[编辑]</h2><p id="18ca" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi">(26/04/2020)</p><ul class=""><li id="a01d" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated">感谢<a class="ph pi ep" href="https://medium.com/u/bff6c3ffbea4?source=post_page-----8ec4d1412376--------------------------------" rel="noopener" target="_blank"> ARKAPRAVA GHOSH </a>指出错别字。</li><li id="2597" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated">感谢anindia Ghosh的宝贵意见。</li></ul><h2 id="a3b7" class="oe lq in bd lr of og dn lv oh oi dp lz lc oj ok mb lg ol om md lk on oo mf op bi translated"><strong class="ak">【参考文献】</strong></h2><ul class=""><li id="6bb8" class="mv mw in kv b kw mh kz mi lc pj lg pk lk pl lo na nb nc nd bi translated"><a class="ae ks" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" rel="noopener ugc nofollow" target="_blank">https://html . spec . whatwg . org/multipage/web app APIs . html # event-loops</a></li><li id="5904" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/HTML _ DOM _ API/Microtask _ guide</a></li><li id="c661" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/HTML _ DOM _ API/Microtask _ guide/In _ depth</a></li><li id="c1ce" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></li></ul></div></div>    
</body>
</html>