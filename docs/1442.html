<html>
<head>
<title>What’s the Difference Between JavaScript Primitive Values and Objects?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript原语值和对象有什么区别？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-the-difference-between-javascript-primitive-values-and-objects-d361ccd2bd67?source=collection_archive---------9-----------------------#2020-03-16">https://javascript.plainenglish.io/whats-the-difference-between-javascript-primitive-values-and-objects-d361ccd2bd67?source=collection_archive---------9-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/244d307b85525c4e4a3911c2947479af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bxjpJ406hSRJ-zjY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lmtrochezz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lina Trochez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ce47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，有两种类型的数据——原始值和对象。了解它们之间的区别是很重要的，这样我们才能正确地处理它们。</p><p id="d816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看JavaScript原始值和对象之间的区别。</p><h1 id="4058" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">有什么区别？</h1><p id="fbc2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，原始值是类型为<code class="fe me mf mg mh b">undefined</code>、<code class="fe me mf mg mh b">null</code>、<code class="fe me mf mg mh b">boolean</code>、<code class="fe me mf mg mh b">number</code>、<code class="fe me mf mg mh b">string</code>和<code class="fe me mf mg mh b">symbol</code>的实体。</p><p id="3d1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他的都是对象。</p><h2 id="0dbe" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">传递和分配</h2><p id="4e9f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">原始值被视为与对象相同。然而，它们之间也有一些不同之处。</p><p id="82c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原始值通过值传递。它们被赋值给变量，并通过复制它们的值，然后执行这些操作，传递给函数。</p><h2 id="7283" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">比较</h2><p id="306c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当它们被比较时，它们是通过价值来比较的。也就是说，比较它们的内容。</p><p id="f6af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象由不同于原始值和作为值的函数的多个属性组成。</p><p id="a009" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是通过引用传递的。所以在它们被传入之前不会复制一份。</p><p id="328c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当它们被比较时，它们的引用被比较。这意味着即使它们具有相同的内容，但被赋予不同的变量或常数，它们也不会被视为相等。</p><p id="b779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="22c2" class="mi lc iq mh b gy nc nd l ne nf">const foo = {<br/>  a: 1<br/>};<br/>const bar = {<br/>  a: 1<br/>};<br/>console.log(foo === bar);</span></pre><p id="ba2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们记录了<code class="fe me mf mg mh b">false</code>,因为它们在内存中没有引用相同的对象，即使它们有相同的内容。</p><p id="f7a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="de79" class="mi lc iq mh b gy nc nd l ne nf">const foo = {<br/>  a: 1<br/>};<br/>const bar = {<br/>  a: 1<br/>};<br/>console.log(foo === foo);</span></pre><p id="eb5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的<code class="fe me mf mg mh b">console.log</code>记录了<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">foo</code>具有与自身相同的引用。</p><p id="d4b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，如果我们将<code class="fe me mf mg mh b">foo</code>分配给<code class="fe me mf mg mh b">bar</code>，如下所示:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="8554" class="mi lc iq mh b gy nc nd l ne nf">let foo = {<br/>  a: 1<br/>};<br/>let bar = foo;<br/>console.log(foo === bar);</span></pre><p id="cf47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也从<code class="fe me mf mg mh b">console.log</code>得到<code class="fe me mf mg mh b">true</code>。</p><h2 id="54bb" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">易变性</h2><p id="3d3a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">原始值是不可变的。我们不能做任何改变他们价值观的操作。</p><p id="e5da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在严格模式下，如果我们试图设置一个字符串的<code class="fe me mf mg mh b">length</code>属性，我们会得到一个错误:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="d72b" class="mi lc iq mh b gy nc nd l ne nf">'use strict';<br/>let str = 'foo';<br/>str.length = 1;</span></pre><p id="27a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，这可以通过数组来实现:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="aabd" class="mi lc iq mh b gy nc nd l ne nf">'use strict';<br/>let arr = [1, 2, 3];<br/>arr.length = 1;</span></pre><p id="341f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使我们将<code class="fe me mf mg mh b">arr</code>数组截断为<code class="fe me mf mg mh b">[1]</code>。</p><p id="d64d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为对象，也就是数组，是可变的。默认情况下，我们可以更改它们的属性。</p><p id="6491" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以通过将单个属性描述符设置为不可写，或者使用<code class="fe me mf mg mh b">Object.freeze</code>方法来防止在对象及其原型的顶层对所有属性描述符进行更改，从而将它们的属性或整个对象设置为不可变的。</p><p id="95ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用<code class="fe me mf mg mh b">Object.freeze</code>:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="60fc" class="mi lc iq mh b gy nc nd l ne nf">let obj = {<br/>  a: 1<br/>}<br/>Object.freeze(obj);</span></pre><p id="486a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们处于严格模式时，下面的赋值会给我们一个错误:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="23e9" class="mi lc iq mh b gy nc nd l ne nf">obj.a = 2;</span></pre><p id="9d9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到错误“未捕获的类型错误:无法分配给对象“# <object>”的只读属性“a”</object></p><p id="0c73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">defineProperty</code>来添加一个不可写的属性，如下所示:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="8022" class="mi lc iq mh b gy nc nd l ne nf">'use strict';<br/>let obj = {};<br/>Object.defineProperty(obj, 'a', {<br/>  value: 1,<br/>  writable: false<br/>})<br/>obj.a = 2;</span></pre><p id="49eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到和以前一样的错误，因为我们使属性<code class="fe me mf mg mh b">a</code>不可写。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/b3e57e86433c63fbabad0af7ba4d992c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ng49lUOVs1dGwaTu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@wildlittlethingsphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Helena Lopes</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b313" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从构造函数中创建的任何东西都是对象</h1><p id="cdf8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当我们使用<code class="fe me mf mg mh b">new</code>关键字创建一个实体时，我们就在创建一个对象。这也适用于<code class="fe me mf mg mh b">Boolean</code>、<code class="fe me mf mg mh b">String</code>和<code class="fe me mf mg mh b">Number</code>构造器。</p><p id="0038" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="5832" class="mi lc iq mh b gy nc nd l ne nf">let foo = new Boolean(1);</span></pre><p id="5a10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">foo</code>是一个对象。</p><p id="07f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这同样适用于<code class="fe me mf mg mh b">new String()</code>和<code class="fe me mf mg mh b">new Number()</code>。</p><p id="dcec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将其转换回原始值，我们必须使用<code class="fe me mf mg mh b">valueOf</code>方法将其转换回原始值。</p><p id="5452" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下代码:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="e95b" class="mi lc iq mh b gy nc nd l ne nf">let foo = new Boolean(1);<br/>console.log(typeof foo);<br/>foo = foo.valueOf();<br/>console.log(typeof foo);</span></pre><p id="22c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从第一个<code class="fe me mf mg mh b">console.log</code>和第二个<code class="fe me mf mg mh b">'boolean'</code>获取<code class="fe me mf mg mh b">'object'</code>日志。</p><p id="4c79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用构造函数创建原语没有任何好处，而且会增加额外的混乱。所以我们应该只使用文字，或者当我们从一种类型的值转换到另一种类型的值时，我们使用工厂函数<code class="fe me mf mg mh b">Boolean</code>、<code class="fe me mf mg mh b">String</code>和<code class="fe me mf mg mh b">Number</code>。</p><p id="2733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用<code class="fe me mf mg mh b">Number</code>将字符串转换成数字:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="f175" class="mi lc iq mh b gy nc nd l ne nf">let foo = Number('1');<br/>console.log(typeof foo);</span></pre><p id="ce3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到从<code class="fe me mf mg mh b">console.log</code>输出的<code class="fe me mf mg mh b">'number'</code>。</p><h1 id="2fdf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d8f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">了解JavaScript中原始值和对象之间的区别很重要。</p><p id="8e1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们非常不同。原始值是不可变的，它们通过引用传递到函数中，通过它们的值进行比较，当我们给它们赋值时，会产生一个副本。</p><p id="69af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，对象是可变的，通过引用传递，通过引用进行比较，当我们把它们赋给另一个变量时，并没有复制。</p><p id="30aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了减少混淆，我们应该使用文字和工厂函数来创建原始值，因为构造函数总是创建对象。</p></div></div>    
</body>
</html>