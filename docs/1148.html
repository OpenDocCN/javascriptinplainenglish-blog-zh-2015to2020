<html>
<head>
<title>JavaScript’s Spread Operator (&amp; its Identical Twin, the Rest Parameter)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的扩展操作符(&amp;它的孪生兄弟，Rest参数)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascripts-spread-operator-and-it-s-identical-twin-the-rest-parameter-1ebcacd7fa47?source=collection_archive---------5-----------------------#2020-02-04">https://javascript.plainenglish.io/javascripts-spread-operator-and-it-s-identical-twin-the-rest-parameter-1ebcacd7fa47?source=collection_archive---------5-----------------------#2020-02-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/2323dc6afdb3e72fe1bf14cb190a4739.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/1*U9n7GdWMpi8jMR2PgSGGPg.gif"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Both the ‘Spread Operator’ and ’Rest Parameter’ look like an ellipsis, but only the latter (sort of) acts like it!</figcaption></figure><p id="a718" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“扩展操作符”是一种奇妙的<a class="ae kt" href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="noopener ugc nofollow" target="_blank">语法糖</a>:简而言之，它允许你将可迭代的元素(例如数组)在不同的上下文中‘扩展’成适当的格式(见下面的例子)。“Rest参数”看起来是一样的，但是用于<strong class="jx io">收集</strong>剩余的东西(因此是“剩余的”)到一个数组或对象中(同样，下面有更多解释)。让我们先来看看Spread的一些用途:</p><h1 id="6d05" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">将数组扩展到函数的参数中</h1><p id="f975" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因此，可以用任意数量的参数调用某些JS方法。例如，<code class="fe lx ly lz ma b">Math.min()</code>不介意你给它传递2个数字，或者200个。例如:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="0764" class="mj kv in ma b gy mk ml l mm mn">Math.min(3,2,4,2,1)  //Outputs --&gt; 1</span></pre><p id="1e14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果你试图传递给<code class="fe lx ly lz ma b">Math.min()</code>一个充满数字的数组，它将返回<code class="fe lx ly lz ma b">NaN</code>，因为它只希望被传递数字参数……展开操作符来拯救它！(下面的第1行到第4行):</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">I’ve added .push() as another example. Like Math.min() or Math.max() it accepts an arbitrary number of parameters. But if you passed arr2 to arr1.push() without using Spread, it would nest arr2 as the final element in arr1!</figcaption></figure><p id="084c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像这样使用Spread也适用于您自己定义的任何函数，例如:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/1008af01091135e25abadedd0169f91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*ZZ3aTErWkD65audkZya_Kw.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Here the values in the array numbers are being spread into the parameters x, y and z when the function <strong class="bd mr">sum</strong> is called on line 11.</figcaption></figure><h1 id="8409" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">与其他可重复项(如字符串)一起使用Spread</h1><p id="4573" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">除了数组之外，Spread还可以与其他'<a class="ae kt" href="https://javascript.info/iterable" rel="noopener ugc nofollow" target="_blank"> iterables </a>'一起使用。让我们看看字符串的例子:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/1ddb51d705ea2f38f145e9b32ee1bdf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jl77zRtxfF7NYrmeP8YWJQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">This is bit of a contrived example for this particular use of the spread operator. But if anyone can point me to something more real-world, please do!</figcaption></figure><p id="8b6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面你可以看到一个字符串可以像我们之前处理一个数组一样被处理。spread操作符给出了遍历字符串的命令，并将其字符分配给我们的<code class="fe lx ly lz ma b">print</code>函数的参数(a、b、c等),直到所有参数都被填充。上面，我选择输出字符串前8个字符的反码，结果是“drawkcab”。</p><h1 id="83e6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用Spread复制JS对象</h1><p id="e46a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">编程中一个常见的准则是，你应该<em class="mx">永远不要修改现有的数据</em>；即始终保持原始数据不变，只修改原始数据的副本(或对其执行功能)。这被视为良好的实践，因为它遵循了拥有<a class="ae kt" href="https://en.wikipedia.org/wiki/Single_source_of_truth" rel="noopener ugc nofollow" target="_blank">‘单一真实来源’</a>的原则，因此给你更多可预测、可更新和可读的代码。</p><p id="5ecd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你创建一个JS对象(如下面的<code class="fe lx ly lz ma b">originalObj</code>)然后声明<code class="fe lx ly lz ma b">copyObj</code>，给它赋值<code class="fe lx ly lz ma b">originalObj</code>(见下面的第52行)，那么你是<strong class="jx io">而不是</strong>在复制！相反，你只是做了一个<a class="ae kt" href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0" rel="noopener" target="_blank">引用</a>(也就是说，实际上给了<code class="fe lx ly lz ma b">originalObj</code>另一个名字)。因此(在下面的第53行)，当您将<code class="fe lx ly lz ma b">copyObj</code>的属性<code class="fe lx ly lz ma b">.name</code>更改为“戴夫”时，您实际上只是更改了<code class="fe lx ly lz ma b">originalObj</code>的名称属性(见顶部输出:右下方)。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi my"><img src="../Images/be00b61205b8b3406bbda4209344361a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mz0kjUVykghihSPu9pec6w.png"/></div></div></figure><div class="mb mc md me gt ab cb"><figure class="mz jo na nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><img src="../Images/b773e6c89d289e153c09d8b25537f9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*RKeqxIoLPCNs_EnnHANKsg.png"/></div></figure><figure class="mz jo nf nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><img src="../Images/ff925fffb770405c0ae25456b0058446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*JNpCJ5l8TF1nFQUMEkf4Zw.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk ng di nh ni">The spread operator will only allow you to make a ‘<strong class="bd mr">shallow’ </strong>copy of a JS object: i.e. it will copy properties that have primitive values like a string or an integer, <strong class="bd mr">but</strong> nested objects won’t be copied, just references inserted instead.</figcaption></figure></div><p id="f553" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见(左上，第55到57行)，使用spread <strong class="jx io">创建JS对象的副本将</strong>复制该对象的属性<strong class="jx io">，只要它们是</strong><a class="ae kt" href="https://codeburst.io/javascript-essentials-types-data-structures-3ac039f9877b" rel="noopener" target="_blank"><strong class="jx io"/></a><strong class="jx io"/>(即字符串、数字、布尔值、空值、未定义和符号)。但是，对象中值不是原语的任何属性，例如<em class="mx">嵌套的</em> JS对象(例如上面的<code class="fe lx ly lz ma b">specialSkills</code>)或数组(例如上面的<code class="fe lx ly lz ma b">favFoods</code>)将不会被复制。相反，将再次给出对嵌套对象/数组的引用。这就是所谓的“浅层”复制，因为它只复制一个对象的第一个<em class="mx">层</em>，而不是任何嵌套对象的内容。</p><h2 id="6522" class="mj kv in bd kw nj nk dn la nl nm dp le kg nn no li kk np nq lm ko nr ns lq nt bi translated">制作“深”拷贝，而不是“浅”拷贝</h2><p id="57ee" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">那么，该怎么办呢？当然，你可以试着只使用spread来复制没有嵌套的JS对象，但是这是相当有限的。在使用JS库React时，我使用了析构(见下文)和spread操作符的组合来确保我使用的是“深层”副本:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nu"><img src="../Images/de9b27e6793e0223e4d0f9c4f7c07912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HL-PRv50IHMHBcPhXpWUg.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Using destructuring (line 72) in conjunction with the spread operator to ensure deep copies are being made</figcaption></figure><p id="c535" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的第72行，这种“析构”语法允许您从JS对象(这里是<code class="fe lx ly lz ma b">originalObj</code>)中提取属性，将它们中的每一个都声明为与其“键”同名的变量(例如name、home等)，并用该属性的“值”(例如“Ross”)初始化新变量。换句话说，这和做:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="f4ce" class="mj kv in ma b gy mk ml l mm mn">let name = originalObj.name</span></pre><p id="1cb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">…针对<code class="fe lx ly lz ma b">orignalObj</code>的每个属性。<em class="mx">但是</em>仅此并不能解决我们的浅抄问题！你会注意到(上面的第72行),我使用了Spread来同时复制嵌套的对象。如果，相反，我刚刚做了:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="3e03" class="mj kv in ma b gy mk ml l mm mn">let { name, home, specialSkills, favFoods } = originalObj</span></pre><p id="f070" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">…那么特殊技能和喜爱的食物仍然只是参考。<strong class="jx io">当然</strong>，如果你在你的嵌套对象中有额外的嵌套对象，那么你必须用同样的方式处理它。对于更复杂的JS对象，这可能会变得混乱！</p><p id="b0d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个解决方案是使用一个名为immutability-helper的JS库。如何做、在哪里做以及为什么做在这篇文章中有概述:“<a class="ae kt" href="https://www.codementor.io/@ramnmiklus/deep-copying-an-object-in-javascript-mdlj2c318" rel="noopener ugc nofollow" target="_blank">用JavaScript </a>深度复制一个对象”。</p><h2 id="a725" class="mj kv in bd kw nj nk dn la nl nm dp le kg nn no li kk np nq lm ko nr ns lq nt bi translated">将数组/对象相互复制</h2><p id="78dc" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">记住上面列出的嵌套限制，Spread可以用来非常整齐地将数组或对象组合在一起，例如:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nv"><img src="../Images/0c1c446429281f6c33b5558f4d3f4a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fenNP7YMXsn1anbVynSN-A.png"/></div></div></figure><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nv"><img src="../Images/0096a3e86b2630dfb2e32e7a2e8244b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtjncvCdZV5QIXxCd6lL-g.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Console output</figcaption></figure><p id="a78a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，当应用于JS对象时，同样的方法允许你复制对象<em class="mx">和</em>同时改变那个副本<em class="mx">的单独属性</em>:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nw"><img src="../Images/1f7e7175f0d50e8cf95002f92e9b3fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3scann7UdKPd_zcUT0U1dQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Line 49: (shallow) copying an object while changing a specific property of the copy (name) at the same time</figcaption></figure><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nx"><img src="../Images/f826804cde0b3b9571fc7bc5111562b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dn5E37V-DTtyg2PB73v0A.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Output from the above</figcaption></figure><p id="5101" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">…我相信你会同意，这很酷。这种技术在JS <a class="ae kt" href="https://redux.js.org/recipes/using-object-spread-operator/" rel="noopener ugc nofollow" target="_blank"> Redux库</a>中被大量使用，以允许你快速复制你的“状态”并添加一些更改；抱歉，如果这对你来说毫无意义，但我不想在这里谈这个！</p><h1 id="0fc7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">其余参数</h1><p id="9b99" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因此，简而言之,“Rest参数”为您收集多余的东西，并将它们放入一个数组(或对象)中。例如，这可以用在函数的括号中，允许你传递任意数量的参数(是的，非常像<code class="fe lx ly lz ma b">Math.min()</code>允许的):</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/bb1263696ed0fc01627a75ded2d9d081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C0d5v62pmjMLHGuBIudbyQ.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Thanks to the Rest parameter this function, add(), can be passed as many numerical arguments as you like.</figcaption></figure><p id="7c27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中,<a class="ae kt" href="https://www.w3schools.com/js/js_loop_for.asp" rel="noopener ugc nofollow" target="_blank"> for/of循环</a>用于遍历<strong class="jx io">数组中的每个元素，数组是Rest参数从传入的参数中为我们生成的</strong>。我在第2行放了一个console.log()来显示正在发生的事情:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nz"><img src="../Images/bee9505d0f1f2566bc5b7f75276fefa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qXnMjCjBCIUyFsxDe3egA.png"/></div></div></figure><h2 id="0eba" class="mj kv in bd kw nj nk dn la nl nm dp le kg nn no li kk np nq lm ko nr ns lq nt bi translated">收集遗留的论点</h2><p id="49dd" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">同样的，<em class="mx">只要你把你的Rest参数放在最后一个参数位置</em>(如下图)，那么它会把任何没有被赋予具体参数的实参收集到一个数组中(下面我称之为<code class="fe lx ly lz ma b">theRest</code>):</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oa"><img src="../Images/c63ef77b7e8469c53141d6dde234d75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6rSjTRX3QoeHw_LIqd0xxw.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">The call of leftovers() on line 31 will have 2 and 3 being assigned to parameters a &amp; b respectively. The third and fourth arguments passed to leftover() will therefore be collected by our Rest Parameter (…theRest).</figcaption></figure><h1 id="7aef" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在析构JS对象时使用Rest</h1><p id="159c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">尽管我们一直将这个工具称为“Rest <em class="mx">参数</em>，但是当从一个JS对象中收集任何额外的<em class="mx">属性</em>时，它可以在函数参数的内部和外部使用。例如:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ob"><img src="../Images/4bab7f44836c0bcf7c7693edea1b112c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48KVwPu5xeDzEoVhpQCNzg.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">Destructuring some properties of an object explicitly , e.g. name and home (line 17), while saving the rest into a new object (everythingElse):</figcaption></figure><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oc"><img src="../Images/95216e27d58645c4639340d237081348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO_fV5PBEWFDIHR8MVhNnw.png"/></div></div></figure><p id="0b24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">无论如何，我希望你能学到一些新的东西！非常欢迎任何评论和指正！</p></div></div>    
</body>
</html>