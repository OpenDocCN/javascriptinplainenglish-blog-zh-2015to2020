<html>
<head>
<title>Node.js for PHP developers: 5 must-know practical aspects with code examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向PHP开发人员的Node.js:包含代码示例的5个必须了解的实用方面</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-for-php-developers-4084aa3ed723?source=collection_archive---------1-----------------------#2020-12-26">https://javascript.plainenglish.io/node-js-for-php-developers-4084aa3ed723?source=collection_archive---------1-----------------------#2020-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/073954a8346f4aa2fec3b5c1c68d1660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fidgGXFi0sX7VSvIIGt8NA.jpeg"/></div></div></figure><p id="5646" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然Node.js的受欢迎程度正在上升，但是PHP的吸引力却在下降,( T2)。在这种背景下，这篇文章将详细阐述PHP开发人员使用Node.js的5个必须知道的实用方面。这些将是通常没有人谈论或写的事情，是时候开始了。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/248caffe78a9fd178508c498dd4c4041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoWmHdZWDK6otzhGuneDLA.jpeg"/></div></div></figure><h1 id="12a7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">面向PHP开发人员的Node.js(不是Node.js vs PHP)</h1><p id="f17c" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这篇文章列出了作为PHP开发人员必须知道并学会有效使用Node.js的一些事情。相反，这个帖子不是Node.js vs PHP写上去的抨击PHP的地方。</p><blockquote class="me mf mg"><p id="e6c6" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">两种语言我都用过。我早在2016年就开始写很多Node.js应用了。</p></blockquote><p id="7517" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我开始的时候，我遇到了一些困难，因为在那之前我已经在工作中使用了7年多的PHP。在2012年底发布了一本书，为PHP开发人员讲述了<a class="ae kw" href="https://www.oreilly.com/library/view/nodejs-for-php/9781449333775/" rel="noopener ugc nofollow" target="_blank"> Node.js。</a></p><p id="381e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇博客文章不会谈论PHP或Node.js是什么，你可以在其他<a class="ae kw" href="https://www.freecodecamp.org/news/what-exactly-is-node-js-ae36e97449f5/" rel="noopener ugc nofollow" target="_blank">文章</a>中读到它。关于<a class="ae kw" href="https://blog.cloudboost.io/why-is-node-called-a-non-blocking-i-o-model-eb639063bc14" rel="noopener ugc nofollow" target="_blank">非阻塞I/O </a>或<a class="ae kw" href="https://blog.logrocket.com/a-complete-guide-to-the-node-js-event-loop/" rel="noopener ugc nofollow" target="_blank">事件循环</a>，我也不再赘述。尽管如此，在讨论编写好的Node.js代码的实际问题时，还是会涉及到其中的一些内容。</p><h1 id="4da5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">面向PHP开发人员的Node.js实用版</h1><p id="0cae" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">PHP自1995年以来一直存在，据报道，W3tech监测的网站中有<a class="ae kw" href="https://w3techs.com/technologies/history_overview/programming_language/ms/q" rel="noopener ugc nofollow" target="_blank"> 79.1 % </a>仍在使用PHP(我真的不能说它是整个互联网)。所以你很有可能使用过PHP或者部署过用PHP编写的东西。例如随着<a class="ae kw" href="https://w3techs.com/technologies/details/cm-wordpress" rel="noopener ugc nofollow" target="_blank">趋势的增长</a>:</p><blockquote class="me mf mg"><p id="6774" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">据我们所知，63.7%的网站使用WordPress的内容管理系统。这是W3Tech监测的所有网站的39.0%。</p></blockquote><p id="db2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Node.js是2009年发布的。像Linked In和PayPal这样的主要科技公司从2011年<a class="ae kw" href="https://engineering.linkedin.com/42/and-running-nodejs-tech-talk-tom-hughes-croucher" rel="noopener ugc nofollow" target="_blank"/>到2013年<a class="ae kw" href="https://medium.com/paypal-engineering/node-js-at-paypal-4e2d1d08ce4f" rel="noopener"/>开始采用它，因为各种原因，比如<a class="ae kw" href="https://geshan.com.np/blog/2020/11/nodejs-microservices/" rel="noopener ugc nofollow" target="_blank">微服务</a>。根据2020年<a class="ae kw" href="https://insights.stackoverflow.com/survey/2020#technology-other-frameworks-libraries-and-tools" rel="noopener ugc nofollow" target="_blank">的栈溢出开发者调查</a>:</p><blockquote class="me mf mg"><p id="df1b" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">Node.js连续第二年位居榜首，因为有一半的受访者使用它。</p></blockquote><p id="a0f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Node.js在过去<a class="ae kw" href="https://trends.google.com/trends/explore?date=2015-11-12%202020-11-13&amp;q=%2Fm%2F0bbxf89" rel="noopener ugc nofollow" target="_blank"> 5年</a>越来越受欢迎已经不是什么秘密了。</p><p id="4e54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，作为一名PHP开发人员，这也是成为一名优秀的Node.js软件工程师必须知道的5件实用的事情。对于PHP开发人员来说，Node.js在某种意义上是相似的，但在其他一些方面也有所不同，如下所述:</p><h1 id="0e8b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.Node.js代码执行是异步和非顺序的</h1><p id="2826" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这是一种欺骗许多PHP开发人员的行为。在PHP中，代码按顺序运行，首先是第1行，然后是第2行，依此类推。在JavaScript中，尤其是在Node.js中，情况可能并非如此。你可以很好地利用承诺和回电来隐藏事情。JavaScript是基于事件的，你的代码响应事件。</p><p id="a3e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个修改后的代码示例，其中的解释来自我的开源货币API回购协议:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Async code in Node.js an example</figcaption></figure><p id="3101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你仔细看，第三行那个看起来很无辜的<code class="fe mr ms mt mu b">db.query</code>已经被推到了背景中。因此它将如下执行:</p><ol class=""><li id="7dfd" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">获取费率</li><li id="1ea6" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">在后台运行插入查询</li><li id="1665" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">当插入运行时，函数已经返回了速率</li><li id="9275" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">如果插入查询中有问题，它会记录在catch中</li></ol><p id="a0ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在PHP中，没有现成的方法可以做这样的事情。这是第一件难倒PHP开发者的事情。这使得PHP开发人员更难理解Node.js。这种异步代码执行行为还使得在Node.js中出现错误时更难找到正确的堆栈跟踪。</p><p id="7658" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说，2020年你可以轻松使用<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank"> async-await </a>。尽管这是承诺的语法糖，但它确实使异步编程容易得多。</p><p id="7202" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我在2016年左右开始进入Node 4/6时代时，有回调和<a class="ae kw" href="https://nodejs.dev/learn/understanding-javascript-promises/" rel="noopener ugc nofollow" target="_blank">承诺</a>，这完全是一场不同的球赛。尽管如此，还是要注意什么时候不要使用async-await(如上所述),而只使用承诺，然后捕捉。不过，在这个过程中不要纠结于<a class="ae kw" href="https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513" rel="noopener">承诺地狱</a>。承诺地狱就像是<a class="ae kw" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>的下一个迭代。</p><blockquote class="me mf mg"><p id="d9b5" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq"> Pro提示:要了解哪些ES6特性可以与哪个版本的Node.js配合使用，请查看</em><a class="ae kw" href="https://node.green/" rel="noopener ugc nofollow" target="_blank"><em class="iq">node . green</em></a><em class="iq">。</em></p></blockquote><p id="85a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个专业建议:</p><blockquote class="me mf mg"><p id="c3df" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq">偶数Node.js版本有</em><a class="ae kw" href="https://nodejs.org/en/about/releases/" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">，奇数则没有。因此，在生产中使用节点14或16，而不是13或15。</em></p></blockquote><p id="26b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">深入一点非顺序执行，承诺和它所拥有的力量在这里扮演着重要的角色。一般来说，Node.js和JavaScript的并发处理能力很强。</p><h2 id="d05c" class="nj lc iq bd ld nk nl dn lh nm nn dp ll kj no np lp kn nq nr lt kr ns nt lx nu bi translated">Node.js承诺可能性</h2><p id="90fb" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">承诺是异步的，你可以同时运行它们。有很多方法可以做到。你可以和3个承诺赛跑，从最快的一个得到结果。你甚至可以做<code class="fe mr ms mt mu b">promise.all</code>如果一个承诺被拒绝，它会停止整个操作。请阅读这篇<a class="ae kw" href="https://sung.codes/blog/2019/05/18/promise-race-vs-promise-any-and-promise-all-vs-promise-allsettled/" rel="noopener ugc nofollow" target="_blank">大对比</a>中关于<code class="fe mr ms mt mu b">Promise.race</code>、<code class="fe mr ms mt mu b">promise.all</code>和<code class="fe mr ms mt mu b">promise.any</code>的更多内容。</p><p id="0bd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，您可以尝试其他NPM库来<a class="ae kw" href="https://github.com/sindresorhus/p-limit" rel="noopener ugc nofollow" target="_blank">限制</a>承诺并发，甚至<a class="ae kw" href="https://github.com/sindresorhus/p-filter" rel="noopener ugc nofollow" target="_blank">通过承诺并发来过滤</a>。你可以用<a class="ae kw" href="https://reactphp.org/" rel="noopener ugc nofollow" target="_blank">react PPH</a>做一些。但是原生PHP里没有，甚至<a class="ae kw" href="https://stitcher.io/blog/new-in-php-8" rel="noopener ugc nofollow" target="_blank"> PHP 8 </a>里也没有。对于PHP开发人员来说，这是Node.js中的新事物。</p><p id="55e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续下一点，进程不需要像PHP一样死在Node.js中。</p><h1 id="c78e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.与PHP不同，Node.js进程是长期运行的</h1><p id="3411" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">PHP注定要消亡并不是说它将来不会被使用。从某种意义上说，所有PHP进程都必须死亡。PHP并不是真正为长期运行的任务/过程而设计的。</p><p id="a603" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在PHP中，当一个新的HTTP请求进来时，进程开始，在发送回响应后，进程被终止。这就是PHP的一般工作方式。这就产生了对FPM T4和其他服务器的需求。你可以说PHP在20多年前就被设计成无服务器的。我让你决定。</p><p id="b532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Node.js是一个长期运行的进程。这使您能够在请求之间共享信息，因为同一个服务器/进程正在处理多个请求。对于一个长时间运行的进程，你可以很容易地利用像内存上的内存化、数据库的连接池等等。它提供了其他可能性，比如计算该进程上并发请求的数量。</p><h2 id="e482" class="nj lc iq bd ld nk nl dn lh nm nn dp ll kj no np lp kn nq nr lt kr ns nt lx nu bi translated">记忆示例</h2><p id="4802" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">如果你不知道<a class="ae kw" href="https://lispcast.com/what-is-memoization/" rel="noopener ugc nofollow" target="_blank">记忆</a>。</p><blockquote class="me mf mg"><p id="96e5" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq">记忆化是缓存另一个函数的高阶函数。它能把一些慢功能变成快功能。它会在第一次调用函数后将结果保存到缓存中，因此如果您使用相同的参数再次调用该函数，它会在缓存中找到它。</em></p></blockquote><p id="e48f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以在Node.js中使用，但不能在PHP中使用。PHP中可能有一些变通方法，比如将函数返回值保存在Redis中。</p><p id="4277" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个在高速公路上使用<a class="ae kw" href="https://github.com/sindresorhus/p-memoize" rel="noopener ugc nofollow" target="_blank"> p-memoize </a>进行记忆的代码示例:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Memoize on the route level with Node.js, it saves the round trip to the DB so it is much faster.</figcaption></figure><p id="8077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样做的明显优势是减少了数据存储区的负载。在1分钟内，它将对相同的参数作出相同的响应。函数<code class="fe mr ms mt mu b">products.getMultiple</code>的输出在内存中缓存一分钟。这使得响应非常快。</p><h2 id="3fc1" class="nj lc iq bd ld nk nl dn lh nm nn dp ll kj no np lp kn nq nr lt kr ns nt lx nu bi translated">MySQL的连接池示例</h2><p id="430e" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">另一件不可能的事情是连接池，因为PHP中有一个垂死的进程。根据<a class="ae kw" href="https://en.wikipedia.org/wiki/Connection_pool" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="me mf mg"><p id="f75a" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq">在软件工程中，连接池是数据库连接的缓存，以便在将来需要数据库请求时可以重用这些连接。连接池用于增强在数据库上执行命令的性能。</em></p></blockquote><p id="5361" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在一个池中将有5个连接，如果您想对数据库运行5个查询，可以同时进行。这节省了连接数据库和运行查询的时间。这在Node.js中很容易做到，但在PHP中却不容易做到。</p><blockquote class="me mf mg"><p id="af22" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq">注意可用连接的数量，并保持连接池的最佳大小。</em></p></blockquote><p id="0630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您正在使用Kubernetes，并且您的应用程序有5个pods，连接池大小为2。这意味着即使没有正在执行的查询，您的数据库也将始终有10个打开的连接。</p><p id="da44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MySQL数据库与<a class="ae kw" href="https://github.com/mysqljs/mysql#pooling-connections" rel="noopener ugc nofollow" target="_blank"> MySQL </a> npm模块的连接池示例时间:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Connection Pool example in Node.js with MySQL connection pooling.</figcaption></figure><p id="242b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码将使用连接池中的5个MySQL连接并行运行相同的查询5次。我希望我能在开箱即用的PHP中完成这项工作。</p><p id="7c35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以我的经验来看，<a class="ae kw" href="https://geshan.com.np/blog/2020/11/nodejs-mysql-tutorial/" rel="noopener ugc nofollow" target="_blank"> Node.js与MySQL </a>配合得非常好。如果您想用Mongo DB尝试连接池，这里有一个<a class="ae kw" href="https://www.compose.com/articles/connection-pooling-with-mongodb/" rel="noopener ugc nofollow" target="_blank"> Mongo </a>的例子。</p><blockquote class="me mf mg"><p id="f2ad" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">作为一名开发人员，对于一个长时间运行的过程，你需要更加小心内存泄漏并做好日常工作。</p></blockquote><p id="1fa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是Node.js for PHP开发人员需要改变代码执行方式的地方。另一方面，对于PHP开发人员来说，这是Node.js的一大优势。</p><h1 id="7dfb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.Node.js中的调试比PHP容易</h1><p id="f628" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">对于任何编程语言来说，逐行代码调试都是开发人员体验的重要部分。为了调试PHP代码，您可以使用类似于<a class="ae kw" href="https://xdebug.org/" rel="noopener ugc nofollow" target="_blank"> X-Debug </a>的附加组件和一些IDE设置。</p><p id="d9f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">退一步说，X-Debug的设置很有挑战性。你必须<a class="ae kw" href="https://xdebug.org/docs/install" rel="noopener ugc nofollow" target="_blank">安装</a>它，启用扩展。之后，用类似<a class="ae kw" href="https://www.jetbrains.com/help/phpstorm/configuring-xdebug.html" rel="noopener ugc nofollow" target="_blank">PHP form</a>的IDE对其进行适当配置。</p><blockquote class="me mf mg"><p id="3366" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq">基本上，简单是让X-debug工作的最后一件事。除非用Docker容器很好地配置了它，并且IDE设置也很容易加载。</em></p></blockquote><p id="c72e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，根据我的经验，与PHP和X-debug相比，运行node <a class="ae kw" href="https://nodejs.org/api/debugger.html" rel="noopener ugc nofollow" target="_blank">本机调试器</a>甚至<a class="ae kw" href="https://geshan.com.np/blog/2019/01/getting-started-with-debugging-nodejs-applications-with-ndb/" rel="noopener ugc nofollow" target="_blank"> ndb </a>要容易得多。有了VS代码的使用，<a class="ae kw" href="https://itnext.io/the-absolute-easiest-way-to-debug-node-js-with-vscode-2e02ef5b1bad" rel="noopener ugc nofollow" target="_blank">调试Node.js应用</a>是如此的容易，连穴居人都能做到。</p><blockquote class="me mf mg"><p id="67d5" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq">打开首选项&gt;设置，在搜索框中输入“节点调试”。在Extensions选项卡下，应该有一个名为“Node debug”的扩展。从这里，单击第一个框:调试&gt;节点:自动连接，并将下拉框设置为“开”。你现在差不多可以走了。是的，真的很简单。</em></p></blockquote><p id="9638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后用<code class="fe mr ms mt mu b">index.js</code>和终端类型<code class="fe mr ms mt mu b">node --inspect index.js</code>在VS代码上设置一些断点。</p><p id="512c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嘣！您的逐步Node.js调试器在VS代码编辑器上运行良好，无需太多努力。与PHP的一个很好的区别是，不需要安装一个不同的扩展，启用它，并配置它来调试程序。不需要安装额外的扩展是Node.js给PHP开发人员带来的好处。</p><p id="3360" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一点也是关于更好的开发者体验，同时升级该语言的多个主要版本。</p><h1 id="d591" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4.Node.js的主要版本升级在PHP上是无缝的</h1><p id="696a" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">甚至在Node.js中跳转多个主要版本都是无缝体验。根据项目的规模和复杂程度，从PHP 5.6升级到PHP 7.0需要一周到一个月的时间。</p><p id="40ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以我个人的经验来说，我过去曾经将Node.js微服务从0.12版本升级到4版本。最近，我将一个应用程序从Node.js 10升级到了14。我的Node.js主要版本的所有升级都很容易。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/f71b69eca218f7eb4583ad31ee5f3eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICkP-Ee2VZkBs0LL25p_ig.jpeg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Example Pull request of Node 10 to 14 upgrade with Docker. It was super smooth.</figcaption></figure><p id="2754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些小的package.json修改是我遇到的唯一的小问题。部署后，很少出现与代码兼容性相关的问题。作为一个额外的奖励，升级主要版本的性能通常会更好。</p><p id="4ccc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，升级PHP并不容易。应用程序从PHP 5.4到5.6的小版本升级并不麻烦。但是，对于一个相对较大的应用程序来说，从PHP 5.6升级到7.2是一件痛苦的事情。花了很长时间，需要多次composer.json修改。测试它也是一项艰巨的任务。PHP主要版本升级的好的一面当然是性能的提升。</p><blockquote class="me mf mg"><p id="fc67" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">这里需要注意的是，我使用的PHP应用程序比Node.js应用程序要老。你的经历肯定会和我的不同。</p></blockquote><h1 id="8d6d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5.与PHP相比，编写Node.js应用程序更容易</h1><p id="70be" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Docker的受欢迎程度在过去的五年里稳步上升<a class="ae kw" href="https://trends.google.com/trends/explore?date=2015-02-11%202020-11-14&amp;q=%2Fm%2F0wkcjgj" rel="noopener ugc nofollow" target="_blank"/>。自从发布以来,<a class="ae kw" href="https://geshan.com.np/blog/2018/11/4-ways-docker-changed-the-way-software-engineers-work-in-past-half-decade/" rel="noopener ugc nofollow" target="_blank">改变了我们软件工程师的工作方式。你也应该使用</a><a class="ae kw" href="https://geshan.com.np/blog/2018/10/why-use-docker-3-reasons-from-a-development-perspective/" rel="noopener ugc nofollow" target="_blank"> Docker进行本地开发</a>。</p><p id="0d05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这一点，根据组件的布局和应用程序的复杂性，编写PHP应用程序的Dockerizing可能是一项困难的任务。相反，对Node.js应用程序进行dockerizing的工作要少一些，过程也很容易。</p><p id="470d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个使用Apache的PHP Laravel应用程序的<a class="ae kw" href="https://github.com/geshan/laravel6-on-google-cloud-run/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>示例。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Example PHP docker file for Laravel with Apache and multi-stage build</figcaption></figure><p id="3dda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Laravel的这个Docker映像的好处是PHP与apache捆绑在同一个映像中。与将PHP和Apache分成两个docker映像相比，这是否是一个更好的方法值得商榷。</p><p id="f708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，请注意上面docker图像中的<a class="ae kw" href="https://geshan.com.np/blog/2019/11/how-to-use-docker-multi-stage-build/" rel="noopener ugc nofollow" target="_blank">多级docker构建</a>。Composer安装在不同的映像中完成，输出被复制到主映像中。如果我们在不同的docker图像中使用PHP-FPM和Nginx，情况会更复杂。需要管理两个不同的docker映像。</p><p id="e278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在该看看Node.js <a class="ae kw" href="https://github.com/geshan/currency-api/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>了。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk">Example Node.js docker file with a multi-stage build</figcaption></figure><p id="d3f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于Node.js有一个内置的web服务器，docker文件要干净得多。</p><blockquote class="me mf mg"><p id="47e0" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated"><em class="iq">当您安装node时，npm与它捆绑在一起。这消除了在docker构建的不同阶段安装软件包的需要。</em></p></blockquote><p id="ee72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的docker文件中，多级docker构建用于分离生产和开发docker映像。对于PHP开发人员来说，在Node.js中捆绑包管理器(npm)和将web服务器作为语言/运行时的一部分是不同的。如果您对一步一步编写Node.js应用程序更感兴趣，请遵循本<a class="ae kw" href="https://geshan.com.np/blog/2020/11/nodejs-with-docker/" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><p id="0c75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的主要区别是Node.js是一种内置web服务器的运行时/语言。这通常会更容易，因为不需要在等式中混合Apache或Nginx。</p><h1 id="d178" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c60a" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">当PHP开发人员使用Node.js时，要想充分利用Node.js的强大功能，确实需要稍微改变一下思路。Node.js不是银弹。它有缺点，需要适应不同的代码执行方式。</p><blockquote class="me mf mg"><p id="015b" class="jy jz mh ka b kb kc kd ke kf kg kh ki mi kk kl km mj ko kp kq mk ks kt ku kv ij bi translated">当然，对于PHP开发人员来说，使用Node.js有一些好处，比如异步编程和并发性。其他优势源于Node.js流程的长期运行。</p></blockquote><p id="f491" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章能帮助你从Node.js中获得更多，即使你是一个有经验的PHP开发人员。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="3eac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mh">最初发表于</em><a class="ae kw" href="https://geshan.com.np/blog/2020/11/nodejs-for-php-developers/" rel="noopener ugc nofollow" target="_blank">T5【https://geshan.com.np】</a><em class="mh">。</em></p></div></div>    
</body>
</html>