<html>
<head>
<title>Understanding the Difference Between Reference and Value in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中引用和值的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-the-difference-between-reference-and-value-in-javascript-21c0a6bac7a9?source=collection_archive---------7-----------------------#2020-05-26">https://javascript.plainenglish.io/understanding-the-difference-between-reference-and-value-in-javascript-21c0a6bac7a9?source=collection_archive---------7-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec9d86b41663af308fd18358f3507b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z3PGL5Yl2zJSDQTk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@codytdavis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">davisco</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fb7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">"对象通过引用传递，而不是通过值传递."</p><p id="f77c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你以前听过这句话，但却很难理解它的意思吗？这是一个经常导致新开发人员在第一次学习JavaScript时犯错误的概念。</p><p id="b5d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过几个例子来更好地理解变量是如何被处理的，以及“引用”和“值”之间的区别。</p><h1 id="444e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">传递原语</h1><p id="29fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript中的原始数据类型类似于<code class="fe me mf mg mh b">number</code>、<code class="fe me mf mg mh b">string</code>、<code class="fe me mf mg mh b">boolean</code>或<code class="fe me mf mg mh b">undefined</code>。还有其他原语，但这些是最常见的。</p><p id="ac9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">原语通过值</strong>传递。为了理解这意味着什么，让我们看一个简单的例子:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6640" class="mq lc iq mh b gy mr ms l mt mu">const myNumber = 10;</span><span id="582c" class="mq lc iq mh b gy mv ms l mt mu">const addOne = x =&gt; x + 1;</span><span id="274e" class="mq lc iq mh b gy mv ms l mt mu">const anotherNumber = addOne(myNumber);</span><span id="4f78" class="mq lc iq mh b gy mv ms l mt mu">console.log(myNumber);<br/>console.log(anotherNumber);</span></pre><p id="ae6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们有一个值为<code class="fe me mf mg mh b">10</code>的变量<code class="fe me mf mg mh b">myNumber</code>。我们有一个函数<code class="fe me mf mg mh b">addOne</code>，它接受一个参数并返回这个参数加上<code class="fe me mf mg mh b">1</code>。然后，我们使用<code class="fe me mf mg mh b">myNumber</code>变量作为参数调用<code class="fe me mf mg mh b">addOne</code>函数，并将结果保存到另一个名为<code class="fe me mf mg mh b">anotherNumber</code>的变量。最后，我们将两个变量的值记录到控制台。</p><p id="023d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，问题是:记录了什么？</p><p id="190c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你回答了<code class="fe me mf mg mh b">10</code>和<code class="fe me mf mg mh b">11</code>，你就答对了。因为数字是通过值传递的，<code class="fe me mf mg mh b">myNumber</code>的值被传递给函数，但是当数字增加时，<code class="fe me mf mg mh b">myNumber</code>变量不受影响。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="338e" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">比较原语</h1><p id="0977" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">所以现在我们知道原语是通过值传递的。但是当他们被比较的时候呢？为了回答这个问题，我们来看另一个例子:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3d62" class="mq lc iq mh b gy mr ms l mt mu">const x = 5;<br/>const y = 5;</span><span id="e056" class="mq lc iq mh b gy mv ms l mt mu">console.log(x === y);</span></pre><p id="0f65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个变量，<code class="fe me mf mg mh b">x</code>和<code class="fe me mf mg mh b">y</code>，它们的值都是<code class="fe me mf mg mh b">5</code>。当我们在控制台记录一个严格相等的检查时，我们得到了什么？</p><p id="43f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你回答了<code class="fe me mf mg mh b">true</code>，你就答对了。这是因为<strong class="kf ir">图元也通过值</strong>进行比较，并且<code class="fe me mf mg mh b">5</code>等于<code class="fe me mf mg mh b">5</code>。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="be36" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">传递物体</h1><p id="8190" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">那么，JavaScript中非原语的数据类型呢？例如，<code class="fe me mf mg mh b">objects</code>不是原语，<code class="fe me mf mg mh b">arrays</code>也不是(它们实际上只是对象，秘密地)。</p><p id="4e37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">对象通过引用传递</strong>。为了理解这意味着什么，让我们看一个简单的例子:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="94aa" class="mq lc iq mh b gy mr ms l mt mu">const someNumbers = [1, 2, 3];</span><span id="1d22" class="mq lc iq mh b gy mv ms l mt mu">const addNumberToArray = arr =&gt; {<br/>  arr.push(100);<br/>  return arr;<br/>}</span><span id="766c" class="mq lc iq mh b gy mv ms l mt mu">const otherNumbers = addNumberToArray(someNumbers);</span><span id="7598" class="mq lc iq mh b gy mv ms l mt mu">console.log(someNumbers);<br/>console.log(otherNumbers);</span></pre><p id="1264" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们有一个变量<code class="fe me mf mg mh b">someNumbers</code>，它是一个包含三个元素的数组。我们有一个函数<code class="fe me mf mg mh b">addNumberToArray</code>，它接受一个参数(一个数组)，将值<code class="fe me mf mg mh b">100</code>推入数组，然后返回数组。然后我们使用<code class="fe me mf mg mh b">someNumbers</code>变量作为参数调用<code class="fe me mf mg mh b">addNumberToArray</code>函数，并将结果保存到另一个名为<code class="fe me mf mg mh b">otherNumbers</code>的变量中。最后，我们将两个变量的值记录到控制台。</p><p id="fc1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，问题是:记录了什么？</p><p id="742c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你回答了<code class="fe me mf mg mh b">[1, 2, 3, 100]</code>和<code class="fe me mf mg mh b">[1, 2, 3, 100]</code>，你就答对了。</p><p id="34df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦不！我们无意中修改了传递给函数的输入数组！</p><p id="4066" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为对象是通过引用传递的，所以对<code class="fe me mf mg mh b">someNumbers</code>的引用被传递给函数。因此，当值<code class="fe me mf mg mh b">100</code>被推送到数组时，该值也被推送到<code class="fe me mf mg mh b">someNumbers</code>表示的同一个数组中。</p><p id="ea04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想确保不在这样的函数中修改原始数组，那么有必要使用<code class="fe me mf mg mh b">concat</code>方法或ES6 <code class="fe me mf mg mh b">spread</code>操作符将值<code class="fe me mf mg mh b">100</code>推入输入数组的副本中。例如:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8ef6" class="mq lc iq mh b gy mr ms l mt mu">const someNumbers = [1, 2, 3];</span><span id="eb0b" class="mq lc iq mh b gy mv ms l mt mu">const addNumberToArray = arr =&gt; [...arr, 100];</span><span id="0d06" class="mq lc iq mh b gy mv ms l mt mu">const otherNumbers = addNumberToArray(someNumbers);</span><span id="82f3" class="mq lc iq mh b gy mv ms l mt mu">console.log(someNumbers);<br/>console.log(otherNumbers);</span></pre><p id="36fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们将这两个变量记录到控制台时，我们将看到<code class="fe me mf mg mh b">[1, 2, 3]</code>和<code class="fe me mf mg mh b">[1, 2, 3, 100]</code>被记录。好多了。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="450f" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">比较对象</h1><p id="ce35" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">所以现在我们知道对象是通过引用传递的。但是当他们被比较的时候呢？为了回答这个问题，我们来看另一个例子:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="69ec" class="mq lc iq mh b gy mr ms l mt mu">const object1 = { someKey: 'someValue' }<br/>const object2 = { someKey: 'someValue' }</span><span id="220a" class="mq lc iq mh b gy mv ms l mt mu">console.log(object1 === object2);</span></pre><p id="ebe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个变量，<code class="fe me mf mg mh b">object1</code>和<code class="fe me mf mg mh b">object2</code>，这两个变量都是只有一个属性的对象。键是<code class="fe me mf mg mh b">someKey</code>，值是<code class="fe me mf mg mh b">someValue</code>。当我们在控制台记录一个严格相等的检查时，我们得到了什么？</p><p id="f256" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你回答了<code class="fe me mf mg mh b">false</code>，你就对了。这是因为<strong class="kf ir">对象也通过引用</strong>进行比较。即使这两个对象的值相同，它们也不是同一个对象。这是保存在两个独立变量中的两个独立对象，所以它们的引用是不同的。</p><p id="1792" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想要快速的完整性检查，您也可以检查每个对象是否等于它自己，就像这样:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f137" class="mq lc iq mh b gy mr ms l mt mu">console.log(object1 === object1);<br/>console.log(object2 === object2);</span></pre><p id="50c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制台的这两个日志都是<code class="fe me mf mg mh b">true</code>,因为在每种情况下，你都将一个对象与其自身进行比较，这是同一个引用。</p><p id="4fac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你真的想检查<code class="fe me mf mg mh b">object1</code>和<code class="fe me mf mg mh b">object2</code>是否有相同的键和值，你需要写一个实用方法来循环对象的键和值，并确保它们都是相同的。或者，你可以使用像<code class="fe me mf mg mh b">lodash</code>这样的库中的帮助方法，它为你实现了这个功能。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="424b" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">结论</h1><p id="9b98" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">原语通过值进行传递和比较。对象通过引用进行传递和比较。理解其中的区别将会为你省去很多调试代码的麻烦！</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="fd4e" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">更新</h1><p id="4a89" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我的心理模型是“原语通过值传递；对象通过引用传递”多年来一直为我服务，它有助于理解预期的行为，但似乎我一直在使用不正确的术语来解释实际发生的事情。</p><p id="16bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释这一概念的更正确的方式是:</p><blockquote class="ni nj nk"><p id="6a0a" class="kd ke nl kf b kg kh ki kj kk kl km kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated"><em class="iq">原语通过值传递。对象通过“引用的副本”传递。</em></p><p id="b543" class="kd ke nl kf b kg kh ki kj kk kl km kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated"><em class="iq">或者，JavaScript中的参数总是通过值传递。但一个对象的“值”才是参照物。</em></p></blockquote></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="664a" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="b555" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>