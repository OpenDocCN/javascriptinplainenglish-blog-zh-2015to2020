<html>
<head>
<title>Rxjs Operators — Throttle and Join</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rxjs运算符—节流和连接</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-operators-throttle-and-join-964f8e63115e?source=collection_archive---------5-----------------------#2020-02-27">https://javascript.plainenglish.io/rxjs-operators-throttle-and-join-964f8e63115e?source=collection_archive---------5-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/669bb05a86f07e060605a7e413ae45f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tseuAoWTr5Ib9Yls"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nathananderson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nathan Anderson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3832" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="1df8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看throttle和join操作符，包括<code class="fe lb lc ld le b">throttle</code>、<code class="fe lb lc ld le b">throttleTime</code>、<code class="fe lb lc ld le b">combineLatest</code>和<code class="fe lb lc ld le b">concatAll</code>。</p><h1 id="63d0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">过滤运算符</h1><h2 id="3a89" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">喉咙</h2><p id="947a" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><code class="fe lb lc ld le b">throttle</code>运算符从源可观测值中发出值，然后在由另一个可观测值决定的时间内忽略随后从源发出的值，然后重复这个过程。</p><p id="d663" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多需要两个参数。第一个是<code class="fe lb lc ld le b">durationSelector</code>，它是一个函数，从源可观察值中获取一个值，然后返回一个可观察值或承诺，计算每个源值的调节持续时间。</p><p id="8016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是一个可选的<code class="fe lb lc ld le b">config</code>对象，用于定义<code class="fe lb lc ld le b">leading</code>和<code class="fe lb lc ld le b">trailing</code>行为。默认值为<code class="fe lb lc ld le b">defaultThrottleConfig</code>。</p><p id="c215" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它从源返回一个执行节流操作的可观察对象。</p><p id="ac30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="2396" class="md lg iq le b gy nc nd l ne nf">import { interval } from "rxjs";<br/>import { throttle } from "rxjs/operators";</span><span id="67ab" class="md lg iq le b gy ng nd l ne nf">const interval$ = interval(1000);<br/>const result = interval$.pipe(throttle(ev =&gt; interval(5000)));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="e802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有一个每秒发出一个数字的<code class="fe lb lc ld le b">interval$</code>可观察对象。来自它的值被<code class="fe lb lc ld le b">pipe</code> d到<code class="fe lb lc ld le b">throttle</code>操作符中，该操作符接受一个返回<code class="fe lb lc ld le b">interval(5000)</code>可观察值的函数，该函数每5秒发出一个数字。</p><p id="6bcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，自从我们的<code class="fe lb lc ld le b">throttle</code>回调函数返回<code class="fe lb lc ld le b">interval(5000)</code>以来，<code class="fe lb lc ld le b">throttle</code>操作符将每5秒从<code class="fe lb lc ld le b">interval$</code>发出一次值。</p><p id="57c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该在<code class="fe lb lc ld le b">console.log</code>中记录每5个数字。</p><h1 id="9284" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">节流时间</h1><p id="5245" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><code class="fe lb lc ld le b">throttleTime</code>从源可观测值发出一个值，然后在<code class="fe lb lc ld le b">duration</code>毫秒内忽略随后发出的值，然后重复该过程。</p><p id="5c89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最多需要3个参数。第一个是<code class="fe lb lc ld le b">duration</code>，是在发出上一个值之后，发出另一个值之前等待的时间。它以毫秒或可选的<code class="fe lb lc ld le b">scheduler</code>的时间单位计量。</p><p id="126c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是可选的<code class="fe lb lc ld le b">scheduler</code>，默认为<code class="fe lb lc ld le b">async</code>。它用于设定发射的时间。</p><p id="a54c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数是<code class="fe lb lc ld le b">config</code>，它是可选的。默认为<code class="fe lb lc ld le b">defaultThrottleConfig</code>。我们可以传入一个对象来定义<code class="fe lb lc ld le b">leading</code>和<code class="fe lb lc ld le b">trailing</code>的行为。默认值是<code class="fe lb lc ld le b">{ leading: true, trailing: false }</code>。</p><p id="9222" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="c0c2" class="md lg iq le b gy nc nd l ne nf">import { interval } from "rxjs";<br/>import { throttleTime } from "rxjs/operators";</span><span id="e7dc" class="md lg iq le b gy ng nd l ne nf">const interval$ = interval(1000);<br/>const result = interval$.pipe(throttleTime(5000));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="ff9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的工作类似于我们之前的<code class="fe lb lc ld le b">throttle</code>示例，除了我们将<code class="fe lb lc ld le b">throttle(ev =&gt; interval(5000))</code>改为<code class="fe lb lc ld le b">throttleTime(5000)</code>，它们做同样的事情。</p><p id="a522" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们每5秒钟从<code class="fe lb lc ld le b">$interval</code>发出一次数字。</p><p id="3c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到与上面例子中相同的数字。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/047a674bbd7998eaf03bce1fcb56ff7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bgYKZVtcBKZjJA5j"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@marius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marius Masalar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e2d7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">连接运算符</h1><h2 id="0be9" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">组合所有</h2><p id="91e8" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><code class="fe lb lc ld le b">combineAll</code>运算符通过在可观察值完成时应用<code class="fe lb lc ld le b">combineLatest</code>来展平可观察值。</p><p id="ba99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它带有一个可选参数，这是一个<code class="fe lb lc ld le b">project</code>函数，用于将发出的每个值映射到我们想要的东西。</p><p id="a481" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦外部可观察对象完成，它就订阅所有收集的可观察对象，并按如下方式组合它们的值:</p><ul class=""><li id="77e1" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated">每次内部可观察对象发出时，输出可观察对象也会发出</li><li id="2743" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">当返回的可观察对象发出并且指定了一个<code class="fe lb lc ld le b">project</code>函数时，当值到达时<code class="fe lb lc ld le b">project</code>被调用，它将使用<code class="fe lb lc ld le b">project </code>函数处理每个值</li><li id="0d3b" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated">如果没有<code class="fe lb lc ld le b">project</code>函数，那么最近的值由返回的可观察值发出</li></ul><p id="b8a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="58d5" class="md lg iq le b gy nc nd l ne nf">import { of } from "rxjs";<br/>import { map, combineAll } from "rxjs/operators";</span><span id="3bf1" class="md lg iq le b gy ng nd l ne nf">const of$ = of(1, 2, 3);<br/>const higherOrderObservable = of$.pipe(map(val =&gt; of("a", "b", "c")));<br/>const result = higherOrderObservable.pipe(combineAll());<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="0a9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将<code class="fe lb lc ld le b">of$</code>可观察值映射到子可观察值。它为每个由<code class="fe lb lc ld le b">of$</code>发出的值返回<code class="fe lb lc ld le b">of(“a”, “b”, “c”)</code>。</p><p id="5105" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe lb lc ld le b">combineAll</code>将<code class="fe lb lc ld le b">higherOrderObservable</code>中每个子观测值的最新值组合成一个数组。然后这些阵列中的每一个都由可观测的<code class="fe lb lc ld le b">result</code>发出。</p><p id="dfd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="8e7b" class="md lg iq le b gy nc nd l ne nf">["c", "c", "a"]<br/>["c", "c", "b"]<br/>["c", "c", "c"]</span></pre><p id="75a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe lb lc ld le b">console.log</code>输出。前两个可观测量在最后一个之前完成，所以我们从它们那里得到<code class="fe lb lc ld le b">'c'</code>。然后随着第三个发出的，加上数组中的最后一个值，所以我们从它们分别得到<code class="fe lb lc ld le b">'a'</code>、<code class="fe lb lc ld le b">'b'</code>和<code class="fe lb lc ld le b">'c'</code>。</p><h2 id="840f" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">concatAll</h2><p id="d70d" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated"><code class="fe lb lc ld le b">concatAll</code>运算符通过按顺序连接内部可观测量来转换高阶可观测量，</p><p id="b4f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不接受任何参数，并返回一个可观察对象，该对象发出所有内部可观察对象的值。</p><p id="11a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="d8f0" class="md lg iq le b gy nc nd l ne nf">import { of } from "rxjs";<br/>import { map, concatAll } from "rxjs/operators";</span><span id="b4d4" class="md lg iq le b gy ng nd l ne nf">const of$ = of(1, 2, 3);<br/>const higherOrderObservable = of$.pipe(map(val =&gt; of("a", "b", "c")));<br/>const result = higherOrderObservable.pipe(concatAll());<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="1593" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">of$</code>可观测值的发射值是<code class="fe lb lc ld le b">pipe</code> d，来自<code class="fe lb lc ld le b">of$</code>的每个值被映射到<code class="fe lb lc ld le b">of(“a”, “b”, “c”)</code>可观测值。</p><p id="fa43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们<code class="fe lb lc ld le b">pipe</code>来自<code class="fe lb lc ld le b">higherOrderObservable</code>中的内部可观测量的结果是从<code class="fe lb lc ld le b">of$</code>映射的3个<code class="fe lb lc ld le b">of(“a”, “b”, “c”)</code>可观测量，它们的发射值由<code class="fe lb lc ld le b">concatAll</code>组合。</p><p id="84e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们得到:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="912d" class="md lg iq le b gy nc nd l ne nf">a<br/>b<br/>c<br/>a<br/>b<br/>c<br/>a<br/>b<br/>c</span></pre><p id="5034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">throttle</code>运算符从源可观测值发出值，然后在由另一个可观测值确定的持续时间内忽略随后从源发出的值，并重复。</p><p id="5c95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">throttleTime</code>从源可观测值发出一个值，然后在给定的时间内忽略随后发出的值，并重复。</p><p id="2796" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">combineAll</code>当可观察值完成时，通过合并最新值来拉平可观察值。</p><p id="8c34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">concatAll</code>运算符按顺序组合内部可观测值的发射值。</p></div></div>    
</body>
</html>