<html>
<head>
<title>Asynchronous JavaScript: Organizing Callbacks for Readability and Reusability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript:为可读性和可重用性组织回调</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-javascript-organizing-callbacks-for-readability-and-reusability-32ad912f2faf?source=collection_archive---------5-----------------------#2020-01-26">https://javascript.plainenglish.io/asynchronous-javascript-organizing-callbacks-for-readability-and-reusability-32ad912f2faf?source=collection_archive---------5-----------------------#2020-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/66bd20f2b0437b7d3ee6794d33bc8571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-3QoGRK244hRoIs6.png"/></div></div></figure><p id="3779" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">异步编程是成为一名完整的JavaScript程序员的重要组成部分。理解JavaScript中的代码执行流是理解它如何处理异步任务的基础。能够编程异步任务使您能够利用JavaScript运行时引擎和外部API提供的大量功能。有了这些工具，您可以通过互联网将您的JavaScript程序与web APIs连接起来，并有效地管理这些(有时是脆弱的)连接。</p><p id="fe3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着权力而来的是复杂性。使用JavaScript回调实现异步功能可以快速创建一系列深度嵌套的函数调用。这篇文章将向您展示如何编写和组织JavaScript回调函数，以最大化异步函数的可读性、可维护性和可重用性。</p><p id="a098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如一句古老的编程谚语所说:</p><blockquote class="kw kx ky"><p id="6e8b" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">任何傻瓜都能写出计算机能理解的代码。优秀的程序员编写人类能够理解的代码。</p></blockquote><p id="de50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本系列的第一部分，<a class="ae ld" href="https://medium.com/swlh/asynchronous-javascript-understanding-callbacks-8c288c555b23" rel="noopener">异步JavaScript:理解回调</a>，提供了JavaScript事件循环、回调队列和执行堆栈的完整概述。在一个简短的案例研究项目中，它向您展示了JavaScripts非阻塞事件模型中的函数执行顺序，以及如何使用回调从外部API检索和操作数据。</p><p id="b133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章继续第一部分的内容，向您展示如何将一系列三个链接的回调函数和五个层次的函数转换成更易维护和调试的代码。设置案例研究项目只需要几分钟时间。</p><h1 id="91d7" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">先决条件</h1><p id="ec3f" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">为了完成这篇文章中的任务，你需要:</p><ul class=""><li id="b7ce" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><a class="ae ld" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也会安装NPM。)</li><li id="b834" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><a class="ae ld" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">吉特</a></li></ul><p id="ead0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还应该对JavaScript和JavaScript事件循环有很好的理解。如果您需要复习后一点，请查看本系列关于异步JavaScript的第一部分。</p><p id="3513" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub上有这篇文章的<a class="ae ld" href="https://github.com/maciejtreder/asynchronous-javascript" rel="noopener ugc nofollow" target="_blank">配套资源库</a>。</p><h1 id="2d32" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正在初始化项目</h1><p id="3763" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">如果你从<a class="ae ld" href="https://medium.com/swlh/asynchronous-javascript-understanding-callbacks-8c288c555b23" rel="noopener">开始</a>开始这个系列，很好！您已经有了项目和代码设置。可以继续使用<em class="kz">异步javascript </em> Node.js应用程序。</p><p id="0732" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您已经知道事件循环是如何工作的，并且在这里关注代码组织，有两种方法可以开始:</p><p id="9580" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">选项1 </strong></p><p id="6565" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在您想要创建项目目录的目录中执行以下指令，克隆第1部分中的项目:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1c66" class="ne lf iq na b gy nf ng l nh ni">git clone <a class="ae ld" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step2<br/>npm install</span></pre><p id="fa39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">选项2 </strong></p><p id="2792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您想要创建项目目录的目录中执行以下命令行指令:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cdeb" class="ne lf iq na b gy nf ng l nh ni">mkdir asynchronous-javascript<br/>cd asynchronous-javascript<br/>git init<br/>npx license mit &gt; LICENSE<br/>npx gitignore node<br/>npm init -y<br/>npm install request<br/>git add -A<br/>git commit -m "Initial commit"</span></pre><p id="a645" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在成功完成选项1或2之后，您应该在项目根目录中拥有一个Node.js项目和一个<em class="kz"> nestedCallbacks.js </em>文件。还有一个带有适当的<em class="kz">的Git repo。Node.js项目的gitignore </em>文件。</p><p id="07fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您遵循了<strong class="ka ir">选项1 </strong>，打开根项目目录中的<em class="kz"> nestedCallbacks.js </em>文件。</p><p id="6285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您遵循了<strong class="ka ir">选项2 </strong>，在根项目目录中创建一个<em class="kz"> nestedCallbacks.js </em>文件，并插入以下JavaScript代码:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fd3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在根项目目录中执行以下命令行指令，验证Node.js项目是否设置正确:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9fcb" class="ne lf iq na b gy nf ng l nh ni">node nestedCallbacks.js</span></pre><p id="534a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制台窗口中显示的输出应该是:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fe79" class="ne lf iq na b gy nf ng l nh ni">The best movie by Quentin Tarantino is... Inglourious Basterds !!!</span></pre><p id="c46a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能不同意这个结果，但是它证明了您的代码工作正常，并且您的API调用与远程API模型相连接。</p><h1 id="d35b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">理解嵌套JavaScript回调的问题</h1><p id="6da5" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在开始重新组织你的回调函数之前，看看一系列嵌套的回调函数对理解问题是有帮助的。</p><p id="5582" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在IDE或代码编辑器中查看<em class="kz"> nestedCallbacks.js </em>代码。如果您使用的是Visual Studio代码(为什么不呢？)你会看到第三个API调用的回调函数中的<code class="fe nl nm nn na b">forEach</code>循环在嵌套的第六层。</p><p id="f98b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然前两个回调函数中的代码很简单，第三个回调函数也很简单，但是不难看出在回调队列中找到自己的位置会变得很复杂。想象一下，如果在API调用、回调函数和依赖于API调用返回值的条件逻辑的参数之间有选择。这可能是意大利面条的配方！</p><h1 id="3283" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">组织异步JavaScript回调</h1><p id="f164" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">随着程序复杂性的增加，除了潜在地难以阅读、维护和调试之外，<em class="kz"> nestedCallbacks.js </em>中的API调用和回调函数不能以当前形式重用。这意味着您可能有重复的代码，导致更多的bug。</p><p id="df88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，很容易将<em class="kz"> nestedCallbacks.js </em>重构为更加模块化和可重用的代码。一个技巧是从最里面的回调开始，一步步向上。</p><p id="0838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，您可以在工作时并排比较这两个版本，在项目根目录中创建一个<em class="kz"> organizedCallbacks.js </em>文件。</p><p id="012d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插入以下JavaScript代码:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bdab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">封装嵌套最多的代码块，也就是最后一个<code class="fe nl nm nn na b">request</code>调用的回调函数。在刚刚添加的行下面插入以下代码:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="156a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能已经注意到，这个函数中有更多的参数。他们是这样做的:</p><p id="63b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">movie</code>是一个对象，包含您要计算平均分的电影的信息。</p><p id="0d83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">reviews</code>是指定<code class="fe nl nm nn na b">movie</code>的评论数组。每个数组元素都有一个评审分数。</p><p id="ebf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">director</code>是一个包含指定<code class="fe nl nm nn na b">movie</code>导演信息的对象。</p><p id="0818" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">toBeChecked</code>是一个计数器，显示还有多少电影需要该函数处理。</p><p id="9f5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe nl nm nn na b">toBeChecked</code>是一个对象而不是一个原始(整数)类型，所以它的状态，检查的电影数量，可以在函数调用之间维护。这在原始代码中是不必要的，因为JavaScript的变量作用域方法:父函数外层循环中的变量<code class="fe nl nm nn na b">checkedMoviesCount</code>可供它下面的函数调用使用。(阅读更多关于JavaScript <a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>的内容。)这是一种可以在许多需要跟踪函数调用之间的值的地方使用的技术。</p><p id="14da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">movies</code>是一个电影数组，函数通过它进行迭代以找到最高分。</p><p id="1614" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数遍历指定导演的电影。它从递增<code class="fe nl nm nn na b">count</code>计数器开始。然后，它遍历电影的每个评论，将每个评论的分数添加到累积分数中，并增加评论的计数。当检查完评论后，它会计算电影的平均评分，并将分数添加到电影列表中的电影条目中。</p><p id="cf9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当检查的电影数等于电影数组的长度时，代码按平均分降序排列该数组。然后，数组中第一个元素的标题，也就是评分最高的电影，被写入控制台输出。</p><p id="79e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，将调用堆栈上移至第二个API调用，该调用检索电影评论。</p><p id="1036" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下JavaScript代码插入到<em class="kz"> organizedCallbacks.js </em>中您在上一步中添加的代码下方:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0b0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数有两个参数:</p><p id="7627" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">movies</code>是一组您要检索评论的电影。</p><p id="c9b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">director</code>是一个对象，包含关于<code class="fe nl nm nn na b">movies</code>数组中电影导演的信息。</p><p id="d02c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该代码初始化<code class="fe nl nm nn na b">toBeChecked</code>计数器，该计数器跟踪剩余待评估的电影数量。</p><p id="aa9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后代码遍历<code class="fe nl nm nn na b">movies</code>数组。它为每个<code class="fe nl nm nn na b">movie</code>调用一个REST来检索评论列表，该列表存储在<code class="fe nl nm nn na b">reviews</code>对象中并传递给<code class="fe nl nm nn na b">calculateAverageScore</code>函数。</p><p id="d8e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您要封装的最后一个代码块是对第一个REST请求的回调，该代码查找给定导演的电影:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d15c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有两个参数:</p><p id="ef82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">directors</code>是要搜索的控制器数组。</p><p id="354d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">name</code>是一个字符串，标识您正在为其检索评论的导演。它用于显示最终结果。(有关这方面的更多信息，请参见下面的<em class="kz">进一步改进</em>部分。)</p><p id="f7a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数体中，代码保存指定的<code class="fe nl nm nn na b">director</code>的<code class="fe nl nm nn na b">id</code>值，并使用它来执行REST调用以检索他的电影列表。</p><p id="9f72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nl nm nn na b">findDirector</code>函数的回调函数是<code class="fe nl nm nn na b">getReviews</code>函数。当对<em class="kz">/asynchronous-JavaScript/directors/{ id }/movies</em>端点的REST调用返回一个电影列表时，该列表被用作<code class="fe nl nm nn na b">movies</code>参数中的<code class="fe nl nm nn na b">getReviews</code>函数的回调函数调用的参数。导演的名字在<code class="fe nl nm nn na b">name</code>参数中传递。</p><p id="a823" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启动整个过程的web API调用是对<em class="kz"> /directors </em>端点的调用，以获取directors列表。在前面的函数下添加以下代码:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4e17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">web API调用获取一个控制器列表，并将JSON对象解析成一个数组。这个控制器列表被传递给<code class="fe nl nm nn na b">directors</code>参数中的回调函数。对<code class="fe nl nm nn na b">findDirector</code>的回调函数调用获得了昆汀·塔伦蒂诺的<code class="fe nl nm nn na b">id</code>值。</p><h1 id="8fc9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试重组后的JavaScript回调</h1><p id="3380" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">通过在项目根目录中执行以下命令行指令，验证新的程序结构是否正常工作:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a864" class="ne lf iq na b gy nf ng l nh ni">node organizedCallbacks.js</span></pre><p id="0ae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出应该是:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3741" class="ne lf iq na b gy nf ng l nh ni">The best movie by Quentin Tarantino is... Inglourious Basterds !!!</span></pre><p id="2706" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">批评家可能会有不同意见，但是结果反映了测试API的平均分数。如果你得到不同的结果，确保你使用正确的<code class="fe nl nm nn na b">id</code>值为导演得到电影列表。</p><h1 id="af47" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">探索封装回调函数的优势</h1><p id="237c" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">封装的回调有什么好处？您已经将代码中嵌套层次的数量从六个减少到三个，使得阅读、维护和调试更加容易。您可以改变或增加每个函数的行为，而对其他函数的影响较小。</p><p id="ac77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还使得扩展应用程序的功能变得更加容易。使用新的程序结构，很容易为测试集中的每个导演找到评分最高的电影。</p><p id="d6b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下几行添加到<em class="kz"> organizedCallbacks.js </em>文件的底部:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5043" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次执行程序。您应该会看到四位导演的顶级电影列表:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="56ff" class="ne lf iq na b gy nf ng l nh ni">Best movie by Quentin Tarantino is... Inglourious Basterds !!!<br/>Best movie by Stanley Kubrick is... 2001: A Space Odyssey !!!<br/>Best movie by James Cameron is... Titanic !!!<br/>Best movie by Wes Anderson is... The Grand Budapest Hotel !!!</span></pre><p id="5242" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您还没有进行编码，并且想要使用GitHub上的配套库来完成这一步，那么在您想要创建项目目录的目录中执行以下命令:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="113b" class="ne lf iq na b gy nf ng l nh ni">git clone <a class="ae ld" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step3<br/>npm install</span></pre><h1 id="147e" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">进一步增强</h1><p id="5069" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">上面的代码比<em class="kz"> nestedCallbacks.js </em>有所改进，但仍有改进的空间。以下是一些可以改进的方法:</p><ul class=""><li id="d0af" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">它是颠倒的。如果代码按照从上到下的顺序执行，你的程序将更具可读性。</li><li id="c4bb" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">这些功能是高度耦合的。程序只能在当前的结构中运行，函数间的数据流只允许程序以一种方式构建。随着需求的变化，这抑制了功能的可重用性和可维护性。</li><li id="19ca" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">这些功能不是原子的。你可以在几个地方很容易地看到这一点:</li><li id="7b25" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">在第一个API调用被调用之前，代码知道您要为其显示得分最高的电影的导演的名字，但是它通过两个函数调用来传递。</li><li id="751b" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">最后一个函数调用<code class="fe nl nm nn na b">calculateAverageScore</code>，显示评分最高的电影——但那“不是它的工作描述的一部分”。</li></ul><p id="b1e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是JavaScript新手，做更多的重构对你来说是一个很好的练习。重要的是要认识到，既然回调嵌套的级别已经降低，那么发现需要改进的地方就容易多了。当你自己编程时，发现你已经创建了一系列深度嵌套的回调函数，这是你应该考虑重构的信号。</p><h1 id="df5b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">组织JavaScript回调概述</h1><p id="0068" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在这篇文章中，您了解了如何获取一组深度嵌套的JavaScript回调并将它们重构为独立的函数，从而使代码更具可读性、可维护性和可调试性。您还看到了如何减少JavaScript回调的嵌套，从而更容易发现代码中可以改进的其他方面。</p><p id="50b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进一步:<a class="ae ld" href="https://medium.com/@maciejtreder/asynchronous-javascript-introduction-to-javascript-promises-3142eeea9b38" rel="noopener">异步JavaScript:JavaScript简介承诺</a></p><h1 id="3902" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">额外资源</h1><p id="6da6" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated"><em class="kz"> JavaScript:精彩部分</em>，道格拉斯·克洛克福特(O'Reilly，2008)如果你只打算读一本关于编写JavaScript的书，这应该就是了。</p><p id="dad4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【json.org】一页上的JSON语言规范。也可从ECMA获得更长的<a class="ae ld" href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf" rel="noopener ugc nofollow" target="_blank"> PDF </a>格式。</p><p id="2eb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub Pages 用于托管本文中使用的测试web API。这是一件值得了解的好事。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="c9a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">我是Maciej Treder，请通过</em><a class="ae ld" href="mailto:contact@maciejtreder.com" rel="noopener ugc nofollow" target="_blank"><em class="kz">contact@maciejtreder.com</em></a><em class="kz">，</em><a class="ae ld" href="https://www.maciejtreder.com/" rel="noopener ugc nofollow" target="_blank">T19】https://www.maciejtreder.com</a><em class="kz">或@ maciejtreder on</em><a class="ae ld" href="http://github.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="kz">GitHub</em></a><em class="kz">，</em><a class="ae ld" href="https://twitter.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="kz">Twitter</em></a><em class="kz">和</em> <a class="ae ld" href="https://www.linkedin.com/in/maciej-treder/" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> LinkedIn </em></a></p><p id="694d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">本帖最初发表在</em> <a class="ae ld" href="https://www.twilio.com/blog/asynchronous-javascript-organize-callbacks-readability-reusability" rel="noopener ugc nofollow" target="_blank"> <em class="kz"> Twilio博客</em> </a> <em class="kz">上。</em></p></div></div>    
</body>
</html>