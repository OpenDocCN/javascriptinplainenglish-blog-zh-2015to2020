<html>
<head>
<title>Algorithm Practice: Checking Whether A String Is A Palindrome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法练习:检查一个字符串是否是回文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithm-practice-checking-whether-a-string-is-a-palindrome-be30fc81f7a8?source=collection_archive---------8-----------------------#2020-12-18">https://javascript.plainenglish.io/algorithm-practice-checking-whether-a-string-is-a-palindrome-be30fc81f7a8?source=collection_archive---------8-----------------------#2020-12-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9fd66b41f4ef2eff9d45b6935cb7160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SABnYfT-DtAuwGOgkqs79g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joshua Sortino</a> on <a class="ae jz" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bed5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一个在技术面试中经常出现的经典算法问题:<em class="ky">给定一个字符串，我们如何检查它是否是回文</em>？</p><p id="bdaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们深入问题本身之前，让我们先退后一步，回顾一下什么是回文。一个<strong class="kc io">回文</strong>是一个前后读起来一样的字符串。经典的例子是“<em class="ky">racecar”</em>—反过来读，字符串还是“racecar”。</p><p id="6673" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经清楚了回文的概念，让我们进入算法和如何解决它:给定一个<em class="ky">非空的</em>字符串，我们的任务是编写一个函数，根据该字符串是否是回文返回<code class="fe kz la lb lc b">true</code>或<code class="fe kz la lb lc b">false</code>。请注意，单字母字符串是一个回文。</p><figure class="le lf lg lh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ld"><img src="../Images/f4c98f0522da1684176f699379616252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47suW06-OsRFkA8Xci-rGA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Src: <a class="ae jz" href="https://www.dictionary.com/e/palindromic-word/" rel="noopener ugc nofollow" target="_blank">Dictionary.com</a></figcaption></figure><p id="d113" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们开始编写解决方案之前，让我们从概念的角度来看这个问题。回文是一个向前和向后读都一样的字符串——所以这意味着如果我们向后遍历字符串，它应该与向前读的字符串完全相等。很简单。</p><p id="f223" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一个问题是:我们如何迭代一个字符串？一种方法是循环遍历字符串，将每次循环得到的每个字母存储在一个数组中，这样我们就可以轻松地访问结果。然后，我们可以将数组中的字母连接在一起创建一个字符串，将结果字符串与原始传入的字符串进行比较，并返回一个布尔值。</p><p id="3860" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这在代码中可能是这样的:</p><figure class="le lf lg lh gt jo"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="8334" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述解决方案是可行的，并且简单有效。从上述解决方案的空间和时间复杂性来看，我们使用O(n)时间和空间。我们能想出一个稍微高效一点的解决方案吗？</p><p id="5107" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们能找到一种方法来解决这个问题，而不需要在一个数组中存储颠倒的字母，会怎么样呢？我们可以使用双指针方法，其中我们有一个右指针和一个左指针，在每次迭代中，我们可以比较右指针处的字母是否等于右指针处的字母。如果在每次迭代中，两个字母是相同的，那么这个字符串就是一个回文。</p><p id="7cc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是该解决方案的代码:</p><figure class="le lf lg lh gt jo"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="78d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这在O(n)时间和O(1)空间中运行，使它更有空间效率。完美。</p></div></div>    
</body>
</html>