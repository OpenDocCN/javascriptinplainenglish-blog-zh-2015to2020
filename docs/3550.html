<html>
<head>
<title>Easy table sorting with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现简单的表格排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/easy-table-sorting-with-javascript-370d8d97cad8?source=collection_archive---------0-----------------------#2020-10-08">https://javascript.plainenglish.io/easy-table-sorting-with-javascript-370d8d97cad8?source=collection_archive---------0-----------------------#2020-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1df2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">静态或动态站点的简单技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/593cb096172423ca0f73851e7ac248c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hUquVZyZ19l-TU-K"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jankolar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jan Antonin Kolar</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="88c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">改进你发布的任何数据的最简单的方法之一是利用JavaScript使其可排序。虽然这可以在服务器端使用动态架构来完成，但在那里不一定是最好的选择<em class="ls">，更不用说在我们别无选择的静态环境中了。</em></p><h1 id="f5a0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">渐进增强</h1><p id="f192" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我将展示一种使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Unobtrusive_JavaScript" rel="noopener ugc nofollow" target="_blank">不引人注目的JavaScript </a>来增强现有内容的技术，如果可能的话使用<em class="ls"/>。对于没有JavaScript的读者来说，他们不会错过核心内容:无论我们展示的是什么数据。虽然他们不能对数据进行分类——对于一个静态网站来说，这是我们能提供的最好的选择——但他们仍然能够查看数据。</p><p id="c6ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在动态环境中，您仍然可以在服务器端排序回退的基础上使用这种技术。用于对每一列进行排序的链接可以在URL参数中发送不同的值，后端脚本使用这些值来生成适当排序的内容。这里介绍的JavaScript方法可以稍加修改，在JavaScript可用的地方，替换那些链接并使用客户端版本。唯一重大的挑战是确保后端和前端版本以完全相同的方式工作；如果使用类似于<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的东西会更容易。</p><h1 id="9c91" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">加价</h1><p id="40eb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们希望对数据进行排序，所以这应该以最合适的形式呈现:a <code class="fe mq mr ms mt b">table</code>。我们将尝试尽可能少的添加内容，以确保内容与功能的最大分离。</p><p id="919c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个基本的例子，你可以从附带的GitHub库下载:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="be1c" class="my lu iq mt b gy mz na l nb nc">&lt;!doctype html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;title&gt;Easy table sorting with JavaScript&lt;/title&gt;<br/>    &lt;link rel="stylesheet" href="styles.css" /&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;table&gt;<br/>        &lt;thead&gt;<br/>            &lt;tr&gt;<br/>                &lt;th&gt;Game&lt;/th&gt;<br/>                &lt;th&gt;Price&lt;/th&gt;<br/>                &lt;th&gt;Release date&lt;/th&gt;<br/>                &lt;th&gt;Rating&lt;/th&gt;<br/>            &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;<br/>            &lt;tr&gt;<br/>                &lt;td&gt;Super Mario Odyssey&lt;/td&gt;<br/>                &lt;td&gt;49.99&lt;/td&gt;<br/>                &lt;td&gt;October 27, 2017&lt;/td&gt;<br/>                &lt;td&gt;97&lt;/td&gt;<br/>            &lt;/tr&gt;<br/>            <em class="ls">&lt;!-- the actual examples includes more rows here --&gt;</em><br/>       &lt;/tbody&gt;<br/>    &lt;/table&gt;<br/>    &lt;script src="sort-table.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="ba0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这个例子指定了HTML5中可选的<code class="fe mq mr ms mt b">thead</code>和<code class="fe mq mr ms mt b">tbody</code>元素。因为这些元素增加了结构，所以它们也增加了更精确或者更简单的实现的可能性。作为一个经验法则，包含元素通常是一个好主意，即使它们是可选的，如果它们添加了像这样有价值的结构。</p><p id="f7bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有任何额外的东西(和最少的样式)，基本表看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/830bf9e7452b765ee40ab835a56b06b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oaxdf28uUFC9zhRziJjtnQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Initial data table before any alterations</figcaption></figure><h1 id="e555" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">准备标记</h1><p id="d524" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了保持内容和行为之间最严格的分离，保持标记尽可能干净是一个好习惯。为此，我们<em class="ls">可以</em>就此打住，但是当涉及到对我们文档中的表格(以及整个站点)进行排序时，我们不太可能希望<em class="ls">每个</em>表格都是可排序的。传达我们意图的最干净的方式是使用名为“sortable”的类。这允许在一个页面上有多个可排序的表，并且类名是完全语义化的，所以在文档上增加的“足迹”是最小的。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="7e70" class="my lu iq mt b gy mz na l nb nc">&lt;table <strong class="mt ir">class="sortable"</strong>&gt;<br/>...<br/>&lt;/table&gt;</span></pre><p id="dd38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当涉及到对不同类型的数据进行排序时，我们将再次讨论这种方法。现在，我将详细介绍一下JavaScript，<code class="fe mq mr ms mt b"><a class="ae kv" href="https://github.com/bobbykjack/sort-table-js/blob/8210606904ffc234aaa18e09cedb05158bd56489/sort-table.js" rel="noopener ugc nofollow" target="_blank">sort-table.js</a></code>。我建议在一个新窗口中打开那个链接，并和文章的其余部分一起查看。</p><h1 id="a45b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">设置事件处理程序</h1><p id="44bb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对表格进行排序的标准方式——这也是我们的访问者最可能期望的——是单击相应的列标题。为了更加明显，我们将从在每个列标题周围注入超链接开始——单击标题的链接将对该列进行排序。</p><p id="711f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重要的是要确保我们的方法可以处理多个表，并按照预期对它们进行独立排序。虽然这个例子在一个页面上只使用了一个表，但是您可以通过创建第二个表来轻松地测试它。您还可以借此机会测试一个没有打开<code class="fe mq mr ms mt b">sortable</code>类的表，以确认它保持不变。</p><p id="b8fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置事件处理程序包括从文档中获取所需的表、注入超链接以及添加事件侦听器来对相应的列进行排序。</p><p id="b6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先使用<code class="fe mq mr ms mt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll" rel="noopener ugc nofollow" target="_blank">querySelectorAll</a>()</code>获取<code class="fe mq mr ms mt b">table</code>元素:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="25d6" class="my lu iq mt b gy mz na l nb nc">var tables = document.querySelectorAll("table.sortable");</span></pre><p id="1d28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们遍历集合，忽略任何没有<code class="fe mq mr ms mt b">thead</code>元素的元素:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="3ec6" class="my lu iq mt b gy mz na l nb nc">for (i = 0; i &lt; tables.length; i++) {<br/>    table = tables[i];</span><span id="f83c" class="my lu iq mt b gy ne na l nb nc">    if (thead = table.querySelector("thead")) {</span></pre><p id="c613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将每一列的标题文本包装在一个超链接中，并向其中添加一个事件侦听器:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="0d3f" class="my lu iq mt b gy mz na l nb nc">headers = thead.querySelectorAll("th");</span><span id="2c65" class="my lu iq mt b gy ne na l nb nc">for (j = 0; j &lt; headers.length; j++) {<br/>    headers[j].innerHTML = "&lt;a href='#'&gt;" + headers[j].innerText<br/>        + "&lt;/a&gt;";<br/>}</span><span id="dde8" class="my lu iq mt b gy ne na l nb nc">thead.addEventListener("click", sortTableFunction(table));</span></pre><p id="92a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">sortTableFunction</code>是一个我们称之为函数的函数，它本身会产生一个函数。我们在主循环中将当前表的值传递给它；这种方法有助于避免一个常见错误，该错误会导致只有最终的表是可排序的:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="c490" class="my lu iq mt b gy mz na l nb nc">function sortTableFunction(table) {<br/>    return function(ev) {<br/>        if (ev.target.tagName.toLowerCase() == 'a') {<br/>            sortRows(table, siblingIndex(ev.target.parentNode));<br/>            ev.preventDefault();<br/>        }<br/>    };<br/>}</span></pre><p id="676b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们检查它实际上是一个被点击的超链接，而不是列标题中围绕它的任何空白。如果你喜欢不同的行为，你可以改变这种方法。当一个链接被点击时，处理程序检查它的<code class="fe mq mr ms mt b">parentNode</code>(<code class="fe mq mr ms mt b">th</code>元素)，这样它就可以通过<code class="fe mq mr ms mt b"><a class="ae kv" href="https://github.com/bobbykjack/sort-table-js/blob/8210606904ffc234aaa18e09cedb05158bd56489/sort-table.js#L42" rel="noopener ugc nofollow" target="_blank">siblingIndex</a></code>函数找出哪一列被点击了。我不会在这里介绍这个函数；它只是为第一列返回<code class="fe mq mr ms mt b">0</code>，为下一列返回<code class="fe mq mr ms mt b">1</code>，依此类推。</p><p id="8fa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经添加了指向列标题的链接，这些链接将标识它们的索引，并调用一个尚未编写的函数<code class="fe mq mr ms mt b">sortRows</code>，传递要排序的表和列索引。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/1e77b6e38830c16e283d012135be7c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1Vomwg1qlKHKE__EQrgDg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The same table with hyperlinks wrapped around column headers</figcaption></figure><h1 id="52fa" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">整理桌子</h1><p id="28d5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这里是所有真正工作发生的地方，在<code class="fe mq mr ms mt b">sortRows</code>函数中。我们分三步进行:</p><ol class=""><li id="95b6" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">获取特定列中的所有值，并将它们存储在一个数组中。</li><li id="090b" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">使用适当的函数对数组进行排序。</li><li id="fddc" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">使用新的顺序逐一定位表格中的行。</li></ol><h2 id="affe" class="my lu iq bd lv nt nu dn lz nv nw dp md lf nx ny mf lj nz oa mh ln ob oc mj od bi translated">第一步:获取值</h2><p id="22b6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">该函数首先从表体中获取所有行，然后设置一个选择器，根据提供的<code class="fe mq mr ms mt b">columnIndex</code>获取适当的表单元格(<code class="fe mq mr ms mt b">td</code>):</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="9dd1" class="my lu iq mt b gy mz na l nb nc">function sortRows(table, columnIndex) {<br/>    var rows = table.querySelectorAll("tbody tr"),<br/>        sel2 = "td:nth-child(" + (columnIndex + 1) + ")",</span></pre><p id="bb68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后循环遍历这组行，使用选择器获取每个<code class="fe mq mr ms mt b">td</code>:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="a4dd" class="my lu iq mt b gy mz na l nb nc">for (index = 0; index &lt; rows.length; index++) {<br/>    node = rows[index].querySelector(sel2);</span></pre><p id="c1a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦有了表格单元格，我们就可以获取其中的值:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="8d2f" class="my lu iq mt b gy mz na l nb nc">val = node.innerText;</span></pre><p id="5d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并将该值存储在一个<code class="fe mq mr ms mt b">values</code>数组中，该数组将保存我们希望排序的所有行:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="55a0" class="my lu iq mt b gy mz na l nb nc">values.push({ value: val, row: rows[index] });</span></pre><p id="647c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们正在构建一个对象数组，每个对象存储实际的<code class="fe mq mr ms mt b">value</code>以及对<code class="fe mq mr ms mt b">row</code>的引用，即<code class="fe mq mr ms mt b">tr</code>节点本身。这将证明在第3步中对行进行重新排序时是有用的；我们将对<code class="fe mq mr ms mt b">values</code>数组中的所有对象进行排序，每个对象都有一个现成的对<code class="fe mq mr ms mt b">row</code>的引用，然后可以按顺序添加到最终的<code class="fe mq mr ms mt b">table</code>。</p><h2 id="9fdd" class="my lu iq bd lv nt nu dn lz nv nw dp md lf nx ny mf lj nz oa mh ln ob oc mj od bi translated">第二步:对数组进行排序</h2><p id="c2e7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们在<code class="fe mq mr ms mt b">values</code>中有了一个对象数组，是时候对它们进行排序了。默认情况下，<code class="fe mq mr ms mt b">Array.sort()</code>进行字符串比较，这可能适用于我们的“游戏”列，但实际上不适用于任何其他列，因为它们是数字。</p><p id="dec7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，默认的排序是区分大小写的，这几乎肯定不是我们想要的，即使对于简单的文本数据也是如此；不区分大小写的顺序更合适。</p><p id="9de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">Array.sort()</code>方法可以接受一个参数，该参数是用户定义的比较函数，形式如下:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="f449" class="my lu iq mt b gy mz na l nb nc">function(a, b) {<br/>         if (a is before b)     return -1;<br/>    else if (a is after b)      return 1;<br/>    else if (b and a are equal) return 0<br/>}</span></pre><p id="5bba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，-1可以是任何小于0的值，1可以是任何大于0的数。这非常有用，因为默认的数字排序函数非常简单:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="35b2" class="my lu iq mt b gy mz na l nb nc">function sortNumber(a, b) {<br/>    return a - b;<br/>}</span></pre><p id="c491" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在代码中使用这个函数，但是是间接的，因为正如第一步中解释的，我们排序的值是对象。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="69af" class="my lu iq mt b gy mz na l nb nc">function sortNumberVal(a, b) {<br/>    return sortNumber(a.value, b.value);<br/>}</span></pre><p id="c806" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们对一列数字进行排序，调用看起来像这样:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="2dbe" class="my lu iq mt b gy mz na l nb nc">values.sort(sortNumberVal);</span></pre><p id="5b59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码还提供了一个字符串排序函数<code class="fe mq mr ms mt b">sortTextVal</code>，以及一个日期排序函数<code class="fe mq mr ms mt b">sortDateVal</code>。他们每个人都做了少量的工作，首先将值转换成合适的值进行比较，然后进行实际的比较。</p><p id="e57f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的一部分我们还没有讨论，这有点复杂，就是类型的识别。在某种程度上，我们可以通过查看第一次获取时遇到的值来“猜测”我们看到的是数字、日期还是其他类型的值。但是这很容易出现问题，所以更健壮的方法是首选。</p><p id="6762" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在前面暗示过这个解决方案，它只是通过将数据包含在原始标记中来指示数据的类型，例如</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="2773" class="my lu iq mt b gy mz na l nb nc">&lt;thead&gt;<br/>    &lt;tr&gt;<br/>        &lt;th&gt;Game&lt;/th&gt;<br/>        &lt;th&gt;Price&lt;/th&gt;<br/>        &lt;th<strong class="mt ir"> class="date"</strong>&gt;Release date&lt;/th&gt;<br/>        &lt;th&gt;Rating&lt;/th&gt;<br/>    &lt;/tr&gt;<br/>&lt;/thead&gt;</span></pre><p id="cd24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，<code class="fe mq mr ms mt b">sortRows</code>函数使用<code class="fe mq mr ms mt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/classList" rel="noopener ugc nofollow" target="_blank">Element.classList</a></code>方法来检查被要求排序的列中的数据类型，例如</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="8b6d" class="my lu iq mt b gy mz na l nb nc">if (classList.contains("date")) {</span></pre><h2 id="6943" class="my lu iq bd lv nt nu dn lz nv nw dp md lf nx ny mf lj nz oa mh ln ob oc mj od bi translated">第三步:定位行</h2><p id="76d7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一旦对<code class="fe mq mr ms mt b">values</code>数组进行了排序，剩下的工作就是根据数组中对象的顺序对行进行排序。<code class="fe mq mr ms mt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" rel="noopener ugc nofollow" target="_blank">Node.appendChild()</a></code>方法的一个有价值的特性是，它可以移动现有的节点，而不必担心它的当前位置:只需指定需要移动的内容(例如每行)和移动到哪里(表体的末尾):</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="0402" class="my lu iq mt b gy mz na l nb nc">for (var idx = 0; idx &lt; values.length; idx++) {<br/>    table.querySelector("tbody").appendChild(values[idx].row);<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7ca1efd6a9cdb121bdd51a03f9a34a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiWsdpxfPOjF-qv12ygrrw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The table reordered, after the “Release date” column has been clicked</figcaption></figure><h1 id="38af" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">摘要</h1><p id="cf10" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">尽管仅仅对表中的一些值进行排序看起来工作量很大，但我们现在有了一个解决方案，它可以跨整个站点、跨表中呈现的任何数据进行移植。只需将<code class="fe mq mr ms mt b">sortable</code>类添加到任何现有的表中，包括脚本，就可以开始了。</p><p id="e86b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个普通的‘不引人注目的JavaScript’方法应该产生高度可移植和可重用的代码。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="70e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在我的网站上查看这个例子并与之互动，或者进一步探索GitHub 上的知识库<a class="ae kv" href="https://github.com/bobbykjack/sort-table-js" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="7890" class="my lu iq bd lv nt nu dn lz nv nw dp md lf nx ny mf lj nz oa mh ln ob oc mj od bi translated">进一步练习</h2><p id="15e6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">要获得更完整的解决方案，请考虑以下一些增强功能:</p><ul class=""><li id="3848" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr ol nl nm nn bi translated">处理更多类型:考虑每种类型的唯一类值和对该类型的值进行排序的独立函数</li><li id="cf47" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ol nl nm nn bi translated">指示对哪一列进行了排序:单击时向标题添加一个类，使用CSS样式化该类</li><li id="3c15" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ol nl nm nn bi translated">指示最初对哪一列进行了排序:使用与上一步相同的类，只需将它添加到标记中</li><li id="b4f9" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr ol nl nm nn bi translated">满足反向排序顺序:当一个列被排序并且被第二次点击时，添加一个“反向”类，并在值被排序后使用<code class="fe mq mr ms mt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" rel="noopener ugc nofollow" target="_blank">Array.reverse()</a></code></li></ul><p id="a55e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>