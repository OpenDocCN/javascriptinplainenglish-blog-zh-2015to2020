<html>
<head>
<title>Understanding Circuit Breakers in JavaScript by dissecting Opossum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过解剖负鼠理解JavaScript中的断路器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/circuit-breakers-in-javascript-opossum-bcd65c2ce9bd?source=collection_archive---------6-----------------------#2020-09-11">https://javascript.plainenglish.io/circuit-breakers-in-javascript-opossum-bcd65c2ce9bd?source=collection_archive---------6-----------------------#2020-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a3e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解断路器模式并在负鼠上实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6adfc9c103d105cc66d3c5129bc6a983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wE9fusMEGcI3uEhB.jpg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A cute picture of a Pygmy Possum to get more people interested in failing gracefully</figcaption></figure><p id="5113" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一个请求没有得到响应，它可能会占用你30到120秒的资源。在客户端和服务器的2层架构中，这可能不是灾难性的，但是如果您的服务器依赖于许多其他微服务，而这些微服务又依赖于其他微服务，则这种持久连接可能会级联地消耗整个网络的资源。这种灾难性的连锁反应可以通过断路器模式轻松挽救。</p><p id="3fac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从广义上看，断路器是一个函数的包装器，它监视错误，并在达到某个阈值后优雅地拒绝请求。该功能还对错误进行计数，并使断路器跳闸，阻止进一步请求呼叫无响应的服务器。让我们更深入地探讨一下这个问题。</p><h1 id="3f7d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">断路:了解负鼠库</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b964d2ae3f93b18038b1cef6914e1973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/0*GzX-78Ci6COHpspw.png"/></div></figure><h2 id="bd1a" class="ml lt iq bd lu mm mn dn ly mo mp dp mc le mq mr me li ms mt mg lm mu mv mi mw bi translated">初始变量</h2><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0630" class="ml lt iq my b gy nc nd l ne nf">// snippet from line 54-67 and 170-173<br/>//<a class="ae lr" href="https://github.com/nodeshift/opossum/blob/bd59b4860ce412608c520c757af1bf2b9398577b/lib/status.js#L146" rel="noopener ugc nofollow" target="_blank">https://github.com/nodeshift/opossum/blob/bd59b4860ce412608c520c757af1bf2b9398577b/lib/status.js#L146</a></span><span id="f022" class="ml lt iq my b gy ng nd l ne nf">// number of buckets in which the CB window should be divided  <br/><strong class="my ir">this[BUCKETS]</strong> = options.rollingCountBuckets; <strong class="my ir">// DEFAULT:</strong> <strong class="my ir">10</strong></span><span id="b14f" class="ml lt iq my b gy ng nd l ne nf">// window length of the CB<br/><strong class="my ir">this[TIMEOUT]</strong> = options.rollingCountTimeout; <strong class="my ir">// DEFAULT: 10000</strong></span><span id="0136" class="ml lt iq my b gy ng nd l ne nf">// Bucket where all the calculations will be stored<br/><strong class="my ir">this[WINDOW]</strong> = new Array(this[BUCKETS]); //<strong class="my ir">QUEUE datastructure</strong></span><span id="fddf" class="ml lt iq my b gy ng nd l ne nf">// rotating interval for the bucket<br/><strong class="my ir">const bucketInterval</strong> = Math.floor(this[TIMEOUT] / this[BUCKETS]);</span><span id="4e15" class="ml lt iq my b gy ng nd l ne nf">// rotate the window bucket<br/><strong class="my ir">this[BUCKET_INTERVAL]</strong> = setInterval(nextBucket(this[WINDOW]),      bucketInterval);</span><span id="963f" class="ml lt iq my b gy ng nd l ne nf">// rotating logic<br/><strong class="my ir">const nextBucket</strong> = window =&gt; _ =&gt; {  window.pop();  window.unshift(bucket());};</span></pre><p id="550e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是代码<br/> 1的要点。用10个桶<br/>做一个<strong class="kx ir">窗口</strong> 2。<strong class="kx ir">每隔<strong class="kx ir"> 1秒<br/>T10】3旋转</strong>铲斗。将初始化变量(<a class="ae lr" href="https://nodeshift.dev/opossum/" rel="noopener ugc nofollow" target="_blank">负鼠的默认变量</a>)排队到窗口，并将最旧的值<br/> 4出列。将区间引用存储在变量中以备将来使用</strong></p><h2 id="12ca" class="ml lt iq bd lu mm mn dn ly mo mp dp mc le mq mr me li ms mt mg lm mu mv mi mw bi translated">负鼠开火</h2><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="268c" class="ml lt iq my b gy nc nd l ne nf">//very very very stripped down overview of call function line 442<br/><a class="ae lr" href="https://github.com/nodeshift/opossum/blob/master/lib/circuit.js" rel="noopener ugc nofollow" target="_blank">https://github.com/nodeshift/opossum/blob/master/lib/circuit.js</a></span><span id="72ef" class="ml lt iq my b gy ng nd l ne nf">call (context, ...rest) {<br/>  <br/>    //emit('fire');</span><span id="575a" class="ml lt iq my b gy ng nd l ne nf">if (CACHE.get(this) !== undefined) {<br/>      // emit('cacheHit') and return cache value<br/>    } else if (this.options.cache) {<br/>      // emit('cacheMiss');<br/>    }</span><span id="436d" class="ml lt iq my b gy ng nd l ne nf">if (!this.closed &amp;&amp; !this.pendingClose) {<br/>      // CB is closed emit('reject', error);<br/>    }<br/>    // emit ('success') if done<br/>    // emit ('timeout') if not done<br/>    // emit ('failure') if not done</span><span id="97dc" class="ml lt iq my b gy ng nd l ne nf">  }</span></pre><p id="b6cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码中出现了以下关键点。<br/> 1。一进入函数<br/> 2就发出fire事件。如果启用了缓存，并且我们命中了缓存，我们将返回缓存的值<br/> 3。如果我们未命中缓存，则发出缓存未命中事件<br/> 4。如果断路器未闭合，发出拒绝事件<br/> 5。如果函数成功，增加当前窗口的成功计数器。<br/> 6。如果发生超时或失败，则发出失败和超时事件，</p><h2 id="58ce" class="ml lt iq bd lu mm mn dn ly mo mp dp mc le mq mr me li ms mt mg lm mu mv mi mw bi translated">收集窗口统计信息</h2><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="31ec" class="ml lt iq my b gy nc nd l ne nf">//copied from line 93<br/>// <a class="ae lr" href="https://github.com/nodeshift/opossum/blob/master/lib/status.js" rel="noopener ugc nofollow" target="_blank">https://github.com/nodeshift/opossum/blob/master/lib/circuit.js</a></span><span id="7ac8" class="ml lt iq my b gy ng nd l ne nf">// Function that return the default values for a bucket<br/>const bucket = _ =&gt; ({  <br/>failures: 0,  <br/>fallbacks: 0,  <br/>successes: 0,  <br/>rejects: 0,  <br/>fires: 0,  <br/>timeouts: 0,  <br/>cacheHits: 0,  <br/>cacheMisses: 0,  <br/>semaphoreRejections: 0,  <br/>percentiles: {},  <br/>latencyTimes: []});</span><span id="5faf" class="ml lt iq my b gy ng nd l ne nf">get stats () {<br/>    const totals = this[WINDOW].reduce((acc, val) =&gt; {<br/>      if (!val) { return acc; }<br/>      Object.keys(acc).forEach(key =&gt; (acc[key] += val[key] || 0));<br/>      return acc;<br/>    }, bucket());</span><span id="a165" class="ml lt iq my b gy ng nd l ne nf">return totals;<br/>  }</span></pre><p id="7e00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请求来自负鼠的统计数据会从由<strong class="kx ir">滚动计数桶</strong>选项设置的桶中聚集统计数据。它只是将窗口中的所有值相加，并返回一个包含所有总和的对象。</p><h2 id="d526" class="ml lt iq bd lu mm mn dn ly mo mp dp mc le mq mr me li ms mt mg lm mu mv mi mw bi translated">失败</h2><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="3799" class="ml lt iq my b gy nc nd l ne nf">//this code looks almost same lol from line 678 -703<br/><a class="ae lr" href="https://github.com/nodeshift/opossum/blob/master/lib/circuit.js" rel="noopener ugc nofollow" target="_blank">https://github.com/nodeshift/opossum/blob/master/lib/circuit.js</a></span><span id="b787" class="ml lt iq my b gy ng nd l ne nf">function fail (circuit, err, args, latency) {</span><span id="72b4" class="ml lt iq my b gy ng nd l ne nf">circuit.emit('failure');</span><span id="4ba4" class="ml lt iq my b gy ng nd l ne nf">const stats = circuit.stats;<br/>  if ((stats.fires &lt; circuit.volumeThreshold) &amp;&amp; !circuit.halfOpen) return;<br/>  const errorRate = stats.failures / stats.fires * 100;<br/>  if (errorRate &gt; circuit.options.errorThresholdPercentage ||<br/>    circuit.halfOpen) {<br/>    circuit.open();<br/>  }<br/>}</span></pre><p id="df75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当代码失败时，我们从<strong class="kx ir"> stats() </strong>询问，并检查错误率是否小于我们设置的阈值。如果超过了阈值，我们就打开断路器。然后发出“打开”事件。</p><h2 id="3415" class="ml lt iq bd lu mm mn dn ly mo mp dp mc le mq mr me li ms mt mg lm mu mv mi mw bi translated">半开</h2><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="fe4d" class="ml lt iq my b gy nc nd l ne nf">//again a little stripped down code from line 178 -197<br/><a class="ae lr" href="https://github.com/nodeshift/opossum/blob/master/lib/circuit.js" rel="noopener ugc nofollow" target="_blank">https://github.com/nodeshift/opossum/blob/master/lib/circuit.js</a></span><span id="1f58" class="ml lt iq my b gy ng nd l ne nf">function _startTimer (circuit) {<br/>    return _ =&gt; {<br/>      const timer = circuit[RESET_TIMEOUT] = setTimeout(() =&gt; {<br/>        circuit[STATE] = HALF_OPEN;<br/>        circuit[PENDING_CLOSE] = true;<br/>        circuit.emit('halfOpen', circuit.options.resetTimeout);<br/>      }, circuit.options.resetTimeout);</span><span id="e1b7" class="ml lt iq my b gy ng nd l ne nf">};<br/>  }</span><span id="cb49" class="ml lt iq my b gy ng nd l ne nf">this.on('open', _startTimer(this));<br/>  this.on('success', _ =&gt; {<br/>    if (this.halfOpen) {<br/>      this.close();<br/>    }<br/>  });<br/> <br/>}</span></pre><p id="dc81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">半开如果断路器试图恢复时的状态。在这里，我们监听open事件，并在事件触发时立即启动计时器。超时完成后，我们检查是否将断路器的状态更改为半开。如果呼叫成功，我们关闭断路器并重置所有值。</p><h1 id="5719" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">TLDR:断路器</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2afd41b4c1011dd2274f5c3584d23612.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*BoEoaIgll6myOSZ3.png"/></div></figure><p id="c798" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">断路器在三种状态之间旋转:<br/> <strong class="kx ir">闭合:</strong>当断路器正常工作时。<br/> <strong class="kx ir">开:</strong>断路器跳闸时。<br/> <strong class="kx ir">半开:</strong>断路器试图恢复时。</p><p id="177d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事件的执行如下:<br/> 1:只要事件成功，断路器就保持闭合。<br/> 2。一旦呼叫超时或失败，就增加窗口中的错误计数。<br/> 3。如果窗口中的误差阈值增加到某个极限，那么我们使断路器跳闸。<br/> 4。在一定的间隔之后，断路器试图恢复并进入半开状态。<br/> 5。如果随后的呼叫失败，断路器回到打开状态。<br/> 6。如果随后的呼叫成功，断路器进入断开状态。</p><h1 id="27d8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在JavaScript项目中使用负鼠</h1><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="e668" class="ml lt iq my b gy nc nd l ne nf">const CircuitBreaker = require('opossum');<br/><br/>function asyncFunctionThatCouldFail (x, y) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    // Do something, maybe on the network or a disk<br/>  });<br/>}<br/><br/>const options = {<br/>  timeout: 3000, // If our function takes longer than 3 seconds, trigger a failure<br/>  errorThresholdPercentage: 50, // When 50% of requests fail, trip the circuit<br/>  resetTimeout: 30000 // After 30 seconds, try again.<br/>};</span><span id="f457" class="ml lt iq my b gy ng nd l ne nf">const breaker = new CircuitBreaker(asyncFunctionThatCouldFail, options);<br/><br/>breaker.fire(params)<br/>  .then(console.log)<br/>  .catch(console.error);</span></pre><p id="b176" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">脚注:每个<code class="fe ni nj nk my b">npm install</code>都是添加到服务器内存和CPU利用率上的成本。深入了解你安装的库，不仅可以帮你节省成本，还可以发现瓶颈，让你有效的使用库。</p><h2 id="6e33" class="ml lt iq bd lu mm mn dn ly mo mp dp mc le mq mr me li ms mt mg lm mu mv mi mw bi translated">简单英语的JavaScript</h2><p id="b285" class="pw-post-body-paragraph kv kw iq kx b ky nl jr la lb nm ju ld le nn lg lh li no lk ll lm np lo lp lq ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">plain English . io</strong></a>找到所有内容的链接！</p></div></div>    
</body>
</html>