<html>
<head>
<title>Algorithms 101: House Robber in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:JavaScript中的入室抢劫犯</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-house-robber-in-javascript-da3e6ee36241?source=collection_archive---------1-----------------------#2019-09-26">https://javascript.plainenglish.io/algorithms-101-house-robber-in-javascript-da3e6ee36241?source=collection_archive---------1-----------------------#2019-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06d0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉LeetCode，第7集，数组操作。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/ee493ef8dc3cbfd8393c2bee14b488c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*kdH-vmjHNxV0Zc8K.jpg"/></div></figure><p id="81c0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有个强盗逍遥法外！他做过功课，所以他知道这个街区每栋房子的贵重物品的市价。这是LeetCode上的描述。<a class="ae lj" href="https://leetcode.com/problems/house-robber/" rel="noopener ugc nofollow" target="_blank">这是链接。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lk"><img src="../Images/28f4f7336d9b3d9697708ba969f2bf63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14pXG0xpQ7sbq1W37nqPbg.png"/></div></div></figure><p id="b087" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这绝对属于容易的范畴，但是Noob并不觉得容易。我和一些朋友一起研究过这个，事实上我们都不觉得它容易！</p><p id="f10e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我的第一个猜测是——也许我们应该把所有偶数的房子和所有奇数的房子加起来，然后选择最大的。这种策略对上面的测试案例有效。不幸的是，它在很多情况下都不起作用。</p><p id="2533" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，在此数组中:</p><p id="fdaa" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lp lq lr ls b">array = [1, 9, 6, 3, 2, 7, 9]</code></p><p id="e8ff" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">偶数索引(数组[0]，数组[2]等)加起来是18；奇数指数加起来是19。但是如果你是cherrypick，你可以选择9s和3，总共21个。</p><h1 id="2215" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">那么，我们如何在代码中选择呢？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/e1db7782e336cfb9095deda55e611fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/0*x_vIb1nqE-Qfzz9m"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">very carefully …</figcaption></figure><p id="032d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我的视觉方法是寻找最大的数字，在心里避开它旁边的数字，然后选择剩下的最大数字，等等。这种方法对我们不起作用，因为它只考虑最大的数字，而不考虑旁边的数字。它没有考虑这样的数组:</p><p id="cb94" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lp lq lr ls b">[ 1, 9, 9, 8, 4, 3]</code></p><p id="5f72" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个数组中，我们有两个9，但显然，我们最好选择前九个，因为这样，我们仍然可以选择8。因此，在这两个大值之间进行选择的方法是在它们两边的值的上下文中进行比较。</p><p id="84dd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们考虑选择最大的数字，如果有几个数字，选择周围值最小的一个。在我们…对其他解决方案进行逆向工程之前，我们很难让这种方法发挥作用。</p><h1 id="faf5" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">逆向工程——比放弃更好</h1><p id="5393" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">我们找到的解决方案从数组的开始一次考虑三个数字，而不是从数组的中间选择最大值。我们是这样做的:</p><p id="0a07" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设数组中至少有两个数字(只有一个和两个数字的数组是我们稍后将处理的边缘情况)，我们设置一个新的数组，<em class="mv"> sorter </em>，在这里我们可以计算我们的变化量。</p><p id="3a99" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们首先将nums数组中的第一个数字添加到排序器中。然后，我们考虑nums数组中的第二个数字。既然相邻，就不能两个都选；我们将挑选两者中较大的一个，并把它放在分类器的末端。</p><p id="f132" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是我们目前掌握的情况:</p><pre class="kg kh ki kj gt mw ls mx my aw mz bi"><span id="232f" class="na lu iq ls b gy nb nc l nd ne">let nums = [1, 5, 9, 4, 2, 20, 3, 7]<br/>var rob = function(nums) {</span><span id="a63e" class="na lu iq ls b gy nf nc l nd ne">    //deal with edge cases here</span><span id="678c" class="na lu iq ls b gy nf nc l nd ne">    //compare first two numbers of array, pick greater value<br/>    let sorter = []<br/>        sorter[0] = nums[0]<br/>        // =&gt; [ 1 ]</span><span id="ca6f" class="na lu iq ls b gy nf nc l nd ne">        sorter[1] = Math.max(nums[1], nums[0])<br/>        // =&gt; [1, 5]</span><span id="6a91" class="na lu iq ls b gy nf nc l nd ne">}</span></pre><p id="013f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在评估了数组的前两个数字后，我们决定房子#2是更好的选择，其可抢劫值为5。</p><p id="e76d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是我们想记住房子#1，以防房子#1的价值加上当前房子的价值(如果我们选择房子#2，我们必须避免这种情况)，加起来超过5。</p><p id="d9b4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下面的代码中，如果我们从房子#1作为<em class="mv">选项a开始，我们将节省我们的最大收获。</em>如果我们从2号房屋开始作为<em class="mv">选项，我们将节省最大的收获。</em></p><p id="7364" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们把我们正在循环的项目，<em class="mv"> nums[i] </em>当作当前的<em class="mv"/>。</p><p id="52ea" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我们决定是否在没有的情况下抢劫<em class="mv">当前时，我们需要考虑:是选择我们<em class="mv">选项A </em>的最大收获加上<em class="mv">当前没有</em>的最大收获，还是选择我们其他可能的<em class="mv">选项B </em>的最大收获，其中不包括<em class="mv">当前没有</em>的最大收获更有价值？然后，我们将这两个值中较大的一个添加到我们的<em class="mv">排序器</em>数组的末尾:</em></p><pre class="kg kh ki kj gt mw ls mx my aw mz bi"><span id="7bbf" class="na lu iq ls b gy nb nc l nd ne">for(let i = 2; i &lt; nums.length; i++){<br/>        let optionA = sorter[i-2]<br/>        let optionB = sorter[i-1]     <br/>        let currentHouse = nums[i]<br/>                <br/>        if(option A + currentHouse &gt; optionB){ <br/>            sorter[i] = optionA + currentHouse <br/>        }  else { <br/>           sorter[i] = optionB <br/>        }</span></pre><p id="baf1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看看这一系列num是如何发挥作用的:</p><pre class="kg kh ki kj gt mw ls mx my aw mz bi"><span id="59df" class="na lu iq ls b gy nb nc l nd ne"> [1, 5, 9, 4, 2, 20, 3, 7]</span></pre><p id="ea16" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">排序器从[ 1，5]开始</p><p id="6be9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们考虑第三个房子。我们是通过抢劫房子#3(价值9)并将其添加到房子#1(价值1)中获得更多的钱，还是应该坚持房子#2(价值5)？由于1 + 9或10大于5，我们将在<em class="mv">排序器</em>的末尾加上10:</p><p id="2dbf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lp lq lr ls b">sorter: [ 1, 5, 10]</code></p><p id="e8f4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，让我们看看4号房子。同样，我们是通过抢夺房子#4(值4)并将其添加到<em class="mv">选项A </em>(不包括房子#3的收获)来获得更多的金钱，还是应该跳过当前房子并坚持使用<em class="mv">选项B </em>(包括房子#3的收获)。由于<em class="mv">选项A </em> + <em class="mv">当前值</em> (5 + 4)小于<em class="mv">选项B </em> (10)，我们将10(较大的值)放在<em class="mv">排序器</em>的末尾。</p><p id="a59f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lp lq lr ls b">sorter [1, 5, 11, 10]</code></p><h1 id="9a4a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">秘密武器</h1><p id="e0ca" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">如果你跟不上其他菜鸟，不仅仅是你。但是——这里有一个秘密武器！(感谢Cynthia Eddy给我指出这一点！)</p><p id="e18d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">即使你没有使用Python，你也可以使用<a class="ae lj" href="http://pythontutor.com/" rel="noopener ugc nofollow" target="_blank">PythonTutor.com</a>来运行多种语言的代码，让它一行一行地遍历代码，这样你就能确切地看到发生了什么。(当您登陆该页面时，点击“可视化您的代码…”链接，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ng"><img src="../Images/d35cedae7f985a5c52d5914809bf82f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1T8d4kdfR1-kSJIp9g6YUw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">click Visualize your code on the PythonTutor.com page</figcaption></figure><p id="5034" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">选择你的语言，用input输入你的代码，调用代码，然后点击‘可视化执行’。</p><p id="1efd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下一页，单击“前进”按钮，逐句通过您的代码。当您这样做时，它会填充代码中的值。</p><p id="cdbb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">nums数组位于顶部下方；分类器在底部。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nh"><img src="../Images/857e1e63ad9a155bf646a3d229808d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ewVNCvdvvsKBDfryKTreqw.png"/></div></div></figure><p id="d375" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是我们的代码，包括一个处理边缘情况的if语句:</p><pre class="kg kh ki kj gt mw ls mx my aw mz bi"><span id="f1c2" class="na lu iq ls b gy nb nc l nd ne">var rob = function(nums) {<br/>    if(nums.length === 1){<br/>        return nums[0]<br/>    } else if(nums.length === 0){<br/>        return 0<br/>    }<br/>    <br/>    let sorter = []<br/>    sorter[0] = nums[0]<br/>    sorter[1] = Math.max(nums[1], nums[0])</span><span id="ec3b" class="na lu iq ls b gy nf nc l nd ne">    for(let i = 2; i &lt; nums.length; i++){<br/>        let optionA = sorter[i-2]<br/>        let optionB = sorter[i-1]     <br/>        let currentHouse = nums[i]<br/>                <br/>        if(optionA + currentHouse &gt; optionB){<br/>            sorter[i] = optionA + currentHouse<br/>        } else {<br/>            sorter[i] = optionB<br/>        }<br/>        <br/>    }<br/>    <br/>    return sorter[sorter.length-1]<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ni"><img src="../Images/20fe778f7b2d2dda731f7a2ab355f6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWgep_jXvlfRUM6Hz2uDXw.png"/></div></div></figure><h1 id="00c3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">重新因子！</h1><p id="27bb" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">感谢<a class="ae lj" href="https://medium.com/@bjcantlupe" rel="noopener">本杰明·坎特鲁普</a>(见评论)，感谢他对修复这个循环的建议。我们从来不需要排序器中的所有值，只需要最后两个值。因此，我们可以在排序器中只存储和更新两个值，而不是构建一个长数组，如下所示:</p><pre class="kg kh ki kj gt mw ls mx my aw mz bi"><span id="fba8" class="na lu iq ls b gy nb nc l nd ne">for(let i = 2; i &lt; nums.length; i++){<br/>        let optionA = sorter[0]<br/>        let optionB = sorter[1]     <br/>        let currentHouse = nums[i]<br/>        <br/>        sorter[0] = optionB;<br/>        sorter[1] = Math.max(optionA + currentHouse, optionB)<br/>    }<br/>    <br/>return sorter[1];</span></pre><p id="fbf7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的代码中，在我们声明变量之后，我们通过将sorter[0]设置为等于选项B(排序器中当前的最后一个值)来更新它。然后，我们将排序器1更新为<em class="mv">选项A +当前值</em>或<em class="mv">选项B </em>中的较大者，并且我们使用清理器<em class="mv"> Math.max() </em>来完成。</p><p id="9856" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在方法的最后，我们仍然返回sorter中的最后一个值。</p><p id="2276" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们的整个函数看起来像这样:</p><pre class="kg kh ki kj gt mw ls mx my aw mz bi"><span id="cead" class="na lu iq ls b gy nb nc l nd ne">var rob = function(nums) {<br/>    if(nums.length === 1){<br/>        return nums[0]<br/>    } else if(nums.length === 0){<br/>        return 0<br/>    }<br/>    <br/>    let sorter = []<br/>    sorter[0] = nums[0]<br/>    sorter[1] = Math.max(nums[1], nums[0])</span><span id="9310" class="na lu iq ls b gy nf nc l nd ne">    for(let i = 2; i &lt; nums.length; i++){<br/>        let optionA = sorter[0]<br/>        let optionB = sorter[1]     <br/>        let currentHouse = nums[i]<br/>        <br/>        sorter[0] = optionB;<br/>        sorter[1] = Math.max(optionA + currentHouse, optionB)<br/>    }<br/>    <br/>    return sorter[1];<br/>}</span></pre><p id="d964" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">效率更高，可读性更强，但速度仍然很快！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nj"><img src="../Images/753a352e623e58be14f02ac94707fe92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBToEDyiY-P0OzVSQCi_Tw.png"/></div></div></figure><p id="7232" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lj" href="https://medium.com/@joanrigdon/algorithms-101-best-time-to-buy-and-sell-stock-in-javascript-7a2249b29495" rel="noopener"> <em class="mv">接下来:算法101，# 8:JavaScript中买卖股票的最佳时机</em> </a></p><p id="2627" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="mv">以防你错过:</em> <a class="ae lj" href="https://medium.com/javascript-in-plain-english/algorithms-101-convert-roman-numerals-to-integers-in-javascript-d3aba86a43d4" rel="noopener"> <em class="mv">算法101，#6:在JavaScript中把罗马数字转换成整数</em> </a></p><p id="16b7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="mv">注:从技术上讲，一个不与任何人对抗就从房子里偷东西的人是窃贼！不是强盗。一个强盗抢劫一个人，一个窃贼从一个地方偷窃。</em></p><p id="8b67" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">版权所有琼·印第安纳·琳斯2019</p></div></div>    
</body>
</html>