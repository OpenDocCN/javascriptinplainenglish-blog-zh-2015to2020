<html>
<head>
<title>A Complete Guide to Vue Lifecycle Hooks in Vue3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue3中Vue生命周期挂钩的完整指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-complete-guide-to-vue-lifecycle-hooks-in-vue3-3861d78033ba?source=collection_archive---------9-----------------------#2020-12-27">https://javascript.plainenglish.io/a-complete-guide-to-vue-lifecycle-hooks-in-vue3-3861d78033ba?source=collection_archive---------9-----------------------#2020-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c8194680e2d49f4258d0c45123e7b5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GY1YFjQukxpDzaZm"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@sonjalangford?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sonja Langford</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="9845" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae jd" href="https://learnvue.co/2020/02/building-the-same-component-in-vue2-vs-vue3" rel="noopener ugc nofollow" target="_blank">的生命周期挂钩Vue2和Vue3 </a>工作非常<strong class="kf jh">相似</strong>——我们仍然可以访问相同的挂钩，我们仍然希望将它们用于相同的用例。</p><p id="d2c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的项目使用Options API，我们不需要为我们的Vue生命周期钩子修改任何代码。这是因为Vue3被设计成<strong class="kf jh">兼容</strong>先前版本的Vue。</p><p id="25a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，当我们决定使用组合API时，我们访问这些钩子的方式有一点不同——这在<strong class="kf jh">更大的Vue项目中特别有用。</strong></p><p id="2698" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到本文结束时，您将知道如何在Options API和Composition API中使用生命周期挂钩，并开始编写更好的代码。</p><p id="e698" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们走吧！</p><p id="1ef0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">目录</strong></p><ol class=""><li id="70ff" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">什么是Vue生命周期挂钩</li><li id="4aa4" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在选项API中使用Vue生命周期挂钩</li><li id="9414" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在组合API中使用Vue3生命周期挂钩</li><li id="6f72" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">将Vue2代码更新到Vue3生命周期挂钩</li><li id="a073" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">看看Vue2和Vue3中的每个生命周期挂钩</li><li id="aa17" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">创作挂钩</li><li id="a773" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">安装挂钩</li><li id="61da" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">更新挂钩</li><li id="2f0f" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">破坏钩</li><li id="46cf" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">激活挂钩</li><li id="1872" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Vue3中的新调试挂钩</li><li id="451a" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">结论</li></ol><h2 id="0146" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">什么是Vue生命周期挂钩</h2><p id="2c0c" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">首先，让我们看一下Vue3生命周期挂钩图，包括选项API和组合API。在我们深入细节之前，这应该给出了正在发生的事情的高层次概述。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/a365e7222095398bd6c454fd2f8b005c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VJAOykVsjRsNB7EV.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source: LearnVue</figcaption></figure><p id="90c3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，每个主要的Vue生命周期事件被分成两个钩子，分别在事件之前和之后调用。您可以在Vue应用中利用四个主要事件(8个主要挂钩)。</p><ul class=""><li id="3340" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la ms lh li lj bi translated">创建-在组件的创建上运行</li><li id="6b8b" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated">挂载—在DOM挂载时运行</li><li id="1c18" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated">更新—在修改反应数据时运行</li><li id="4b2b" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated">销毁—在元素被销毁之前运行。</li></ul><h2 id="b8d6" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">在选项API中使用我们的Vue生命周期挂钩</h2><p id="eae4" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">有了Options API，我们的生命周期挂钩在我们的Vue实例上作为options 公开。我们不需要导入任何东西，我们只需要调用方法并为生命周期钩子编写代码。</p><p id="fc2b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设我们想要访问我们的<code class="fe mt mu mv mw b">mounted()</code>和<code class="fe mt mu mv mw b">updated()</code>生命周期挂钩。它可能看起来像这样。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="bb71" class="lp lq jg mw b gy nb nc l nd ne">&lt;script&gt;     <br/>   export default {         <br/>      mounted() {             <br/>         console.log('mounted!')         <br/>      },         <br/>      updated() {             <br/>         console.log('updated!')         <br/>      }     <br/>   }<br/>&lt;/script&gt;</span></pre><p id="67a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，对吧？</p><p id="12c0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧。让我们继续在组合API中使用Vue 3生命周期挂钩。</p><h2 id="327b" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">在Vue3组合API中使用我们的Vue生命周期挂钩</h2><p id="9938" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在组合API中，我们必须在使用生命周期挂钩之前将其导入到我们的项目中。这有助于保持项目尽可能的轻量级。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="d1ae" class="lp lq jg mw b gy nb nc l nd ne">import { onMounted } from 'vue'</span></pre><p id="5047" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了<code class="fe mt mu mv mw b">beforeCreate</code>和<code class="fe mt mu mv mw b">created</code>(由<code class="fe mt mu mv mw b">setup</code>方法本身代替)之外，我们可以在我们的设置方法中访问9个选项API生命周期钩子</p><ul class=""><li id="ef8e" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onBeforeMount</code> -安装开始前调用</li><li id="fb36" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onMounted</code> -安装部件时调用</li><li id="1e67" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onBeforeUpdate</code> -当反应数据改变时和重新渲染前调用</li><li id="2b57" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onUpdated</code> -重新渲染后调用</li><li id="17e7" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onBeforeUnmount</code> -在Vue实例被销毁之前调用</li><li id="21ac" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onUnmounted</code> -在实例被销毁后调用</li><li id="d689" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onActivated</code> -激活保活组件时调用</li><li id="f58a" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onDeactivated</code> -当保持激活的组件被停用时调用</li><li id="1b67" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">onErrorCaptured</code> -当从子组件捕获到错误时调用</li></ul><p id="70e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们导入它们并在代码中访问它们时，应该是这样的。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="52eb" class="lp lq jg mw b gy nb nc l nd ne">&lt;script&gt;<br/>import { onMounted } from 'vue'<br/><br/>export default {<br/>   setup () {<br/>     onMounted(() =&gt; {<br/>       console.log('mounted in the composition api!')<br/>     })<br/>   }<br/>}<br/>&lt;/script&gt;</span></pre><h2 id="7d2c" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">将Vue2代码更新为Vue3生命周期挂钩</h2><p id="21e4" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这种方便的Vue2到Vue3生命周期映射直接来自<a class="ae jd" href="https://vue-composition-api-rfc.netlify.com/api.html#watcheffect" rel="noopener ugc nofollow" target="_blank"> Vue3 Composition API文档</a>，我认为这是了解事物将如何变化以及我们如何使用它们的最有用的方法之一。</p><ul class=""><li id="7227" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la ms lh li lj bi translated"><code class="fe mt mu mv mw b">beforeCreate</code> - &gt;使用<code class="fe mt mu mv mw b">setup()</code></li><li id="8c9d" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">created</code> - &gt;使用<code class="fe mt mu mv mw b">setup()</code></li><li id="2d80" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">beforeMount</code> - &gt; <code class="fe mt mu mv mw b">onBeforeMount</code></li><li id="c3fb" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">mounted</code> - &gt; <code class="fe mt mu mv mw b">onMounted</code></li><li id="49b2" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">beforeUpdate</code>-&gt;T21</li><li id="9cba" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">updated</code> - &gt; <code class="fe mt mu mv mw b">onUpdated</code></li><li id="6d2c" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">beforeDestroy</code> - &gt; <code class="fe mt mu mv mw b">onBeforeUnmount</code></li><li id="80c6" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">destroyed</code> - &gt; <code class="fe mt mu mv mw b">onUnmounted</code></li><li id="dade" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la ms lh li lj bi translated"><code class="fe mt mu mv mw b">errorCaptured</code> - &gt; <code class="fe mt mu mv mw b">onErrorCaptured</code></li></ul><h2 id="e99b" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">深入了解每个生命周期挂钩</h2><p id="a084" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们现在明白了两件重要的事情:</p><ol class=""><li id="62a2" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">我们可以使用的不同生命周期挂钩</li><li id="00de" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如何在选项API和合成API中使用它们</li></ol><p id="3cb3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更深入地了解每个生命周期钩子，看看它们是如何使用的，我们可以在每个钩子中编写什么样的代码，以及它们在选项API和组合API中的区别。</p><h2 id="6115" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">创建钩子——虚拟企业生命周期的开始</h2><p id="7b99" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">创建钩子是程序中第一个运行的东西。</p><h2 id="7cdc" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf"> beforeCreate() —选项API </em></h2><p id="c987" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">因为创建的钩子是初始化所有反应数据和事件的东西，<code class="fe mt mu mv mw b">beforeCreate</code>不能访问任何组件的反应数据和事件。</p><p id="1384" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下面的代码块为例:</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="63c1" class="lp lq jg mw b gy nb nc l nd ne">export default {<br/>   data() { <br/>     return { <br/>       val: 'hello'    <br/>     }<br/>   },<br/>   beforeCreate() {     <br/>     console.log('Value of val is: ' + this.val)   <br/>   }<br/>}</span></pre><p id="bfe2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为数据还没有初始化，<code class="fe mt mu mv mw b">val</code>的输出值是<code class="fe mt mu mv mw b">undefined</code>。您也不能在这个方法中调用组件方法。</p><p id="fb60" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想查看可用内容的完整列表，我建议您只需运行<code class="fe mt mu mv mw b">console.log(this) </code>来查看已经初始化的内容。当使用Options API时，这在其他钩子中也很有用。</p><p id="a722" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您需要某种不需要分配给数据的逻辑/API调用时，使用<code class="fe mt mu mv mw b">beforeCreate</code>钩子非常有用。因为如果我们现在给数据赋值，一旦状态被初始化，数据就会丢失。</p><h2 id="8805" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf"> created() —选项API </em></h2><p id="d4d5" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们现在可以访问组件的数据和事件。因此，修改上面的示例，使用<code class="fe mt mu mv mw b">created</code>而不是<code class="fe mt mu mv mw b">beforeCreate</code>，我们可以看到输出是如何变化的。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="7b2c" class="lp lq jg mw b gy nb nc l nd ne">export default {<br/>   data() { <br/>     return { <br/>       val: 'hello'    <br/>     }<br/>   },<br/>   created() {     <br/>     console.log('Value of val is: ' + this.val)   <br/>   }<br/>}</span></pre><p id="6b5b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样的输出将会是<code class="fe mt mu mv mw b">Value of val is: hello</code>，因为我们已经初始化了我们的数据。</p><p id="0ee9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当处理读/写反应数据时，使用创建的方法是有用的。例如，如果您想进行一个API调用，然后存储该值，那么这里就是这样做的地方。</p><p id="753e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里做比在mounted中做更好，因为它在Vue的同步初始化过程中发生得更早，您可以执行所有您想要的数据读/写。</p><h2 id="afd3" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">复合API创建挂钩呢？</h2><p id="858a" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">对于使用组合API的Vue3生命周期挂钩，<code class="fe mt mu mv mw b">beforeCreate</code>和<code class="fe mt mu mv mw b">created</code>都被<code class="fe mt mu mv mw b">setup()</code>方法替换。这意味着您将放在这些方法中的任何代码现在都在您的setup方法中。</p><p id="9133" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们刚刚在创建的生命周期挂钩中编写的代码将被重写为这样。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="942d" class="lp lq jg mw b gy nb nc l nd ne">import { ref } from 'vue'<br/><br/>export default {<br/>   setup() {    <br/>     const val = ref('hello') <br/>     console.log('Value of val is: ' + val.value)       <br/>     return {         <br/>       val<br/>     }<br/>   }<br/>}</span></pre><h2 id="5192" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">挂载钩子—访问DOM</h2><p id="358a" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这些安装钩处理<strong class="kf jh">组件的安装和渲染</strong>。这些是项目和应用程序中最常用的挂钩。</p><h2 id="a7eb" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf"> beforeMount()和onBeforeMount() </em></h2><p id="bd5d" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在组件DOM实际呈现和挂载之前调用。在这一步中，根元素尚不存在。在选项API中，这可以使用<code class="fe mt mu mv mw b">this.$el</code>来访问。在组合API中，为了做到这一点，您必须在根元素上使用一个<code class="fe mt mu mv mw b">ref</code>。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="66c8" class="lp lq jg mw b gy nb nc l nd ne">export default {<br/>   beforeMount() {<br/>     console.log(this.$el)<br/>   }<br/> }</span></pre><p id="a0b5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用refs的合成模板如下所示。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="2c35" class="lp lq jg mw b gy nb nc l nd ne">&lt;template&gt;<br/>   &lt;div ref='root'&gt;<br/>     Hello World<br/>   &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="087e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，相应的脚本尝试访问ref。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="5805" class="lp lq jg mw b gy nb nc l nd ne">import { ref, onBeforeMount } from 'vue'<br/><br/>export default {<br/>   setup() {<br/>      const root = ref(null) <br/>      onBeforeMount(() =&gt; {   <br/>         console.log(root.value) <br/>      }) <br/>      return { <br/>         root<br/>      }<br/>    },<br/>    beforeMount() {<br/>      console.log(this.$el)<br/>    }<br/> }</span></pre><p id="f03d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe mt mu mv mw b">app.$el</code>尚未创建，输出将是未定义的。</p><p id="43e0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然最好使用<code class="fe mt mu mv mw b">created()</code> / <code class="fe mt mu mv mw b">setup()</code>来执行API调用，但这确实是最后一步，因为这是在创建之后，所以在过程的后期不必要调用它们之前，它们可以访问相同的组件变量。</p><h2 id="26e0" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf">已安装()和未安装()</em></h2><p id="4d7e" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在组件第一次呈现后立即调用。该元素现在是可用的，允许直接DOM访问。</p><p id="d0d0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，在Options API中，我们可以使用<code class="fe mt mu mv mw b">this.$el</code>来访问我们的DOM，而在Composition API中，我们需要使用refs来访问Vue生命周期钩子中的DOM。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="1f48" class="lp lq jg mw b gy nb nc l nd ne">import { ref, onMounted } from 'vue'<br/> <br/><br/> export default {<br/>   setup() {    /* Composition API */<br/> <br/>     const root = ref(null)<br/> <br/>     onMounted(() =&gt; {<br/>       console.log(root.value)<br/>     })<br/> <br/><br/>     return {<br/>       root<br/>     }<br/>   },<br/>   mounted() { /* Options API */<br/>     console.log(this.$el)<br/>   }<br/> }</span></pre><h2 id="40b8" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">更新挂钩VueJS生命周期中的反应</h2><p id="cdbe" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">每当修改反应数据时，都会触发更新的生命周期事件，从而触发渲染更新。</p><h2 id="9c0a" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf"> beforeUpdate()和onBeforeUpdate() </em></h2><p id="e7ff" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在数据更改和组件重新呈现之前运行。这是在发生任何变化之前手动更新DOM的好地方。例如，您可以删除事件侦听器。</p><p id="c9af" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mw b">beforeUpdate</code>可用于跟踪对组件的编辑次数，甚至跟踪创建“撤销”功能的动作。</p><h2 id="2372" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf">已更新()和未更新()</em></h2><p id="8a23" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">一旦DOM被更新，updated方法就会调用。下面是一些同时使用beforeUpdate和updated的起始代码。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="214f" class="lp lq jg mw b gy nb nc l nd ne">&lt;template&gt;<br/>    &lt;div&gt;<br/>      &lt;p&gt;| edited {{ count }} times&lt;/p&gt;<br/>      &lt;button @click='val = Math.random(0, 100)'&gt;Click to Change&lt;/button&gt;<br/>    &lt;/div&gt;<br/> &lt;/template&gt;</span></pre><p id="ae87" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用相应的脚本。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="7755" class="lp lq jg mw b gy nb nc l nd ne">export default {<br/>   data() {<br/>      return {<br/>        val: 0<br/>      }<br/>   },<br/>   beforeUpdate() {<br/>      console.log("beforeUpdate() val: " + this.val)<br/>   },<br/>   updated() {<br/>      console.log("updated() val: " + this.val<br/>   }<br/> }</span></pre><p id="c3c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运筹学</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="75e5" class="lp lq jg mw b gy nb nc l nd ne">import { ref, onBeforeUpdate, onUpdated } from 'vue'<br/> <br/> export default {<br/>   setup () {<br/>     const count = ref(0)<br/>     const val = ref(0)<br/> <br/>     onBeforeUpdate(() =&gt; {<br/>       count.value++;<br/>       console.log("beforeUpdate");<br/>     })<br/> <br/>     onUpdated(() =&gt; {<br/>       console.log("updated() val: " + val.value)<br/>     })<br/> <br/>     return {<br/>       count, val<br/>     }<br/>   }<br/> }</span></pre><p id="c729" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些方法很有用，但是对于很多用例，我们可能要考虑使用观察器来检测这些数据变化。观察器很好，因为它们给出了更改数据的旧值和新值。</p><p id="2d00" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种选择是使用计算值来改变基于元素的状态。</p><h2 id="71e6" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">破坏挂钩——清理东西</h2><p id="e023" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">组件的销毁钩用于移除组件和清理所有松散末端的过程中。现在是<a class="ae jd" href="https://learnvue.co/2020/01/a-vue-event-handling-cheatsheet-the-essentials/" rel="noopener ugc nofollow" target="_blank">删除事件监听器</a>和如果处理不当可能导致内存泄漏的东西的时候了。</p><h2 id="8fc8" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf"> beforeUnmount()和onBeforeUnmounted() </em></h2><p id="aec1" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">因为这是在组件开始拆卸之前，所以这是进行大部分(如果不是全部)清理工作的时候。在这个阶段，您的组件仍然是完全可用的，没有任何东西被破坏。</p><p id="5f84" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在选项API中，删除事件侦听器的示例如下所示。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="892b" class="lp lq jg mw b gy nb nc l nd ne">export default {<br/>   mounted() {<br/>     console.log('mount')<br/>     window.addEventListener('resize', this.someMethod);<br/>   },<br/>   beforeUnmount() {<br/>     console.log('unmount')<br/>     window.removeEventListener('resize', this.someMethod);<br/>   },<br/>   methods: {<br/>      someMethod() {<br/>         // do smth<br/>      }<br/>   }<br/>}</span></pre><p id="1126" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在组合API中</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="10e0" class="lp lq jg mw b gy nb nc l nd ne">import { onMounted, onBeforeUnmount } from 'vue' <br/><br/> export default {<br/>   setup () {<br/> <br/>     const someMethod = () =&gt; {<br/>       // do smth<br/>     }<br/> <br/>     onMounted(() =&gt; {<br/>       console.log('mount')<br/>       window.addEventListener('resize', someMethod);<br/>     })<br/> <br/>     onBeforeUnmount(() =&gt; {<br/>       console.log('unmount')<br/>       window.removeEventListener('resize', someMethod);<br/>     })<br/> <br/>   }<br/> }</span></pre><p id="0282" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是在Vite、vue-cli或任何支持热重载的开发环境中工作。当您的代码更新时，您的一些组件将卸载和安装它们自己..</p><h2 id="f433" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf">未安装的()和未安装的()</em></h2><p id="2ed4" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在这一点上，你的大部分组件和它的属性都消失了，所以你能做的不多。再一次，我会使用打印出一些数据来看看到底还有什么，以及它是否对你的项目有用。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="600e" class="lp lq jg mw b gy nb nc l nd ne">import { onUnmounted } from 'vue'<br/><br/>export default {<br/>  setup () { /* Composition API */<br/><br/>    onUnmounted(() =&gt; {<br/>      console.log('unmounted')<br/>    })<br/><br/>  },<br/>  unmounted() { /* Options API */<br/>    console.log('unmounted')<br/>  }<br/>}</span></pre><h2 id="f4c5" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">激活挂钩—管理保持活动状态的组件</h2><p id="50f3" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">一个<a class="ae jd" href="https://learnvue.co/2019/12/an-overview-of-vue-keep-alive/ https://learnvue.co/2020/04/a-beautiful-parallax-scrolling-effect-in-vuejs-daily-vue-tips-2/ https://learnvue.co/2020/01/getting-smart-with-vue-form-validation-vuelidate-tutorial/ https://learnvue.co/2020/01/build-a-custom-vuejs-tag-input-in-under-10-minutes/ https://learnvue.co/ https://learnvue.co/2020/02/building-the-same-component-in-vue2-vs-vue3/ https://learnvue.co/2020/01/4-vue3-composition-api-tips-you-should-know/ https://learnvue.co/2019/12/8-free-vue-icon-libraries-to-pretty-up-your-web-app/ https://learnvue.co/2020/02/how-and-why-to-use-wrapper-components-in-vue3/ https://learnvue.co/2020/04/animated-active-menu-highlights-in-vuejs-daily-vue-tips-1/ https://learnvue.co/2020/03/extract-and-reuse-logic-in-the-vue-composition-api/ https://learnvue.co/2020/01/7-simple-vuejs-tips-you-can-use-to-become-a-better-developer/ https://learnvue.co/2019/12/what-you-need-to-know-about-vue3-in-2020/ https://learnvue.co/2020/01/an-introduction-to-vuejs-suspense-components/ https://learnvue.co/2020/01/creating-your-first-vuejs-custom-directive/ https://learnvue.co/2020/09/a-quick-vue3-infinite-scrolling-component-daily-vue-tips-4/ https://learnvue.co/2020/09/an-introduction-to-vue-teleport-a-new-feature-in-vue3/ https://learnvue.co/2020/03/7-great-vue3-tutorials-and-resources-to-start-learning-today/ https://learnvue.co/2020/01/how-to-use-vuejs-filters-to-write-better-code/ https://learnvue.co/2020/03/using-vue-watcheffect-to-track-reactive-dependencies/ https://learnvue.co/2020/09/how-to-deploy-your-vue-app-to-github-pages/" rel="noopener ugc nofollow" target="_blank">保活标签是动态组件</a>的包装元素。它存储了对非活动组件的缓存引用，这样Vue就不必在每次动态组件改变时创建一个全新的实例。</p><p id="cea1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个特定的用例，Vue给了我们两个生命周期挂钩</p><h2 id="5b61" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf">激活()和未激活()</em></h2><p id="028b" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">每当保持活动状态的动态组件被“重新激活”时，就会调用该方法，这意味着它现在是动态组件的活动视图。</p><p id="e6d6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们使用keep-alive组件来管理不同的选项卡视图，那么每次我们在选项卡之间切换时，当前选项卡都会运行这个激活的钩子。</p><p id="d72e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有以下使用保活包装器的<a class="ae jd" href="https://learnvue.co/2020/01/an-overview-of-vuejs-dynamic-components/" rel="noopener ugc nofollow" target="_blank">动态组件设置</a>。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="95d8" class="lp lq jg mw b gy nb nc l nd ne">&lt;template&gt;<br/>   &lt;div&gt;<br/>     &lt;span @click='tabName = "Tab1"'&gt;Tab 1 &lt;/span&gt;<br/>     &lt;span @click='tabName = "Tab2"'&gt;Tab 2&lt;/span&gt;<br/>     &lt;keep-alive&gt;<br/>       &lt;component :is='tabName' class='tab-area'/&gt;<br/>     &lt;/keep-alive&gt;<br/>   &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import Tab1 from './Tab1.vue'<br/>import Tab2 from './Tab2.vue'<br/><br/>import { ref } from 'vue'<br/><br/>export default {<br/>  components: {<br/>    Tab1,<br/>    Tab2<br/>  },<br/>  setup () { /* Composition API */<br/>    const tabName = ref('Tab1')<br/><br/>    return {<br/>      tabName<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="2ee6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe mt mu mv mw b">Tab1.vue</code>组件中，我们可以像这样访问我们的激活钩子。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="9e67" class="lp lq jg mw b gy nb nc l nd ne">&lt;template&gt;<br/> &lt;div&gt;<br/> &lt;h2&gt;Tab 1&lt;/h2&gt;<br/> &lt;input type='text' placeholder='this content will persist!'/&gt;<br/> &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import { onActivated } from 'vue'<br/><br/>export default {<br/> setup() {<br/>    onActivated(() =&gt; {<br/>       console.log('Tab 1 Activated')<br/>    })<br/> }<br/>} <br/>&lt;/script&gt;</span></pre><h2 id="c427" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated"><em class="nf">停用()和未停用()</em></h2><p id="3ed6" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">正如您所猜测的，当一个保持活动状态的组件不再是动态组件的活动视图时，就会调用这个函数。</p><p id="47b8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个钩子对于一些用例很有用，比如当一个特定的视图失去焦点时保存用户数据和触发动画。</p><p id="0b1d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像这样抓住钩子。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="70da" class="lp lq jg mw b gy nb nc l nd ne">import { onActivated, onDeactivated } from 'vue'<br/><br/>export default {<br/>  setup() {<br/>    onActivated(() =&gt; {<br/>       console.log('Tab 1 Activated')<br/>    })<br/><br/>    onDeactivated(() =&gt; {<br/>       console.log('Tab 1 Deactivated')<br/>    })<br/>  }<br/>}</span></pre><p id="edac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们在选项卡之间切换时，每个动态组件的状态都将被缓存和保存。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/637063e8ec8f7ecfb6c4d19aa4f2930e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/0*kZ1YV_fOUbXeojRp.gif"/></div></div></figure><p id="9591" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！</p><h2 id="0e8f" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">Vue3调试挂钩</h2><p id="b4ec" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Vue3给了我们两个钩子，我们可以用它们来进行调试。它们是:</p><ol class=""><li id="5065" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe mt mu mv mw b">onRenderTracked</code></li><li id="83ad" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe mt mu mv mw b">onRenderTriggered</code></li></ol><p id="1869" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个事件都有一个DebuggerEvent，它允许我们判断是什么导致了Vue实例中的重新呈现。</p><pre class="mo mp mq mr gt mx mw my mz aw na bi"><span id="1200" class="lp lq jg mw b gy nb nc l nd ne">export default {<br/>    onRenderTriggered(e) {<br/>       debugger<br/>       // inspect which dependency is causing the component to re-render<br/>    }<br/>}</span></pre><h2 id="ec15" class="lp lq jg bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">结论</h2><p id="6c39" class="pw-post-body-paragraph kd ke jg kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">无论您决定使用Options API还是Composition API，重要的是不仅要知道使用什么生命周期挂钩，还要知道为什么使用它。</p><p id="adc0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于许多问题，多个生命周期挂钩是可行的。但是知道哪一个<strong class="kf jh">对你的用例来说是最好的</strong>还是很好的。无论如何，你应该考虑一下，并且有一个好的理由来选择一个特定的生命周期挂钩。</p><p id="cb50" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这能帮助你理解更多关于生命周期挂钩的知识，以及如何在你的项目中实现它们。</p><p id="3a9b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码快乐！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="5a37" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://learnvue.co/vue-3-essentials-cheatsheet/" rel="noopener ugc nofollow" target="_blank">如果你有兴趣了解更多关于Vue 3的知识，下载我的免费的Vue 3备忘单，里面有基本的知识，比如组合API、Vue 3模板语法和事件处理。</a></p></div></div>    
</body>
</html>