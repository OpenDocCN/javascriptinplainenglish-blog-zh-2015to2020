<html>
<head>
<title>Scheduling in React 16.x</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 16.x中的调度</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/scheduling-in-react-16-x-a6108db99208?source=collection_archive---------1-----------------------#2020-06-24">https://javascript.plainenglish.io/scheduling-in-react-16-x-a6108db99208?source=collection_archive---------1-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09d683e5c81830e411109a9184b85861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JvYv8Dj7DKge6VCEq7y8Q.jpeg"/></div></div></figure><h1 id="a0d1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是调度程序？</h1><p id="171f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">先说一些理论。</p><p id="929b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">JavaScript是一种单线程语言。这意味着我们有一个调用堆栈，它可以同时执行一段代码。在执行代码的过程中，浏览器需要执行一种不同的工作。这包括:</p><ul class=""><li id="8b49" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">管理事件(用户点击处理程序，<em class="mi"> setTimeout </em>回调等)。)</li><li id="8a98" class="lz ma iq ky b kz mj ld mk lh ml ll mm lp mn lt me mf mg mh bi translated">布局计算(建筑DOM / CSSOM)和</li><li id="0725" class="lz ma iq ky b kz mj ld mk lh ml ll mm lp mn lt me mf mg mh bi translated">重画(基于布局计算)</li></ul><p id="0fe0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们把重点放在最后一个。在一秒钟内，浏览器通常会重画60次，这意味着每16.6毫秒就有一次重画(或多或少，取决于环境)。</p><p id="6086" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当你运行一段同步代码大约一秒钟的时候，你会意外地丢失大约60帧，这会导致延迟，影响UX，让你的应用程序没有反应。</p><p id="68f4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，调度器的主要目标是平衡浏览器中正在执行的所有活动，不要让它们中的任何一个挨饿，同时保持你的应用程序的重画意识。</p><p id="2b18" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是，作为开发者，我们应该关心吗？毫无疑问，我们应该意识到这个问题。如今，在开发我们的应用程序时，我们将相当多的职责外包给第三方实体。</p><p id="d26e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Web框架为我们做了很多，它们管理路由和状态，提供变化检测机制，双向数据绑定(Angular/Vue.js)，直接更新DOM，等等。它们充当我们和浏览器之间的中间件，所以它似乎是一个解决调度问题的好地方，对吗？</p><p id="27a2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">web框架就是这样做的。React也不例外(至少React 16.x是这样)。</p><h1 id="b97c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">尝试实现一个简单的调度程序</h1><p id="054a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我将解释React是如何管理它的，但是，为了理解潜在的问题，让我们编写一些简单的代码…</p><p id="05fd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们来模拟一个重度浏览器app:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3464" class="mx jz iq mt b gy my mz l na nb">setInterval(() =&gt; {<br/>    document.body.appendChild(document.createTextNode('hi'))<br/>}, 3)</span></pre><p id="1ad7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它迫使浏览器进行重画(由每3毫秒进行一次的DOM操作引起)。现在，考虑这段代码:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ac3a" class="mx jz iq mt b gy my mz l na nb">setInterval(() =&gt; {<br/>    document.body.appendChild(document.createTextNode('hi'))<br/>}, 3)</span><span id="8cb4" class="mx jz iq mt b gy nc mz l na nb">render()</span><span id="ce2d" class="mx jz iq mt b gy nc mz l na nb">function render() {<br/>    for (let i = 0; i &lt; 20; i++) {<br/>        performUnitOfWork()<br/>    }<br/>}</span><span id="e74c" class="mx jz iq mt b gy nc mz l na nb">function performUnitOfWork() {<br/>    sleep(5)<br/>}</span><span id="453a" class="mx jz iq mt b gy nc mz l na nb">function sleep(milliseconds) {<br/>    // sleep for given {milliseconds} period (synchronous)<br/>}</span></pre><p id="e8ca" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们的浏览器渲染机制有什么影响？嗯，<em class="mi">渲染</em>是同步的，所以冻结浏览器100ms (20 * 5ms = 100ms)。在这段时间内不能重新油漆。用户输入事件也不回调。让我们来看看Chrome对给定代码的“性能工具”输出:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/e371d08dc81648c95ae4c4a4fc63719a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3E_3nQonR5Q1VyjNHLAs5A.png"/></div></div></figure><p id="bb0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在本例中，我们丢帧超过100毫秒(见垂直虚线，它们显示帧何时结束)。如前所述，浏览器每隔16.6毫秒(每秒60帧)重画一次。在这种情况下，重画被延迟，这将冻结当时执行的任何动画。用户输入处理程序也会被延迟。这不是我们想要的，对吗？</p><p id="e866" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，让我们假设提供的<em class="mi">渲染</em>函数是渲染机制的React 15.x实现。在这个过程中，React跟踪变化，调用我们的生命周期方法，比较道具等。这是一个耗时的过程，可能需要很长时间来计算，尤其是在繁重的应用程序中。</p><p id="176a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">React 15.x到底有没有调度器机制？不，没有，所以我们的同步<em class="mi">渲染</em>函数和React 15.x渲染实现没有区别。</p><p id="6b3b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">互联网上有一个很好的例子，展示了React 15.x如何管理繁重的应用程序，其中包括大量的浏览器重画(调整大小)以及JavaScript计算(生命周期方法执行):</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/f130ddf7f3f78a999728b7101c326616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-PW6PWy8FC3lPYSch7ezhw.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">React 15.x render problems</figcaption></figure><p id="61ad" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这里看它是如何工作的<a class="ae nj" href="https://claudiopro.github.io/react-fiber-vs-stack-demo/stack.html" rel="noopener ugc nofollow" target="_blank">。安静的懒虫，对吧？让我们回到我们的例子…我们如何改进这种基于同步的渲染机制？增加<em class="mi"> setTimeout </em>怎么样？</a></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f69e" class="mx jz iq mt b gy my mz l na nb">...</span><span id="7f0e" class="mx jz iq mt b gy nc mz l na nb">function render() {<br/>    performUnitOfWork()<br/>    setTimeout(render, 0)<br/>}</span><span id="c3a3" class="mx jz iq mt b gy nc mz l na nb">...</span></pre><p id="32f0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">结果如何？</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/afbf06f850595892b6054e9ba8c01b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilMwuhXPhDSPZ9U17NfVVg.png"/></div></div></figure><p id="7c0a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">是的，好多了，我们的画面不再延迟了。我们的<code class="fe nl nm nn mt b"><em class="mi">performUnitOfWork</em></code>函数在每一帧上都被单独处理。重画是定期进行的——没有帧延迟。</p><p id="84ef" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">那么，这是React 16.x应用程序解决调度问题的方式吗？不完全是。在整个内部引擎重写(所谓的React Fiber)中，React团队引入了一个专用模块(“React Scheduler”)来解决调度问题。它是如何工作的？我将很快解释它，但首先—我们需要引入… <a class="ae nj" href="https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API" rel="noopener ugc nofollow" target="_blank">通道消息API </a>。</p><h1 id="6e60" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">基于消息通道的调度</h1><p id="4b27" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">它做的事情很简单。它允许你在不同的JavaScript上下文中进行通信，例如，在你的代码和iframe之间，或者在你的代码和web worker的上下文之间。</p><p id="cff9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">考虑下面的例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="fc5c" class="mx jz iq mt b gy my mz l na nb">// index.html<br/>&lt;iframe src="iframe-page.html"&gt;&lt;/iframe&gt;</span><span id="5685" class="mx jz iq mt b gy nc mz l na nb">&lt;script&gt;<br/>var iframe = document.querySelector('iframe')<br/>var channel = new MessageChannel()</span><span id="3723" class="mx jz iq mt b gy nc mz l na nb">iframe.addEventListener('load', () =&gt; {<br/>    channel.port1.onmessage = e =&gt; console.log(e.data)<br/>    iframe.contentWindow.postMessage('hi!', '*', [channel.port2])<br/>})<br/>&lt;/script&gt;</span><span id="8fc8" class="mx jz iq mt b gy nc mz l na nb">// iframe-page.html<br/>&lt;script&gt;<br/>window.addEventListener('message', event =&gt; {<br/>    console.log(event.data)<br/>    event.ports[0].postMessage(<br/>        'Message back from the IFrame'<br/>    )<br/>})<br/>&lt;/script&gt;</span></pre><p id="ba90" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您需要做的是在一个端口(<em class="mi"> port1 </em>)上设置一个监听器，并使用<em class="mi"> postMessage </em> API将另一个端口(<em class="mi"> port2 </em>，它将被发送方使用)转移到另一个上下文(即iframe)中。然后就可以双向交流了。</p><p id="47e9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是我们的app里需要和iframe或者WebWorker沟通吗？不尽然，但是API(除了通信能力之外)还有另一个优势。它让你友好地安排工作，尊重其他浏览器活动，如渲染，DOM计算等。</p><p id="f805" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">怎么会？通过所谓的“消息循环”机制。现在，让我用下面的代码替换前面同步<em class="mi">渲染</em>函数的实现:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a0e1" class="mx jz iq mt b gy my mz l na nb">setInterval(() =&gt; {<br/>    document.body.appendChild(document.createTextNode('hi'))<br/>}, 3)</span><span id="859c" class="mx jz iq mt b gy nc mz l na nb">const channel = new MessageChannel()</span><span id="e94f" class="mx jz iq mt b gy nc mz l na nb">render()</span><span id="528b" class="mx jz iq mt b gy nc mz l na nb">function render() {<br/>    channel.port1.onmessage = onMessageReceived<br/>    channel.port2.postMessage(null)<br/>}</span><span id="1b65" class="mx jz iq mt b gy nc mz l na nb">function onMessageReceived(event) {<br/>    performUnitOfWork()<br/>    channel.port2.postMessage(null)<br/>}</span><span id="3414" class="mx jz iq mt b gy nc mz l na nb">function performUnitOfWork() {<br/>    sleep(5)<br/>}</span></pre><p id="2b99" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们的渲染函数已更新，以利用MessageChannel API。我们刚刚创建了“消息循环”。在<em class="mi">端口2 </em>上发送消息(在<em class="mi">渲染</em>函数内)<em class="mi"> </em>强制<code class="fe nl nm nn mt b"><em class="mi">onmessage</em></code> <em class="mi"> ( </em>即<em class="mi"> onMessageReceived) </em>被调用，后者做一些计算(<code class="fe nl nm nn mt b"><em class="mi">performUnitOfWork</em></code>)。然后，它再次强制在<em class="mi">端口2 </em>上发送一条消息，最终……是的……你看到模式了，对吗？这就是消息循环的创建方式。</p><p id="db01" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们看看我们的性能概况:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/d51e0339c2f832c16d0813418e549d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9-yQ5NY6kNo_24rnkEVwg.png"/></div></div></figure><p id="dfb0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">每隔14毫秒/19毫秒重新油漆一次。在单帧期间，我们可以看到<em class="mi"> performUnitOfWork </em>甚至被执行了3次，这比<em class="mi"> setTimeout </em>方法要好。更重要的是，在<em class="mi"> setTimeout </em>解决方案中,“执行栏”之间有更多的空白空间，浏览器在那里什么也不做。在消息循环中不是这样。</p><h1 id="c3f8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">React 16.x中的调度</h1><p id="088d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有趣的部分来了。我刚刚向您描述了React Scheduler的最新实现是如何工作的。它使用MessageGlobal API来实现他们的浏览器内调度目标。与<code class="fe nl nm nn mt b"><em class="mi">setTimeout</em></code>实现相比，这种方法甚至更好，因为它最终能够在框架内执行更多的工作。</p><p id="0bf0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，这种方法需要将一个作品分割成更小的块。我们的示例实现<em class="mi"> render </em>函数执行大约5毫秒的计算(<code class="fe nl nm nn mt b"><em class="mi">performUnitOfWork</em></code>)。React实现也没有什么不同——它也将工作分成更小的块，在5毫秒内执行。</p><p id="bc30" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为什么我们要把执行分成更小的块呢？让主线程同时执行未决事件/重画/管理动画，这样就不会有UX延迟。</p><p id="b221" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">考虑这段React <a class="ae nj" href="https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1467-L1472" rel="noopener ugc nofollow" target="_blank">代码</a>:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/15c7b5924c9df46ea280f5168c1f8821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9mt-dUpiCVNtG8VHEIUiw.png"/></div></div></figure><p id="3226" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是React代码中最重要的片段之一。主工作循环。如前所述，React的最新版本(与React 15.x相反)允许你将工作分成小块(<em class="mi"> workInProgress </em>)。它们中的每一个都被逐一处理(<em class="mi"> performUnitOfWork </em>)，只要:</p><p id="ceb4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1.我们有些工作要做。== null  ) <br/> 2。并且<em class="mi"> shouldYield() </em>返回false。</p><p id="2d9a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如此多的同步工作正在<code class="fe nl nm nn mt b"><em class="mi">performUnitOfWork</em></code>中进行。这段代码来自React的“调解器”机制。如果你想了解更多React的工作原理，我强烈建议你搜索“React Fiber”短语。出于本文的目的，让我们假设<em class="mi"> performUnitOfWork </em>是一个遍历组件树、进行变更检测计算的函数，包括调用生命周期方法、副作用标记。这是一个反应渲染过程的核心。</p><p id="22e5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">React纤程的设计方式是，每个完成的工作结果都保存在堆中，所以我们可以随时中断一个<code class="fe nl nm nn mt b"><em class="mi">workLoopConcurrent</em></code>循环，稍后再返回。</p><p id="58d5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是我们如何知道何时中断这项工作呢？</p><p id="e9df" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里出现了<em class="mi"> shouldYield </em>函数，它是“调度程序”模块的一部分。它只有一个责任——决定是停止还是继续工作任务(<code class="fe nl nm nn mt b"><em class="mi">performUnitOfWork</em></code>)。当我们应该停止计算并让位于主线程时，它返回<em class="mi"> true </em>，或者当我们应该继续计算时，它返回<em class="mi"> false </em>。</p><p id="3d25" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">什么是<a class="ae nj" href="https://github.com/facebook/react/blob/v16.13.1/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L164-L166" rel="noopener ugc nofollow" target="_blank">一个<em class="mi"> shouldYield </em> </a>的实现？</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/f00762957b9d04a4bf9aad66b12a52b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHXtElbMjsWvoqrrewfWZQ.png"/></div></div></figure><p id="9bbf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它检查我们是否超过了最后期限。截止日期是什么时候？这是一个<em class="mi"> currentTime + 5m，</em>所以看起来，React scheduler每隔<br/> 5 ms中断一次执行，所以是一样的，正如我们在本文前面的例子中所介绍的。在源代码中有一个描述性的注释介绍了它的工作方式:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/d3fba6cead573575ece15acf7e1f0be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wS1QYm-r1zYuIb5aXUDZKw.png"/></div></div></figure><p id="6d1e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">好了，呈现MessageChannel循环的代码在哪里？</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/408a85eaaed57743007c14338e7195de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jzDc_94zVs0FMtNUBneQRw.png"/></div></div></figure><p id="367e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这有点复杂，但是在代码清单的最底部，我们有一个通道设置。您可以简单地浏览代码注释来查看流程。<code class="fe nl nm nn mt b"><em class="mi">performWorkUntilDeadline</em></code>里面有<code class="fe nl nm nn mt b"><em class="mi">port.postMessage(null)</em></code><em class="mi">；保持消息循环运行。</em></p><p id="fd39" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们也有一段代码，准备截止日期(<code class="fe nl nm nn mt b"><em class="mi">deadline = currentTime + yieldInterval;</em></code>)</p><p id="e471" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">什么是<code class="fe nl nm nn mt b"><em class="mi">scheduledHostCallback</em></code>？长话短说，它最终触发了前面提到的<em class="mi"> workLoopConcurrent </em>，这是React渲染过程的主要工作循环。但是该函数被设计为返回信息，无论工作是否完成，或者我们是否应该在下一个消息循环迭代中继续(<em class="mi"> hasMoreWork </em>)。</p><p id="6686" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还记得呈现<a class="ae nj" href="https://claudiopro.github.io/react-fiber-vs-stack-demo/stack.html" rel="noopener ugc nofollow" target="_blank">调度问题</a>的React 15.x app例子吗？</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/f130ddf7f3f78a999728b7101c326616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-PW6PWy8FC3lPYSch7ezhw.png"/></div></div></figure><p id="bc98" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><a class="ae nj" href="https://claudiopro.github.io/react-fiber-vs-stack-demo/fiber.html" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以看到相同的应用，但采用React 16.x及其新的React Fiber方法。好多了，对吧？</p><h1 id="d9a6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">React的调度程序模块</h1><p id="fb2e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe nl nm nn mt b"><em class="mi">shouldYield</em></code>不是React devs内部使用的唯一API。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/6648e8d161a4ff085b0adacc301e0aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1N1lsiU2H4H8Ez971HAcCg.png"/></div></div></figure><p id="8751" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">考虑到<a class="ae nj" href="https://github.com/facebook/react/blob/v16.13.1/packages/scheduler/src/Scheduler.js#L415-L434" rel="noopener ugc nofollow" target="_blank">公开函数</a>的命名约定，我们可以断定该模块仍处于开发阶段，API届时可能会发生变化。</p><p id="cf93" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当心！这个API不是为开发人员(比如你和我)设计的。它仅供团队成员/贡献者内部使用。当然，我们使用它，但是间接的。</p><p id="3e14" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">可以看到，该模块导出了函数<code class="fe nl nm nn mt b"><em class="mi">runWithPriority</em></code>以及一些预定义的常量(<em class="mi">用户阻塞优先级</em>、<em class="mi">正常优先级</em>、<em class="mi">低优先级</em>)。它还没有在React中广泛使用，但是这样做的目的是让React schedule以不同的优先级工作。我们可以预期在未来的React版本中，这个API将支持更多的用例。</p><p id="6bee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这样的逻辑目的是什么？以优先呈现特定元素。在脸书的应用中，首先看到<em class="mi">新闻提要</em>比看到页眉、页脚或认证用户部分更重要。在这种情况下，我们可能会以更高的优先级呈现与<em class="mi">新闻提要</em>相关的组件。</p><p id="f98f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这就是目标，希望在即将到来的React版本中看到一些真实的用例。是未来，但现在呢？我们在哪里使用调度器模块调度任务？</p><p id="2116" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">嗯，钩子的效果<a class="ae nj" href="https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2190-L2193" rel="noopener ugc nofollow" target="_blank">正在使用React调度器模块进行调度</a>。</p><p id="b30e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">有一个令人费解的<a class="ae nj" href="https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2182-L2196" rel="noopener ugc nofollow" target="_blank"><em class="mi">enqueuePendingPassiveHookEffectMount</em></a>函数，它调度<em class="mi"> scheduleCallback </em>任务，优先级为<em class="mi">正常</em>。</p><p id="4507" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们把注意力集中在函数名(<em class="mi">enqueuePendingPassiveHookEffectMount</em>)上，并找出每个名字的含义:</p><ul class=""><li id="1a30" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><em class="mi"> enqueuePending… </em>:幕后的调度程序模块构建了一个需要调用的回调列表(并为其分配了优先级)，因此<em class="mi"> enqueue </em>前缀在这个上下文中是准确的。</li><li id="42b5" class="lz ma iq ky b kz mj ld mk lh ml ll mm lp mn lt me mf mg mh bi translated"><em class="mi"> …PassiveHookEffect…: </em>这才是真正的乐趣。什么是<strong class="ky ir">被动</strong> <strong class="ky ir">挂钩效果</strong>？：</li></ul><p id="624d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们有两类效果，<strong class="ky ir">被动</strong> ( <em class="mi">使用效果</em>)和<strong class="ky ir">布局</strong> ( <em class="mi">使用布局</em>)。想象一下这个组件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7b62" class="mx jz iq mt b gy my mz l na nb">const App = () =&gt; {<br/>    useEffect(() =&gt; {<br/>        console.log('passive effect')<br/>    }, [])</span><span id="1c44" class="mx jz iq mt b gy nc mz l na nb">    useLayout(() =&gt; {<br/>        console.log('layout effect')<br/>    }, [])<br/>}</span></pre><p id="7de0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">哪个效果会先被调用？<strong class="ky ir">布局效果</strong>。为什么？正如文档中提到的，<strong class="ky ir">布局效果</strong>在DOM突变后被调用，但在浏览器渲染前被调用。<strong class="ky ir">另一方面，被动效果</strong>在浏览器渲染后被延迟(使用调度模块)调用<strong class="ky ir">。</strong></p><ul class=""><li id="d87a" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><em class="mi">…挂载:</em>最容易理解<strong class="ky ir">挂载</strong>，以及<strong class="ky ir">卸载</strong>的钩子效果的例子是:</li></ul><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="56fc" class="mx jz iq mt b gy my mz l na nb">useEffect(() =&gt; {<br/>    // this is "mount" passive hook<br/>    return () =&gt; {<br/>        // this is "unmount" passive hook<br/>    }<br/>}, [])</span></pre><p id="f0f2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">根据组件的状态，React调解器模块调用<strong class="ky ir">挂载</strong>或<strong class="ky ir">卸载</strong>(即在销毁组件时)。</p><p id="399c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">总而言之，所有的<strong class="ky ir">被动效果</strong>钩子都被异步调用<strong class="ky ir">——在浏览器重画之后。与阻止浏览器重绘的旧实现<em class="mi">componentid mount</em>或<em class="mi">componentid update</em>相比，这是一种不同的方法。同样值得注意的是，在钩子世界中，我们没有选择<em class="mi">组件将安装</em>或<em class="mi">组件将更新</em>。这些方法曾经是开发人员引入副作用的好地方(这可能会再次延迟重画)，因此他们决定放弃它。</strong></p><p id="42f0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以，你放在<strong class="ky ir">被动效果</strong>中的所有代码都要通过React调度程序。</p><h1 id="c6de" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是' isInputPending '？</h1><p id="d15c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">该功能是脸书工程师努力缩短用户输入(即点击、鼠标、键盘事件)执行时间的结果。</p><p id="f147" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们看看这个例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="23c0" class="mx jz iq mt b gy my mz l na nb">while (workQueue.length &gt; 0) {<br/>    if (navigator.scheduling.isInputPending()) {<br/>        // Stop doing work if we have to handle an input event.<br/>        break;<br/>    }</span><span id="54e5" class="mx jz iq mt b gy nc mz l na nb">    let job = workQueue.shift();<br/>    job.execute();<br/>}</span></pre><p id="7728" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过<code class="fe nl nm nn mt b"><em class="mi">navigator.scheduling.isInputPending()</em></code>我们可以发现是否有未决的用户事件(点击、鼠标、键盘、拖拽&amp;等等)。)所以我们可以通过将执行交给主线程(即通过<em class="mi"> break </em>语句)来处理事件，从而快速做出反应。</p><p id="63ee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当然是实验，不是官方标准。作为<a class="ae nj" href="https://developers.chrome.com/origintrials/#/view_trial/4544132024016830465" rel="noopener ugc nofollow" target="_blank"> Chrome Origin试用</a>的一部分，从版本74到78(直到2019年12月4日)都可以在Chrome浏览器上获得。</p><p id="dba0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以在Gihub和脸书的工程博客上了解更多。</p><p id="af5e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是为什么我要在这篇基于调度器的文章中描述这个东西呢？有趣的是，<a class="ae nj" href="https://github.com/facebook/react/blob/v16.13.1/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L127-L161" rel="noopener ugc nofollow" target="_blank">React Scheduler的当前实现</a>利用了这个特性:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/f8e124da92f02a1ab48eeb5b186d05db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJgujad64XQK8SVI3T2NGQ.png"/></div></div></figure><p id="f2fa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">满足特定要求后:</p><ul class=""><li id="c924" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">我们的React应用构建启用了一个特性标志(<code class="fe nl nm nn mt b"><em class="mi">enableIsInputPending</em></code>)</li><li id="dc06" class="lz ma iq ky b kz mj ld mk lh ml ll mm lp mn lt me mf mg mh bi translated">我们使用谷歌浏览器，并启用了实验性的<code class="fe nl nm nn mt b"><em class="mi">navigator.scheduling.isInputPending</em></code>功能</li></ul><p id="79e4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们的React调度器模块提供了一个改进版本的<em class="mi"> shouldYield </em>实现，当有任何未决事件等待执行时，它会将执行让给主线程。</p><h1 id="2d60" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">React中的计划历史</h1><p id="8a73" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">React 15.x的问题是整个渲染过程是同步进行的。一、大型、耗时、同步、递归(！)的一段代码。这不能与其他浏览器活动合作，对不对？</p><p id="fda5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在React Fiber开发(16.x)的最开始，React团队使用的是<em class="mi"> requestIdleCallback </em>。但是，就像丹·阿布拉莫夫说的那样，这似乎没有团队希望的那么有侵略性。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/7f162f0d83658c823906c0e0db6857f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7vnnafyNKy9GB9AWMvY9g.png"/></div></div></figure><p id="6576" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下一步是用<em class="mi"> requestAnimationFrame </em>模拟<code class="fe nl nm nn mt b"><em class="mi">requestIdleCallback</em></code>。他们试图猜测帧大小，并将React渲染机制与vsync循环对齐。这还不错，直到最近的一部(由安德鲁·克拉克制作)去掉了<em class="mi"> requestAnimationFrame </em>，如此处<a class="ae nj" href="https://github.com/facebook/react/pull/16271" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><h1 id="05a7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="1c3d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，我们有几个API可能会有所帮助，比如<em class="mi"> requestAnimationFrame </em>、<em class="mi"> requestIdleCallback </em>、消息循环(<em class="mi"> MessageChannel </em>)，甚至<em class="mi"> setTimeout </em>。</p><p id="e645" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是，嘿——它们是为稍微不同的目的而设计的，不是吗？</p><p id="121e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">毫无疑问，调度问题已经摆在桌面上，一些概念最近已经在浏览器供应商环境中公布。如果你对这个话题感兴趣——我推荐<a class="ae nj" href="https://github.com/WICG/main-thread-scheduling" rel="noopener ugc nofollow" target="_blank">WICG/main-thread-scheduling</a>repo以及它的“<a class="ae nj" href="https://github.com/WICG/main-thread-scheduling#further-reading--viewing" rel="noopener ugc nofollow" target="_blank">延伸阅读</a>”部分。</p><p id="ba85" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">想要更多吗？关注我的博客，<a class="ae nj" href="https://adasq.github.io/" rel="noopener ugc nofollow" target="_blank"> adasq.github.io </a>。</p></div></div>    
</body>
</html>