<html>
<head>
<title>Real-time data with redux-saga event channels and socket.IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有redux-saga事件通道和套接字的实时数据。超正析象管(Image Orthicon)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/real-time-data-with-redux-saga-event-channels-and-socket-io-ad6e64dbefd9?source=collection_archive---------2-----------------------#2017-11-23">https://javascript.plainenglish.io/real-time-data-with-redux-saga-event-channels-and-socket-io-ad6e64dbefd9?source=collection_archive---------2-----------------------#2017-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5c67123448c74fb1982a4e680635e1d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SK-wb5zDu0yFioWXqzb7dg.jpeg"/></div></div></figure><h1 id="7685" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="25fa" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有一堆关于在react/redux应用中处理实时数据的教程。他们通常展示如何制作一个简单的聊天应用程序，缺乏商业应用程序所需的实时数据管理的生产就绪功能。</p><p id="4b61" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">大多数业务应用程序使用socket接收实时数据，而上游请求通过标准REST API进行，因此您将在下面看到的代码中没有<code class="fe lz ma mb mc b">send</code>选项。但是一旦你理解了它是如何工作的，你就可以很容易地添加这个功能。</p><p id="68ef" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如今，实时数据应用有两种主要选择:</p><p id="3668" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1.现成的Google firebase数据库</p><p id="c406" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">2.基于socket.io库的自定义后端</p><p id="2cd5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以很快开始使用firebase，但是你的定制选项会受到限制。有了第二个选择，你可以做得更多。</p><p id="5751" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你更倾向于第二种选择，请继续读下去。</p><h1 id="f0af" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">基础</h1><p id="0791" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您在实时数据方面的主要挑战很可能是这样的:</p><p id="61e1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1.您的React/Redux应用程序在架构上可能看起来很完美，但是一旦您尝试合并实时数据，它就可能开始崩溃</p><p id="0228" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">2.在经典的REST API中，如果一个服务器宕机，你会得到一个500错误，并向你的用户显示一条友好的消息。使用实时API，您可能收不到任何东西，要么是因为服务器停机，要么是因为您没有任何新数据。因此，连接监控变得更加复杂和重要。</p><p id="380b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">幸运的是，我们有redux-saga及其被称为<code class="fe lz ma mb mc b">eventChannels </code>的酷功能，以及<code class="fe lz ma mb mc b">forks</code>、<code class="fe lz ma mb mc b">delays</code>、<code class="fe lz ma mb mc b">race </code>和其他功能，它们共同帮助我们构建强大的实时数据应用。</p><p id="5f2c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你只是想看一个工作示例，可以直接跳到源代码<a class="ae md" href="https://github.com/slava-lu/saga-socket-example" rel="noopener ugc nofollow" target="_blank">https://github.com/slava-lu/saga-socket-example</a></p><p id="34af" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">否则，请阅读下面的解释，示例应用程序是做什么的。你必须知道redux和redux-saga的基础知识。</p><p id="c110" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">redux-saga中有一个<code class="fe lz ma mb mc b">take</code>函数，通常用来监听redux动作，并根据动作类型做一些事情。但是这个<code class="fe lz ma mb mc b">take</code>功能也可以用来监听所谓的频道。</p><p id="8c89" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b"><strong class="ky ir">const </strong>payload = <strong class="ky ir">yield </strong>take(channel);</code></p><p id="32dc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通道是用另一个带有标准签名的函数构造的，您只需从redux-saga文档(或我的例子)中获取该签名即可。这个签名使用了<code class="fe lz ma mb mc b">eventChannel </code> redux-saga函数来完成这个任务。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="df7a" class="mm jz iq mc b gy mn mo l mp mq"><strong class="mc ir">const </strong>createSocketChannel = socket =&gt; eventChannel((emit) =&gt; {<br/> <strong class="mc ir">const </strong>handler = (data) =&gt; {<br/> emit(data);<br/> };<br/> socket.on(<strong class="mc ir">‘newTask’</strong>, handler);<br/> <strong class="mc ir">return </strong>() =&gt; {<br/> socket.off(<strong class="mc ir">‘newTask’</strong>, handler);<br/> };<br/> });<br/> </span></pre><p id="993b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因为您希望仅在成功连接到服务器时才创建套接字通道，所以您需要将<code class="fe lz ma mb mc b">socket.on</code>事件监听器包装到承诺中，因为redux-saga使用承诺而不是回调。</p><p id="365f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">综上所述，您的代码可能如下所示。</p><pre class="me mf mg mh gt mi mc mj mk aw ml bi"><span id="059c" class="mm jz iq mc b gy mn mo l mp mq"><strong class="mc ir"> const </strong>socketServerURL = <strong class="mc ir">‘http://localhost:3000'</strong>;<br/> <strong class="mc ir">let </strong>socket;<br/> <br/> <em class="mr">// wrapping function for socket.on<br/> </em><strong class="mc ir">const </strong>connect = () =&gt; {<br/> socket = io(socketServerURL);<br/> <strong class="mc ir">return new </strong>Promise((resolve) =&gt; {<br/> socket.on(<strong class="mc ir">‘connect’</strong>, () =&gt; {<br/> resolve(socket);<br/> });<br/> });<br/> };<br/> <br/> <em class="mr">// This is how a channel is created<br/> </em><strong class="mc ir">const </strong>createSocketChannel = socket =&gt; eventChannel((emit) =&gt; {<br/> <strong class="mc ir">const </strong>handler = (data) =&gt; {<br/> emit(data);<br/> };<br/> socket.on(<strong class="mc ir">‘newTask’</strong>, handler);<br/> <strong class="mc ir">return </strong>() =&gt; {<br/> socket.off(<strong class="mc ir">‘newTask’</strong>, handler);<br/> };<br/> });<br/> <br/> <em class="mr">// saga that listens to the socket and puts the new data into the reducer<br/> </em><strong class="mc ir">const </strong>listenServerSaga = <strong class="mc ir">function</strong>* () {<br/> <br/> <em class="mr">// connect to the server<br/> </em><strong class="mc ir">const </strong>socket = <strong class="mc ir">yield </strong>call(connect);<br/> <br/> <em class="mr">// then create a socket channel<br/> </em><strong class="mc ir">const </strong>socketChannel = <strong class="mc ir">yield </strong>call(createSocketChannel, socket);<br/> <br/> <em class="mr">// then put the new data into the reducer<br/> </em><strong class="mc ir">while </strong>(<strong class="mc ir">true</strong>) {<br/> <strong class="mc ir">const </strong>payload = <strong class="mc ir">yield </strong>take(socketChannel);<br/> <strong class="mc ir">yield </strong>put({type: ADD_TASK, payload});<br/> }<br/> };</span></pre><p id="13fa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以在这里停止，因为除了基本的react/redux/saga设置之外，您只需要从您的socket服务器获取实时数据。</p><p id="2de7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是…</p><h1 id="1069" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">投入生产</h1><p id="26cd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是，要将其投入生产，您还需要做更多的工作:</p><p id="8cf2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1.侦听断开连接和重新连接事件</p><p id="ca8e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">2.通过单击按钮或在组件生命周期功能中打开和关闭通道</p><p id="8bfc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">3.等待连接超时，以了解服务器是启动还是关闭(没有500错误)</p><p id="78e4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">4.确保服务器再次启动时，您的saga将自动接收数据</p><p id="af15" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">5.将所有这些连接信息放入reducer进行进一步处理</p><p id="4f32" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要把这一切联系起来，你需要足够好地理解redux-saga。至少你要知道<code class="fe lz ma mb mc b">call </code>和<code class="fe lz ma mb mc b">fork</code>、<code class="fe lz ma mb mc b">all </code>和<code class="fe lz ma mb mc b">race</code>、<code class="fe lz ma mb mc b">take </code>和<code class="fe lz ma mb mc b">takeEvery</code>的区别，还要明白如何取消任务。</p><p id="01c0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以，如果你想掌握redux-saga和实时数据管理，打开redux-saga文档和我的示例应用程序，成为一名redux-saga忍者:)</p><p id="7b48" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以在这里找到完整的代码<a class="ae md" href="https://github.com/slava-lu/saga-socket-example" rel="noopener ugc nofollow" target="_blank">https://github.com/slava-lu/saga-socket-example</a></p><p id="1a7c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要使用此示例应用程序，您需要:</p><p id="5656" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">1.在客户机和服务器文件夹中运行<code class="fe lz ma mb mc b">yarn </code>来安装node_modules</p><p id="5511" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">2.通过运行服务器文件夹中的<code class="fe lz ma mb mc b">node ./index.js</code>打开套接字服务器</p><p id="c27b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">3.通过运行客户端文件夹中的<code class="fe lz ma mb mc b">yarn start</code>启动客户端应用程序，并将浏览器指向<a class="ae md" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a></p><p id="3c94" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你做的一切都正确，你应该看到这个屏幕</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/d7771918a7da0d6d0590aefde4acdc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*OPHwxbf4Q29m1tRtsbUGyA.png"/></div></figure></div></div>    
</body>
</html>