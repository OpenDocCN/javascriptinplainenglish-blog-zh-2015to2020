<html>
<head>
<title>A First Step to Improve Your Code Before Diving into Domain Driven Design or the Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在进入领域驱动设计或干净架构之前，改进代码的第一步</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-first-step-to-improve-your-code-before-diving-into-domain-driven-design-or-the-clean-architecture-90da4a80d863?source=collection_archive---------3-----------------------#2020-11-24">https://javascript.plainenglish.io/a-first-step-to-improve-your-code-before-diving-into-domain-driven-design-or-the-clean-architecture-90da4a80d863?source=collection_archive---------3-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0e76" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件设计</h2><div class=""/><div class=""><h2 id="e7dc" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">你可能听说过这两个概念:它们很聪明，但需要一些时间来实验和掌握。这里有一些技巧可以帮助你顺利缩小差距。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/dfb850d24b0e449bd8b6c03a06376b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oeEKfYGXHtnSG5h0fK4beA.png"/></div></div></figure><p id="1f3f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">既然你的代码库已经长大了，你是否觉得有问题，想回避新的开发？厌倦了花时间跟踪和修复臭虫，它甚至成了一场噩梦？因为你的软件没有负载而摧毁了你有前途的公司？</p><p id="35e2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">你知道吗？我理解你的感受</strong>……<strong class="lc ja">我去年也经历过悲伤的时刻。</strong></p><p id="449c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在我的开发生涯中，我已经写了很多糟糕的、紧密耦合的、不可测试的、随机的代码，这些代码至今仍在生产中……我可能不是唯一一个这样的人，但是在思考了如何改进我自己和我的工作之后，我最终想到了一些可能解决这些问题的概念。</p><p id="4283" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">像<em class="lw">清洁代码(Martin Fowler) </em>、<em class="lw">域驱动设计(Eric Evans) </em>或者甚至<em class="lw">清洁架构(Robert C. Martin) </em>这样具有大量相关模式的东西，比如<em class="lw"> CQRS </em>、<em class="lw">聚合根</em>、<em class="lw">适配器、……</em>都是我们上面讨论的问题的流行解决方案。但这可能是个问题……</p><p id="7968" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">🤔你为什么要读那篇文章？</strong></p><p id="092f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所有这些看起来(并且是)很酷，但是乍一看，对于新手和软件工艺新手来说，可能有点复杂。也许就像我的一些朋友一样，你还没有准备好开始这些方面的工作。</p><p id="4100" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">慢慢来！慢下来:跳过步骤从来都不是一个好主意！</strong></p><p id="5249" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，为了让过渡更顺利，我想与你分享一些原则和实践，当你决定对这些话题感兴趣时，这些原则和实践会对你有所帮助。</p><h1 id="95d4" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">什么是软件开发中的好项目？</h1><p id="7282" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">这是一个非常主观的问题，我将尝试将我的答案重新组合成我们在项目生命周期中可以观察到的四个核心原则/关键绩效指标:</p><ul class=""><li id="34ae" class="mu mv iq lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">让代码尽可能接近业务需求，以便适应它并增加“真正的”价值。(<strong class="lc ja">真人</strong></li><li id="e07f" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">能够完成应用程序的关键部分，以确保交付工作工具。一个好的项目只是在生产中运作，并在没有随机用户体验的情况下满足最初的需求。(<strong class="lc ja">一致性</strong>)</li><li id="a765" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">能够使应用程序具有可维护性、演进性和时间弹性。这不会在第一次开发人员变更或新框架更新时中断。这是一个易于掌握、部署和更新的应用程序。(<strong class="lc ja">回弹力</strong>)</li><li id="64d7" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">有能力运送新的开发人员，新的开发或功能，或者只是在团队内切换开发人员，没有眼泪。(<strong class="lc ja">适应性</strong></li></ul><p id="8762" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">本文试图在学习那些架构原则和工作方式之前给你一些提示和想法，这样一旦你做好准备，理解DDD、TDD、清洁架构原则和任何其他东西就更容易了。</p><h1 id="f8fe" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">软件开发中什么知识最重要？</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/9f020131b2cb7a114f1781e214679415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omIY52SrGlYSqxUVBdgAeg.png"/></div></div></figure><p id="27a2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你需要在那些与时间相关的事情上投入时间。我们看到了著名的JS疲劳期，它告诉我们总是有新的框架可以使用。<strong class="lc ja">在此期间，你唯一可以依靠并且保持稳定的是你自己的业务规则，这些规则定义了你的项目DNA。</strong></p><p id="4e57" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">我们可以利用那些使用编程基础的东西:干净的代码和软件架构。</strong></p><p id="94f9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过学习如何通过关注重要的东西来构建程序，以及如何用抽象来设计代码，你将能够使用任何框架或工具。这并不意味着你必须这样做，但你可以这样做。</p><p id="06e4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">环顾四周，所有的工作机会就像</p><ul class=""><li id="b8f4" class="mu mv iq lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">高级反应开发者</li><li id="7491" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">VueJS专家</li></ul><p id="a381" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我恭敬地认为这些提议是错误的。他们谈论实现细节，却忽略了最重要的方面:构建软件，这是一项与特定框架无关的技能。</p><p id="7653" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">理想情况下，您不需要React开发人员。你想要一个知道如何构建应用程序的开发人员，必须将业务逻辑连接到前端框架，在那里，为什么不使用React。</p><h1 id="591f" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">在进入DDD / Clean Architecture之前，提高开发人员技能的一些原则。</h1><h2 id="0132" class="ni ly iq bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn iw bi translated">1.在深入代码和数据模型化之前，在纸上思考用例以及核心领域事件</h2><p id="f095" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">做申请的时候我们做什么？</p><p id="f0c4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们利用计算机的处理能力解决现实生活中的问题。记住这一点。</p><p id="32ec" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">制作一个不符合业务需求的应用程序毫无意义！花一些时间与业务团队一起定义上下文，并确保找到应用程序的核心事件和操作(领域)。</p><p id="f569" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">这将帮助你围绕这些概念构建你的应用文件夹和代码。</strong></p><p id="0590" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">大多数开发人员(我以前是这方面的专家)正在考虑制作一个UML图或者查看我的实体将拥有哪些数据。这是一件坏事。</p><p id="812c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">也不要考虑你的库、工具或框架如何适应你的业务需求，而是定义你的业务需求而不考虑框架的限制。然后，您将选择合适的工具来满足业务需求。</p><p id="b98f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们应该开始考虑动作(<code class="fe nt nu nv nw b">bookACar</code>、<code class="fe nt nu nv nw b">searchProducts</code>、…)，而不是先考虑实体(<code class="fe nt nu nv nw b">Car</code>、<code class="fe nt nu nv nw b">Products</code>)。通过这种方式，我们可以编写足够的代码来满足需求，因为变量字段会在我们需要时弹出。代码越少，潜在的错误就越少，程序的复杂性也就越低。</p><p id="2edc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">此外，现在就开始在IT和业务之间使用一个通用的共享词汇表</strong></p><p id="4c06" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通常业务和开发团队不使用相同的措辞，这种引入绝对是灾难性的最终行为。花些时间正确地给业务命名，以确保你说的是同一件事。</p><blockquote class="nx"><p id="7f34" class="ny nz iq bd oa ob oc od oe of og lv dk translated">投入生产的是开发团队已经理解的内容，而不是产品负责人或首席执行官的想法。</p></blockquote><p id="8883" class="pw-post-body-paragraph la lb iq lc b ld oh ka lf lg oi kd li lj oj ll lm ln ok lp lq lr ol lt lu lv ij bi translated">考虑上下文，想象一个电子商务应用程序:</p><ul class=""><li id="192f" class="mu mv iq lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated"><strong class="lc ja"> <em class="lw">产品是未来可能发生变化的东西</em> </strong></li><li id="a9d2" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated"><strong class="lc ja"> <em class="lw">而是开票上下文中的产品线</em> </strong>(乍一看可能会被误认为是产品关系，但不应该！)是<strong class="lc ja">被冻结</strong>的东西，有独立的生命周期，就是它所来自的原始产品！</li></ul><p id="2419" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这种错误很常见，会给你的业务带来灾难性的影响。如果有人更新了一个项目的价格，而所有以前的发票都改变了价格，该怎么办？你错过了一些概念。</p><h2 id="d594" class="ni ly iq bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn iw bi translated">2.编写干净的代码</h2><p id="f2a5" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated"><strong class="lc ja"> <em class="lw">干净代码有多种定义。</em>T24】</strong></p><p id="c7c8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对我来说:这是一个易于阅读的代码，被分成具有单一目的的指令，任何开发人员都可以使用它，而不会感到头痛，并对其行为充满信心。因为它很小，我们可以很容易地将代码指令与单元测试的其他代码模拟交换。</p><p id="a2fd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">以下是一些制作干净代码的原则:</p><ul class=""><li id="e67f" class="mu mv iq lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">保持函数/类有一个<strong class="lc ja">单一目的</strong>，如果有一个以上的目的，只需将逻辑拆分到另一个函数/类中。</li><li id="1e8e" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">正确命名事物，当你阅读一个代码时，不应该产生歧义。使用像<code class="fe nt nu nv nw b">List</code>这样后缀，用<code class="fe nt nu nv nw b">customer</code>代替<code class="fe nt nu nv nw b">user</code>这样的东西……试着用它们在商业术语中所代表的东西来命名。不要使用类似<code class="fe nt nu nv nw b">a</code>或<code class="fe nt nu nv nw b">b</code>的东西。</li><li id="1144" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">减少耦合，写没有副作用的纯函数。这样你就可以利用依赖注入和测试。</li></ul><p id="8cb9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你可以在罗伯特·c·马丁的<em class="lw">干净代码手册</em>中读到更多</p><p id="05d4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就引出了第三个技巧:<strong class="lc ja">减少耦合</strong></p><h2 id="dc66" class="ni ly iq bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn iw bi translated">3.减少代码耦合考虑抽象</h2><p id="d79e" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">正如我们前面所说的，框架和工具只是业务逻辑的实现细节，不要过分依赖它们。例如，如果你需要一个支付工具，你可能会从Stripe开始，它非常受欢迎且易于使用。</p><p id="09ef" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你把你的代码和它紧密地结合在一起，当明天你不为这笔交易感到自豪，而费用条适用于你的时候，你会怎么把它换成另一个能让你少付钱的提供商呢？这肯定会非常困难，甚至可能会毁掉你的公司。</p><p id="a8be" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">思考抽象有助于您将自己的业务逻辑从外部服务中分离出来。</p><p id="a2fe" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您自己的业务逻辑可能是这样的:X服务的提供商获得了多少报酬？或者，我的“现收现付”计划依靠什么来计算费用？。</p><p id="6cba" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先要检查的是从大方法(称为<em class="lw">事务脚本</em>)中重构我们的代码，将它提取到以原语作为输入和输出(接口)的小函数/类中。</p><p id="7863" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过减少耦合和考虑抽象，我们可以轻松地编写代码，重用它，并通过提供一个假的实现来测试它。</p><p id="3b70" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">同样:分两部分考虑应用程序:</p><ul class=""><li id="06ae" class="mu mv iq lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">你的应用程序的核心代码，你不能从任何其他地方得到，比如sass服务，数据库，用户输入。(<strong class="lc ja">域代码</strong>)</li><li id="1983" class="mu mv iq lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">这个外部代码依赖于您使用的框架或外部服务(<strong class="lc ja">基础设施代码</strong>)</li></ul><p id="1cf7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">以这种方式思考，你就不依赖于实现，这就变成了一个细节。</p><h2 id="1695" class="ni ly iq bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn iw bi translated">考虑可重用性和领域驱动</h2><p id="d161" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">不要按架构(事物是什么)打包你的代码，而是按域/模块(它们属于哪个域)打包。</p><p id="b2fb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">很长一段时间，我使用像<code class="fe nt nu nv nw b">Controllers</code>或<code class="fe nt nu nv nw b">Reducers</code>这样的文件夹名打包，但是当项目长大后，它变得很难维护。</p><p id="db7e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一个更好的方法是按领域打包，像<code class="fe nt nu nv nw b">Users</code>或<code class="fe nt nu nv nw b">Authentication</code>甚至<code class="fe nt nu nv nw b">Payments</code>，在这些文件夹中，你保持代码小，并且在领域代码和实现代码之间分开。</p><ul class=""><li id="85a9" class="mu mv iq lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">按领域模块(与哪个领域相关)而不是基础设施(使用什么结构，像控制器、映射器:我们用来构建应用程序的工具)打包代码</li></ul><p id="afc7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这样做，如果做得正确，你甚至可以在项目和应用程序之间重用模块。即使看起来不那么远，您也可以更容易地在模块之间共享代码，因为它们耦合度更低</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="1076" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">这是一个简单的介绍</strong></p><p id="6b4a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我希望所有这些能够帮助你在软件架构的世界里迈出第一步。一旦你想尝试DDD或清洁建筑，通过应用这四个概念，你会帮助你自己。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><h2 id="8533" class="ni ly iq bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn iw bi translated"><a class="ae ot" href="https://codingspark.io/?referral=medium" rel="noopener ugc nofollow" target="_blank"> ↓ For French People↓↓我建议您浏览Coding Spark并订阅我的时事通讯,免费获取科技内容!(T1 )</a></h2></div></div>    
</body>
</html>