<html>
<head>
<title>NGRX component-store deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGRX组件-商店深入探讨</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/ngrx-component-store-deep-dive-947c0a5be6dc?source=collection_archive---------0-----------------------#2020-06-18">https://javascript.plainenglish.io/ngrx-component-store-deep-dive-947c0a5be6dc?source=collection_archive---------0-----------------------#2020-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="adce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:让我们深入了解NGRX的新<a class="ae kf" href="https://ngrx.io/guide/component-store" rel="noopener ugc nofollow" target="_blank">组件库</a>!</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/744f8c4a952f8ad59f38022d9026ec19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KM3oFVTlyJBx_s940a64ng.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Picture courtesy of <a class="ae kf" href="https://unsplash.com/@jeremybishop" rel="noopener ugc nofollow" target="_blank">Jeremy Bishop</a></figcaption></figure><p id="3def" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一部分<a class="ae kf" href="https://medium.com/javascript-in-plain-english/introducing-ngrx-component-store-part-1-67019dba0cb0" rel="noopener">中，我已经解释了NGRX的组件存储模块是什么。如果你还没有读，那么我建议你现在就去看看:</a><a class="ae kf" href="https://medium.com/javascript-in-plain-english/introducing-ngrx-component-store-part-1-67019dba0cb0" rel="noopener">https://medium . com/JavaScript-in-plain-English/introducing-ngrx-component-store-part-1-67019 DBA 0 CB 0</a></p><p id="2d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二部分中，我将首先解释组件存储的API，然后我们将一起通过一些例子来发现如何使用它。最后，我将向您展示我是如何构建简单的<a class="ae kf" href="https://ngrx-component-store-demo.netlify.app/" rel="noopener ugc nofollow" target="_blank">演示</a>的。</p><p id="dc1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:因为还没有最终版本，所以对本文的代码样本要有所保留。API可能不会改变太多(如果有的话)，但可能会有细微的差别。</p><h1 id="7ec2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">装置</h1><p id="2385" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">安装组件存储非常容易，因为您可以简单地将它添加到RxJS旁边的项目中；它不依赖于NGRX的任何其他模块。</p><p id="c442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，组件存储库处于测试阶段；您可以使用以下方法将其添加到您的项目中:</p><pre class="kh ki kj kk gt mp mq mr ms aw mt bi"><span id="492c" class="mu lt iq mq b gy mv mw l mx my">npm install @ngrx/component-store</span></pre><p id="71b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦添加，只需安装，你就可以走了。</p><p id="373f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦最终版本发布，只需更新您的依赖关系:)</p><h1 id="02f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">组件存储的关键概念</h1><p id="1eb3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">以下几点直接摘自(草案)<a class="ae kf" href="https://ngrx.io/guide/component-store" rel="noopener ugc nofollow" target="_blank">正式文件</a>:</p><ul class=""><li id="8b84" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">本地状态可以被延迟初始化</li><li id="2535" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">本地状态通常与特定组件的生命周期相关联，并在该组件被销毁时被清除。</li><li id="606b" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">ComponentStore的用户可以通过<code class="fe nn no np mq b">setState</code>或<code class="fe nn no np mq b">updater</code>来更新状态，要么强制更新，要么通过提供一个可观察对象来更新。</li><li id="cc4f" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">ComponentStore的用户可以通过<code class="fe nn no np mq b"><a class="ae kf" href="https://ngrx.io/api/store/select" rel="noopener ugc nofollow" target="_blank">select</a></code>或顶级<code class="fe nn no np mq b"><a class="ae kf" href="https://ngrx.io/api/store-devtools/StoreDevtools#state" rel="noopener ugc nofollow" target="_blank">state</a>$</code>读取状态。选择器的性能非常好。</li><li id="e89b" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">ComponentStore的用户可以用<code class="fe nn no np mq b"><a class="ae kf" href="https://ngrx.io/api/effects/EffectNotification#effect" rel="noopener ugc nofollow" target="_blank">effect</a></code>开始副作用，同步和异步都可以，并强制或被动地输入数据。</li></ul><p id="7ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个列表中，我们已经可以认出几个熟悉的术语:<code class="fe nn no np mq b">select</code>、<code class="fe nn no np mq b">effect</code>、<code class="fe nn no np mq b">setState</code>。好，我们已经感觉到在已知的领域；-)</p><p id="0b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这还不十分清楚。让我们更详细地看看API，了解一下它的本质。</p><h1 id="93f8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">ComponentStore类</h1><p id="5d46" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，component-store提供了一个我们可以扩展的<code class="fe nn no np mq b">ComponentStore&lt;T&gt;</code>基类。扩展这个基类允许我们创建一个特定的组件存储类型，它将保存一个具有特定形状<code class="fe nn no np mq b">T</code>的状态树。</p><p id="d0a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们希望在组件存储中存储以下信息:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c8ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有什么花哨的；我们有一堆接口，其中有一个特别定义了我们状态的形状(我更喜欢这样命名，以使它的目的更清楚)。</p><p id="73c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于此，组件存储实现的最简单的表达式如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4d67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们简单地创建了一个可注入的Angular服务，它扩展了NGRX组件存储的<code class="fe nn no np mq b">ComponentStore&lt;T&gt;</code>类。此外，我们已经为我们的<code class="fe nn no np mq b">WhateverState</code>接口设置了泛型类型，以定义我们的商店数据的形状。最后，注意我们已经通过调用<code class="fe nn no np mq b">super</code>为我们的商店定义了一个默认/初始状态。</p><p id="47fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们的组件存储服务(CSS！:p)已经可以用了，但是目前为止还不是很有趣。</p><p id="a48c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在想让你明白的是，这个服务可以在多个地方被注入，并且可以被实例化多次(我们将进一步了解如何实现。这一点非常重要，因为这是全球NGRX商店的一大优势。</p><p id="8585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">全局NGRX存储被创建一次，并且被许多模块/组件共享(即使它们依赖于状态树的不同部分/与状态树的不同部分交互)。</p><p id="b37f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与全局NGRX存储相反，基于组件存储的服务可以多次存在，彼此独立。正如我在上一篇文章中所解释的，这个想法是复杂组件的不同实例可以各自拥有自己的状态，由一个专用的组件存储服务实例保存。</p><h1 id="486c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">ComponentStore类的基本API</h1><p id="e6f8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如前一节所述，我们的空的基于组件存储的服务类(相当拗口)现在没什么用。在其当前状态下(双关语)，它可以保持我们的初始/默认状态，并将其公开为可观察状态，但仅此而已。</p><p id="e536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，如果你实例化它，你会看到有一些方法可用。</p><p id="46a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是由<code class="fe nn no np mq b">ComponentStore</code>基类提供的主要元素:</p><ul class=""><li id="e98f" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><code class="fe nn no np mq b">state$</code>:作为<a class="ae kf" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>可观察对象公开的类实例所拥有的当前状态</li><li id="ab30" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><code class="fe nn no np mq b">setState</code>:可用于更新/替换当前实例的<strong class="ky ir">状态</strong>的函数。正如我们将在后面看到的，这个函数有两个主要的变体</li><li id="f08c" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><code class="fe nn no np mq b">select</code>:可以用来定义选择器的函数。创建的选择器可以选择/提取/合成/转换当前实例持有的状态树的部分</li><li id="c19c" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><code class="fe nn no np mq b">effect</code>:可用于定义<strong class="ky ir">副作用</strong>的功能；和NGRX的想法差不多。效果可以(例如)用于触发异步操作(例如，调用后端服务)、触发状态更新等</li><li id="0d96" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><code class="fe nn no np mq b">updater</code>:可用于定义状态更新函数的函数；可以根据提供的参数更新状态的函数。更新器函数确实是<strong class="ky ir">还原器</strong>。需要注意的是，状态更新函数必须返回状态的新版本，而不是同一实例的变异版本</li></ul><p id="528d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在接下来的章节中探讨每一个问题。</p><p id="d958" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">警告</strong>:在接下来的部分中，我将解释由<code class="fe nn no np mq b">ComponentStore</code>公开的基本方法，但是这些将脱离它们的上下文来显示，所以请等到后面涵盖演示的部分来更好地理解这些是如何组合在一起的；否则你可能只能看到一部分。</p><h2 id="b592" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">订阅状态/状态更新</h2><p id="ef9a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">从消费者的角度来看(例如，组件依赖于<code class="fe nn no np mq b">WhateverComponentStore</code>服务的一个实例)，我们可以做的第一件事是订阅当前状态以获得它，并在它改变时得到通知。</p><p id="6e21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件库的每个实例都有自己的状态。如果您创建了另一个实例，那么状态将不会被共享；相反，另一个实例将拥有自己的。</p><p id="9a24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想继续，那么继续手动创建服务的一个实例:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cbea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建实例后，我们已经可以订阅当前状态，如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ebf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当执行这段代码时，我们确实得到了当前的状态:</p><pre class="kh ki kj kk gt mp mq mr ms aw mt bi"><span id="6849" class="mu lt iq mq b gy mv mw l mx my">'Current state: ', Object{foo: 'default foo', bar: 'default bar', isWorkingFromHome: false, someData: [], users: Object{}}</span></pre><p id="5614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，组件存储服务实例持有的状态是<em class="od">可观察的</em>。这本身就很酷，但是只有当所述状态可以被更新时才变得有趣..当然可以。</p><h2 id="0b31" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">选择州的部分地区</h2><p id="d83e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">就像NGRX Store一样，我们可以定义并订阅<em class="od">选择器</em>，以便检索状态树的特定部分。</p><p id="4e1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，与NGRX存储选择器一样，组件存储选择器可以提取状态的子集，但是它们也可以根据消费的需要组成/转换数据。这意味着你可以在组件存储选择器中反规格化数据，就像你在NGRX存储选择器中做的那样。</p><p id="2613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子展示了如何选择我们的状态树的<code class="fe nn no np mq b">foo</code>属性:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="194f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们只需将一个<em class="od">投影</em>函数传递给<code class="fe nn no np mq b">select</code>方法。使用当前状态对象调用投影函数，并返回它想要的任何内容。</p><p id="110e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面，请注意<code class="fe nn no np mq b">fooSelector</code>是一个可观察值，因此我们可以很容易地订阅它以获得当前值，并在值发生变化时得到通知:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="62bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，TypeScript类型推断在这里起了很大的作用；一切都打对了。</p><p id="d7af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，选择器的有趣之处还在于它们可以组合在一起，因此您可以定义一个选择器来提取状态树的一部分，然后定义另一个选择器来重用第一个选择器并执行额外的操作。</p><p id="1d74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NGRX组件存储选择器目前<em class="od">没有被记忆</em>，但是在内部使用<code class="fe nn no np mq b">distinctUntilChanged</code>和<code class="fe nn no np mq b">shareReplay</code>，这意味着我们可以多次订阅一个选择器，并且所有这些订阅将获得相同的值(不需要触发单独的执行)。</p><h2 id="039d" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">初始化/设置状态</h2><p id="8651" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">正如我们前面看到的，默认/初始状态是在我们的<code class="fe nn no np mq b">ComponentStore</code>类的构造函数中定义的。事实上，该类可以接受初始状态作为构造函数参数；这是一个设计选择。实际上，我认为设置一个缺省值并避免通过构造函数传递初始状态更有意义，但这取决于你。</p><p id="ed12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何更新状态呢？</p><p id="52ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法是使用<code class="fe nn no np mq b">setState</code>功能。这里有一个例子:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们简单地将新状态作为参数传递给了<code class="fe nn no np mq b">setState</code>函数。或者，您可以如下传递一个<em class="od">更新器</em>函数:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这种样式，您可以访问当前状态，因此可以更容易地更新特定部件。请注意，您必须返回一个新对象，当然不能改变现有的对象；否则，你会违反合同，状态也不会像你希望的那样更新。不变性超级重要，就像NGRX Store和宇宙中任何好的东西一样，真的。</p><p id="4b88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你当然可以随心所欲地多次调用<code class="fe nn no np mq b">setState</code>。</p><h2 id="fe97" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">更新状态</h2><p id="3a21" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">调用<code class="fe nn no np mq b">setState</code>很好，但是能够定义负责更新状态特定部分的函数也很有趣。这正是<code class="fe nn no np mq b">updater</code>的意义所在。</p><p id="de38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建更新程序就像这样简单:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ac99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nn no np mq b">ComponentStore</code>的<code class="fe nn no np mq b">updater</code>函数接受一个函数作为参数。调用该函数时，它将接收两个参数:</p><ul class=""><li id="c05c" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">当前状态</li><li id="56ff" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">一些更新的值(在它上面是一个字符串，但它可以是你喜欢的任何东西)</li></ul><p id="42e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这些输入，updater函数的作用是返回状态的新版本。</p><p id="6093" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，更新不能改变现有状态，而是返回一个新状态。我推荐你看一看<a class="ae kf" href="https://immerjs.github.io/" rel="noopener ugc nofollow" target="_blank"> Immer </a>在实现这样的减速器时使用它。</p><p id="fdd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">状态更新功能可以轻松调用，如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5049" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们这样做时，服务实例持有的状态得到更新。很好。</p><p id="50f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<a class="ae kf" href="https://twitter.com/AlexOkrushko/status/1273809090188398598" rel="noopener ugc nofollow" target="_blank">正如Alex </a>所强调的，请注意更新程序可以将可观察值作为参数(不仅仅是命令性数据)，并且可以取消订阅。这意味着您可以将流链接在一起，使您的代码更具反应性；-)</p><h2 id="bc96" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">处理副作用</h2><p id="1109" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">效果是最有趣的地方。通过实现效果，您可以定义复杂的场景，只要调用效果就可以执行这些场景。</p><p id="c7c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，一个效果可以根据它接收到的值，决定调用一个远程API，调用更新程序来修改状态，等等。天空是无限的。</p><p id="0eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常基本的效果例子:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d5a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个玩具示例只是将它接收到的值记录到控制台，但是显示了它的症结所在。当用一个值调用<code class="fe nn no np mq b">myEffect</code>效应时，该值作为可观察值的下一个值被传递给效应函数，然后效应函数可以通过管道将它传递给它想要的任何东西(正如你所知道的，一旦你手中有了一个流，宇宙就是你的了)。</p><p id="eb4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，我们没有被强迫传递一个值给一个效果；我们也可以简单地称之为没有价值观；在这种情况下，呼叫将作为简单的信号。</p><p id="923a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用组件存储实现业务逻辑时，效果当然会起很大的作用。我会给你看一个更具体的例子。</p><p id="3fc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与更新程序一样，effects也可以将可观察值作为参数，而不仅仅是我在上面的例子中展示的命令性数据！</p><h1 id="c836" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么去哪里？</h1><p id="7222" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，您已经看到了如何定义一个基本的<code class="fe nn no np mq b">ComponentStore</code>类，如何在没有Angular的情况下实例化它，以及它公开了什么方法。</p><p id="bce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到了每个内置方法是如何独立工作的，但是现在这仍然有点抽象。在这一点上，你可能想知道<em class="od">到底把那些选择器、更新器和特效放在哪里..</em></p><p id="8c85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们当然不属于你的组件，因为你想让它们更简单，尽管我们看到它们可以在任何地方<em class="od">被创建/传递/使用。</em></p><p id="b617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我将在下一节中展示的，选择器、更新器和效果实际上应该在从<code class="fe nn no np mq b">ComponentStore</code>扩展的类中定义。这样，该类将维护一个特定的状态树，并将封装所有操纵该状态的代码。当然，选择器/效果/更新器将被绑定到类的一个特定实例，并将与一个特定的状态树交互。</p><p id="6456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看一下演示，这样您就可以更具体地感受如何实际使用组件存储了！</p><h1 id="1a03" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">演示</h1><p id="e193" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然我们已经发现了组件存储的公共API，我们可以看一个更具体的例子来把事情放在上下文中。</p><p id="0de4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想看看我接下来要描述的代码，你可以看看下面的<a class="ae kf" href="https://github.com/dsebastien/ngrx-component-store-demo" rel="noopener ugc nofollow" target="_blank"> Git库</a>:<a class="ae kf" href="https://github.com/dsebastien/ngrx-component-store-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/dsebastien/ngrx-component-store-demo</a></p><p id="e80a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以看看<a class="ae kf" href="https://ngrx-component-store-demo.netlify.app/" rel="noopener ugc nofollow" target="_blank">现场演示来玩玩</a>。</p><p id="3046" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个演示不是很高级，但是它展示了我们如何利用组件存储将状态和逻辑提取到扩展<code class="fe nn no np mq b">ComponentStore</code>的定制服务类中。此外，演示还展示了服务是如何配置的。</p><p id="f9e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，演示清楚地表明，使用基于组件存储的服务的组件的每个实例都有自己独立的状态，并且与其他实例完全隔离。</p><p id="7d40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，这个演示只不过是一个虚拟的例子，在整体计划中不一定有意义。所以让我们假装这一切都有意义；-)</p><h2 id="80e2" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">领域模型</h2><p id="ff47" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">演示有一个微小的领域模型:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="08b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对此我并没有太过担心。演示允许操作“课程”。</p><h2 id="4a07" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">成分</h2><p id="f5d9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">演示的想法是，根据当前状态，用户可以或不可以添加/删除课程和/或教师。</p><p id="c541" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示中有两个主要的角度分量。第一个，“课程”是一个哑组件，可以显示特定的课程。</p><p id="c98f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个是“课程目录”，这是一个智能/表示组件，应该足够复杂以保证组件存储的使用。该组件知道并使用通过组件存储实现的服务。</p><h2 id="b56c" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">决赛成绩</h2><p id="c579" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们开始查看代码之前，让我们看看演示是什么样子的:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oe"><img src="../Images/25a9bed292371a3e32b6bee7a4a14185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOKb1z2MQyo3DALlmrY88w.png"/></div></div></figure><p id="2389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您在上面看到的是三个彼此相邻的课程目录组件实例。顶部的“添加目录”按钮添加了一个课程目录组件的实例。</p><p id="8ac8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些组件实例中的每一个都有自己的组件存储实例，具有单独的状态。正如您在上面的截图中看到的，每个目录的状态都是独立发展的。例如，“默认”目录没有“添加课程”或每个课程下面的“删除”按钮，等等。</p><p id="45ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，所有这些组件都使用了<a class="ae kf" href="https://angular.io/api/core/ChangeDetectionStrategy" rel="noopener ugc nofollow" target="_blank"> OnPush变化检测策略</a>。</p><p id="cd23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按钮允许操纵状态。</p><p id="19d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，你可以在Netlify 上找到<a class="ae kf" href="https://ngrx-component-store-demo.netlify.app/" rel="noopener ugc nofollow" target="_blank">的现场演示，也可以在Github上找到源代码</a></p><p id="a71f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好奇？好吧，我们开始吧！</p><h2 id="06eb" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">课程目录状态</h2><p id="e826" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">以下是课程目录组件的状态:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ff75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有什么花哨的；只有几个数据点和几个标志来允许/拒绝一些操作。</p><h2 id="e738" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">应用程序组件</h2><p id="5673" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">app组件只是保存一组目录元素；单击“Add”目录元素，向集合中添加一个。</p><p id="6b85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次创建新目录时，app组件都创建/呈现附加的课程目录组件:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="6159" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">课程组件</h2><p id="716e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">课程组件非常简单，是一个漂亮的哑组件:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="0950" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">课程目录组件存储</h2><p id="0aee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">啊，现在是最终查看组件存储实现的时候了:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="54a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可以看到我们把选择器，更新器和效果放在哪里了。所有这些都在组件存储服务中进行了很好的重新组合。</p><p id="3642" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们回顾一下每种类型的一个元素，尽管我们在本文前面已经讨论过了。</p><p id="0982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">选择器</strong>:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个选择器只是返回状态的<code class="fe nn no np mq b">canAddLessons</code>属性。很简单。</p><p id="46c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更新器</strong>:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当被调用时，这个名为<code class="fe nn no np mq b">addLesson</code>的更新器接收当前状态以及要更新的教训对象。鉴于它是如何实现的，它也可以被称为addOrUpdate，但这并不太重要。如您所见，updater函数创建并返回了一个全新的状态对象(同样，这很重要)。在生产应用程序中，我建议使用Immer的produce函数来实现它。</p><p id="9b63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">效果</strong>:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="785d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe nn no np mq b">loadLessons</code>效果并不惊天动地，但是它应该给你一个效果如何工作的概念。当effect被调用时，它们期望接收一些输入(实际上是随着时间的推移的多个输入)，并且可观察到的输入以神奇和神秘的方式传输。</p><p id="44af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们可以想象这种效应触发了数据的异步加载，然后调用一个更新器来更新状态树。</p><p id="1742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢RxJS，那就随便扇我耳光，我知道我活该，但这只是个例。如果你的RxJS-fu不是很棒，一定要了解使用switchMap进行此类操作的风险；-)</p><p id="18c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，如果你看一下Github 上的代码<a class="ae kf" href="https://github.com/dsebastien/ngrx-component-store-demo/blob/master/src/app/lessons-catalog/lessons-catalog-component-store.service.ts#L121" rel="noopener ugc nofollow" target="_blank">，你会发现我把效果做得更有趣了</a><a class="ae kf" href="https://github.com/dsebastien/ngrx-component-store-demo/blob/master/src/app/lessons-catalog/lessons-catalog-component-store.service.ts#L121" rel="noopener ugc nofollow" target="_blank"/>，增加了一个<code class="fe nn no np mq b">loading</code>状态；当效果开始时，将其设置为<code class="fe nn no np mq b">true</code>，当效果结束时，将其设置回<code class="fe nn no np mq b">false</code>。</p><p id="1127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一件事:对于现实世界的应用，<strong class="ky ir">不要忘记处理你的效果中的错误</strong>。就像NGRX存储效果一样，如果出现错误并且没有得到处理，component-store将让可观察到的流消失！</p><h2 id="3cf0" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">课程目录组件</h2><p id="906a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后但同样重要的是，让我们看看课程目录组件。这是我们应该感受到使用我们的组件存储服务的影响的地方。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="12cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有几件事要提一下。</p><p id="f5f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，注意组件在其providers数组中定义了<code class="fe nn no np mq b">LessonsCatalogComponentStore</code>。这就是我们如何将服务的生命周期与这个组件的生命周期联系起来的(当这个组件被销毁时，相关的服务实例也会被销毁！).它当然允许我们在每个组件实例中注入一个单独的服务实例。注意，它还使同一服务实例对应用程序的这个子树中的任何组件可用</p><p id="cfda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，注意我们在<code class="fe nn no np mq b">ngOnInit</code>方法中设置了一个初始状态。我们可以想象，这个初始状态是由这个表示组件在从路由器或从其他地方(例如，服务、全局NGRX存储等)提取信息之后导出的。</p><p id="4f0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，请注意，这个组件中没有多少内容。几乎是空的！这真的很酷。没有太多状态，没有太多逻辑。不需要；那现在大部分在我们的组件商店里！</p><p id="9270" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们看看模板:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b47d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我直接使用模板中的目录组件存储。我本可以在控制器上添加处理程序方法或定义字段来公开选择器(例如，将模板与组件存储区隔离开)，但这感觉像是添加了不必要的间接内容。</p><p id="4075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在提供设计指导还为时过早(仍在学习中)，所以不要认为这是“正确的”方法…</p><p id="8c74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要为烟斗流汗；我只是想尝试一下ngrx组件，这是下一篇文章的主题:p。</p><p id="5599" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件和子组件的状态由组件库保存，我们可以使用前面看到的选择器轻松地订阅特定的状态部分。</p><p id="2c3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，像添加/删除东西这样的操作直接向组件库请求，组件库有更新程序和效果来处理一切。</p><p id="1f2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！</p><h1 id="19ff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">少了什么？</h1><p id="81e3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">希望很快会有第一个最终版本。我没有问Alex它什么时候发布，但是我想象在不太遥远的将来…-)</p><p id="664d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我看到在component-store周围也有一些开放的门票:</p><ul class=""><li id="08ec" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">一个补充<a class="ae kf" href="https://github.com/ngrx/platform/issues/2570" rel="noopener ugc nofollow" target="_blank">原理图</a></li><li id="7376" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">一加<a class="ae kf" href="https://github.com/ngrx/platform/issues/2569" rel="noopener ugc nofollow" target="_blank"> ng加支持</a></li></ul><h1 id="d691" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><p id="2fbb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本文的代码示例都可以在Github上找到:<a class="ae kf" href="https://github.com/dsebastien/ngrx-component-store-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/dsebastien/ngrx-component-store-demo</a></p><p id="68fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kf" href="https://ngrx-component-store-demo.netlify.app/" rel="noopener ugc nofollow" target="_blank">现场演示在Netlify</a>:<a class="ae kf" href="https://ngrx-component-store-demo.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://ngrx-component-store-demo.netlify.app/</a>上线</p><ul class=""><li id="3ceb" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">官方文件:<a class="ae kf" href="https://ngrx.io/guide/component-store" rel="noopener ugc nofollow" target="_blank">https://ngrx.io/guide/component-store</a></li><li id="8e2f" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">设计文件:<a class="ae kf" href="https://okrushko.dev/component-store-dd" rel="noopener ugc nofollow" target="_blank">https://okrushko.dev/component-store-dd</a></li><li id="3859" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">刘彦生活流覆盖组件-商店:<a class="ae kf" href="https://www.youtube.com/watch?v=EeNMGhLnBGg" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=EeNMGhLnBGg</a>&amp;<a class="ae kf" href="https://www.youtube.com/watch?v=-hp72aA0wBw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=-hp72aA0wBw</a></li><li id="c0da" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">ComponentStore类的来源:<a class="ae kf" href="https://github.com/ngrx/platform/blob/master/modules/component-store/src/component-store.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/ngrx/platform/blob/master/modules/component-store/src/component-store . ts</a></li></ul><h1 id="0d35" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="5130" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本文中，我解释了<a class="ae kf" href="https://ngrx.io/guide/component-store" rel="noopener ugc nofollow" target="_blank"> NGRX组件库</a>的概念和API。我还向您展示了一个简单的演示，展示了它的易用性。</p><p id="f558" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望您现在对NGRX组件存储是什么以及它是如何工作的有一个清晰的概念。</p><p id="317c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我确信NGRX的这个新模块带来了有趣的想法，对于将状态/逻辑隔离在复杂组件之外，使它们更容易处理，这些想法肯定是有价值的。</p><p id="8f7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我在上一篇文章中解释的那样，组件存储也为使用全局NGRX存储没有意义的情况提供了一个答案。</p><p id="9eb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，它将允许我们使复杂的有状态组件可重用，甚至跨应用程序共享。也许这为更容易地将复杂组件集成到Storybook中铺平了道路？相当酷！</p><p id="4b79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢Kevin Elko提出这个想法/原始设计，感谢Alex Okrushko将它带入NGRX！</p><p id="2e92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止！</p><h1 id="b8c8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">喜欢这篇文章吗？</h1><p id="4edf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你想了解关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的大量其他很酷的东西，那么不要犹豫<a class="ae kf" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae kf" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>