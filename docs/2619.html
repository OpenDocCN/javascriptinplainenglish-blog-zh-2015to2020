<html>
<head>
<title>Useful JavaScript Tips — Sets, Hidden Elements, and Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的JavaScript技巧——集合、隐藏元素和循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useful-javascript-tips-sets-hidden-elements-and-loops-b767baa4d45a?source=collection_archive---------10-----------------------#2020-07-09">https://javascript.plainenglish.io/useful-javascript-tips-sets-hidden-elements-and-loops-b767baa4d45a?source=collection_archive---------10-----------------------#2020-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e219f8af177934e9c6c12e4fabec3047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yYa88aTZI1sx3fxP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tgrossen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Travis Grossen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a81b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些应该遵循的技巧，以便更快更好地编写JavaScript代码。</p><h1 id="55dc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置</h1><p id="5ad0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">集合是用于存储无重复项的有用数据结构。</p><p id="b382" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是一个iterable对象，是用<code class="fe me mf mg mh b">Set</code>构造函数创建的。</p><h1 id="8c10" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">初始化集合</h1><p id="5b14" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Set</code>构造函数创建一个集合。</p><p id="44ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a516" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set()</span></pre><h1 id="108e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向器械包中添加物品</h1><p id="df88" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">add</code>方法向集合中添加项目。</p><p id="aa21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7933" class="mq lc iq mh b gy mr ms l mt mu">set.add('foo');<br/>set.add('bar');</span></pre><h1 id="de5d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查物品是否在器械包中</h1><p id="8aca" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">集合有一个<code class="fe me mf mg mh b">has</code>方法来检查一个项目是否在集合中。</p><p id="e133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7f2" class="mq lc iq mh b gy mr ms l mt mu">set.has('foo');<br/>set.has('bar');</span></pre><h1 id="03db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从集合中删除项目</h1><p id="10fd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">delete</code>来删除一个已设置的项目。</p><p id="277a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5cdb" class="mq lc iq mh b gy mr ms l mt mu">set.delete('foo');</span></pre><h1 id="d586" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">确定器械包中物品的数量</h1><p id="fdeb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">属性让我们获得一个集合中的项目数。</p><p id="250b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f45c" class="mq lc iq mh b gy mr ms l mt mu">set.size</span></pre><h1 id="d063" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从集合中移除所有项目</h1><p id="b58c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">方法从集合中移除所有的项目。</p><p id="cfb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="88e2" class="mq lc iq mh b gy mr ms l mt mu">set.clear()</span></pre><h1 id="a0fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">迭代集合中的项目</h1><p id="8873" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用for-of循环来遍历集合中的项目。</p><p id="1228" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0900" class="mq lc iq mh b gy mr ms l mt mu">for (const k of set.keys()) {<br/>  console.log(k)<br/>}</span></pre><p id="cb46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">循环通过该组的键。</p><p id="2e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">values()</code>方法来做同样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c482" class="mq lc iq mh b gy mr ms l mt mu">for (const v of set.values()) {<br/>  console.log(v)<br/>}</span></pre><p id="785a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有返回迭代器的<code class="fe me mf mg mh b">entries</code>方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="10b2" class="mq lc iq mh b gy mr ms l mt mu">const i = set.entries();</span></pre><p id="d0ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">next</code>方法来获取序列中的下一个条目:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="851f" class="mq lc iq mh b gy mr ms l mt mu">i.next()</span></pre><p id="97c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回的对象具有<code class="fe me mf mg mh b">value</code>或<code class="fe me mf mg mh b">done</code>属性。</p><p id="667c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当序列中有下一项时<code class="fe me mf mg mh b">done</code>为<code class="fe me mf mg mh b">false</code>，否则为<code class="fe me mf mg mh b">true</code>。</p><p id="e323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">value</code>有来自集合的值。</p><h1 id="ab4e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用值初始化集合</h1><p id="f84c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Set</code>构造函数创建带有值的集合:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5671" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set([1, 2, 3]);</span></pre><h1 id="7aa7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">转换为数组</h1><p id="04fc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用spread运算符将集合转换为数组:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4237" class="mq lc iq mh b gy mr ms l mt mu">const arr = [...s.keys()]</span></pre><p id="adcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac75" class="mq lc iq mh b gy mr ms l mt mu">const arr = [...s.values()]</span></pre><h1 id="dd50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">WeakSet</h1><p id="abaa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">WeakSet是一种特殊的<code class="fe me mf mg mh b">Set</code>。</p><p id="2f08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">项目永远不会在集合中被垃圾收集。</p><p id="17a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WeakSet中的项目可以被垃圾回收。</p><p id="5c33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不能迭代WeakSet中的项目。</p><p id="5e30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们无法清除武器集中的所有物品。</p><p id="6627" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也无法检查它的大小。</p><p id="d2ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，它有添加项目的<code class="fe me mf mg mh b">add</code>方法。</p><p id="9c9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">has</code>检查项目是否存在的方法。</p><p id="b1b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">delete</code>用于删除一个条目。</p><h1 id="48ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查元素是否隐藏</h1><p id="a071" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用jQuery检查一个元素是否被隐藏。</p><p id="845e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2cea" class="mq lc iq mh b gy mr ms l mt mu">$(element).is(":visible");</span></pre><p id="eac7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是对<code class="fe me mf mg mh b">display: none</code>的检查。</p><p id="ca20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="110a" class="mq lc iq mh b gy mr ms l mt mu">$(element).is(":hidden");</span></pre><p id="0f2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并检查<code class="fe me mf mg mh b">visibility: hidden</code>。</p><p id="6c3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以得到隐藏的所有元素:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7b40" class="mq lc iq mh b gy mr ms l mt mu">$(element).is(":hidden");</span></pre><p id="550d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">visible</code>选择器来选择:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f226" class="mq lc iq mh b gy mr ms l mt mu">$('element:visible')</span></pre><h1 id="cbac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">深度克隆对象</h1><p id="19ee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">JSON.stringify</code>和<code class="fe me mf mg mh b">JSON.parse</code>方法深度克隆一个对象。</p><p id="de6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="06f9" class="mq lc iq mh b gy mr ms l mt mu">const cloned = <!-- -->JSON.parse(JSON.stringify(object));</span></pre><p id="9e6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来克隆对象内部带有函数值的<code class="fe me mf mg mh b">object</code>。</p><p id="496d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Infinity</code>将被转换为<code class="fe me mf mg mh b">null</code>并且<code class="fe me mf mg mh b">undefined</code>值将被删除。</p><p id="bb3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，正则表达式文字也被删除。</p><p id="bed9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们没有那些将被转换或丢失的值，我们可以使用它。</p><p id="3328" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用Lodash <code class="fe me mf mg mh b">cloneDeep</code>方法轻松克隆对象。</p><p id="185d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它克隆一个对象中的所有东西。</p><p id="53e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.assign</code>spread语法还将所有可枚举的自身属性的值从一个对象复制到另一个对象。</p><p id="f792" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1774" class="mq lc iq mh b gy mr ms l mt mu">const cloned = Object.assign({}, obj);</span></pre><p id="4c29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="23ee" class="mq lc iq mh b gy mr ms l mt mu">const cloned = {...obj };</span></pre><h1 id="c454" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对于每个循环</h1><p id="5d70" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于for-of循环来说，遍历数组中的所有项是最容易的，</p><p id="7570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Array</code>实例也有<code class="fe me mf mg mh b">forEach</code>方法。</p><p id="9656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">老式的for循环也可以。</p><p id="f751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8061" class="mq lc iq mh b gy mr ms l mt mu">for (const a of arr){<br/>  console.log(a);<br/>}</span></pre><p id="f33b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e956" class="mq lc iq mh b gy mr ms l mt mu">arr.forEach(a =&gt; {<br/>  console.log(a);<br/>})</span></pre><p id="7f57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5575" class="mq lc iq mh b gy mr ms l mt mu">for (let i = 0; i &lt; arr.length; i++){<br/>  console.log(arr[i]);<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/58e4ff3ea68a24d2f25f1ac644400eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VNhr0i7u-kRZ6aRJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jma1053?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Josephine Baran</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2336" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e366" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">集合是一种有用的数据结构，用于存储没有重复的数据。</p><p id="f0ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用jQuery检查隐藏的元素。</p><p id="56e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多方法可以迭代数组。</p><h2 id="5792" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">简单英语的JavaScript</h2><p id="a117" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>