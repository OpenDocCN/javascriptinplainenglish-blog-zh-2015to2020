<html>
<head>
<title>JavaScript: Arrow Functions vs Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:箭头函数与函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-arrow-functions-vs-functions-3f6ce860f8b5?source=collection_archive---------2-----------------------#2020-02-07">https://javascript.plainenglish.io/javascript-arrow-functions-vs-functions-3f6ce860f8b5?source=collection_archive---------2-----------------------#2020-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a5f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">他们真的一样吗？</h2></div><p id="1d83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘿大家好！</p><p id="fab2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我经常听说“箭头函数和<em class="lb"> JavaScript </em>中的函数是相同的，只是语法不同”。为了澄清这一点，我将参考一些它们行为不同的用例，包括一些为什么和注释。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/4067a69220482fa30dd080e02ef2c372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q_OO2J8M-s-DVr-Y"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Photo by <a class="ae ls" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hello I’m Nik 🇬🇧</a> on <a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5780" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">这和争论</h1><h2 id="0d65" class="ml lu iq bd lv mm mn dn lz mo mp dp md ko mq mr mf ks ms mt mh kw mu mv mj mw bi translated">这</h2><p id="dc10" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">让我们看看下面这个匿名函数的例子，它是由<em class="lb"> setTimeout </em>在1000毫秒后调用的。在其中，我们记录了hello变量值和分配给这个的hello属性。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">A function using <em class="ne">this</em></figcaption></figure><p id="7de5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预计输出将是<code class="fe nf ng nh ni b">hello</code>和<code class="fe nf ng nh ni b">hello from this</code>。但是结果却是这样的:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/02a3b9e76000fbb04c6a72312aba36d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*fm_9CSab17kkIe7_340ohQ.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Function using this output</figcaption></figure><p id="4768" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发生这种情况是因为<em class="lb">这个</em>的值是根据运行时调用该函数的方式来确定的。因此，匿名函数正在使用由<em class="lb"> setTimeout </em>提供的<em class="lb"> this </em>，而不是其作用域内的函数。</p><p id="a3fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意:</strong>为了避免这个问题，人们经常使用<em class="lb"> self/that </em>模式来保证他们可以访问自己的作用域<em class="lb"> this </em>，而不是调用者提供的作用域。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Self pattern</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a886e521a7741d5237ef303d193da7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*3YwKR0YFoNsTfNUTWW5qPg.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Self pattern output</figcaption></figure><p id="74de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在看同一个例子，但是用一个箭头函数重写了。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">An arrow function using this</figcaption></figure><p id="725e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看输出。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/68d08161780554bb971023b9ddc6d70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*qWaArJh5b3HMcqV9BN6JfA.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Arrow function using this output</figcaption></figure><p id="8697" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出正是我们对第一个函数示例的预期。发生这种情况是因为<strong class="kh ir">箭头函数没有自己的<em class="lb"/>和<em class="lb">自变量</em> </strong>而取而代之的是利用作用域进行一切操作。</p><h2 id="9d9c" class="ml lu iq bd lv mm mn dn lz mo mp dp md ko mq mr mf ks ms mt mh kw mu mv mj mw bi translated">争论</h2><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">A function logging its arguments returning an anonymous function that also logs its arguments</figcaption></figure><p id="dcdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们定义了一个记录其<em class="lb"> arguments </em>对象内容的函数，并返回一个匿名函数来做同样的事情。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6a325d5502deddd4dfde92d239dbb5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*ylCqXI2W9zUg9d3LzNE3Yw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of the values of the argument for each function</figcaption></figure><p id="31ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出正是我们所期望的。这是因为分配给<em class="lb"> arguments </em>对象的值与每个函数相关，所以每个新函数都有其<em class="lb"> arguments </em>对象。</p><p id="9a4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一个类似的例子，但是使用了箭头函数。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">A function logging its arguments returning an arrow function that also logs its arguments</figcaption></figure><p id="f702" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了同样的例子，但是它没有返回一个匿名函数，而是返回一个箭头函数。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9824336c781e3b7d524993f41319896d.png" data-original-src="https://miro.medium.com/v2/resize:fit:184/format:webp/1*bxNoB4-lY8FNBoFJdHGwdw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of the values of the argument for each function</figcaption></figure><p id="1e70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，arrow函数没有自己的<em class="lb"> this </em>和<em class="lb"> arguments </em>。这里发生的事情是，arrow函数中使用的<em class="lb"> arguments </em>对象是来自其作用域的对象，在本例中，它是来自返回它的函数的对象。</p><p id="a255" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注</strong> : <em class="lb"> ES6 </em>为我们介绍了<em class="lb">的其余参数</em>。使用<em class="lb"> rest参数</em>优于使用<em class="lb"> arguments </em>对象，因为每个函数和arrow函数都有自己的一个。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Using rest parameters</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6a325d5502deddd4dfde92d239dbb5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*ylCqXI2W9zUg9d3LzNE3Yw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of using rest parameters for each function</figcaption></figure><h1 id="a622" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用绑定、调用和应用</h1><p id="7a2b" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">使用函数和箭头函数的另一个不同之处是<em class="lb">绑定</em>、<em class="lb">调用、</em>和<em class="lb">应用</em>函数。这是因为前面提到的<em class="lb">这个</em>的行为。既然arrow函数没有自己的<em class="lb"> this，</em>那么试图用这些函数绑定或传递它就无关紧要了。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Using apply with a function</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/571a1d919c94aad15c123234dd89631b.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*8Kh4LOYxK0Qr7TyLh9c7Mw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of using apply with a function</figcaption></figure><p id="e84b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子如预期的那样工作。使用<em class="lb">调用</em>函数时传递的对象被绑定到<em class="lb">这个</em>函数。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Using apply with an arrow function</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9d3698c6508212e9dc623793feaad097.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*VaOEtXUwdUHLRGU-J6EUlg.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of using apply with an arrow function</figcaption></figure><p id="f87e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，分配给<em class="lb"> this </em>的hello属性的输出是<em class="lb"> undefined </em>，因为尽管在使用<em class="lb"> call </em>时试图分配它，但arrow函数没有为这个绑定工作的<em class="lb">this</em>——同样，由于全局<em class="lb"> this </em>没有hello属性，它将记录<em class="lb"> undefined </em>。</p><h2 id="7cc6" class="ml lu iq bd lv mm mn dn lz mo mp dp md ko mq mr mf ks ms mt mh kw mu mv mj mw bi translated">箭头函数不能充当构造函数</h2><p id="5b6e" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">如果我们想要创建对象，我们会使用构造函数。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Constructor Function</figcaption></figure><p id="d0cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在上面看到的，为了实例化一个对象，我们使用了<em class="lb"> new </em>关键字来调用这个函数作为构造函数。对于箭头函数，这不起作用，因为箭头函数不能作为构造函数调用。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">An attempt of calling an arrow function as a constructor</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8d12aa07d8c8cffbcb44dc535e1f9c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*Oa6-HCUbzN85eeY8WxruzQ.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of the failed attempt</figcaption></figure><p id="8613" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意</strong>:在<em class="lb"> ES6 </em>之后，我们可以留下构造函数，使用一个<em class="lb">类</em>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Using a class</figcaption></figure><p id="6414" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注2 </strong>:由于arrow函数不能作为构造函数调用，试图在其中使用<em class="lb"> new.target </em>会抛出错误。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nr"><img src="../Images/218a1bc3f66781b9b69d7c1a9868b504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESFh5fYUtnGO1Bi5_TAQew.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of the attempt of using new.target inside an arrow function</figcaption></figure><h1 id="a784" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">箭头函数没有原型</h1><p id="093a" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">尽管函数有<em class="lb">原型</em>属性，但箭头函数没有。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Using prototypes with a function and an arrow function</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/32851972769012d7ac797a5c0cf8248e.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*gND4W5iSQa2p24eXiybY_Q.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of each prototype</figcaption></figure><h1 id="f4a2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">箭头函数不能是生成器</h1><p id="a2d9" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">箭头函数不支持在其体内使用<em class="lb"> yield </em>，除非在嵌套函数内。此外，还没有合适的<em class="lb">语法</em>和生成器箭头函数的实现。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Generator</figcaption></figure><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">An attempt of Generator with Arrow Function</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2fa721d4b7f8e0d6ccf480209d66a522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*BdTKtDL8dlVz7fE_c8rDOw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of the attempt</figcaption></figure><h1 id="8299" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">要小心</h1><h2 id="c8ba" class="ml lu iq bd lv mm mn dn lz mo mp dp md ko mq mr mf ks ms mt mh kw mu mv mj mw bi translated">对象文字</h2><p id="a17c" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">使用箭头函数返回对象文字必须用括号括起来，以保证它的键不被视为标签。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The name is being treated as a label</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b130989fd7117086fa952ac1ae373099.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*7KP1zSZu-I4E-tx4Tq1Jfg.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of the return of the arrow function</figcaption></figure><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Since we wrapped with parentheses, now the key is treated as it should</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d74c2161beb5db573a53e3fbd6b0daf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:298/format:webp/1*Sz0WlUuJj7pbhzh7A92jZg.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The output of wrapping the object literal with parentheses</figcaption></figure><h1 id="e285" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="a708" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">即使看起来一样，箭头函数的行为也不像常规函数。它们对<em class="lb">这个</em>和<em class="lb">参数</em>没有绑定，没有<em class="lb">原型、</em>，不能作为生成器或构造器使用。</p><p id="d630" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，arrow函数允许编写更短的函数，减少函数的大小和“噪音”。我们所要做的就是小心整篇文章中提到的一些细微差别。</p><p id="09e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢并关注未来的帖子。</p></div></div>    
</body>
</html>