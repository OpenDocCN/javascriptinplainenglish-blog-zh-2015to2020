<html>
<head>
<title>Fix Memory Leaks in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复JavaScript中的内存泄漏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fixing-memory-leak-in-javascript-fa5fc8abd42a?source=collection_archive---------4-----------------------#2020-11-06">https://javascript.plainenglish.io/fixing-memory-leak-in-javascript-fa5fc8abd42a?source=collection_archive---------4-----------------------#2020-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ae8482b2bd685b159ea9f50de8315545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvPE6_djZVFNW4ygNpJeCw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Memory costs</figcaption></figure><p id="6c1b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">内存泄漏是指应用程序使用的内存即使在使用后也没有释放的情况。这可能会导致操作系统分配给应用程序的内存比所需的多得多。在内存泄漏的情况下，内存分配是渐进的。应用程序的这种内存消耗将不断增加，直到操作系统耗尽它。</p><p id="d8be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">想象一下，你邀请一些客人来吃晚饭，他们拿走了你漂亮的陶瓷盘子，吃完饭后还不肯放手。然后非常优雅地继续拿更多，直到他们拥有一切。这基本上是内存泄漏。让我们看看JavaScript中内存泄漏的不同之处。</p><h1 id="151d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JavaScript中的内存管理</h1><p id="ea57" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">一般来说内存管理有3个过程:<br/> 1。分配<br/> 2。用法<br/> 3。收集/释放</p><p id="fcd6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你创建的每个对象/变量都要经历这三个阶段。这里我们关注的是最后一个过程:收集/释放。在JavaScript中，这个过程是隐式的，称为垃圾收集。</p><p id="4f4c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">不幸的是，这种便利让我们忽略了应用程序的内存使用，导致web应用程序使用了比它实际应该使用的更多的内存。更糟糕的是，这使得即使是最简单的应用程序也更容易发生内存泄漏。</p><p id="c6fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那么，如何识别内存泄漏呢？</p><h1 id="4d4e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">识别内存泄漏</h1><ol class=""><li id="3471" class="ma mb in kb b kc lv kg lw kk mc ko md ks me kw mf mg mh mi bi translated"><strong class="kb io">内存泄漏初步测试:<br/> </strong>当您导航到web应用程序中的某个页面时，性能会在一段时间内逐渐下降，这可能是内存泄漏的迹象。然而，这不是决定性的，因为这只是一个严重资源消耗的迹象，也可能是糟糕的网络或严重的CPU消耗。</li><li id="ade3" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated"><strong class="kb io">内存泄漏的二次测试:<br/> </strong>你可以简单地在chrome中打开任务管理器，观察这个特定标签的内存占用情况。如果它持续增加，很有可能存在内存泄漏。</li><li id="a822" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated"><strong class="kb io">内存泄漏的决定性测试:<br/> </strong>前两个测试虽然有效，但只能检测到中度到重度的内存泄漏。有时内存泄漏真的很小，并且只有在很长一段时间后才会显示出它们的影响。这种方法甚至可以检测到最小的内存泄漏。因此，这是推荐的方法，以确保你的客人不会拿走你所有的盘子。这涉及到使用Chrome inspector的性能功能。</li></ol></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="91ce" class="kx ky in bd kz la mv lc ld le mw lg lh li mx lk ll lm my lo lp lq mz ls lt lu bi translated"><strong class="ak"> 1。使用性能可视化泄漏</strong></h1><p id="6455" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">以下是记录演奏的步骤:<br/> 1。打开Chrome检查器并导航到性能选项卡。<br/> 2。确保选中内存复选框。<br/> 3。单击录制按钮。<br/> 4。执行您怀疑导致内存泄漏的操作。<br/> 5。等待一段时间(30-60秒)并停止录制。</p><p id="9297" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在是检查内存图的时候了。你会在屏幕上看到许多图表。您需要寻找下图所示的蓝色图表:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/9e9efb3162b20608b356acfce5d51953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9HAcG-HYb8vApLCFJh1oA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Normal JS Heap Performance</figcaption></figure><p id="302a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上图蓝色阶梯图就是你的JS堆。通常情况下，当页面加载时，随着对象的分配，您会期望内存增加，并且在垃圾收集时会发生下降(<em class="nf">标有橙色圆圈</em>)。当页面完全加载后，您会看到在内存消耗方面达到了平衡。该图将随时间在该最大值和最小值之间振荡。如果你的图表像这样，你的应用程序没有内存泄漏。万岁！让我们来看一个内存泄漏案例:</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/14fd1632e2377ecffa9e4880c1487487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jBCqkgjebnK7N-m9crKT2g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Memory Leak</figcaption></figure><p id="6655" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">JS堆的这个阶梯图清楚地表明您的应用程序中存在内存泄漏。这里，dip再次表示垃圾收集，但是，在这种情况下，内存分配随着时间的推移不断增加。最终，页面性能会显著下降。这证实了你的应用有内存泄漏。</p><p id="97e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有时候，图表不是很清晰。在这种情况下，您需要记录更长时间的性能，以查看长期趋势。现在我们知道我们有一个内存泄漏，是时候修复它了。</p><h1 id="0936" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.修补漏洞</h1><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/f3f826c31657144a20bc8d11dbb5d6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U47ewuGNCdMRuef6PXbzIw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">“Debugging is a crime scene where you are the detective, the victim and the criminal”</figcaption></figure><p id="9a5d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们需要从确定导致内存泄漏的嫌疑人开始。Chrome Inspector中的内存标签将帮助我们做到这一点。</p><p id="aa43" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">单击内存选项卡。这里，您有三个选择来拍摄内存快照:</p><ol class=""><li id="8d99" class="ma mb in kb b kc kd kg kh kk ni ko nj ks nk kw mf mg mh mi bi translated"><a class="ae nl" href="https://developers.google.com/web/tools/chrome-devtools/memory-problems/heap-snapshots" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> JS堆快照</strong> </a> <strong class="kb io"> : </strong>显示JS对象和DOM元素的内存分布。</li><li id="7a5d" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated"><strong class="kb io">时间线上的分配检测:</strong>显示特定时间间隔内的JS对象内存分配。这用于隔离内存泄漏。</li><li id="6f86" class="ma mb in kb b kc mj kg mk kk ml ko mm ks mn kw mf mg mh mi bi translated"><a class="ae nl" href="https://developers.google.com/web/tools/chrome-devtools/memory-problems/allocation-profiler" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">分配采样</strong> </a> <strong class="kb io"> : </strong>按JS执行任务分解内存分配。具有最少的性能开销。</li></ol><p id="6aac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里我们主要关注JS堆快照和分配采样。您可以选择它们中的每一个并记录快照。</p><h1 id="7671" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JS堆快照</h1><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/a259aa83ec45554ff85fc9f1486b4e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Aba7bl0q67wZcj43lakxQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">JS Snapshot of a page</figcaption></figure><p id="5589" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里可以看到哪个DOM元素占用了最多的内存。这样，您就可以隔离内存泄漏嫌疑并进一步调查。正如您在图像中看到的，我们列出了对象和距离、浅尺寸以及保留尺寸。</p><p id="b032" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">距离是从DOM中的根节点开始的元素长度。浅层大小指的是对象本身的大小，如数组、JS对象、变量等。保留尺寸是删除对象后<em class="nf">可以保留的尺寸。如果嫌疑对象是一个重复出现的DOM元素或一个不断增加的JS对象，这可以大大缩小搜索范围。</em></p><h1 id="5324" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">分配抽样</h1><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/30197dbbb2850f436b1c1202614e9898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rj5pBxOr1_N3CUnnL81Wbg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Allocation Sampling example</figcaption></figure><p id="6311" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在分配采样中，您可以看到基于单个函数的内存分布。你可以在顶部按权重排序，这样可以列出占用内存最多的函数。一旦知道了函数名，就可以调查该函数所属的代码片段，并找出导致泄漏的原因。</p><h1 id="a1ab" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="adc3" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">这是调试内存泄漏的一种非常有效的方法，可以解决web应用程序中大多数严重的内存泄漏问题。是时候拿回你的陶瓷盘子了！</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="2d66" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果这篇文章对你有帮助，请关注我，我写代码，讲故事。干杯！</p></div></div>    
</body>
</html>