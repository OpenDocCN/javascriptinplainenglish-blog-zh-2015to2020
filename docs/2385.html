<html>
<head>
<title>Functional Programming Concepts Used in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中使用的函数式编程概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-programming-concepts-used-in-react-215e277f3662?source=collection_archive---------3-----------------------#2020-06-19">https://javascript.plainenglish.io/functional-programming-concepts-used-in-react-215e277f3662?source=collection_archive---------3-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5a029b8b38ded262429e734bf3d35dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u5ahCsRbM7ZRFLH0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@verika?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Erika Varju</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2ecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何在React应用程序中使用函数式编程特性。</p><h1 id="1d06" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一等品</h1><p id="5daa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript包含的一个很大的函数式编程特性是，函数和其他任何东西一样都是对象。</p><p id="886f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以将它们设置为属性值，为它们分配变量，并将它们作为参数传入。</p><p id="f7e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cd02" class="mn lc iq mj b gy mo mp l mq mr">const add = (a, b) =&gt; a + b;</span></pre><p id="6f0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写来创建一个函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="26a3" class="mn lc iq mj b gy mo mp l mq mr">const log = func =&gt; (...args) =&gt; {<br/>  console.log(...args);<br/>  return func(...args);<br/>}</span></pre><p id="6487" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以使用<code class="fe ms mt mu mj b">log</code>如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c4ad" class="mn lc iq mj b gy mo mp l mq mr">const add = (a, b) =&gt; a + b;<br/>const logAdd = log(add);<br/>logAdd(1, 2);</span></pre><p id="9925" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe ms mt mu mj b">logAdd</code>来创建它。</p><p id="4cdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">log</code>是一个高阶函数，因为它将一个函数作为自变量。</p><p id="d1e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还返回一个可以用自己的参数调用的函数。</p><p id="addd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe ms mt mu mj b">add</code>函数传递给<code class="fe ms mt mu mj b">log</code>来返回一个函数。</p><p id="6415" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过向返回的函数传递参数来调用它。</p><h1 id="0086" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">纯函数</h1><p id="5eb1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">纯函数是不产生副作用，只返回某些东西的函数。</p><p id="09e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着它们不会改变函数之外的任何东西。</p><p id="f850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不纯的函数更难调试，因为它们改变了函数之外的东西。</p><p id="f201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8963" class="mn lc iq mj b gy mo mp l mq mr">const add = (a, b) =&gt; a + b</span></pre><p id="9aff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这就是一个纯函数，因为它只返回某些东西，不做任何其他事情。</p><p id="206f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，以下不是一个纯函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e4da" class="mn lc iq mj b gy mo mp l mq mr">let sum;<br/>const add = (a, b) =&gt; {<br/>  sum = a + b;<br/>  return sum;<br/>}</span></pre><p id="d7dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它改变了函数之外的<code class="fe ms mt mu mj b">sum</code>的值。</p><h1 id="ae15" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不变</h1><p id="a734" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不可变数据是另一个函数式编程特性。</p><p id="d14d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好，因为它减少了数据意外变化的机会。</p><p id="ee6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然不能不小心更改数据，就不用担心有意外了。</p><p id="5473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些事情会改变数据。例如，数组的<code class="fe ms mt mu mj b">push</code>方法改变了现有的数组。</p><p id="2370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6ca8" class="mn lc iq mj b gy mo mp l mq mr">arr.push(3)</span></pre><p id="681b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们加3作为<code class="fe ms mt mu mj b">arr</code>的最后一个值。</p><p id="40eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们使用spread操作符，那么我们不会改变现有的数组:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="36a8" class="mn lc iq mj b gy mo mp l mq mr">const newArr = [...arr, 3];</span></pre><p id="a444" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们给<code class="fe ms mt mu mj b">arr</code>和<code class="fe ms mt mu mj b">newArr</code>分配了一个新的数组。</p><h1 id="1f3c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Currying</h1><p id="513a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Currying是将接受多个参数的函数转换为一次接受一个参数的函数的过程。</p><p id="e6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ee58" class="mn lc iq mj b gy mo mp l mq mr">const add = (a, b) =&gt; a + b</span></pre><p id="8ef2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e957" class="mn lc iq mj b gy mo mp l mq mr">const add = a =&gt; b =&gt; a + b</span></pre><p id="5f0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于第二个<code class="fe ms mt mu mj b">add </code>函数，我们通过编写来调用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0212" class="mn lc iq mj b gy mo mp l mq mr">const sum = add(1)(2);</span></pre><p id="6739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多次重用由<code class="fe ms mt mu mj b">add</code>返回的函数是一种方便的方法。</p><p id="94a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b74b" class="mn lc iq mj b gy mo mp l mq mr">const addOne = add(1);<br/>const sum1 = addOne(2);<br/>const sum2 = addOne(3);</span></pre><h1 id="ae4d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">作文</h1><p id="1f04" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">组合是将多种功能组合起来做更高级或更复杂的事情的概念。</p><p id="943b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9d82" class="mn lc iq mj b gy mo mp l mq mr">const add = (a, b) =&gt; a + b<br/>const cube = x =&gt; x ** 3</span></pre><p id="1647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后可以通过书写将它们结合起来:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2e55" class="mn lc iq mj b gy mo mp l mq mr">const cubed = cube(add(1, 3));</span></pre><p id="ae20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">add</code>，然后对返回的结果调用<code class="fe ms mt mu mj b">cube</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/1ca070e42bf88ef1991e57772a28ce38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQMIeSw7hmBlxxQd"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freetousesoundscom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Free To Use Sounds</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7428" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数式编程和反应</h1><p id="c6bd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们使用函数式编程来对嵌套组件做出反应，也用于创建更高阶的组件。</p><p id="1962" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">高阶组件在向它们传递一个组件后返回一个新组件。</p><p id="513f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有。钩子可以组成。</p><p id="52c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将一个函数传递给<code class="fe ms mt mu mj b">useState</code>钩子中返回的函数，用新值更新现有值。</p><h1 id="3e95" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="da53" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数式编程在React项目中很重要。</p><p id="9cb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将经常使用它来创建嵌套组件、高阶函数、钩子等等。</p><h2 id="ba62" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">简单英语的JavaScript</h2><p id="dc91" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四种出版物吗？通过<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> plainenglish.io </strong> </a>找到他们——通过关注我们的出版物和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>