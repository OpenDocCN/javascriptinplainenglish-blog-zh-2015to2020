<html>
<head>
<title>Building the Same Component in Vue2 vs. Vue3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Vue2和Vue3中构建相同的组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-the-same-component-in-vue2-vs-vue3-ed47a09ade15?source=collection_archive---------1-----------------------#2020-02-25">https://javascript.plainenglish.io/building-the-same-component-in-vue2-vs-vue3-ed47a09ade15?source=collection_archive---------1-----------------------#2020-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a84eee8a9c73a7a0b6c47ef56c2df984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L6AUYb5Us3-JxViU"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Safar Safarov</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="f566" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">随着Vue3的发布即将到来，许多人都在想“Vue2和Vue3有什么不同？”</h2></div><p id="c1b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管我们以前写过关于即将到来的最大变化的文章，但我们还没有真正深入地研究过<em class="lr">到底是</em>我们的代码将如何变化。为了展示这些变化，我们将在Vue2和Vue3中构建一个简单的表单组件。</p><p id="e48a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到本文结束时，您将理解Vue2和Vue3之间的主要编程差异，并开始成为一名更好的开发人员。</p><p id="61bd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想知道如何构建你的第一个Vue3应用，看看我们的初学者指南。</p><p id="8c1e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好吧——我们走！</p><h2 id="dd3d" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">创建我们的模板</h2><p id="4ee6" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">对于大多数组件，Vue2和<a class="ae jd" href="https://learnvue.co/2019/12/what-you-need-to-know-about-vue3-in-2020/" rel="noopener ugc nofollow" target="_blank"> Vue3 </a>中的代码即使不完全相同，也会非常<em class="lr">相似</em>。然而，Vue3支持片段，这意味着组件可以有多个根节点。</p><p id="f3bc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这在呈现列表中的组件以移除不必要的包装div元素时特别有用。但是，在这种情况下，我们将为表单组件的两个版本保留一个根节点。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5f80" class="ls lt jg mv b gy mz na l nb nc">&lt;template&gt;<br/>  &lt;div class='form-element'&gt;<br/>    &lt;h2&gt; {{ title }} &lt;/h2&gt;<br/>    &lt;input type='text' v-model='username' placeholder='Username' /&gt;<br/>    <br/>    &lt;input type='password' v-model='password' placeholder='Password' /&gt;<br/><br/>    &lt;button @click='login'&gt;<br/>      Submit<br/>    &lt;/button&gt;<br/>    &lt;p&gt; <br/>      Values: {{ username + ' ' + password }}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="8c20" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一真正的区别是我们如何访问我们的数据。在Vue3中，我们的反应数据都包装在一个反应状态变量中——所以我们需要访问这个状态变量来获得我们的值。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="af82" class="ls lt jg mv b gy mz na l nb nc">&lt;template&gt;<br/>  &lt;div class='form-element'&gt;<br/>    &lt;h2&gt; {{ state.title }} &lt;/h2&gt;<br/>    &lt;input type='text' v-model='state.username' placeholder='Username' /&gt;<br/>    <br/>    &lt;input type='password' v-model='state.password' placeholder='Password' /&gt;<br/><br/>    &lt;button @click='login'&gt;<br/>      Submit<br/>    &lt;/button&gt;<br/>    &lt;p&gt; <br/>      Values: {{ state.username + ' ' + state.password }}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><h2 id="b7bd" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">设置数据</h2><p id="cc76" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx jh">这就是主要区别所在Vue2选项API与Vue3 </strong> <a class="ae jd" href="https://learnvue.co" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jh">组合API。</strong> </a></p><p id="3e86" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Options API将我们的代码分成不同的属性:数据、计算属性、方法等。同时，组合API允许我们按照功能而不是属性的类型对代码进行分组。</p><p id="09b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于我们的表单组件，假设我们只有两个数据属性:一个<code class="fe nd ne nf mv b">username</code>和一个<code class="fe nd ne nf mv b">password</code>。</p><p id="e0a9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Vue2代码看起来像这样——我们只是在数据属性中添加了两个值。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9dee" class="ls lt jg mv b gy mz na l nb nc">export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  data () {<br/>    return {<br/>      username: '',<br/>      password: ''<br/>    }<br/>  }<br/>}</span></pre><p id="9f70" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae jd" href="https://learnvue.co/2019/12/what-does-vuejs-3-0-mean-for-web-development/" rel="noopener ugc nofollow" target="_blank"> Vue 3.0 </a>中，我们必须付出更多的努力，使用一个新的<code class="fe nd ne nf mv b">setup()</code>方法，在那里我们所有的组件初始化都应该发生。</p><p id="4084" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，为了给开发者更多的控制权，我们可以直接访问Vue的reactivity API。</p><p id="bf4a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建反应数据包括三个步骤:</p><ol class=""><li id="fbb5" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">从vue导入<code class="fe nd ne nf mv b">reactive</code></li><li id="0b3c" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">使用反应式方法声明我们的数据</li><li id="89c0" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">让我们的<code class="fe nd ne nf mv b">setup</code>方法返回反应数据，这样我们的模板就可以访问它</li></ol><p id="fea1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在代码方面，它看起来会有点像这样。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="79f2" class="ls lt jg mv b gy mz na l nb nc">import { reactive } from 'vue'<br/><br/>export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  setup () {<br/>    const state = reactive({<br/>      username: '',<br/>      password: ''<br/>    })<br/><br/>    return { state }<br/>  }<br/>}</span></pre><p id="d77f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，在我们的模板中，我们像访问<code class="fe nd ne nf mv b">state.username</code>和<code class="fe nd ne nf mv b">state.password</code>一样访问它们</p><h2 id="9e41" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">在Vue2和Vue3中创建方法</h2><p id="580b" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">Vue2选项API有一个单独的方法部分。在其中，我们可以定义我们所有的方法，并按照我们想要的方式组织它们。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="b063" class="ls lt jg mv b gy mz na l nb nc">export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  data () {<br/>    return {<br/>      username: '',<br/>      password: ''<br/>    }<br/>  },<br/>  methods: {<br/>    login () {<br/>      // login method<br/>    }<br/>  }<br/>}</span></pre><p id="63df" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://learnvue.co" rel="noopener ugc nofollow" target="_blank"> Vue3组合API </a>中的setup方法也处理方法。它的工作方式有点类似于声明数据——我们必须首先声明我们的方法，然后<strong class="kx jh">返回它</strong>,以便组件的其他部分可以访问它。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6fdc" class="ls lt jg mv b gy mz na l nb nc">export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  setup () {<br/>    const state = reactive({<br/>      username: '',<br/>      password: ''<br/>    })<br/><br/>    const login = () =&gt; {<br/>      // login method<br/>    }<br/>    return { <br/>      login,<br/>      state<br/>    }<br/>  }<br/>}</span></pre><h2 id="38c3" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">生命周期挂钩</h2><p id="c06c" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在Vue2中，我们可以直接从组件选项中访问<a class="ae jd" href="https://learnvue.co/2019/12/a-beginners-guide-to-vuejs-lifecycle-hooks/" rel="noopener ugc nofollow" target="_blank">生命周期挂钩</a>。对于我们的例子，我们将等待安装的事件。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a01d" class="ls lt jg mv b gy mz na l nb nc">export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  data () {<br/>    return {<br/>      username: '',<br/>      password: ''<br/>    }<br/>  },<br/>  mounted () {<br/>    console.log('component mounted')<br/>  },<br/>  methods: {<br/>    login () {<br/>      // login method<br/>    }<br/>  }<br/>}</span></pre><p id="cc1d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在有了Vue3组合API，几乎所有东西都在setup()方法中。这包括安装的生命周期挂钩。</p><p id="0d10" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，默认情况下不包含生命周期挂钩，所以我们必须导入在Vue3中调用的<code class="fe nd ne nf mv b">onMounted</code>方法。这看起来和前面导入reactive一样。</p><p id="903a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，在我们的setup方法中，我们可以通过将onMounted方法传递给我们的函数来使用它。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ba44" class="ls lt jg mv b gy mz na l nb nc">import { reactive, onMounted } from 'vue'<br/><br/>export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  setup () {<br/>    // ..<br/><br/>    onMounted(() =&gt; {<br/>      console.log('component mounted')<br/>    })<br/><br/>    // ...<br/>  }<br/>}</span></pre><h2 id="4723" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">计算属性</h2><p id="963e" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">让我们添加一个计算属性，将用户名转换成小写字母。</p><p id="658c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了在Vue2中实现这一点，我们向options对象添加了一个计算字段。从这里，我们可以这样定义我们的属性…</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="b785" class="ls lt jg mv b gy mz na l nb nc">export default {<br/>  // .. <br/>  computed: {<br/>    lowerCaseUsername () {<br/>      return this.username.toLowerCase()<br/>    }<br/>  }<br/>}</span></pre><p id="3841" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Vue3 的<a class="ae jd" href="https://learnvue.co/2019/12/how-vue3-is-designed-for-both-hobby-devs-and-large-projects/" rel="noopener ugc nofollow" target="_blank">设计允许开发者导入他们所使用的东西，并且在他们的项目中没有不必要的包。本质上，他们不希望开发人员必须包含他们从未使用过的东西，这在Vue2中已经成为一个日益严重的问题。</a></p><p id="907a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以要在Vue3中使用computed属性，我们首先必须将computed导入到我们的组件中。</p><p id="2718" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，类似于我们之前创建反应数据的方式，我们可以将一段反应数据作为计算值，如下所示:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="f577" class="ls lt jg mv b gy mz na l nb nc">import { reactive, onMounted, computed } from 'vue'<br/><br/>export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  setup () {<br/>    const state = reactive({<br/>      username: '',<br/>      password: '',<br/>      lowerCaseUsername: computed(() =&gt; state.username.toLowerCase())<br/>    })<br/><br/>    // ...<br/>  }</span></pre><h2 id="e5f4" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">获取道具</h2><p id="ae62" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">访问道具带来了Vue2和Vue3之间的重要区别——<code class="fe nd ne nf mv b"><strong class="kx jh">this</strong></code><strong class="kx jh">意味着完全不同的东西。</strong></p><p id="9e02" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Vue2中，<code class="fe nd ne nf mv b">this</code>几乎总是指组件，而不是特定的属性。虽然这在表面上使事情变得容易，但它使类型支持变得痛苦。</p><p id="8e09" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，我们可以很容易地访问道具——让我们添加一个简单的例子，比如在挂载钩子时打印出我们的<code class="fe nd ne nf mv b">title</code>道具:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6bdf" class="ls lt jg mv b gy mz na l nb nc">mounted () {<br/>    console.log('title: ' + this.title)<br/>}</span></pre><p id="f2de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而在Vue3中，我们不再使用<code class="fe nd ne nf mv b">this</code>来访问道具、发出事件和获取属性。相反，<code class="fe nd ne nf mv b">setup()</code>方法接受两个参数:</p><ol class=""><li id="a8ee" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated"><code class="fe nd ne nf mv b">props</code> -不可变的访问组件的道具</li><li id="2f7b" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated"><code class="fe nd ne nf mv b">context</code>-vu E3显示的选定属性(发射、插槽、属性)</li></ol><p id="6557" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用props参数，上面的代码如下所示。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c41a" class="ls lt jg mv b gy mz na l nb nc">setup (props) {<br/>    // ...<br/><br/>    onMounted(() =&gt; {<br/>      console.log('title: ' + props.title)<br/>    })<br/><br/>    // ...<br/>}</span></pre><h2 id="ae82" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">发射事件</h2><p id="12f7" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">类似地，Vue2中的<a class="ae jd" href="https://learnvue.co/2020/01/a-vue-event-handling-cheatsheet-the-essentials" rel="noopener ugc nofollow" target="_blank">发射事件</a>非常简单，但是Vue3让您对如何访问属性/方法有更多的控制。</p><p id="9c53" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，假设当“提交”按钮被按下时，我们希望向父组件发出一个登录事件。</p><p id="f076" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Vue2代码只需调用<code class="fe nd ne nf mv b">this.$emit</code>并传入我们的有效载荷对象。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="09bc" class="ls lt jg mv b gy mz na l nb nc">login () {<br/>      this.$emit('login', {<br/>        username: this.username,<br/>        password: this.password<br/>      })<br/> }</span></pre><p id="df62" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，在Vue3中，我们现在知道<code class="fe nd ne nf mv b">this</code>不再表示同一件事，所以我们必须以不同的方式来做。</p><p id="fd7e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，上下文对象公开了<code class="fe nd ne nf mv b">emit</code>，这给了我们与<code class="fe nd ne nf mv b">this.$emit</code>相同的东西</p><p id="cc60" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们所要做的就是将<code class="fe nd ne nf mv b">context</code>作为第二个参数添加到我们的设置方法中。我们将析构上下文对象，使我们的代码更加简洁。</p><p id="429e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们只需调用emit来发送我们的事件。然后，和以前一样，emit方法接受两个参数:</p><ol class=""><li id="39b3" class="ng nh jg kx b ky kz lb lc le ni li nj lm nk lq nl nm nn no bi translated">我们活动的名称</li><li id="9f74" class="ng nh jg kx b ky np lb nq le nr li ns lm nt lq nl nm nn no bi translated">与我们的事件一起传递的有效负载对象</li></ol><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8f1e" class="ls lt jg mv b gy mz na l nb nc">setup (props, { emit }) {<br/>    // ...<br/><br/>    const login = () =&gt; {<br/>      emit('login', {<br/>        username: state.username,<br/>        password: state.password<br/>      })<br/>    }<br/><br/>    // ...<br/>}</span></pre><h2 id="0c71" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">最终的Vue2 vs. Vue3代码！</h2><p id="8432" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">太好了！我们已经熬到最后了。如你所见，在Vue2和Vue3中所有的概念都是一样的，但是我们访问属性的一些方式有了一点点的改变。</p><p id="b507" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总的来说，我认为Vue3将帮助开发人员编写更有组织的代码——尤其是在大型代码库中。这主要是因为Composition API允许您按照特定的特性将代码组合在一起，甚至可以将功能提取到它们自己的文件中，并根据需要将它们导入到组件中。</p><p id="c0e7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的所有内容之后是Vue2中表单组件的代码。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1359" class="ls lt jg mv b gy mz na l nb nc">&lt;template&gt;<br/>  &lt;div class='form-element'&gt;<br/>    &lt;h2&gt; {{ title }} &lt;/h2&gt;<br/>    &lt;input type='text' v-model='username' placeholder='Username' /&gt;<br/>    <br/>    &lt;input type='password' v-model='password' placeholder='Password' /&gt;<br/><br/>    &lt;button @click='login'&gt;<br/>      Submit<br/>    &lt;/button&gt;<br/>    &lt;p&gt; <br/>      Values: {{ username + ' ' + password }}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  data () {<br/>    return {<br/>      username: '',<br/>      password: ''<br/>    }<br/>  },<br/>  mounted () {<br/>    console.log('title: ' + this.title)<br/>  },<br/>  computed: {<br/>    lowerCaseUsername () {<br/>      return this.username.toLowerCase()<br/>    }<br/>  },<br/>  methods: {<br/>    login () {<br/>      this.$emit('login', {<br/>        username: this.username,<br/>        password: this.password<br/>      })<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="0861" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是在Vue3中。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="26f0" class="ls lt jg mv b gy mz na l nb nc">&lt;template&gt;<br/>  &lt;div class='form-element'&gt;<br/>    &lt;h2&gt; {{ state.title }} &lt;/h2&gt;<br/>    &lt;input type='text' v-model='state.username' placeholder='Username' /&gt;<br/>    <br/>    &lt;input type='password' v-model='state.password' placeholder='Password' /&gt;<br/><br/>    &lt;button @click='login'&gt;<br/>      Submit<br/>    &lt;/button&gt;<br/>    &lt;p&gt; <br/>      Values: {{ state.username + ' ' + state.password }}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>import { reactive, onMounted, computed } from 'vue'<br/><br/>export default {<br/>  props: {<br/>    title: String<br/>  },<br/>  setup (props, { emit }) {<br/>    const state = reactive({<br/>      username: '',<br/>      password: '',<br/>      lowerCaseUsername: computed(() =&gt; state.username.toLowerCase())<br/>    })<br/><br/>    onMounted(() =&gt; {<br/>      console.log('title: ' + props.title)<br/>    })<br/><br/>    const login = () =&gt; {<br/>      emit('login', {<br/>        username: state.username,<br/>        password: state.password<br/>      })<br/>    }<br/><br/>    return { <br/>      login,<br/>      state<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="20d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇教程有助于强调Vue代码在Vue3中的一些不同之处。如果还有其他问题，就留言回复吧！</p><p id="d06d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="ad0b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://learnvue.co/vue-3-essentials-cheatsheet/" rel="noopener ugc nofollow" target="_blank">如果你有兴趣了解更多关于Vue 3的知识，请下载我的免费Vue 3备忘单，里面有一些基本知识，比如组合API、Vue 3模板语法和事件处理。</a></p></div></div>    
</body>
</html>