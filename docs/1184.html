<html>
<head>
<title>A few pointers on Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于大O符号的几点提示</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/about-big-o-notation-aedafde0aa65?source=collection_archive---------7-----------------------#2020-02-09">https://javascript.plainenglish.io/about-big-o-notation-aedafde0aa65?source=collection_archive---------7-----------------------#2020-02-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3cb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为一名刚从软件工程训练营毕业的学生，我通过面试找到了我的第一份开发工作，我不止一次地遇到了“大O符号”这个术语。</p><p id="63d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当输入变得任意大时，运行时相对于输入的增长速度对我来说是非常模糊的，这似乎是明天的问题，而不是今天的问题。</p><p id="9d25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我读的文章越多，写的代码越多，为面试练习代码挑战的次数越多，和其他开发人员交谈的次数越多，我就越意识到这是一个多么重要的概念。这就是为什么我决定写这篇文章，列出我所理解的围绕大O符号的关键概念和JavaScript中的具体应用</p></div><div class="ab cl kk kl hr km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ig ih ii ij ik"><h2 id="5b1a" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">一般概念</h2><p id="38a1" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">首先，算法只是完成一组任务所需的一个过程或一组步骤。现在这个问题已经解决了，我们可以继续了。大O由两部分组成:</p><ul class=""><li id="109e" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated"><strong class="jm io">时间复杂度</strong>与我们如何分析一个算法在其输入规模增加时的运行时间有关。</li><li id="01da" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">空间复杂度与需要分配多少额外的内存来运行我们算法中的代码有关。<br/>注意:在本文中，一般来说当提到大O时，空间复杂度是<strong class="jm io">辅助空间复杂度</strong>。这意味着我们感兴趣的是算法所需的空间量，不包括输入所占用的空间。</li></ul><p id="9601" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">时间</strong>复杂性的一些一般规则:</p><ul class=""><li id="49e8" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated">算术运算、变量赋值和访问带索引的数组元素或带键的对象元素是<strong class="jm io">常量</strong> : O(1)。</li><li id="de84" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">在一个循环中，时间复杂度是循环的<strong class="jm io">长度</strong>乘以循环内发生的任何事情。</li></ul><p id="deef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">空间</strong>复杂性的一些一般规则:</p><ul class=""><li id="93c0" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated">JavaScript中的大多数原语类型都是空间中的<strong class="jm io">常量</strong>:O(1)。</li><li id="2bd1" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">字符串需要O(n)个空间，其中n是<strong class="jm io">字符串的长度</strong>。</li><li id="ba0b" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">引用类型一般需要O(n)，其中n是数组的<strong class="jm io">长度</strong>或对象的<strong class="jm io">键数</strong>。</li></ul><p id="5378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下图总结了不同的复杂程度。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/455d117e8cad25bfb4efeaa12f762217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENi6u9Dles2KegA8_XfuCA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk">Big O comparison chart in web development</figcaption></figure><p id="c92b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个图表的重点是展示各种复杂性之间的巨大差异以及它的重要性。事实上，你可以有两个算法来完成相同的任务，但时间复杂度不同，比如说O(2n)-简化为O(n)-和O(n)。在我们的输入是一个包含3个元素的数组的情况下，运行时的差异可能是微不足道的。时间复杂度为O(2n)的算法是6，时间复杂度为O(n)的算法是9。但是在我们的输入是1000个元素的数组的情况下，O(2n)是2000，而O(n)是1 000 000。从这个角度来看，您可以看到更高性能算法的影响。</p></div><div class="ab cl kk kl hr km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ig ih ii ij ik"><h2 id="31b9" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">关于对象的使用</h2><p id="b9b4" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">JavaScript中的对象是<strong class="jm io">无序的</strong>数据结构，一切都存储在<strong class="jm io">键值对</strong>中。当您不需要以特定顺序排列对象的元素时，以及当您需要快速访问、插入和移除时，使用对象是合适的。</p><p id="6a32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对象的一般规则:</p><ul class=""><li id="4d26" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated"><strong class="jm io">插入</strong>、<strong class="jm io">移除</strong>和<strong class="jm io">访问</strong>在时间上与O(1)是常数。</li><li id="486c" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io">搜索</strong>复杂度为O(n)。搜索是检查某条信息是否存储在数据结构中某个位置的值中。没有简单的方法可以做到这一点，如果需要检查所需信息的每一个值，可能会非常快或非常长。</li></ul><p id="a094" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对象方法:</p><ul class=""><li id="527c" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated"><strong class="jm io"> Object.keys </strong>，<strong class="jm io"> Object.values </strong>，<strong class="jm io"> Object.entries </strong>有O(n)</li><li id="c6b0" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io"> Object.hasOwnProperty </strong>有O(1)。如果属性存在，它将返回true，否则返回false。</li></ul></div><div class="ab cl kk kl hr km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ig ih ii ij ik"><h2 id="054a" class="kr ks in bd kt ku kv dn kw kx ky dp kz jv la lb lc jz ld le lf kd lg lh li lj bi translated">关于数组的使用</h2><p id="842d" class="pw-post-body-paragraph jk jl in jm b jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh ig bi translated">JavaScript中的数组是有序的T21数据结构。当数组元素的顺序很重要，并且需要快速访问和快速插入或移除元素时，在算法中使用它们是合适的。</p><p id="4607" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">阵列的一般规则:</p><ul class=""><li id="2821" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated"><strong class="jm io">访问</strong>有O(1)。只要提供一个有效的索引，访问一个元素确实非常容易。不管数组有多长，时间都是不变的。</li><li id="f5f6" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io">插入</strong>的性能取决于元素必须插入的位置。在末尾插入非常简单，并且具有O(1)，而在其他地方插入会非常耗费时间。事实上，在数组的开头插入意味着后面的每个元素都需要用新的索引来修改。所以通常在数组的开头插入O(n)。</li><li id="0061" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io">移除</strong>与插入非常相似。移除数组末尾的元素需要O(1)，而移除数组开头的元素意味着后面的每个元素都需要重新索引，这可能是一个开销很大的操作O(n)。</li><li id="1aba" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io">搜索</strong>一个数组和搜索一个对象的性能是一样的。因为所有的元素都可能被检查，所以假设O(n)用于搜索是合理的。</li></ul><p id="402f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，不应该不惜一切代价避免长数组，但值得注意的是，随着数组大小的增加，许多操作的时间复杂度也会增加。</p><p id="7edf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组方法:</p><ul class=""><li id="51d9" class="lp lq in jm b jn jo jr js jv lr jz ls kd lt kh lu lv lw lx bi translated"><strong class="jm io"> push() </strong>和<strong class="jm io"> pop() </strong>有O(1)，因为它们在末尾插入和移除。</li><li id="f987" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io"> shift() </strong>和<strong class="jm io"> unshift() </strong>有O(n)，因为在数组开头插入和删除会触发重新索引。</li><li id="4ab2" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io"> concat() </strong>有O(n)。由于合并数组的增长，时间也在增长。</li><li id="3644" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io"> slice() </strong>返回一个新数组中数组的一部分，具有O(n)。时间根据新数组中元素的数量而增长。</li><li id="eb98" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io"> splice() </strong>用途广泛但一般认为有O(n)。</li><li id="c7b9" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated"><strong class="jm io"> sort() </strong>有O(n log n)，比O(n)高，因为运算多。</li><li id="f02e" class="lp lq in jm b jn ly jr lz jv ma jz mb kd mc kh lu lv lw lx bi translated">迭代方法—如<strong class="jm io"> map() </strong>、<strong class="jm io"> filter() </strong>、<strong class="jm io"> forEach() </strong>、<strong class="jm io"> reduce() </strong> —具有O(n)，因为对每个元素都应用了一个操作。</li></ul></div><div class="ab cl kk kl hr km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ig ih ii ij ik"><p id="d3d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总结一下，大O是用来分析算法的<strong class="jm io">性能</strong>的。它给了我们一个<strong class="jm io">高</strong> - <strong class="jm io">平</strong>-<strong class="jm io">观</strong>的时空复杂度。不是关于<strong class="jm io">精度</strong>，而是关于<strong class="jm io">一般</strong>趋势<strong class="jm io">。最后，当用大O测量时，复杂度只取决于<strong class="jm io">算法</strong>，而不取决于所使用的<strong class="jm io">硬件</strong>。</strong></p><p id="c824" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读，希望这对您有所帮助。</p></div></div>    
</body>
</html>