<html>
<head>
<title>An important TypeScript feature you might not be using yet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能还没有使用的一个重要的TypeScript特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-important-typescript-feature-you-might-not-be-using-yet-e3a982eabcc7?source=collection_archive---------2-----------------------#2020-09-17">https://javascript.plainenglish.io/an-important-typescript-feature-you-might-not-be-using-yet-e3a982eabcc7?source=collection_archive---------2-----------------------#2020-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bd9b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TypeScript中的映射类型:理解语法并创建自己的类型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/725e588529ef5beb79264a7c096acb53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbZ4d3IzTmi46SzfihlJqw.jpeg"/></div></div></figure><p id="e48f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript用类型扩展了JavaScript，使您能够在错误发生之前捕捉它们。在原语和简单对象上设置类型通常很简单，但是当您需要更复杂结构的小变化时，这可能会变得很棘手。您可能需要一个只读版本，一个只有一些属性的版本，一个所有属性都可以为空的版本。</p><p id="953c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您手动创建这些变体中的每一个，您将会以10种不同的类型表示相同的结构而告终，并且可能会认为TypeScript实际上不值得这样做。</p><p id="1b0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript的映射类型允许您从现有类型创建新类型，从而大大减少了键入工作。映射的类型如下所示:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="67ea" class="ls lt iq lo b gy lu lv l lw lx">type Readonly&lt;T&gt; = {<br/>  readonly [P in keyof T]: T[P]<br/>};</span></pre><p id="2024" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以映射属性，并且可以通过指定一些规则来转换每个属性类型。要映射所有属性，可以使用索引类型查询操作符<code class="fe ly lz ma lo b">keyof</code>。在类型上调用时，它创建其属性名的字符串联合。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="6d4b" class="ls lt iq lo b gy lu lv l lw lx">interface Coordinates {<br/>  longitude: number;<br/>  latitude: number;<br/>}<br/><br/>type Properties = keyof Coordinates;<br/>// Properties = "longitude" | "latitude"</span></pre><p id="fb2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ly lz ma lo b">in</code>关键字，可以迭代从<code class="fe ly lz ma lo b">keyof</code>获得的属性。一旦你拥有了接口<code class="fe ly lz ma lo b">T</code>的属性<code class="fe ly lz ma lo b">P</code>，你就可以通过简单地调用<code class="fe ly lz ma lo b">T[P]</code>来访问<code class="fe ly lz ma lo b">P</code>的类型。<code class="fe ly lz ma lo b">T[P]</code>是查找类型，代表<code class="fe ly lz ma lo b">T</code>中属性<code class="fe ly lz ma lo b">P</code>的类型。在<code class="fe ly lz ma lo b">Coordinates</code>示例中，您可以通过调用将返回<code class="fe ly lz ma lo b">number</code>的<code class="fe ly lz ma lo b">Coordinates['longitude']</code>来获取<code class="fe ly lz ma lo b">longitude</code>属性的类型。</p><p id="eb8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们可以创建一个映射类型<code class="fe ly lz ma lo b">Identity</code>，它创建一个与原始类型完全相同的新类型。如果你给它传递一个类型<code class="fe ly lz ma lo b">T</code>，它映射<code class="fe ly lz ma lo b">T</code>的属性，并为每个属性<code class="fe ly lz ma lo b">P</code>设置<code class="fe ly lz ma lo b">P</code>的类型为<code class="fe ly lz ma lo b">T[P]</code>。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="08cf" class="ls lt iq lo b gy lu lv l lw lx">type Identity&lt;T&gt; = {<br/>  [P in keyof T]: T[P]<br/>};</span></pre><p id="7557" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以通过调用<code class="fe ly lz ma lo b">Identity&lt;Coordinates&gt;</code>将其应用于<code class="fe ly lz ma lo b">Coordinates</code>。它将创建一个类型为<code class="fe ly lz ma lo b">Coordinates['longitude']</code>的属性<code class="fe ly lz ma lo b">longitude</code>，也就是<code class="fe ly lz ma lo b">number</code>，以及一个类型为<code class="fe ly lz ma lo b">Coordinates['latitude']</code>的属性<code class="fe ly lz ma lo b">latitude</code>，再次是<code class="fe ly lz ma lo b">number</code>。</p><p id="beb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ly lz ma lo b">Identity</code>映射类型没有实际用途，但是您可以在映射类型中的每个属性类型上应用一些转换。例如，您可以将属性设置为readonly，正如我们在第一个示例中所做的那样:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="19d6" class="ls lt iq lo b gy lu lv l lw lx">type Readonly&lt;T&gt; = {<br/>  readonly [P in keyof T]: T[P]<br/>};</span></pre><p id="3025" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常典型的用例，它是TypeScript的一部分。你可以在你的类型上使用<code class="fe ly lz ma lo b">Readonly</code>，例如<code class="fe ly lz ma lo b">Readonly&lt;Coordinates&gt;</code>，而不必重新定义它。另一个常见的应用是使字段可选:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="f8d2" class="ls lt iq lo b gy lu lv l lw lx">type Partial&lt;T&gt; = {<br/>  [P in keyof T]?: T[P]<br/>};</span></pre><p id="2c1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它也是TypeScript实用工具类型。但是在TypeScript中，并不是所有的用例都被默认覆盖。例如，如果您将<code class="fe ly lz ma lo b">tsconfig</code>中的<code class="fe ly lz ma lo b">strict</code>属性设置为<code class="fe ly lz ma lo b">true</code>，则不允许您将<code class="fe ly lz ma lo b">null</code>值赋给变量，除非您将其显式键入为<code class="fe ly lz ma lo b">null</code>。如果要使现有接口的属性可为空，可能需要定义自己的映射类型:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="e086" class="ls lt iq lo b gy lu lv l lw lx">type Nullable&lt;T&gt; = {<br/>  [P in keyof T]: T[P] | null<br/>};</span></pre><p id="f1f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你有一个只读类型，你也可以创建一个映射类型，其中的字段是<strong class="kt ir">而不是</strong>只读的:使用<code class="fe ly lz ma lo b">-</code>你可以从你的属性中删除<code class="fe ly lz ma lo b">readonly</code>修饰符:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="c9c7" class="ls lt iq lo b gy lu lv l lw lx">type Mutable&lt;T&gt; = {<br/>  -readonly [P in keyof T]: T[P];<br/>};</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="60f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">映射类型是TypeScript的一项强大功能，使您能够减少复杂类型的键入工作量，同时仍然拥有强类型对象。您可以在属性类型中添加或移除修饰符，以便从原始类型创建各种版本。最常见的用例，如<code class="fe ly lz ma lo b">Readonly</code>或<code class="fe ly lz ma lo b">Partial</code>，是TypeScript语言的一部分，不需要重新定义，但是一旦你理解了语法，你就可以创建自己的映射类型来满足你的所有需求。</p><h2 id="5619" class="ls lt iq bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx my bi translated">简单英语的JavaScript</h2><p id="3e43" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ne" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kt ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>