# 停止争论代码中循环和副作用的使用

> 原文：<https://javascript.plainenglish.io/bad-loops-too-many-function-concerns-and-side-effects-just-more-obtuse-addle-minded-1acc3062c7c0?source=collection_archive---------3----------------------->

![](img/f78c2c4c1bc61dd4b679d8c240e802d6.png)

在 web 开发中——以及一般的编程中——我们有一个严重的问题，那就是回声室、盲目地模仿谎言，以及把原本很好的想法完全夸大到弊大于利的程度。

正如我以前的文章“不要把避免变成永远不要”中所说的，我们有很多好主意，但是人们都以不切实际、不合理和过分的方式去应用它们。

## 循环不是你需要对抗的恶魔

函数式程序员在这方面是最差的。编程中最有效的构造之一——简单循环——最近被许多人贴上了“不好”的标签，坦率地说，这些人正在谈论他们的缺点。

我之所以说这完全是胡说八道，是因为人们会不遗余力地编写臃肿、效率极其低下的代码，作为替代方案。递归？白白发挥作用？复试？你只是写了更多的代码，引入了更多的开销！**这些是如何让事情变得更简单的？**

这方面的一个典型例子是 JavaScript 的“`Array.forEach`”与令人痛苦的神秘的“箭头函数”垃圾相结合。使用神秘的符号来混淆代码已经够糟糕的了，我发誓 ECMA 不会高兴的，直到 JavaScript 看起来像 [brainf***](https://en.wikipedia.org/wiki/Brainfuck) …不，现在我们需要将函数作为回调来引入大量无用的内存和 CPU 浪费开销。

以火车事故为例:

```
var
  data = [2, 3, 5, 7, 11],
  sum = 0;

data.forEach((value) => { sum += value; });
```

对不起，但对我来说，这不仅仅是“哇哇，眼睛 dunz wunna tiep teh wurd funzion”方式的毫无意义的含糊不清，它的效率也非常低，因为你正在为每个该死的项目创建一个函数调用的开销。更不用说在内部它仍然在做一个循环。

在这一点上，只要做一个翻转循环。

```
var
  data = [2, 3, 5, 7, 11],
  sum = 0;

for (var value of data) sum += value;
```

在这两者中，后者的代码要干净得多。甚至老派的方法:

```
var
  data = [2, 3, 5, 7, 11],
  sum = 0;

for (var i = 0, iLen = data.length; i < iLen; i++) sum += data[i];
```

应该围绕(+n)回调运行。

*— edit —*
那些说“使用 reduce，你甚至不知道数组”的人可以马上离开，因为你已经完全、完全、完全错过了这一点，因为 Map 或任何其他数组方法都没有提供任何不同，只是隐藏了循环并引入了函数调用开销！*但是可以肯定的是，我才是那个不懂的人。
—结束编辑—*

但是一旦你陷入函数式程序员为了避免“副作用”而不得不进行递归的疯狂境地，事情就变得更糟了。以一个阶乘例程为例，人们实际上欺骗自己认为这是有效的代码:

```
function factorial(n, product = 1) {
   if (n < 2) return product;
   return factorial(n - 1, n * product);
}
```

当它所做的只是产生一个巨大的堆栈和更多的垃圾收集/内存管理工作，并且由于涉及到函数而执行较慢。但是正如我几周前在别的地方说过的，我是一个会写阶乘函数的疯子:

```
function factorial(value) {
  for (var result = 1; value > 1; value--) result *= value;
  return result;
}
```

在任何适当优化的语言中，它应该围绕前者展开，并且更容易理解。*旁注，注意这个函数是如何利用 var 的作用域的……但是请再告诉我一次，引入 let/const BS 的无用开销有多“优越”。*

虽然我怀疑我的这种想法源于我对汇编的了解，在我考虑高级对等物之前，我会先考虑用机器语言来解决这样的问题。

```
factorial:
  ; ACCEPTS
  ;   ECX - 32 bit value
  ; RETURNS
  ;   EDX : EAX - 64 bit result
  ; CORRUPTS
  ;   ECX
  mov  EAX, 1
  xor  EDX, EDX
  or   ECX, ECX
  jz   .done
.loop:
  mul  ECX
  loop .loop
.done:
  retf
```

## 拆分功能通常并不“干净”

这是人们在背后谈论的另一个亮点，他们会说“分解那个长函数”或“那个函数负责做太多的事情”…而通常情况下，替代方案要糟糕得多。

*我发誓，说这种话的小丑们可能不会高兴，除非每一行该死的代码都有一个函数围绕着它。*

当他们谈论 switch/case 之类的东西如何不“可扩展”,你如何“不得不修改代码”以及如何“很难阅读”时，你可以看出他们有多胡说八道……**与什么相对？**是的，要改变它的工作方式或添加功能，您必须修改或添加代码。除了制造更多我们根本不需要的代码之外，他们荒谬臃肿的替代方法到底改变了什么？！？

我的意思是，如果你想让它做别的事情，你就得写更多的代码。无论是查找方法的新对象方法，还是另一种情况。坦率地说，如果你这样想:

```
doWhatever[‘what’] = function(value) {
  /* do something with value here */
}
```

神奇地比以下内容更好或更容易处理:

```
case 'what':
  /* do something with value here */
  break;
```

然后你需要承认失败，放弃编程。如果你想让它做别的事情，你就得写更多的代码。将它放在代码中间的函数中，如何使它“更好”或“更容易”？更不用说给交换机添加外壳有什么“困难”了？！？**牛 b 饼干和胡言乱语！**

尤其是如果你考虑到增加所有该死的“无用功能”所带来的开销。局部变量的新“堆栈框架”,执行路径的推送/弹出，堆栈上参数的传递…

*我在想一个函数是如何用机器语言实现的。有理由相信 JS 必须以类似的方式处理函数、参数和名称空间……只是效率较低。*

更糟糕的是，人们在寻找通常是代码两倍到二十倍的替代品时，会跳过燃烧的火圈！

当人们把更多的代码分散在不同的功能甚至文件中，作为一个更干净/更清晰/更好的选择时，你的狗屁警报应该响起来了！这样做是有原因的——比如 PHP 中的分支加载——但代码清晰不是其中之一。

这实际上让我想起了我们在 90 年代对抗的东西，“黑箱综合症”。代码的某些部分——无论是由于原始编码者的意图还是由于编写它的人的损失——变得不可侵犯，因为目前没有人真正理解它。不是修复深入骨髓的根深蒂固的缺陷，而是将额外的代码包裹在它周围，试图在该部分完成其任务后修复或添加内容。我们在 OS/2 的代码库中看到了这一点，这是导致 IBM 和微软分裂的一部分，在 Gecko 的代码库中，直到大量代码被抛弃并被“Quantum”取代，问题才得到解决。*尽管 Gecko 是一个“开源”项目，但它的大部分代码仍然是可怕的“遗产”和“黑箱”状态。我不想这么说，但也许是时候让他们放弃拥有自己的引擎了。它老化得不好，尤其是现在 Mozilla 解雇了所有从事实际项目和产品的人。*

许多程序员试图实现的机制只不过是故意制造了一层层的黑盒"*我不想知道它实际上是如何工作的*"废话。试图保护、保护和过度隔离代码已经成为一种时尚，这种方式使得与代码一起工作或维护代码变得更加困难。

# 副作用——全面的营销和宣传

甚至仅仅名字就散发出被选择的特殊原因，让人感觉而不是思考。这意味着它们可能是一件坏事；被称为转移的宣传技术的典型代表。

这是一种“热点”措辞，用来推动一种完全没有事实依据的想法。类似于“工作权”听起来像是工人应该支持的东西；实际上它是反工人的。或者《爱国者法案》被选中，不是因为该法案在任何方面、形状或形式上是爱国的——*如果有什么不同的话，那就是它是你所能得到的最不美国的——*而是为了让任何反对它的人看起来不爱国。

同样，这种“副作用”的说法只是为了让人们相信，编程中正常的日常基本部分——实际上是与外界对话或让组件相互对话——在某种程度上是错误的。就像避免循环或为每一个该死的操作创建一个函数一样，不管有多小，结果都是人们扔掉了做这项工作所需的 2 到 10 倍的代码，方法和对象的迟钝链接，以及目前流行的所有其他令人费解的废话。

类似于错误地使用“结束”这个词，即“你继续使用这个词”。

说真的，伙计们，找本字典:

**副作用** *名词

1.  药物、化学药品或其它药物的任何超出其预期效果的效果，尤指有害的或令人不快的效果。
2.  任何伴随的或必然的，通常是有害的影响

程序员所说的副作用与这个术语的定义没有一点关系，因为你正在做的事情——让函数、方法或块修改值或与它们自己作用域之外的例程对话**是故意的**！毫不夸张地说，这就是做你正在做的事情的全部意义！

为什么他们会选择一个与正在发生的事情毫无关系的名字/术语？

这很简单:这个词是精心挑选的，让人感觉而不是思考。只要这样称呼，他们就能控制叙述，让你在他们解释之前就相信他们所说的。

## **一个有意的动作不是副作用！**

你可以看出——尤其是对“函数编程”着迷的人——当他们开始谈论“函数纯度”时，他们是多么的胡说八道。这个词本身应该告诉你运行。当一个典型的“职业教育家”告诉我 appendChild 或 insertBefore 是“*远程函数*中应该避免的副作用”时？好吧，那就是我知道事情不对劲的地方。

我怀疑，就像最近在块级范围内的严重错误或不必要的、令人痛苦的神秘箭头函数垃圾一样，这只是一小撮无知的人在他们了解足够的编程知识甚至有一个明智的意见之前，做出影响深远的决定并盲目地鹦鹉学舌。

我总是被教导向外阻止作用域是好的，但是向内阻止作用域是愚蠢的，因为你的代码是如何“与世界对话”的。最常见的替代方案总是将值作为参数传递，并白白浪费大量内存，这并不能激发人们对整个概念的信心，因为它实际上是以任何方式、形状或形式为基础的。

# 结论

我已经在各种规模的各种项目中编程超过四十年了。我在阿达为一家“字母汤”机构工作了十年。我在轨道上有 RCA 1802 机器语言… **所有这些东西给我的印象是欺骗、无知和操纵。有太多的建议在向有前途的程序员兜售完全的童话般的废话。**

这种沙泽雷就像热腾腾的面条上的糖浆一样四处传播，这似乎深深植根于一种观念中，即“我太笨了，无法理解它，所以其他人不应该被允许使用它”。

…这也是开发人员在这一点上表现出的白痴行为。

这和我们在编程的其他方面看到的谎言是一样的——比如框架——**谈论**这些垃圾有多“容易”或“更适合与其他程序员一起工作”或“更有效率”，因为他们写的是可以想象的最臃肿、最复杂、最费解、最痛苦的代码。他们做出毫无根据的断言，当被追问支持事实时，除了“因为他们这么说”或“事情就是这样”之外，他们很少能给出其他答案。

这就是我们在 web 开发中的结局，100k 的标记完成 16k 的工作，半打文件中的半兆 CSS 完成一个文件的 32k 工作，两兆的脚本分布在几十个文件中，这些文件通常位于甚至不保证客户端脚本存在的站点上，并且可能不应该使用超过 48k 的东西作为增强…因为它“更容易”。好吧…约瑟芬，再告诉我一个。

这一切都可以追溯到我在 80 年代学到的关于编程的课程。

> 您使用的代码越少，就越不容易被破解。

现代开发人员似乎在与这种想法作斗争，并以迂腐、无知、臃肿的做法走向完全相反的方向，这些做法破坏了几十年的进展，并使一切比需要的更复杂、更难处理。你现在可以在一篇又一篇的文章和大量的代码库中看到它；完成这项工作所需的代码使用了 2 到 10 倍，其中大部分代码分散在整个创作过程中，这使得遵循逻辑变得更加困难。然后，作为一个与蹩脚借口相匹配的营销广告词,“更容易”这个词被那些对底层语言或一般编程不够了解的人四处传播，以至于他们在这个话题上喋喋不休！

**注意**虽然我在这里特别提到了“函数式编程”,但我并不是说它不好。这只是工具箱中的另一个工具，当*在适当的地方使用*时*可以*提供一些好处。

问题是，就像这个行业中的许多其他事情一样，人们用油漆滚筒而不是滴管来涂抹它，把它硬塞进它不适合的地方，就像女人穿 5 码鞋时 18 码的牛蹄子一样。“功能纯粹或一无所有”的怪癖和“一切都应该是对象”的怪癖一样糟糕。

合适的工具适合合适的工作！不要做谚语中的拿着锤子的木匠；对他们来说一切都像钉子。当然你**可以**用锤子——或者如瑞德叔叔所说的“平头螺丝刀”——拧螺丝，但这并不意味着它在负载下会保持在一起，不管你用多少胶带。