<html>
<head>
<title>Stop using React componentDidMount/Update</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用React componentDidMount/Update</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-using-react-componentdidmount-and-componentdidupdate-1b6a2d87830c?source=collection_archive---------5-----------------------#2020-04-10">https://javascript.plainenglish.io/stop-using-react-componentdidmount-and-componentdidupdate-1b6a2d87830c?source=collection_archive---------5-----------------------#2020-04-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/08a80b1f165c8ef85cccc67e7ad5ed3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GK9vbx6L6IrrSRPSpGW_5g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Blog Rocketseat — <a class="ae jz" href="https://blog.rocketseat.com.br/" rel="noopener ugc nofollow" target="_blank">https://blog.rocketseat.com.br/</a></figcaption></figure><h1 id="35da" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">React库中有哪些钩子？</h1><blockquote class="ky kz la"><p id="ebc3" class="lb lc ld le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">钩子是一组方法，让我们从功能组件中<strong class="le io">获得</strong>进入<strong class="le io">反应</strong>状态和生命周期特性，并更容易地在其他组件中重用它们。</p></blockquote><p id="701f" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">React团队相信，随着他们的最新发布，一些老问题已经不复存在，一些痛点可能最终会被消除。组件往往聚集了很多逻辑，有时似乎很难提取它们并在其他组件中重用它们。</p><p id="f308" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">让我们通过这些问题来理解他们的动机。</p><h1 id="2f20" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">1.很难在组件之间重用有状态逻辑</h1><p id="3b87" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">在最近的版本中，功能组件似乎取代了旧的基于类的组件，钩子是主要原因。由于类组件有其适当的生命周期方法，使用功能组件给开发人员更多的灵活性来编写和重用他们的代码。因为生命周期方法由类组件拥有，所以它们不能在另一个组件中使用。</p><h1 id="d256" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.管理状态现在更简单了</h1><p id="47bd" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">让我们看一个基于类的组件的简单例子:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="37e9" class="mr kb in mn b gy ms mt l mu mv">class Clock extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { date: new Date()}; <br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Hello, world!&lt;/h1&gt;<br/>        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="cc0a" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">类组件使用构造函数方法声明初始设置，并使用超级方法声明组件的属性。现在，让我们来看看使用<strong class="le io">使用状态</strong>钩子的功能组件:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4a73" class="mr kb in mn b gy ms mt l mu mv">const Clock = (props) =&gt; {<br/>    const [date, setDate] = useState({ date: new Date() });</span><span id="0dfe" class="mr kb in mn b gy mw mt l mu mv">    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;Hello, world!&lt;/h1&gt;<br/>            &lt;h2&gt;It is {date.toLocaleTimeString()}.&lt;/h2&gt;<br/>        &lt;/div&gt;<br/>    );<br/>};</span></pre><p id="b274" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">有了<strong class="le io"> useState </strong> hook就更容易声明你需要什么，也更容易返回。</p><h1 id="69ca" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">3.大型组件可能很难理解它们的逻辑</h1><p id="91c7" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">在我们的生活中，我们都有一个非常复杂的项目，它让我们的组件像杂草一样生长。问题是每个生命周期方法都有一部分所有的组件逻辑，例如，<strong class="le io">componentdimount</strong>有一些逻辑，而<strong class="le io"> componentDidUpdate </strong>有另一部分逻辑，而<strong class="le io">componentdimunmount</strong>有其他部分的逻辑，但最终，它可能与某种UI动作中的同一部分逻辑相关。有了钩子，我们可以将那部分逻辑分解成函数，并根据需要多次重用。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="e412" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">现在我们确信Hooks是我们项目的更好的方法，让我们看看<strong class="le io"> useEffect </strong> hook并理解为什么它可以帮助我们降低组件的复杂性。</p><p id="6b0e" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">我在前面的第三点中说过，在一个基于类的组件中，每一块逻辑都分布在每个生命周期方法之间。想象一下，我们正试图展示我们所宣称的状态。没有<strong class="le io"> useEffect </strong>我们需要在同一段代码中使用<strong class="le io">componentid mount</strong>和<strong class="le io">componentid update</strong>。通过<strong class="le io">使用效果</strong>，我们可以避免:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7d8f" class="mr kb in mn b gy ms mt l mu mv">function Toggle() {<br/>    const [toggle, setToggle] = useState(false);</span><span id="861d" class="mr kb in mn b gy mw mt l mu mv">    useEffect(() =&gt; {<br/>        console.log(`Toggle is ${toggle}`);<br/>    }, []);</span><span id="2a60" class="mr kb in mn b gy mw mt l mu mv">    return (<br/>        &lt;div onClick={() =&gt; setToggle(!toggle)}&gt;<br/>            {toggle &amp;&amp;<br/>                &lt;div&gt;Show me or not!&lt;/div&gt;<br/>            }<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="3e03" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">这是使用<strong class="le io"> componentDidUpdate </strong>的克隆，如果我们需要为UI提供一些更新，我们需要将那个console.log添加到那个生命周期方法中，这样我们就复制了代码。有了钩子，更新UI更加简单。通常情况下，<strong class="le io"> ComponentDidUpdate </strong>使用两个参数来检测是否发生了变化(例如:prevProps，prevState)，而不是使用一个参数的<strong class="le io"> useEffect </strong>。在前面的例子中，您可以在<strong class="le io"> useEffect </strong>中使用空方括号。如果您不需要更新UI，您可以简单地删除它，但是如果您想要更新，只需将状态作为参数传递，React将检测状态是否已更改并更新UI。</p><h1 id="5644" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="aeee" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">钩子的存在是为了简化我们的工作，我认为我们需要用这种新特性逐步更新我们的项目，不仅是为了维护或使用最新版本，也是为了简化我们的代码片段，减少产生bug的可能性。生命周期方法很快就会被否决，所以只要我们更新代码，我们的项目就会变得更好，但是当然需要先看看利弊，就像我们以前做的那样。</p><h2 id="4ad7" class="mr kb in bd kc ne nf dn kg ng nh dp kk ma ni nj ko mb nk nl ks mc nm nn kw no bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="c18b" class="pw-post-body-paragraph lb lc in le b lf md lh li lj me ll lm ma mf lp lq mb mg lt lu mc mh lx ly lz ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:<a class="ae jz" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="le io"/></a><a class="ae jz" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="le io">UX</strong></a><a class="ae jz" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="le io">Python</strong></a><strong class="le io"/>——谢谢，继续学习！</p><p id="d789" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm ma lo lp lq mb ls lt lu mc lw lx ly lz ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jz" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="le io">submissions @ plain English . io</strong></a>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>