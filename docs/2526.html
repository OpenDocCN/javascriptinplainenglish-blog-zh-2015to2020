<html>
<head>
<title>Common JavaScript Debugging Problems and How to Solve Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的JavaScript调试问题及其解决方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/common-javascript-debugging-problems-and-how-to-solve-them-300316d949d5?source=collection_archive---------7-----------------------#2020-07-02">https://javascript.plainenglish.io/common-javascript-debugging-problems-and-how-to-solve-them-300316d949d5?source=collection_archive---------7-----------------------#2020-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ca003653b03584794f6d7a25d703ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*biLs0r8qLhaaorteiG6Dxg.jpeg"/></div></div></figure><p id="09a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用任何编程语言时，都会有一个阶段你必须处理恼人的bug和错误。JavaScript尤其有很多隐藏的bug和错误，等待最佳时机在生产中爆发。无论你是在做本地调试还是远程调试，知道如何修复这些常见的JavaScript错误会让你的生活更轻松。</p><p id="d3df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将探讨各种常见的JavaScript问题以及如何解决它们。</p><h1 id="3a4d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">未捕获的引用错误:“x”未定义</h1><p id="066c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是最常见的JavaScript错误之一，通常发生在代码中引用了一个不存在的变量时。</p><p id="8159" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变量要么没有声明好，要么在错误的范围内声明。</p><p id="f447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看下面的代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="817a" class="mj ky iq mf b gy mk ml l mm mn">console.log(foo) // Uncaught ReferenceError: 'foo' is not defined</span></pre><p id="e36d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会抛出未定义的<code class="fe mo mp mq mf b">Uncaught ReferenceError: ‘foo’</code>,因为我们没有声明<code class="fe mo mp mq mf b">foo</code>。这可以通过声明变量<code class="fe mo mp mq mf b">foo</code>来解决:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6a41" class="mj ky iq mf b gy mk ml l mm mn">var foo = "foobar";</span><span id="4ad9" class="mj ky iq mf b gy mr ml l mm mn">console.log(foo) // foobar</span></pre><p id="5640" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子是下面的代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8a97" class="mj ky iq mf b gy mk ml l mm mn">function add() {<br/>  var x = 5, y = 1;<br/>  return x + y;<br/>}</span><span id="c91a" class="mj ky iq mf b gy mr ml l mm mn">console.log(x); // Uncaught ReferenceError: x is not defined</span></pre><p id="eb45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的问题是<code class="fe mo mp mq mf b">x</code>只在<code class="fe mo mp mq mf b">add</code>函数的范围内可用，不能在该函数之外使用。然而，<code class="fe mo mp mq mf b">add</code>函数可以访问任何全局变量及其局部变量。</p><p id="95c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要修复它，您需要将变量<code class="fe mo mp mq mf b">x</code>声明为全局变量。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c695" class="mj ky iq mf b gy mk ml l mm mn">var x = 5, y = 1</span><span id="66bb" class="mj ky iq mf b gy mr ml l mm mn">function add() {<br/>  return x + y;<br/>}</span><span id="7b84" class="mj ky iq mf b gy mr ml l mm mn">console.log(x); // 5</span></pre><p id="1a66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就对了。已经修好了。</p><h1 id="e2c0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">未捕获的类型错误:无法读取未定义的属性“x”</h1><p id="304e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是另一个困扰JavaScript开发人员的常见恼人的JavaScript错误，通常发生在您试图访问一个<a class="ae kw" href="https://en.wikipedia.org/wiki/Undefined_variable" rel="noopener ugc nofollow" target="_blank">未定义值或变量</a>的属性时。</p><p id="0b15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发生这种情况有很多原因。让我们看看下面的代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1e8d" class="mj ky iq mf b gy mk ml l mm mn">var x = "foobar";</span><span id="128e" class="mj ky iq mf b gy mr ml l mm mn">console.log(x.substring(1)) // oobar</span><span id="d9a6" class="mj ky iq mf b gy mr ml l mm mn">console.log(x.foobar) // undefined</span><span id="e2fe" class="mj ky iq mf b gy mr ml l mm mn">console.log(x.foobar.substring(1))  // Uncaught TypeError: Cannot read property 'substring' of undefined</span></pre><p id="d73e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，在第3行和第4行，我们试图访问x的一个未定义的值。第3行的<code class="fe mo mp mq mf b">x.foobar </code>将给出<code class="fe mo mp mq mf b">undefined</code>，因为<code class="fe mo mp mq mf b">x</code>没有属性<code class="fe mo mp mq mf b">foobar</code>，并且试图访问值<code class="fe mo mp mq mf b">undefined</code>的<code class="fe mo mp mq mf b">substring</code>将导致一个错误。</p><p id="d379" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时，在处理JavaScript对象时会出现这种错误，例如:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6f7d" class="mj ky iq mf b gy mk ml l mm mn">const state = {<br/>  common: {<br/>    auth: {<br/>      user: {<br/>        name: "John Smith",<br/>      },<br/>      token: {<br/>        jwt: "eyJAD.LAKDIDCWECUWJKDSnlwpihfwpfo",<br/>        bearer: "LAKDIDCWECUWJKDSnlwpihfwpfo",<br/>      }<br/>    }<br/>  }<br/>}</span><span id="46bf" class="mj ky iq mf b gy mr ml l mm mn">console.log(state.common.auth.user.name) // John Smith</span><span id="f9f9" class="mj ky iq mf b gy mr ml l mm mn">console.log(state.common.auth.tokne.jwt) // Uncaught TypeError: Cannot read property 'jwt' of undefined</span></pre><p id="248d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第15行，我们把属性名<code class="fe mo mp mq mf b">token</code>打成了<code class="fe mo mp mq mf b">tokne</code>，这将导致<code class="fe mo mp mq mf b">undefined</code>，而访问属性<code class="fe mo mp mq mf b">jwt</code>将导致<code class="fe mo mp mq mf b">uncaught typeerror</code>。这可以通过修复错别字名称来解决。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2db5" class="mj ky iq mf b gy mk ml l mm mn">console.log(state.common.auth.tokne.jwt)</span></pre><h1 id="ca63" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">未捕获的类型错误:无法读取null的属性“x”</h1><p id="878a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这与前面的错误类似，但是当您试图访问空值或空变量的属性时，会出现这种情况。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1536" class="mj ky iq mf b gy mk ml l mm mn">var x = null;</span><span id="e37f" class="mj ky iq mf b gy mr ml l mm mn">console.log(x.substring()) // Uncaught TypeError: Cannot read property 'substring' of null</span></pre><p id="2355" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一件事是，例如，当从ajax或api加载数据时，如果一个变量、一个对象在初始时被设置为<code class="fe mo mp mq mf b">null</code>，并且你试图在数据被加载之前访问它。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b5a2" class="mj ky iq mf b gy mk ml l mm mn">const data = {<br/>  messages: null<br/>};</span><span id="f749" class="mj ky iq mf b gy mr ml l mm mn">fetch("https://medrum.herokuapp.com/messages/birthday_message/")<br/>.then((r) =&gt; r.json())<br/>.then((d) =&gt; {<br/>  data.messages = d<br/>})</span><span id="2154" class="mj ky iq mf b gy mr ml l mm mn">setTimeout(() =&gt; {<br/>  console.log(data.messages.messages)<br/>}, 1500)</span><span id="83f1" class="mj ky iq mf b gy mr ml l mm mn">console.log(data.messages.messages) // Uncaught TypeError: Cannot read property 'messages' of null</span></pre><p id="04aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，我们希望从端点获取数据到<code class="fe mo mp mq mf b">data</code>对象的<code class="fe mo mp mq mf b">messages</code>属性中。由于还没有数据，<code class="fe mo mp mq mf b">messages</code>首先被设置为<code class="fe mo mp mq mf b">null</code>。</p><p id="da5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您试图在数据未准备好时访问它，您将得到错误<code class="fe mo mp mq mf b">Uncaught TypeError: Cannot read property ‘messages’ of null</code>。要解决这个问题，您可以检查一下<code class="fe mo mp mq mf b">messages</code>是否不为空，然后访问它。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="997b" class="mj ky iq mf b gy mk ml l mm mn">if(data.messages){<br/>  console.log(data.messages.messages)<br/>}</span></pre><h1 id="dedb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">未捕获的类型错误:x不是函数</h1><p id="c29a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这也是当你试图调用一个非函数/方法变量时经常发生的另一个错误。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="aa8a" class="mj ky iq mf b gy mk ml l mm mn">const add = 1 + 2;</span><span id="78da" class="mj ky iq mf b gy mr ml l mm mn">console.log(add); // 3</span><span id="34bb" class="mj ky iq mf b gy mr ml l mm mn">console.log(add()) // Uncaught TypeError: add is not a function</span></pre><p id="ccdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您试图将<code class="fe mo mp mq mf b">add</code>作为<code class="fe mo mp mq mf b">add()</code>函数或方法调用，第3行肯定会抛出一个错误。</p><h1 id="8c09" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">对此的错误引用</h1><p id="6fec" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这不是一个错误，但更像是一个可能导致各种错误的bug。大多数JavaScript代码在<code class="fe mo mp mq mf b">top-level</code>方法(不同于顶级函数)中引用<code class="fe mo mp mq mf b">this</code>时通常会出现这种错误。JavaScript中的顶级方法可以是函数、对象、类等等中的嵌套函数。</p><p id="b294" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mf b">this</code>是一种很好的自引用对象的方式，每次调用函数时，它的作用域可能不同，在回调和闭包中调用的方式也可能不同。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="49ce" class="mj ky iq mf b gy mk ml l mm mn">function mainFunction() {<br/>  this.someMethod1 = function() {<br/>    var elementBtn = document.getElementById('myBtn');<br/>    elementBtn.onclick = function() {<br/>      this.someMethod2(); <br/>      //Uncaught TypeError: undefined is not a function<br/>    };<br/>  };<br/>  this.someMethod2 = function() {<br/>    alert('OK');<br/>  };<br/>}</span></pre><p id="5062" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当<code class="fe mo mp mq mf b">myBtn</code>被点击时，它会尝试调用<code class="fe mo mp mq mf b">this.someMethod2()</code>，它当前引用的是<code class="fe mo mp mq mf b">elementBtn</code>对象，而不是<code class="fe mo mp mq mf b">mainFunction</code>。<code class="fe mo mp mq mf b">this</code>的范围在<code class="fe mo mp mq mf b">onclick</code>方法中已经改变为当前元素对象。</p><p id="a52d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要解决这个问题，您需要保存一个对<code class="fe mo mp mq mf b">mainFunction</code>的引用，并用它来调用<code class="fe mo mp mq mf b">someMethod2()</code>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f421" class="mj ky iq mf b gy mk ml l mm mn">function mainFunction() {<br/>  const _this = this;<br/>  this.someMethod1 = function() {<br/>    var elementBtn = document.getElementById('myBtn');<br/>    elementBtn.onclick = function() {<br/>      _this.someMethod2();<br/>    };<br/>  };<br/>  this.someMethod2 = function() {<br/>    alert('OK');<br/>  };<br/>}</span></pre><p id="5733" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个例子是:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2f92" class="mj ky iq mf b gy mk ml l mm mn">function App() {<br/>  this.data = null<br/>}</span><span id="b232" class="mj ky iq mf b gy mr ml l mm mn">App.prototype.getLocalData = function () {<br/>  const data = {<br/>    user: {<br/>      name: "Smith"<br/>    }<br/>  }<br/>  return data<br/>}</span><span id="088b" class="mj ky iq mf b gy mr ml l mm mn">App.prototype.setData = function (data) {<br/>  this.data = data<br/>}</span><span id="40a3" class="mj ky iq mf b gy mr ml l mm mn">App.prototype.loadApp = function () {<br/>  const data = this.getLocalData();<br/>  this.load = setTimeout(function() {<br/>    this.setData(data);<br/>  }, 0);<br/>}</span><span id="6dbe" class="mj ky iq mf b gy mr ml l mm mn">App.prototype.loadApp()</span></pre><p id="9bde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，您得到了错误，因为您正在调用<code class="fe mo mp mq mf b">setTimeout</code>中的<code class="fe mo mp mq mf b">this.setData</code>，它与<code class="fe mo mp mq mf b">window.setTimeou</code> t是一回事，并且有它自己的<code class="fe mo mp mq mf b">this</code>引用。</p><p id="b824" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你所说的<code class="fe mo mp mq mf b">this</code>的语境已经不在<code class="fe mo mp mq mf b">loadApp</code>中，而是在<code class="fe mo mp mq mf b">window</code>的语境中。</p><p id="7484" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要解决这个问题，您需要像我们之前做的那样保存一个<code class="fe mo mp mq mf b">this</code>的引用:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="43ed" class="mj ky iq mf b gy mk ml l mm mn">App.prototype.loadApp = function () {</span><span id="cbcc" class="mj ky iq mf b gy mr ml l mm mn">const _this = this</span><span id="161f" class="mj ky iq mf b gy mr ml l mm mn">const data = this.getLocalData()</span><span id="7bd9" class="mj ky iq mf b gy mr ml l mm mn">this.load = setTimeout(function() {</span><span id="f5e0" class="mj ky iq mf b gy mr ml l mm mn">_this.setData(data);</span><span id="002f" class="mj ky iq mf b gy mr ml l mm mn">}, 0);</span><span id="d016" class="mj ky iq mf b gy mr ml l mm mn">}</span></pre><p id="2b00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，您可以调用<code class="fe mo mp mq mf b">bind()</code>方法在现代浏览器中传递正确的<code class="fe mo mp mq mf b">this</code>引用:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6cd9" class="mj ky iq mf b gy mk ml l mm mn">App.prototype.loadApp = function () {</span><span id="1d03" class="mj ky iq mf b gy mr ml l mm mn">const data = this.getLocalData()</span><span id="d643" class="mj ky iq mf b gy mr ml l mm mn">this.load = setTimeout(this.reset.bind(this, data), 0);</span><span id="2918" class="mj ky iq mf b gy mr ml l mm mn">}</span><span id="d084" class="mj ky iq mf b gy mr ml l mm mn">App.prototype.reset = function(data){</span><span id="8bd0" class="mj ky iq mf b gy mr ml l mm mn">this.setData(data)</span><span id="e405" class="mj ky iq mf b gy mr ml l mm mn">}</span></pre><h1 id="2be3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">未捕获的范围错误:超出了最大调用堆栈大小</h1><p id="3279" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是最不希望出现的错误之一，通常是由于处理递归或超范围操作时出现的错误。根据您执行的操作，会出现各种类型的未捕获的RangeError错误。</p><p id="b9ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最常见的是<code class="fe mo mp mq mf b">Maximum call stack size exceeded</code>，它通常出现在非终止递归函数中。参见下面的代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5c28" class="mj ky iq mf b gy mk ml l mm mn">function iRecurse(){</span><span id="918e" class="mj ky iq mf b gy mr ml l mm mn">iRecurse();</span><span id="d6ab" class="mj ky iq mf b gy mr ml l mm mn">}</span><span id="6a47" class="mj ky iq mf b gy mr ml l mm mn">iRecurse(); // Uncaught RangeError: Maximum call stack size exceeded</span></pre><p id="ace0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子是一个非终止的<a class="ae kw" href="https://javascript.info/recursion" rel="noopener ugc nofollow" target="_blank">递归</a>，并在一个无限循环中不断调用自己，直到达到最大调用堆栈。</p><p id="f281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使我们添加了终止递归的条件，也有很多方法可以引入错误:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a5e3" class="mj ky iq mf b gy mk ml l mm mn">x = 1</span><span id="4e0f" class="mj ky iq mf b gy mr ml l mm mn">function iRecurse(){</span><span id="b943" class="mj ky iq mf b gy mr ml l mm mn">x+=2;</span><span id="14ab" class="mj ky iq mf b gy mr ml l mm mn">if(x%2==0) return;</span><span id="28f8" class="mj ky iq mf b gy mr ml l mm mn">iRecurse();</span><span id="b5b4" class="mj ky iq mf b gy mr ml l mm mn">}</span><span id="4628" class="mj ky iq mf b gy mr ml l mm mn">iRecurse(); // Uncaught RangeError: Maximum call stack size exceeded</span></pre><p id="9587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子不会终止，因为<code class="fe mo mp mq mf b">x</code>模数<code class="fe mo mp mq mf b">2</code>的每一个增量都不会导致<code class="fe mo mp mq mf b">0</code>，因为<code class="fe mo mp mq mf b">x</code>最初是<code class="fe mo mp mq mf b">1</code>并且每一个增量都将是<code class="fe mo mp mq mf b">odd</code>个数字。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="322e" class="mj ky iq mf b gy mk ml l mm mn">x = 0</span><span id="2beb" class="mj ky iq mf b gy mr ml l mm mn">function iRecurse(){</span><span id="dce8" class="mj ky iq mf b gy mr ml l mm mn">x+=2;</span><span id="3ee6" class="mj ky iq mf b gy mr ml l mm mn">if(x%2==0) return;</span><span id="8fee" class="mj ky iq mf b gy mr ml l mm mn">iRecurse();</span><span id="d51c" class="mj ky iq mf b gy mr ml l mm mn">}</span><span id="b223" class="mj ky iq mf b gy mr ml l mm mn">iRecurse();</span></pre><p id="6eaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将<code class="fe mo mp mq mf b">x</code>设置为<code class="fe mo mp mq mf b">0</code>，我们能够修复这个bug。</p><p id="2e07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他范围误差包括:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="90ed" class="mj ky iq mf b gy mk ml l mm mn">// Array</span><span id="8b04" class="mj ky iq mf b gy mr ml l mm mn">var arrEx = new Array(2) // ok</span><span id="9ddc" class="mj ky iq mf b gy mr ml l mm mn">var arrExErr = new Array(-2) // Uncaught RangeError: Invalid array length</span><span id="4028" class="mj ky iq mf b gy mr ml l mm mn">// Number</span><span id="fd79" class="mj ky iq mf b gy mr ml l mm mn">var num = Number(5.45);</span><span id="7435" class="mj ky iq mf b gy mr ml l mm mn">console.log(num.toFixed(20)) // 5.45000000000000017764</span><span id="8bbe" class="mj ky iq mf b gy mr ml l mm mn">console.log(num.toFixed(120)) // Uncaught RangeError: toFixed() digits argument must be between 0 and 100</span><span id="842c" class="mj ky iq mf b gy mr ml l mm mn">console.log(num.isPrecision(20)) // "5.4500000000000001776"</span><span id="1b85" class="mj ky iq mf b gy mr ml l mm mn">console.log(num.isPrecision(120)) // Uncaught RangeError: isPrecision() digits argument must be between 1 and 100</span><span id="e19d" class="mj ky iq mf b gy mr ml l mm mn">console.log(num.toExponential(20)) // "5.45000000000000017764e+0"</span><span id="1428" class="mj ky iq mf b gy mr ml l mm mn">console.log(num.toExponential(120)) // Uncaught RangeError: toExponential() argument must be between 0 and 100</span></pre><h1 id="9105" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">未捕获的类型错误:将循环结构转换为JSON</h1><p id="9e4e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这也是处理JSON数据时另一个常见的JavaScript错误和bug。如果您正在处理JSON数据，就有可能遇到这种类型的错误。</p><p id="5d86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这通常发生在你试图<code class="fe mo mp mq mf b">JSON.stringify</code>相互循环引用的对象时。</p><p id="64fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f9a9" class="mj ky iq mf b gy mk ml l mm mn">var a = {}</span><span id="9f77" class="mj ky iq mf b gy mr ml l mm mn">var b = {a:b}</span><span id="3316" class="mj ky iq mf b gy mr ml l mm mn">a.b = b</span><span id="4deb" class="mj ky iq mf b gy mr ml l mm mn">b.a = a</span></pre><p id="04dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你尝试这样做:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a276" class="mj ky iq mf b gy mk ml l mm mn">JSON.stringify(b) // Uncaught TypeError: Converting circular structure to JSON</span></pre><p id="ebe0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将得到错误:<code class="fe mo mp mq mf b">Uncaught TypeError: Converting circular structure to JSON</code>。由于<code class="fe mo mp mq mf b">a</code>和<code class="fe mo mp mq mf b">b</code>都有相互引用，b或a都不能转换成JSON。</p><p id="334c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题最简单的方法是在<code class="fe mo mp mq mf b">JSON.stringifying</code>你的对象之前检查并防止对象的循环引用。您还可以指定一个自定义序列化程序函数来检测和清理循环引用。</p><p id="a0b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你真的不需要自己写，在<a class="ae kw" href="https://github.com/isaacs/json-stringify-safe" rel="noopener ugc nofollow" target="_blank"> Github </a>或<a class="ae kw" href="https://www.rookout.com/" rel="noopener ugc nofollow" target="_blank"> Rookout </a>上有这样的解决方案，可以帮助识别循环引用。</p><h1 id="55f0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="cab2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果您不知道错误来自哪里以及如何解决它，JavaScript错误/bug可能会令人讨厌、困惑和耗时。我们已经能够探索一些基本的JavaScript错误以及如何修复它们。</p><p id="44d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当调试JavaScript错误时，我建议你打开<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener ugc nofollow" target="_blank">严格模式</a>，因为它有助于更快地处理错误，并使用<a class="ae kw" href="https://developers.google.com/web/tools/chrome-devtools" rel="noopener ugc nofollow" target="_blank"> Chrome DevTools </a>。</p></div></div>    
</body>
</html>