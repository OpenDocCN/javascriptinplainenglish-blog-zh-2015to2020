<html>
<head>
<title>Why React and Redux need immutable data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么React和Redux需要不可变的数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-react-and-redux-need-immutable-data-dae3ab3611a0?source=collection_archive---------3-----------------------#2019-09-30">https://javascript.plainenglish.io/why-react-and-redux-need-immutable-data-dae3ab3611a0?source=collection_archive---------3-----------------------#2019-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3f8a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用图画和例子来解释，这样我们才能最终理解它。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d037eccbb484d514682b9218f4e3d7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVi6CrO_iNAm-Mn9yzkJqQ.png"/></div></div></figure><h2 id="77fc" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">简短回答:</h2><p id="8a3d" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">React在决定是否应该重新渲染组件时使用<em class="md"> shallowCompare </em>。</p><h2 id="f3df" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><em class="me">参考文献</em></h2><p id="8e15" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">为了理解<em class="md"> shallowCompare </em>，我们首先需要知道JavaScript如何处理对象引用。让我们看一个例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="033c" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls kx mj lu lv lb mk lx ly lf ml ma mb mc ig bi translated"><code class="fe mm mn mo mp b">johnClone</code>和<code class="fe mm mn mo mp b">john</code>同名同岁，但他们不是同一个人。<br/>我们在申报<code class="fe mm mn mo mp b">john = people[1]</code>的时候，并没有把<code class="fe mm mn mo mp b">people[1]</code>的名字和年龄复制到<code class="fe mm mn mo mp b">john</code>。两个变量都指向同一个对象作为引用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/93f5f8b65c15ad89708689124455eb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYah87gmVzagrPhQVH7VqA.png"/></div></div></figure><h2 id="537e" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">浅层比较</h2><p id="fff6" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">现在，让我们来看一个<em class="md">浅层比较</em>的例子:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0065" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls kx mj lu lv lb mk lx ly lf ml ma mb mc ig bi translated">如果我们想安慰约翰的更新，我们需要克隆它。这样，<em class="md"> shallowCompare </em>就知道道具变了。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h2 id="0171" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">反应示例</h2><p id="725e" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls kx lt lu lv lb lw lx ly lf lz ma mb mc ig bi translated">React使用相同的原理来避免不必要的组件重新渲染。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/80d41b63bf23cb792a1bca3b872a07d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*9akb-ISq_hnfo6vzJOYOuQ.png"/></div></figure><p id="1ac0" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls kx mj lu lv lb mk lx ly lf ml ma mb mc ig bi translated">如果我们单击按钮，组件将不会呈现john的更新，因为<code class="fe mm mn mo mp b">people[1]</code>是上次的相同引用。出于这个原因，我们不能变异<code class="fe mm mn mo mp b">john</code>。我们需要先克隆<code class="fe mm mn mo mp b">john</code>，然后更新数组。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/dc7d8ce760e5457a5932062ae9967f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*Lv6NWqgOcys0UDTvH22iHg.png"/></div></figure><p id="c47a" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls kx mj lu lv lb mk lx ly lf ml ma mb mc ig bi translated">意识到我们没有克隆<code class="fe mm mn mo mp b">people[0]</code>(玛丽)。不可变数据并不意味着我们必须详尽地克隆所有对象的分支。这不是很有效率。我们只需要通过我们更改的路径创建新的引用。</p></div></div>    
</body>
</html>