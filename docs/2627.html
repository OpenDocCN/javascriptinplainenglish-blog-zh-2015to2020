<html>
<head>
<title>Understanding JavaScript Call Stack, Task Queue and Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript调用堆栈、任务队列和事件循环</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-javascript-call-stack-task-queue-and-event-loop-2d586d5ad4db?source=collection_archive---------6-----------------------#2020-07-10">https://javascript.plainenglish.io/understanding-javascript-call-stack-task-queue-and-event-loop-2d586d5ad4db?source=collection_archive---------6-----------------------#2020-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fde3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果JavaScript是单线程的，异步函数是如何工作的？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d1a455b1ed7514e164b83cbbca766ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YvH1xdhQnhlKRj8g.jpg"/></div></div></figure><blockquote class="ko kp kq"><p id="3589" class="kr ks kt ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">声明:这篇文章很大程度上受到了Phillip Roberts在2014年EUConf上的一次会议<a class="ae lo" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=635s" rel="noopener ugc nofollow" target="_blank">演讲</a>的启发。</p></blockquote><p id="8549" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">JS的批评者喜欢指出的一点是，它是单线程的。当我开始用JS编码时，这让我很困惑。那JS是怎么处理异步函数的呢？我们怎样才能让像<code class="fe ls lt lu lv b">setTimeout()</code>这样的东西独立于主线程工作呢？希望在这篇文章结束时，你能找到所有这些问题的答案。本文的另一个目标是解释JS的一些核心高级概念:调用栈、任务队列和事件循环，它们是理解JS如何在浏览器中工作的基础。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><p id="18a9" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">假设您为一个web应用程序编写了一些JS代码，并发布了这些代码。JS代码在浏览器上运行。浏览器怎么知道该怎么处理？浏览器能够运行JS代码，因为它有一个JS引擎，对于Chrome来说就是<a class="ae lo" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"> V8 </a> JavaScript引擎。简单来说，V8知道如何把JS代码转换成机器码。</p><p id="ad42" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">浏览器不仅仅是JavaScript引擎。它有自己的一套API，称为Web APIs。<code class="fe ls lt lu lv b">setTimeout()</code>是这套API的一部分。当你调用像<code class="fe ls lt lu lv b">setTimeout()</code>这样的函数时，你使用的是浏览器向你展示的API函数。</p><p id="5fc4" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated"><em class="kt">浏览器能够运行JS代码，因为它有一个JS引擎，对于Chrome来说就是</em><a class="ae lo" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"><em class="kt">V8</em></a><em class="kt">JavaScript引擎。</em></p><p id="9c94" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">我们已经讨论了浏览器的两个关键部分:JS引擎和Web APIs。现在让我们继续讨论JS的单线程特性。当我们说JS是单线程的时候，我们的意思是JS有<strong class="ku io">一个调用栈</strong>。调用栈是一个简单的数据结构，它有两个功能:它只能从顶部添加(推入)或移除(弹出)项目。想象一下你洗完碗碟后放在一个桶里。您只能从顶部添加或移除一道菜。当一个函数被调用时，它被添加到调用栈中，当它返回时，它被弹出。这就是JS跟踪何时运行哪些函数的方式。一个直观的例子:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi md"><img src="../Images/796b91cbb387e232d02807acd2e0fdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9TLZWd539YCKKtgVMF5fw.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Screenshot taken from <a class="ae lo" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=635s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=635s</a> .</figcaption></figure><p id="2884" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">当我们说JS是单线程的时候，我们的意思是JS有<strong class="ku io">一个调用栈</strong>。调用堆栈是一个简单的数据结构，它有两个功能:它只能从顶部添加(推入)或移除(弹出)一个项目。</p><p id="2ed6" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">假设JS只有一个调用栈，栈底的函数依赖于它们上面的函数:在它们上面的所有函数执行完之前，它们不会运行。如果我们在堆栈上放置一个进行网络调用的异步函数，它将冻结浏览器直到完成，因为网络调用可能相对较慢。这样会让用户体验苦不堪言。那么，我们如何解决这个问题呢？输入任务队列。</p><p id="bcb4" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">一张图胜过千言万语:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mi"><img src="../Images/d9d628101b036e37879bff9537ac036d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TyAP9cdgdfoWCC4-szhpew.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk">Screenshot taken from <a class="ae lo" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=635s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;t=635s</a> .</figcaption></figure><p id="6a92" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">因为<code class="fe ls lt lu lv b">setTimeout()</code>是一个异步调用，在我们的例子中，它将在5秒钟后完成。当<code class="fe ls lt lu lv b">setTimeout()</code>被点击时，它被推到堆栈上，并触发web apis的<code class="fe ls lt lu lv b">timer() </code>功能。当<code class="fe ls lt lu lv b">timer()</code>完成时，它将回调函数推送到<strong class="ku io">任务队列</strong>，这是一个基于队列的数据结构，保存回调函数。</p><p id="a274" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated">然后是<strong class="ku io">事件循环</strong>，它的任务是查看任务队列中是否有项目，如果有，它等待调用堆栈清空，然后将项目从任务队列推到调用堆栈。这就完成了一个异步函数的完整周期。</p><p id="13bb" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated"><strong class="ku io">有趣的花絮:</strong>如果你想让一段代码在调用栈为空时运行，把它包装在一个setTimeout()中，延迟0秒。即使它是0，它也将被事件循环从任务队列中取出，并在堆栈为空时被推送到调用堆栈。</p><p id="dba7" class="pw-post-body-paragraph kr ks in ku b kv kw jo kx ky kz jr la lp lc ld le lq lg lh li lr lk ll lm ln ig bi translated"><strong class="ku io">有趣花絮2: </strong> <a class="ae lo" href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" rel="noopener ugc nofollow" target="_blank">工作队列</a>是留给承诺的。<em class="kt"/>【then-able】承诺代码存储在作业队列中。</p><h2 id="001a" class="mj mk in bd ml mm mn dn mo mp mq dp mr lp ms mt mu lq mv mw mx lr my mz na nb bi translated">让我们回顾一下:</h2><ul class=""><li id="5c44" class="nc nd in ku b kv ne ky nf lp ng lq nh lr ni ln nj nk nl nm bi translated">JS是单线程的，这意味着它只有一个调用栈。</li><li id="d6ea" class="nc nd in ku b kv nn ky no lp np lq nq lr nr ln nj nk nl nm bi translated">当调用函数时，它们被推到调用堆栈上。当它们返回/完成时，它们被弹出。</li><li id="14b2" class="nc nd in ku b kv nn ky no lp np lq nq lr nr ln nj nk nl nm bi translated">异步函数不是JS引擎的一部分。它们由Web APIs公开。当您使用setTimer(callback，timeInMs)时，它被推送到调用堆栈上，触发Web API中的一个方法，即Timer(callback，timeInMs ),并从调用堆栈中弹出，释放调用堆栈。</li><li id="163d" class="nc nd in ku b kv nn ky no lp np lq nq lr nr ln nj nk nl nm bi translated">当Web API栈中异步调用触发的函数完成时，即timer(callback，timeInMs)，异步方法的回调函数被推送到回调队列。</li><li id="3479" class="nc nd in ku b kv nn ky no lp np lq nq lr nr ln nj nk nl nm bi translated">事件循环的工作是将东西从回调队列中移出，并放回调用堆栈。只有当调用堆栈为空时，它们才会这样做。</li></ul></div></div>    
</body>
</html>