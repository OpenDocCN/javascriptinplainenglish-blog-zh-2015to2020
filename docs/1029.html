<html>
<head>
<title>NodeJS — Nuance of Requiring a File VS Reading a File</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS —需要文件与读取文件的细微差别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nodejs-nuance-of-requiring-a-file-vs-reading-a-file-d1d1306d214d?source=collection_archive---------2-----------------------#2020-01-17">https://javascript.plainenglish.io/nodejs-nuance-of-requiring-a-file-vs-reading-a-file-d1d1306d214d?source=collection_archive---------2-----------------------#2020-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca6b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们将通过一个<strong class="ak">运行NodeJS进程</strong>期间<strong class="ak">要求</strong>与<strong class="ak">直接读取</strong>文件的<strong class="ak">小细节</strong>之一。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/04ed46564780e07e1b74a48d8295970e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3HSKaQ6l_LftoqjTUYscQ.jpeg"/></div></div></figure><p id="49db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="ln">注意:这不是对require和fs.readFile </em> </strong>的深入比较</p><h2 id="b653" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">TLDR</h2><p id="8437" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">如果想在运行NodeJS的整个过程中引用文件的最新版本<strong class="kt ir">请使用<strong class="kt ir"> fs </strong>包，否则如果想让数据<strong class="kt ir">保持不变</strong>或者不希望文件改变，请使用<strong class="kt ir"> require </strong>。</strong></p><h1 id="8174" class="mm lp iq bd lq mn mo mp lt mq mr ms lw jw mt jx lz jz mu ka mc kc mv kd mf mw bi translated">例子</h1><p id="5917" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">编程时，通常会引用本地文件并在代码中使用它们，例如:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="997e" class="lo lp iq my b gy nc nd l ne nf">let <strong class="my ir">data</strong> = <strong class="my ir">require</strong>(‘<strong class="my ir">./data.json</strong>’);<br/>// data = {"name": "count": "value": 4}</span></pre><p id="a1a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果您需要更新文件的值，会发生什么呢？您可以尝试以下方式:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ad11" class="lo lp iq my b gy nc nd l ne nf">const <strong class="my ir">fs</strong> = <strong class="my ir">require</strong>('<strong class="my ir">fs</strong>').promises;</span><span id="9ad1" class="lo lp iq my b gy ng nd l ne nf">const <strong class="my ir">newData</strong> = {"<strong class="my ir">name</strong>": "count", "<strong class="my ir">value</strong>": 1000000}</span><span id="fc63" class="lo lp iq my b gy ng nd l ne nf">await <strong class="my ir">fs</strong>.<strong class="my ir">writeFile</strong>('./<strong class="my ir">data</strong>', JSON.stringify(<strong class="my ir">newData</strong>))</span></pre><p id="cf11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">如果你打开文件，你会看到值已经改变。</strong></p><p id="893b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您希望在稍后的代码中引用更新后的文件。然后和之前一样通过<strong class="kt ir">要求</strong>访问文件。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7966" class="lo lp iq my b gy nc nd l ne nf">let <strong class="my ir">data</strong> = <strong class="my ir">require</strong>(‘./<strong class="my ir">data.json</strong>’);<br/>// data = {"<strong class="my ir">name</strong>": "count": "<strong class="my ir">value</strong>": 4}</span></pre><p id="07b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哦…你还在引用原始文件。</p><p id="6fe6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试着使用<strong class="kt ir"> fs </strong>在同一个节点进程中读取文件。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4f41" class="lo lp iq my b gy nc nd l ne nf">let <strong class="my ir">data</strong> = JSON.parse(<strong class="my ir">fs</strong>.<strong class="my ir">readFileSync</strong>('./<strong class="my ir">data</strong>', 'utf8'))<br/>// data = {"<strong class="my ir">name</strong>": "count", "<strong class="my ir">value</strong>": 1000000}</span></pre><p id="89d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在你正在使用更新的文件！！！</p><h1 id="6c57" class="mm lp iq bd lq mn mo mp lt mq mr ms lw jw mt jx lz jz mu ka mc kc mv kd mf mw bi translated">结论</h1><p id="d584" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我只是想提供一些见解，以防你在没有得到正确版本的文件时遇到问题。请记住，如果想要在整个运行的节点进程中引用文件的<strong class="kt ir">最新版本</strong>，请使用<strong class="kt ir"> fs </strong>包，否则，如果想要数据<strong class="kt ir">保持不变</strong>或不希望文件发生变化，请使用<strong class="kt ir">要求</strong>。</p><h2 id="d370" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">附:更新！</h2><p id="1595" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">丹尼尔·帕斯卡尔在关于a <code class="fe nj nk nl my b">require.cache</code>的评论中提出了一个很好的观点。一定要去看看！</p></div></div>    
</body>
</html>