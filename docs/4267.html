<html>
<head>
<title>Decrypting OpenSSL Data with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript解密OpenSSL数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/decrypting-openssl-data-with-javascript-38bbeebc34fc?source=collection_archive---------11-----------------------#2020-11-29">https://javascript.plainenglish.io/decrypting-openssl-data-with-javascript-38bbeebc34fc?source=collection_archive---------11-----------------------#2020-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e93b3658f8182eac38f564bfedf1387a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LC3YWajgEfTzGmMC.png"/></div></div></figure><p id="8b0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我最近编写了一个移动应用程序来跟踪库存。库存有大约1000条记录，应用程序只读取数据。我选择以JSON格式存储数据，并从AWS S3存储桶中托管它。这允许使用公共S3 URL下载文件。</p><p id="c350" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不在乎文件是否被其他人下载，所以我不需要认证，但想保持内容的秘密，所以我加密了它。密码短语包含在程序的某个地方，但是用户必须输入PIN来完成加密密码短语。因为文件是通过https获得的，所以在应用程序解密之前，这可以保持数据的秘密。该文件不应以未加密的形式存储在应用程序中。</p><p id="e429" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上传到AWS之前，我使用了<code class="fe kt ku kv kw b">openssl</code>命令来加密。我使用Expo中的<code class="fe kt ku kv kw b">FileSystem</code>组件将文件下载到我的React本地应用程序中。然后读取、解密和解析加密的文件，创建一个JSON对象。该应用程序只是在一个长列表中显示JSON。</p><p id="edbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要一个NPM模块来为React Native解密被<code class="fe kt ku kv kw b">openssl</code>加密的数据。大多数NodeJS程序中都使用了<code class="fe kt ku kv kw b">crypto-js</code> NPM模块，但是它在React Native中不起作用。需要一个纯JavaScript实现。幸运的是，一些好人已经用纯JavaScript重新实现了<code class="fe kt ku kv kw b">crypto-js</code>，并将其发布为<code class="fe kt ku kv kw b">crypto-es</code> NPM模块。这个模块可以在React Native、NodeJS和浏览器中工作。</p><p id="6437" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">openssl</code>可以对数据进行二进制或Base64编码。我发现使用<code class="fe kt ku kv kw b">FileSystem</code>组件和<code class="fe kt ku kv kw b">crypto-es</code>的组合来下载和解密Base64编码的文件是最容易的。Base64编码通常被格式化为76个字符的行，在末尾有一个换行符。<code class="fe kt ku kv kw b">openssl</code>可以创建一个长字符串来代替，这是最好的格式。对文件进行编码的命令行是:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="3892" class="lf lg in kw b gy lh li l lj lk">% openssl enc -aes-256-cbc -base64 -A &lt; file.txt &gt; encoded_file.txt</span></pre><p id="1cba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">-base64</code>选择带行的Base64编码，<code class="fe kt ku kv kw b">-A</code>使行成为长字符串。</p><p id="edfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我试过不用<code class="fe kt ku kv kw b">-base64</code>解密文件，用<code class="fe kt ku kv kw b">crypto-es</code>解密<code class="fe kt ku kv kw b">-A</code>都没有成功。我确信这是可能的，但是使用这种格式对我来说效果最好。</p><p id="e032" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过NodeJS使用这个JavaScript文件:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="e6c6" class="lf lg in kw b gy lh li l lj lk">import fs from 'fs'; import CryptoES from 'crypto-es'; if (process.argv.length == 3) { const pass = process.argv[2].split(':')[1]; const data = fs.readFileSync(0, 'utf-8'); function decodeBase64String(encrypted, pass) { var decrypted = CryptoES.AES.decrypt(encrypted, pass); var utf8 = CryptoES.enc.Utf8.stringify(decrypted); fs.writeFileSync(1, utf8); } decodeBase64String(data, pass); } else { console.log('need -pass:PASS'); }</span></pre><p id="3106" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将该文件保存到decrypt.js。</p><p id="d068" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们用NodeJS来解密它:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="6d4a" class="lf lg in kw b gy lh li l lj lk">% node decrypt.js -pass:PASS &lt; secretmsg.b64s The file contents are displayed.</span></pre><p id="158c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编写整个移动应用程序要复杂得多，但为<code class="fe kt ku kv kw b">openssl</code>找出正确的选项集是最具挑战性的，以至于我很长时间都避免在JavaScript中使用加密。既然我想通了，我就可以想用多少加密就用多少。希望这也能帮助您将加密技术添加到您的武器库中。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><p id="6900" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ls">原载于2020年11月29日【https://focusedforsuccess.com】<a class="ae lt" href="https://focusedforsuccess.com/decrypting-openssl-data-with-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a><em class="ls">。</em></em></p></div></div>    
</body>
</html>