<html>
<head>
<title>Doubly Linked Lists With JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript的双向链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/doubly-linked-lists-with-javascript-9c20a9dc4fb3?source=collection_archive---------0-----------------------#2020-12-01">https://javascript.plainenglish.io/doubly-linked-lists-with-javascript-9c20a9dc4fb3?source=collection_archive---------0-----------------------#2020-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a964" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript数据结构系列的第4部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/79167dd3cf141281958a7217ffff7bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DmGcIrktwqxrK7EZ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JJ Ying</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将看看双向链表，并使用JavaScript将它们与单向链表进行比较。如果你不熟悉单链表，可以看看下面的两篇文章。</p><div class="ls lt gp gr lu lv"><a href="https://chadmuro.medium.com/building-a-singly-linked-list-with-javascript-8427733361f8" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">用JavaScript构建一个单链表</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">他们说学东西的最好方法是教它。在这一系列文章中，我将教你关于…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">chadmuro.medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://medium.com/swlh/reversing-a-singly-linked-list-with-javascript-a2d3dc58d344" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">用JavaScript反转单向链表</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在我的上一篇文章中，我们用JavaScript构建了一个具有push、pop、shift和unshift功能的单链表。检查…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mk l mg mh mi me mj kp lv"/></div></div></a></div><h1 id="b299" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">什么是双向链表？</h1><p id="2896" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">双向链表非常类似于单向链表；它是由节点组成的数据结构。该列表将有一个头、尾和长度值。与数组不同，链表没有指向每个节点的索引，所以搜索或访问数据的唯一方法是遍历链表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/76c1935a850ab72275d2e2078f79be9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8OI5w8cS4idbtYyr-iNag.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.geeksforgeeks.org/doubly-linked-list/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/doubly-linked-list/</a></figcaption></figure><p id="850f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">双向链表和单向链表的一个区别是双向链表中的每个节点都有指向下一个和上一个值的指针，而单向链表中的节点只有指向下一个值的指针。要建立一个双向链表类，它将与单向链表完全相同。下面的代码为节点建立了一个类，为双向链表建立了一个类。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="8198" class="no mm iq nk b gy np nq l nr ns">class Node {<br/>  constructor(val) {<br/>    this.val = val;<br/>    this.prev = null;<br/>    this.next = null;<br/>  }<br/>}</span><span id="7854" class="no mm iq nk b gy nt nq l nr ns">class DoublyLinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>    this.tail = null;<br/>    this.length = 0;<br/>  }<br/>}</span></pre></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="22df" class="ml mm iq bd mn mo ob mq mr ms oc mu mv jw od jx mx jz oe ka mz kc of kd nb nc bi translated">向双向链表添加方法</h1><p id="1e06" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我们现在将向双向链表类添加方法。在本文中，我们将处理push、pop、shift和unshift的基本方法。它类似于构建一个单链表类，除了我们需要记住每个节点都有一个next和一个previous值。</p><h2 id="f0ec" class="no mm iq bd mn og oh dn mr oi oj dp mv lf ok ol mx lj om on mz ln oo op nb oq bi translated"><strong class="ak">推送(在末尾添加一个节点)</strong></h2><p id="8936" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">push方法将接受一个值作为参数，我们将首先用该值创建一个新节点，我们在这里将其保存为new node。我们需要检查一种极端情况，即列表是否为空。我们可以通过检查是否没有头，或者长度是否等于0来做到这一点。如果是这样，那么我们将简单地将列表的头部和尾部设置为新的节点。如果列表不为空，我们将把当前尾部的next属性设置为新节点，把新节点的previous属性设置为当前尾部，把列表的tail属性设置为新节点。最后，我们将列表的长度增加一，并返回列表。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="e3e0" class="no mm iq nk b gy np nq l nr ns">push(val) {<br/>  const newNode = new Node(val);<br/>  if (this.length === 0) {<br/>    this.head = newNode;<br/>    this.tail = newNode;<br/>  } else {<br/>    this.tail.next = newNode;<br/>    newNode.prev = this.tail;<br/>    this.tail = newNode;<br/>  }<br/>  this.length++;<br/>  return this;<br/>}</span></pre><h2 id="4254" class="no mm iq bd mn og oh dn mr oi oj dp mv lf ok ol mx lj om on mz ln oo op nb oq bi translated">Pop(从末端移除节点)</h2><p id="f2c7" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在pop方法中，我们将有两种边缘情况。首先，如果列表是空的，我们返回undefined。第二，如果列表的长度等于1，我们将删除该节点，因此我们将列表的head和tail属性设置为null。在其他情况下，我们首先需要将当前尾部存储在一个临时变量中，这样我们就不会丢失对它的引用。然后，我们将设置列表的尾部等于当前尾部的前一个节点。接下来，我们需要切断新旧尾巴之间的联系。这是通过将新尾部的下一个设置为空并将旧尾部的前一个(存储为temp)设置为空来实现的。最后，我们将长度减少1，并返回旧的尾部。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="7e28" class="no mm iq nk b gy np nq l nr ns">pop() {<br/>  if (this.length === 0) return undefined;<br/>  const temp = this.tail;<br/>  if (this.length === 1) {<br/>    this.head = null;<br/>    this.tail = null;<br/>  } else {<br/>    this.tail = temp.prev;<br/>    this.tail.next = null;<br/>    temp.prev = null;<br/>  }<br/>  this.length--;<br/>  return temp;<br/>}</span></pre><h2 id="571a" class="no mm iq bd mn og oh dn mr oi oj dp mv lf ok ol mx lj om on mz ln oo op nb oq bi translated"><strong class="ak"> Shift(从开始处删除一个节点)</strong></h2><p id="d5ec" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">对于一个双向链表，shift方法与pop方法非常相似，除了我们将使用头部，而不是尾部。我们将再次首先检查长度等于0和等于1的两种情况，并做完全相同的事情。否则，我们将把当前头存储在一个临时变量中，然后把列表的新头设置为旧头的下一个值。然后，我们将通过将新头的前一个值设置为空，并将旧头的下一个值(存储为temp)设置为空，来切断新旧头之间的联系。最后，我们将列表的长度减1，并返回旧的头。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="2f42" class="no mm iq nk b gy np nq l nr ns">shift() {<br/>  if (this.length === 0) return undefined;<br/>  const temp = this.head;<br/>  if (this.length === 1) {<br/>    this.head = null;<br/>    this.tail = null;<br/>  } else {<br/>    this.head = temp.next;<br/>    this.head.prev = null;<br/>    temp.next = null;<br/>  }<br/>  this.length--;<br/>  return temp;<br/>}</span></pre><h2 id="f3be" class="no mm iq bd mn og oh dn mr oi oj dp mv lf ok ol mx lj om on mz ln oo op nb oq bi translated"><strong class="ak"> Unshift(在开头添加一个节点)</strong></h2><p id="d6a7" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">就像shift类似于pop，unshift类似于push，除了我们将使用头部而不是尾部。unshift方法有一个参数，我们将用这个值创建一个新节点。我们将首先检查空列表的边缘情况。如果是这样，我们将把列表的head和tail属性设置为新的节点。否则，我们将设置新节点的下一个值为旧头，设置旧头的上一个值为新节点，设置列表的头为新节点。最后，我们将长度增加1并返回列表。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="503e" class="no mm iq nk b gy np nq l nr ns">unshift(val) {<br/>  const newNode = new Node(val);<br/>  if (this.length === 0) {<br/>    this.head = newNode;<br/>    this.tail = newNode;<br/>  } else {<br/>    newNode.next = this.head;<br/>    this.head.prev = newNode;<br/>    this.head = newNode;<br/>  }<br/>  this.length++;<br/>  return this;<br/>}</span></pre><p id="375b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终的代码应该如下所示。在我们的例子中，我们有节点类和双向链表类，以及push、pop、shift和unshift方法。在代码的最后，我们创建了一个列表，并将值1–5推送到列表中。从这里，您可以使用我们编写的方法轻松地添加或删除节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or os l"/></div></figure></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="5dd1" class="ml mm iq bd mn mo ob mq mr ms oc mu mv jw od jx mx jz oe ka mz kc of kd nb nc bi translated">双向链表与单向链表</h1><p id="dbc2" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">从上面的例子中可以看出，在双向链表中添加和删除与单向链表相似。但是，需要记住一些不同之处。</p><h2 id="07e8" class="no mm iq bd mn og oh dn mr oi oj dp mv lf ok ol mx lj om on mz ln oo op nb oq bi translated">双向遍历</h2><p id="fd3c" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">如果需要从头到尾遍历列表，拥有一个双向链表会很方便。与只能从头开始遍历的单链表相比，它使得在链表中导航容易得多。</p><h2 id="d52f" class="no mm iq bd mn og oh dn mr oi oj dp mv lf ok ol mx lj om on mz ln oo op nb oq bi translated">流行音乐的大O符号</h2><p id="d37d" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在单链表中，pop方法有一个大O符号O(N)。这是因为我们需要在尾部之前获取节点的值，唯一的方法是从头开始遍历每个节点。在一个双向链表中，pop有一个很大的O(1)符号，因为我们可以从尾部访问它作为前一个值。</p><h2 id="f2f7" class="no mm iq bd mn og oh dn mr oi oj dp mv lf ok ol mx lj om on mz ln oo op nb oq bi translated">记忆</h2><p id="7b83" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">单链表需要更少的内存来存储，因为每个节点只有一个方向的指针。在双向链表中，每个节点也有一个previous指针，所以会占用更多内存。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="5040" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ot">喜欢这篇文章吗？如果有，通过</em> <a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="ot">订阅我们的YouTube频道</em> </strong> </a> <strong class="ky ir"> <em class="ot">获取更多类似内容！</em>T11】</strong></p><p id="6aa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ot">如果您错过了本系列的第3部分，在那一部分中，我们讨论了使用JavaScript的堆栈和队列，请查看下面的文章。</em></p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/stacks-vs-queues-with-javascript-eeb33ae4c93c" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用JavaScript的堆栈与队列</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JavaScript数据结构系列的第3部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="ou l mg mh mi me mj kp lv"/></div></div></a></div><p id="67f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ot">敬请关注该系列的第4部分，我们将在那里深入了解二分搜索法树。</em></p></div></div>    
</body>
</html>