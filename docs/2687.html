<html>
<head>
<title>JavaScript Best Practices — Statements, Chaining, and Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—语句、链接和构造函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-statements-chaining-and-constructors-7edb55991e73?source=collection_archive---------10-----------------------#2020-07-14">https://javascript.plainenglish.io/javascript-best-practices-statements-chaining-and-constructors-7edb55991e73?source=collection_archive---------10-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1114c115f5ed75f695dc79b5d755710a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XnUduGO5aB_0sDLX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jairoalzate?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jairo Alzate</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ba61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="2522" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">每行的最大语句数</h1><p id="33ff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每行不应该有太多的语句。</p><p id="1c1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="34d6" class="mn lc iq mj b gy mo mp l mq mr">function foo () { let  bar; let baz; if (condition) { bar = 1; } else { baz = 2; } return true; }</span></pre><p id="bc3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="acd8" class="mn lc iq mj b gy mo mp l mq mr">function foo() {<br/>  let bar;<br/>  let baz;<br/>  if (condition) {<br/>    bar = 1;<br/>  } else {<br/>    baz = 2;<br/>  }<br/>  return true;<br/>}</span></pre><h1 id="fbe0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">要求构造函数名称以大写字母开头</h1><p id="b570" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">构造函数名称以大写字母开头，以区别于其他标识符。</p><p id="1b22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写作；</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ea21" class="mn lc iq mj b gy mo mp l mq mr">const person = new Person();</span></pre><p id="0820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个被普遍接受的惯例，所以人们会理解它。</p><h1 id="ec98" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调用不带参数的构造函数时使用括号</h1><p id="e755" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们在没有参数的情况下调用构造函数时，我们应该在构造函数中添加括号。</p><p id="08fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以跳过括号，但我们应该保留它们。</p><p id="055c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="100c" class="mn lc iq mj b gy mo mp l mq mr">const person = new Person;</span></pre><p id="8f01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="928a" class="mn lc iq mj b gy mo mp l mq mr">const person = new Person();</span></pre><h1 id="ba70" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">变量声明后的空行</h1><p id="b8fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将变量声明组合在一起。</p><p id="a545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4a52" class="mn lc iq mj b gy mo mp l mq mr">const greet = "hello,",<br/>const name = "james";</span><span id="78d7" class="mn lc iq mj b gy ms mp l mq mr">const foo = 12;</span></pre><p id="6fe3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用空行将它们分组，以便于区分。</p><h1 id="1998" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">return</code>语句前的空行</h1><p id="97c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">语句前的空行没什么用，所以我们可以跳过它们。</p><p id="cbb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c20d" class="mn lc iq mj b gy mo mp l mq mr">function foo(baz) {<br/>  if (!baz) {<br/>    return;<br/>  }<br/>  return baz;<br/>}</span></pre><p id="3735" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且节省一些空间。</p><h1 id="0f73" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">方法链中每次调用后换行</h1><p id="b3af" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有很长的方法链，我们应该在每次调用后加一个换行符。</p><p id="7c40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ec7b" class="mn lc iq mj b gy mo mp l mq mr">$("#p")<br/>  .css("color", "green")<br/>  .slideUp(2000)<br/>  .slideDown(2000);</span></pre><p id="f340" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="69c7" class="mn lc iq mj b gy mo mp l mq mr">$("#p").css("color", "green").slideUp(2000).slideDown(2000);</span></pre><h1 id="1ea2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用警报进行调试</h1><p id="f0a8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe mt mu mv mj b">alert</code>进行调试。</p><p id="7909" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调试有更好的选择，比如<code class="fe mt mu mv mj b">console</code>和<code class="fe mt mu mv mj b">debugger</code>。</p><p id="e025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，它们可以用于显示预期的警报。</p><h1 id="e7ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">Array</code>建造者</h1><p id="c3a9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">Array</code>构造函数适合创建空数组。</p><p id="fcd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，应该避免它能做的其他事情，而应该支持数组文字。</p><p id="86a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来创建一个空数组:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="04ba" class="mn lc iq mj b gy mo mp l mq mr">Array(10)</span></pre><p id="7611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到一个有10个空槽的数组。</p><p id="7c8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe mt mu mv mj b">fill</code>填充它们:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5441" class="mn lc iq mj b gy mo mp l mq mr">Array(10).fill().map((_, i) =&gt; i);</span></pre><p id="9231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">fill</code>和<code class="fe mt mu mv mj b">map</code>用内容填充空数组。</p><h1 id="7e71" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按位运算符</h1><p id="86dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">由于大多数人不知道JavaScript按位操作符，我们可能想要检查它们，这样它们就不会被错误地使用。</p><p id="dfa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">||</code>和<code class="fe mt mu mv mj b">&amp;&amp;</code>看起来像<code class="fe mt mu mv mj b">|</code>和<code class="fe mt mu mv mj b">&amp;</code>位运算符。</p><h1 id="077d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">呼叫者/被呼叫者的使用</h1><p id="1e75" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe mt mu mv mj b">arguments.caller</code>和<code class="fe mt mu mv mj b">arguments.callee</code>来获取函数的调用者和被调用者。</p><p id="87e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不能在严格模式下使用。</p><h1 id="df0d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">case/default子句中的词法声明</h1><p id="4287" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用<code class="fe mt mu mv mj b">case</code>和<code class="fe mt mu mv mj b">defaukt</code>块，这样我们就可以在不同的块中用相同的名称声明块范围变量。</p><p id="d52b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1594" class="mn lc iq mj b gy mo mp l mq mr">switch (foo) {<br/>  case 1:<br/>    let x = 1;<br/>    break;<br/>  case 2:<br/>    const y = 2;<br/>    break;<br/>  case 3:<br/>    function f() {}<br/>    break;<br/>  default:<br/>    class C {}<br/>}</span></pre><p id="ecaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1aef" class="mn lc iq mj b gy mo mp l mq mr">switch (foo) {<br/>  case 1: {<br/>    let x = 1;<br/>    break;<br/>  }<br/>  case 2: {<br/>    const x = 2;<br/>    break;<br/>  }<br/>  case 3: {<br/>    function f() {}<br/>    break;<br/>  }<br/>  default: {<br/>    class C {}<br/>  }<br/>}</span></pre><p id="cb6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在不同的块中声明<code class="fe mt mu mv mj b">x</code>,因为它们是块范围的。</p><h1 id="3444" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修改类声明的变量</h1><p id="9362" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该修改类声明的值。</p><p id="8e72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="380d" class="mn lc iq mj b gy mo mp l mq mr">class A { }<br/>A = 0;</span></pre><p id="aaa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不会得到一个错误，但它会使人迷惑。</p><h1 id="7013" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无法与-0进行比较</h1><p id="4936" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">===</code>不区分0和-0。</p><p id="339a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以比较它们不会得到我们期望的结果。</p><p id="5fee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bc5a" class="mn lc iq mj b gy mo mp l mq mr">if (x === -0) {<br/>  doSomething()<br/>}</span></pre><p id="df45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要用<code class="fe mt mu mv mj b">Object.is</code>来比较，它确实区分了+0和-0:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="86c4" class="mn lc iq mj b gy mo mp l mq mr">if (Object.is(x, -0)) {<br/>  doSomething();<br/>}</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ecb2fcf9e3902d1589598e12f795baa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yJXeRrItqPD94p0j"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Gold</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2094" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="046f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在一行中有太多的语句。</p><p id="3d61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">arguments</code>对象中的任何东西都不应该被使用。</p><p id="f026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按位运算符很容易被误认为布尔运算符。</p><p id="f166" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mt mu mv mj b">Object.is</code>与-0进行比较。</p><p id="72e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该总是用括号调用构造函数。</p></div></div>    
</body>
</html>