<html>
<head>
<title>Reviving a legacy codebase with React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React Native恢复遗留代码库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/my-first-experience-with-react-native-reviving-a-legacy-code-base-ac031d1010ca?source=collection_archive---------1-----------------------#2019-07-13">https://javascript.plainenglish.io/my-first-experience-with-react-native-reviving-a-legacy-code-base-ac031d1010ca?source=collection_archive---------1-----------------------#2019-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/33d65b3a6a6632bf5c6574605422f513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C_U3EhT_-8bvhYv_"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@illest_shinobi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Richard Catabay</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4715" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去的几个月里，我一直在帮助一个Pokemon Go社区组织开发他们基于React Native的移动应用程序，该应用程序已经有一年没有在上面进行积极的开发了，所以代码库需要一点TLC。</p><p id="df3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我有机会开发这个应用程序，因为我有React的经验，我的一个朋友建议他们和我谈谈，但这是我第一次使用React Native，我总是乐于学习新的东西。</p><p id="266d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我继承遗留代码时，特别是当它是一个JavaScript项目时，我必须做的第一件事就是让项目构建并运行。</p><h1 id="5f33" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">反应本地工具</h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/201624a106a055973bcf129f8198b204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tnScNsDo2NSQ42O5"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="02c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React Native有一个CLI，分别使用<code class="fe mb mc md me b">react-native run-ios</code>和<code class="fe mb mc md me b">react-native run-android</code>这样的命令可以相对容易地做到这一点，但是我遇到了一个问题，因为自上次创建应用程序以来，iOS和Xcode一直在更新，我需要更新依赖项才能与新版本一起工作。</p><p id="8f57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对React原生框架的一次简单更新导致了许多需要更新的依赖项，但最终一切似乎都井然有序，我可以开始编写代码了。</p><p id="d581" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我使用React Native而不是一些旧的“本地应用的web技术”技术时，最大的(令人愉快的)惊喜之一是Metro bundle server，它允许您只需刷新即可看到应用的变化，而不必重新编译应用——这真的加快了开发速度。</p><p id="3dda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，React Native的调试工具与web开发人员习惯使用的工具相同，即Chrome developer tools和Chrome developer tools扩展的独立版本<code class="fe mb mc md me b">react-devtools</code>。</p><p id="4250" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些工具允许您查看React组件结构以及组件的JavaScript，这使得弄清楚发生了什么变得轻而易举。</p><p id="878f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，React Native创建Xcode和Gradle项目，因此您可以使用Xcode和Android Studio来编译和运行应用程序，并调试本机级别的功能。</p><p id="a201" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，我无法与Expo合作，我知道Expo使事情变得容易得多，但该项目被“驱逐”,这意味着Expo不再管理应用程序的构建周期，因为已经添加了自定义的原生功能。</p><h1 id="49b9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">学习代码库</h1><p id="2be6" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">在我让应用程序运行之后，下一步是更好地理解代码库。</p><p id="f692" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之前的开发团队在将应用程序组织成不同的模块(动作、减速器、组件、屏幕等)方面做得很好，但组件并没有像它们应该的那样模块化，也没有测试和有限的文档。</p><p id="2489" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为最好的办法是浏览整个代码库，并在每一处添加文档。</p><p id="afca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将允许我弄清楚每件事都在做什么，并留下重构笔记供我以后继续学习。</p><h2 id="591c" class="mk kz in bd la ml mm dn le mn mo dp li kl mp mq lm kp mr ms lq kt mt mu lu mv bi translated">生成文档</h2><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/ddd590c9b8b88e3229088662980f675f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sVeutFWUYQRC7EIl"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@eddrobertson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ed Robertson</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aee6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然添加文档字符串相对容易，但是将这些文档字符串转换成可用的文档站点稍微困难一些。</p><p id="6a5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最初从<code class="fe mb mc md me b">jsdoc</code>开始，因为我过去一直在使用它，但是代码库中使用的模块结构似乎混淆了<code class="fe mb mc md me b">jsdoc</code>，我不得不使用<code class="fe mb mc md me b">better-docs</code>来手动定义模块结构。</p><p id="262a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我用<code class="fe mb mc md me b">esdoc2</code>和它提供的插件进行了实验。这工作得很好，因为它选择了模块结构，并包含了很好的工具，如文档覆盖报告，并允许单元测试用例与功能相关联。</p><p id="9f9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最终决定使用<code class="fe mb mc md me b">jsdoc</code>,因为我遇到了<code class="fe mb mc md me b">esdoc2</code>的一个问题，它从我无法正确配置的类中省略了许多公共方法——这可不是你想从文档生成器中看到的！</p><h2 id="a2fe" class="mk kz in bd la ml mm dn le mn mo dp li kl mp mq lm kp mr ms lq kt mt mu lu mv bi translated">添加测试</h2><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/7f4a8b0fbab4d91db225510de22ad02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LaA17vxdNWl-IN_J"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@nicolasthomas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicolas Thomas</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9008" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于代码库没有测试，我开始添加一些。</p><p id="106a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编写测试是迄今为止理解一个函数或类正在做什么的最好方法，之前的开发团队在他们的待办事项中有许多标签来添加测试，这允许我学习这些标签的代码和标记。</p><p id="77f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该应用程序使用redux，所以我开始进行单元测试，测试内容包括action和reducers，因为当与redux的愿景内联实现时，这些都是没有副作用的纯函数，这使得它们非常容易测试。</p><p id="640c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我为应用程序中的状态管理编写了测试，我就可以开始为改变状态的函数编写测试，然后为显示状态数据的组件编写测试。</p><p id="1b8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于React本机组件只是组件，因此可以采用与React组件相同的方法来测试它们，例如快照测试和浅层渲染。</p><h2 id="226f" class="mk kz in bd la ml mm dn le mn mo dp li kl mp mq lm kp mr ms lq kt mt mu lu mv bi translated">项目管理</h2><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/19d1a4cfb827cce30925ed930f04e6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0EsXi9NllDoFBDTv"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@kylejglenn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kyle Glenn</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9662" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名开发人员，我发现继承项目最容易被忽视的一个方面是项目管理&amp;代码库的产品开发方面。</p><p id="a772" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一名开发人员，当面对一个庞大的代码库时，很容易全神贯注于代码，以至于我们无法思考最初为什么以及如何编写代码。</p><p id="f86b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在继承代码库的早期，我和一个人开了一次会，这个人让我负责理解哪些未完成的拉请求(有八个)可以被删除，我们能够将回购上的特性分支数量减少到只有两个。</p><p id="c4be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这使事情变得更容易，因为移动的部分更少，更重要的是，我可以看到开发团队在工作中有什么变化，当他们关闭工具时，因为有可能最终这些变化会使我正在做的一些重构变得多余。</p><p id="6b11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还进行了一次待办事项梳理会议，这样我就可以了解哪些功能是重要的，就好像他们计划很快删除或重写一些东西，这样我就可以让自己不要太专注于应用程序的这个领域。</p><p id="a9ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些会议和测试实际上是最有用的，因为我对以前的开发团队留下的事情有了一个全面的了解，并且我知道应该在哪里集中精力。</p><h1 id="33b0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从反应移动到反应本地</h1><p id="7ce8" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">React Native的目标之一是将web组件技术引入原生开发领域，使构建原生应用变得快速而简单，我敢说它绝对达到了这个目标。</p><p id="c364" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了最终只是在模拟器或设备上协调应用程序外壳的编译和运行的附加工具之外，构建应用程序的工作流程没有太大的不同。</p><p id="0040" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您使用组件时，可以(也应该)使用相同的设计模式，例如纯组件和高阶组件，并且可以使用工具，例如<a class="ae jz" href="https://storybook.js.org/" rel="noopener ugc nofollow" target="_blank"> Storybook.js，使团队之间的交流和共享理解更加容易</a>。</p><p id="70da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，我的下一步是将许多复杂的组件分解成更小的纯组件，这些组件将形成一个导入主应用程序的组件库，这样代码库更清晰，而且这些纯组件可以在其他地方重用。</p><p id="50a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我发现这种模式在大型React应用程序中非常有效，因为一个团队可以专注于应用程序数据结构的组成，而另一个团队可以专注于数据和用户旅程的显示。</p><p id="9798" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Redux正在应用程序中使用，所以我很可能会很快对它进行重构，以包括Redux Saga，因为应用程序中有大量的副作用(例如，将状态写入本地存储)可以使用Sagas抽象出来，我发现Redux Saga使这些副作用非常容易测试。</p><h1 id="f5fc" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">后续步骤</h1><p id="ef76" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">这可能会是我未来几个月甚至几年博客中的一个不断发展的话题，因为我还有很多关于React Native和also React的内容要学。</p><p id="90cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，接下来的步骤是重构代码库，以允许创建纯组件库，添加Redux Saga，并设置一个持续集成服务器来运行测试，作为开发工作流的一部分。</p><p id="669f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">敬请关注React Native的更多见解！</p></div></div>    
</body>
</html>