<html>
<head>
<title>Integrating ag-Grid into your React application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将ag-Grid集成到React应用程序中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/integrating-ag-grid-into-your-react-application-53f430a3ab05?source=collection_archive---------7-----------------------#2020-12-29">https://javascript.plainenglish.io/integrating-ag-grid-into-your-react-application-53f430a3ab05?source=collection_archive---------7-----------------------#2020-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/20d2283e79f6435ea7f9fa1e2606ba95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NANHjCqTxUvequ6Abbi6BQ.png"/></div></div></figure><p id="67b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正在尝试学习如何将ag-Grid整合到React应用程序中，那么您已经找对了地方。</p><p id="b3e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将介绍ag-Grid的客户端和服务器端实现。我将解释所有必要的部分，以及如何将这两个实现集成到React应用程序中。</p><p id="83bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于不熟悉ag-Grid的人来说，它是一个功能丰富的JavaScript数据网格，支持React、Angular和Vue等主流JavaScript框架。</p><p id="97bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我链接了ag-Grid文档中列出的一些流行功能:</p><ul class=""><li id="2c9b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><a class="ae lc" href="https://www.ag-grid.com/javascript-grid-row-styles/" rel="noopener ugc nofollow" target="_blank">布局&amp;造型</a></li><li id="63e3" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated"><a class="ae lc" href="https://www.ag-grid.com/javascript-grid-selection-overview/" rel="noopener ugc nofollow" target="_blank">选择</a></li><li id="2e83" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated"><a class="ae lc" href="https://www.ag-grid.com/javascript-grid-filtering-overview/" rel="noopener ugc nofollow" target="_blank">过滤</a></li><li id="f5dc" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated"><a class="ae lc" href="https://www.ag-grid.com/javascript-grid-rendering-flow/" rel="noopener ugc nofollow" target="_blank">渲染</a></li></ul><h1 id="2346" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">客户端实现</h1><p id="8aa1" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">客户端实现非常简单。下面是客户端实现所需的内容:</p><ul class=""><li id="77f9" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">银栅反应元件</li><li id="e52d" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">ongriddready</li><li id="52c7" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">网格选项</li><li id="8819" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">ColumnDefs</li><li id="046d" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">RowData</li></ul><p id="740e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有一件事我们要添加，但是<strong class="jx io">别担心，</strong>我会解释的。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="0c0e" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">ongriddready</h2><p id="aaf7" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们添加的第一个道具是<code class="fe nd ne nf ng b">onGridReady</code>，这是一个提供网格和列API的事件回调。这里我们用它来设置局部变量<code class="fe nd ne nf ng b">gridApi</code>的状态，稍后我们可以用它在网格上执行操作，比如获取一个选中的行。</p><h2 id="bf07" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">网格选项</h2><p id="81b5" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><code class="fe nd ne nf ng b">gridOptions</code>是整个电网接口的<em class="nh">【一站式】</em>。所有网格属性都可以通过该对象获得。这里指向<code class="fe nd ne nf ng b">GridConfig.gridConfig</code>。</p><p id="c10f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我创建的名为<code class="fe nd ne nf ng b">GridConfig</code>的文件，其中包含一个对象，该对象具有网格所需的一些属性。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><blockquote class="ni nj nk"><p id="d0ab" class="jv jw nh jx b jy jz ka kb kc kd ke kf nl kh ki kj nm kl km kn nn kp kq kr ks ig bi translated">注意:没有必要为网格创建单独的文件。我这样做只是为了分散关注</p></blockquote><h2 id="40d0" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">ColumnDefs</h2><p id="1288" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">如前所述，<code class="fe nd ne nf ng b">columnDefs</code>是网格所必需的。它是一个包含要显示的<code class="fe nd ne nf ng b">headerName</code>和对应行数据的<code class="fe nd ne nf ng b">field</code>的属性。</p><p id="415a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过<code class="fe nd ne nf ng b">gridOptions</code>，我们正在设置列定义。我们可以很容易地将<code class="fe nd ne nf ng b">rowData</code>属性放在配置文件中，或者直接将其作为道具添加。</p><h2 id="c600" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">RowData</h2><p id="3a09" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><code class="fe nd ne nf ng b">rowData</code>是用于设置数据在网格中显示为行的属性。</p><h2 id="ee39" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">获取数据</h2><p id="5730" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">剩下要解释的就是<code class="fe nd ne nf ng b">getGridData</code>函数了。它向public文件夹中的一个文件发出GET请求，我在这个文件夹中为网格添加了数据(<em class="nh">这可以用一个真正的端点</em>来替换)。一旦数据被返回，我们将<code class="fe nd ne nf ng b">rowData</code>设置为它的结果，网格就会被这些数据填充。</p><h1 id="1427" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">服务器端实施(仅限企业)</h1><p id="fbda" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">在使用ag-Grid的服务器端实现时有一些不同。首先我们要介绍一些新道具，它们是<code class="fe nd ne nf ng b">rowModelType</code>和<code class="fe nd ne nf ng b">cacheBlockSize</code>。我们还必须提供一种新的机制来为网格提供数据。</p><p id="1d69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用客户端行模型实现时，我们所要做的就是向网格的<code class="fe nd ne nf ng b">rowData</code> prop提供数据。然而，这个属性只适用于客户端实现。</p><p id="6c56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用服务器端行模型实现时，应用程序需要实现一个数据源，用于向网格提供数据。这个实现必须符合服务器端数据源接口。</p><p id="8b12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下代码片段显示了一个简单的数据源实现:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/ba04a56f20b39a4915b0dc06da958fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnc8lUq91MVyFH1ratb3HQ.png"/></div></div></figure><p id="87ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们的实现:</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="bcfc" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">RowModelType</h2><p id="05ba" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><code class="fe nd ne nf ng b">rowModelType</code>设置了将数据加载到网格中的策略。默认设置为<code class="fe nd ne nf ng b">clientSide</code>。</p><h2 id="da41" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">CacheBlockSize</h2><p id="c787" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated"><code class="fe nd ne nf ng b">cacheBlockSize</code>属性决定每个请求获取多少数据</p><h2 id="411e" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">注册数据源</h2><p id="5203" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">除了网格需要的新道具之外，我们还需要引入一些其他的新东西:</p><ul class=""><li id="5dec" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">getRows(参数)</li><li id="17e1" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">params.successCallBack()</li><li id="a624" class="kt ku in jx b jy ld kc le kg lf kk lg ko lh ks ky kz la lb bi translated">parms . API . setserversidedata source()</li></ul><p id="0f07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当网格需要数据时，调用<code class="fe nd ne nf ng b">getRows(params)</code>函数。从服务器获取的行通过<code class="fe nd ne nf ng b">params.successCallback()</code>提供给网格。<code class="fe nd ne nf ng b">params.api.setServerSideDataSource()</code>将数据源注册到网格中。</p><h2 id="18a2" class="mr lj in bd lk ms mt dn lo mu mv dp ls kg mw mx lw kk my mz ma ko na nb me nc bi translated">获取数据</h2><p id="40f1" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">在这个<code class="fe nd ne nf ng b">getGridData</code>函数中，我们首先向行数据所在的公共文件夹中的位置发出一个GET请求。然后，我们使用返回的数据数组通过<code class="fe nd ne nf ng b">params.successCallback()</code>向网格提供行。最后，我们使用<code class="fe nd ne nf ng b">params.api.setServerSideDataSource()</code>注册数据源。</p><h1 id="190b" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="1bce" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们现在已经讨论了将行数据加载到网格中的两种不同策略。对于客户端实现，应用程序将完整的数据集加载到客户端，然后将它全部传递到网格。对于服务器端实现，数据保存在服务器上，并分部分加载到网格中。归根结底，是决定哪种实现最适合您的应用程序的需求。更多关于ag-Grid及其所有功能的信息，请查阅<a class="ae lc" href="https://www.ag-grid.com/documentation-main/documentation.php" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p></div></div>    
</body>
</html>