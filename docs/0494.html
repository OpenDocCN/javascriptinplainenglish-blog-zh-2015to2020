<html>
<head>
<title>Using WebGL to Solve a Practical Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用WebGL解决一个实际问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-webgl-to-solve-a-practical-problem-751c186889aa?source=collection_archive---------4-----------------------#2019-10-28">https://javascript.plainenglish.io/using-webgl-to-solve-a-practical-problem-751c186889aa?source=collection_archive---------4-----------------------#2019-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9d59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">虚拟程序员介绍(使用史密斯-沃特曼算法)</h2></div><p id="8d43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前一段时间，我在教python入门和基本的浏览器编程。在这段时间里，我写了一个应用程序来比较软件代码的片段，并在一个力导向和龙卷风图中展示了它们的相似性。我半定期(每周)运行这个软件，很早，我的解决方案出现了一个重大问题。</p><p id="b79f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决这个问题花了很长时间。一只<strong class="kh ir">真的</strong>长时间了。一个<strong class="kh ir">痛苦地</strong>漫长的时间。</p><p id="3d2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我需要找到一种方法来加快处理速度。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/6cb27fbfd67f50886d9ee542a1fa5364.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/1*rcQJwTza2yxMR9yiORtuYA.gif"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">The points are computer programs, and the orange line represents the progress of a comparison. With 36 comparisons, this takes … long enough that I get bored.</figcaption></figure><p id="fbe3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我编写这个工具的时候，GPU处理非常热门，每个人都在谈论这将如何加速一切。无论是什么问题，GPU都是答案。这是一个明显的调查途径。然而，我已经决定在浏览器中编写这个工具(法律和道德约束)，浏览器不能直接访问底层硬件。</p><p id="f66a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果所有酷孩子都在使用GPU，并且这是在浏览器中编写的，我非常好奇…</p><p id="3872" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来我正在学习WebGL和GLSL。</p><div class="lp lq gp gr lr ls"><a href="https://jefferey-cave.gitlab.io/miss/webgl.html" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab fo"><div class="lu ab lv cl cj lw"><h2 class="bd ir gy z fp lx fr fs ly fu fw ip bi translated">WebGL演示</h2><div class="lz l"><h3 class="bd b gy z fp lx fr fs ly fu fw dk translated">因为WebGL自然地处理4个内存寄存器(RGBA)，所以我们将这些用于(4？)存储位置。这也使得…</h3></div><div class="ma l"><p class="bd b dl z fp lx fr fs ly fu fw dk translated">jefferey-cave.gitlab.io</p></div></div></div></a></div><blockquote class="mb mc md"><p id="d167" class="kf kg lo kh b ki kj jr kk kl km ju kn me kp kq kr mf kt ku kv mg kx ky kz la ij bi translated">自从写了<a class="ae lb" href="https://jefferey-cave.gitlab.io/miss/" rel="noopener ugc nofollow" target="_blank"> M.I.S.S. </a>之后，Google发布了tensorflow.js，也有了gpu.js和twgl.js等其他工具。虽然我选择直接用WebGL编写，但这些库提供的计算抽象层通常很有用。</p><p id="9041" class="kf kg lo kh b ki kj jr kk kl km ju kn me kp kq kr mf kt ku kv mg kx ky kz la ij bi translated">WebGL不是一种计算语言……但这何时停止了冒险。</p></blockquote><h2 id="e3d8" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">先决条件</h2><p id="b120" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在开始之前，你应该熟悉编程。演示是用普通的浏览器JavaScript编写的，所以没有使用特别高级的技术；然而，使用WebGL需要在两种语言之间切换，并编译代码。Web编程通常不涉及那些东西。</p><p id="0599" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你应该稍微熟悉的唯一编程技术是“细胞自动机”:<a class="ae lb" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener ugc nofollow" target="_blank">康威的《生命的游戏》</a>是这方面的经典例子。50年来，它一直是编程教师的主食，因为问题相对简单，解决方案足够复杂，可以锻炼学生的技能，而且输出也很有趣。</p><p id="78b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我强烈建议去当地的办公用品商店，买一只便宜的铅笔、橡皮擦和格子纸垫。没有什么比自己解决问题更能增进理解了。</p><h1 id="ecf9" class="nj mi iq bd mj nk nl nm mm nn no np mp jw nq jx ms jz nr ka mv kc ns kd my nt bi translated">GPU如何加快处理速度</h1><p id="ce2f" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">GPU是与CPU完全不同的机制。CPU的设计是为了给人们提供许多操作，并允许你一次运行一个。GPU提供更少的操作，但是以一种你可以同时运行它们的方式设置它们(并行处理)。</p><p id="5327" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对我们程序员来说有几个不同的代价。</p><ol class=""><li id="3694" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">就像在不同的电脑上工作一样。</li><li id="507e" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">我们为一个写的指令，不一定存在于另一个上。</li></ol><p id="b3aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很烦人，但是…并行处理:只要它们都运行相同的指令集，你就可以同时运行一个计算几千次。非常简单地说:</p><p id="f974" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">GPU做单个函数的并行处理。</strong></p><p id="3b67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从技术上讲，这个函数被称为“内核”，在我的代码中我称它为“程序”。</p><p id="3974" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑以下函数:</p><pre class="ld le lf lg gt oi ni oj ok aw ol bi"><span id="9257" class="mh mi iq ni b gy om on l oo op">function MultiplicationTable(size=10){ <br/>    let table = Allocate2DArray(size);<br/>    for(memLoc.x=0; memLoc.x &lt; list.length; memLoc.x++){<br/>        for(memLoc.y=0; memLoc.y &lt; list.length; memLoc.y++){<br/>            <strong class="ni ir">table[memLoc.x][memLoc.y] = memLoc.x * memLoc.y;</strong><br/>        }<br/>    }<br/>    return table;<br/>}</span></pre><p id="5ead" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GPU上的并行处理是指同时执行相同的操作。在这种情况下，乘法是一个始终如一的过程。</p><p id="a2c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将只做一些基本的数学计算:一个<code class="fe nf ng nh ni b">10 x 10</code>数组花费我们100个单位的处理时间。</p><p id="7c29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在考虑使用GPU的处理</p><pre class="ld le lf lg gt oi ni oj ok aw ol bi"><span id="36df" class="mh mi iq ni b gy om on l oo op">function MultiplicationTable(size=10){<br/>    let table = Allocate2DArray(size);<br/>    table = gpu(table)<br/>        .forEach((memLoc)=&gt;{<strong class="ni ir">return memLoc.x * memLoc.y;</strong>});<br/>    return table;<br/>}</span></pre><p id="b443" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论是<code class="fe nf ng nh ni b">10x10</code>还是<code class="fe nf ng nh ni b">10000x10000</code>，该<code class="fe nf ng nh ni b">forEach</code>都花费一(1)个单位的处理时间。</p><p id="26d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我编了那个代码，它不会工作，但是它确实给了你一些我们努力工作的想法。无论我们制造多大的<code class="fe nf ng nh ni b">table</code>,都需要1个单位的处理时间。</p><h1 id="10df" class="nj mi iq bd mj nk nl nm mm nn no np mp jw nq jx ms jz nr ka mv kc ns kd my nt bi translated">使用GPU</h1><p id="2845" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">GPU在机械上不同于CPU。</p><p id="8dfa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这种机械差异，将GPU视为一台完全独立的计算机是很有用的。你不仅有单独的处理单元(GPU而不是CPU)，它还使用单独的内存，和单独的指令集。</p><p id="25d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分离的这三个要素意味着我们需要经历三个主要阶段来利用它们:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi oq"><img src="../Images/23d79f68e3874a54592e8a7e9ffd405c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qh8H4jLZ1oPn_xByPeU6Mg.png"/></div></div></figure><ol class=""><li id="6a41" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">在GPU空间发送指令(编译)</li><li id="e745" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">与GPU空间交换内存(传输—读/写)</li><li id="0482" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">执行指令(执行)</li></ol><p id="8fbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管理这三个阶段是使用WebGL最困难和复杂的部分。仅仅为了与另一个空间交换信息，就需要处理大量的细节。</p><p id="5305" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部分原因是GPU和WebGL中的<code class="fe nf ng nh ni b">G</code>代表“图形”。我们正在尝试使用一些为处理图像而设计的东西来进行一般的计算。需要管理的细节围绕着定义图像的元素；这意味着我们需要经历一个用图像来描述原始数据的过程。</p><p id="3472" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过创建将为我们描述数据的助手函数，简化了这一过程。</p><h2 id="a157" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">psGPU</h2><p id="7bc2" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在<code class="fe nf ng nh ni b">WebGL.html</code>中，就设置了这样一个助手类，叫做<code class="fe nf ng nh ni b">psGPU [<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L158-457" rel="noopener ugc nofollow" target="_blank">webgl.html:158</a>]</code>。它有几个功能来抽象掉大部分配置:</p><ol class=""><li id="2447" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated"><code class="fe nf ng nh ni b">addProgram</code>:编译并发送一段GLSL代码(字符串)到GPU空间。<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L384-456" rel="noopener ugc nofollow" target="_blank">webgl.html:384</a>]</code></li><li id="0eb4" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><code class="fe nf ng nh ni b">initMemory</code>:创建一个隐藏的图像，作为我们的处理记忆<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L289-346" rel="noopener ugc nofollow" target="_blank">webgl.html:289</a>]</code></li><li id="4784" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><code class="fe nf ng nh ni b">write</code>:将我们的记忆(<code class="fe nf ng nh ni b">UInt8Array</code>)转移到GPU空间<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L254-264" rel="noopener ugc nofollow" target="_blank">webgl.html:254</a>]</code></li><li id="f88c" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><code class="fe nf ng nh ni b">read</code>:将我们的记忆从GPU空间转移回来<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L241-252" rel="noopener ugc nofollow" target="_blank">webgl.html:241</a>]</code></li><li id="f347" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated"><code class="fe nf ng nh ni b">run</code>:执行我们编译的程序<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L266-287" rel="noopener ugc nofollow" target="_blank">webgl.html:266</a>]</code></li></ol><p id="3e7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个新手，这些功能对于设置GPU变得至关重要。我对实现一个算法非常感兴趣，内存管理的复杂性极大地分散了我想关注的复杂性。</p><h2 id="f21f" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated"><code class="fe nf ng nh ni b">pixel</code></h2><p id="084f" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在某个时候，第二个助手类被创建，称为<code class="fe nf ng nh ni b">pixel</code>。<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L96-156" rel="noopener ugc nofollow" target="_blank">webgl:96</a>]</code></p><p id="6335" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过读写交换的内存由一个字节数组组成。将图像解释为字节数组需要更多的助手。特别地，图像的每个像素被解释为4个字节，代表该像素的<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgba()" rel="noopener ugc nofollow" target="_blank">红色、绿色、蓝色和Alpha </a> ( <code class="fe nf ng nh ni b">rgba</code>)值。在GPU中，这些值由类型<code class="fe nf ng nh ni b">vec4</code>表示，它是4个值的集合(<code class="fe nf ng nh ni b">r</code>、<code class="fe nf ng nh ni b">g</code>、<code class="fe nf ng nh ni b">b</code>、<code class="fe nf ng nh ni b">a</code>)。</p><p id="ffdd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了帮助在CPU/GPU边界上保持一致的命名，创建了pixel类。pixel类实际上只是方便将返回的<code class="fe nf ng nh ni b">UInt8Array</code>映射到代表给定像素的4个字节，允许它们被相同的<code class="fe nf ng nh ni b">rgba</code>符号引用。<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L102-112" rel="noopener ugc nofollow" target="_blank">webgl:102</a>]</code></p><h2 id="fa34" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">绘图网格</h2><p id="935d" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">可能最有趣的(也许“有用”是个更好的词)效用函数是<code class="fe nf ng nh ni b">DrawGrid</code>。<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L828-883" rel="noopener ugc nofollow" target="_blank">webgl:828</a>]</code></p><p id="3b4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为GPU是为管理图像而设计的，所以检查内存变化的唯一方法就是查看图片。由于这个项目的目的与图像无关，颜色不是一种有意义的表现。这使得调试变得更加棘手。</p><p id="3ede" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了有所帮助，<code class="fe nf ng nh ni b">DrawGrid</code>只不过是将每个像素位置呈现为它们的底层数值。它大致相当于JavaScript的<code class="fe nf ng nh ni b">console.log</code>，允许开发人员将一组值转储到一个可见的位置进行检查。</p><p id="20b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将它(和一个断点)放在内核<code class="fe nf ng nh ni b">run</code>之后，可以最有效地使用它。测速的时候别忘了注释掉。</p><h2 id="1ba4" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">实际运行</h2><p id="f699" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">一旦助手就位，定义我们的处理函数并以正确的顺序调用它们就很简单了。</p><ol class=""><li id="3fd9" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">发送GPU空间中的指令</li><li id="86af" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">与GPU空间交换内存</li><li id="04ad" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">执行指令</li></ol><p id="f09f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定适当数量的助手代码，在CPU侧的实际代码部分<em class="lo">中没有留下大量要执行的指令。所有真正有趣的逻辑都应该移到GPU上；所有有趣的处理都应该驻留在内核定义中。</em></p><p id="de36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在CPU端，我们将指令发送到GPU ( <code class="fe nf ng nh ni b">addProgram</code>)，然后反复发送通知执行函数(<code class="fe nf ng nh ni b">run</code>)。</p><h1 id="4e79" class="nj mi iq bd mj nk nl nm mm nn no np mp jw nq jx ms jz nr ka mv kc ns kd my nt bi translated">普遍的问题</h1><p id="53c1" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">比较代码的相似性是一个很好解决的问题。“比较指令序列，同时考虑到小的变化”，听起来非常类似于DNA比较。</p><p id="6312" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在遗传学的世界里，<a class="ae lb" href="https://en.wikipedia.org/wiki/Sequence_alignment" rel="noopener ugc nofollow" target="_blank">序列比对</a>算法已经存在很长时间了(<a class="ae lb" href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm" rel="noopener ugc nofollow" target="_blank"> Needleman-Wunsch </a>大约可以追溯到1970年)。比较DNA序列的相似性，同时考虑到由于突变或交换引起的微小差异是一个共同的目标，这也是我们试图解决的问题。把这想象成软件的亲子鉴定。</p><p id="9ee1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就我而言，我进行了史密斯-沃特曼的比较。</p><p id="86ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理解一个算法最好的方法就是用铅笔和纸来解。在这种情况下，我花了大量的时间，从当地的便利店买了一支铅笔、一块橡皮和一沓网格纸。</p><p id="ca0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">取两种动物的名字:<code class="fe nf ng nh ni b"><a class="ae lb" href="http://slideplayer.com/slide/5142106/16/images/21/Smith-Waterman-Algorithm.jpg" rel="noopener ugc nofollow" target="_blank">coelecanth</a></code> <a class="ae lb" href="http://slideplayer.com/slide/5142106/16/images/21/Smith-Waterman-Algorithm.jpg" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe nf ng nh ni b"><a class="ae lb" href="http://slideplayer.com/slide/5142106/16/images/21/Smith-Waterman-Algorithm.jpg" rel="noopener ugc nofollow" target="_blank">pellican</a></code>。</p><p id="bf0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从表面上看，它们看起来并不相似，然而，仔细观察(令人惊讶地)会发现它们确实排列得相当好:</p><pre class="ld le lf lg gt oi ni oj ok aw ol bi"><span id="1264" class="mh mi iq ni b gy om on l oo op">c o <strong class="ni ir">e . l e c a n</strong> t h<br/>p . <strong class="ni ir">e l l i c a n</strong></span></pre><p id="086d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过编程，我们可以通过求解Smith-Waterman矩阵找到这种排列:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/70849d3ede2d47abea98641168f94ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*CQJrOZyzxeYPoJ0-CaipUA.png"/></div></figure><p id="01b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解如何机械地解决上面的排列，我建议遵循维基百科上给出的<a class="ae lb" href="https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm#Example" rel="noopener ugc nofollow" target="_blank">例子。我的意思不是去阅读维基百科页面，我的意思是拿出那张网格纸，为你自己复制这个例子。求解每一步，并对照示例进行验证。如果你犯了一个错误，花些时间理解你的错误，然后重新开始。</a></p><p id="f4ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你能自己解决一个史密斯-沃特曼问题时，你就证明你理解了它。</p><p id="b9ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然下面详细讨论了实现，但是有必要对所涉及的两个过程中的一个有一个直观的理解；试图同时学习两者更难。如果您对如何在GPU上实现算法感兴趣，了解示例算法是非常有用的。如果您已经是GPU的大师，并且对如何实现Smith-Watermans感兴趣，这个非常基本的例子可能是一个很好的敲门砖。</p><h1 id="1bcf" class="nj mi iq bd mj nk nl nm mm nn no np mp jw nq jx ms jz nr ka mv kc ns kd my nt bi translated">放在一起</h1><p id="8ee1" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">这并不容易。使用GPU需要我们并行思考，这需要我们以我们通常不习惯的方式思考。在线性处理中我们认为理所当然的事情对我们来说是不存在的；我们通常会避免的事情，我们为了能够使用工具而接受。</p><p id="6587" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何做到这一点的想法实际上来自我最喜欢的大学作业之一:康威的生活游戏(GoL)。在GoL中，每个生命形式位置根据其最近邻居的状态改变其状态。这通常在屏幕上用数值表表示的网格中解决。</p><p id="ce4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这句话的关键是，每个自动机细胞都有一个独立于所有其他细胞的状态，并基于其最近邻居的值。这也很好地描述了史密斯-沃特曼。唯一真正的变化是Smith-Watermans只考虑左上角的相邻单元(北、西、西北)。</p><p id="b964" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在能够计算值之前，需要计算这些“父”值，这代表了并行化算法的挑战之一:不能并行计算从属值。思想上的第一个突破是我在网上找到的一个动画GIF，它展示了SW矩阵中数值的对角线平行化。(原参考现在已经失传到记忆深处了…如果知道的话，留下评论)</p><p id="e5c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更糟糕的是，我最初优化我的算法是为了降低内存消耗。为了做到这一点，如果给定的细胞不是链的一部分，我已经最大限度地释放了与它相关的早期记忆。使用GPU的挑战之一是确定一种方式来安排内存，以便只对具有完整父集的元素执行计算。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/f5befdae2d5946733ac543865c2f65e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/1*1P1O0n5nB66I4zsAAu7JVQ.gif"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Working diagonally, allows us to maintain sufficient parent cells (green) to calculate a number of child cells (yellow) in parallel. Processing this on the GPU means that all of the other cells (white) will be calculated for no reason. A reasonable trade-off.</figcaption></figure><p id="150f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种对优化的关注让我忽视了一个事实，即不管矩阵的大小如何，用GPU评估矩阵的成本都是1。使用CPU计算的原始速度需要一次评估一个单元:<code class="fe nf ng nh ni b">width * height</code>处理时间。使用GPU，每次计算所有的元素感觉像是浪费工作，但在某个时候，我的虚拟程序员大脑开始意识到这仍然只是<code class="fe nf ng nh ni b">width <strong class="kh ir">+</strong> height</code>处理时间。</p><p id="5870" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谁在乎浪费一堆处理<em class="lo">努力</em>当它节省那么多<em class="lo">时间</em>！？</p><p id="45b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我肯定会提高效率，但与不必要地评估单元直到整个矩阵被求解的速度增加相比，这是微不足道的。</p><p id="e40a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦接受了这种情况，就有理由创建GPU函数(或“内核”)<code class="fe nf ng nh ni b">smithwaterman</code>，它可以求解单个二维矩阵单元<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L528-586" rel="noopener ugc nofollow" target="_blank">webgl:528</a>]</code>。还创建了一个初始化程序，用于计算初始匹配值<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L687-710" rel="noopener ugc nofollow" target="_blank">webgl:687</a>]</code>。</p><p id="04c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先要注意的是整个程序作为<code class="fe nf ng nh ni b">string</code>传递给<code class="fe nf ng nh ni b">addProgram </code>。这是为了让GPU编译代码，但不幸的是，这意味着没有语法高亮显示。它还会导致关于无效语法的非常隐晦的消息。建议您在进行更改时，尽量小一些，以确保您可以识别出语法错误发生的位置。</p><p id="c4b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">算法本身在实现上非常小…</p><h2 id="8521" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">初始化存储器</h2><p id="7dea" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在我们开始处理值之前，我们需要将值传输到GPU。当<code class="fe nf ng nh ni b">addProgram</code>用于将代码写入GPU时，写入内存由<code class="fe nf ng nh ni b">write</code>函数执行。我们首先获取一个适当大小的数组，然后只填充数组<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L735-744" rel="noopener ugc nofollow" target="_blank">webgl.html:735</a>]</code>的<strong class="kh ir">顶部</strong>和<strong class="kh ir">左侧</strong>部分。这通过将迭代部分留给GPU来最小化CPU周期。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/706f4c9fd3d9b72d611d887912f7354b.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*T7bgJye2U4KlEbVG-jHq6Q.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">The initial Matrix score is done by comparing the extreme North and West values. Matches get a base score of 2 while everything else is set to 0.</figcaption></figure><p id="0bcf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的第一个GPU任务(<code class="fe nf ng nh ni b">initializeSpace</code>)是比较这些匹配值的交集<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L687-710" rel="noopener ugc nofollow" target="_blank">webgl.html:687</a>]</code>。对于每个单元格，我们查找最西边和最北边<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L700-701" rel="noopener ugc nofollow" target="_blank">webgl.html:700</a>]</code>的值，并为匹配分配<code class="fe nf ng nh ni b">2</code>点，为不匹配分配<code class="fe nf ng nh ni b">0</code>点<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L707" rel="noopener ugc nofollow" target="_blank">webgl.html:707</a>]</code>。该分数存储在<code class="fe nf ng nh ni b">red</code>通道中。</p><p id="2609" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是，GPU是根据分数值(<code class="fe nf ng nh ni b">float</code>)进行处理的:一切都是1的一部分。因此，虽然分数是整数值<code class="fe nf ng nh ni b">0</code>和<code class="fe nf ng nh ni b">2</code>，但它们必须按比例消耗。这些值实际上是作为<code class="fe nf ng nh ni b">0.0/255.0</code>和<code class="fe nf ng nh ni b">2.0/255.0</code>传递给函数的，这使得它们很容易在<code class="fe nf ng nh ni b">UInt8</code>和<code class="fe nf ng nh ni b">float</code>之间转换。</p><p id="2c55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一件需要记住的重要事情。出于该算法的目的:</p><p id="4c12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lo">一切GPU端都是把数字当做浮点数，但是返回的内存是整数。</em></p><h2 id="67e0" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">求解矩阵</h2><p id="9b6e" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">Smith-Waterman构建了一个代表“最佳”匹配的价值链。在这种情况下，“最佳”被定义为具有最高运行分数的邻居。</p><p id="5d84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步是查找最近的邻居，这需要我们确定这些邻居有多近。GPU是按照分数值来思考的(<code class="fe nf ng nh ni b">float</code>)，而我们是按照离散值来思考的(<code class="fe nf ng nh ni b">int</code>)。我们需要计算一个内存位置(一个像素)的分数大小<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L544" rel="noopener ugc nofollow" target="_blank">webgl.html:544</a>]</code>。完成后，我们可以查找当前单元格的值(<code class="fe nf ng nh ni b">here</code>)及其最近的邻居(<code class="fe nf ng nh ni b">nw</code>、<code class="fe nf ng nh ni b">n</code>、<code class="fe nf ng nh ni b">w</code> ) <code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L548-551" rel="noopener ugc nofollow" target="_blank">webgl.html:548</a>]</code>)。</p><p id="7ed7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们确定了重要的邻国，我们就可以开始评估它们的价值。这是通过检查所有三个来查看哪个分数最高，并将其临时存储在<code class="fe nf ng nh ni b">blue</code>通道<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L562-565" rel="noopener ugc nofollow" target="_blank">webgl.html:562</a>]</code>上来完成的。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/4df43708ae85100831bf76a0222d83ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*QG-Mse_W0EXeoxrUqcKY5A.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Looking at the nearest neighbours (yellow) we can determine the direction of the match. In this case horizontal (127) is the best match. Values are stored as fractions of 255 (255/2 → 127).</figcaption></figure><p id="0bbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">知道哪个分数最高，允许我们确定哪个方向形成了链；对每个方向进行测试，看它是否形成所需的链。在分数相等的情况下，应该优先选择对角线比赛，因为水平和垂直比赛代表一个跳跃；水平和垂直关系可以任意解决。方向性由<code class="fe nf ng nh ni b">1-north</code>、<code class="fe nf ng nh ni b">2-west</code>、<code class="fe nf ng nh ni b">3-northwest</code>的枚举表示，存储在<code class="fe nf ng nh ni b">blue</code>通道<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L568-576" rel="noopener ugc nofollow" target="_blank">webgl.html:568</a>]</code>上。</p><p id="593e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">知道了链条的方向，我们现在可以计算出运行总数。链的运行分数被添加到本地匹配分数；从逻辑上讲，这是在记录方向之后进行的，但是，由于每个单元只有4个存储位置，所以在我们最终确定方向<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L565" rel="noopener ugc nofollow" target="_blank">webgl.html:565</a>]</code>之前，从<code class="fe nf ng nh ni b">blue </code>通道上存储的临时值中提取。我们还对必须执行跳过操作(非对角线方向)<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L579" rel="noopener ugc nofollow" target="_blank">webgl.html:579</a>]</code>的链应用“跳过”惩罚(-1分)。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/153e8b7f70c085cd039a6c5997b612d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*PD-i5mS9rWSZWT-wra5HPA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Having identified the parent, we can add the running score, to the local score, and apply any skip penalties. In this case (<code class="fe nf ng nh ni b">2+2-1</code>), which then gets stored on the current alpha channel.</figcaption></figure><p id="a62a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦计算完成，这些值将永久保存在<code class="fe nf ng nh ni b">alpha</code>通道<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L584" rel="noopener ugc nofollow" target="_blank">webgl.html:584</a>]</code>的当前单元格中。值得回顾的是，每个单元有4个存储单元，以及我们是如何分配它们的:</p><ul class=""><li id="52b9" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la pa oa ob oc bi translated"><code class="fe nf ng nh ni b">red</code>:本地匹配分数</li><li id="ec4d" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la pa oa ob oc bi translated"><code class="fe nf ng nh ni b">green</code>:未使用(留作将来使用)</li><li id="a484" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la pa oa ob oc bi translated"><code class="fe nf ng nh ni b">blue</code>:链条方向</li><li id="0f21" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la pa oa ob oc bi translated"><code class="fe nf ng nh ni b">alpha</code>:连锁评分</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d0ae1b218c982c3a866041afe756c8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/1*XjM2Wnbo0SqbpQ_e7RRkhA.gif"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">This diagram shows the calculation wave as it moves across the matrix. Green values represent cells with sufficient information to solve, yellow values represent values that have settled into their final state, and white values are ones that are indeterminate. Every cell is calculated on every cycle. Using this pattern, we can reduce the number of required cycles from `<code class="fe nf ng nh ni b">x*y</code>` to `<code class="fe nf ng nh ni b">x+y</code>`.</figcaption></figure><p id="024e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，只执行一次这个过程是不够的。当我们计算每个单元的链分数时，没有足够的信息供最后一个单元完成其链计算，直到它的邻居完成其计算。为了解决这个问题，我们多次运行GPU处理:首先计算所需的最坏情况周期数<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L518" rel="noopener ugc nofollow" target="_blank">webgl.html:518</a>]</code>，然后向GPU a循环发送处理信号<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L752-755" rel="noopener ugc nofollow" target="_blank">webgl.html:752</a>]</code>。GPU处理的每一次迭代都将已完成计算的“浪潮”向前推进一步。</p><p id="6c39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦这个循环完成，并且这个波的尖端到达我们矩阵的右下角，计算的第一阶段就完成了。最重要的是，它是在<code class="fe nf ng nh ni b">x+y</code>个周期内完成的，而不是<code class="fe nf ng nh ni b">x*y</code>个周期。虽然测试样本太小，无法获取准确读数(在大多数浏览器中分辨率为1毫秒)，但<code class="fe nf ng nh ni b">animals</code>样本从10毫秒增加到1毫秒以下，而<code class="fe nf ng nh ni b">lorem</code>样本从5.5秒增加到1毫秒左右，没有为<code class="fe nf ng nh ni b">identical</code>、<code class="fe nf ng nh ni b">longchain</code>或<code class="fe nf ng nh ni b">gilbertsulivan</code> <code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L477-501" rel="noopener ugc nofollow" target="_blank">webgl.html:477</a>]</code>获取初始读数。</p><p id="b333" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使考虑到显著的测量误差，这也是一个显著的进步！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/90c87e332314c294dd894b965480a0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/1*Hi4x81f5wMY-QM-gOSMO9g.gif"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">We can see a significant improvement in speed in just the first 30 seconds of processing.</figcaption></figure><h1 id="459f" class="nj mi iq bd mj nk nl nm mm nn no np mp jw nq jx ms jz nr ka mv kc ns kd my nt bi translated">结论</h1><p id="dfac" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我再也找不到来源了，但是网络上对图形处理器最好的浏览之一来自一个会议谈话的视频</p><blockquote class="pd"><p id="761b" class="pe pf iq bd pg ph pi pj pk pl pm la dk translated">如果你觉得这是一个肮脏的黑客攻击，那是因为它是。</p><p id="c720" class="pe pf iq bd pg ph pi pj pk pl pm la dk translated">—如果您知道该视频，请留言</p></blockquote><p id="759d" class="pw-post-body-paragraph kf kg iq kh b ki pn jr kk kl po ju kn ko pp kq kr ks pq ku kv kw pr ky kz la ij bi translated">其中一些肯定有肮脏黑客的感觉，例如，在所有提及<code class="fe nf ng nh ni b">RGBA</code>的地方工作感觉很奇怪。WebGL是为图形设计的，而不是计算。对于喜欢冒险的人来说，这给了他们一种兴奋和挑战的感觉。</p><p id="fd7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现这让我回到了我在“c”工作的(非常短暂的)日子，那里的记忆操作更近了一点。符合<code class="fe nf ng nh ni b">vec4</code>记忆(<code class="fe nf ng nh ni b">rgba</code>)真的会鼓励你想出新的方法来使用(和滥用)你使用记忆的方式，或者重新使用记忆，或者将多余的<code class="fe nf ng nh ni b">bit</code>信息压缩到未完全使用的<code class="fe nf ng nh ni b">byte</code>中(其中大部分已经被重构出例子)。</p><p id="8928" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然几十年来我一直喜欢康威的生活游戏，但我从未想过我会为细胞自动机找到一个实用的目的。注意到这个问题和GoL之间的相似性后，我现在想重温一次在JavaScript中实现雾化颗粒分散模型的个人尝试(我的已经不见了，<a class="ae lb" href="https://omrelli.ug/smoke.js/" rel="noopener ugc nofollow" target="_blank">这个非常酷</a>)。</p><p id="f6da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，对我来说，最有教育意义的部分是铅笔和网格纸的价值。很多调试都围绕着用铅笔求解网格，然后将手工求解的矩阵与程序的解进行比较。</p><p id="95c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用手解决史密斯-沃特曼问题也像做一个巨大的数独或填字游戏……有点好玩。</p><h1 id="24f2" class="nj mi iq bd mj nk nl nm mm nn no np mp jw nq jx ms jz nr ka mv kc ns kd my nt bi translated">下一步</h1><ol class=""><li id="e30a" class="nu nv iq kh b ki na kl nb ko ps ks pt kw pu la nz oa ob oc bi translated">在浏览器中打开</li><li id="1cdb" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">点击<code class="fe nf ng nh ni b">F12</code></li><li id="7f82" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">插入断点</li><li id="9974" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">开始逐句通过代码</li></ol><p id="c13a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我实际上建议先保存一个本地副本，以便您可以做一些小的更改来查看效果。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="pv pw l"/></div></figure><p id="2a47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在GPU上实现该算法，我看到了显著的性能提升:速度提高了大约5000倍。然而，我越是思考这个问题，我就越能找到改进的方法。</p><p id="20e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面…</p><p id="f345" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个工具是作为满足个人需求的个人实用工具编写的。在人们对<a class="ae lb" href="https://jefferey-cave.gitlab.io/miss/" rel="noopener ugc nofollow" target="_blank"> M.I.S.S. </a>更感兴趣之前，很可能没有理由实现性能提升。</p><p id="6c37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这已经够快了……就目前而言。</p><h2 id="e205" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">环</h2><p id="0a78" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">我怀疑我在循环中调用<code class="fe nf ng nh ni b">run</code>是低效的。很可能，将循环作为GPU代码的一部分来实现会更好。但是，有两个原因我没有这样做:</p><ol class=""><li id="3a93" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">当前的实现允许定期读取数据，允许可视化的进度条(橙色连接器)。</li><li id="b393" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">输入和输出内存是在执行之前声明的。在辅助函数中，每次运行后，输入内存和输出内存都会交换。我不知道如何在单次执行的情况下做到这一点。</li></ol><p id="866b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些问题似乎都不是不可克服的。</p><h2 id="9073" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">链式分辨率</h2><p id="08e7" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">史密斯-沃特曼呼吁分两个阶段</p><ol class=""><li id="137d" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">建造锁链</li><li id="4d18" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la nz oa ob oc bi translated">解开锁链</li></ol><p id="816f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章有意忽略了史密斯-沃特曼的第二阶段；从内存中读取链的代码。M.I.S.S .中的当前实现使用纯CPU JavaScript来解析链。然而，最近在办公室的一次讨论让我重新思考这是如何做到的，并启发我重写链解析函数以更多地使用GPU。</p><p id="7193" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我鼓励读者看看GPU函数<code class="fe nf ng nh ni b">chain</code> <code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L588-685" rel="noopener ugc nofollow" target="_blank">webgl.html:588</a>]</code>来看看它的实现。它使用了与已经讨论过的<code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/webgl.html#L763-768" rel="noopener ugc nofollow" target="_blank">webgl.html:763</a>]</code>非常相似的技术。</p><h2 id="c072" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">内存消耗</h2><p id="97c8" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">在内存中建立一个二维矩阵意味着<code class="fe nf ng nh ni b">height</code> <strong class="kh ir">乘以</strong> <code class="fe nf ng nh ni b">width</code>。这将取决于你的投入而快速增长。此外，随着令牌数量的增长，代表它们的数字有超过65535 (2字节)的风险。</p><p id="3163" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对代码进行的最初验证测试之一是对<code class="fe nf ng nh ni b"><a class="ae lb" href="https://www.ncbi.nlm.nih.gov/nuccore/CU651637.1?report=fasta" rel="noopener ugc nofollow" target="_blank">E.Coli</a></code>和<code class="fe nf ng nh ni b"><a class="ae lb" href="https://www.ncbi.nlm.nih.gov/nuccore/AE009952.1?report=fasta" rel="noopener ugc nofollow" target="_blank">Y.Pestarius</a></code> <code class="fe nf ng nh ni b">[<a class="ae lb" href="https://gitlab.com/jefferey-cave/miss/blob/medium-practicalwebgl/www/samples/bigcompares.zip" rel="noopener ugc nofollow" target="_blank">bigcompares.zip</a>]</code>的基因组进行比较。不幸的是，这消耗了内存，8TB的阵列超出了我的笔记本电脑的能力。</p><p id="0e85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很想看到一个实现，将巨大的矩阵切割成一系列更小的<em class="lo"/><code class="fe nf ng nh ni b">16000x16000</code><code class="fe nf ng nh ni b">2GB</code>？).这将确保它们永远不会消耗超过可用的内存，并且永远不会生成大于2字节的令牌标识符。</p><p id="d649" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于给定的区块，令牌可以被映射到不超过<code class="fe nf ng nh ni b">UInt16</code>的索引。瓷砖可以独立解决(并行，如果你有一个以上的GPU)，只存储他们的内部链和边缘。在链解析过程中，边可以被“缝合”在一起。</p><p id="2f46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个有趣的想法，我很乐意看到有人来执行它…</p><h1 id="72c4" class="nj mi iq bd mj nk nl nm mm nn no np mp jw nq jx ms jz nr ka mv kc ns kd my nt bi translated">进一步阅读</h1><p id="5b5e" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">不幸的是，这大部分是在大约2年前作为个人项目完成的，所以我使用的许多参考资料和教程已经消失在时间的迷雾中(在我的例子中，“时间的迷雾”大约是20分钟)</p><h2 id="02e2" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">助手功能</h2><p id="b856" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">如果这是你想要扩展的，我强烈建议你研究一下我的助手函数。有很多…事情…正在进行</p><h2 id="3b91" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">史密斯-沃特曼公司</h2><p id="ee3e" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">最初，我只是尝试了Java实现的一个端口。不幸的是(或者幸运的是)，我移植的努力，加上我缺乏理解，导致了非功能性代码的混乱。调试的努力创造了我的理解，但导致的东西看起来一点也不像开始时的样子。</p><ul class=""><li id="c286" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la pa oa ob oc bi translated">GitHub: <a class="ae lb" href="https://github.com/Checksims/checksims" rel="noopener ugc nofollow" target="_blank"> CheckSims </a></li></ul><p id="df01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的大部分知识来自于简单地浏览维基百科上给出的例子，以及我自己的例子。</p><ul class=""><li id="fdd1" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la pa oa ob oc bi translated">维基百科:<a class="ae lb" href="https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm" rel="noopener ugc nofollow" target="_blank">史密斯-沃特曼</a></li><li id="dd3e" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la pa oa ob oc bi translated">维基百科:<a class="ae lb" href="https://en.wikipedia.org/wiki/Cellular_automaton" rel="noopener ugc nofollow" target="_blank">康威的人生游戏</a></li></ul><p id="fd1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过用PoJS(普通的旧JavaScript)编写代码来理解算法，而不增加GPU的复杂性。现在，我更好地理解了GPU，我认为这将是更容易的解决方案…马后炮是20/20，所以谁真的知道。</p><h2 id="3c5c" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">WebGL</h2><p id="970f" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated"><a class="ae lb" href="https://webglfundamentals.org/" rel="noopener ugc nofollow" target="_blank"> WebGL基础</a>:是我学习如何使用WebGL的主要教程</p><p id="6584" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL" rel="noopener ugc nofollow" target="_blank"> Mozilla Developer Network </a>:是所有与浏览器相关的事实上的标准参考，包括WebGL的教程和通用参考。</p><h2 id="7887" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">图书馆</h2><p id="95b1" class="pw-post-body-paragraph kf kg iq kh b ki na jr kk kl nb ju kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">WebGL相对较新，而<a class="ae lb" href="https://www.khronos.org/webcl/" rel="noopener ugc nofollow" target="_blank"> WebCL </a> (Web计算语言)仍然是一项正在进行中的工作。幸运的是，已经开发了相当多的库来使WebGL在计算上更加友好。</p><ul class=""><li id="b604" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la pa oa ob oc bi translated"><a class="ae lb" href="https://www.tensorflow.org/js" rel="noopener ugc nofollow" target="_blank"> tensorflow.js </a>:谷歌著名的机器学习库…用JavaScript实现</li><li id="d722" class="nu nv iq kh b ki od kl oe ko of ks og kw oh la pa oa ob oc bi translated"><a class="ae lb" href="https://github.com/greggman/twgl.js" rel="noopener ugc nofollow" target="_blank"> TWGL </a> : <code class="fe nf ng nh ni b">psGPU</code>本意是变成<code class="fe nf ng nh ni b">TWGL</code>是什么。如果我要再次解决这个问题，我会使用这个库。</li></ul><p id="2e78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lo">更多内容请看</em><a class="ae lb" href="http://plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lo">plain English . io</em></strong></a></p></div></div>    
</body>
</html>