<html>
<head>
<title>Securing Express.js API Using JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JWT保护Express.js API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/securing-express-js-api-using-jwt-b2834325d2e8?source=collection_archive---------1-----------------------#2020-12-01">https://javascript.plainenglish.io/securing-express-js-api-using-jwt-b2834325d2e8?source=collection_archive---------1-----------------------#2020-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3ec26dd54efdf2db7ef0af2e67374a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtptE2Pyu9W_2i6UPslSBA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Express.js — JWT Authentication</figcaption></figure><p id="c99e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这篇文章中，我将展示如何使用<strong class="kb io"> jsonwebtoken </strong>将JWT认证集成到Express.js应用程序中。</p><h1 id="105b" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="d262" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">我们需要保护用户的数据不被擅自更改或显示。有许多类型的认证。我们通常使用JWT认证来保护web APIs。这种方法最适合web APIs。它不需要在客户机上存储cookies，也不需要在服务器上存储会话。这是一种无状态的资源授权方式。实现起来超级简单。在众多方法中，它是非常流行的web APIs认证方法。</p><p id="744e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有很多关于这个话题的文章。我将尽量减少这个话题，并展示一些安全方面的最佳实践，比如散列密码。<a class="ae ma" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> Jsonwebtoken </strong> </a>是一个可以生成JWT令牌并进行验证的NPM包。我们还使用<a class="ae ma" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> bcrypt </strong> </a>包来散列密码，然后将其保存在DB中。它保护密码不被数据库管理员显示。</p><h1 id="2186" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是JWT？</h1><blockquote class="mb mc md"><p id="12a7" class="jz ka me kb b kc kd ke kf kg kh ki kj mf kl km kn mg kp kq kr mh kt ku kv kw ig bi translated">JSON Web令牌是一种开放的行业标准<a class="ae ma" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> RFC 7519 </strong> </a>方法，用于在双方之间安全地表示声明— <a class="ae ma" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> https://jwt.io </a></p></blockquote><p id="dfc9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在现实世界的应用程序中，会有许多web APIs来读取或写入资源。我们需要授权一些人做某些动作。如果一个未经授权的人试图进行授权的操作，那么在响应中将会收到一个<strong class="kb io"> 401 </strong> http状态代码。</p><p id="f7aa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们用一个例子来证明这一点。首先，让我们考虑我们有一个资源用户。下图显示了JWT认证演示的步骤；</p><ul class=""><li id="a436" class="mi mj in kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">首先，我们尝试在没有任何身份验证的情况下获取用户并显示。API返回未授权，状态码为<strong class="kb io"> 401 </strong>。</li><li id="3c23" class="mi mj in kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">然后，我们尝试登录并接收应用程序生成的JWT令牌</li><li id="388d" class="mi mj in kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">最后，令牌可用于<strong class="kb io">验证</strong>授权的API并显示用户。</li></ul><figure class="mx my mz na gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ebfddcb85875290b21862e915c6d41c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*NZwu5mB2MhfEiJevK3kFUw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Diagram/ demonstrating JWT authentication</figcaption></figure><h2 id="8c55" class="nb ky in bd kz nc nd dn ld ne nf dp lh kk ng nh ll ko ni nj lp ks nk nl lt nm bi translated">授权API</h2><p id="35ee" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">有许多方法可以授权应用程序资源。一个简单的方法是创建一个中间件，注入任何需要授权的express.js路由。</p><p id="15ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们考虑我们的例子，资源<strong class="kb io"> <em class="me">获取/用户</em> </strong> <em class="me">。</em>我们需要检索存储在数据库中的用户列表，只有授权用户才能检索。</p><ul class=""><li id="bdf7" class="mi mj in kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">中间件检查包含JWT令牌的请求头中的授权。</li><li id="4c60" class="mi mj in kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">它使用<a class="ae ma" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"><strong class="kb io">jsonwebtoken</strong></a><strong class="kb io"/>库验证令牌。</li></ul><pre class="mx my mz na gt nn no np nq aw nr bi"><span id="3f47" class="nb ky in no b gy ns nt l nu nv">const authenticateMiddleware = (req, res, next) =&gt; {<br/>  const { authorization } = req.headers;<br/>  const token = authorization &amp;&amp; authorization.split(" ")[1];<br/>  if (token == null) return res.sendStatus(401);<br/>  jwt.verify(token, SECRET_KEY, (err, user) =&gt; {<br/>    if (err) return res.sendStatus(403);<br/>    req.user = user;<br/>    next();<br/>   });<br/>};</span></pre><ul class=""><li id="99df" class="mi mj in kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">该中间件可以通过<strong class="kb io"> Express.js </strong>应用的任意路径注入<strong class="kb io">。</strong></li></ul><pre class="mx my mz na gt nn no np nq aw nr bi"><span id="6511" class="nb ky in no b gy ns nt l nu nv">app.get("/api/users", authenticateMiddleware, async (req, res) =&gt; {<br/>  const { id } = req.params;<br/>  const { title, content } = req.body;<br/>  var blog = await User.find({});<br/>  res.json({<br/>    success: true,<br/>    blog,<br/>  });<br/>});</span></pre><p id="b8e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，如果我们尝试获取没有令牌的API或带有无效令牌的事件，我们会收到<strong class="kb io">未授权的</strong> <strong class="kb io"> 401 </strong>。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/214e57ac654888792da3ebc28b5595bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WAwjHzlQKOArKy-7OIgi6A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd nx">Fetching an Authorized Resource</strong></figcaption></figure><h2 id="4fbf" class="nb ky in bd kz nc nd dn ld ne nf dp lh kk ng nh ll ko ni nj lp ks nk nl lt nm bi translated">生成JWT令牌</h2><p id="12e4" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">因此，在尝试读取或写入任何授权资源之前，我们需要一个JWT令牌。</p><p id="b5bf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">生成JWT令牌的最简单方法是允许用户向服务器发送用户名/密码。服务器根据存储在数据库中的用户验证用户名/密码。最后，如果用户存在于数据库中，应用程序会生成一个令牌并将其发送给客户端。</p><p id="0464" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最好在保存之前对密码进行哈希处理。这限制了授权的数据库用户只使用哈希登录。<a class="ae ma" href="https://www.npmjs.com/package/bcryptjs" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> bcrypt.js </strong> </a>是一个NPM包，它使我们的应用程序能够对密码进行哈希处理，并将普通密码与哈希后的密码进行比较。</p><pre class="mx my mz na gt nn no np nq aw nr bi"><span id="917b" class="nb ky in no b gy ns nt l nu nv">app.post("/api/user/login", async (req, res) =&gt; {<br/>  const { username, password } = req.body;<br/>  const user = await User.findOne({ username });<br/>  if (user == null) {<br/>    res.sendStatus(401);<br/>    return;<br/>  }<br/>  bcrypt.compare(password, user.hash, (err, result) =&gt; {<br/>    if (err) res.sendStatus(401);<br/>    else if (!result) res.sendStatus(401);<br/>    else {<br/>      jwt.sign({ id: user._id }, SECRET_KEY, (err, token) =&gt; {<br/>        if (err) res.sendStatus(500);<br/>        else res.json({<br/>          success: true,<br/>          user: { username: user.username },<br/>          token,<br/>        });<br/>      });<br/>    }<br/>  });<br/>});</span></pre><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/fbf79de877de42c946e4d984b4d73922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4FiAfdW-XGuNEK_yBeyKw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><strong class="bd nx">Login</strong></figcaption></figure><h2 id="ea37" class="nb ky in bd kz nc nd dn ld ne nf dp lh kk ng nh ll ko ni nj lp ks nk nl lt nm bi translated">验证请求</h2><p id="774b" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">现在，我们需要在授权标签中选择<strong class="kb io">承载令牌</strong>。用户被检索并显示在请求的正文中。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/e48a45799cc62b0a806a8d11070458a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwYmlVUahDepiiXF9hgicQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Reading an Authorized Resource</figcaption></figure><h1 id="cbb8" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">完整示例</h1><p id="35d4" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">下面是使用JWT授权express.js应用程序的完整示例。在这个例子中，我创建了两个资源<strong class="kb io">用户</strong>和<strong class="kb io">博客</strong>。</p><ul class=""><li id="b28f" class="mi mj in kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated"><strong class="kb io">开机自检:API/用户/登录— </strong>只有该路径未被授权。它被用户用来登录和生成JWT令牌。</li><li id="d08a" class="mi mj in kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">其他路由是授权的，需要在报头中进行授权。</li></ul><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="c15e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="634e" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">这是关于如何使用<a class="ae ma" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> jsonwebtoken </strong> </a>库来保护Express.js应用程序的完整指南。如果你不熟悉Express.js应用程序，我之前已经创建了一个关于<a class="ae ma" href="https://medium.com/javascript-in-plain-english/building-web-api-using-express-js-c0ae69901cf3" rel="noopener"> <strong class="kb io">使用Express.js </strong> </a>创建API的教程。</p><ul class=""><li id="d371" class="mi mj in kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">欢迎您的评论，我将很高兴一起增强代码。</li></ul></div></div>    
</body>
</html>