<html>
<head>
<title>Creating a Map-Based App With NativeScript Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NativeScript Vue创建基于地图的应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-map-based-app-with-nativescript-vue-2880e684e79a?source=collection_archive---------7-----------------------#2020-01-16">https://javascript.plainenglish.io/creating-a-map-based-app-with-nativescript-vue-2880e684e79a?source=collection_archive---------7-----------------------#2020-01-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="930f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着移动设备和通信网络的发展，其最受欢迎的用途之一是基于位置的应用。Nativescript提供了一些插件，这些插件提供了创建现代地图应用程序所需的地图和位置发现工具。在这篇文章中，我将讨论如何使用地图、定位服务和API调用来创建一个Nativescript Vue应用程序，该应用程序将显示当前用户位置的地图，并允许用户搜索附近的地方。</p><h1 id="dc09" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">入门指南</h1><p id="47bb" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">首先，我们将使用CLI创建一个名为ns6maps的新应用程序。当被询问时，选择一个Vue。开始编码的JS空白应用程序模板。一旦完成，我们将添加<a class="ae ll" href="https://github.com/dapriett/nativescript-google-maps-sdk" rel="noopener ugc nofollow" target="_blank">谷歌地图插件</a>，并在模拟器中运行，以确保一切正常。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="5cce" class="lv kj in lr b gy lw lx l ly lz">tns create ns6maps <br/>cd ns6maps <br/>tns doctor <br/>tns plugin add nativescript-google-maps-sdk <br/>tns run ios</span></pre><p id="52a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要一些API密钥来在iOS和Android上使用谷歌地图，所以登录<a class="ae ll" href="https://cloud.google.com/console/google/maps-apis/overview" rel="noopener ugc nofollow" target="_blank">谷歌云平台网站</a>并为你的应用程序创建一个新项目。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/d819e18f89804da8b89b78a0cf21f1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/0*FrRQtyN3Owl5A3U1.png"/></div></figure><p id="77e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在页面顶部选择该项目，您将看到一个屏幕，其中显示了可用于您的项目的所有API</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/8b7897d04d32110274a1e42654cf2ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_loDXt_uzYzjWtV-.png"/></div></div></figure><p id="ae4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先通过点击那个框来启用iOS的地图SDK，它将带你到那个API的概述。点击凭证，然后点击顶部的链接，转到主Google APIs &amp; Services凭证区域，然后点击按钮创建凭证并选择一个API密钥。您将看到一个弹出窗口，显示新创建的密钥，以及一个限制该密钥的链接。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/1805e712fce3e70831225c65999ef5e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/0*nAbl5klhsMlddv2p.png"/></div></figure><p id="eb3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击<code class="fe mk ml mm lr b">Restrict Key</code>链接，选择应用限制下的iOS应用。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mn"><img src="../Images/b0492fc39ac30e529521f562c0673d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*31q1BYlDcbhBJVp2.png"/></div></div></figure><p id="f84b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将需要您的应用捆绑包标识符，因此让我们确保它与您的<code class="fe mk ml mm lr b">package.json</code>中的标识符相匹配。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/04b7be42819e6c279d77bcd829f9f064.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*KbbGj-9EFsMAUbXs.png"/></div></figure><p id="349e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存设置，并记下iOS密钥以备后用。现在，创建另一个API键，按照限制链接，将这个键限制为Android应用程序。对于Android，你需要为用于开发应用的调试键和生产键添加SHA1指纹。如果您还没有一个产品密钥库，请按照<a class="ae ll" href="https://developer.android.com/studio/publish/app-signing#generate-key" rel="noopener ugc nofollow" target="_blank"> Google文档</a>创建一个。对于Linux/OSX系统，可以通过使用<code class="fe mk ml mm lr b">keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android</code>来获取调试指纹，按键限制屏幕的右侧显示了说明，显示了如何获取应用程序调试和生产版本的指纹。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mp"><img src="../Images/6ca806859ef056aeeede9749ed90ede7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tN2VKyLfeP-Suny3.png"/></div></div></figure><p id="ad45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了API键，让我们将它们添加到我们的应用程序中。对于Android，我们将从复制模板配置文件开始，使用:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="77d3" class="lv kj in lr b gy lw lx l ly lz">cp -r node_modules/nativescript-google-maps-sdk/platforms/android/res/values app/App_Resources/Android/src/main/res</span></pre><p id="863b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后编辑<code class="fe mk ml mm lr b">app/App_Resources/Android/src/main/res/values/nativescript_google_maps_api.xml</code>,在用Android Google Maps API键替换占位符后取消对字符串的注释。最后，编辑<code class="fe mk ml mm lr b">app/App_Resources/Android/src/main/AndroidManifest.xml</code>并将以下内容添加到<code class="fe mk ml mm lr b">application</code>标签中:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1cad" class="lv kj in lr b gy lw lx l ly lz">&lt;meta-data android:name="com.google.android.geo.API_KEY" android:value="@string/nativescript_google_maps_api_key" /&gt;</span></pre><p id="decb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于iOS，我们将编辑/app/app.js，并在其他导入之后将以下代码添加到页面顶部，使用之前生成的iOS Google Maps API密钥。我们还将添加代码来注册与Nativescript Vue一起使用的插件，并将该插件作为MapView加载，以便在该应用程序中使用。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e230" class="lv kj in lr b gy lw lx l ly lz">import { isAndroid, isIOS } from "tns-core-modules/platform";<br/>if (isIOS) {<br/>    GMSServices.provideAPIKey('REPLACE_WITH_IOS_KEY');<br/>}<br/>Vue.registerElement('MapView', () =&gt; require('nativescript-google-maps-sdk').MapView);</span></pre><p id="8846" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编辑<code class="fe mk ml mm lr b">Home.vue</code>并将内容替换为:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e38a" class="lv kj in lr b gy lw lx l ly lz">&lt;template&gt;<br/>    &lt;Page actionBarHidden="true" backgroundSpanUnderStatusBar="false"&gt;<br/>        &lt;StackLayout height="100%" width="100%" &gt;<br/>            &lt;MapView iosOverflowSafeArea="true" :latitude="latitude" :longitude="longitude" :zoom="zoom" :bearing="bearing" :tilt="tilt" height="100%" @mapReady="onMapReady" @markerSelect="onMarkerSelect" @markerInfoWindowTapped="onMarkerInfoWindowTapped"&gt;&lt;/MapView&gt;<br/>        &lt;/StackLayout&gt;<br/>    &lt;/Page&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>export default {};<br/>&lt;/script&gt;<br/><br/>&lt;style scoped&gt;<br/>&lt;/style&gt;</span></pre><p id="92d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，我们已经将Map组件包含在StackLayout中，宽度和高度都设置为100%。这样做是为了避免当地图是更复杂的页面布局的一部分时的潜在问题，并确保地图组件全屏显示。我们还将组件的<code class="fe mk ml mm lr b">iosOverflowSafeArea</code>属性设置为true，这样地图将在更大的缺口设备上完全填充屏幕，而不是被限制在安全的矩形屏幕区域。使用<code class="fe mk ml mm lr b">tns run ios</code>运行应用程序，如果一切正常，您应该会看到一幅完整的地图:</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/cb57064d52abfb2ec89ae7d1978b758f.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*O8SWCjHFu4V5djeM.png"/></div></figure><h1 id="5a52" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用Nativescript进行地理定位</h1><p id="ab97" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">如果您查看MapView组件，您会看到我们已经定义了参数，我们将使用这些参数来配置地图的位置和显示。我们现在将添加另一个插件，允许Nativescript请求当前设备位置，然后将这些位置设置为地图的中心坐标。我们还将在地图上显示当前用户的位置以供参考。首先安装<a class="ae ll" href="https://github.com/NativeScript/nativescript-geolocation" rel="noopener ugc nofollow" target="_blank">地理定位插件</a>:</p><p id="f46d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mk ml mm lr b">tns plugin add nativescript-geolocation</code></p><p id="2263" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了访问设备位置，我们需要额外的权限，所以让我们先解决这些问题。由于我们将使用地图，因此我们需要为该应用程序请求精确的位置权限。编辑<code class="fe mk ml mm lr b">app/App_Resources/Android/src/main/AndroidManifest.xml</code>并添加以下权限:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="9df9" class="lv kj in lr b gy lw lx l ly lz">&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;<br/>&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;</span></pre><p id="ac10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编辑<code class="fe mk ml mm lr b">app/App_Resources/iOS/Info.plist</code>并添加以下字符串，以在请求位置许可时显示给用户:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3a8e" class="lv kj in lr b gy lw lx l ly lz">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;<br/>	&lt;string&gt;Find your current location to see places nearby.&lt;/string&gt;<br/>&lt;key&gt;NSLocationUsageDescription&lt;/key&gt;<br/>	&lt;string&gt;Find your current location to see places nearby.&lt;/string&gt;</span></pre><p id="1e39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将用map组件使用的变量填充exports default data部分。我们还将添加<code class="fe mk ml mm lr b">mounted()</code>部分，在那里我们将请求位置许可，然后请求当前位置(如果我们有它们的话)。如果设备返回一个位置，我们将使用用户的当前坐标更新数据变量，这也将使地图重新以该位置为中心。将脚本部分修改为:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="3ec3" class="lv kj in lr b gy lw lx l ly lz">const geolocation = require("nativescript-geolocation");<br/>export default {<br/>    data() {<br/>        return {<br/>            latitude: '',<br/>            longitude: '',<br/>            zoom: '',<br/>            bearing: '',<br/>            tilt: '',<br/>            mapView:null,<br/>        }<br/>    },<br/>    mounted() {<br/>        let that = this<br/>        geolocation.enableLocationRequest(true, true).then(() =&gt; {<br/>            geolocation.isEnabled().then(value =&gt; {<br/>                if (!value) {<br/>                    console.log("NO permissions!");<br/>                    return false;<br/>                } else {<br/>                    console.log("Have location permissions");<br/>                    geolocation<br/>                        .getCurrentLocation({<br/>                            timeout: 20000<br/>                        })<br/>                        .then(location =&gt; {<br/>                            if (!location) {<br/>                                console.log("Failed to get location!");<br/>                            } else {<br/>                                that.latitude = location.latitude<br/>                                that.longitude = location.longitude<br/>                                that.zoom = 14<br/>                                that.bearing = 0<br/>                                that.altitude = 0<br/>                            }<br/><br/>                        });<br/>                    return true;<br/>                }<br/>            });<br/>        })<br/><br/>    },<br/>    methods: {},<br/>}</span></pre><p id="a608" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在iOS模拟器上运行应用程序，允许位置权限，如果您的模拟器设置了默认的旧金山位置，您应该会看到如下内容。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/8d7fb886193f19571f5e8c43ef60b637.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*Q1viQln_6lPnisnu.png"/></div></figure><p id="7633" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们通过显示当前用户位置来改进我们的地图。我们将通过添加一个新函数来配置MapView，一旦地图组件被加载并准备好使用，就会调用这个新函数。将以下函数添加到方法部分:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1266" class="lv kj in lr b gy lw lx l ly lz">    onMapReady(args) {<br/>            this.mapView = args.object;<br/>            this.mapView.myLocationEnabled = true;<br/>            this.mapView.zoomGesturesEnabled = true;<br/>            var gMap = this.mapView.gMap;<br/>            if (isAndroid) {<br/>                uiSettings = gMap.getUiSettings();<br/>                uiSettings.setMyLocationButtonEnabled(true);<br/>                gMap.setMyLocationEnabled(true);<br/>            }<br/>            if (isIOS) {<br/>                gMap.myLocationEnabled = true;<br/>                gMap.settings.myLocationButton = true;<br/>                this.mapView.on("myLocationTapped", event =&gt; {<br/>                    geolocation.isEnabled().then(enabled =&gt; {<br/>                        if (enabled) {<br/>                            geolocation.getCurrentLocation({<br/>                                maximumAge: 5000,<br/>                                timeout: 20000<br/>                            }).then(location =&gt; {<br/>                                gMap.animateToLocation(location);<br/>                            });<br/>                        }<br/>                    });<br/>                });<br/>            }<br/>        },<br/>	onMarkerSelect() {},<br/>        onMarkerInfoWindowTapped() {},</span></pre><p id="16c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦map组件初始化，就会运行<code class="fe mk ml mm lr b">onMapReady</code>函数。首先，我们存储一个对map组件的引用，供以后其他函数使用。然后，我们配置地图以显示当前用户位置，并在每个平台上启用一个浮动位置按钮，用于将地图置于当前用户位置的中心。最后，我们启用指南针按钮的显示以将地图指向北方(仅在用户旋转地图时显示)并允许缩放手势。你会注意到，对于iOS，我们已经添加了一个小的解决方法来修复这个插件的一个错误，这个错误会影响较新的iOS版本，并在点击按钮时阻止地图居中。在模拟器上运行该应用程序，您现在应该会看到一个蓝色的脉冲点，显示您设备的当前位置，以及用于将地图置于该位置中心的浮动按钮。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/23533246507bf54f7f3242749b4ef6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/0*Eu_WywU8NAZnQ0RG.png"/></div></figure><p id="89dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">立即在Android模拟器上运行该应用程序。你可能会遇到一些问题，这些问题会使地图插件挂起或崩溃。为了避免此插件在Android上的一个常见问题，您应该在<code class="fe mk ml mm lr b">app/App_Resources/Android/before-plugins.gradle</code>文件中设置Google Play服务的版本(如果该文件不存在，只需创建它):</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="8749" class="lv kj in lr b gy lw lx l ly lz">android { <br/>    project.ext { googlePlayServicesVersion = "16.+" } <br/>}</span></pre><p id="8d94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦准备好了，你会在Android上遇到另一个问题，当你试图显示当前用户的位置，而在<code class="fe mk ml mm lr b">onMapReady()</code>中没有一个位置的许可时。为了避免这种情况，我们将使用一个在<code class="fe mk ml mm lr b">mounted()</code>中解决权限状态后设置的标志<code class="fe mk ml mm lr b">isMounted</code>，并且只有在用户授予位置权限并且MapView已经初始化后才启用Android上的当前位置设置。这种方法可能会导致一种竞争情况，因为我们期望地图插件在<code class="fe mk ml mm lr b">mounted()</code>中的权限检查之前完成加载，否则，按钮可能不会被启用和显示。为了避免这种情况，我们还将检查<code class="fe mk ml mm lr b">mapView</code>变量是否已经在<code class="fe mk ml mm lr b">mounted()</code>中赋值，并且在这里启用该设置之前权限检查是否已经完成。在一个更现实的应用程序中，你可能会用一个加载器或<code class="fe mk ml mm lr b">v-if</code>隐藏地图屏幕，直到其他一切准备就绪，地图可以开始初始化。更新<code class="fe mk ml mm lr b">default</code>部分，使其包含以下更改:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e542" class="lv kj in lr b gy lw lx l ly lz">    data() {<br/>        return {<br/>            latitude: '',<br/>            longitude: '',<br/>            zoom: '',<br/>            bearing: '',<br/>            tilt: '',<br/>            mapView: null,<br/>            isMounted: false<br/>        }<br/>    },<br/>    mounted() {<br/>        let that = this<br/>        geolocation.isEnabled().then(function(isEnabled) {<br/>            if (!isEnabled) {<br/>                geolocation.enableLocationRequest(true, true).then(() =&gt; {<br/>                    that.isMounted = true<br/>                    if (isAndroid &amp;&amp; that.mapView) {<br/>                        let uiSettings = that.mapView.gMap.getUiSettings();<br/>                        uiSettings.setMyLocationButtonEnabled(true);<br/>                        that.mapView.gMap.setMyLocationEnabled(true);<br/>                    }<br/>                    geolocation<br/>                        .getCurrentLocation({<br/>                            timeout: 20000<br/>                        })<br/>                        .then(location =&gt; {<br/>                            if (!location) {<br/>                                console.log("Failed to get location!");<br/>                            } else {<br/>                                that.latitude = location.latitude<br/>                                that.longitude = location.longitude<br/>                                that.zoom = 14<br/>                                that.bearing = 0<br/>                                that.altitude = 0<br/>                            }<br/><br/>                        });<br/>                }, (e) =&gt; {<br/>                    console.log("Error: " + (e.message || e));<br/>                }).catch(ex =&gt; {<br/>                    console.log("Unable to Enable Location", ex);<br/>                });<br/>            } else {<br/>                that.isMounted = true<br/>                if (isAndroid &amp;&amp; that.mapView) {<br/>                    let uiSettings = that.mapView.gMap.getUiSettings();<br/>                    uiSettings.setMyLocationButtonEnabled(true);<br/>                    that.mapView.gMap.setMyLocationEnabled(true);<br/>                }<br/>                geolocation<br/>                    .getCurrentLocation({<br/>                        timeout: 20000<br/>                    })<br/>                    .then(location =&gt; {<br/>                        if (!location) {<br/>                            console.log("Failed to get location!");<br/>                        } else {<br/>                            that.latitude = location.latitude<br/>                            that.longitude = location.longitude<br/>                            that.zoom = 14<br/>                            that.bearing = 0<br/>                            that.altitude = 0<br/>                        }<br/><br/>                    });<br/><br/>            }<br/>        }, function(e) {<br/>            console.log("Error: " + (e.message || e));<br/>        });<br/><br/>    },<br/>    methods: {<br/>        onMapReady(args) {<br/>            this.mapView = args.object;<br/>            var gMap = this.mapView.gMap;<br/>            this.mapView.settings.myLocationEnabled = true;<br/>            this.mapView.settings.myLocationButtonEnabled = true<br/>            this.mapView.settings.compassEnabled = true<br/>            this.mapView.settings.zoomGesturesEnabled = true;<br/>            if (isAndroid &amp;&amp; this.isMounted &amp;&amp; geolocation.isEnabled()) {<br/>                let uiSettings = gMap.getUiSettings();<br/>                uiSettings.setMyLocationButtonEnabled(true);<br/>                gMap.setMyLocationEnabled(true);<br/>            }<br/>            if (isIOS) {<br/>                gMap.myLocationEnabled = true;<br/>                gMap.settings.myLocationButton = true;<br/>                this.mapView.on("myLocationTapped", event =&gt; {<br/>                    geolocation.isEnabled().then(enabled =&gt; {<br/>                        if (enabled) {<br/>                            geolocation.getCurrentLocation({<br/>                                maximumAge: 5000,<br/>                                timeout: 20000<br/>                            }).then(location =&gt; {<br/>                                gMap.animateToLocation(location);<br/>                            });<br/>                        }<br/>                    });<br/>                });<br/>            }<br/>        },<br/>        onMarkerSelect() {},<br/>        onMarkerInfoWindowTapped() {},<br/>    },</span></pre><p id="77cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Android模拟器上运行该应用程序，您应该会看到类似于以下内容的内容:</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/c56d8b2b07be115d362c8cb2c6eb4458.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*7Acb0GEImlgNkLEF.png"/></div></figure><h1 id="06d0" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">添加地图标记</h1><p id="a621" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们已经有了一张显示我们当前位置的地图，但现在让我们为感兴趣的位置添加标记来使它变得有用。让我们将模拟器中的当前位置设置为美国加利福尼亚州山景城圣安东尼奥路645号的坐标。我们将使用示例地图标记，通过在Google Maps中搜索杂货店找到该位置附近的几个地方，并记下名称和位置信息。将以下导入添加到脚本部分的顶部:</p><p id="ca30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mk ml mm lr b">const mapsModule = require("nativescript-google-maps-sdk");</code></p><p id="b6c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后添加一个新的数据变量来存储要由我们的应用程序呈现的标记数组:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1e1b" class="lv kj in lr b gy lw lx l ly lz">           markers: [{<br/>                    name: 'Whole Foods',<br/>                    address: '4800 El Camino Real',<br/>                    city: 'Los Altos',<br/>                    state: 'CA',<br/>                    zip: '94022',<br/>                    type: 'Grocery Store',<br/>                    latitude: '37.398933',<br/>                    longitude: '-122.110570',<br/>                },<br/>                {<br/>                    name: 'Trader Joe\'s',<br/>                    address: '590 Showers Dr',<br/>                    city: 'Mountain View',<br/>                    state: 'CA',<br/>                    zip: '94040',<br/>                    type: 'Grocery Store',<br/>                    latitude: '37.402180',<br/>                    longitude: '-122.110888',<br/>                },<br/>                {<br/>                    name: 'Safeway',<br/>                    address: '645 San Antonio Rd',<br/>                    city: 'Mountain View',<br/>                    state: 'CA',<br/>                    zip: '94040',<br/>                    type: 'Grocery Store',<br/>                    latitude: '37.402079',<br/>                    longitude: '-122.111946',<br/>                },<br/>                {<br/>                    name: 'Walmart',<br/>                    address: '600 Showers Dr',<br/>                    city: 'Mountain View',<br/>                    state: 'CA',<br/>                    zip: '94040',<br/>                    type: 'Grocery Store',<br/>                    latitude: '37.400774',<br/>                    longitude: '-122.109642',<br/>                },<br/>            ]</span></pre><p id="00c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们将使用添加到<code class="fe mk ml mm lr b">onMapReady</code>末尾的以下代码添加标记:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="19e3" class="lv kj in lr b gy lw lx l ly lz">           this.markers.forEach(element =&gt; {<br/>                var marker = new mapsModule.Marker();<br/>                marker.position = mapsModule.Position.positionFromLatLng(<br/>                    element.latitude,<br/>                    element.longitude<br/>                );<br/>                marker.title = element.name;<br/>                this.mapView.addMarker(marker);<br/>            })</span></pre><p id="c3ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果您运行该应用程序，您应该会看到类似以下内容:</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9044156f3e9969865c2106aa145e79c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/0*k7HgYujfhc78_PPn.png"/></div></figure><p id="741a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击标记时，地图会以该标记为中心，并显示该标记的标题。我们可以通过弹出一个包含更多信息的窗口来做得更好，就像你通过他们的应用程序或网站使用谷歌地图时得到的那些信息一样。将刚刚添加的代码块替换为:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="b96e" class="lv kj in lr b gy lw lx l ly lz">           this.mapView.infoWindowTemplate = `&lt;StackLayout orientation="vertical" width="240" height="140"  &gt;<br/>        	    &lt;Label text="{{title}}"  marginTop="26" marginLeft="20"    textWrap="true" color="black"  fontSize="18" /&gt;<br/>                &lt;Label text="{{type}}"  marginLeft="20"    textWrap="true" color="gray"  fontSize="12" /&gt;<br/>                &lt;Label text="{{address}}"  marginLeft="20"    textWrap="true" color="gray"  fontSize="14" /&gt;<br/>            &lt;/StackLayout&gt;`;<br/>            this.markers.forEach(element =&gt; {<br/>                var marker = new mapsModule.Marker();<br/>                marker.position = mapsModule.Position.positionFromLatLng(<br/>                    element.latitude,<br/>                    element.longitude<br/>                );<br/>                marker.title = element.name;<br/>                marker.type = element.type<br/>                marker.address = element.address + ' ' + element.city + ',' + element.state + ' ' + element.zip<br/>                this.mapView.addMarker(marker);<br/>            })</span></pre><p id="d479" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们添加了一个用于弹出窗口的XML模板，它引用了我们添加到每个标记对象的属性。您可以在这些弹出窗口中尝试样式化和使用本地图像，如果您想要执行诸如导航到该位置的详细信息页面之类的操作，还可以实现标记点击处理程序。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mv"><img src="../Images/2439c67a94ec00964226adb6488c31ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/0*fec_FUbzk_gt3Yvw.png"/></div></div></figure><h1 id="4ebd" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">带有Google Places的搜索框</h1><p id="987c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">让我们使这个地图更具交互性，并添加一个连接到Google Places的搜索框来查找结果并根据这些结果渲染标记。我们将需要为Google Places获取另一个API密钥，这将需要与Google Maps密钥相同的步骤，除了这一次我们将只生成一个由API限制的仅用于Google Places的密钥，并将其用于两个平台。一旦获得了这个键，就将下面的内容添加到XML部分的<code class="fe mk ml mm lr b">&lt;StackLayout&gt;</code>内和<code class="fe mk ml mm lr b">MapView</code>组件之上:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="c15e" class="lv kj in lr b gy lw lx l ly lz">&lt;SearchBar hint="What are you looking for?" v-model="searchPhrase" @submit="onSubmit" textFieldHintColor="gray" marginTop="20" /&gt;</span></pre><p id="a873" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在页面顶部呈现一个<a class="ae ll" href="https://nativescript-vue.org/en/docs/elements/components/search-bar/" rel="noopener ugc nofollow" target="_blank">搜索栏组件</a>，并将搜索查询绑定到一个新的本地变量<code class="fe mk ml mm lr b">searchPhrase</code>，我们将把它作为<code class="fe mk ml mm lr b">searchPhrase: '',</code>添加到数据导出部分。在脚本部分的顶部添加一个新的导入，这样我们就可以进行HTTP调用:<code class="fe mk ml mm lr b">import * as http from "http";</code>。我们需要建立一个到API服务器的URL请求，其中包含当前用户位置、1000米结果的最大距离、用户提交的搜索查询和受限的Google Places API密钥。在首先移除所有旧标记后，返回的任何结果都将被解析并作为新标记添加到地图上。这将发生在添加到方法部分的新的<code class="fe mk ml mm lr b">onSubmit</code>函数中:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ab52" class="lv kj in lr b gy lw lx l ly lz">      onSubmit() {<br/>            let that = this<br/>            this.mapView.removeAllMarkers()<br/>            let searchurl = "https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=" + this.latitude + "," + this.longitude + "&amp;radius=1000&amp;keyword=" + encodeURI(this.searchPhrase) + "&amp;key=YOUR_API_KEY"<br/>            http<br/>                .request({<br/>                    url: searchurl,<br/>                    method: "GET",<br/>                    timeout: 10000,<br/>                    headers: { "Content-Type": "application/json" }<br/>                })<br/>                .then(function(data) {<br/>                    if (data.statusCode == 200) {<br/>                        let result = JSON.parse(data.content);<br/>                        let results = result.results<br/>                        results.forEach(element =&gt; {<br/>                            var marker = new mapsModule.Marker();<br/>                            marker.position = mapsModule.Position.positionFromLatLng(<br/>                                element.geometry.location.lat,<br/>                                element.geometry.location.lng<br/>                            );<br/>                            marker.title = element.name;<br/>                            marker.type = element.types[0]<br/>                            marker.address = element.vicinity<br/>                            that.mapView.addMarker(marker);<br/>                        })<br/><br/>                    } else {<br/>                        console.log("Error requesting youtube metadata! Returned: ");<br/>                        console.dir(data);<br/>                    }<br/>                })<br/>                .catch(e =&gt; {<br/>                    console.log("Error retreiving youtube metadata");<br/>                    console.error(e);<br/>                });<br/>        },</span></pre><p id="94cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数首先使用当前用户位置、1 km的搜索半径、搜索查询和API键为Google Places API调用构建查询字符串。您可以在此阅读更多关于<a class="ae ll" href="https://developers.google.com/places/web-service/search" rel="noopener ugc nofollow" target="_blank">如何使用和解释此次通话结果的信息。</a>调用完成后，我们将检查有效的状态代码，然后通过创建新标记并将它们添加到地图来处理返回的任何结果。从数据段中删除示例<code class="fe mk ml mm lr b">markers</code>变量数组，并删除在<code class="fe mk ml mm lr b">onMapReady</code>中添加这些示例标记的代码。现在运行代码并搜索“杂货店”,您应该会看到类似这样的内容:</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d5d846ca0855247cadb8c270aa8fec2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/0*trixAiJamrKUlu-d.png"/></div></figure><p id="a167" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，这是可行的，但是如果用户四处移动，那么我们在加载应用程序时获得的初始位置将不再准确。为了确保我们发送当前位置的搜索结果，我们可以在发出查询之前从设备请求当前位置，确保我们将获得当前位置的结果，而不是过去的结果。将<code class="fe mk ml mm lr b">onSubmit</code>功能修改为:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2f74" class="lv kj in lr b gy lw lx l ly lz">     onSubmit() {<br/>            let that = this<br/>            geolocation<br/>                .getCurrentLocation({<br/>                    timeout: 20000<br/>                })<br/>                .then(location =&gt; {<br/>                    if (!location) {<br/>                        console.log("Failed to get location!");<br/>                    } else {<br/>                        that.latitude = location.latitude<br/>                        that.longitude = location.longitude<br/>                        that.mapView.removeAllMarkers()<br/>                        let searchurl = "https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=" + that.latitude + "," + that.longitude + "&amp;radius=1000&amp;keyword=" + encodeURI(that.searchPhrase) + "&amp;key=AIzaSyCnnXo6rqBp4ItB__nC80OyoLDYjxWcxBQ"<br/>                        http<br/>                            .request({<br/>                                url: searchurl,<br/>                                method: "GET",<br/>                                timeout: 10000,<br/>                                headers: { "Content-Type": "application/json" }<br/>                            })<br/>                            .then(function(data) {<br/>                                if (data.statusCode == 200) {<br/>                                    let result = JSON.parse(data.content);<br/>                                    let results = result.results<br/>                                    results.forEach(element =&gt; {<br/>                                        var marker = new mapsModule.Marker();<br/>                                        marker.position = mapsModule.Position.positionFromLatLng(<br/>                                            element.geometry.location.lat,<br/>                                            element.geometry.location.lng<br/>                                        );<br/>                                        marker.title = element.name;<br/>                                        marker.type = element.types[0]<br/>                                        marker.address = element.vicinity<br/>                                        that.mapView.addMarker(marker);<br/>                                    })<br/><br/>                                } else {<br/>                                    console.log("Error getting google places data");<br/>                                    console.dir(data);<br/>                                }<br/>                            })<br/>                            .catch(e =&gt; {<br/>                                console.log("Error getting google places data");<br/>                                console.error(e);<br/>                            });<br/>                    }<br/><br/>                });<br/>        },</span></pre><p id="31ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然这确实可行，但更好的替代方法是使用地理定位插件功能<code class="fe mk ml mm lr b">watchLocation</code>设置一个位置监视器，并在设备位置发生变化时在后台更新应用程序的当前用户位置。</p><h1 id="e7af" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">给地图加边界</h1><p id="25ed" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">您可能想要实现的另一个功能是将地图缩放并居中，以便它适合从搜索结果返回的所有标记。这将需要特定于每个平台的本地调用来从所有标记创建一个新的边界框，然后将其应用到<code class="fe mk ml mm lr b">MapView</code>以将其置于该框的中心。对于Android，一旦所有标记都添加到地图上，我们就可以计算边界框。对于iOS，我们需要在添加所有标记之前、期间和之后执行操作。更新<code class="fe mk ml mm lr b">onSubmit</code>到:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="36d7" class="lv kj in lr b gy lw lx l ly lz">onSubmit() {<br/>            let that = this<br/>            geolocation<br/>                .getCurrentLocation({<br/>                    timeout: 20000<br/>                })<br/>                .then(location =&gt; {<br/>                    if (!location) {<br/>                        console.log("Failed to get location!");<br/>                    } else {<br/>                        that.latitude = location.latitude<br/>                        that.longitude = location.longitude<br/>                        that.mapView.removeAllMarkers()<br/>                        let searchurl = "https://maps.googleapis.com/maps/api/place/nearbysearch/json?location=" + that.latitude + "," + that.longitude + "&amp;radius=1000&amp;keyword=" + encodeURI(that.searchPhrase) + "&amp;key=AIzaSyCnnXo6rqBp4ItB__nC80OyoLDYjxWcxBQ"<br/>                        http<br/>                            .request({<br/>                                url: searchurl,<br/>                                method: "GET",<br/>                                timeout: 10000,<br/>                                headers: { "Content-Type": "application/json" }<br/>                            })<br/>                            .then(function(data) {<br/>                                if (data.statusCode == 200) {<br/>                                    let result = JSON.parse(data.content);<br/>                                    let results = result.results<br/>                                    var bounds<br/>                                    let padding = 100<br/>                                    if (isIOS) {<br/>                                        bounds = GMSCoordinateBounds.alloc().init();<br/>                                    }<br/>                                    results.forEach(element =&gt; {<br/>                                        var marker = new mapsModule.Marker();<br/>                                        marker.position = mapsModule.Position.positionFromLatLng(<br/>                                            element.geometry.location.lat,<br/>                                            element.geometry.location.lng<br/>                                        );<br/>                                        if (isIOS) bounds = bounds.includingCoordinate(marker.position);<br/>                                        marker.title = element.name;<br/>                                        marker.type = element.types[0]<br/>                                        marker.address = element.vicinity<br/>                                        that.mapView.addMarker(marker);<br/>                                    })<br/>                                    if (isAndroid) {<br/>                                        var builder = new com.google.android.gms.maps.model.LatLngBounds.Builder();<br/>                                        that.mapView.findMarker(function(marker) { builder.include(marker.android.getPosition()); });<br/>                                        bounds = builder.build();<br/>                                        var cu = com.google.android.gms.maps.CameraUpdateFactory.newLatLngBounds(bounds, padding);<br/>                                        that.mapView.gMap.animateCamera(cu);<br/>                                    }<br/>                                    if (isIOS) {<br/>                                        var update = GMSCameraUpdate.fitBoundsWithPadding(bounds, padding);<br/>                                        that.mapView.gMap.animateWithCameraUpdate(update);<br/>                                    }<br/>                                } else {<br/>                                    console.log("Error getting google places data");<br/>                                    console.dir(data);<br/>                                }<br/>                            })<br/>                            .catch(e =&gt; {<br/>                                console.log("Error getting google places data");<br/>                                console.error(e);<br/>                            });<br/>                    }<br/><br/>                });<br/>        },</span></pre><h1 id="57d6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">自定义标记图标</h1><p id="3a43" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">除了为每个标记定制弹出窗口，我们还可以更进一步，定制标记本身的外观。我们可以做的最简单的改变是修改标记图标的颜色。为此，我们可以使用<code class="fe mk ml mm lr b">marker.color="COLOR"</code>简单地给每个标记分配一种颜色。让我们将标记添加到地图的循环中，通过将<code class="fe mk ml mm lr b">marker.color="green"</code>添加到<code class="fe mk ml mm lr b">onSubmit</code>来将所有标记更改为绿色而不是红色。现在你的地图和标记应该看起来像:</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4924963e1723950b7240971a6db4b5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/0*MOoTbiTU7jlfVWYp.png"/></div></figure><p id="bef4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用图像几乎同样简单，尽管你必须小心使用的图像大小以及它们在iOS和Android平台上的呈现方式。让我们注释掉标记颜色分配，并添加以下行:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ad06" class="lv kj in lr b gy lw lx l ly lz">// marker.color = "green"<br/>let imageSource = ImageSource.fromFileSync("~/images/foodicon.png");<br/>const icon = new Image();<br/>icon.imageSource = imageSource;<br/>marker.icon = icon;<br/>that.mapView.addMarker(marker);</span></pre><p id="372a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经下载了一个48x48的图标图像，并将其放在<code class="fe mk ml mm lr b">/app/images/</code>目录中。我们还需要一些Nativescript图像库，因此将这些导入添加到脚本部分:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4c5c" class="lv kj in lr b gy lw lx l ly lz">import { ImageSource } from "tns-core-modules/image-source";  <br/>import { Image } from "tns-core-modules/ui/image";</span></pre><p id="4039" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行应用程序，执行搜索，您现在应该有带此图标的标记，而不是默认的大头针标记:</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="gh gi my"><img src="../Images/2caf320443cf79312971ce96c2f2712c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*qC5DWSoI3LVgg3_I.png"/></div></figure><h1 id="9633" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">完成的</h1><p id="ae69" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这个帖子到此为止。如果你想下载最终的源文件，你可以在<a class="ae ll" href="https://github.com/drangelod/ns6maps" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="66a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ng">原载于2020年1月16日https://blog.angelengineering.com</em><a class="ae ll" href="https://blog.angelengineering.com/nativescript-maps/" rel="noopener ugc nofollow" target="_blank"><em class="ng"/></a><em class="ng">。</em></p></div></div>    
</body>
</html>