<html>
<head>
<title>6 Interview Questions That Combine Promise and setTimeout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6个包含承诺和暂停的面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/6-interview-questions-that-combine-promise-and-settimeout-34c430fc297e?source=collection_archive---------0-----------------------#2020-04-29">https://javascript.plainenglish.io/6-interview-questions-that-combine-promise-and-settimeout-34c430fc297e?source=collection_archive---------0-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3d2f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">彻底掌握这种类型的面试问题。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0b925fb5746716fb4d8006da90c074c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bUen12d9Uw37yI-V"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@bharat_patil_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bharat Patil</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，我希望你能弄清楚几个知识点。</p><p id="4031" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件循环按以下顺序执行:</p><ul class=""><li id="1aca" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">JS引擎中有两个任务队列:宏任务队列和微任务队列</li><li id="cfde" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">整个脚本最初作为宏任务执行</li><li id="369f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">执行过程中，同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li><li id="b7ed" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当当前宏任务完成时，检查微任务队列，并依次执行所有的微任务</li><li id="277d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">执行浏览器UI线程的呈现(在本文中可以忽略这一点)</li><li id="c45a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果存在任何Web Worker任务，就执行它(在本文中可以忽略这一点)</li><li id="02ff" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">检查宏任务队列，如果它不为空，返回到步骤2并执行下一个宏任务。</li></ul><p id="fbfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，第四步:当一个宏任务完成后，先依次执行其他所有的微任务，然后执行下一个宏任务。</p><p id="06dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">微任务包括:<code class="fe mg mh mi mj b">MutationObserver</code>、<code class="fe mg mh mi mj b">Promise.then()</code>和<code class="fe mg mh mi mj b">Promise.catch()</code>，其他基于承诺的技术如fetch API、V8垃圾收集过程、节点环境中的<code class="fe mg mh mi mj b">process.nextTick()</code>。</p><p id="a823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">宏任务包括:初始脚本、<code class="fe mg mh mi mj b">setTimeout</code>、<code class="fe mg mh mi mj b">setInterval</code>、<code class="fe mg mh mi mj b">setImmediate</code>、I/O、UI渲染。</p><p id="fd00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，如果你没有完全理解这是怎么回事也没关系，我们用例子来练习一下。</p><p id="b28b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">共有10个问题:前4个是简单的承诺问题，帮助你理解微任务；接下来的6个问题混合了承诺和暂停。</p><h1 id="4638" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">1.</h1><p id="31e7" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">让我们从一个简单的例子开始解释微任务。</p><h2 id="c4f8" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="d4f7" class="nh ml iq mj b gy nx ny l nz oa">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  console.log(1);<br/>  resolve('success')<br/>});</span><span id="d6e4" class="nh ml iq mj b gy ob ny l nz oa">promise1.then(() =&gt; {<br/>  console.log(3);<br/>});</span><span id="26bb" class="nh ml iq mj b gy ob ny l nz oa">console.log(4);</span></pre><h2 id="b19b" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><ul class=""><li id="e69f" class="ls lt iq ky b kz nc lc nd lf oc lj od ln oe lr lx ly lz ma bi translated">首先，执行这段代码的前四行。控制台会打印出<code class="fe mg mh mi mj b">1</code>，然后<code class="fe mg mh mi mj b">promise1</code>会变成<code class="fe mg mh mi mj b">resolved</code>状态。</li><li id="1f9f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">promise1.then(() =&gt; {console.log(3);}); </code>片段。因为<code class="fe mg mh mi mj b">promise1</code>现在处于已解决状态，所以<code class="fe mg mh mi mj b">() =&gt; {console.log(3);}</code>将被立即添加到微任务队列中。</li><li id="d868" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">但是我们知道<code class="fe mg mh mi mj b">() =&gt; {console.log(3);}</code>是一个微任务，所以没有立即调用。</li><li id="5a31" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行最后一行代码(<code class="fe mg mh mi mj b">console.log(4);</code>)，并在控制台中打印<code class="fe mg mh mi mj b">4</code>。</li><li id="b5b3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">此时，所有同步的代码，即当前的宏任务，都被执行。然后JavaScript引擎检查微任务队列并依次执行它们。</li><li id="a988" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">() =&gt; {console.log(3);}</code>,并在控制台中打印<code class="fe mg mh mi mj b">4</code>。</li></ul><h2 id="1581" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/90fe9cc279e2c469f3c6fa6f15ecdd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ro_ohReRC0dYVboGKQbXkw.png"/></div></div></figure><h1 id="b96f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">2.</h1><h2 id="10e7" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="04ce" class="nh ml iq mj b gy nx ny l nz oa">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  console.log(1);<br/>});</span><span id="1190" class="nh ml iq mj b gy ob ny l nz oa">promise1.then(() =&gt; {<br/>  console.log(3);<br/>});</span><span id="7d83" class="nh ml iq mj b gy ob ny l nz oa">console.log(4);</span></pre><h2 id="e366" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><p id="0471" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这个例子和上一个非常相似，除了在这个例子中，<code class="fe mg mh mi mj b">promise1</code>将一直处于<code class="fe mg mh mi mj b">pending</code>状态，所以<code class="fe mg mh mi mj b">() =&gt; {console.log(3);}</code>不会被执行，控制台也不会打印3。</p><h2 id="91a2" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/14b3d77f7ff9bb8a48cfbc13d5627a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16tw9IL2uHtXBeFKdp_mqw.png"/></div></div></figure><h1 id="906f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">3.</h1><h2 id="adde" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="8778" class="nh ml iq mj b gy nx ny l nz oa">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  console.log(1)<br/>  resolve('resolve1')<br/>})</span><span id="c1f5" class="nh ml iq mj b gy ob ny l nz oa">const promise2 = promise1.then(res =&gt; {<br/>  console.log(res)<br/>})</span><span id="678c" class="nh ml iq mj b gy ob ny l nz oa">console.log('promise1:', promise1);<br/>console.log('promise2:', promise2);</span></pre><p id="64df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细考虑控制台打印结果的顺序和每个承诺的状态。</p><h2 id="9b3f" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><ul class=""><li id="9bcf" class="ls lt iq ky b kz nc lc nd lf oc lj od ln oe lr lx ly lz ma bi translated">首先，前四行代码和前面一样，<code class="fe mg mh mi mj b">1</code>打印在控制台中，<code class="fe mg mh mi mj b">promise1</code>的状态是<code class="fe mg mh mi mj b">resolved</code>。</li><li id="8ff6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">const promise2 = promise1.then(...)</code>，将<code class="fe mg mh mi mj b">res =&gt; {console.log(res)}</code>添加到微任务队列中。同时，<code class="fe mg mh mi mj b">promise1.then()</code>会返回一个新的<code class="fe mg mh mi mj b">pending</code>承诺对象。</li><li id="61ae" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">console.log(‘promise1:’, promise1);</code>，控制台打印出解析状态下的字符串<code class="fe mg mh mi mj b">'promise1'</code>和<code class="fe mg mh mi mj b">promise1</code>。</li><li id="3384" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">console.log(‘promise2:’, promise2);</code>，控制台打印出字符串<code class="fe mg mh mi mj b">‘promise2’</code>和挂起状态的<code class="fe mg mh mi mj b">promise2</code>。</li><li id="942c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">此时，所有同步的代码，即当前的宏任务，都被执行。然后JavaScript引擎检查微任务队列并依次执行它们。</li><li id="25bf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">res =&gt; {console.log(res)}</code>是微任务队列中唯一的任务，现在将执行它。然后控制台会打印<code class="fe mg mh mi mj b">'reslove1'</code>。</li></ul><h2 id="c791" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/1c5706425ce80a3d6793bd9b3cc6feb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3y4WjCdNd3T6BNZc04lqAw.png"/></div></div></figure><h1 id="0f62" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">4.</h1><h2 id="f750" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="9544" class="nh ml iq mj b gy nx ny l nz oa">const fn = () =&gt; (new Promise((resolve, reject) =&gt; {<br/>  console.log(1)<br/>  resolve('success')<br/>}));</span><span id="a4a3" class="nh ml iq mj b gy ob ny l nz oa">fn().then(res =&gt; {<br/>  console.log(res)<br/>});</span><span id="5001" class="nh ml iq mj b gy ob ny l nz oa">console.log(2)</span></pre><h2 id="0a5f" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><p id="8962" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">与之前不同，在这个例子中，创建Promise对象的行为发生在<code class="fe mg mh mi mj b">fn</code>函数中。虽然<code class="fe mg mh mi mj b">fn</code>函数是一个普通的同步函数，但它并没有什么特别之处，这个例子仍然很简单。</p><h2 id="5731" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/a0ff6ab15b9f28f053a5ed0547891ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXZ5OKBFV-2MCgPd2MvnsQ.png"/></div></div></figure><p id="587f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oj">前面的例子比较简单，现在问题会逐渐变得复杂，你准备好了吗？</em></p><h1 id="8b9c" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">5.</h1><h2 id="1c01" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="e54c" class="nh ml iq mj b gy nx ny l nz oa">console.log('start')</span><span id="b4a1" class="nh ml iq mj b gy ob ny l nz oa">setTimeout(() =&gt; {<br/>  console.log('setTimeout')<br/>})</span><span id="303f" class="nh ml iq mj b gy ob ny l nz oa">Promise.resolve().then(() =&gt; {<br/>  console.log('resolve')<br/>})</span><span id="ffe8" class="nh ml iq mj b gy ob ny l nz oa">console.log('end')</span></pre><h2 id="9211" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><ul class=""><li id="28aa" class="ls lt iq ky b kz nc lc nd lf oc lj od ln oe lr lx ly lz ma bi translated">首先，JS引擎中有两个任务队列:宏任务队列和微任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/5fd65ceb6f7059748c9df33f2b122b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1WVDRU9iIjfRLBRtNyk0A.png"/></div></div></figure><ul class=""><li id="65e0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在程序开始时，所有的初始代码都被当作一个宏任务，推入宏任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/006c119f44eddfb07484eb79454842a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3OKRAAKSNlq13Wa2PP2cnw.png"/></div></div></figure><ul class=""><li id="a1d4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后执行第一行代码<code class="fe mg mh mi mj b">console.log('start')</code>，并在控制台中打印<code class="fe mg mh mi mj b">‘start’</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/7874a8786f5b7cc99727b545afa906e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qc739Y1Rb9vPTZEl-vaJDg.png"/></div></div></figure><ul class=""><li id="62ba" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">那么<code class="fe mg mh mi mj b">setTimeout(...)</code>就是一个等待时间为0的定时器，会立即执行。正如我们在本文开头提到的，<code class="fe mg mh mi mj b">setTimeout</code>是一个宏任务，所以<code class="fe mg mh mi mj b">setTimeout(...)</code>、<code class="fe mg mh mi mj b">() =&gt; {console.log(‘setTimeout’)}</code>的回调函数不会立即执行，它会被压入宏任务队列，等待以后执行。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/4f4dd2efcaa4c2d1227b4d2355cd2301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BK1euceBTfMKdZF5uo2zSg.png"/></div></div></figure><ul class=""><li id="9bd2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后它开始执行<code class="fe mg mh mi mj b">Promise.resolve().then(…)</code>，并且<code class="fe mg mh mi mj b">() =&gt; {console.log('resolve')}</code>被推入微任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/7e480a59b5e3c7dd3454ddfa5598db5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOCkvHEnZRaH7V7kOWfagA.png"/></div></div></figure><ul class=""><li id="63aa" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">现在执行<code class="fe mg mh mi mj b">console.log(‘end’)</code>，在控制台打印<code class="fe mg mh mi mj b">‘end’</code>，第一个宏任务完成。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/af483fe6adbb300353a37c73faaba089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39UsxNuy1XM9UvemaFwv-A.png"/></div></div></figure><ul class=""><li id="9148" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当一个宏任务完成时，JS引擎首先检查微任务的队列，然后依次执行所有的微任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/11e824d60e8e79de3e1a6bdc061e0e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqELYSf1rlH3k3cvg7KZJg.png"/></div></div></figure><ul class=""><li id="b836" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当微任务队列为空时，JS引擎检查宏任务队列，并开始执行下一个宏任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/f48e59fa9d37f890bc61c0eeffaf0668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RERtHyTfdORz1Fa5NJUfZg.png"/></div></div></figure><p id="fdc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得强调的是，虽然<code class="fe mg mh mi mj b">setTimeout(...)</code>在<code class="fe mg mh mi mj b">Promise.resolve().then(...)</code>之前执行，但是<code class="fe mg mh mi mj b">setTimeout(...)</code>的回调函数仍然在后面执行，因为<code class="fe mg mh mi mj b">setTimeout</code>是一个宏任务。这是新手犯错误最多的地方。</p><p id="1fdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，以上示例代码就是这样运行的。希望我的素描能帮到你。</p><h2 id="4b98" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/6fb7b84bf766f532f75beb7531669ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KT72m-N67UUbho1mznelw.png"/></div></div></figure><h1 id="1311" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">6.</h1><h2 id="983c" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="f4bd" class="nh ml iq mj b gy nx ny l nz oa">const promise = new Promise((resolve, reject) =&gt; {<br/>  console.log(1);<br/>  setTimeout(() =&gt; {<br/>    console.log("timerStart");<br/>    resolve("success");<br/>    console.log("timerEnd");<br/>  }, 0);<br/>  console.log(2);<br/>});</span><span id="1fee" class="nh ml iq mj b gy ob ny l nz oa">promise.then((res) =&gt; {<br/>  console.log(res);<br/>});</span><span id="606b" class="nh ml iq mj b gy ob ny l nz oa">console.log(4);</span></pre><h2 id="9600" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><ul class=""><li id="685e" class="ls lt iq ky b kz nc lc nd lf oc lj od ln oe lr lx ly lz ma bi translated">首先，我们暂时忽略那些回调函数，简化代码:</li></ul><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="d388" class="nh ml iq mj b gy nx ny l nz oa">const promise = new Promise((resolve, reject) =&gt; {<br/>  console.log(1);<br/>  setTimeout(..., 0);<br/>  console.log(2);<br/>});</span><span id="b0c7" class="nh ml iq mj b gy ob ny l nz oa">promise.then(...);</span><span id="9a71" class="nh ml iq mj b gy ob ny l nz oa">console.log(4);</span></pre><ul class=""><li id="3f64" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后我们像以前一样画图。起初，所有的代码都可以被认为是一个宏任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/7f66c288fb2c0d6f8cbede528444843d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BCQvj20HioN9vvHlgXqzw.png"/></div></div></figure><ul class=""><li id="0ec6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">new Promise(...)</code>，然后进入执行器内部执行<code class="fe mg mh mi mj b">console.log(1)</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/167ab76325986751da9ce0c92d0878a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaJS4wxpM_zAPMHm2u-KTQ.png"/></div></div></figure><ul class=""><li id="e92b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">setTimeout(..., 0)</code>。计时器立即结束，其回调函数被推入宏任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/9e169e9dadda7e9fbfb420dc50d2acc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhHWnnZluNQhqgcluCEL-A.png"/></div></div></figure><ul class=""><li id="72f4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">console.log(2)</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/ce9a1daaefaaa10eeca5f997df524088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3JJkPsEtP7PGuxxdN4ZGg.png"/></div></div></figure><ul class=""><li id="6bd6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">现在开始执行<code class="fe mg mh mi mj b">promise.then(…)</code>。因为promise对象仍然处于未决状态，所以它的回调函数还没有被压入微任务队列。也就是说，微任务队列当前仍然是空的。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/143d6daadb7f29144dd459ce5cbed82d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VT2jfcZ3i7hSD23uhb6og.png"/></div></div></figure><ul class=""><li id="e615" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">console.log(4)</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/d047873992430de84f517899d3ef0d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOHXkTJyd-qyv_SYnuBVqA.png"/></div></div></figure><ul class=""><li id="9a73" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">此时，第一个宏任务结束，微任务队列仍然为空，因此JS引擎启动下一个宏任务。</li><li id="bcb3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">console.log(‘timerStart')</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/b22367a4ef4cb210c30ab35e881f82fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAIuwiM8MOPsCDNOMFcFCA.png"/></div></div></figure><ul class=""><li id="5c67" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">现在<code class="fe mg mh mi mj b">resolve()</code>函数被执行，承诺的状态将是<code class="fe mg mh mi mj b">resolved</code>并且<code class="fe mg mh mi mj b">promise.then(…)</code>的回调函数被推入微任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/d15f761b9ec5efacf0546502b3effee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86CYERUzQzcBysK8LrP4Kw.png"/></div></div></figure><ul class=""><li id="6cf8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">console.log(‘timerEnd')</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/ba898ef79b06607b7a704e350f6afcab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAVAqsoafQx86jEdj-rORA.png"/></div></div></figure><ul class=""><li id="a69c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">现在当前的宏任务已经结束，JS引擎再次检查微任务队列，并依次执行它们。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/f4c04025ddf25a5d290bd210a96edb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqHbWwO_c5FrqGT7b7a7yA.png"/></div></div></figure><h2 id="fae7" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/28d30c4dc52fbdaea184c18b7233a8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCkh9GuBYBXXJaCjYcgKmw.png"/></div></div></figure><h1 id="2f80" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">7.</h1><h2 id="0069" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="e66a" class="nh ml iq mj b gy nx ny l nz oa">const timer1 = setTimeout(() =&gt; {<br/>  console.log('timer1');</span><span id="697c" class="nh ml iq mj b gy ob ny l nz oa">const timer3 = setTimeout(() =&gt; { <br/>    console.log('timer3')<br/>  }, 0)<br/>}, 0)</span><span id="b4b1" class="nh ml iq mj b gy ob ny l nz oa">const timer2 = setTimeout(() =&gt; {<br/>  console.log('timer2')<br/>}, 0)</span><span id="ee16" class="nh ml iq mj b gy ob ny l nz oa">console.log('start')</span></pre><h2 id="b119" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><p id="5107" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在这个例子中有三个<code class="fe mg mh mi mj b">setTimeout</code>函数，所以程序累积了三个额外的宏任务。</p><ul class=""><li id="eb0e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">首先，让我们画出初始的宏任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/74fc23952c90f44bad6250c07f928d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*wxUrpum_S6j34O22acxNyA.png"/></div></figure><ul class=""><li id="671b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">timer1</code>对应的<code class="fe mg mh mi mj b">setTimeout(...)</code>。同时，创建一个新的宏任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/7ec22ae6273d0fa91d620477c192d9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYRKdiLJ9YqscFmTk-5CQA.png"/></div></div></figure><ul class=""><li id="bdf8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">timer2</code>对应的<code class="fe mg mh mi mj b">setTimeout</code>。同时，创建了另一个新的宏任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/9fd7fed889ffdcf1ad1baa4d3b92cbf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zQlahWYV4DWzidTFb4c_g.png"/></div></div></figure><ul class=""><li id="065a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">好，现在我们有三个宏观任务，没有微观任务。</li><li id="247d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/f63daae0a9b43b34bc7ea35833d76d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssgn2pQN4m_gObEoG72nNA.png"/></div></div></figure><ul class=""><li id="852c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">既然第一个宏任务及其执行已经完成，并且微任务队列仍然为空，那么JS引擎将开始执行下一个宏任务。</li><li id="8416" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe mg mh mi mj b">console.log('timer1')</code>被执行。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/9b5084fc0db788c02c9594c3339bafe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OmLeFGkBkBhNhu2_rRH6g.png"/></div></div></figure><ul class=""><li id="db3d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后开始执行<code class="fe mg mh mi mj b">timer3</code>对应的<code class="fe mg mh mi mj b">setTimeout(...)</code>。将创建一个新的宏任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/0b2710f64072b0cf6355a5c92d7660a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32dAMIConkCVu43pjOTu0g.png"/></div></div></figure><ul class=""><li id="8570" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/6aa2434f135f09f99241b8c22a06529a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgkqnYWayURL2a4DrXuOGQ.png"/></div></div></figure><ul class=""><li id="b264" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/dc62c30dbbdf6534619f70c38b09fee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SS3CyDJalrgBz1vDW3nnKQ.png"/></div></div></figure><h2 id="1788" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/a8a8528de9bc575cb89ffff443a85e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-7OukV3NOOdcacfUfx-RQ.png"/></div></div></figure><h1 id="945f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">8.</h1><h2 id="508c" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">示例:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="49fd" class="nh ml iq mj b gy nx ny l nz oa">const timer1 = setTimeout(() =&gt; {<br/>  console.log('timer1');<br/>  const promise1 = Promise.resolve().then(() =&gt; {<br/>    console.log('promise1')<br/>  })<br/>}, 0)</span><span id="39b3" class="nh ml iq mj b gy ob ny l nz oa">const timer2 = setTimeout(() =&gt; {<br/>  console.log('timer2')<br/>}, 0)</span><span id="cc60" class="nh ml iq mj b gy ob ny l nz oa">console.log('start')</span></pre><h2 id="6a53" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><p id="cc82" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这个例子与上一个类似，除了我们用一个<code class="fe mg mh mi mj b">Promise.then</code>替换了一个<code class="fe mg mh mi mj b">setTimeout</code>。因为<code class="fe mg mh mi mj b">setTimeout</code>是一个宏任务，而<code class="fe mg mh mi mj b">Promise.then</code>是一个微任务，并且微任务优先于宏任务，所以控制台输出的顺序是不一样的。</p><ul class=""><li id="e1de" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">首先，让我们画出初始任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/dd1b89c01f07bff8c94ba771e6d961f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UY2hLJwe8MgNzqZtZICi_A.png"/></div></div></figure><ul class=""><li id="0fcc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/db799f330a875f39fc0c137f24d489ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cb1sWW4sAIjjgwNgsA70yg.png"/></div></div></figure><ul class=""><li id="9542" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/7c345c596e668a61190f9b8a7af0054f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2wXis_o2dyd5taIWaeUqg.png"/></div></div></figure><ul class=""><li id="181d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/7743e4b5649ef1d3a74b94a1315c4585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcaOfYV94AUxYO6d5oHwBQ.png"/></div></div></figure><ul class=""><li id="fe86" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/f202371e8dbd092e08902cec8fb21c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WDCVrFEEqVFMJwxa-3CYQ.png"/></div></div></figure><ul class=""><li id="f417" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/d7e211189e9c939354ae1c95eb1e8a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSqVP0GIxfG1dghLz4PrdA.png"/></div></div></figure><ul class=""><li id="5e8c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">注意此时<code class="fe mg mh mi mj b">Promise.then()</code>正在创建一个微任务。它的回调函数由JS引擎在下一个宏任务之前执行。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/61ec388a3da9620c749bd582c2bfed9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXzT54AhlpqZEgak2M2BfQ.png"/></div></div></figure><ul class=""><li id="57aa" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后结束。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/23bbca70a738740d5cbc3c2e41456428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nqTmH_uzBeB7RPg26uX-w.png"/></div></div></figure><h2 id="bc25" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/8c4c64ebae8aa2485f68049931306950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGV-0bU-RDhWUTASAVYXyg.png"/></div></div></figure><h1 id="a024" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">9.</h1><h2 id="d0ca" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated"><code class="fe mg mh mi mj b">Example:</code></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="89f4" class="nh ml iq mj b gy nx ny l nz oa">const promise1 = Promise.resolve().then(() =&gt; {<br/>  console.log('promise1');<br/>  const timer2 = setTimeout(() =&gt; {<br/>    console.log('timer2')<br/>  }, 0)<br/>});</span><span id="6033" class="nh ml iq mj b gy ob ny l nz oa">const timer1 = setTimeout(() =&gt; {<br/>  console.log('timer1')<br/>  const promise2 = Promise.resolve().then(() =&gt; {<br/>    console.log('promise2')<br/>  })<br/>}, 0)</span><span id="8373" class="nh ml iq mj b gy ob ny l nz oa">console.log('start');</span></pre><h2 id="04f9" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><p id="789c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在这个例子中，宏任务和微任务是交替创建的，这是一个困难的话题。如果你只是在头脑中思考，那就很容易出错。但是如果你开始和我一起画图表，就很容易找到正确的答案。</p><ul class=""><li id="e0b8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">首先，让我们画出初始的宏任务队列。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/48d6ad7def9334a1564d39cc47c88405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOYAq6gfBqRm9mrJQMhACg.png"/></div></div></figure><ul class=""><li id="e286" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后执行第一段代码，并创建一个微任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/0b9581d0209cadb13d94a1307a8e0300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBHc2noek3IyCLWhydJ4aA.png"/></div></div></figure><ul class=""><li id="8686" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后执行第二段代码，并创建一个宏任务</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/67dcccfd7e7ff5448fc6c12bd5d93cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFbUVwKHox6zvvYMS1FvmA.png"/></div></div></figure><ul class=""><li id="3441" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/c533d27fb15ebad54e9cb1f17fe0a191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGdT45NuteL33nq3t45ktw.png"/></div></div></figure><ul class=""><li id="7dda" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当前宏任务完成，微任务队列中的任务开始。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/4a6f31c3d348b4c202756da1a18fb013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umq1fgcOulr_quFV_ytB1A.png"/></div></div></figure><ul class=""><li id="5855" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后，开始执行与定时器2相关的<code class="fe mg mh mi mj b">setTimeout(...)</code>并创建一个新的宏任务</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/b4573d96e49994397868e8f1abb9c621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GdBUykmwgVhS-wVlEAiPw.png"/></div></div></figure><ul class=""><li id="6cac" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">清除当前微任务队列，并开始下一个宏任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/ba98f3f86e74993d47fc4e42916a476f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1No4Hqn2Mn9a6Nhb0nMB8w.png"/></div></div></figure><ul class=""><li id="1233" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">然后，创建另一个微任务。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/c80696a8b9c7bbf776a67588b2382302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A-SbXDbphGMk0YS-gzpcKw.png"/></div></div></figure><ul class=""><li id="4f70" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当前宏任务已完成。JS引擎再次检查微任务队列，发现队列不为空，并开始区分微任务队列中任务的优先级。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/ffd92f827979759ac14d3b14dd95f907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v2cBmJAYmc5ehOyjv9pfg.png"/></div></div></figure><ul class=""><li id="901a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">最后</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/7952641e1c8c559711d1cd5c6e20a292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dufIUq3gxC0sQWgucNGI8Q.png"/></div></div></figure><h2 id="9ec5" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/8b14bf3dd8f8586005c9d506e3c5d694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBiUZJ-VXqdQFbhT3NjScQ.png"/></div></div></figure><h1 id="7301" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi">10.</h1><h2 id="d751" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated"><code class="fe mg mh mi mj b">Example:</code></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><pre class="kg kh ki kj gt nt mj nu nv aw nw bi"><span id="a76f" class="nh ml iq mj b gy nx ny l nz oa">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  const timer1 = setTimeout(() =&gt; {<br/>    resolve('success')<br/>  }, 1000)<br/>})</span><span id="cd42" class="nh ml iq mj b gy ob ny l nz oa">const promise2 = promise1.then(() =&gt; {<br/>  throw new Error('error!!!')<br/>})</span><span id="f805" class="nh ml iq mj b gy ob ny l nz oa">console.log('promise1', promise1)<br/>console.log('promise2', promise2)</span><span id="4454" class="nh ml iq mj b gy ob ny l nz oa">const timer2 = setTimeout(() =&gt; {<br/>  console.log('promise1', promise1);<br/>  console.log('promise2', promise2);<br/>}, 2000)</span></pre><h2 id="97d2" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">流程分析:</h2><ul class=""><li id="e969" class="ls lt iq ky b kz nc lc nd lf oc lj od ln oe lr lx ly lz ma bi translated">首先，它通过处于待定状态的<code class="fe mg mh mi mj b">new Promise(…)</code>创建了<code class="fe mg mh mi mj b">promise1</code>。还创建了一个延时1秒的定时器。</li><li id="e545" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">const promise2 = promise1.then(...)</code>，因为<code class="fe mg mh mi mj b">promise1</code>当前处于<code class="fe mg mh mi mj b">Pending</code>状态，所以<code class="fe mg mh mi mj b">promise1.then()</code>的回调函数还不会加入到微任务队列中。</li><li id="9641" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">console.log(‘promise1’, promise1)</code>。此时，<code class="fe mg mh mi mj b">promise1</code>还是<code class="fe mg mh mi mj b">Pending</code>。</li><li id="eead" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">console.log(‘promise2’, promise2)</code>。此时，<code class="fe mg mh mi mj b">promise2</code>仍然是<code class="fe mg mh mi mj b">Pending</code>。</li><li id="3fc9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后执行<code class="fe mg mh mi mj b">const timer2 = setTimeout(…)</code>。还创建了一个延时2秒的定时器。</li><li id="8ee9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">1000毫秒后，<code class="fe mg mh mi mj b">timer1</code>完成。然后执行<code class="fe mg mh mi mj b">resolve(‘success’)</code>，并且<code class="fe mg mh mi mj b">promise1</code>变成<code class="fe mg mh mi mj b">resolved</code>。</li><li id="29a8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">调用了<code class="fe mg mh mi mj b">promise1.then(...)</code>的回调函数，执行了<code class="fe mg mh mi mj b">throw new Error(‘error!!!’)</code>。一个错误被抛出，<code class="fe mg mh mi mj b">promise2</code>变成了<code class="fe mg mh mi mj b">reject</code>。</li><li id="6cad" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">又过了1000毫秒，<code class="fe mg mh mi mj b">timer2</code>完成了。<code class="fe mg mh mi mj b">() =&gt; {console.log(‘promise1’, promise1); console.log(‘promise2’, promise2);}</code>被执行。</li></ul><h2 id="fb3a" class="nh ml iq bd mm ni nj dn mq nk nl dp mu lf nm nn mw lj no np my ln nq nr na ns bi translated">结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qa"><img src="../Images/a9eb3947cd22c9213b4ae9193315d285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzX03P9D2h7gnBReOrDG1g.png"/></div></div></figure></div></div>    
</body>
</html>