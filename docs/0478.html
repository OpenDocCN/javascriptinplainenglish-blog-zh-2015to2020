<html>
<head>
<title>How to Test JSON Schema with AJV in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中用AJV测试JSON模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-test-json-schema-with-ajv-in-typescript-bd0361e0c03e?source=collection_archive---------1-----------------------#2019-10-24">https://javascript.plainenglish.io/how-to-test-json-schema-with-ajv-in-typescript-bd0361e0c03e?source=collection_archive---------1-----------------------#2019-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8d8e6a5c1baaeca6cb74b24114818a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6cov08DLkDvTElYxvaarA.png"/></div></div></figure><p id="668b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">如何测试您的请求和响应是否与接口匹配？我初学<code class="fe lf lg lh li b">Jest</code>的时候，只用过<code class="fe lf lg lh li b">toMatchSnapshot</code>。使用<code class="fe lf lg lh li b">toMatchShot</code>，如果没有现有的快照，您可以保留传递到<code class="fe lf lg lh li b">expect</code>中的数据的快照。如果有，那么<code class="fe lf lg lh li b">Jest</code>会自动将现有值与您传递给<code class="fe lf lg lh li b">expect</code>的值进行比较。</p><p id="ffad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，快照测试是很棒的，尤其是因为你的UI组件不会发生意外的变化。然而，如果你处理的数据经常改变，你不能保证它总是满足你的测试用例。</p><h1 id="0675" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="b6bb" class="mh mi iq ka b kb mj kf mk kj ml kn mm kr mn kv mo mp mq mr bi translated">测试API响应并不容易，因为它的值总是变化的。因此，我们可以检查值的类型，而不是比较值。</li><li id="89e5" class="mh mi iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe lf lg lh li b">typescript-json-schema</code>用于生成JSON模式对象。</li><li id="b51f" class="mh mi iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe lf lg lh li b">ajv</code>用于通过与用<code class="fe lf lg lh li b">typescript-json-schema</code>创建的JSON模式对象进行比较来验证您的数据</li></ul><h1 id="0e7e" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">JSON模式将是您的解决方案之一</h1><blockquote class="mx my mz"><p id="1d4a" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><strong class="ka ir"> JSON模式</strong>是一个词汇表，允许您<strong class="ka ir">注释</strong>和<strong class="ka ir">验证</strong> JSON文档。</p></blockquote><p id="f7d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JSON Schema是一个基于JSON的格式数据文档。易于维护、阅读和使用。</p><p id="cf22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您拥有一个JSON对象。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="e9ed" class="nm lk iq li b gy nn no l np nq">{<br/>  "name": "john",<br/>  "age": 30<br/>}</span></pre><p id="5de2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个JSON对象在通过JSON模式生成器时被转换如下。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="c9ca" class="nm lk iq li b gy nn no l np nq">{<br/>  "definitions": {},<br/>  "$schema": "http://json-schema.org/draft-07/schema#",<br/>  "$id": "http://example.com/root.json",<br/>  "type": "object",<br/>  "title": "The Root Schema",<br/>  "required": [<br/>    "name",<br/>    "age"<br/>  ],<br/>  "properties": {<br/>    "name": {<br/>      "$id": "#/properties/name",<br/>      "type": "string",<br/>      "title": "The Name Schema",<br/>      "default": "",<br/>      "examples": [<br/>        "john"<br/>      ],<br/>      "pattern": "^(.*)$"<br/>    },<br/>    "age": {<br/>      "$id": "#/properties/age",<br/>      "type": "integer",<br/>      "title": "The Age Schema",<br/>      "default": 0,<br/>      "examples": [<br/>        30<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="d5ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，没错。你们中的一些人可能已经注意到它看起来有点像<a class="ae nr" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"><em class="na"/></a>。花一点时间来看看这个结构。你能看到什么？对象中几乎没有属性。</p><p id="6f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要关注的是<em class="na">属性</em>。它包含原始对象中的所有关键点，包括<em class="na">姓名</em>和<em class="na">年龄</em>。<code class="fe lf lg lh li b"><em class="na">type</em></code>描述物业应满足的类型。请注意，在验证我们将要研究的JSON模式时，了解这一点非常重要。</p><h1 id="17cb" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">好了，我知道JSON模式是什么了。"那我如何将我的typescript接口转换成JSON模式呢？"</h1><p id="4f42" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">好吧。有一个非常有用的库可以将typescript接口转换成JSON模式文件。<a class="ae nr" href="https://github.com/YousefED/typescript-json-schema#readme" rel="noopener ugc nofollow" target="_blank"> <em class="na">点击此处访问TJS </em> </a>的github页面。</p><p id="d4e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">推荐你先看一下<a class="ae nr" href="https://medium.com/@moonformeli/jest-how-to-use-extend-with-typescript-4011582a2217" rel="noopener"> <em class="na">这个帖子</em> </a>，里面讲的是<code class="fe lf lg lh li b">Jest.extend</code>。这篇文章的前提是，你已经知道如何在<code class="fe lf lg lh li b">Jest</code>中定制匹配器。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h2 id="e500" class="nm lk iq bd ll oc od dn lp oe of dp lt kj og oh lx kn oi oj mb kr ok ol mf om bi translated">步骤1:创建项目结构</h2><p id="a3d3" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">让我们首先创建项目。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="477b" class="nm lk iq li b gy nn no l np nq">&gt; npm init -y<br/>&gt; mkdir src</span></pre><p id="3598" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，安装所需的软件包。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="9154" class="nm lk iq li b gy nn no l np nq">&gt; npm i -D jest ts-jest typescript @types/jest<br/>&gt; touch jest.config.js<br/>&gt; touch ./src/tsconfig.json</span></pre><p id="44db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na"> tsconfig.json </em>文件应该包含这些选项。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="1fee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是为了<em class="na"> jest.config.js </em></p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="76c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建测试和打字文件夹。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="f475" class="nm lk iq li b gy nn no l np nq">&gt; mkdir ./src/typings ./src/__tests__<br/>&gt; touch ./src/typings/index.d.ts</span></pre><p id="c9f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在要做的是为typescript创建类型化文件，这样我们就可以稍后在测试套件中使用它。用<code class="fe lf lg lh li b">index.d.ts</code>写代码。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="43b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让<code class="fe lf lg lh li b">Jest</code>知道我们已经准备好注册我们的新匹配器，创建新文件夹并制作一个文件。我们将在测试文件中导入这个文件，并在所有测试用例之前调用函数。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="f6f0" class="nm lk iq li b gy nn no l np nq">&gt; mkdir ./src/hooks<br/>&gt; touch ./src/hooks/index.ts</span></pre><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="5ee1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">extendJSCMatcher</code>尚未完成，我们稍后将完成该功能。</p><p id="c146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，创建测试文件，基本的准备工作就完成了。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="d66a" class="nm lk iq li b gy nn no l np nq">&gt; touch ./src/__tests__/jsc.spec.ts</span></pre><h2 id="11b5" class="nm lk iq bd ll oc od dn lp oe of dp lt kj og oh lx kn oi oj mb kr ok ol mf om bi translated">步骤2:创建接口和包</h2><p id="26d6" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">如果到目前为止你按照步骤做得很好，这个项目应该像下面这样。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="b5cc" class="nm lk iq li b gy nn no l np nq">node_modules<br/>src<br/>  __tests__<br/>    jsc.spec.ts<br/>  hooks<br/>    index.ts<br/>  typings<br/>    index.d.ts<br/>jest.config.js<br/>package-lock.json<br/>package.json</span></pre><p id="b98a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们将使用节点本地模块(<em class="na"> path </em>和<em class="na"> fs </em>，我们需要安装某种类型的定义包。此外，这里是我们的英雄，JSON模式验证器和JSON模式生成器包。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="850e" class="nm lk iq li b gy nn no l np nq">&gt; npm i -D @types/node typescript-json-schema ajv</span></pre><p id="13e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只要使用typescript，就要安装<code class="fe lf lg lh li b">@types/node</code>包使用<em class="na"> path </em>或者<em class="na"> fs </em>等节点原生模块。<a class="ae nr" href="https://www.npmjs.com/package/@types/node" rel="noopener ugc nofollow" target="_blank"> <em class="na">点击此处查看更多关于@types/node </em> </a> <em class="na">。</em></p><p id="c923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">typescript-json-schema</code>是为JSON模式文件生成typescript接口的神奇库。即使指南不是很好，你也可以写一个简单的例子。</p><p id="7541" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">ajv</code>是Node.js和浏览器最快的JSON模式验证器。它做的和<code class="fe lf lg lh li b">typescript-json-schema</code>做的完全相反。<code class="fe lf lg lh li b">ajv</code>根据给定的模式，检查给定的对象是否编写正确。如果对象与模式不匹配，它将返回一个错误对象。</p><p id="cafe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要为接口创建文件夹。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="7897" class="nm lk iq li b gy nn no l np nq">&gt; mkdir ./src/models<br/>&gt; touch ./src/models/ISchool.ts</span></pre><p id="042a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接口文件中将有3个有效载荷。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="3b17" class="nm lk iq bd ll oc od dn lp oe of dp lt kj og oh lx kn oi oj mb kr ok ol mf om bi translated">步骤3:编写JSON模式生成代码</h2><p id="b246" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">使<em class="na">实用程序</em>的文件夹层次如下。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="974a" class="nm lk iq li b gy nn no l np nq">utils<br/>  index.ts<br/>  jsc.ts<br/>  validate.ts</span></pre><p id="67ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们从<em class="na"> index.ts </em>开始</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="cbbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很简单的管道函数，但是如果你不懂这个或者不知道什么是管道函数，我推荐你<a class="ae nr" href="https://medium.com/@venomnert/pipe-function-in-javascript-8a22097a538e" rel="noopener"> <em class="na">看这篇文章</em> </a>。注意，这里没有返回值。我们将在不同的文件中调用该函数。</p><p id="817e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们来谈谈套餐，<code class="fe lf lg lh li b">typescript-json-schema</code>。有几个步骤你需要记住。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="068d" class="nm lk iq li b gy nn no l np nq">1. import the package<br/>2. generate the object called program<br/>3. generate the object called generator, using program</span></pre><p id="dd0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个画面看起来很简单。对于#2和#3，只需要传递几个参数。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="ecb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">generator</code>的方法很少。其中一个是<em class="na"> getUserSymbols </em>，它获取所有的符号。列表中有很多符号，如果你运行<code class="fe lf lg lh li b">console.dir(generator.getUserSymbols())</code>，看看最上面的3个项目。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="e18d" class="nm lk iq li b gy nn no l np nq">// all symbols<br/>[ 'StudentInterface',<br/>  'TeacherInterface',<br/>  'SchoolInterface',<br/>  'BaseComment',<br/>  'CommentBlock',<br/>  ...<br/>]</span></pre><p id="7595" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们是你之前写的typescript接口。这是因为你在程序生成器函数中添加了额外的文件。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="62d7" class="nm lk iq li b gy nn no l np nq">console.log(files);<br/>// ['..yourPath/ISchoolts']</span></pre><p id="8d7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这次试试<code class="fe lf lg lh li b">console.log(generator.getSchemaForSymbol(‘StudentInterface’))</code>，看看之后会怎么样。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="ae68" class="nm lk iq li b gy nn no l np nq">// this is the schema object<br/>{ type: 'object',<br/>  properties:<br/>   { name: { type: 'string' },<br/>     age: { type: 'number' },<br/>     address: { type: 'string' } },<br/>  required: [ 'age', 'name' ],<br/>  '$schema': '<a class="ae nr" href="http://json-schema.org/draft-07/schema#'" rel="noopener ugc nofollow" target="_blank">http://json-schema.org/draft-07/schema#'</a> <br/>}</span></pre><p id="07b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您已经创建了模式对象！</p><p id="bf37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，您可以将这些模式对象存储在目录<em class="na"> schema </em>中。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="a4e1" class="nm lk iq bd ll oc od dn lp oe of dp lt kj og oh lx kn oi oj mb kr ok ol mf om bi translated">步骤4:用ajv验证JSON模式</h2><p id="f753" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">这将是最后一步。既然我们在<em class="na"> schema </em>文件夹中创建了JSON模式文件，那么是时候使用<code class="fe lf lg lh li b">ajv</code>了。</p><p id="d948" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<em class="na"> validate.ts </em>文件，编写这段代码。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6775" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有几个使用<code class="fe lf lg lh li b">ajv</code>、<a class="ae nr" href="https://www.npmjs.com/package/ajv#options" rel="noopener ugc nofollow" target="_blank">、<em class="na">的方法点击这里查看。</em> </a> <em class="na"> </em>当<em class="na">验证</em>未发现错误时，则<em class="na"> errorText() </em>的错误信息为“无错误”。</p><p id="8edf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行这个文件，看看会得到什么结果。</p><pre class="ne nf ng nh gt ni li nj nk aw nl bi"><span id="d094" class="nm lk iq li b gy nn no l np nq">&gt; npx ts-node ./src/utils/validate.ts</span><span id="977a" class="nm lk iq li b gy op no l np nq">// result<br/>&gt; data should have required property 'subject'</span></pre><p id="6b15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试其他测试对象，看看结果！</p><p id="339a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们忘了完成我们制作的jest hook文件。这实际上是为了测试代码，所以如果您不想运行测试，可以跳过这一步。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><h1 id="b3cd" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">完整代码</h1><p id="9a44" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ns kl km kn nt kp kq kr nu kt ku kv ij bi translated">我在这里上传了完整的代码<a class="ae nr" href="https://github.com/moonformeli/typescript-json-schema-validate" rel="noopener ugc nofollow" target="_blank"><em class="na"/></a><em class="na"/>稍加重构。</p></div></div>    
</body>
</html>