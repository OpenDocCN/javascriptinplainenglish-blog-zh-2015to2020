<html>
<head>
<title>Multiple Attribute Angular directives on an element</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">元素上的多属性角度指令</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/multiple-attribute-angular-directives-on-an-element-f06312d2a60c?source=collection_archive---------0-----------------------#2020-06-11">https://javascript.plainenglish.io/multiple-attribute-angular-directives-on-an-element-f06312d2a60c?source=collection_archive---------0-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2056e86f6a6c2a89ef5a63bd73d9b003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3iE8ovdDMda9zg7qwl5LA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="60a1" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated"><em class="kq">角度属性指令——用于改变元素、组件或不同指令的外观或行为</em></h2></div><p id="0fe5" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在许多情况下，我们可能需要格式化用户的输入，或者在用户输入时改变元素的外观；和指令是Angular中这种情况的合适候选者。本文的目标是关注一个元素上多个指令的用例，并学习它在事件委托方面是如何工作的。</p><p id="1660" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln"> Angular有几个内置的属性指令ngStyle和ngClass，这使得在组件或元素上动态应用样式变得容易</em></p><h2 id="d678" class="lo lp jb bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">示例用例/需求</strong></h2><p id="107b" class="pw-post-body-paragraph kr ks jb kt b ku mh kc kw kx mi kf kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">现在让我们构建两个指令:一个限制用户输入的长度，另一个将用户输入转换成大写。</p><h2 id="dba2" class="lo lp jb bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">指令执行</strong></h2><ol class=""><li id="a5df" class="mm mn jb kt b ku mh kx mi la mo le mp li mq lm mr ms mt mu bi translated"><em class="ln"> MaxLength指令</em></li></ol><figure class="mw mx my mz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/309f8a5613c160792556e7e14ffbcd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Gen2Wqni7wayfwwFgYdbw.png"/></div></div></figure><p id="0b8a" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用angular的主机监听器绑定到主机元素的输入事件。onChange函数的实现非常简单，只需减少额外的字符，并使用渲染器更新原生元素的值。</p><p id="5012" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.<em class="ln">大写指令</em></p><figure class="mw mx my mz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/eb979e54ba59b73ab1f62a8da16879b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7MSw7m3sKo9qfSCIL-yBg.png"/></div></div></figure><p id="3594" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个简单的指令监听本地元素的输入事件，将文本转换成大写字母，最后使用渲染器更新本地元素。</p><p id="0bf2" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们创建一个带有input元素的组件，并将这两条指令添加到其中。</p><figure class="mw mx my mz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/d14531d6a9153735f6505d4d9261313e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tfl2KHvL_DdRxsqndMsWQ.png"/></div></div></figure><p id="51b0" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您注意到，我们已经添加了两个刚刚创建的指令和一个绑定到输入的新事件。因此，现在我们在这个输入上总共有三个输入绑定:两个在指令中，一个在组件中。</p><h2 id="f9a7" class="lo lp jb bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><em class="kq">这些事件是如何执行的，以什么顺序执行？</em></h2><p id="5ec7" class="pw-post-body-paragraph kr ks jb kt b ku mh kc kw kx mi kf kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">就执行事件处理程序而言，指令比组件具有更高的优先级。而且，如果一个元素有不止一个指令，这正是我们上面的场景，事件处理程序的执行遵循它们在元素上的放置顺序。</p><p id="5b3f" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让这变得更有趣一点，让我们使用fromEvent来绑定app组件中这个本地元素的输入事件。</p><figure class="mw mx my mz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/b6df3c0db6a1dbed77ace0bac24bb5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKGmSB9YWW35hN8VcOlCHA.png"/></div></div></figure><p id="1050" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我开始输入，所有的指令和组件事件都会被执行，然后是rxjs fromEvent。</p><p id="d8b3" class="pw-post-body-paragraph kr ks jb kt b ku kv kc kw kx ky kf kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这能让你对如何使用这些指令有所了解，尤其是在多个指令拥有相同的事件侦听器来更新本地元素的情况下。</p><blockquote class="nd ne nf"><p id="97c9" class="kr ks ln kt b ku kv kc kw kx ky kf kz ng lb lc ld nh lf lg lh ni lj lk ll lm ij bi translated"><em class="jb">源代码:https://github . com/kondareddyyaramala/element-with-multi-attribute-directives</em></p></blockquote><h2 id="b97d" class="lo lp jb bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">结论</strong></h2><p id="a35f" class="pw-post-body-paragraph kr ks jb kt b ku mh kc kw kx mi kf kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">如果多个指令侦听元素上的同一事件，事件传播取决于指令在主机元素上的放置顺序。感谢阅读！关注更多有趣的文章。</p></div></div>    
</body>
</html>