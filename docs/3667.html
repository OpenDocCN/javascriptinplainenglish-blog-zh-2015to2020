<html>
<head>
<title>How to Combine Context Providers for Cleaner React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何组合上下文提供者以获得更清晰的反应代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-combine-context-providers-for-cleaner-react-code-9ed24f20225e?source=collection_archive---------2-----------------------#2020-10-16">https://javascript.plainenglish.io/how-to-combine-context-providers-for-cleaner-react-code-9ed24f20225e?source=collection_archive---------2-----------------------#2020-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1234" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您不是生活在玻璃下，并且在过去两年中您已经看过React代码，那么您已经看到了React上下文的实际应用。上下文是一个如此强大特性，对于我们所有正在使用React的人来说，它意味着从正确的钻探和容器类组件的移除中解脱出来，我敢说Redux也是如此😱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/195bf5cf0ae71948aabdc84097aa4ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sgf5m6TugWBdEhlm.jpg"/></div></div></figure><p id="f6ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，很容易迷失在上下文提供者的地狱中，因为在你眨眼之前，你的代码将看起来像这样:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="d9fa" class="kz la in kv b gy lb lc l ld le">&lt;ContextProvider1&gt;</span><span id="a7ad" class="kz la in kv b gy lf lc l ld le">  &lt;ContextProvider2&gt;</span><span id="35b7" class="kz la in kv b gy lf lc l ld le">    &lt;ContextProvider3&gt;</span><span id="6cf8" class="kz la in kv b gy lf lc l ld le">      &lt;ContextProvider4&gt;</span><span id="509a" class="kz la in kv b gy lf lc l ld le">        ....</span><span id="47fb" class="kz la in kv b gy lf lc l ld le">      &lt;/ContextProvider4&gt;</span><span id="0e57" class="kz la in kv b gy lf lc l ld le">    &lt;/ContextProvider3&gt;</span><span id="788a" class="kz la in kv b gy lf lc l ld le">  &lt;/ContextProvider2&gt;</span><span id="e555" class="kz la in kv b gy lf lc l ld le">&lt;/ContextProvider1&gt;</span></pre><p id="8a71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将很快失去控制。正如我们所知，当我们谈论上下文提供者时，ORDER MATHERS。</p><p id="161f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如:<br/>您可以在<em class="lg"> ContextProvider2 </em>中使用<em class="lg"> ContextProvider1 </em>，因为<em class="lg"> ContextProvider1 </em>正在包装<em class="lg"> ContextProvider2 </em>，但反之则不然，所以如下所示:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="86e5" class="kz la in kv b gy lb lc l ld le">// insade <em class="lg">ContextProvider2</em></span><span id="9f5d" class="kz la in kv b gy lf lc l ld le">...<br/>const { foo } = useContext(Context1) // WORKS!</span></pre><p id="4eb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，事情是这样的:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="4348" class="kz la in kv b gy lb lc l ld le">// insade <em class="lg">ContextProvider1</em></span><span id="687b" class="kz la in kv b gy lf lc l ld le">...<br/>const { baz } = useContext(Context2) // DOES NOT WORK!</span></pre><p id="0a62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以很难通过模板检查谁在包装谁。所以让我们简单点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lh li l"/></div></figure></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="1820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上下文提供者只是函数，因此它们可以被组合，并用于创建<strong class="jm io"> AppContextProvider </strong>我们就这么做吧。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="03fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们创建util来帮助我们。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="f44f" class="kz la in kv b gy lb lc l ld le">// <em class="lg">combineComponents.tsx</em></span><span id="eb9c" class="kz la in kv b gy lf lc l ld le"><em class="lg">import </em>React, { ComponentProps, FC } <em class="lg">from </em>'react';<br/><br/><em class="lg">export const </em>combineComponents = (...<em class="lg">components</em>: FC[]): FC =&gt; {<br/>  <em class="lg">return components</em>.reduce(<br/>    (<em class="lg">AccumulatedComponents</em>, <em class="lg">CurrentComponent</em>) =&gt; {<em class="lg"><br/>      return </em>({ <em class="lg">children </em>}: ComponentProps&lt;FC&gt;): JSX.Element =&gt; {<br/>        <em class="lg">return </em>(<br/>          &lt;AccumulatedComponents&gt;<br/>            &lt;CurrentComponent&gt;{<em class="lg">children</em>}&lt;/CurrentComponent&gt;<br/>          &lt;/AccumulatedComponents&gt;<br/>        );<br/>      };<br/>    },<br/>    ({ <em class="lg">children </em>}) =&gt; &lt;&gt;{<em class="lg">children</em>}&lt;/&gt;,<br/>  );<br/>};</span></pre><p id="ab20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，我们现在只需传递一组上下文提供者，它们将从左到右组合起来。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="1bd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其次，让我们创建“<em class="lg"> AppContextProvider </em>”。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="2a5e" class="kz la in kv b gy lb lc l ld le">// AppContextProvider.tsx</span><span id="3041" class="kz la in kv b gy lf lc l ld le">import React from 'react';</span><span id="81d5" class="kz la in kv b gy lf lc l ld le">import { <em class="lg">ContextProvider1 </em>} from '.../Context1';<br/>import { ContextProvider2 } from '.../Context2';<br/>import { ContextProvider3 } from '.../Context3';<br/>import { ContextProvider4 } from '.../Context4';</span><span id="d622" class="kz la in kv b gy lf lc l ld le">import { combineComponents } from '.../utils/combineComponents;</span><span id="f08e" class="kz la in kv b gy lf lc l ld le">const providers = [<br/>  <em class="lg">ContextProvider1,<br/>  ContextProvider2,<br/>  ContextProvider3,<br/>  ContextProvider4<br/></em>]</span><span id="c6b6" class="kz la in kv b gy lf lc l ld le"><em class="lg">export const </em>AppContextProvider = combineComponents(...providers);</span></pre><p id="7786" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于哪个上下文在哪里可用的规则是一样的，但是它更容易跟踪和推理。<br/>现在我们的组件看起来像这样:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="d759" class="kz la in kv b gy lb lc l ld le">&lt;AppContextProvider&gt;</span><span id="d0b8" class="kz la in kv b gy lf lc l ld le">  ....</span><span id="ad2e" class="kz la in kv b gy lf lc l ld le">&lt;/AppContextProvider&gt;</span></pre><p id="b8e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那就是我们现在可以在应用程序的任何地方使用我们的上下文。这是你可以用来开发大规模应用程序的原则。</p><p id="9559" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于用上下文替换Redux和Redux中间件的更多信息，请阅读<a class="ae lq" href="https://medium.com/@rasha08/react-context-async-calls-with-hooks-redux-like-architecture-and-combine-context-providers-with-ee95ca87b455" rel="noopener">https://medium . com/@ rasha 08/react-Context-async-calls-with-hooks-Redux-like-architecture-and-combine-Context-providers-with-ee95 ca 87 b 455</a></p><p id="6108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lg">更多内容请看</em><a class="ae lq" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lg">plain English . io</em></strong></a><em class="lg">。报名参加我们的</em> <a class="ae lq" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="lg">免费周报</em> </strong> </a> <em class="lg">。关注我们关于</em><a class="ae lq" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lg">Twitter</em></strong></a><a class="ae lq" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lg">LinkedIn</em></strong></a><em class="lg"/><a class="ae lq" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lg">YouTube</em></strong></a><em class="lg"/><a class="ae lq" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="lg">不和</em> </strong> </a> <strong class="jm io"> <em class="lg">。</em>T49】</strong></p><p id="9a6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lg">对缩放您的软件启动感兴趣</em> </strong> <em class="lg">？检查</em> <a class="ae lq" href="https://circuit.ooo/?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="lg">电路</em> </strong> </a> <em class="lg">。</em></p></div></div>    
</body>
</html>