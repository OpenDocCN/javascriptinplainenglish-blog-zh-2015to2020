<html>
<head>
<title>Narrated by test cases: Redux Action Retry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">由测试用例叙述:Redux动作重试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/narrated-by-test-cases-redux-action-retry-b2e004c4c823?source=collection_archive---------7-----------------------#2020-05-19">https://javascript.plainenglish.io/narrated-by-test-cases-redux-action-retry-b2e004c4c823?source=collection_archive---------7-----------------------#2020-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b146" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">测试用例可能是描述技术的最佳方式，例如:</h2><div class=""/><div class=""><h2 id="f2b5" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">我如何做一个库来解决HTTP客户端重试。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2e03c123c4864d7d922bbc9c532e4ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jkP11NO8Ot7sUdAdROQ_g.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@simonmigaj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Simon Migaj</a> on <a class="ae le" href="https://unsplash.com/collections/168922/vintage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f5d3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我的团队有一个移动应用程序有一个大问题:它丢失了客户数据。</p><h1 id="a850" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">从产品到问题</h1><p id="61b5" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">让我给你一个从产品到问题场景的美好旅程:</p><h2 id="0f7d" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">该产品</h2><p id="ec96" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们的团队为快递公司开发了一个移动应用程序，其员工(快递员)在现场上传收到的包裹的签名照片。</p><h2 id="be80" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">堆</h2><p id="a9c2" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们使用:</p><ol class=""><li id="dead" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated"><a class="ae le" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> React原生</strong> </a>并为iOS和Android打造。</li><li id="397c" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><a class="ae le" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> Redux </strong> </a>为国家管理者。</li><li id="24bb" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><a class="ae le" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja"> Redux-Saga </strong> </a>为异步副作用。</li><li id="d04b" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><a class="ae le" href="https://github.com/rt2zz/redux-persist" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">-Redux-Persist</strong></a><strong class="lh ja"/>保存手机上的数据。</li></ol><h2 id="2efa" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">应用生命周期</h2><p id="a42a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">不知道你是否能想象出它已经有了堆栈，但我将向你简要解释我们的应用程序状态是如何工作的:</p><ol class=""><li id="2d19" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">我们使用React Native用JavaScript编写一个移动客户端，使用React Native工具，我们为iOS和Android生成构建。</li><li id="c3e4" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">当应用程序启动时，redux-persist从内存中检索最后的状态，作为应用程序的初始状态(再水合)。</li><li id="3097" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">当用户与一个元素交互时，它<a class="ae le" href="https://redux.js.org/api/store#dispatchaction" rel="noopener ugc nofollow" target="_blank">发送</a>一个<a class="ae le" href="https://redux.js.org/basics/actions" rel="noopener ugc nofollow" target="_blank">动作</a>。</li><li id="df0c" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">当一个动作被分派时，它同步产生一个新的状态。</li><li id="f8d7" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">分派一个动作还会触发一个<a class="ae le" href="https://redux-saga.js.org/docs/basics/UsingSagaHelpers.html" rel="noopener ugc nofollow" target="_blank">事件</a>，它作为一个异步操作工作，并可能产生其他动作，从而引起连锁反应。</li><li id="8500" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">当存储发生变化时，redux-persist会将状态保存在内存中(这种情况经常发生，我们永远不知道应用程序何时会被关闭)。</li></ol><h2 id="3b93" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">问题场景</h2><p id="8218" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我将向您描述我们的主要问题场景:</p><ol class=""><li id="8789" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">应用程序已打开。</li><li id="ac88" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">商店被重新水化。</li><li id="aed9" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">用户上传照片。</li><li id="6f5b" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">同步内部状态<strong class="lh ja">乐观地</strong>将图像添加到状态。</li><li id="49a7" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">状态保存在永久存储器中。</li><li id="ee3a" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">saga通过HTTP请求将照片上传到服务器。</li><li id="ff46" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi">???</li><li id="4385" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><strong class="lh ja"> <em class="nx">请求永远不会到达服务器。</em>T29】</strong></li><li id="1531" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">该应用程序关闭和打开。</li><li id="dfee" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">商店被重新水化。</li><li id="5be1" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">照片在手机上，并出现在应用程序中。</li><li id="8415" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">一天或多天过去了。</li><li id="e9b1" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><strong class="lh ja">客户抱怨他的员工成功地将照片上传到应用程序，但照片不在报告中。</strong></li></ol><h1 id="4c92" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">分析问题</h1><p id="11ed" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">当你在开发一个移动应用程序时，你遇到的第一个网络困境是移动设备会比桌面更频繁地离线。自然地，我们的应用程序已经有了一个库，它对动作进行排队以便稍后重试。</p><h2 id="2910" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">离线图书馆通常如何工作</h2><ol class=""><li id="425d" class="nj nk iq lh b li mt ll mu lo ny ls nz lw oa ma no np nq nr bi translated">库是冗余的中间件。</li><li id="5ce3" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">他们通常有一个机制，允许他们检测是否有互联网可用。</li><li id="06b4" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">如果图书馆检测到有互联网，它什么也不做。</li><li id="328a" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">但是，如果库检测到没有互联网:当一个动作被分派时，库截获该动作并将其排队，执行同步操作(乐观状态)但忽略异步操作(sagas，可能保存HTTP请求)。</li><li id="6607" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">如果库再次检测到有互联网，它调度所有排队的动作，并转到点3。</li></ol><p id="f9ff" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">起初，我们认为我们的问题是图书馆误识别了电话是否在线，发送了带有假阳性互联网连接的请求，显然，我们得到了网络错误。</p><p id="7eeb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最简单的方法是寻找一个替代方案。我们尝试了许多针对Redux的<em class="nx">【离线队列】</em>解决方案，都是基于添加一个中间件，将被标记为“可重试”的动作排队，和/或在手机离线时阻止sagas的执行。它们之间的主要区别在于它们如何检测互联网连接以及与其他库的交互(比如redux-persist)。</p><p id="530f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在某个时候，我们开始分叉这些库以改进离线检测机制，并很快意识到这些库测试了网络连接，但没有测试互联网的可访问性，因此在有Wi-Fi但没有互联网的情况下执行sagas会导致排队的操作丢失，当然，这是由于网络错误而失败。</p><p id="c162" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当时React Native没有现成的解决方案来检测互联网的可达性(不确定它现在是否有)，我们唯一的选择是ping一个服务器，看看包是否真的穿过了马路。</p><p id="f41b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在原型化我们确保到达服务器的方法时，我们遇到了一个更大的问题:我们的服务器有短暂的错误。也就是说，我们有停机时间，这是局部的，是瞬间的事情，但我们可以注意到它。</p><p id="f07d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">设备中的网络可达性检测无法解决服务器上的瞬时错误，因此我们的客户端仍然需要在逻辑上正确处理500个状态代码(以不丢失数据)，因此我们决定打破常规，寻找另一种方法来解决这个问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/91e2c94a6e2fad67ba7279609cfc5538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lw-_CCEic0wNbawlsf0FPg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Mobile app Network &amp; Server scenario</figcaption></figure><h1 id="666f" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">解决我们头脑中的问题</h1><p id="a661" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在研究了针对这个问题的库之后，我们能找到的只有<strong class="lh ja"> <em class="nx">【最多一次交付】，</em> </strong>具有网络可用性意识，这阻止了在明显不好的场景中执行动作。</p><p id="2dd3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在真正分析了这个问题之后，我的脑袋在尖叫:没有办法预先知道一个行动是否会失败。预测HTTP请求是否会失败是徒劳的。</p><p id="49b1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们需要确保我们的HTTP请求成功，而不仅仅是在“理想的”场景中发送它(比如有互联网的时候)。至少我们可以检查我们的请求是否到达服务器，我们需要<strong class="lh ja"> <em class="nx">“至少一次交付”</em> </strong>。</p><p id="da40" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">经过几个星期的努力寻找解决方案，我们放弃了，我说服团队让我建立我们自己的工具，这没有多大说服力，我们真的需要解决这种数据丢失。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/1939783ae5c47d407ac7991f984b170e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ps8m6CvnuYXkvq9DLazTIw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Common libraries: At most once delivery with network availability awareness</figcaption></figure><p id="cf40" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这一点上，我们已经发现我们需要一个更强大的方法，另一种思考退休行动的方式，我想到的是:</p><blockquote class="oc od oe"><p id="723f" class="lf lg nx lh b li lj ka lk ll lm kd ln of lp lq lr og lt lu lv oh lx ly lz ma ij bi translated"><strong class="lh ja">行动必须重试，直到成功、衰老或明确停止。</strong></p></blockquote><h2 id="f4a1" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">至少一次交货</h2><p id="79fd" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">但是如何保证<strong class="lh ja"> <em class="nx">【至少一次交货】</em> </strong>？嗯……这是书中最古老的把戏，当然是致谢。</p><p id="7664" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">新库不应假定何时从缓存中移除。如果我们调度了一个动作，它必须缓存在重试机制中，以便以后重试，并且它的saga必须显式地向重试机制发送一个确认，以删除缓存的动作。</p><p id="63bb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">它应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/25c700c8df87ca36980185c4681a2b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kras3FlnJl1OIP_IkqBy-A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://github.com/edgarjrg/redux-action-retry" rel="noopener ugc nofollow" target="_blank">Redux-action-retry</a> main scenario</figcaption></figure><h1 id="a303" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">开始</h1><p id="f163" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">现在我们知道了解决问题应该是什么样子，让我们实际上开始编程一些东西来完成我们想要的。</p><h2 id="97e3" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">一个Redux库的剖析</h2><p id="b94a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">Redux库通常由3个组件组成:</p><ol class=""><li id="e9fb" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">向Redux添加行为的中间件。</li><li id="9ebb" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">一个Reducer，用于更新库自身的状态，如果需要的话。</li><li id="083f" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">最后是动作创建者，它们是预定义的动作，开箱即用是有意义的。</li></ol><p id="d237" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，我们的解决方案可以由这三个部分中的任何一个组成，尽可能不引人注目和最小化配置也很好，但这些都是次要的，重要的是解决问题！</p><p id="5e38" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Redux库的内部很复杂，非常纠结，它们不会是一个好的讲述者，但是你知道会是什么吗？测试。</p><h2 id="b7c9" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">寻找叙述者</h2><p id="716c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">当然，我首选的JavaScript测试框架是<a class="ae le" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，但是在经过大量的场景分析后，我发现编写这样一个库有太多可能出错的地方，仅仅Jest是不够的。所以我决定:</p><blockquote class="oc od oe"><p id="2a37" class="lf lg nx lh b li lj ka lk ll lm kd ln of lp lq lr og lt lu lv oh lx ly lz ma ij bi translated">让我们只关注事物的实际形状，其他的都应该是随机的。</p></blockquote><p id="c543" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以我决定和我的朋友<a class="ae le" href="https://github.com/dubzzz/fast-check" rel="noopener ugc nofollow" target="_blank">一起进行“基于属性的测试”，快速检查</a>。fast-check是一个神奇的库，它可以帮助您发现奇怪的边缘情况，同时允许您只关注测试的属性，而不是短暂的值。</p><p id="6ea5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是为什么是快速检查而不是其他？好吧，即使有其他库来帮助我们完成基于属性的测试，快速检查也是用TypeScript编写的，对于可能已经认识我的人来说，我完全同意这一点。</p><p id="a7c3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我将尽我所能在快速检查的帮助下讲述这个故事，但请不要太关注它的细微差别，如果你不熟悉，这些测试的价值不在于快速检查的使用。</p><h2 id="7364" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">测试驱动开发(TDD)</h2><p id="8806" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我使用测试驱动开发来设计这个库应该是什么样子，然而，我是一年前做的这个库，所以我不能向你展示测试是如何塑造这个库的。你可能认为有些部分是事后做的，但它们大多是测试的迭代，例如:我提取了更容易重用的功能的公共代码，只有在我意识到它们是公共的之后。</p><h2 id="5f6c" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">黑盒测试</h2><p id="b138" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">关于这些测试的另一个重要的事情是，它们是黑盒测试，这意味着我们不会测试库的内部，而只是Redux本身的行为。</p><p id="bcda" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们的测试就像我们在应用程序中实现库一样，我们将只使用库本身公开的接口。</p><p id="10e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不多说了，我将向您展示测试套件，它应该比其他任何套件都更好地解释了这个库的使用。</p><h1 id="e3cc" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">核心</h1><p id="957c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">该库的核心由5个属性组成:</p><ol class=""><li id="f475" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">不可缓存的操作不会被缓存。</li><li id="c2b7" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">可缓存的操作被缓存。</li><li id="148c" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">Reset返回空缓存。</li><li id="8952" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">Remove返回没有元素的缓存。</li><li id="5d61" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">全部重试。</li></ol><p id="ab87" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我在nice函数中提取了一些公共代码，以使测试尽可能容易编写，让我带您开始使用Redux管道。</p><h2 id="7bdb" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">撕毁</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/89dd4ed83943afae6c47982d32e70f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqynjWAv2olArt0EwP_xOQ.png"/></div></div></figure><ol class=""><li id="ad8d" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated"><code class="fe oj ok ol om b">preloadState</code>表示<code class="fe oj ok ol om b">createStore</code>的初始状态。</li><li id="6262" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">config</code>是对库的配置。</li><li id="d90c" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">gotToReducerSpy</code>让我们知道我们的应用程序中的reducers将采取什么行动。</li><li id="0273" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">store</code>是我们的库的最小Redux存储配置的样子。</li></ol><p id="99c1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如您所见，<code class="fe oj ok ol om b">wholePipeline</code>返回一个初始化的Redux存储，以及我们的重试机制和一些工具(间谍)来帮助我们查看事情是否正常工作:<code class="fe oj ok ol om b">dispatchSpy</code>和<code class="fe oj ok ol om b">gotToReducerSpy</code>。</p><p id="0c6a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">有了所有这些工具，现在我们可以将我们的测试用例集中在检查事情是否正在发生，并且我们不需要对Redux做任何其他的配置。</p><p id="0425" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所有的核心测试都在一个文件<code class="fe oj ok ol om b">test/core.spec.ts</code>中。</p><p id="1827" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">好吧！不是，我们都准备好要看第一个测试场景了:</p><h2 id="d201" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">不可缓存的操作不会被缓存</h2><p id="830b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">对于我们的第一个测试，我们应该检查最低配置是否有效，也就是:什么都不做。</p><p id="8145" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们没有显式地配置库来缓存任何动作，那么在分派任何动作时，缓存存储应该保持为空。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/af694a5452772c8b772f550033fe4ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pq3osILNbO9KlABaYD2Zww.jpeg"/></div></div></figure><p id="6ec6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们的测试是这样的:</p><ol class=""><li id="81d4" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">无论<code class="fe oj ok ol om b">assert</code>里面是什么函数，它都会运行大约100次。</li><li id="b68d" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">property</code>获取数据类型生成器并将它们应用于第二个参数中的函数。</li><li id="a5e3" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们生成的数据类型是一个可变长度的数组，包含一个元组(一个已知长度的数组)，有两个不同的字符串:<br/> <code class="fe oj ok ol om b">[ [ full unicode string, full unicode string], ... ]</code></li><li id="7a30" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们用一个空对象作为状态来启动管道。</li><li id="6194" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们将库配置为不存储任何动作。</li><li id="0368" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">对于数组中的每一项(元组)，使用数组的第一个元素作为动作的<code class="fe oj ok ol om b">type</code>字符串，使用数组的第二个元素作为有效负载。</li><li id="9f86" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们迅速行动。</li><li id="1170" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">处于状态的缓存应该为空。为什么？因为:我们没有配置任何要缓存的操作。</li></ol><p id="c75c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在你已经熟悉了快速检查(<code class="fe oj ok ol om b">fc</code>)，<code class="fe oj ok ol om b">assert</code>让测试运行x次(默认为100)，这使得<code class="fe oj ok ol om b">property</code>产生100种不同的情况(小数组、大数组、空字符串、奇怪的字符串)。然后，我们使用生成的数据来构建发送到商店的操作，在每个场景中，我们都应该得到一个空状态。</p><h2 id="33ef" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">可缓存的操作被缓存</h2><p id="b536" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">对于我们的第二个测试，让我们证明我们的lib配置工作，如果我们说一个动作应该被缓存，它必须在缓存存储中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/3cf677aa2297e2f846f59eda06932fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EL15te_id711ErZZNQLk5w.jpeg"/></div></div></figure><p id="e62d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个测试的可读性可以提高一点，你不觉得吗？像<code class="fe oj ok ol om b">[x[0]]:{}</code>这样的行很难理解，我将再试一次:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/ae834d903f8472c145cee2678cc8b499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMNEfg0r9dHb8f8dEX7WDw.jpeg"/></div></div></figure><p id="abf4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">测试流程是这样的:</p><ol class=""><li id="43f4" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">我们创建一个记录(对象)数组，其中包含一个至少包含1个字符的<code class="fe oj ok ol om b">type</code>属性，一个可以是任意字符串的<code class="fe oj ok ol om b">payload</code>属性，以及一个对于每个动作都应该是唯一的id。</li><li id="6c94" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们配置库来存储我们生成的所有动作类型。</li><li id="2381" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们用一个id来标识所有的动作，这是库所要求的，我将在后面介绍更多的细节。</li><li id="f2a1" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">我们调度并检查该动作是否是最后添加的。</li><li id="82bd" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">最后，我们检查整个缓存是否包含所有已排序的操作。</li></ol><p id="6c4e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">到目前为止一切顺利，我们现在可以确信我们的动作正在被缓存！</p><h2 id="0788" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">重置返回空缓存</h2><p id="e84f" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们的第一个案例基本上证明了我们的库可以无干扰地添加到Redux配置中，并且确保缓存存储工作正常，那么我们接下来的场景中最少要测试什么呢？我认为应用程序生命周期是一个很好的候选，它帮助我们思考库如何在应用程序中生存。</p><p id="b678" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">常见的应用程序生命周期命令:</p><ol class=""><li id="29d5" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">安装应用程序。</li><li id="b01f" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">打开应用程序。</li><li id="aca9" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">登录。</li><li id="3f6e" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">使用。</li><li id="1574" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">关闭。</li><li id="73cc" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">注销。👀</li><li id="43da" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">已卸载。</li></ol><p id="3362" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果用户启动应用程序，redux-persist可能会恢复我们的缓存存储，库不需要做任何事情，但是，如果用户注销，我们可能希望清空我们的存储，以便为下一个登录的用户有一个干净的开始，让我们接下来这样做:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/1b8bd8378fc3c8ba9a6fb0bca4713178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WGDbzI0nIIM6RPDIh1yKg.jpeg"/></div></div></figure><p id="7b88" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个测试用例中，我做了另一个改进，我在属性中构造了我们的整个动作，所以我们不需要在下面创建它，现在看起来很明显。</p><p id="acd4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一般来说，这种情况可以通过3个简单的步骤来实现:</p><ol class=""><li id="ab65" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">提起诉讼。</li><li id="2f6a" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">调度重置。</li><li id="75bc" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">检查缓存存储是否为空。</li></ol><h2 id="cfee" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">移除返回没有元素的缓存</h2><p id="1e21" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">既然我们的应用程序生命周期似乎已经覆盖，我们可以转移到我们的主要工作，重试操作。我喜欢在测试中从决策树的叶子开始，这样我可以确保以后有更完整的测试场景。</p><p id="6bbc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，我们的重试场景可能是这样的:</p><ol class=""><li id="c59b" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">分派一个操作，并检查它是否被缓存。</li><li id="bb46" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">调度重试，查看重试是否发生，并检查操作是否仍在缓存中。</li><li id="eb77" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">分派移除操作，并检查该操作是否已不在缓存中。</li></ol><p id="0209" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们现在做这个测试，如果我们还没有设计或者实现，我们怎么能发送一个移除动作命令呢？TDD方式告诉我，我应该首先提出一个移除的案例。</p><p id="a61d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">与所有内容都必须删除的重置场景不同，删除必须针对单个操作，因为它们可能彼此独立地成功，删除一个元素如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/1b8bd8378fc3c8ba9a6fb0bca4713178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WGDbzI0nIIM6RPDIh1yKg.jpeg"/></div></div></figure><p id="fa8b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们所做的是:</p><ol class=""><li id="1b8a" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">使用目标的引用(更准确地说，是要删除的目标操作的id)创建一个删除操作。</li><li id="dd02" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">获取当前商店的快照。</li><li id="144c" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">派遣行动。</li><li id="5703" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">分派移除操作。</li><li id="a0f8" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">断言新状态，因为我们应该已经删除了该动作，应该与缓存该动作之前的状态相同。</li><li id="63f6" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">最后，在我们删除每个添加的动作时，检查缓存是否为空。</li></ol><p id="6950" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们有了重试测试用例的所有要素。</p><h2 id="6db5" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">重复数据删除</h2><p id="5c7a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">至此，我们有足够的信心来创建重试测试用例，这将比其他的更复杂一些。</p><p id="525b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们考虑一下，一个断言库是否正在正确重试的测试将不得不分派动作，并重试它们多次，看看是否都重试了。</p><p id="5ea4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们重试这些操作，您能想象缓存存储应该是什么样子吗？因为一旦我们分派了重试，所有的动作都被重试，这些动作将再次进入中间件(我们的库)，但是，我们不希望它们被复制。</p><p id="bd79" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">没错，我们需要准备好重复数据删除，这就是<code class="fe oj ok ol om b">meta.REDUX_ACTION_RETRY.id</code>派上用场的时候，正如我之前在TDD部分提到的，我已经迭代了一些测试，例如，在这一点上，我必须修改之前的测试以使用<code class="fe oj ok ol om b">id</code>属性，因为在这一点之前它不是一个要求，事实上，我花了一段时间来决定<code class="fe oj ok ol om b">id</code>必须是一个要求而不是可选属性。</p><h2 id="2066" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">全部重试</h2><p id="c067" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如果我们希望每个唯一的操作在缓存中只出现一次，这意味着我们不能只使用缓存存储来断言操作被重试。如果我们分派一个可缓存的动作，分派一个重试全部，并且存储没有被明显地修改，我们如何断言我们做了什么？</p><p id="8204" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们不能使用缓存存储来证明事情正在工作，那么也许我们可以基于哪些操作符合reducer来构建一个“历史”,并比较它们是否按照期望的顺序到达。</p><p id="8cfb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">做这个测试需要几天的时间来反复设计重试动作应该是什么样子，但是我想我想到了一个模式，它准确地描述了事情是如何工作的，并且极大地简化了测试用例。</p><p id="5039" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在观察<code class="fe oj ok ol om b">redux-persist</code>如何工作时，我意识到库将动作分派给它自己的reducer中间件，这是一种非常好的可调试方式，因为它们是非常容易识别的动作。这时我想到不要插入任何通过我们的中间件自动传递的动作，而是分派一个<code class="fe oj ok ol om b">upsert</code>动作，并让缓存缩减器对其做出反应。</p><p id="160b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们要做的是:我们将生成许多动作，对于每个动作，我们将分派一个动作和一个<code class="fe oj ok ol om b">retryAllAction</code>，到达我们的reducer spy的动作历史应该如下所示:</p><ol class=""><li id="4d35" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated"><code class="fe oj ok ol om b">upsertAction</code></li><li id="08cb" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">行动</li><li id="1d74" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">retryAllAction</code></li><li id="b3c5" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">对应的<code class="fe oj ok ol om b">upsertAction</code>之前的每个先前分派的动作的序列。</li></ol><p id="cef5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更详细地说，假设我分派了动作<code class="fe oj ok ol om b">A</code>和<code class="fe oj ok ol om b">B</code>:</p><ol class=""><li id="52a8" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">调度<code class="fe oj ok ol om b">A</code></li><li id="43ed" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">调度<code class="fe oj ok ol om b">retryAll</code></li><li id="ed13" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">调度<code class="fe oj ok ol om b">B</code></li><li id="aaaa" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">调度<code class="fe oj ok ol om b">retryAll</code></li></ol><p id="4c1f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">那么<code class="fe oj ok ol om b">gotToReducerSpy</code>一定是通过以下方式调用的:</p><ol class=""><li id="5a7a" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated"><code class="fe oj ok ol om b">upsertAction A</code>，Redux中间件可以在将当前动作向下传递之前调度动作，<strong class="lh ja"> upsert机制</strong>应该这样做，以确保在处理动作和触发reducers和sagas之前缓存动作，这可能会失败甚至关闭应用程序。</li><li id="faba" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b"><strong class="lh ja">A</strong></code>，我们实际出动的行动。</li><li id="cd74" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b"><strong class="lh ja">retryAll</strong></code>，我们实际出动的另一个行动。</li><li id="badd" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">upsertAction A</code>，<strong class="lh ja">重试机构</strong>实际上只调度了<code class="fe oj ok ol om b">A</code>，上插机构应该再次在<code class="fe oj ok ol om b">A</code>之前将<code class="fe oj ok ol om b">upsertAction</code>推下链条。</li><li id="24a0" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">A</code>，由重试机制调度。</li><li id="6c98" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">upsertAction B</code>，upsert机制。</li><li id="c850" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b"><strong class="lh ja">B</strong></code>，我们实际出动的行动。</li><li id="2745" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b"><strong class="lh ja">retryAll</strong></code>，我们实际出动的最后一次行动。</li><li id="7060" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">upsertAction A</code>，upsert机制。</li><li id="28c9" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">A</code>，重试机制。</li><li id="c8e2" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">upsertAction B</code>，upsert机制。</li><li id="a58c" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated"><code class="fe oj ok ol om b">B</code>，重试机制。</li></ol><p id="724e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们对此进行归纳，我们会得到:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/2d2ad50eb77ddc91f832cd921923ff02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkxXmMdfwWrD4kkxwPUJTw.jpeg"/></div></div></figure><p id="efe4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们所做的:</p><ol class=""><li id="d33e" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">对于每个动作:分派动作。</li><li id="5cb1" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">检查该操作是否是最后添加到缓存存储中的。</li><li id="9b17" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">给商店拍快照。</li><li id="c405" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">分派“重试全部”操作。</li><li id="ab04" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">断言新店和上一家完全一样。</li><li id="df28" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">在动作迭代器的末尾，对间谍进行全面检查，这应该与我们的模式相匹配。</li><li id="de5a" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">偏执地再次检查所有的动作是否都在缓存中(以另一种方式多余地断言某件事似乎是偏执的，直到这样做救了你的命)。</li></ol><h2 id="fb4e" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">重试所有模式的操作</h2><p id="437c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这个测试看起来很简单，但是要完成它需要很多迭代、努力和时间。简洁代码的一个秘密是间谍调用中的抽象模式，但不用担心，我会告诉你:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/36ad3a196e93d64eef80faa08383809b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syMoLKr0efWacXeUAKOcRg.jpeg"/></div></div></figure><p id="e88e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是模式现在的样子，但是为了得出在<code class="fe oj ok ol om b">A</code>、<code class="fe oj ok ol om b">B</code>动作中解释的结论，在笔记本和白板上画了很多东西。</p><p id="5686" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可能想知道，为什么库操作如此冗长/多余？嗯，这是最安全和更易调试的方式来表示重试的情况，如果您遇到问题，您只需使用任何Redux中间件打印操作，并查看什么操作先出现，什么操作被认为需要增加等等，顺序和原子性得到了保证。没有那些<code class="fe oj ok ol om b">upsertAction</code>能做到吗？是的，它会变得不那么健谈，但是保持沉默不是一个好的生产系统。</p><h1 id="1047" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">好消息</h1><p id="abeb" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我有几个好消息要告诉你:</p><h2 id="7829" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">你已经到达终点了</h2><p id="6564" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">你把这些都吃完了！感谢你一直读到这一部分，我真的希望这些测试的见解能帮助你做出更好的测试。</p><h2 id="46d7" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">还有更多</h2><p id="cfc6" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">更多好消息，还有更多功能！在编写这个库的时候，我尽最大努力做到模块化，并开发了我们刚刚隐含介绍的核心特性:</p><ol class=""><li id="a271" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">向上插入。</li><li id="242f" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">重置。</li><li id="6083" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">移除。</li><li id="9a75" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">全部重试。</li><li id="e554" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">垃圾收集器，👀还是我们没有？</li></ol><p id="54a2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是，这个库中还有更多东西帮助我们实现了真正强大的解决方案:</p><ol class=""><li id="fd63" class="nj nk iq lh b li lj ll lm lo nl ls nm lw nn ma no np nq nr bi translated">垃圾收集器。</li><li id="d775" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">次数(或重试次数)。</li><li id="6016" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">冷却时间。</li><li id="90a1" class="nj nk iq lh b li ns ll nt lo nu ls nv lw nw ma no np nq nr bi translated">是时候活下去了。</li></ol><p id="a09c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我没有包括这些情况，因为这篇文章很长，这是我第一次发表这种格式，所以我不知道添加其他4个更复杂的规范会有什么反应，但是，如果你想让我做，请告诉我。</p><h2 id="1b23" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">开源代码库</h2><p id="f260" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这个库是开源的！去<a class="ae le" href="https://github.com/edgarjrg/redux-action-retry" rel="noopener ugc nofollow" target="_blank">https://github.com/edgarjrg/redux-action-retry</a>，评论，启动，分叉，使用，看其他测试用例，来个爆款。</p><p id="8bb3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我一年前做了这个库，我工作的公司很酷，允许我发布它，但是，我没有收到任何请求，所以我没有对它做任何维护，但是如果你愿意，我可以做一个依赖项的快速更新，或者你喜欢或需要的任何其他内容。</p><h2 id="99aa" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">x状态</h2><p id="8044" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我正在认真考虑将这个库移植到XState，以带来一个更清晰的解决方案，因为Statecharts可能更好地表示内部情况，我认为这太乱了，无法在本文中展示，而是让测试用例讲述一个更好的故事。</p><h2 id="6825" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">我写了更多</h2><p id="75fd" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><a class="ae le" href="http://eepurl.com/hg7AeP" rel="noopener ugc nofollow" target="_blank">我有一份简讯，你可能会喜欢</a>，我还写了其他可能对你有帮助的文章，比如<a class="ae le" href="https://medium.com/javascript-in-plain-english/the-6tools-that-changed-javascript-for-me-3ee1faf40585" rel="noopener">为我改变JavaScript的6个工具</a>、<a class="ae le" href="https://medium.com/javascript-in-plain-english/you-should-never-use-an-arrow-function-in-any-of-these-two-situations-8bc2fbbc39b8" rel="noopener">永远不要使用箭头函数的两种情况</a>和<a class="ae le" href="https://medium.com/better-programming/how-management-is-limiting-your-potential-as-a-developer-abb46f18e097" rel="noopener">管理如何限制你作为开发人员的潜力</a>，希望我的故事能给你带来一些价值。</p><p id="6cf7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">谢谢你这么牛逼！</p><h2 id="a1fc" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="59b6" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae le" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae le" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">订阅我们的YouTube频道</strong> </a> <strong class="lh ja">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>