<html>
<head>
<title>How memory management works in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中内存管理的工作原理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-memory-management-works-in-javascript-43e1ef22c3bb?source=collection_archive---------0-----------------------#2020-03-02">https://javascript.plainenglish.io/how-memory-management-works-in-javascript-43e1ef22c3bb?source=collection_archive---------0-----------------------#2020-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6628" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">JavaScript的基础知识</h2><div class=""/><div class=""><h2 id="fd8a" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一本通过闭包、作用域和其他相关事物理解引用的指南，你可能是初学者，也可能不是。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d7382e4b2fee368f7b8d21a11204aecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13lt6jfcdikg1yszK3H__g.png"/></div></div></figure><p id="fdb1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">老实说，我是那些在阅读整个文档之前尝试做一些事情的人之一…大多数时候，它工作得很好，如果我卡住了，我会打开文档并检查我的问题的答案。</p><p id="dc02" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是最近，我在使用React应用程序处理JavaScript引用时遇到了一些问题，并且不太容易发现，因为我的代码没有以可预测的方式产生变化。</p><p id="2edf" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">它是关于一些我认为我正在掌握的东西，但是我很久以前读过关于它的文章和文档，我已经忘记了一些关于它的事情。</p><p id="d3b5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些问题对我帮助很大，我学到了一些我已经错过很长时间的东西，一些被认为是基础的东西…即使我是一名程序员已经很多年了。我想和你分享我今天学到的东西。</p><p id="89ec" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">这一期是关于理解JavaScript中的内存管理，</strong>特别是通过作用域。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="09f8" class="md me iq bd mf mg mh mi mj mk ml mm mn kf mo kg mp ki mq kj mr kl ms km mt mu bi translated">JavaScript内存管理解释</h1><p id="f0c3" class="pw-post-body-paragraph la lb iq lc b ld mv ka lf lg mw kd li lj mx ll lm ln my lp lq lr mz lt lu lv ij bi translated">好的，为了理解JS内存，我们需要记住下面文章中的两条规则，它们非常简单:</p><ul class=""><li id="a9b0" class="na nb iq lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><strong class="lc ja">原始类型</strong> <em class="nj">(字符串、数字、布尔)</em> <strong class="lc ja">作为副本传递给函数参数。</strong></li><li id="91ee" class="na nb iq lc b ld nk lg nl lj nm ln nn lr no lv nf ng nh ni bi translated"><strong class="lc ja">对象作为函数参数的引用被传递</strong></li><li id="8a9c" class="na nb iq lc b ld nk lg nl lj nm ln nn lr no lv nf ng nh ni bi translated"><strong class="lc ja">函数</strong>和<strong class="lc ja">数组</strong>(也是null，但这是出于历史原因保留的一个bug，它并不像其他两个那样是可变的)<strong class="lc ja">被JavaScript认为是对象</strong></li></ul><p id="132d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您可以在您的浏览器控制台中尝试这个<code class="fe np nq nr ns b">typeof []</code>来验证该行为，您将最终得到被打印的<code class="fe np nq nr ns b">object</code>。</p><h2 id="5d24" class="nt me iq bd mf nu nv dn mj nw nx dp mn lj ny nz mp ln oa ob mr lr oc od mt iw bi translated">JavaScript中的引用是如何工作的以及如何解释它</h2><p id="2134" class="pw-post-body-paragraph la lb iq lc b ld mv ka lf lg mw kd li lj mx ll lm ln my lp lq lr mz lt lu lv ij bi translated">你在下面看到的是一般的JavaScript引擎，不管是框架还是环境，但是我们将在后面看到为什么这对于ReactJS和hooks来说是乏味的。</p><pre class="kp kq kr ks gt oe ns of og aw oh bi"><span id="6e56" class="nt me iq ns b gy oi oj l ok ol">const someObject = { a: 5 };<br/>const someArray = [1, 2];</span></pre><p id="5499" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你可能会认为下面的语句是在<code class="fe np nq nr ns b">{ a: 5 }</code>引用位置(内存位置)创建的<code class="fe np nq nr ns b">someObject</code>，但实际上，你应该把它理解为<code class="fe np nq nr ns b">someObject</code>变量对对象<code class="fe np nq nr ns b">{ a: 5 }</code>引用的引用点。</p><p id="a42d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">上述语句可以分解如下</p><pre class="kp kq kr ks gt oe ns of og aw oh bi"><span id="99e8" class="nt me iq ns b gy oi oj l ok ol">| const someObject   | =                   | { a: 5 };<br/>| const someArray    | =                   | [1, 2]<br/>| variable reference | assignment operator | object Reference</span></pre><p id="c5c0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">也可以看看那两个增加更多解释的要点:<a class="ae om" href="https://gist.github.com/siwalikm/dbf0e71f6e7e3406369b2cff1a6eb416" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja">这个</strong> </a>和<a class="ae om" href="https://gist.github.com/rtablada/81507edfdfce8063be9a7728c7ae7135" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja">这个</strong> </a>。</p><p id="17ad" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好了，现在我们有了基础，让我们看看为什么如果理解不好会有问题。</p><h1 id="e567" class="md me iq bd mf mg on mi mj mk oo mm mn kf op kg mp ki oq kj mr kl or km mt mu bi translated">JavaScript闭包和引用</h1><p id="654b" class="pw-post-body-paragraph la lb iq lc b ld mv ka lf lg mw kd li lj mx ll lm ln my lp lq lr mz lt lu lv ij bi translated"><strong class="lc ja">快速记住闭包</strong></p><blockquote class="os"><p id="9e3e" class="ot ou iq bd ov ow ox oy oz pa pb lv dk translated"><a class="ae om" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">闭包</a>是一个记住其外部变量并能访问它们的函数。在JavaScript中，几乎所有的函数自然都是闭包。</p></blockquote><p id="8abb" class="pw-post-body-paragraph la lb iq lc b ld pc ka lf lg pd kd li lj pe ll lm ln pf lp lq lr pg lt lu lv ij bi translated">使用JavaScript时，你每次都在使用闭包和管理作用域，通过这样做，你需要理解引用是如何工作的。</p><p id="917c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在闭包里，有一个<strong class="lc ja">词汇环境</strong>的概念，它保存不同范围的值。我这里就不展开那么多了如果你想了解更多，<strong class="lc ja">随意在这里</strong> 阅读详情 <a class="ae om" href="https://javascript.info/closure#lexical-environment" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja">。</strong></a></p><p id="604c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">带参数的➡️原语类型被作为副本传递</strong>。下面是一个简单的例子。</p><p id="4e89" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在下面的例子中，修改<code class="fe np nq nr ns b">a</code>或<code class="fe np nq nr ns b">b</code>对范围2内的<code class="fe np nq nr ns b">arg</code>没有任何副作用。同样在范围2内修改<code class="fe np nq nr ns b">arg</code>对<code class="fe np nq nr ns b">a</code>还是<code class="fe np nq nr ns b">b</code>没有影响。</p><p id="6d3b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">记住:</strong>范围用括号<code class="fe np nq nr ns b">{ }</code>分隔。</p><pre class="kp kq kr ks gt oe ns of og aw oh bi"><span id="34df" class="nt me iq ns b gy oi oj l ok ol">// Scope 1<br/>let a = 5;<br/>let b = "hello";</span><span id="30c0" class="nt me iq ns b gy ph oj l ok ol">function test(arg) {<br/>  // Scope 2<br/>  arg = "Something else";<br/>}</span><span id="a6a4" class="nt me iq ns b gy ph oj l ok ol">test(a)<br/>test(b)</span></pre><p id="65b9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> ➡️对象被作为引用传递，</strong>我们将通过闭包与突变和赋值来研究这一点。</p><h2 id="7796" class="nt me iq bd mf nu nv dn mj nw nx dp mn lj ny nz mp ln oa ob mr lr oc od mt iw bi translated">JavaScript中带闭包的赋值与变异</h2><p id="88f5" class="pw-post-body-paragraph la lb iq lc b ld mv ka lf lg mw kd li lj mx ll lm ln my lp lq lr mz lt lu lv ij bi translated">因为闭包和回调是JavaScript编程和事件驱动编程的核心，所以你会在很多时候依赖这些东西。</p><p id="a419" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在下面的示例中，有一个quick NodeJS片段，它将模拟向注册了主题的用户显示消息的行为。但是这段代码有点动态:</p><ul class=""><li id="32a2" class="na nb iq lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated">在程序执行过程中，订阅的用户会发生变化。我每隔10秒使用一个<code class="fe np nq nr ns b">setInterval</code>函数<strong class="lc ja">来模拟这个。有时添加一个感兴趣的用户，有时删除一个。</strong></li><li id="4b14" class="na nb iq lc b ld nk lg nl lj nm ln nn lr no lv nf ng nh ni bi translated">每秒钟，我们都会向订阅用户发送一条随机消息。</li></ul><p id="1b4b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在文件的最后，有两个<code class="fe np nq nr ns b">setInterval</code>函数负责改变我们的订阅用户数组。由于名为<code class="fe np nq nr ns b">startListeningForMessages</code>的闭包函数，我们还创建了一个可变范围。</p><p id="d34c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">让我们试试代码</strong></p><p id="4ec0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">请随意使用你自己的NodeJS环境或者这个托管在云中的环境:<a class="ae om" href="https://repl.it/languages/nodejs" rel="noopener ugc nofollow" target="_blank">https://repl.it/languages/nodejs</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pi pj l"/></div></figure><p id="6636" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">脚本使用说明</strong></p><p id="5fe1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">尝试在第一个<code class="fe np nq nr ns b">setInterval</code>取消注释的情况下启动程序，然后反转并取消注释第二个，并注释第一个。</p><p id="1e92" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你看出区别了吗？</p><h2 id="ebd3" class="nt me iq bd mf nu nv dn mj nw nx dp mn lj ny nz mp ln oa ob mr lr oc od mt iw bi translated">说明</h2><ul class=""><li id="4e27" class="na nb iq lc b ld mv lg mw lj pk ln pl lr pm lv nf ng nh ni bi translated"><strong class="lc ja">在第一个区间</strong>中，什么也没有显示。那是因为我们在替换数组的引用。即使作为引用传递了<code class="fe np nq nr ns b">listeningUsers</code>自变量仍然指向旧的<code class="fe np nq nr ns b">interestedUsers</code>指针引用。这样<code class="fe np nq nr ns b">interestedUsers</code>被重新分配，而旧的<code class="fe np nq nr ns b">interestedUsers</code>仍然存在，但不能被垃圾收集，因为引用仍然存在，也不能在闭包范围之外被访问。这可能是内存泄漏，但在我们的例子中，情况更糟，因为我们在兴趣列表中不再同步。</li><li id="aff4" class="na nb iq lc b ld nk lg nl lj nm ln nn lr no lv nf ng nh ni bi translated">在第二个间歇，事情发生了变化。这是因为我们使用了数组对象的变异方法。这样，引用不会改变，但数组中的元素会改变。通过这样做，我们不会因为闭包函数而丢失上下文。</li></ul><p id="b47f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就是为什么你应该总是问自己是否应该改变或重新分配一些东西，并在使用范围外变量时考虑副作用。</p><h2 id="9d27" class="nt me iq bd mf nu nv dn mj nw nx dp mn lj ny nz mp ln oa ob mr lr oc od mt iw bi translated"><strong class="ak">这也适用于物体！</strong></h2><p id="a472" class="pw-post-body-paragraph la lb iq lc b ld mv ka lf lg mw kd li lj mx ll lm ln my lp lq lr mz lt lu lv ij bi translated">对于一个几乎相同的对象，如果你在闭包函数中编辑了对象的一个键，这是可以的，因为你仍然指向同一个引用。但是如果你在函数内部重新赋值对象，你就失去了引用。</p><h1 id="04ce" class="md me iq bd mf mg on mi mj mk oo mm mn kf op kg mp ki oq kj mr kl or km mt mu bi translated">React hooks呢？</h1><p id="fd72" class="pw-post-body-paragraph la lb iq lc b ld mv ka lf lg mw kd li lj mx ll lm ln my lp lq lr mz lt lu lv ij bi translated">同样的事情在这里，因为只有当调用setter后<code class="fe np nq nr ns b">Object.is</code>比较返回false时<code class="fe np nq nr ns b">useState</code>才会导致重新渲染。如果你使用<code class="fe np nq nr ns b">useState</code>而不改变引用，你的UI将不会得到更新。</p><p id="c78f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就是为什么我们通常在状态改变时请求useEffect和clean closure作用域，但有时这样做，在用新值取消订阅/重新订阅期间，您可能会丢失事件侦听器中的一些事件。当有对象状态或数组状态时，这也很重要</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pn pj l"/></div></figure></div></div>    
</body>
</html>