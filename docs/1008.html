<html>
<head>
<title>Working With Images in Nativescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nativescript中的图像</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/working-with-images-in-nativescript-4a7b64faaf38?source=collection_archive---------8-----------------------#2020-01-13">https://javascript.plainenglish.io/working-with-images-in-nativescript-4a7b64faaf38?source=collection_archive---------8-----------------------#2020-01-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="833f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在之前的一篇文章<a class="ae ki" href="https://medium.com/swlh/stateful-nativescript-vue-camera-gallery-app-with-font-awesome-37bd7d19c16" rel="noopener"/>中，我讲述了如何创建一个Nativescript Vue图像库应用程序，该应用程序使用设备摄像头拍摄照片，在一个简单的图像库中显示这些照片，使用Font Awesome图标，并在应用程序运行期间维护图像库的状态。这篇文章将展示如何扩展该应用程序以允许从设备添加图像，以及如何使用Nativescript在您自己的应用程序中调整大小、保存和编辑图像。</p><p id="18b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Nativescript 6.3.2是最近发布的，将是本文使用的版本(如果您要在这里编写自己的副本或Github repo，请使用该版本，以避免因破坏版本更改而出错)。使用以下命令克隆上一篇文章中的相机图库应用程序:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="29df" class="ks kt in ko b gy ku kv l kw kx">git clone https://github.com/drangelod/nsimagegallery6 ns6images</span></pre><p id="74a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更改该目录，并使用<code class="fe ky kz la ko b">tns doctor</code>确保您的Nativescript应用程序环境正常。您会收到一些警告，要求您更新Nativescript平台和核心模块包以匹配当前的CLI版本。</p><figure class="kj kk kl km gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lb"><img src="../Images/4a824afcc77974da2650a713019395cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d872tqJB1dPuVxfI.png"/></div></div></figure><p id="d00f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以通过编辑<code class="fe ky kz la ko b">package.json</code>来完成。使用像<a class="ae ki" href="https://www.npmjs.com/package/npm-check-updates" rel="noopener ugc nofollow" target="_blank"> NCU </a>这样的工具，我们会看到一些其他的包可以更新:</p><figure class="kj kk kl km gt lc gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/7725e1f55320f0cfddab967b49e46ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/0*vImmc5dnAl3uFvdT.png"/></div></figure><p id="91c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于这篇文章，我们将只更新<code class="fe ky kz la ko b">tns-core-modules</code>和<code class="fe ky kz la ko b">nativescript-dev-webpack</code>到他们的最新版本。编辑完package.json后，让NPM通过运行<code class="fe ky kz la ko b">npm i</code>来更新软件包。您会收到关于<code class="fe ky kz la ko b">nativescript-dev-webpack</code>某些更改的警告，因此您还需要运行<code class="fe ky kz la ko b">./node_modules/.bin/update-ns-webpack --configs</code>。完成所有这些后，在模拟器上运行该应用程序，以确保图像库正常工作。</p><figure class="kj kk kl km gt lc gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/8918a300e4e36627d84a7771a923376a.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*l8JTsDpiR6gtoE6d_BUiOQ.png"/></div></figure><h1 id="3cff" class="ll kt in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">在应用程序中使用设备图像</h1><p id="0606" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">图库应用程序允许您使用设备摄像头拍摄新照片，但最好在设备上添加已有图像。为了使用设备图像，Nativescript有<a class="ae ki" href="https://github.com/NativeScript/nativescript-imagepicker" rel="noopener ugc nofollow" target="_blank">Nativescript-image picker</a>插件，允许我们从设备中选择一个图像来使用。使用CLI命令安装此插件:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="042a" class="ks kt in ko b gy ku kv l kw kx">tns plugin add nativescript-imagepicker</span></pre><p id="390c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要为安卓和iOS配置文件添加一些权限，因为在将应用程序发布到应用商店之前，您需要这些权限。编辑<code class="fe ky kz la ko b">app/App_Resources/Android/src/main/AndroidManifest.xml</code>并将以下权限请求添加到其他条目(如果尚未存在):</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="cd5a" class="ks kt in ko b gy ku kv l kw kx">&lt;uses-permission android:name="android.permission.CAMERA"/&gt;<br/>&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;<br/>&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;</span></pre><p id="5589" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在新版本的Android上使用这个插件也会遇到问题，所以在<code class="fe ky kz la ko b">&lt;application</code>标签中添加以下内容:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="4fff" class="ks kt in ko b gy ku kv l kw kx">android:requestLegacyExternalStorage="true"</span></pre><p id="16fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，打开<code class="fe ky kz la ko b">app/App_Resources/iOS/Info.plist</code>文件，添加以下iOS权限(如果还没有的话):</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="a5f3" class="ks kt in ko b gy ku kv l kw kx">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt; <br/>&lt;string&gt;Take pictures for the gallery&lt;/string&gt;<br/>&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;<br/>&lt;string&gt;Add images from your device&lt;/string&gt;</span></pre><p id="1bc3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加了权限后，现在我们将编辑<code class="fe ky kz la ko b">Home.vue</code>组件来添加一个新按钮和它将调用的使用图像拾取器插件的函数。我们将修改<code class="fe ky kz la ko b">Home.vue</code>中的XML并删除原来的<code class="fe ky kz la ko b">Label</code>元素，然后添加一个新的<code class="fe ky kz la ko b">GridLayout</code>来并排显示两个按钮:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="db33" class="ks kt in ko b gy ku kv l kw kx">&lt;GridLayout columns="*,*" rows="auto" verticalAlignment="center"&gt;<br/> 	&lt;Label col="0" row="0" text.decode="&amp;#xf030; " @tap="takePicture" class="take-picture-icon fa" /&gt;<br/>	&lt;Label col="1" row="0" text.decode="&amp;#xf1c5; " @tap="chooseImage" class="take-picture-icon fa" /&gt;<br/>&lt;/GridLayout&gt;</span></pre><p id="b85a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将新插件的导入添加到<code class="fe ky kz la ko b">&lt;script&gt;</code>部分的顶部:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="f604" class="ks kt in ko b gy ku kv l kw kx">const imagepicker = require("nativescript-imagepicker");</span></pre><p id="38f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以将<code class="fe ky kz la ko b">chooseImage</code>函数添加到<code class="fe ky kz la ko b">methods:{</code>对象中，它将调用插件让用户从设备中选择一幅图像，然后将所选图像添加到图库中:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="4275" class="ks kt in ko b gy ku kv l kw kx">chooseImage(){<br/>    let that = this<br/>    let context = imagepicker.create({ mode: "single" });<br/>    context<br/>        .authorize()<br/>        .then(() =&gt; {<br/>            return context.present();<br/>        })<br/>        .then(selection =&gt; {<br/>            const imageAsset = selection.length &gt; 0 ? selection[0] : null;<br/>            imageSourceModule.fromAsset(imageAsset).then(<br/>                savedImage =&gt; {<br/>                    let filename = "image" + "-" + new Date().getTime() + ".png";<br/>                    let folder = fsModule.knownFolders.documents();<br/>                    let path = fsModule.path.join(folder.path, filename);<br/>                    savedImage.saveToFile(path, "png");<br/>                    var loadedImage = imageSourceModule.fromFile(path);<br/>                    loadedImage.filename = filename;<br/>                    loadedImage.note = "";<br/>                    that.arrayPictures.unshift(loadedImage);<br/>                    that.storeData();<br/>                },<br/>                err =&gt; {<br/>                    console.log("Failed to load from asset");<br/>                    console.log(err)<br/>                }<br/>            );<br/>        })<br/>        .catch(err =&gt; {<br/>            console.log(err);<br/>        });<br/>}</span></pre><p id="aedd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行应用程序，点击右侧按钮使用图像拾取器，并从您的设备中选择一幅图像添加到图库。你可以从像NASA这样的网站下载图片进行测试，尽管你会注意到大图片比小图片加载和渲染的时间要长得多。如果你将应用程序图像上传到服务器，或者稍后再次下载它们，大图像尺寸尤其成问题，因为你不需要在手机上显示大图像。相反，让我们努力减少从相机或设备获得的图像的大小/尺寸，以获得更流畅的应用程序体验。</p><figure class="kj kk kl km gt lc gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/987bd78e43fbb5008bfa4b1bf18f7834.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/0*2F4uVK-CB8MNEJ0i.png"/></div></figure><h1 id="85e8" class="ll kt in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用Nativescript调整图像大小</h1><p id="a950" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">在<a class="ae ki" href="https://blog.angelengineering.com/resizing-images/" rel="noopener ugc nofollow" target="_blank">的另一篇文章</a>中，我讨论了如何使用Nativescript的本地代码来更精确地控制图像尺寸/大小，以避免过大的图像文件，例如现代手机相机通常产生的图像文件。我们将在这里应用相同的概念，以确保来自相机和图像拾取器插件的图像在大于所选阈值时被缩小。在这篇文章中，我们将限制图库图像的大小，使较大的尺寸最大为500像素，而另一个尺寸缩小以保持原始图像的纵横比。如果两个维度都超过500像素，每个平台都需要适当的本机代码调用来调整图像拾取器插件返回的图像的大小。</p><p id="94cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于iOS和Android，我们需要检测两个维度是否都大于500像素，然后计算缩小宽度和高度所需的缩放比例，以使较大的维度为500像素。要在Nativescript中做到这一点，我们首先需要将插件返回的<code class="fe ky kz la ko b">ImageAsset</code>转换为<code class="fe ky kz la ko b">ImageSource</code>，从中我们可以获得图像的尺寸。对于每个平台，在保存到设备文件系统之前，将使用图形库的本地调用来调整<code class="fe ky kz la ko b">ImageSource</code>的大小，并像以前一样使用Nativescript调用来声明。新的<code class="fe ky kz la ko b">chooseImage</code>功能将如下所示:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="2ab8" class="ks kt in ko b gy ku kv l kw kx">    chooseImage() {<br/>            let that = this<br/>            let context = imagepicker.create({ mode: "single" });<br/>            context<br/>                .authorize()<br/>                .then(() =&gt; {<br/>                    return context.present();<br/>                })<br/>                .then(selection =&gt; {<br/>                    const imageAsset = selection.length &gt; 0 ? selection[0] : null;<br/>                    imageAsset.options.autoScaleFactor = false;<br/>                    imageAsset.options.keepAspectRatio = true;<br/>                    imageSourceModule<br/>                        .fromAsset(imageAsset)<br/>                        .then(imageSource =&gt; {<br/>                            var newheight = imageSource.height,<br/>                                newwidth = imageSource.width<br/>                            if (imageSource.width &gt; 500 &amp;&amp; imageSource.height &gt; 500) {<br/>                                if (imageSource.width &gt; imageSource.height) {<br/>                                    newwidth = 500<br/>                                    newheight = Math.round(500 * (imageSource.height / imageSource.width))<br/>                                } else {<br/>                                    newheight = 500<br/>                                    newwidth = Math.round(500 * (imageSource.width / imageSource.height))<br/>                                }<br/>                            }<br/>                            if (imageSource.width &gt; 500 &amp;&amp; imageSource.height &gt; 500) {<br/>                                if (isAndroid) {<br/>                                    try {<br/>                                        var downsampleOptions = new android.graphics.BitmapFactory.Options();<br/>                                        var bitmap = android.graphics.BitmapFactory.decodeFile(imageAsset.android, null);<br/>                                        var newBitmap = android.graphics.Bitmap.createScaledBitmap(bitmap, newwidth, newheight, true);<br/>                                        imageSource.setNativeSource(newBitmap);<br/>                                        let filename = "image-" + new Date().getTime() + ".jpg";<br/>                                        let folder = fsModule.knownFolders.documents();<br/>                                        let path = fsModule.path.join(folder.path, filename);<br/>                                        imageSource.saveToFile(path, "jpeg");<br/>                                        imageSource.filename = filename;<br/>                                        imageSource.note = "";<br/>                                        that.arrayPictures.unshift(imageSource);<br/>                                        that.storeData();<br/>                                    } catch (err) {<br/>                                        console.error(err);<br/>                                    }<br/>                                } else {<br/>                                    let manager = PHImageManager.defaultManager();<br/>                                    let options = new PHImageRequestOptions();<br/>                                    options.resizeMode = PHImageRequestOptionsResizeMode.Exact;<br/>                                    options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat;<br/>                                    manager.requestImageForAssetTargetSizeContentModeOptionsResultHandler(<br/>                                        imageAsset.ios, { width: newwidth, height: newheight },<br/>                                        PHImageContentModeAspectFill,<br/>                                        options,<br/>                                        function(result, info) {<br/>                                            let filename = "image" + "-" + new Date().getTime() + ".jpg";<br/>                                            let folder = fsModule.knownFolders.documents();<br/>                                            let path = fsModule.path.join(folder.path, filename);<br/>                                            let newasset = new imageAssetModule.ImageAsset(result);<br/>                                            newasset.options.autoScaleFactor = false;<br/>                                            newasset.options.keepAspectRatio = true;<br/>                                            newasset.height = newheight<br/>                                            newasset.width = newwidth<br/>                                            imageSourceModule<br/>                                                .fromAsset(newasset)<br/>                                                .then(newimageSource =&gt; {<br/>                                                    newimageSource.saveToFile(<br/>                                                        path,<br/>                                                        "jpeg"<br/>                                                    );<br/>                                                    newimageSource.filename = filename;<br/>                                                    newimageSource.note = "";<br/>                                                    that.arrayPictures.unshift(newimageSource);<br/>                                                    that.storeData();<br/>                                                });<br/>                                        }<br/>                                    );<br/>                                }<br/>                            } else {<br/>                                let folder = fsModule.knownFolders.documents();<br/>                                let filename = "image-" + new Date().getTime() + ".jpg";<br/>                                let path = fsModule.path.join(folder.path, filename);<br/>                                imageSource.saveToFile(path, "jpeg");<br/>                                imageSource.filename = filename;<br/>                                imageSource.note = "";<br/>                                that.arrayPictures.unshift(imageSource);<br/>                                that.storeData();<br/>                            }<br/>                        })<br/>                        .catch(err =&gt; {<br/>                            console.error(err);<br/>                        });<br/>                });<br/>        },</span></pre><p id="08f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将看到我们添加了一个新的部分，该部分检测两个维度是否都大于500，并计算图像的缩放高度和宽度，以便较大的维度最大为500像素。然后，我们使用<code class="fe ky kz la ko b">isAndroid</code>和<code class="fe ky kz la ko b">isIOS</code>平台库函数来确定正在使用哪种类型的设备(将<code class="fe ky kz la ko b">import { isAndroid, isIOS } from "tns-core-modules/platform";</code>添加到您的导入部分以使用这些助手)。对于Android设备，我们本地调用<code class="fe ky kz la ko b">android.graphics.Bitmap.createScaledBitmap</code>来调整图像的大小。对于iOS，我们调用<code class="fe ky kz la ko b">PHImageManager.requestImageForAssetTargetSizeContentModeOptionsResultHandler</code>来缩放图像。需要注意的一点是，iOS库调用将返回缩放图像的文件名，而不是图像对象，因此我们有一个额外的步骤来从文件中加载图像，然后将其保存在我们自己的app documents文件夹中进行处理。</p><h1 id="6cc4" class="ll kt in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">调整设备相机图像的大小</h1><p id="7807" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">正如我在上一篇关于在Nativescript中处理图像的文章中提到的，相机插件通常可以很好地将相机图像调整到所要求的最大尺寸，特别是对于iOS，尽管在Android上不太可靠。我们将在<code class="fe ky kz la ko b">takePicture</code>函数中添加类似的代码，用于缩放那些相机插件无法自动调整大小的设备的大图像。</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="bef9" class="ks kt in ko b gy ku kv l kw kx">takePicture() {<br/>            let that = this;<br/>            cameraModule<br/>                .takePicture({<br/>                    width: 500, //these are in device independent pixels<br/>                    height: 500, //only one will be respected depending on os/device if<br/>                    keepAspectRatio: true, //    keepAspectRatio is enabled.<br/>                    saveToGallery: false //Don't save a copy in local gallery, ignored by some Android devices<br/>                })<br/>                .then(imageAsset =&gt; {<br/>                    imageAsset.options.autoScaleFactor = false;<br/>                    imageAsset.options.keepAspectRatio = true;<br/>                    imageSourceModule<br/>                        .fromAsset(imageAsset)<br/>                        .then(imageSource =&gt; {<br/>                            var ratio = 1,<br/>                                newheight = imageSource.height,<br/>                                newwidth = imageSource.width<br/>                            if (imageSource.width &gt; 500 &amp;&amp; imageSource.height &gt; 500) {<br/>                                if (imageSource.width &gt; imageSource.height) {<br/>                                    newwidth = 500<br/>                                    newheight = Math.round(500 * (imageSource.height / imageSource.width))<br/>                                } else {<br/>                                    newheight = 500<br/>                                    newwidth = Math.round(500 * (imageSource.width / imageSource.height))<br/>                                }<br/>                            }<br/>                            if (imageSource.width &gt; 500 &amp;&amp; imageSource.height &gt; 500) {<br/>                                if (isAndroid) {<br/>                                    try {<br/>                                        var downsampleOptions = new android.graphics.BitmapFactory.Options();<br/>                                        var bitmap = android.graphics.BitmapFactory.decodeFile(imageAsset.android, null);<br/>                                        var newBitmap = android.graphics.Bitmap.createScaledBitmap(bitmap, newwidth, newheight, true);<br/>                                        imageSource.setNativeSource(newBitmap);<br/>                                        let filename = "image-" + new Date().getTime() + ".jpg";<br/>                                        let folder = fsModule.knownFolders.documents();<br/>                                        let path = fsModule.path.join(folder.path, filename);<br/>                                        imageSource.saveToFile(path, "jpeg");<br/>                                        imageSource.filename = filename;<br/>                                        imageSource.note = "";<br/>                                        that.arrayPictures.unshift(imageSource);<br/>                                        that.storeData();<br/>                                    } catch (err) {<br/>                                        console.error(err);<br/>                                    }<br/>                                } else {<br/>                                    let manager = PHImageManager.defaultManager();<br/>                                    let options = new PHImageRequestOptions();<br/>                                    options.resizeMode =<br/>                                        PHImageRequestOptionsResizeMode.Exact;<br/>                                    options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat;<br/>                                    manager.requestImageForAssetTargetSizeContentModeOptionsResultHandler(<br/>                                        imageAsset.ios, { width: newwidth, height: newheight },<br/>                                        PHImageContentModeAspectFill,<br/>                                        options,<br/>                                        function(result, info) {<br/>                                            let folder = fsModule.knownFolders.documents();<br/>                                            let path = fsModule.path.join(folder.path, filename);<br/>                                            let filename = "image-" + new Date().getTime() + ".jpg";<br/>                                            let newasset = new imageAssetModule.ImageAsset(result);<br/>                                            imageSourceModule<br/>                                                .fromAsset(newasset)<br/>                                                .then(newimageSource =&gt; {<br/>                                                    newimageSource.saveToFile(path, "jpeg");<br/>                                                    newimageSource.filename = filename;<br/>                                                    newimageSource.note = "";<br/>                                                    that.arrayPictures.unshift(newimageSource);<br/>                                                    that.storeData();<br/>                                                });<br/>                                        }<br/>                                    );<br/>                                }<br/><br/>                            } else {<br/>                                let filename = "image" + "-" + new Date().getTime() + ".jpg";<br/>                                let folder = fsModule.knownFolders.documents();<br/>                                let path = fsModule.path.join(folder.path, filename);<br/>                                imageSource.saveToFile(path, "jpeg");<br/>                                imageSource.filename = filename;<br/>                                imageSource.note = "";<br/>                                that.arrayPictures.unshift(imageSource);<br/>                                that.storeData();<br/>                            }<br/>                        })<br/>                })<br/>        },</span></pre><h1 id="3620" class="ll kt in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">将图像保存到您的设备</h1><p id="ace0" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">既然我们能够将缩放后的图像从相机或设备加载到我们的图库应用程序中，让我们允许用户将图片从图库保存到设备的照片图库中。这将需要允许应用程序写入设备存储的权限，以及每个平台的一些本地调用。因为我们已经在第一篇文章的<code class="fe ky kz la ko b">Home.vue</code>中添加了访问设备相机和照片库的权限请求，所以我们不需要在这里做任何其他事情，尽管我们将使用一个本地调用在iOS上做另一个检查，以显示如果你没有在应用程序中使用相机和图像拾取器插件，它是如何完成的。在Android上，在这种情况下访问设备存储之前，可以使用<code class="fe ky kz la ko b">nativescript-permissions</code>插件请求权限。</p><p id="9b56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将更新<code class="fe ky kz la ko b">app/components/ImageDetails.vue</code> XML和脚本部分为:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="07c3" class="ks kt in ko b gy ku kv l kw kx">&lt;template&gt;<br/>    &lt;Page class="page" ref="page" actionBarHidden="false" backgroundSpanUnderStatusBar="true"&gt;<br/>        &lt;ActionBar class="action-bar" title="Picture Details"&gt;<br/>            &lt;NavigationButton text="Done" android.systemIcon="ic_menu_back" @tap="$navigateBack()" /&gt;<br/>            &lt;Label text.decode="&amp;#xf019;" @tap="downloadImage()" class="take-picture-icon fa" /&gt;<br/>        &lt;/ActionBar&gt;<br/>        &lt;ScrollView orientation="vertical"&gt;<br/>            &lt;StackLayout&gt;<br/>                &lt;Image class="picture-full" stretch="aspectFit" :src="curImage" /&gt;<br/>                &lt;GridLayout columns="*,*" rows="60,30,*,300"&gt;<br/>                    &lt;StackLayout col="1" row="0" class="delete-picture-icon-wrapper" @tap="deletePicture"&gt;<br/>                        &lt;Label verticalAlignement="bottom" text="delete" class="delete-picture-icon"&gt;&lt;/Label&gt;<br/>                    &lt;/StackLayout&gt;<br/>                    &lt;Label col="0" colSpan="2" row="1" text="Note:" class="section-label" /&gt;<br/>                    &lt;TextView col="0" colSpan="2" row="2" class="text-picture" hint="Add a note for this picture here" editable="true" v-model="navObject.image.note" /&gt;<br/>                    &lt;Label col="0" colSpan="2" row="3" text="" /&gt;<br/>                &lt;/GridLayout&gt;<br/>            &lt;/StackLayout&gt;<br/>        &lt;/ScrollView&gt;<br/>    &lt;/Page&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>const imageSourceModule = require("tns-core-modules/image-source");<br/>const imageAssetModule = require("tns-core-modules/image-asset/image-asset");<br/>const fsModule = require("tns-core-modules/file-system");<br/>const applicationModule = require("application");<br/>import { isAndroid, isIOS } from "tns-core-modules/platform";<br/>export default {<br/>    name: "image-details-page",<br/>    data() {<br/>        return { curImage: ''};<br/>    },<br/>    props: {<br/>        navObject: {<br/>            type: Object<br/>        },<br/>    },<br/>    components: {},<br/>    computed: {},<br/>    created() {},<br/>    beforeDestroy() {<br/>        this.navObject.storeData()<br/>    },<br/>    mounted() {<br/>    	this.curImage = this.navObject.image<br/>    },<br/>    methods: {<br/>        deletePicture() {<br/>            let pictureIndex = this.navObject.arrayPictures.indexOf(this.navObject.image);<br/>            this.navObject.arrayPictures.splice(pictureIndex, 1);<br/>            this.$navigateBack()<br/>        },<br/>        downloadImage() {<br/>            let that = this<br/>            let folder = fsModule.knownFolders.documents();<br/>            let path = fsModule.path.join(folder.path, this.navObject.image.filename);<br/>            let imageSource = imageSourceModule.fromFile(path)<br/>            if (isIOS) {<br/>                PHPhotoLibrary.requestAuthorization((result) =&gt; {<br/>                    if (result === PHAuthorizationStatus.Authorized) {<br/>                        var CompletionTarget = NSObject.extend({<br/>                            "thisImage:hasBeenSavedInPhotoAlbumWithError:usingContextInfo:": function(<br/>                                image,<br/>                                error,<br/>                                context<br/>                            ) {<br/>                                if (error) {<br/>                                    console.error("Unable to save to library, please try again.")<br/>                                }<br/>                            }<br/>                        }, {<br/>                            exposedMethods: {<br/>                                "thisImage:hasBeenSavedInPhotoAlbumWithError:usingContextInfo:": {<br/>                                    returns: interop.types.void,<br/>                                    params: [UIImage, NSError, interop.Pointer]<br/>                                }<br/>                            }<br/>                        });<br/>                        var completionTarget = CompletionTarget.new();<br/>                        UIImageWriteToSavedPhotosAlbum(<br/>                            imageSource.ios,<br/>                            completionTarget,<br/>                            "thisImage:hasBeenSavedInPhotoAlbumWithError:usingContextInfo:",<br/>                            null<br/>                        );<br/>                        console.log("Image saved to device")<br/>                    } else {<br/>                        if (isIOS) alert({ title: "Save Failed!", okButtonText: "OK", message: "Allow permission in Settings &gt; Privacy &gt; Photos to save an image to your device!" })<br/>                        else alert("Save Failed! No permissions to save to this device.")<br/>                    }<br/>                });<br/>            } else {<br/>                function broadCast(imageFile) {<br/>                    var mediaScanIntent = new android.content.Intent(<br/>                        android.content.Intent.ACTION_MEDIA_SCANNER_SCAN_FILE<br/>                    );<br/>                    var contentUri = android.net.Uri.fromFile(imageFile);<br/>                    mediaScanIntent.setData(contentUri);<br/>                    applicationModule.android.foregroundActivity.sendBroadcast(<br/>                        mediaScanIntent<br/>                    );<br/>                    alert("Image saved to device")<br/>                }<br/>                var folderPath = android.os.Environment.getExternalStoragePublicDirectory(<br/>                    android.os.Environment.DIRECTORY_DOWNLOADS<br/>                ).toString();<br/>                let filename = "galleryimg_" + new Date().getTime() + ".jpg";<br/>                let savepath = fsModule.path.join(folderPath, filename);<br/>                var saved = imageSource.saveToFile(savepath, "jpeg");<br/>                if (saved) {<br/>                    broadCast(new java.io.File(savepath));<br/>                } else {<br/>                    alert("Error: Unable to save file!");<br/>                }<br/>            }<br/>        },<br/>    }<br/>};<br/>&lt;/script&gt;</span></pre><p id="47b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看XML部分，您会看到添加了一个新的字体图标按钮，它调用了一个新的<code class="fe ky kz la ko b">downloadImage()</code>函数。在脚本部分的顶部还添加了一些导入，以允许新功能与设备映像和文件系统一起工作。<code class="fe ky kz la ko b">downloadImage()</code>函数首先从本地应用文件系统加载映像，然后在每个平台上使用它进行本地调用。对于Android，我们广播一个<code class="fe ky kz la ko b">ACTION_MEDIA_SCANNER_SCAN_FILE</code>意图，要求操作系统将当前图像保存到设备。出错或完成时，会向用户显示一个警告，你可以在一个真正的应用程序中用toast消息来替换它。对于iOS，首先，在调用<code class="fe ky kz la ko b">UIImageWriteToSavedPhotosAlbum</code>将当前图像保存到iOS相册之前，我们使用<code class="fe ky kz la ko b">PHPhotoLibrary.requestAuthorization</code>检查授权。这里我们不通知iOS上的用户，因为使用本机代码进行图形相关的Nativescript调用会使应用程序崩溃，所以当图像保存到设备时，您必须使用另一种方法通知用户。</p><figure class="kj kk kl km gt lc gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f7ee3a5a3412a6193903ea8a1a6284e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*thjgJhBwF19r-nO1.png"/></div></figure><h1 id="9c7d" class="ll kt in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">在Nativescript中编辑图像</h1><p id="d050" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">如果你也想让用户编辑图像，你可以在你的应用程序中使用<code class="fe ky kz la ko b">nativescript-photo-editor</code>插件。使用CLI添加它，方法是:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="1ae5" class="ks kt in ko b gy ku kv l kw kx">tns plugin add nativescript-photo-editor</span></pre><p id="eac0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将该插件的以下导入添加到<code class="fe ky kz la ko b">ImageDetails.vue</code>的脚本部分:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="88a3" class="ks kt in ko b gy ku kv l kw kx">import { PhotoEditor, PhotoEditorControl } from "nativescript-photo-editor"; <br/>const photoEditor = new PhotoEditor();</span></pre><p id="a2a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将在当前呈现删除按钮的GridLayout中添加一个新的编辑按钮:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="9eab" class="ks kt in ko b gy ku kv l kw kx">&lt;StackLayout col="0" row="0" class="delete-picture-icon-wrapper" @tap="editImage"&gt;<br/>     &lt;Label verticalAlignement="bottom" text="edit" class="delete-picture-icon"&gt;&lt;/Label&gt;<br/>&lt;/StackLayout&gt;</span></pre><p id="1ce0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加由该按钮调用的新的<code class="fe ky kz la ko b">editImage()</code>功能:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="82e9" class="ks kt in ko b gy ku kv l kw kx">editImage() {<br/>            let that = this<br/>            let folder = fsModule.knownFolders.documents();<br/>            let path = fsModule.path.join(folder.path, this.navObject.image.filename);<br/>            photoEditor<br/>                .editPhoto({ imageSource: this.curImage })<br/>                .then(newImage =&gt; {<br/>                    newImage.filename = that.curImage.filename<br/>                    newImage.note = that.curImage.note<br/>                    that.curImage = newImage;<br/>                    let pictureIndex = that.navObject.arrayPictures.indexOf(that.navObject.image);<br/>                    that.navObject.arrayPictures.splice(pictureIndex, 1, newImage);<br/>                    newImage.saveToFile(path, "jpeg");<br/>                })<br/>                .catch(e =&gt; {<br/>                    console.error(e);<br/>                });<br/>        },</span></pre><p id="9e86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数将当前图像发送到插件进行编辑。如果用户保存编辑过的图像，那么这个新图像将被分配与原始图像相同的文件名和注释，并且替换当前页面上、状态数组中以及文件系统上的原始图像。在iOS模拟器上运行应用程序，点击编辑按钮，你会看到运行中的插件。</p><figure class="kj kk kl km gt lc gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1cc70230465b380d8c10d3ccf935cb62.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/0*B9bywtwzk0tmznxC.png"/></div></figure><p id="cb18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你在像iPhone XS这样的较新的iOS设备上运行，你会遇到一个小问题，插件显示为模态而不是全屏，由于干扰了滚动处理程序，这会干扰图像的绘制。要解决这个问题，请编辑<code class="fe ky kz la ko b">node_modules/nativescript-photo-editor/photo-editor.ios.js</code>并将下面一行添加到<code class="fe ky kz la ko b">PhotoEditor.prototype.editPhoto</code>中，并使用其他viewController设置:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="88df" class="ks kt in ko b gy ku kv l kw kx">viewController.modalPresentationStyle = 0;</span></pre><h1 id="9467" class="ll kt in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">搞定了。</h1><p id="9711" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">这个帖子到此为止。如果你想下载最终的源文件，你可以在<a class="ae ki" href="https://github.com/drangelod/ns6images" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="d8de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mx">原载于2020年1月13日https://blog.angelengineering.com</em><a class="ae ki" href="https://blog.angelengineering.com/nativescript-images/" rel="noopener ugc nofollow" target="_blank"><em class="mx"/></a><em class="mx">。</em></p></div></div>    
</body>
</html>