<html>
<head>
<title>Authentication Handling in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的身份验证处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/authentication-in-react-caf2abfa0494?source=collection_archive---------0-----------------------#2020-05-03">https://javascript.plainenglish.io/authentication-in-react-caf2abfa0494?source=collection_archive---------0-----------------------#2020-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="edd9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用钩子和上下文</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bf502d7e19380d7ee34876e1649802f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CLEzQlUx6GvvspUz"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@mr_williams_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Micah Williams</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5699" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用户认证是现代前端应用的主要支柱之一</h1><p id="f710" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将在这里创建一个React应用程序，并在此过程中添加身份验证部分，最终完成自动登录和自动注销。</p><h2 id="7e8e" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">基本认证</h2><p id="7b5b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们的react应用程序将有一个App组件，它将托管另外两个组件。一个是认证逻辑，另一个是受保护的组件，用户只有通过认证后才能看到。</p><h2 id="5d97" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">App.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="d3f3" class="mk kx iq mx b gy nb nc l nd ne">import react from ‘react’</span><span id="58da" class="mk kx iq mx b gy nf nc l nd ne">export default function App(){<br/>   return (<br/>       &lt;div class="center"&gt;<br/>          &lt;Authentication/&gt;<br/>          &lt;ProtectedResource /&gt;<br/>       &lt;/div&gt;<br/>   )<br/>}</span></pre><p id="f188" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">这里是<strong class="lq ir">认证</strong>和<strong class="lq ir">保护资源</strong>组件的代码。</p><h2 id="4a18" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">认证. js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="8f53" class="mk kx iq mx b gy nb nc l nd ne">import react from ‘react’</span><span id="3c67" class="mk kx iq mx b gy nf nc l nd ne">export default function Authentication(){<br/>   return (<br/>       &lt;&gt;<br/>          &lt;button className="login"&gt;Login&lt;/button&gt;<br/>          &lt;button className="logout"&gt;Logout&lt;/button&gt;<br/>       &lt;/&gt;<br/>   )<br/>}</span></pre><h2 id="8e41" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">protectedPage.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6d18" class="mk kx iq mx b gy nb nc l nd ne">import react from ‘react’</span><span id="9ed0" class="mk kx iq mx b gy nf nc l nd ne">export default function ProtectedResource(){<br/>   return (<br/>       &lt;h1&gt;I am a authenticated resource&lt;/h1&gt;<br/>   )<br/>}</span></pre><p id="68c9" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">目前这两个组件都是可见的，因为没有合适的逻辑。</p><p id="e1b1" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">让我们开始一点一点地添加我们的身份验证。由于我们将在多个组件中需要认证信息，我们可以利用react中的一个概念，即<strong class="lq ir">上下文</strong>。</p><blockquote class="nl nm nn"><p id="34c4" class="lo lp no lq b lr ng jr lt lu nh ju lw np ni lz ma nq nj md me nr nk mh mi mj ij bi translated">上下文允许我们在应用程序的任何组件之间传递数据，而不需要使用props。</p></blockquote><p id="bb55" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">我们的上下文应该是这样的:</p><h2 id="348f" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">上下文. js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c7e0" class="mk kx iq mx b gy nb nc l nd ne">import { createContext } from “react”;</span><span id="4692" class="mk kx iq mx b gy nf nc l nd ne">export const AuthContext = createContext({<br/>    isLoggedIn: false,<br/>    token: null,<br/>    login: () =&gt; {},<br/>    logout: () =&gt; {}<br/>});</span></pre><p id="effa" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">我们在这里定义了几个属性，一旦用户登录或注销，我们将在App.js文件中设置这些属性。</p><p id="9c4b" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">这就是我们如何在App.js中使用AuthContext，方法是像下面这样导入它:</p><h2 id="450f" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">App.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="3f85" class="mk kx iq mx b gy nb nc l nd ne">import react from ‘react’<br/>import {AuthContext} from ‘./context’;</span><span id="2b54" class="mk kx iq mx b gy nf nc l nd ne">export default function App(){<br/>   return (<br/>       &lt;AuthContext.Provider&gt;<br/>          &lt;Authentication/&gt;<br/>          &lt;ProtectedResource /&gt;<br/>       &lt;AuthContext.Provider /&gt;<br/>   )<br/>}</span></pre><p id="b861" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">用AuthContext包装我们的应用程序组件可以确保上下文中的任何内容发生变化时，应用程序中使用上下文的子组件也会发生变化。</p><p id="9a33" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">我们现在可以在应用程序组件中管理一些状态，并将其绑定到我们上下文的值属性，因此当状态发生变化时，我们将能够重新呈现或更新对我们上下文感兴趣的组件。</p><h2 id="a423" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">App.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c216" class="mk kx iq mx b gy nb nc l nd ne">import react, { useState } from ‘react’<br/>import {AuthContext} from ‘./context’;</span><span id="79cc" class="mk kx iq mx b gy nf nc l nd ne">export default function App(){<br/>    const [loggedIn, setLoggedIn] = useState(false);</span><span id="0e26" class="mk kx iq mx b gy nf nc l nd ne">    const login = () =&gt; {<br/>        setLoggedIn(true);<br/>    }</span><span id="e5d2" class="mk kx iq mx b gy nf nc l nd ne">    const logout = () =&gt; {<br/>        setLoggedIn(false);<br/>    }</span><span id="e694" class="mk kx iq mx b gy nf nc l nd ne">return (<br/>       &lt;AuthContext.Provider value={isLoggedIn: isLoggedIn, login: login, logout: logout}&gt;<br/>           &lt;div class="center"&gt;<br/>              &lt;Authentication/&gt;<br/>              &lt;ProtectedResource /&gt;<br/>           &lt;/div&gt;<br/>       &lt;AuthContext.Provider /&gt;<br/>   )<br/>}</span></pre><p id="3919" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">现在，我们来听听其他组件中的上下文变化:</p><h2 id="d45a" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">protectedPage.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="4623" class="mk kx iq mx b gy nb nc l nd ne">import react, { useContext } from ‘react’<br/>import { AuthContext } from "./context";</span><span id="a08c" class="mk kx iq mx b gy nf nc l nd ne">export default function ProtectedResource(){ <br/>   const authContext = useContext(AuthContext);</span><span id="2fe8" class="mk kx iq mx b gy nf nc l nd ne">   return authContext.isLoggedIn &amp;&amp; &lt;h2&gt;Protected resource&lt;/h2&gt;;<br/>}</span></pre><h2 id="cf5c" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">认证. js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="7cf2" class="mk kx iq mx b gy nb nc l nd ne">import react, { useContext } from ‘react’<br/>import { AuthContext } from "./context";</span><span id="b964" class="mk kx iq mx b gy nf nc l nd ne">export default function Authentication(){<br/>   const authContext = useContext(AuthContext);</span><span id="689c" class="mk kx iq mx b gy nf nc l nd ne">   const loginHandler = () =&gt; {<br/>       authContext.login();<br/>   };</span><span id="4e76" class="mk kx iq mx b gy nf nc l nd ne">   const logoutHandler = () =&gt; {<br/>       authContext.logout();<br/>   };</span><span id="9509" class="mk kx iq mx b gy nf nc l nd ne">return (<br/>       &lt;&gt;<br/>          {!authContext.isLoggedIn &amp;&amp; &lt;button className="login" onClick={loginHandler}&gt;Login&lt;/button&gt;}<br/>          {authContext.isLoggedIn &amp;&amp; (&lt;button className="login" onClick={logoutHandler}&gt;Logout&lt;/button&gt;<br/>       &lt;/&gt;<br/>   )<br/>}</span></pre><p id="f405" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">您还会注意到，我在身份验证组件中添加了处理程序，它会改变我们上下文中的值。</p><p id="1daa" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">以下是沙盒中的代码概述:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Basic Authentication</figcaption></figure><p id="55c2" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">以下几点总结了我们迄今取得的成就:</p><ul class=""><li id="533c" class="nu nv iq lq b lr ng lu nh lx nw mb nx mf ny mj nz oa ob oc bi translated">创建了一个包含两个组件“身份验证”和“受保护资源”的应用程序</li><li id="b1f0" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">创建了AuthContext，它包含要与组件共享的身份验证信息</li><li id="3752" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">用上下文和托管状态包装我们的应用程序组件，用于登录和注销</li><li id="e578" class="nu nv iq lq b lr od lu oe lx of mb og mf oh mj nz oa ob oc bi translated">侦听“身份验证”和“受保护的资源”组件中的上下文更改。</li></ul></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="d3e7" class="kw kx iq bd ky kz op lb lc ld oq lf lg jw or jx li jz os ka lk kc ot kd lm ln bi translated">自动登录和自动注销</h1><p id="b014" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在有趣的部分来了，我们在客户端持久化用户的会话。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/1e04f8f02156643f58e7528ed73b8282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*snq1pCMKnC_mvxFw"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@erdaest?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Erda Estremera</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="623a" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">让我们对我们的身份验证组件进行一些更改，假设me对服务器进行一个登录调用，结果接收到一个令牌以进行进一步的身份验证。我们还假设这个令牌的过期时间被设置为距后端1小时。这个到期时间将会派上用场，以确保我们的客户端在令牌到期之前做出相应的响应。</p><h2 id="e739" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">认证. js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="46d1" class="mk kx iq mx b gy nb nc l nd ne">import react, { useContext } from ‘react’<br/>import { AuthContext } from "./context";</span><span id="6d24" class="mk kx iq mx b gy nf nc l nd ne">export default function Authentication(){<br/>   const authContext = useContext(AuthContext);</span><span id="e07d" class="mk kx iq mx b gy nf nc l nd ne">   const loginHandler = () =&gt; {<br/>       <em class="no">//API call to server...</em></span><span id="8ca4" class="mk kx iq mx b gy nf nc l nd ne"><em class="no">       //response from server<br/>       </em>const userResponse = {<br/>           token: "abjd2323jb443jbbb"<br/>       };<br/>       authContext.login(userResponse.token);//setAuthContext       <br/>   };</span><span id="e312" class="mk kx iq mx b gy nf nc l nd ne">   const logoutHandler = () =&gt; {<br/>       authContext.logout();<br/>   };</span><span id="5936" class="mk kx iq mx b gy nf nc l nd ne">   return (<br/>       &lt;&gt;<br/>          {!authContext.isLoggedIn &amp;&amp; &lt;button className="login" onClick={loginHandler}&gt;Login&lt;/button&gt;}<br/>          {authContext.isLoggedIn &amp;&amp; (&lt;button className="logout" onClick={logoutHandler}&gt;Logout&lt;/button&gt;<br/>       &lt;/&gt;<br/>   )<br/>}</span></pre><p id="f5c5" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">让我们也管理App.js中的令牌状态:</p><h2 id="0aab" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">App.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="609f" class="mk kx iq mx b gy nb nc l nd ne">import react, { useState } from ‘react’<br/>import {AuthContext} from ‘./context’;</span><span id="a7d1" class="mk kx iq mx b gy nf nc l nd ne">export default function App(){<br/>    const [token, setToken] = useState(null);</span><span id="36cb" class="mk kx iq mx b gy nf nc l nd ne">    const login = () =&gt; {<br/>        setToken(token);<br/>    }</span><span id="95dd" class="mk kx iq mx b gy nf nc l nd ne">    const logout = () =&gt; {<br/>        setToken(null);<br/>    }</span><span id="24ff" class="mk kx iq mx b gy nf nc l nd ne">    return (<br/>       &lt;AuthContext.Provider value={isLoggedIn: !!token, login:         login, logout: logout}&gt;<br/>          &lt;Authentication/&gt;<br/>          &lt;ProtectedResource /&gt;<br/>       &lt;AuthContext.Provider /&gt;<br/>   )<br/>}</span></pre><p id="35a1" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">我们从App组件中移除了<strong class="lq ir"> isLoggedIn </strong>状态，并引入了<strong class="lq ir">令牌</strong>状态变量。</p><blockquote class="nl nm nn"><p id="ee96" class="lo lp no lq b lr ng jr lt lu nh ju lw np ni lz ma nq nj md me nr nk mh mi mj ij bi translated">如果你想知道的话！！值属性中的标记只是将标记值转换为布尔值。</p></blockquote><p id="3e30" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">现在，如果您单击登录，应用程序将会以同样的方式运行。它会让您登录并显示受保护的组件。但是，如果重新加载页面，就会出现持久性问题。我们的应用程序的状态在重新加载时丢失，我们被重定向回登录页面。那么，我们在这里可以做什么来保持应用程序状态不变，因为我们知道我们的令牌有一个小时的过期时间。</p><h1 id="c0bb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">管理令牌到期日期</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/95ed6fe540909629bbd9cc01d944a8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YdpWLFxCR4RthLjx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@hngstrm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Henry &amp; Co.</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="78a4" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">我们可以利用localStorage来保存我们的令牌和到期时间，这样即使当用户重新加载页面时，也不会发生重定向到登录状态的情况。</p><p id="6079" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">让我们对App.js中的代码进行相应的更改:</p><h2 id="b43f" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">App.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="82d0" class="mk kx iq mx b gy nb nc l nd ne">import react, { useState } from ‘react’<br/>import {AuthContext} from ‘./context’;</span><span id="91c2" class="mk kx iq mx b gy nf nc l nd ne">export default function App(){<br/>    const [token, setToken] = useState(null);<br/>    const [tokenExpirationTime, setTokenExpirationTime] = useState();</span><span id="b08b" class="mk kx iq mx b gy nf nc l nd ne">    const login = (token) =&gt; {<br/>        setToken(token);<br/>        const expiration = new Date(new Date().getTime() + 1000 * 60  * 60);</span><span id="3257" class="mk kx iq mx b gy nf nc l nd ne">        setTokenExpirationDate(expiration);//set expiration time one hour from current time</span><span id="b267" class="mk kx iq mx b gy nf nc l nd ne">        localStorage.setItem(<br/>             "userData",<br/>              JSON.stringify({<br/>                     token,<br/>                     expirationTime: expiration.toISOString()<br/>               })<br/>         );<br/>     }</span><span id="ad99" class="mk kx iq mx b gy nf nc l nd ne">     const logout = () =&gt; {<br/>        setToken(null);<br/>        setTokenExpirationTime(null);<br/>         localStorage.removeItem(‘userData’);<br/>     }</span><span id="8526" class="mk kx iq mx b gy nf nc l nd ne">     return (<br/>       &lt;AuthContext.Provider value={isLoggedIn: !!token, login:         login, logout: logout}&gt;<br/>          &lt;Authentication/&gt;<br/>          &lt;ProtectedResource /&gt;<br/>       &lt;AuthContext.Provider /&gt;<br/>     )<br/>}</span></pre><p id="a7ec" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated"><strong class="lq ir">我们已经创建了一个新的tokenExpirationTime状态变量，并将我们的令牌及其到期时间保存在localStorage中</strong>。注销时，我们清除两个状态变量。</p><p id="4b2b" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">现在，如果用户重新加载页面，检查某个内容是否在localStorage中的最好方法是什么？—是的，你猜对了，在使用效果挂钩。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="d41e" class="mk kx iq mx b gy nb nc l nd ne">useEffect(() =&gt; {<br/>    const storedData = JSON.parse(localStorage.getItem(“userData”));</span><span id="3c64" class="mk kx iq mx b gy nf nc l nd ne">    if (storedData &amp;&amp; storedData.token &amp;&amp; new Date(storedData.expirationTime) &gt; new Date()) <br/>     {<br/>        login(storedData.token, new Date(storedData.expirationTime));<br/>     }</span><span id="7265" class="mk kx iq mx b gy nf nc l nd ne">}, [login]);</span></pre><p id="ad53" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">我们检查localStorage是否有相关的数据，如果过期时间仍然在未来，那么只有我们调用我们的登录函数。这里login现在用两个参数调用；第二个是未来的到期日。所以我们需要在我们的登录函数中接受如下内容:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="57f1" class="mk kx iq mx b gy nb nc l nd ne">const login = (token, expirationTime) =&gt; {<br/>    setToken(token);<br/>    const expiration = expirationTime || new Date(new  Date().getTime() + 1000 * 60 * 60);<br/>    <br/>    setTokenExpirationDate(expiration);</span><span id="350b" class="mk kx iq mx b gy nf nc l nd ne">    localStorage.setItem(<br/>          “userData”,<br/>          JSON.stringify({<br/>                token,<br/>                expirationTime: expiration.toISOString()<br/>     })<br/>    );<br/>};</span></pre><p id="3ae8" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">通过上面的方法，我们可以确保使用正确的到期时间，并且它不总是被设置为从当前时间算起的一个小时。</p><p id="6435" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">现在我们需要设置一个定时器，这样一旦定时器到期，用户就会自动注销。我们的App.js最终版本如下:</p><h2 id="c0b8" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">App.js</h2><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5165" class="mk kx iq mx b gy nb nc l nd ne">import react, { useState, useEffect } from ‘react’<br/>import {AuthContext} from ‘./context’;</span><span id="7863" class="mk kx iq mx b gy nf nc l nd ne">let logoutTimer;</span><span id="7bd0" class="mk kx iq mx b gy nf nc l nd ne">export default function App(){<br/>    const [token, setToken] = useState(null);<br/>    const [tokenExpirationTime, setTokenExpirationTime] = useState();</span><span id="6053" class="mk kx iq mx b gy nf nc l nd ne">    const login = (token, expirationTime) =&gt; {<br/>        setToken(token);<br/>        const expiration = expirationTime || new Date(new Date().getTime() + 1000 * 60  * 60);</span><span id="5708" class="mk kx iq mx b gy nf nc l nd ne">    setTokenExpirationDate(expiration);<br/>        localStorage.setItem(<br/>             "userData",<br/>              JSON.stringify({<br/>                     token,<br/>                     expirationTime: expiration.toISOString()<br/>               })<br/>         );<br/>     }</span><span id="b114" class="mk kx iq mx b gy nf nc l nd ne">    const logout = () =&gt; {<br/>        setToken(null);<br/>        setTokenExpirationTime(null);<br/>        localStorage.removeItem(‘userData’);<br/>    }<br/></span><span id="893f" class="mk kx iq mx b gy nf nc l nd ne">    //hook to check if something is there in localStorage and logs user in accordingly<br/>    useEffect(() =&gt; {<br/>        const storedData = JSON.parse(localStorage.getItem(“userData”));</span><span id="5b03" class="mk kx iq mx b gy nf nc l nd ne">        if (storedData &amp;&amp; storedData.token &amp;&amp; new  Date(storedData.expirationTime) &gt; new Date()) <br/>        {<br/>           login(storedData.token, new Date(storedData.expirationTime));<br/>        }</span><span id="74e3" class="mk kx iq mx b gy nf nc l nd ne">     }, [login]);</span><span id="56ef" class="mk kx iq mx b gy nf nc l nd ne"><br/>     //new useEffect hook to set the timer if the expiration time is in future otherwise we clear the timer here<br/>     useEffect(() =&gt; {<br/>         if (token &amp;&amp; tokenExpirationDate) {<br/>            const remainingTime = tokenExpirationDate.getTime() - new Date().getTime();<br/>            logoutTimer = setTimeout(logout, remainingTime);<br/>          } else {<br/>            clearTimeout(logoutTimer);<br/>          }<br/>      }, [token, logout, tokenExpirationDate]);<br/></span><span id="3964" class="mk kx iq mx b gy nf nc l nd ne">     return (<br/>       &lt;AuthContext.Provider value={isLoggedIn: !!token, login:         login, logout: logout}&gt;<br/>          &lt;Authentication/&gt;<br/>          &lt;ProtectedResource /&gt;<br/>       &lt;AuthContext.Provider /&gt;<br/>     )<br/>}<br/></span></pre><p id="849c" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">如果您点击登录并再次重新加载应用程序，由于我们上面添加的逻辑，它将留在受保护的资源中。</p><p id="a7b5" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">这么多代码看不到输出，这肯定有点令人困惑，所以添加了一个最终沙箱。希望当你通读代码时，一切都有意义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="711f" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">仅此而已。</p><p id="1109" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">感谢阅读。希望你从这篇文章中有所收获！</p><h2 id="1b7d" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="f5f5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="lq ir">AI in Plain English</strong></a><a class="ae kv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="lq ir">UX in Plain English</strong></a><a class="ae kv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="lq ir">Python in Plain English</strong></a><strong class="lq ir"/>——谢谢，继续学习！</p><p id="55b6" class="pw-post-body-paragraph lo lp iq lq b lr ng jr lt lu nh ju lw lx ni lz ma mb nj md me mf nk mh mi mj ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">submissions @ plain English . io</strong></a><strong class="lq ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>