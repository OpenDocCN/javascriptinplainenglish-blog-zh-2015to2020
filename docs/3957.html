<html>
<head>
<title>Best of Modern JavaScript — Iterators and Iterables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——迭代器和可迭代对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-iterators-and-iterables-488d4b5bb2b0?source=collection_archive---------13-----------------------#2020-11-05">https://javascript.plainenglish.io/best-of-modern-javascript-iterators-and-iterables-488d4b5bb2b0?source=collection_archive---------13-----------------------#2020-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09849e5bdd9534b1196b98d026f1d260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BTsKvxlzSqiOpF2F"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@a_lo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Angela Loria</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d5b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript可迭代对象。</p><h1 id="8b5c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可迭代的迭代器</h1><p id="1a5b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在<code class="fe me mf mg mh b">Symbol.iterator</code>方法中返回<code class="fe me mf mg mh b">this</code>，我们可以将<code class="fe me mf mg mh b">next</code>函数移到它自己的对象方法中。</p><p id="1c5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f6b5" class="mq lc iq mh b gy mr ms l mt mu">function iterate(...args) {<br/>  let index = 0;<br/>  const iterable = {<br/>    [Symbol.iterator]() {<br/>      return this;<br/>    },<br/>    next() {<br/>      if (index &lt; args.length) {<br/>        return {<br/>          value: args[index++]<br/>        };<br/>      } else {<br/>        return {<br/>          done: true<br/>        };<br/>      }<br/>    },<br/>  };<br/>  return iterable;<br/>}</span></pre><p id="4527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们返回的<code class="fe me mf mg mh b">iterable</code>对象中有<code class="fe me mf mg mh b">next</code>。</p><p id="ab8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">args</code>包含了我们想要迭代的条目。</p><p id="220f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe me mf mg mh b">index</code>小于<code class="fe me mf mg mh b">args.length</code>时，我们返回带有<code class="fe me mf mg mh b">value</code>的对象。</p><p id="966e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有什么需要迭代的，我们返回一个设置为<code class="fe me mf mg mh b">true</code>的对象。</p><p id="04b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">Symbo.iterator</code>方法中返回<code class="fe me mf mg mh b">this</code>，这样迭代就可以完成了。</p><p id="cbab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-of循环只适用于iterables，而不直接适用于迭代器。</p><p id="1155" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Iterables总是有<code class="fe me mf mg mh b">Symbol.iterator</code>方法，所以我们必须把迭代器放在iterable对象上，使它成为iterable。</p><h1 id="3518" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">return()</code>和<code class="fe me mf mg mh b">throw()</code></h1><p id="93a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有两个迭代器方法是可选的。</p><p id="6bec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果迭代器提前结束，给我们一个机会清理迭代器。</p><p id="5a7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">throw</code>让我们将方法调用转发给通过<code class="fe me mf mg mh b">yield*</code>迭代的生成器。</p><h1 id="8d44" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭迭代器</h1><p id="bd24" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">return</code>来关闭一个迭代器。</p><p id="c24a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有之前的<code class="fe me mf mg mh b">iterate</code>函数。</p><p id="7acc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe me mf mg mh b">break</code>来干净利落地结束for-of循环:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6b80" class="mq lc iq mh b gy mr ms l mt mu">for (const x of iterate('foo', 'bar', 'baz')) {<br/>  console.log(x);<br/>  break;<br/>}</span></pre><p id="0552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">return</code>必须返回一个对象。</p><p id="6cb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为生成器如何处理<code class="fe me mf mg mh b">return</code>语句。</p><p id="c355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些构造函数关闭了没有完全清理干净的迭代器。</p><p id="46ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括:</p><ul class=""><li id="cbb6" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe me mf mg mh b">for-of</code></li><li id="3624" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">yield*</code></li><li id="b606" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">解构</li><li id="8de0" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">Array.from()</code></li><li id="8806" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">Map()</code>、<code class="fe me mf mg mh b">Set()</code>、<code class="fe me mf mg mh b">WeakMap()</code>、<code class="fe me mf mg mh b">WeakSet()</code></li><li id="ed3b" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">Promise.all()</code>，<code class="fe me mf mg mh b">Promise.race()</code></li></ul><h1 id="eed4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">组合子</h1><p id="6ee6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">组合子是组合现有的可重复项来创建新的可重复项的函数。</p><p id="b26b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容来创建一个:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a1b8" class="mq lc iq mh b gy mr ms l mt mu">function combinator(n, iterable) {<br/>  const iter = iterable[Symbol.iterator]();<br/>  return {<br/>    [Symbol.iterator]() {<br/>      return this;<br/>    },<br/>    next() {<br/>      if (0 &lt; n) {<br/>        n--;<br/>        return iter.next();<br/>      } else {<br/>        return {<br/>          done: true<br/>        };<br/>      }<br/>    }<br/>  };<br/>}</span></pre><p id="0d04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个函数来返回iterable对象中的第一个<code class="fe me mf mg mh b">n</code>项。</p><p id="ef4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e53f" class="mq lc iq mh b gy mr ms l mt mu">const arr = ['foo', 'bar', 'baz', 'qux'];<br/>for (const x of combinator(3, arr)) {<br/>  console.log(x);<br/>}</span></pre><p id="6903" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将记录<code class="fe me mf mg mh b">arr</code>数组的前3项。</p><h1 id="4bfb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无限迭代</h1><p id="bb6a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Iterable可以返回无限多的值。</p><p id="070a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="552c" class="mq lc iq mh b gy mr ms l mt mu">function evenNums() {<br/>  let n = 0;<br/>  return {<br/>    [Symbol.iterator]() {<br/>      return this;<br/>    },<br/>    next() {<br/>      return {<br/>        value: (++n) * 2<br/>      };<br/>    }<br/>  }<br/>}</span></pre><p id="9ddb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建返回偶数的iterable对象。</p><p id="6fa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="db45" class="mq lc iq mh b gy mr ms l mt mu">const nums = evenNums()<br/>console.log(nums.next());<br/>console.log(nums.next());<br/>console.log(nums.next());</span></pre><p id="1a41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">evenNums</code>函数来创建迭代器。</p><p id="e5f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在每个迭代器上调用<code class="fe me mf mg mh b">next</code>来生成数字。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/ac23d054f927b7bd0eb011ba8b551f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Z-SJf1FH3Eu44Fi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aginsbrook?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anthony Fomin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="42fb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7462" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建返回有限和无限数量的值的可迭代对象。</p><p id="71aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>