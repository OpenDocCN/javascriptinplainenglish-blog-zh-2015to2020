<html>
<head>
<title>How to Handle Password Reset in Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Express.js中处理密码重置</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-password-reset-in-expressjs-fde6f5015332?source=collection_archive---------8-----------------------#2020-12-24">https://javascript.plainenglish.io/how-to-handle-password-reset-in-expressjs-fde6f5015332?source=collection_archive---------8-----------------------#2020-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dc28ce44cf3140c68f2153e884671aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MQSXvfuRP4UKXu7x.jpg"/></div></div></figure><p id="5eb1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有密码重置功能的认证系统是不完整的。就我个人而言，我绝不会出售不包含这一功能的产品。有必要为用户提供一种在丢失或忘记密码的情况下恢复对其帐户/数据的访问的方法。在本文中，我将演示如何在ExpressJS中处理密码重置。</p><p id="39b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前两篇文章中，我写了<a class="ae kt" href="https://kelvinmwinuka.com/how-to-set-up-mongoose-with-expressjs/" rel="noopener ugc nofollow" target="_blank">如何将ExpressJS应用程序连接到MongoDB数据库</a>和<a class="ae kt" href="https://kelvinmwinuka.com/how-to-create-registration-authentication-with-express-passportjs/" rel="noopener ugc nofollow" target="_blank">构建用户注册和认证系统</a>。</p><p id="7c1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两篇文章都与今天的文章有关。我们将使用mongoose和我们保存的用户数据来启用密码重置。</p><p id="ccb0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您已经阅读了这些文章，或者已经有了自己的认证系统，请继续阅读。即使您使用不同的技术，您仍然可以从这种方法中获得一些有价值的想法。</p><p id="c46c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一如既往，这个项目是在<a class="ae kt" href="https://github.com/kelvinmwinuka/express-tutorial" rel="noopener ugc nofollow" target="_blank"> Github </a>上托管的。请随意克隆这个项目，以获得我在本文中使用的源代码。</p><h1 id="3f91" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">密码重置流程</h1><p id="9f60" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在深入研究代码之前，让我们首先从用户的角度建立密码重置流程，然后设计该流程的实现。</p><h1 id="a067" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用户视角</h1><p id="e23a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">从用户的角度来看，这个过程应该如下:</p><ol class=""><li id="156e" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">点击登录页面中的“忘记密码”链接。</li><li id="3d5a" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">已重定向至需要电子邮件地址的页面。</li><li id="893d" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">在电子邮件中接收密码重置链接。</li><li id="b30c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">链接重定向到需要新密码和密码确认的页面。</li><li id="ea6b" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">提交后，重定向到带有成功消息的登录页面。</li></ol><h1 id="162e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">重置系统特性</h1><p id="6ce3" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们还需要了解好的密码重置系统的一些特征:</p><ol class=""><li id="a67a" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">应该为用户生成唯一的密码重置链接，以便当用户访问该链接时，可以立即识别他们。这意味着在链接中包含一个唯一的令牌。</li><li id="f7ae" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">密码重置链接应有一个过期时间(例如2小时)，过期后将不再有效，并且不能用于重置密码。</li><li id="30d9" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">密码重置后，重置链接应过期，以防止同一链接被用于多次重置密码。</li><li id="6959" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果用户多次请求更改密码，而没有遵循整个过程，则每个生成的链接都会使前一个无效。这可以防止拥有多个可以重置密码的活动链接。</li><li id="b5b6" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果用户选择忽略发送给他们的电子邮件的密码重置链接，他们当前的凭据应该保持不变，并对未来的身份验证有效。</li></ol><h1 id="3622" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">实施步骤</h1><p id="e603" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们现在从用户的角度清楚地了解了重置流程以及密码重置系统的特征。以下是我们在实施该系统时将采取的步骤:</p><ol class=""><li id="2879" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">创建一个名为“PasswordReset”的mongoose模型来管理活动的密码重置请求/令牌。此处设置的记录应在指定的时间段后过期。</li><li id="5cd5" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">在登录表单中包含“忘记密码”链接，该链接会导致包含电子邮件表单的路由。</li><li id="747c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">将电子邮件提交到发布路径后，检查是否存在具有所提供电子邮件地址的用户。</li><li id="2edd" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果用户不存在，重定向回电子邮件输入表单，并通知用户没有找到具有所提供电子邮件的用户。</li><li id="b1db" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果该用户存在，则生成一个密码重置令牌，并将其保存到引用该用户的文档中的password reset集合中。如果此集合中已经有与此用户关联的文档，则更新/替换当前文档(每个用户只能有一个文档)。</li><li id="b056" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">生成一个包含密码重置令牌的链接，通过电子邮件将该链接发送给用户。</li><li id="7c05" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">重定向至提示用户检查其电子邮件地址以获取重置链接的成功消息的登录页面。</li><li id="508c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">一旦用户单击该链接，它应该指向一个GET route，该路由将令牌作为路由参数之一。</li><li id="18fe" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">在此路由中，提取令牌并查询此令牌的PasswordReset集合。如果找不到文档，提醒用户链接无效/过期。</li><li id="c531" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果找到了文档，加载一个表单来重置密码。该表单应该有2个字段(新密码和确认密码字段)。</li><li id="02b9" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">当提交表单时，它的post route会将用户的密码更新为新密码。</li><li id="55bd" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">删除password reset集合中与此用户关联的密码重置文档。</li><li id="4b52" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">将用户重定向到带有成功消息的登录页面。</li></ol><h1 id="4363" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">履行</h1><h1 id="71d9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置</h1><p id="d5e7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先，我们必须建立项目。安装用于生成唯一令牌的<a class="ae kt" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>包和用于发送电子邮件的<a class="ae kt" href="https://www.npmjs.com/package/nodemailer" rel="noopener ugc nofollow" target="_blank"> nodemailer </a>包。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="34f1" class="mu kv in mq b gy mv mw l mx my">npm install uuid nodemailer</span></pre><p id="2cf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将整个域添加到环境变量中。我们需要它来生成一个填充链接字符串，并通过电子邮件发送给用户。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="05d2" class="mu kv in mq b gy mv mw l mx my">DOMAIN=http://localhost:8000</span></pre><p id="dae7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在以下方面对应用程序条目文件进行一些更改:</p><ol class=""><li id="1501" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">在mongoose连接选项中将“useCreateIndex”设置为“true”。这使得mongoose的默认索引构建使用createIndex而不是ensureIndex，并防止MongoDB弃用警告。</li><li id="5cc2" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">导入一个包含所有名为“密码重置”的重置路由的新路由文件。我们稍后将创建这些路线。</li></ol><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="30a6" class="mu kv in mq b gy mv mw l mx my">const connection = mongoose.connect(process.env.MONGO_URI, {<br/>  useNewUrlParser: true,<br/>  useUnifiedTopology: true,<br/>  useCreateIndex: true<br/>})</span><span id="9252" class="mu kv in mq b gy mz mw l mx my">...</span><span id="5467" class="mu kv in mq b gy mz mw l mx my">app.use('/', require('./routes/password-reset'))</span></pre><h1 id="3621" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">模型</h1><p id="c4d2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们需要一个专门的模型来处理密码重置记录。在“模型”文件夹中，使用以下代码创建一个名为“PasswordReset”的模型:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b391" class="mu kv in mq b gy mv mw l mx my">const { Schema, model } = require('mongoose')</span><span id="1766" class="mu kv in mq b gy mz mw l mx my">const schema = new Schema({<br/>  user: {<br/>    type: Schema.Types.ObjectId,<br/>    ref: 'User',<br/>    required: true<br/>  },<br/>  token: {<br/>    type: Schema.Types.String,<br/>    required: true<br/>  }<br/>}, {<br/>  timestamps: true<br/>})</span><span id="cf52" class="mu kv in mq b gy mz mw l mx my">schema.index({ 'updatedAt': 1 }, { expireAfterSeconds: 300 })</span><span id="afa4" class="mu kv in mq b gy mz mw l mx my">const PasswordReset = model('PasswordReset', schema)</span><span id="e81c" class="mu kv in mq b gy mz mw l mx my">module.exports = PasswordReset</span></pre><p id="2ddc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个模型中，我们有两个属性，一个是请求密码重置的用户，另一个是分配给特定请求的惟一令牌。</p><p id="e31e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保将时间戳选项设置为true，以便在文档中包括“createdAt”和“updatedAt”字段。</p><p id="d7d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">定义模式后，在updatedAt字段上创建一个索引，过期时间为300秒(5分钟)。我把它设得这么低是为了测试。在生产中，您可以将这个时间增加到更实际的时间，比如2小时。</p><p id="8b08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们在本文的<a class="ae kt" href="https://kelvinmwinuka.com/how-to-set-up-mongoose-with-expressjs/" rel="noopener ugc nofollow" target="_blank">中创建的用户模型(或您当前拥有的用户模型)中，将预保存挂钩更新为以下内容:</a></p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="cbef" class="mu kv in mq b gy mv mw l mx my">userSchema.pre('save', async function(next){<br/>  if (this.isNew || this.isModified('password')) this.password = await bcrypt.hash(this.password, saltRounds)<br/>  next()<br/>})</span></pre><p id="4c57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做是为了确保无论文档是新的还是现有文档中的密码字段已被更改，密码字段都会被散列。</p><h1 id="447b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">路线</h1><p id="61ff" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在路由的文件夹中创建一个名为“password-reset.js”的新文件。这是我们在应用入口文件中导入的文件。</p><p id="9a6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此文件中，导入User和PasswordReset模型。从uuid包中导入v4函数以生成令牌。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ecd0" class="mu kv in mq b gy mv mw l mx my">const router  = require('express').Router()<br/>const { User, PasswordReset } = require('../models')<br/>const { v4 } = require('uuid')</span><span id="de35" class="mu kv in mq b gy mz mw l mx my">/* Create routes here */</span><span id="471c" class="mu kv in mq b gy mz mw l mx my">module.exports = router</span></pre><p id="569e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建前两条路线。这些路由与接受用户电子邮件地址的表单相关联。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d65d" class="mu kv in mq b gy mv mw l mx my">router.get('/reset', (req, res) =&gt; res.render('reset.html'))</span><span id="3a38" class="mu kv in mq b gy mz mw l mx my">router.post('/reset', async (req, res) =&gt; {<br/>  /* Flash email address for pre-population in case we redirect back to reset page. */<br/>  req.flash('email', req.body.email)</span><span id="9be7" class="mu kv in mq b gy mz mw l mx my">/* Check if user with provided email exists. */<br/>  const user = await User.findOne({ email: req.body.email })<br/>  if (!user) {<br/>    req.flash('error', 'User not found')<br/>    return res.redirect('/reset')<br/>  }</span><span id="d9ef" class="mu kv in mq b gy mz mw l mx my">/* Create password reset token and save in collection along with user. <br/>     If there already is a record with current user, replace it. */<br/>  const token = v4().toString().replace(/-/g, '')<br/>  PasswordReset.updateOne({ <br/>    user: user._id <br/>  }, {<br/>    user: user._id,<br/>    token: token<br/>  }, {<br/>    upsert: true<br/>  })<br/>  .then( updateResponse =&gt; {<br/>    /* Send email to user containing password reset link. */<br/>    const resetLink = `${process.env.DOMAIN}/reset-confirm/${token}`<br/>    console.log(resetLink)</span><span id="6792" class="mu kv in mq b gy mz mw l mx my">req.flash('success', 'Check your email address for the password reset link!')<br/>    return res.redirect('/login')<br/>  })<br/>  .catch( error =&gt; {<br/>    req.flash('error', 'Failed to generate reset link, please try again')<br/>    return res.redirect('/reset')<br/>  })<br/>})</span></pre><p id="b01e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个是到“/reset”的GET路由。在此路径中，呈现“reset.html”模板。我们稍后将创建这个模板。</p><p id="9f67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个路由是“/reset”的POST路由。此路由要求在请求正文中包含用户的电子邮件。在这条路线中:</p><ol class=""><li id="069a" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">闪回电子邮件进行预填充，以防我们重定向回电子邮件表单。</li><li id="c3f9" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">检查提供电子邮件的用户是否存在。否则，刷新错误并重定向回“/reset”。</li><li id="6f3c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">使用v4创建令牌。</li><li id="8127" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">更新与当前用户关联的密码重置文档。在选项中将upsert设置为true以创建一个新文档(如果还没有文档的话)。</li><li id="5a47" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果更新成功，将链接发送给用户，显示成功消息并重定向到登录页面。</li><li id="ac20" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">如果更新不成功，闪烁一条错误消息并重定向回电子邮件页面。</li></ol><p id="b05a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，我们只记录到控制台的链接。我们稍后将实现电子邮件逻辑。</p><p id="da09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当用户访问上面的链接生成的链接时，创建2条路由。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="13f5" class="mu kv in mq b gy mv mw l mx my">router.get('/reset-confirm/:token', async (req, res) =&gt; {<br/>  const token = req.params.token<br/>  const passwordReset = await PasswordReset.findOne({ token })<br/>  res.render('reset-confirm.html', { <br/>    token: token,<br/>    valid: passwordReset ? true : false<br/>  })<br/>})</span><span id="9289" class="mu kv in mq b gy mz mw l mx my">router.post('/reset-confirm/:token', async (req, res) =&gt; {<br/>  const token = req.params.token<br/>  const passwordReset = await PasswordReset.findOne({ token })<br/>  <br/>  /* Update user */<br/>  let user = await User.findOne({ _id: passwordReset.user })<br/>  user.password = req.body.password<br/>  <br/>  user.save().then( async savedUser =&gt;  {<br/>    /* Delete password reset document in collection */<br/>    await PasswordReset.deleteOne({ _id: passwordReset._id })<br/>    /* Redirect to login page with success message */<br/>    req.flash('success', 'Password reset successful')<br/>    res.redirect('/login')<br/>  }).catch( error =&gt; {<br/>    /* Redirect back to reset-confirm page */<br/>    req.flash('error', 'Failed to reset password please try again')<br/>    return res.redirect(`/reset-confirm/${token}`)<br/>  })<br/>})</span></pre><p id="ed1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个路由是get路由，它需要url中的令牌。提取令牌，然后进行验证。通过在PasswordReset集合中搜索具有所提供令牌的文档来验证令牌。</p><p id="bf9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果找到了文档，则将“有效”模板变量设置为true，否则，将其设置为false。确保将令牌本身传递给模板。我们将在密码重置表单中使用它。</p><p id="53d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过按令牌搜索PasswordReset集合来检查令牌的有效性。</p><p id="30bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个路由是接受密码重置表单提交的POST路由。从url中提取令牌，然后检索与之关联的密码重置文档。</p><p id="cf97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新与此特定密码重置文档关联的用户。设置新密码并保存更新的用户。</p><p id="969d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新用户后，删除密码重置文档以防止其被重新用于重置密码。</p><p id="ee56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">闪现一条成功消息，并将用户重定向到登录页面，用户可以使用新密码登录。</p><p id="cf16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果更新不成功，闪现一条错误消息并重定向回相同的表单。</p><h1 id="ff30" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">模板</h1><p id="a22e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">一旦我们创建了路线，我们需要创建模板</p><p id="21d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“视图”文件夹中，创建一个包含以下内容的“reset.html”模板文件:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e5c4" class="mu kv in mq b gy mv mw l mx my">{% extends 'base.html' %}</span><span id="e21c" class="mu kv in mq b gy mz mw l mx my">{% set title = 'Reset' %}</span><span id="ad64" class="mu kv in mq b gy mz mw l mx my">{% block styles %}<br/>{% endblock %}</span><span id="235a" class="mu kv in mq b gy mz mw l mx my">{% block content %}<br/>  &lt;form action='/reset' method="POST"&gt;<br/>    {% if messages.error %}<br/>      &lt;div class="alert alert-danger" role="alert"&gt;{{ messages.error }}&lt;/div&gt;<br/>    {% endif %}<br/>    &lt;div class="mb-3"&gt;<br/>      &lt;label for="name" class="form-label"&gt;Enter your email address&lt;/label&gt;<br/>      &lt;input <br/>        type="text" <br/>        class="form-control {% if messages.error %}is-invalid{% endif %}" <br/>        id="email" <br/>        name="email"<br/>        value="{{ messages.email or '' }}"<br/>        required&gt;<br/>    &lt;/div&gt;<br/>    &lt;div&gt;<br/>      &lt;button type="submit" class="btn btn-primary"&gt;Send reset link&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  &lt;/form&gt;<br/>{% endblock %}</span></pre><p id="b01a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个电子邮件字段，如果在之前的请求中闪现了一个电子邮件值，则该字段会预填充一个电子邮件值。</p><p id="c690" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">包括一个警告，如果从以前的请求刷新了一个错误消息，则显示一个错误消息。</p><p id="7089" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在同一文件夹中创建另一个名为“reset-confirm.html”的模板，内容如下:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d623" class="mu kv in mq b gy mv mw l mx my">{% extends 'base.html' %}</span><span id="ec25" class="mu kv in mq b gy mz mw l mx my">{% set title = 'Confirm Reset' %}</span><span id="0c19" class="mu kv in mq b gy mz mw l mx my">{% block content %}<br/>  {% if not valid %}<br/>    &lt;h1&gt;Oops, looks like this link is expired, try to &lt;a href="/reset"&gt;generate another reset link&lt;/a&gt;&lt;/h1&gt;<br/>  {% else %}<br/>    &lt;form action='/reset-confirm/{{ token }}' method="POST"&gt;<br/>      {% if messages.error %}<br/>        &lt;div class="alert alert-danger" role="alert"&gt;{{ messages.error }}&lt;/div&gt;<br/>      {% endif %}<br/>      &lt;div class="mb-3"&gt;<br/>        &lt;label for="name" class="form-label"&gt;Password&lt;/label&gt;<br/>        &lt;input <br/>          type="password" <br/>          class="form-control {% if messages.password_error %}is-invalid{% endif %}" <br/>          id="password" <br/>          name="password"&gt;<br/>        &lt;div class="invalid-feedback"&gt;{{ messages.password_error }}&lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="mb-3"&gt;<br/>        &lt;label for="name" class="form-label"&gt;Confirm password&lt;/label&gt;<br/>        &lt;input <br/>          type="password" <br/>          class="form-control {% if messages.confirm_error %}is-invalid{% endif %}" <br/>          id="confirmPassword" <br/>          name="confirmPassword"&gt;<br/>        &lt;div class="invalid-feedback"&gt;{{ messages.confirm_error }}&lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        &lt;button type="submit" class="btn btn-primary"&gt;Confirm reset&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/form&gt;<br/>  {% endif %}<br/>{% endblock %}</span></pre><p id="b283" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个表单中，检查我们在GET route中设置的“valid”变量的值，如果为false，则呈现过期的令牌消息。否则，呈现密码重置表单。</p><p id="cef4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果在之前的请求中刷新了一个错误消息，则包括显示错误消息的警报。</p><p id="c8fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">转到我们在<a class="ae kt" href="https://kelvinmwinuka.com/how-to-create-registration-authentication-with-express-passportjs/" rel="noopener ugc nofollow" target="_blank">注册&amp;认证</a>文章中创建的登录表单，并将以下代码添加到表单顶部:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5039" class="mu kv in mq b gy mv mw l mx my">{% if messages.success %}<br/>    &lt;div class="alert alert-success" role="alert"&gt;{{ messages.success }}&lt;/div&gt;<br/>{% endif %}</span></pre><p id="c000" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这会呈现我们在创建/发送重置链接时以及在重定向到登录页面之前更新用户密码时闪烁的成功消息。</p><h1 id="01f5" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">邮件</h1><p id="7269" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在前面的路由部分中，我们记录了控制台中的重置链接。理想情况下，当用户请求密码重置链接时，我们应该向用户发送电子邮件。</p><p id="6c9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个例子，我使用了<a class="ae kt" href="https://ethereal.email/" rel="noopener ugc nofollow" target="_blank"> ethereal.email </a>来生成一个用于开发目的的测试电子邮件帐户。去那里创建一个(这是一个点击过程)。</p><p id="6eae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建测试帐户后，将以下变量添加到环境变量中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b3fc" class="mu kv in mq b gy mv mw l mx my">EMAIL_HOST=smtp.ethereal.email EMAIL_NAME=Leanne Zulauf EMAIL_ADDRESS=leanne.zulauf@ethereal.email EMAIL_PASSWORD=aDhwfMry1h3bbbR9Av EMAIL_PORT=587 EMAIL_SECURITY=STARTTLS</span></pre><p id="9525" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些是我写作时的价值观，在这里插入你自己的价值观。</p><p id="ea78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在项目的根目录下创建一个“helpers.js”文件。这个文件将包含一系列有用的函数，这些函数可能会在整个项目中重用。</p><p id="679e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里定义这些函数，这样我们就可以在需要的时候导入它们，而不是在整个应用程序中重复类似的逻辑。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2dc0" class="mu kv in mq b gy mv mw l mx my">const nodemailer = require('nodemailer')</span><span id="112b" class="mu kv in mq b gy mz mw l mx my">module.exports = {<br/>  sendEmail: async ({ to, subject, text }) =&gt; {<br/>    /* Create nodemailer transporter using environment variables. */<br/>    const transporter = nodemailer.createTransport({<br/>      host: process.env.EMAIL_HOST,<br/>      port: Number(process.env.EMAIL_PORT),<br/>      auth: {<br/>        user: process.env.EMAIL_ADDRESS,<br/>        pass: process.env.EMAIL_PASSWORD<br/>      }<br/>    })<br/>    /* Send the email */<br/>    let info = await transporter.sendMail({<br/>      from: `"${process.env.EMAIL_NAME}" &lt;${process.env.EMAIL_ADDRESS}&gt;`,<br/>      to,<br/>      subject,<br/>      text<br/>    })<br/>    /* Preview only available when sending through an Ethereal account */<br/>    console.log(`Message preview URL: ${nodemailer.getTestMessageUrl(info)}`)<br/>  }<br/>}</span></pre><p id="e297" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导出具有各种功能的对象。第一个是“发送电子邮件”功能。</p><p id="49a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该函数接收收件人的地址、电子邮件主题和电子邮件文本。使用之前在选项中定义的环境变量创建节点邮件传输器。使用传递给该函数的参数发送电子邮件。</p><p id="a089" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该函数的最后一行将消息url记录在控制台中，以便您可以在Ethereal mail上查看消息。测试帐户实际上并不发送电子邮件。</p><p id="687d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">返回“password-reset.js”路线，添加电子邮件功能。首先，导入函数:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f961" class="mu kv in mq b gy mv mw l mx my">const { sendEmail } = require('../helpers')</span></pre><p id="06d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“/reset”POST路由中，添加以下代码，而不是在控制台上记录reset链接:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ba89" class="mu kv in mq b gy mv mw l mx my">sendEmail({<br/>      to: user.email, <br/>      subject: 'Password Reset',<br/>      text: `Hi ${user.name}, here's your password reset link: ${resetLink}. <br/>      If you did not request this link, ignore it.`<br/>    })</span></pre><p id="ae5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">成功更新用户后，再发送一封电子邮件，通知用户在“/重置-确认”发布路径中成功更改了密码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e5fa" class="mu kv in mq b gy mv mw l mx my">user.save().then( async savedUser =&gt;  {<br/>    /* Delete password reset document in collection */<br/>    await PasswordReset.deleteOne({ _id: passwordReset._id })<br/>    /* Send successful password reset email */<br/>    sendEmail({<br/>      to: user.email, <br/>      subject: 'Password Reset Successful',<br/>      text: `Congratulations ${user.name}! Your password reset was successful.`<br/>    })<br/>    /* Redirect to login page with success message */<br/>    req.flash('success', 'Password reset successful')<br/>    res.redirect('/login')<br/>  }).catch( error =&gt; {<br/>    /* Redirect back to reset-confirm page */<br/>    req.flash('error', 'Failed to reset password please try again')<br/>    return res.redirect(`/reset-confirm/${token}`)<br/>  })</span></pre><h1 id="b95c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="191f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在本文中，我演示了如何使用NodeMailer在ExpressJS中实现密码重置特性。</p><p id="b5fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一篇文章中，我将讲述如何在您的Express应用程序中实现一个用户电子邮件验证系统。我将使用与本文类似的方法，选择NodeMailer作为电子邮件包。</p><p id="34b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果你喜欢这篇文章，可以考虑关注我的</strong> <a class="ae kt" href="https://kelvinmwinuka.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">个人网站</strong> </a> <strong class="jx io">，以便在我的内容在媒体上发布之前提前获取(别担心，它仍然是免费的，没有烦人的弹出广告！).另外，请随意评论这篇文章。我很想听听你们的想法！</strong></p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="2ce5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nh">原载于2020年12月24日https://kelvinmwinuka.com</em><em class="nh">的</em> <a class="ae kt" href="https://kelvinmwinuka.com/how-to-handle-password-reset-in-expressjs/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">。</em></a></p></div></div>    
</body>
</html>