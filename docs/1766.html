<html>
<head>
<title>The Comparison Between Observables and Promises When Applied to Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用于角度分析时，可观察值和承诺值之间的比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-comparison-between-observables-and-promises-when-applied-to-angular-7f4a8f23fb2d?source=collection_archive---------9-----------------------#2020-04-20">https://javascript.plainenglish.io/the-comparison-between-observables-and-promises-when-applied-to-angular-7f4a8f23fb2d?source=collection_archive---------9-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/60429a3ab576eba32057bbfa041172fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dOKNQIC7r_I4lX53"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zachspears?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zachary Spears</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="26c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular是Google制作的一个流行的前端框架。像其他流行的前端框架一样，它使用基于组件的架构来构建应用程序。</p><p id="380a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将比较可观察到的和承诺之间的区别。</p><p id="5dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都是异步的，但是它们非常不同。</p><h1 id="e8a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与承诺相比，可观察到的</h1><p id="0c68" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">可观察到的和承诺之间有很多不同。</p><p id="1f56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可观测量是说明性的。计算直到订阅才开始。</p><p id="e4eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺在创造时立即生效。这使得observables更适用于我们只需要在有需要时运行的情况。</p><p id="6835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可观察提供了许多价值。承诺提供一个。</p><p id="c4f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可观察性区分了链接和订阅。承诺只能用<code class="fe me mf mg mh b">then</code>子句链接。</p><p id="6422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，可观察对象可用于为它们发出的数据创建复杂的转换。</p><p id="d607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Observables <code class="fe me mf mg mh b">subscribe</code>负责处理错误。承诺将错误推送到子承诺。这使得错误处理更加集中和可预测。</p><h1 id="f425" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建和订阅</h1><p id="bbf4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们订阅可观测量，而不是像承诺的那样立即运行代码。</p><p id="5b59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们通过撰写以下内容来订阅observables:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4809" class="mq lc iq mh b gy mr ms l mt mu">new Observable((observer) =&gt; { //... });<br/><br/>observable.subscribe(() =&gt; {<br/>  //...<br/>});</span></pre><p id="80e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当订阅后发出值时，回调中的代码运行。</p><p id="2011" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于承诺立即运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8a54" class="mq lc iq mh b gy mr ms l mt mu">const promise = new Promise((resolve, reject) =&gt; { resolve('foo') });<br/><br/>promise.then((value) =&gt; {<br/>  console.log(value)<br/>});</span></pre><p id="9e8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们创建了一个承诺，然后通过对它调用<code class="fe me mf mg mh b">then</code>来运行它。</p><h1 id="045c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">链接</h1><p id="6e5a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">可观测量与<code class="fe me mf mg mh b">pipe</code>和<code class="fe me mf mg mh b">map</code>等操作符链接如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2a56" class="mq lc iq mh b gy mr ms l mt mu">observable.pipe(map((x) =&gt; 2*x));</span></pre><p id="f1ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于承诺，我们在<code class="fe me mf mg mh b">then</code>回调中解析值如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="31ed" class="mq lc iq mh b gy mr ms l mt mu">promise.then((v) =&gt; 2*v);</span></pre><p id="5ae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来映射值。</p><h1 id="7dad" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">取消</h1><p id="870c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用可观察对象上的<code class="fe me mf mg mh b">unsubscribe</code>来取消订阅，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f1ea" class="mq lc iq mh b gy mr ms l mt mu">const sub = obs.subscribe(...); <br/>sub.unsubscribe();</span></pre><p id="4753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺没有这个功能。</p><h1 id="4f30" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">错误处理</h1><p id="a0ad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">错误是用可观察对象中的错误处理程序来处理的。订阅中的错误被发送到错误处理程序。</p><p id="d68d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cbe0" class="mq lc iq mh b gy mr ms l mt mu">of(1, 2, 3).subscribe(<br/>  () =&gt; {<br/>    throw Error("error");<br/>  }<br/>);</span></pre><p id="f406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们抛出一个错误。<code class="fe me mf mg mh b">of</code>是发出有限数值的可观察物体。</p><p id="5727" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在承诺的<code class="fe me mf mg mh b">then</code>回调中抛出错误:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="960f" class="mq lc iq mh b gy mr ms l mt mu">promise.then(() =&gt; {<br/>  throw Error('my error');<br/>});</span></pre><h1 id="a8bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与事件API相比的可观察值</h1><p id="4c94" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Observables也可以处理DOM事件。</p><p id="c7bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下命令来监听可观察到的按钮点击声:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6209" class="mq lc iq mh b gy mr ms l mt mu">import { fromEvent } from "rxjs";</span><span id="10d0" class="mq lc iq mh b gy mv ms l mt mu">const buttonEl = document.querySelector("button");<br/>const clicks$ = fromEvent(buttonEl, "click");</span><span id="b0fd" class="mq lc iq mh b gy mv ms l mt mu">let subscription = clicks$.subscribe(e =&gt; console.log("clicked", e));</span></pre><p id="1994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">fromEvent</code>创建一个可观察对象，然后用<code class="fe me mf mg mh b">subscribe</code>方法订阅它。</p><p id="b09a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">subscribe</code>回调中，我们记录从可观察对象发出的值。</p><p id="11f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过写信取消订阅可观察到的事件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e4bf" class="mq lc iq mh b gy mr ms l mt mu">subscription.unsubscribe();</span></pre><p id="b6fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用本地事件API实现这一点，我们编写了以下代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ed62" class="mq lc iq mh b gy mr ms l mt mu">const buttonEl = document.querySelector("button");<br/>const handler = e =&gt; console.log("clicked", e);<br/>buttonEl.addEventListener("click", handler);</span></pre><p id="08de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe me mf mg mh b">removeListener</code>来删除监听器，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fef0" class="mq lc iq mh b gy mr ms l mt mu">button.removeEventListener(‘click’, handler);</span></pre><p id="4827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于可观测量，我们可以将从<code class="fe me mf mg mh b">fromEvents</code>可观测量发出的值转换如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0ea" class="mq lc iq mh b gy mr ms l mt mu">import { fromEvent } from "rxjs";<br/>import { map } from "rxjs/operators";<br/>const buttonEl = document.querySelector("button");<br/>const clicks$ = fromEvent(buttonEl, "click").pipe(map(e =&gt; e.target));<br/>let subscription = clicks$.subscribe(e =&gt; console.log("clicked", e));</span></pre><p id="ac55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不能用本地DOM事件API来完成。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ca4162d18997fee36725aa4f5fd86f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g4M2MYydhewpjmN9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Clode</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4752" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与数组相比的可观测量。</h1><p id="d416" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">可观测量随着时间的推移发出数值。数组是一组静态的值。</p><p id="9b5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，常见的阵列操作也有其可观察的类似物。</p><p id="7906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有以下可观察到的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="43cf" class="mq lc iq mh b gy mr ms l mt mu">const obs = of(1, 2, 3);</span></pre><p id="d436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和数组:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f10d" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2, 3];</span></pre><p id="2e5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对每个进行以下操作:</p><h2 id="4ff8" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">串联</h2><p id="e3ce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Rxjs <code class="fe me mf mg mh b">concat</code>函数连接观察值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d1a0" class="mq lc iq mh b gy mr ms l mt mu">import { of, concat } from "rxjs";<br/>const obs = of(1, 2, 3);<br/>const obsB = of(4, 5, 6);<br/>concat(obs, obsB);</span></pre><p id="5ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数组，我们可以使用<code class="fe me mf mg mh b">concat</code>方法返回一个新的数组:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7c43" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2, 3];<br/>const arrB = [4, 5, 6];<br/>const newArr = arr.concat(arrB);</span></pre><h2 id="fb53" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">过滤</h2><p id="295a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以如下使用Rxjs <code class="fe me mf mg mh b">filter</code>运算符:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="44b7" class="mq lc iq mh b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { filter } from "rxjs/operators";<br/>const obs = of(1, 2, 3);<br/>obs.pipe(filter(v =&gt; v &gt; 1));</span></pre><p id="8f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数组，我们使用<code class="fe me mf mg mh b">filter</code>方法返回一个新数组，该数组的值满足返回的谓词:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c4d1" class="mq lc iq mh b gy mr ms l mt mu">arr.filter(v =&gt; v &gt; 1);</span></pre><h2 id="f3c9" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">发现</h2><p id="1347" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以如下使用Rxjs <code class="fe me mf mg mh b">find</code>操作符来发出满足条件的单个值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="41c1" class="mq lc iq mh b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { find } from "rxjs/operators";<br/>const obs = of(1, 2, 3);<br/>obs.pipe(find(v =&gt; v &gt; 1));</span></pre><p id="6920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arrays还有一个<code class="fe me mf mg mh b">find</code>方法来返回满足谓词的第一个值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6cbb" class="mq lc iq mh b gy mr ms l mt mu">arr.find(v =&gt; v &gt; 1);</span></pre><h2 id="40fe" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">为每一个</h2><p id="f917" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Rxjs有<code class="fe me mf mg mh b">tap</code>操作符来获取发出的值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c7e" class="mq lc iq mh b gy mr ms l mt mu">obs.pipe(tap((v) =&gt; {<br/>  console.log(v);<br/>}))</span></pre><p id="b6d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Array有<code class="fe me mf mg mh b">forEach</code>方法来获取正在循环的值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="22a3" class="mq lc iq mh b gy mr ms l mt mu">arr.forEach((v) =&gt; {<br/>  console.log(v);<br/>})</span></pre><h2 id="96f6" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">地图</h2><p id="0055" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">map</code>运算符来映射可观测量发出的值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2e07" class="mq lc iq mh b gy mr ms l mt mu">obs.pipe(map((v) =&gt; 2*v))</span></pre><p id="126f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组也有<code class="fe me mf mg mh b">map</code>方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5f03" class="mq lc iq mh b gy mr ms l mt mu">arr.map((v) =&gt; 2*v)</span></pre><h2 id="2e11" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">组合值</h2><p id="c11b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Rxjs有一个<code class="fe me mf mg mh b">reduce</code>操作符，将发出的值组合成一个值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e709" class="mq lc iq mh b gy mr ms l mt mu">obs.pipe(reduce((s, v)=&gt; s + v, 0))</span></pre><p id="62eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组也有一个<code class="fe me mf mg mh b">reduce</code>方法来做同样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="71a9" class="mq lc iq mh b gy mr ms l mt mu">arr.reduce((s,v) =&gt; s + v, 0)</span></pre><h1 id="2058" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="95e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">可观测量在角坐标的许多地方都有使用。它们在JavaScript中有类似的各种实体。</p><p id="108f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可观察值发出被观察者订阅的值。除非有人订阅，否则它们不会运行。</p><p id="0c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们总是异步的，并且有异步代码不具备的额外功能，比如取消和重试。</p><h2 id="facd" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="04c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的喜爱:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="7927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>