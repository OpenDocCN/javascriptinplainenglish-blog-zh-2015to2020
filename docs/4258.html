<html>
<head>
<title>The Validate Subsequence Algorithm: A Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">验证子序列算法:深入研究</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-deep-dive-of-one-of-the-algorithms-ive-solved-this-week-534f13e8f1e?source=collection_archive---------2-----------------------#2020-11-29">https://javascript.plainenglish.io/a-deep-dive-of-one-of-the-algorithms-ive-solved-this-week-534f13e8f1e?source=collection_archive---------2-----------------------#2020-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9796991d113a155bb33eadcb7d9412c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIceMdxlt0Kg_wdiTR4zzA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Custom Word Art I created online- to make yours click <a class="ae jz" href="https://wordart.com/create" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="bcd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就像爱情和金钱让世界运转一样，算法是让技术性工作面试运转的因素，当然还有一些数据结构基础知识。理解这两个主题并知道如何快速解决它们是为任何程序员掌握如何更好地编写高效代码的技能打下坚实基础的。</p><p id="4169" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么会这样呢？为什么解决算法会让你成为更好的开发人员，有很多答案，但我想解决这个问题的最简单的方法是陈述一个事实。事实是算法只是程序的一个花哨的词。换句话说，它只是计算机执行任务的一系列步骤的列表(有时在结束前必须重复)。因此，如果你能编码一个过程来得到一个结果，那么将你过程中的模式应用到编码项目中就更容易了，这也就更容易写出更好的代码。</p><p id="795d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还是太复杂？可以这样想:蛋糕混合盒的指令被认为是一种算法。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/4abfc0e064de009fd40c5eed222c3296.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*6OzGO_7dgz9HoCDZe3uprA.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A trip down memory lane before I knew how to make a cake from scratch…</figcaption></figure><p id="a1b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为软件开发人员，或许还有兼职的蛋糕师，我们的工作是编码列出计算机思考的方式，以尽可能平稳的方式完成手头的任务。</p><p id="ee86" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近这个星期，我已经解决了一些算法挑战，但是为了尽我的一份力量帮助编程社区理解如何解决算法的概念，我将挑选一个，然后解释我在解决算法时的思维过程。之后，用一个测试实例在更深层次上进行解释。这个编码挑战的解决方案将用JavaScript编码。</p><h1 id="417c" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">验证子序列算法</h1><p id="f078" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated"><strong class="kc io">提示或问题陈述</strong>:给定两个非空整数数组，写一个函数，判断第二个数组是否是第一个数组的子序列。</p><p id="8733" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数组的子序列是一组数字，它们在数组中不一定相邻，但它们在数组中出现的顺序相同。例如这些数字</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="adb7" class="ml le in mh b gy mm mn l mo mp">[2, 3, 5]</span></pre><p id="0dce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是数组的子序列:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="251e" class="ml le in mh b gy mm mn l mo mp">[1, 2, 3, 4, 5]</span></pre><p id="3bb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，数组中的单个数字和数组本身都是数组的有效子序列。</p><p id="788f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">一个样本输入</strong>(进入参数的内容):array = [5，1，22，25，6，-1，8，10]</p><p id="ecd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">序列= [1，2，-1，10]</p><p id="54ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">一个样本输出</strong>(一个算法过程应该产生的结果的例子):真</p><p id="93a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一步:根据输出结果，问自己一些关于解决方案的基本问题</strong></p><p id="762c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在试图解决这个问题时，我的第一个想法是问自己:“从函数中获得真或假结果的最好方法是什么？”我下一个回答我自己问题的想法当然是使用if语句，所以在那一点上，我知道在我的解决方案中我需要一个if语句。</p><p id="5918" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我想，“我要如何遍历一个数组来确定一个条件是否为真？”它将使用一个循环来迭代(遍历)主数组中他们给我的所有数字。有很多方法可以迭代JavaScript，比如使用while循环、for循环和for of循环。我选择for循环，因为在我看来，索引更容易跟踪。</p><p id="c413" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二步:编写你的主结构，用合适的参数把所有东西组合在一起</p><p id="6f9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了这两个想法，我就有了算法解决方案的主要结构。我从关键字function开始，给函数取了一个合适的名字，并传入了他们在问题中谈到的两个参数:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="8e77" class="ml le in mh b gy mm mn l mo mp">function isValidSubsequence(array, sequence) {<br/><br/>}</span></pre><p id="5d3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第三步:根据第一步编写主结构的代码。注意:必要时重复步骤1。</strong></p><p id="594c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在是时候写我的for循环了。我的for循环需要对照子序列数组检查主数组中的每个数字，所以我知道对于for循环的第一部分，我必须从0开始让counter变量检查主数组的第一个数字。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="71a8" class="ml le in mh b gy mm mn l mo mp">function isValidSubsequence(array, sequence) {<br/>   for(i=0;<br/>}</span></pre><p id="4c15" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我知道我需要一直使用主数组，直到被检查的数字的索引到达列表的末尾，所以我在for循环中设置我的条件，说计数器变量值必须总是小于数组的长度。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="1097" class="ml le in mh b gy mm mn l mo mp">function isValidSubsequence(array, sequence) {<br/>   for(i=0; i &lt; array.length;<br/>}</span></pre><p id="4e3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我需要一种方法来说明每次在主数组中比较一个数字时，移动到列表中要比较的下一个数字，这就是为什么我使用了一个递增运算符。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="b7aa" class="ml le in mh b gy mm mn l mo mp">function isValidSubsequence(array, sequence) {<br/>   for(i=0; i &lt; array.length; i++){<br/>      </span></pre><p id="9513" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我需要一个if语句来查看数组中的当前数字是否等于序列数组中的当前序列号。如果相等，我需要一种方法来移动到序列数组中的下一个数字，以检查下一个数字。这就是为什么我设置了一个名为j的新变量，将它设置为0，就像主数组的counter变量一样。这种情况最终看起来像下面这样，还有我的一些有用的评论。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="ac3d" class="ml le in mh b gy mm mn l mo mp">function isValidSubsequence(array, sequence) {<br/>   let j = 0 //set a variable equal to j, this represents the index      of the sequence array</span><span id="2b48" class="ml le in mh b gy mq mn l mo mp">   for(i=0; i &lt; array.length; i++){</span><span id="7e89" class="ml le in mh b gy mq mn l mo mp">//if the number we are on in the first array matches the number we are on in the second array then add 1 to the variable j <br/>   if (array[i] === sequence[j]) {<br/>         j++</span><span id="c7a0" class="ml le in mh b gy mq mn l mo mp">//Add 1 to j<br/>      }<br/>   }</span><span id="2b91" class="ml le in mh b gy mq mn l mo mp">}</span></pre><p id="a550" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第四步:在某个时刻，通过返回请求的输出，找到某种方法来结束算法解。</strong></p><p id="4f45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此时，for循环将反复运行，检查每个数组中的每个数字是否匹配。现在我想“在这个循环结束后，必须有某种方法用if语句返回true或false。”所以我决定写一个if语句，说如果序列数组的索引等于其数组的序列长度，那么返回true否则，返回false。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="f597" class="ml le in mh b gy mm mn l mo mp">function isValidSubsequence(array, sequence) {<br/>   let j = 0 //set a variable equal to j, this represents the index      of the sequence array</span><span id="46f5" class="ml le in mh b gy mq mn l mo mp">   for(i=0; i &lt; array.length; i++){</span><span id="b674" class="ml le in mh b gy mq mn l mo mp">   //if the number we are on in the first array matches the number  we are on in the second array then add 1 to the variable j <br/>   if (array[i] === sequence[j]) {<br/>         j++</span><span id="0973" class="ml le in mh b gy mq mn l mo mp">//Add 1 to j<br/>      }<br/>   }<br/>  if (j === sequence.length) {</span><span id="0a2b" class="ml le in mh b gy mq mn l mo mp">//if the final index of the sequence array is equal to the sequence's length then return true<br/>  return true<br/> } else {</span><span id="53f9" class="ml le in mh b gy mq mn l mo mp">//in all other cases return false<br/>  return false<br/> }</span><span id="11f0" class="ml le in mh b gy mq mn l mo mp">}</span></pre><p id="c714" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我这样编码是因为一旦发现整个序列与主数组相匹配，在序列的结束索引与序列中的项目数(长度)相匹配之后，序列就确实存在于主数组中。另一方面，如果不是序列中的所有数字都匹配主数组的某个部分，那么j将不会像我们的for循环中看到的那样递增。请记住，只有当主数组的编号与序列的编号匹配时，j才能递增。这就是为什么在所有其他情况下，函数将返回false。</p><p id="537f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的算法解决方案到此结束。</p><h1 id="e330" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">将其付诸实践—一个测试用例示例</h1><p id="3821" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">在这一点上，我想用我的解决方案来实现一个测试用例，因为我知道如果没有一个好的例子，整个事情看起来可能会令人困惑。</p><p id="0d0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">测试用例输入:</strong>数组= [1，1，6，1]，序列= [1，1，1，6]</p><p id="5dc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">检测例输出:</strong>假</p><p id="4c6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，我们开始吧:</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="aceb" class="ml le in mh b gy mm mn l mo mp">1 function isValidSubsequence(array, sequence) {<br/> 2 let j=0<br/> 3 for(i=0; i &lt; array.length; i++){<br/> <br/> 4 if (array[i] === sequence[j]) {<br/> 5 j++<br/> 6 }<br/> 7 }<br/> 8 if (j === sequence.length) {<br/> 9   return true<br/> 10 } else {<br/>    11 return false<br/> 12 }<br/>13 }</span></pre><p id="cbef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一次通过时，我们从主数组中第0位的1(由I表示)和序列数组中第0位的1(由j表示)开始。</p><p id="19f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第4行，如果我们正在检查的数字，在这种情况下是1，等于我们正在另一个数组中检查的数字，在这种情况下也是1，那么增量j. J现在等于1，只要for循环经过另一轮，我总是递增1，所以现在i = 1。(i=1，j=1)</p><p id="4168" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">for循环不断重复，直到它遍历了主数组中的所有数字。它通过运行第3行到第7行来重复。</p><p id="ff04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二次，我们再次从主数组中第一位的1(再次由I表示)和序列数组中第一位的1(再次由j表示)开始。同样，我们检查的数字彼此相等，所以现在j和I再次递增。(i=2，j=2)</p><p id="3e74" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在情况将在第三轮发生变化，主数组中的6与序列数组中的1相比。这次j不会增加，因为我们的条件是假的，但是变量I仍然会增加。(i=3，j=2)</p><p id="49de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">for循环再次运行，不会再增加j，所以现在技术上i=4对j=2。for循环结束，因为数组中的所有元素都已被检查过，现在代码在第8行运行。</p><pre class="kz la lb lc gt mg mh mi mj aw mk bi"><span id="2d53" class="ml le in mh b gy mm mn l mo mp">8 if (j === sequence.length) {<br/> 9   return true<br/> 10 } else {<br/>    11 return false<br/> 12 }<br/>13 }</span></pre><p id="6397" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后的检查表明，如果j等于数组中序列的长度，则返回true。我们知道，代表j的2不等于3，3是序列数组的长度，从0开始计数，就像计算机一样。因此，这个测试用例示例在第11行返回false。</p><p id="c30d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个算法肯定不是我做过的最难的一个，但绝对是一个让我在掌握一些更困难的挑战上有一个好的开始。很可能以后会有更多类似这样的博客文章出现在这条崎岖的算法道路上，可能是因为我对它们的着迷，以及我对它们对软件开发世界有多重要的理解。</p><p id="370c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，重要的是要记住算法只是过程列表，如果你能弄清楚列表的每一部分用什么来编码，最终得到测试用例工作的结果，那么你就找到了解决方案。</p><p id="410e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你自己想在算法方面变得更好，我强烈建议你试试Algoexpert.io。我知道你可能已经看到了劣质的YouTube广告，但这个网站真的可以通过漂亮的用户界面使学习算法变得更容易。快乐的算法求解和蛋糕制作:)</p></div></div>    
</body>
</html>