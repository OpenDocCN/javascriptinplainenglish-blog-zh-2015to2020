<html>
<head>
<title>Build a ‘Like’ Counter With Fauna, Netlify and Nuxt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用动物群、Netlify和Nuxt建立一个“Like”计数器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-like-counter-with-fauna-netlify-and-nuxt-d4106d30a821?source=collection_archive---------18-----------------------#2020-10-26">https://javascript.plainenglish.io/build-a-like-counter-with-fauna-netlify-and-nuxt-d4106d30a821?source=collection_archive---------18-----------------------#2020-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e10b84a540658293f0633696bc46aa5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tka-91MFOHmeqLZ7.png"/></div></div></figure><h1 id="97ba" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="0f59" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">当我建立这个网站的时候，我不断地从我所关注和敬仰的科技领域的一些人那里寻找灵感。其中一个人就是<strong class="kv io">乔希·科莫</strong>(推特上的@乔希·科莫)。</p><p id="a752" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在他的网站上，我读了一篇名为<a class="ae lw" href="https://joshwcomeau.com/react/serverless-hit-counter/" rel="noopener ugc nofollow" target="_blank">构建现代点击计数器</a>的博客，这篇博客揭示了在Jamstack网站上，与FaunaDB配合使用的无服务器功能有多么强大。</p><p id="9281" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">虽然他的帖子主要涉及React/Gatsby，但我想使用他提供的一些无服务器概念和代码在每个博客帖子上创建一个“like”计数器(在我的情况下是一个“voltage”计数器)，作为一个很酷的小细节(<strong class="kv io"> <em class="lx">非常类似于Josh在他的博客帖子</em> </strong>上的“heart”计数器)。我也将重用和扩展他的一些代码，所以我想给他信用！</p><p id="041c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这篇文章的目的是让你使用Netlify函数和<a class="ae lw" href="https://fauna.com/" rel="noopener ugc nofollow" target="_blank"> FaunaDB </a>进行设置，并向你展示如何利用这些工具为你的个人Nuxt博客构建一个动态的“like”计数器。</p><h1 id="e663" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置</h1><p id="32d9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我们开始之前，我们需要确保我们有一个<strong class="kv io">动物群</strong>帐户设置来处理存储和检索数据，以及一个<strong class="kv io"> Netlify </strong>帐户，我们将在其中部署我们的应用程序和捆绑的无服务器功能。</p><p id="8392" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">另外，你需要选择一个你喜欢的无头CMS来管理你的博客内容。我个人使用<a class="ae lw" href="https://content.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Nuxt Content </a>，但是只要你能利用或者为每篇博客文章定义一个独特的<code class="fe ly lz ma mb b">slug</code>，你就没问题！</p><h1 id="e4f9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">动物群</h1><p id="6d1e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">一旦你创建了一个动物账户，你需要登录并为你的项目创建一个新的数据库。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/509e0792fa5bd4b80036ee53406dcff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naBduFyDmC33eYB-X23x7Q.png"/></div></div></figure><p id="9272" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在建立我们的数据库后，我们还需要创建一个集合来存储我们每个博客帖子的赞。继续创建一个名为“喜欢”的。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/fabb327ad1ec0189a024c0be16faced2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LftBYXMDochUOqBqiajlA.png"/></div></div></figure><p id="3c79" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为了成功地查询我们的数据库，我们还需要建立一个<strong class="kv io">索引</strong>。索引允许我们根据文档属性而不是文档引用来查询文档，这在我们使用博客<code class="fe ly lz ma mb b">slug</code>获取和更新我们相应的喜好时非常重要。</p><p id="fc04" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">继续创建一个名为<code class="fe ly lz ma mb b">likes_by_slug</code>的索引，使用我们的<code class="fe ly lz ma mb b">likes</code>集合作为源集合，<code class="fe ly lz ma mb b">data.slug</code>是我们可以搜索的术语之一。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/fc48e323afc65d96ddea5d9549ea35c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfzXhYp50Dx1zjjLmlfklQ.png"/></div></div></figure><p id="17d6" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">太神奇了！我们快到了。现在我们需要生成一个API密钥，我们可以在Nuxt项目中使用它来安全地查询我们的动物群数据库。导航到您的动物仪表板中的<strong class="kv io">安全</strong>部分，并生成一个新的管理密钥。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/a4ca12d61b29923f409898eb26b998fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmxWNdF3TlpaEQJPxHdXzQ.png"/></div></div></figure><p id="abaa" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们将使用<code class="fe ly lz ma mb b">FAUNA_SECRET_KEY</code>环境变量来引用这个键。</p><h1 id="3574" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">Nuxt</h1><p id="0c8f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">太好了！我们已经准备好动物了。现在我们可以跳到我们的Nuxt项目，开始引入一些我们需要的依赖项。</p><p id="d961" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">继续安装<a class="ae lw" href="https://www.npmjs.com/package/faunadb" rel="noopener ugc nofollow" target="_blank">动物群npm包</a>。</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="fcf0" class="mo jw in mb b gy mp mq l mr ms"># install using npm </span><span id="15e8" class="mo jw in mb b gy mt mq l mr ms">npm install --save faunadb </span><span id="9670" class="mo jw in mb b gy mt mq l mr ms"># install using yarn </span><span id="b4f6" class="mo jw in mb b gy mt mq l mr ms">yarn add faunadb</span></pre><p id="ffdd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们还将使用<a class="ae lw" href="https://axios.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> Axios </a>来处理我们的API请求，所以继续安装Nuxt模块:</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="50c6" class="mo jw in mb b gy mp mq l mr ms"># install using npm </span><span id="adba" class="mo jw in mb b gy mt mq l mr ms">npm install @nuxtjs/axios </span><span id="5067" class="mo jw in mb b gy mt mq l mr ms"># install using yarn </span><span id="3b96" class="mo jw in mb b gy mt mq l mr ms">yarn add @nuxtjs/axios</span></pre><p id="8a14" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">并将其添加到您的<code class="fe ly lz ma mb b">nuxt.config.js</code>文件中:</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="84ff" class="mo jw in mb b gy mp mq l mr ms">export default {<br/>  modules: ['@nuxtjs/axios']<br/>}</span></pre><p id="d2d3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">此外，在项目的根目录下创建一个<code class="fe ly lz ma mb b">.env</code>文件，并放入您之前生成的动物群API密匙</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="e869" class="mo jw in mb b gy mp mq l mr ms">BASE_URL=YOUR_PROD_URL<br/>FAUNA_SECRET_KEY=YOUR_KEY</span></pre><p id="cd92" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">太好了！最后，我们现在可以使用我们的<code class="fe ly lz ma mb b">BASE_URL</code>环境变量来为本地开发和生产部署设置Axios。</p><p id="186b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">当我使用<a class="ae lw" href="https://www.netlify.com/products/dev/" rel="noopener ugc nofollow" target="_blank"> Netlify Dev </a>在本地运行我的Netlify项目时，我在端口<code class="fe ly lz ma mb b">8888</code>上运行它。为了在我们尝试测试无服务器功能时不出现问题，我们需要告诉Axios通过端口<code class="fe ly lz ma mb b">8888</code>调用，或者在本地开发时通过您喜欢的任何端口调用。</p><p id="56b8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">将这一行添加到您的<code class="fe ly lz ma mb b">nuxt.config.js</code>文件中:</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="0742" class="mo jw in mb b gy mp mq l mr ms">export default {<br/>  axios: {<br/>    baseURL: process.env.NODE_ENV === 'production' ? process.env.BASE_URL : 'http://localhost:8888/',<br/>  },<br/>}</span></pre><h1 id="cfa7" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">网络生活</h1><p id="8db7" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果你不熟悉<a class="ae lw" href="https://www.netlify.com/products/functions/" rel="noopener ugc nofollow" target="_blank"> Netlify函数</a>，它们本质上是在AWS Lambda之上的Netlify的包装器(具有非常大的自由层)。简而言之，它们是完全受管理的、自动扩展的无服务器功能，适用于您的网络项目。</p><p id="e764" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为了确保我们部署的站点能够成功查询我们的动物群数据库，我们需要导航到Netlify并添加我们之前定义的<a class="ae lw" href="https://docs.netlify.com/configure-builds/environment-variables/" rel="noopener ugc nofollow" target="_blank">环境变量</a>，这样当我们部署应用程序时，它们将对我们的应用程序可用！</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/be8bb83789e902d6df3cc8bfa555fce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4B_llO7_AvSuwuAV_NtRQ.png"/></div></div></figure><p id="bee8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您还应该检查一下<a class="ae lw" href="https://www.netlify.com/products/dev/" rel="noopener ugc nofollow" target="_blank"> Netlify Dev </a>，它将允许您在部署之前在本地测试您的功能。这可以在调试函数和UI时节省大量时间。这是一个有点复杂的过程，所以我不会涉及它，但是我强烈建议您安装Netlify CLI，并将您的站点链接到您的项目！</p><p id="97bf" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">太好了。我们现在已经完全完成了所需零件的安装。</p><p id="bc80" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们有<strong class="kv io">动物群</strong>来处理我们的“喜好”存储，<strong class="kv io"> Netlify函数</strong>来处理通过<strong class="kv io"> Axios </strong>更新和检索数据，这是我们选择的无头CMS，当然还有<strong class="kv io"> Nuxt </strong>！</p><p id="fc39" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">是时候深入研究一些代码了！</p><h1 id="0f1d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">编写我们的函数</h1><p id="cef1" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们对这些功能的需求可以分为两部分。</p><ul class=""><li id="1c40" class="mv mw in kv b kw lr la ls le mx li my lm mz lq na nb nc nd bi translated">我们需要获取当前喜欢的博客页面加载</li><li id="51fb" class="mv mw in kv b kw ne la nf le ng li nh lm ni lq na nb nc nd bi translated">当用户点击我们的“喜欢”计数器时，我们需要能够增加这些喜欢</li></ul><h1 id="14a8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">获取喜欢的功能</h1><p id="eeb9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们将从一个能让我们的博客依靠页面加载(或组件安装)的博客开始。</p><p id="3bea" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">继续，在你的Nuxt项目的根目录下创建一个名为<code class="fe ly lz ma mb b">functions</code>的文件夹。每次部署时，Netlify都会自动在此处查找任何无服务器功能。</p><p id="f29c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在<code class="fe ly lz ma mb b">functions</code>文件夹内创建一个名为<code class="fe ly lz ma mb b">fetch_likes_for_blog.js</code>的文件。</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="9db8" class="mo jw in mb b gy mp mq l mr ms">// Credit to Josh Comeau <br/>const faunadb = require('faunadb');<br/>exports.handler = async (event) =&gt; {<br/>  const q = faunadb.query;<br/>  const client = new faunadb.Client({<br/>    secret: process.env.FAUNA_SECRET_KEY,<br/>  });<br/><br/>  const { slug } = event.queryStringParameters;<br/>  if (!slug) {<br/>    return {<br/>      statusCode: 400,<br/>      body: JSON.stringify({<br/>        message: 'Article slug not provided',<br/>      }),<br/>    };<br/>  }<br/><br/>  const doesDocExist = await client.query(<br/>    q.Exists(q.Match(q.Index('likes_by_slug'), slug))<br/>  );<br/><br/>  if (!doesDocExist) {<br/>    await client.query(<br/>      q.Create(q.Collection('likes'), {<br/>        data: { slug: slug, likes: 1 },<br/>      })<br/>    );<br/>  }<br/><br/>  const document = await client.query(<br/>    q.Get(q.Match(q.Index('likes_by_slug'), slug))<br/>  );<br/><br/>  return {<br/>    statusCode: 200,<br/>    body: JSON.stringify({<br/>      likes: document.data.likes,<br/>    }),<br/>  };<br/>};</span></pre><p id="2140" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们从头到尾看一遍。</p><ol class=""><li id="7be2" class="mv mw in kv b kw lr la ls le mx li my lm mz lq nj nb nc nd bi translated">首先，我们正在用之前生成的密钥初始化我们的动物群客户端</li><li id="20f8" class="mv mw in kv b kw ne la nf le ng li nh lm ni lq nj nb nc nd bi translated">我们正在检查博客段是否作为查询参数提供，如果没有，我们返回<strong class="kv io"> 400 </strong></li><li id="e2ef" class="mv mw in kv b kw ne la nf le ng li nh lm ni lq nj nb nc nd bi translated">我们检查动物群中的文件是否已经存在</li><li id="3b94" class="mv mw in kv b kw ne la nf le ng li nh lm ni lq nj nb nc nd bi translated">如果它不存在，我们会在<code class="fe ly lz ma mb b">likes</code>集合中创建一个新的文档，并使用我们的<code class="fe ly lz ma mb b">slug</code>作为唯一的标识符将初始的喜欢设置为<code class="fe ly lz ma mb b">1</code></li><li id="1384" class="mv mw in kv b kw ne la nf le ng li nh lm ni lq nj nb nc nd bi translated">我们查询之前使用<code class="fe ly lz ma mb b">slug</code>创建的<code class="fe ly lz ma mb b">likes_by_slug</code>索引，以检索当前的喜好</li><li id="32f5" class="mv mw in kv b kw ne la nf le ng li nh lm ni lq nj nb nc nd bi translated">我们会回复类似博客的内容</li></ol><h1 id="258d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">递增喜欢函数</h1><p id="f873" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这个函数与fetch函数非常相似，除了我们需要在将现有的like count返回给客户端之前对其进行递增。</p><p id="f285" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">当用户与我们想用来处理喜欢博客文章的图标/按钮交互时，我们将调用这个函数。</p><p id="1e54" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在你的<code class="fe ly lz ma mb b">functions</code>目录下创建一个名为<code class="fe ly lz ma mb b">register-like.js</code>的新文件</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="b6b3" class="mo jw in mb b gy mp mq l mr ms">// Credit to Josh Comeau<br/>const faunadb = require('faunadb');<br/>exports.handler = async (event) =&gt; {<br/>  const q = faunadb.query;<br/>  const client = new faunadb.Client({<br/>    secret: process.env.FAUNA_SECRET_KEY,<br/>  });<br/><br/>  const { slug } = event.queryStringParameters;<br/>  if (!slug) {<br/>    return {<br/>      statusCode: 400,<br/>      body: JSON.stringify({<br/>        message: 'Article slug not provided',<br/>      }),<br/>    };<br/>  }<br/><br/>  const doesDocExist = await client.query(<br/>    q.Exists(q.Match(q.Index('likes_by_slug'), slug))<br/>  );<br/>  <br/>  if (!doesDocExist) {<br/>    await client.query(<br/>      q.Create(q.Collection('likes'), {<br/>        data: { slug: slug, likes: 1 },<br/>      })<br/>    );<br/>  }<br/><br/>  const document = await client.query(<br/>    q.Get(q.Match(q.Index('likes_by_slug'), slug))<br/>  );<br/><br/>  await client.query(<br/>    q.Update(document.ref, {<br/>      data: {<br/>        likes: document.data.likes + 1,<br/>      },<br/>    })<br/>  );<br/><br/>  return {<br/>    statusCode: 200,<br/>    body: JSON.stringify({<br/>      likes: document.data.likes,<br/>    }),<br/>  };<br/>};</span></pre><p id="c912" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">正如您所看到的，代码本质上是相同的，除了在我们查询索引之后，我们在我们的文档上运行<code class="fe ly lz ma mb b">update</code>并按<code class="fe ly lz ma mb b">1</code>递增。</p><h1 id="4142" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">在Nuxt中使用我们的功能</h1><p id="37a8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">当我们最终部署应用程序时，我们可以通过以下途径获得它们:<code class="fe ly lz ma mb b">/.netlify/functions/NAME_OF_FUNCTION</code>。</p><p id="db4c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在我的例子中，我创建了一个<a class="ae lw" href="https://github.com/DavidTParks/dev-portfolio-2.0/blob/master/components/VoltBatteryCounter.vue" rel="noopener ugc nofollow" target="_blank"> VoltBatteryCounter </a>组件，我在<code class="fe ly lz ma mb b">pages/blog/_slug.vue</code>中插入到我的动态博客页面的侧面。在这个组件中，我利用<code class="fe ly lz ma mb b">this.$route.params.slug</code>将段塞传递给函数。</p><p id="71fd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">由于我使用的是Nuxt的<code class="fe ly lz ma mb b">static</code>模式，我正在利用设置了<code class="fe ly lz ma mb b">fetchOnServer: false</code>的<a class="ae lw" href="https://nuxtjs.org/api/pages-fetch/" rel="noopener ugc nofollow" target="_blank">获取</a>钩子，以确保每次安装组件时调用钩子，而不是在构建期间只调用一次。</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="6b33" class="mo jw in mb b gy mp mq l mr ms">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      initialLikes: null,<br/>    }<br/>  },<br/>  async fetch() {<br/>    const { data } = await this.$axios.get(`/.netlify/functions/fetch_likes_for_blog?slug=${this.$route.params.slug}`);<br/>    this.initialLikes = data.likes;<br/>  },<br/>  fetchOnServer: false,<br/>}<br/>&lt;/script&gt;</span></pre><p id="4566" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">然后，每当用户点击我博客右边的电池，我就会使用我们之前设置的<strong class="kv io"> Axios </strong>调用servleress函数来增加相同的计数。</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="3d65" class="mo jw in mb b gy mp mq l mr ms">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      initialLikes: null,<br/>    }<br/>  },<br/>  async fetch() {<br/>    const { data } = await this.$axios.get(`/.netlify/functions/fetch_likes_for_blog?slug=${this.$route.params.slug}`);<br/>    this.initialLikes = data.likes;<br/>  },<br/>  fetchOnServer: false,<br/>  methods: {<br/>    addLike() {<br/>      this.initialLikes++;<br/>      this.incrementLikes();<br/>    },<br/>    async incrementLikes() {<br/>      await this.$axios.post(`/.netlify/functions/register-like?slug=${this.$route.params.slug}`);<br/>    }<br/>  },<br/>}<br/>&lt;/script&gt;</span></pre><p id="7d84" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">不过，你可能想知道,<strong class="kv io"> <em class="lx">如果有人决定垃圾邮件我的喜欢按钮数千次，并完全吃掉我的自由层的功能呢？</em> </strong></p><p id="c351" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有几条路你可以走。其中之一是引入一些像<code class="fe ly lz ma mb b">userLikeCount</code>这样的地方州，以及一个名为<code class="fe ly lz ma mb b">likesMaxed</code>的计算属性，该属性只允许用户将计数器增加12次左右。例如:</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="8877" class="mo jw in mb b gy mp mq l mr ms">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      initialLikes: null,<br/>      userLikeCount: 0,<br/>    }<br/>  },<br/>  async fetch() {<br/>    const { data } = await this.$axios.get(`/.netlify/functions/fetch_likes_for_blog?slug=${this.$route.params.slug}`);<br/>    this.initialLikes = data.likes;<br/>  },<br/>  fetchOnServer: false,<br/>  methods: {<br/>    addLike() {<br/>      if(!likesMaxed) {<br/>        this.initialLikes++;<br/>        this.userLikeCount++;<br/>        this.incrementLikes();<br/>      }<br/>    },<br/>    async incrementLikes() {<br/>      await this.$axios.post(`/.netlify/functions/register-like?slug=${this.$route.params.slug}`);<br/>    }<br/>  },<br/>  computed: {<br/>    likesMaxed() {<br/>      return this.userLikeCount &gt;= 12;<br/>    },<br/>  },<br/>}<br/>&lt;/script&gt;</span></pre><p id="c448" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">然而，用户只需重新加载页面，并将计数器再增加12次。</p><p id="6733" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在我的例子中，我决定使用<code class="fe ly lz ma mb b">localStorage</code>来确保每个博客帖子用户最多只能增加12次相同的次数，这将会持续到后续的页面访问中(这个想法归功于<a class="ae lw" href="https://twitter.com/li_hbr" rel="noopener ugc nofollow" target="_blank">露西</a>！)</p><h1 id="68c2" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">将喜好存储在本地存储中</h1><p id="ce6c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先在你的Nuxt项目的<code class="fe ly lz ma mb b">store</code>目录中创建一个名为<code class="fe ly lz ma mb b">index.js</code>的文件。</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="b980" class="mo jw in mb b gy mp mq l mr ms">export const state = () =&gt; ({<br/>  storedUserLikes: 1<br/>})<br/><br/>export const mutations = {<br/>  initializeLikes(state, slug) {<br/>    const storedLikes = Math.abs(Number(localStorage.getItem(slug)));<br/><br/>    if(storedLikes) {<br/>      storedLikes &gt;= 12 ? state.storedUserLikes = 12 : state.storedUserLikes = storedLikes;<br/>    } else {<br/>      localStorage.setItem(slug, 1);<br/>      state.storedUserLikes = 1;<br/>    }<br/>  },<br/>  incrementLikes(state, slug) {<br/>    state.storedUserLikes = state.storedUserLikes + 1;<br/>    localStorage.setItem(slug, state.storedUserLikes);<br/>  }<br/>}</span></pre><p id="e201" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">首先，我通过从本地存储中读取相关的计数来初始化页面上的喜欢。</p><p id="09dd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我还添加了一些检查，以获得绝对值，以防用户将其编辑为负数，允许他们无限点击，并确定该数字是否大于12，以仅将storedLikes设置为12。</p><p id="b209" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，我们可以扩展我们以前的代码来利用这个新的全局状态。</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="9fc9" class="mo jw in mb b gy mp mq l mr ms">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      initialLikes: null,<br/>      userLikeCount: 0,<br/>    }<br/>  },<br/>  async fetch() {<br/>    const { data } = await this.$axios.get(`/.netlify/functions/fetch_likes_for_blog?slug=${this.$route.params.slug}`);<br/>    this.initialLikes = data.likes;<br/>  },<br/>  mounted() {<br/>    this.$store.commit('initializeLikes', this.$route.params.slug);<br/>  },<br/>  fetchOnServer: false,<br/>  methods: {<br/>    async addLike() {<br/>      if(this.storedUserLikes &lt; 12) {<br/>        this.initialLikes++;<br/>        this.$store.commit('incrementLikes', this.$route.params.slug);<br/>        this.incrementLikes();<br/>      }<br/>    },<br/>    async incrementLikes() {<br/>      await this.$axios.post(`/.netlify/functions/register-like?slug=${this.$route.params.slug}`);<br/>    }<br/>  },<br/>  computed: {<br/>    likesMaxed() {<br/>      return this.userLikeCount &gt;= 12;<br/>    },<br/>    storedUserLikes() {<br/>      return this.$store.state.storedUserLikes;<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="364e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们首先在<code class="fe ly lz ma mb b">mounted()</code>钩子中调用我们的Vuex突变<code class="fe ly lz ma mb b">initializeLikes</code>,因为localStorage对我们来说是可用的，然后我们使用一个计算属性<code class="fe ly lz ma mb b">storedUserLikes</code>从我们的存储中检索那个博客的赞(如果有的话)。</p><p id="ea85" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">厉害！我们现在有了一个like计数器，它在多个会话和页面访问中保持不变。这取决于你想如何呈现喜欢计数，所以用你的想象力！如果你想做一些类似于我的电池的事情，请随时查看我在Github上的<a class="ae lw" href="https://github.com/DavidTParks/dev-portfolio-2.0/blob/master/components/VoltBatteryCounter.vue" rel="noopener ugc nofollow" target="_blank">源代码</a>，因为我已经决定开源我的网站。</p><p id="e9e6" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你喜欢更传统的“喜欢按钮”外观，这里有一个简单的顺风按钮让你开始！</p><pre class="md me mf mg gt mk mb ml mm aw mn bi"><span id="4a17" class="mo jw in mb b gy mp mq l mr ms">&lt;template&gt;<br/>  &lt;button @click="addLike" class="focus:outline-none" :class="{'text-red-600' : likesMaxed}"&gt;<br/>    {{initialLikes}}<br/>    &lt;svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" &gt;&lt;path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"&gt;&lt;/path&gt;&lt;/svg&gt;<br/>  &lt;/button&gt;<br/>&lt;/template&gt;</span></pre><h1 id="6ce0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">包扎</h1><p id="92ed" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果你已经走了这么远，干得好！我迫不及待地(希望)在未来静态生成的Nuxt站点上看到更多动态的计数器。</p><p id="16d7" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你决定实施一个，请在Twitter上告诉我！我很想看看你有什么想法。</p><p id="8c43" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">感谢阅读！</p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="6678" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><em class="lx">原载于2020年10月26日</em><a class="ae lw" href="https://davidparks.dev/blog/building-a-like-counter-with-faunadb-and-nuxt" rel="noopener ugc nofollow" target="_blank"><em class="lx">https://David parks . dev</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>