<html>
<head>
<title>Useful Lodash Array Functions — Extraction and Intersection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的Lodash数组函数—提取和相交</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useful-lodash-array-functions-extraction-and-intersection-106569b7238?source=collection_archive---------2-----------------------#2020-02-28">https://javascript.plainenglish.io/useful-lodash-array-functions-extraction-and-intersection-106569b7238?source=collection_archive---------2-----------------------#2020-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/093690353cde2b0e3f83df9911902873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n7IV9kxJptPKisK5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bec_brown?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bec Brown</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fb53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个实用程序库，有很多操作对象的方法。它有我们一直在使用的东西，也有我们不常使用或不想使用的东西。</p><p id="7bca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究更有用的Lodash数组方法，包括<code class="fe lb lc ld le b">head</code>、<code class="fe lb lc ld le b">indexOf</code>、<code class="fe lb lc ld le b">initial</code>、<code class="fe lb lc ld le b">intersection</code>、<code class="fe lb lc ld le b">intersectionBy</code>和<code class="fe lb lc ld le b">intersectionWith</code>方法。</p><h1 id="7a40" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">头</h1><p id="f1da" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">方法获取数组的第一个元素并返回它。<code class="fe lb lc ld le b">first</code>是<code class="fe lb lc ld le b">head</code>的别名。</p><p id="8f1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将一个数组作为唯一的参数。</p><p id="bde3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9396" class="mq lg iq le b gy mr ms l mt mu">import * as _ from "lodash";<br/>const array = [1, 2, 3];<br/>const result = _.head(array);<br/>console.log(result);</span></pre><p id="3cca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们对<code class="fe lb lc ld le b">result</code>得到1。<code class="fe lb lc ld le b">head</code>返回<code class="fe lb lc ld le b">undefined</code>传入的数组是否为空。</p><h1 id="199a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">indexOf</code></h1><p id="c8ee" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">indexOf</code>获取传入参数的数组中第一个匹配项的索引并返回。</p><p id="4c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最多需要3个参数。第一个是要搜索的数组。第二个参数是要查找的值。第三个是索引开始搜索的可选参数。</p><p id="6859" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4c86" class="mq lg iq le b gy mr ms l mt mu">import * as _ from "lodash";<br/>const array = [1, 2, 3];<br/>const result = _.indexOf(array, 2, 1);<br/>console.log(result);</span></pre><p id="df01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到1，因为2在第二个位置，我们从开始搜索。</p><h1 id="b6d3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">initial</code></h1><p id="3af2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">initial</code>方法获取数组中除最后一个元素之外的所有元素并返回它。</p><p id="5187" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将一个数组作为唯一的参数。</p><p id="d2d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7cf7" class="mq lg iq le b gy mr ms l mt mu">import * as _ from "lodash";<br/>const array = [1, 2, 3];<br/>const result = _.initial(array);<br/>console.log(result);</span></pre><p id="bb5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lb lc ld le b">result</code>的<code class="fe lb lc ld le b">[1, 2]</code>。</p><h1 id="95ce" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">intersection</code></h1><p id="fc3b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">intersection</code>方法返回包含在所有给定数组中的值的数组。相等比较是用SameValueZero比较完成的，除了<code class="fe lb lc ld le b">NaN</code>被认为等于自身之外，它与<code class="fe lb lc ld le b">===</code>相同。</p><p id="d13e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个逗号分隔的数组列表来返回交集。</p><p id="9f41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="01f0" class="mq lg iq le b gy mr ms l mt mu">import * as _ from "lodash";<br/>const arr1 = [1, 2, 3];<br/>const arr2 = [3, 4, 5];<br/>const result = _.intersection(arr1, arr2);<br/>console.log(result);</span></pre><p id="1123" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lb lc ld le b">[3]</code>，因为在<code class="fe lb lc ld le b">arr1</code>和<code class="fe lb lc ld le b">arr2</code>中只有3个。</p><h1 id="0f0f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">intersectionBy</code></h1><p id="21c4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">intersectionBy</code>与<code class="fe lb lc ld le b">intersection</code>相似，只是它采用了一个为每个数组的每个元素调用的函数来生成比较项目的标准。第一个数组确定结果的顺序和引用。</p><p id="d8d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它以逗号分隔的数组列表作为参数，以一个函数作为要比较的标准来查找交集，或者以一个字符串作为要比较的属性名。</p><p id="3d92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="45b5" class="mq lg iq le b gy mr ms l mt mu">import * as _ from "lodash";<br/>const arr1 = [<br/>  { name: "Joe", age: 10 },<br/>  { name: "Mary", age: 12 },<br/>  { name: "Jane", age: 13 }<br/>];<br/>const arr2 = [<br/>  { name: "Joe", age: 10 },<br/>  { name: "Jerry", age: 12 },<br/>  { name: "Amy", age: 13 }<br/>];<br/>const result = _.intersectionBy(arr1, arr2, a =&gt; a.name);<br/>console.log(result);</span></pre><p id="a9c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ee3f" class="mq lg iq le b gy mr ms l mt mu">[<br/>  {<br/>    "name": "Joe",<br/>    "age": 10<br/>  }<br/>]</span></pre><p id="76ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe lb lc ld le b">result</code>。</p><p id="5fe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe lb lc ld le b">'name'</code>代替<code class="fe lb lc ld le b">a =&gt; a.name</code>，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fd5f" class="mq lg iq le b gy mr ms l mt mu">import * as _ from "lodash";<br/>const arr1 = [<br/>  { name: "Joe", age: 10 },<br/>  { name: "Mary", age: 12 },<br/>  { name: "Jane", age: 13 }<br/>];<br/>const arr2 = [<br/>  { name: "Joe", age: 10 },<br/>  { name: "Jerry", age: 12 },<br/>  { name: "Amy", age: 13 }<br/>];<br/>const result = _.intersectionBy(arr1, arr2, "name");<br/>console.log(result);</span></pre><p id="4d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到同样的东西。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/98be024421b9fb5a4b05f8828c650ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZnREXkZlLjC24pO5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@seandubois?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sean DuBois</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b13f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">intersectionWith</code></h1><p id="e61b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">intersectionWith</code>类似于<code class="fe lb lc ld le b">intersection</code>，只是它将一个比较器函数作为最后一个参数。该函数的参数是数组中要比较的2个条目。</p><p id="ecfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它以逗号分隔的数组列表作为参数，比较器函数作为最后一个参数。</p><p id="c42e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a529" class="mq lg iq le b gy mr ms l mt mu">import * as _ from "lodash";<br/>const arr1 = [<br/>  { name: "Joe", age: 10 },<br/>  { name: "Mary", age: 12 },<br/>  { name: "Jane", age: 13 }<br/>];<br/>const arr2 = [<br/>  { name: "Joe", age: 10 },<br/>  { name: "Jerry", age: 12 },<br/>  { name: "Amy", age: 13 }<br/>];<br/>const result = _.intersectionWith(arr1, arr2, (a, b) =&gt; a.name === b.name);<br/>console.log(result);</span></pre><p id="018a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4d89" class="mq lg iq le b gy mr ms l mt mu">[<br/>  {<br/>    "name": "Joe",<br/>    "age": 10<br/>  }<br/>]</span></pre><p id="0852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<code class="fe lb lc ld le b">result</code>。</p><p id="479b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">head</code>方法获取数组的第一个元素并返回它。<code class="fe lb lc ld le b">first</code>是<code class="fe lb lc ld le b">head</code>的别名。</p><p id="28c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">indexOf</code>获取传入参数的数组中第一个出现的项目的索引并返回。它可以从默认为0的起始索引开始搜索。</p><p id="8d02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">initial</code>获取数组中除最后一个元素之外的所有元素并返回。</p><p id="b66a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了找到所有数组中的数组条目，我们可以使用<code class="fe lb lc ld le b">intersection</code>、<code class="fe lb lc ld le b">intersectionBy</code>和<code class="fe lb lc ld le b">intersectionWith</code>方法。它们的不同之处在于，它们可以分别采用标准函数进行比较，或者采用比较器方法进行相等性比较。</p></div></div>    
</body>
</html>