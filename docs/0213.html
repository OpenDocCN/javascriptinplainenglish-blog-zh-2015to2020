<html>
<head>
<title>React: Building an accessible FAQ component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:构建可访问的FAQ组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-building-an-accessible-faq-component-bac135116532?source=collection_archive---------0-----------------------#2019-08-18">https://javascript.plainenglish.io/react-building-an-accessible-faq-component-bac135116532?source=collection_archive---------0-----------------------#2019-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="14bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个企业都需要在其网站上有一个常见问题(或FAQ)部分。FAQ，或者一般来说，帮助部分，可以根据产品需求和设计指南来设计，尽管就设计模式而言，有一些模式比其他模式更普遍。一些流行的模式是:</p><ul class=""><li id="ecf5" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">将用户带到相应帮助页面的链接列表，</li><li id="82d0" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">一个简单的问题和答案列表，</li><li id="5d87" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">一组可折叠的部分/手风琴，这是我们在这篇文章中要实现的模式。</li></ul><p id="e143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将在React中从头开始构建一个基本的可访问FAQ组件，并看看我们如何避免一些明显的错误。</p><p id="b30d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这张常见问题的图片，并思考实现它所需的语义结构。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/4982ea3933654d0aa1e1ae932d3ee6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnvDuY0Ukxd_upUQvQT0EA.png"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk">screenshot of the faq example on <a class="ae lp" href="https://www.w3.org/TR/wai-aria-practices/examples/disclosure/disclosure-faq.html" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/wai-aria-practices/examples/disclosure/disclosure-faq.html</a></figcaption></figure><p id="ff06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你怎么想呢?</p><p id="d2ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">纯粹就实施而言:</p><ul class=""><li id="3a6d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">这可以使用<code class="fe lq lr ls lt b">div</code> s来实现。</li><li id="0675" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">这可以使用有序或无序列表来实现。</li><li id="4374" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">这可以使用<code class="fe lq lr ls lt b">button</code>和段落或跨度来实现。<br/>以此类推……</li></ul><p id="c840" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管在语义上，它是某种列表，其中每个FAQ都是一个列表项。每个FAQ都是可折叠的，这意味着点击问题会切换相应的答案。<br/>对于我们当前的目的，基于一些研究，一个<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl" rel="noopener ugc nofollow" target="_blank">定义/描述列表</a>似乎很适合FAQ，其中问题是术语，答案是定义/描述。</p><p id="59af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是基本标记的样子:</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="e0e5" class="ly lz iq lt b gy ma mb l mc md">&lt;dl&gt;<br/> &lt;dt&gt;<br/>  // Question 1 here<br/> &lt;/dt&gt;<br/> &lt;dd&gt;<br/>  // Answer 1 here<br/> &lt;/dd&gt;<br/> &lt;dt&gt;<br/> // Question 2 here<br/> &lt;/dt&gt;<br/> &lt;dd&gt;<br/> // Answer 2 here<br/> &lt;/dd&gt;<br/>&lt;/dl&gt;</span></pre><p id="f001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将要使用的可访问性模式是<a class="ae lp" href="https://www.w3.org/TR/wai-aria-practices/#disclosure" rel="noopener ugc nofollow" target="_blank">公开模式</a>。<br/>功能也类似于<a class="ae lp" href="https://www.w3.org/TR/wai-aria-practices/#accordion" rel="noopener ugc nofollow" target="_blank">手风琴样式</a>。</p><p id="8064" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们做一些观察:</p><ol class=""><li id="bfaf" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk me kr ks kt bi translated">问题需要是可点击的，这意味着语义上问题内容在<code class="fe lq lr ls lt b">button</code>中是有意义的。因为我们使用<code class="fe lq lr ls lt b">dt</code>作为包装器，所以我们将在其中使用一个<code class="fe lq lr ls lt b">button</code>来包装问题内容。</li><li id="452a" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk me kr ks kt bi translated">答案需要是可折叠的，但是即使当答案被折叠时，我们也需要有效的HTML和语义，所以<code class="fe lq lr ls lt b">dd</code>本身永远不会被隐藏(否则定义列表的语义结构将被破坏)，我们将把答案包装在<code class="fe lq lr ls lt b">div</code>或<code class="fe lq lr ls lt b">p</code>中，并在需要时将其折叠。</li><li id="64f2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk me kr ks kt bi translated">屏幕阅读器用户需要理解问题按钮和答案之间的关系，所以我们可以在问题<code class="fe lq lr ls lt b">button</code>上利用<code class="fe lq lr ls lt b">aria-controls</code>来暗示它控制相应的答案。答案需要有一个IDREF(或简称为id ),我们将把它传递给<code class="fe lq lr ls lt b">button</code>的<code class="fe lq lr ls lt b">aria-controls</code>。</li><li id="7bd2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk me kr ks kt bi translated">我们还需要在<code class="fe lq lr ls lt b">button</code>上使用<code class="fe lq lr ls lt b">aria-expanded</code>来指示由<code class="fe lq lr ls lt b">button</code>控制的内容当前是否可见。</li><li id="f623" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk me kr ks kt bi translated">由于我们使用的是<code class="fe lq lr ls lt b">aria-controls</code>，我们需要确保折叠后的答案不会从DOM中移除，否则<code class="fe lq lr ls lt b">aria-controls</code>中的IDREF将会无效，所以我们将简单地使用<code class="fe lq lr ls lt b">display:none</code>来隐藏内容，这将在视觉上隐藏内容，同时对屏幕阅读器用户也是如此。(还要注意，隐藏内容的其他方式，例如<code class="fe lq lr ls lt b">opacity: 0</code>、<code class="fe lq lr ls lt b">height: 0 </code>等只会在视觉上隐藏内容，但是该“隐藏”内容中的交互元素仍然是可聚焦的，并且该内容对于屏幕阅读器用户仍然是可见的)</li></ol><p id="4eaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们需要同时使用<code class="fe lq lr ls lt b">aria-expanded</code>和<code class="fe lq lr ls lt b">aria-controls</code>？</p><p id="6ded" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自<a class="ae lp" href="https://www.w3.org/WAI/PF/aria-1.1/states_and_properties#aria-expanded" rel="noopener ugc nofollow" target="_blank">https://www . w3 . org/WAI/PF/aria-1.1/States _ and _ properties # aria-expanded</a></p><blockquote class="mf mg mh"><p id="df2c" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">如果具有<code class="fe lq lr ls lt b">aria-expanded</code>属性的元素控制不属于该元素的另一个分组容器的扩展，那么作者<strong class="jp ir">应该使用<code class="fe lq lr ls lt b"><a class="ae lp" href="https://www.w3.org/WAI/PF/aria-1.1/states_and_properties#aria-controls" rel="noopener ugc nofollow" target="_blank">aria-controls</a></code>属性来引用该容器。</strong></p></blockquote><p id="6739" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，根据这些观察，让我们看看我们的标记应该是什么样子:</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="5775" class="ly lz iq lt b gy ma mb l mc md">&lt;dl&gt;<br/> &lt;dt&gt;<br/>  &lt;button aria-expanded="true" aria-controls="a1"&gt;Question 1&lt;/button&gt;<br/> &lt;/dt&gt;<br/> &lt;dd&gt;<br/>  &lt;p id="a1"&gt; Answer 1 here &lt;/p&gt;<br/> &lt;/dd&gt;<br/> &lt;dt&gt;<br/>  &lt;button aria-expanded="true" aria-controls="a2"&gt;Question 2&lt;/button&gt;<br/> &lt;/dt&gt;<br/> &lt;dd&gt;<br/>  &lt;p id="a2"&gt; Answer 1 here &lt;/p&gt;<br/> &lt;/dd&gt;<br/>&lt;/dl&gt;</span></pre><p id="597c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始在React中构建它。</p><p id="5f82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们想要为FAQ组件公开的api，有多个选项，我们可以传入一组问题/答案，或者我们可以通过使用render props模式创建内部组件来允许该组件的用户有更大的灵活性，但是，在这种情况下，我们将从一个复合组件开始，其他功能稍后可以在此基础上构建。</p><p id="7934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">注意:关于使用什么模式以及如何实现它的讨论超出了本文的范围，可以在别处找到。</em><a class="mm mn ep" href="https://medium.com/u/db72389e89d8?source=post_page-----bac135116532--------------------------------" rel="noopener" target="_blank"><em class="mi">Kent c . Dodds</em></a><em class="mi">在React组件模式上有一些真实的内容。</em></p><p id="5a17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们的FAQ组件的使用方式</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="2d56" class="ly lz iq lt b gy ma mb l mc md">&lt;FAQ&gt;<br/> &lt;FAQ.Item&gt;<br/>  &lt;FAQ.Question&gt; Question 1&lt;/FAQ.Question&gt;<br/>  &lt;FAQ.Answer&gt; Answer 1&lt;/FAQ.Answer&gt;<br/> &lt;/FAQ.Item&gt;<br/> &lt;FAQ.Item&gt;<br/>  &lt;FAQ.Question&gt; Question 2 &lt;/FAQ.Question&gt;<br/>  &lt;FAQ.Answer&gt; Answer 2&lt;/FAQ.Answer&gt;<br/> &lt;/FAQ.Item&gt;<br/>&lt;/FAQ&gt;</span></pre><p id="f835" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FAQ组件将负责功能性和可访问性方面所需的其他一切。</p><p id="96dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种方法可以实现展开/折叠状态。</p><ul class=""><li id="fcc1" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">每个FAQ项可以单独处理状态，或者</li><li id="9262" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">父FAQ组件可以管理状态。</li></ul><p id="16bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将让父FAQ组件管理状态，因为它可以决定当一个问题被单击时要做什么，这在我们希望构建一个功能时非常有用，我们希望一次只展开一个答案，并且当我们展开另一个答案时，前一个应该折叠。</p><p id="2300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于FAQ组件负责管理状态，我们也将从FAQ组件获得切换功能。</p><h1 id="129a" class="mo lz iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">问题组件</h1><p id="0357" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">让我们构建问题组件。我们知道问题的标记应该是这样的:</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="22ae" class="ly lz iq lt b gy ma mb l mc md">&lt;dt&gt;<br/> &lt;button aria-controls="<em class="mi">answerId</em>" aria-expanded="<em class="mi">true/false</em>" onclick="<em class="mi">toggle</em>"&gt; Question text &lt;/button&gt;<br/>&lt;/dt&gt;</span></pre><p id="699a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于上面的标记，我们可以决定问题组件的api，它需要</p><ul class=""><li id="682c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">它控制的答案的id，必须来自props。</li><li id="2768" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">当前的展开/折叠状态，这也应该来自props，如果我们将它作为问题组件的内部状态，我们将不得不通过父组件将该状态传递给答案组件，因此在这种情况下直接从父组件获取它是很方便的。(这也意味着问题组件是受控组件)</li><li id="542d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">切换功能也应该来自道具。</li><li id="5082" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">内容是作为道具传入的。孩子们，有一些注意事项，例如，我们的问题组件的用户应该确保他们没有传入无效的HTML，因为内容将在<code class="fe lq lr ls lt b">button</code>中呈现。我们还可以让api更严格一点，只允许它们在一个名为<em class="mi"> label </em>或<em class="mi"> text的属性中将文本作为字符串传递。</em></li></ul><p id="e5c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于此，下面是我们的问题组件的样子</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="21d2" class="ly lz iq lt b gy ma mb l mc md">function Question({ children, isOpen, answerId, onToggle }) {<br/> return (<br/>  &lt;dt&gt;<br/>   &lt;button<br/>    className="FAQ__question"<br/>    aria-expanded={isOpen}<br/>    aria-controls={answerId}<br/>    onClick={onToggle}<br/>   &gt;<br/>    {children}<br/>   &lt;/button&gt;<br/>  &lt;/dt&gt;<br/> );<br/>}</span></pre><h1 id="3b22" class="mo lz iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">答案组件</h1><p id="cb53" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">答案部分相当简单。它只需要知道它是折叠的还是展开的，并基于此改变应用的类，这样它就可以隐藏/显示自己。</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="5e5f" class="ly lz iq lt b gy ma mb l mc md">function Answer({ children, id, isOpen }) {<br/> const mergedClassname = classNames("FAQ__answer", {<br/>  "FAQ__answer--hidden: !isOpen<br/> });</span><span id="45b5" class="ly lz iq lt b gy nq mb l mc md"> return (<br/>  &lt;dd&gt;<br/>   &lt;p className={mergedClassname} id={id}&gt;<br/>    {children}<br/>   &lt;/p&gt;<br/>  &lt;/dd&gt;<br/> );<br/>}</span></pre><h1 id="fba8" class="mo lz iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">项目组件</h1><p id="ff8a" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">Item组件只是问题/答案对的包装器，因此它可以将FAQ组件传递的属性转发/转换到问题和答案组件(在复合组件中，我们还可以使用上下文传递这些属性，而不是通过Item组件显式传递它们)。</p><p id="fba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目组件不应该呈现任何额外的标记，因为<code class="fe lq lr ls lt b">dt</code>和<code class="fe lq lr ls lt b">dd</code>已经分别在问题和答案组件中被处理，并且在项目组件中呈现的任何其他标记将破坏语义。</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="95e4" class="ly lz iq lt b gy ma mb l mc md">function Item({ children, isOpen, onToggle }) {<br/> return React.Children.map(children, (child, index) =&gt; {<br/>  return React.cloneElement(child, {<br/>   isOpen: isOpen,<br/>   onToggle: onToggle<br/>  });<br/> });<br/>}</span></pre><h1 id="f54a" class="mo lz iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">常见问题组件</h1><p id="7989" class="pw-post-body-paragraph jn jo iq jp b jq nl js jt ju nm jw jx jy nn ka kb kc no ke kf kg np ki kj kk ij bi translated">FAQ组件负责管理状态，并将isOpen和toggle功能传递给每个Item组件。</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="503a" class="ly lz iq lt b gy ma mb l mc md">function FAQ({ children }) {<br/> const [open, setIsOpen] = useState([]);<br/> const isOpen = index =&gt; {<br/>  return open.includes(index) ? true : false;<br/> };<br/> <br/> const onToggle = index =&gt; {<br/>  if (open.includes(index)) {<br/>   setIsOpen(open.filter(item =&gt; item !== index));<br/>  } else {<br/>   setIsOpen([...open, index]);<br/>  }<br/> };</span><span id="ebbe" class="ly lz iq lt b gy nq mb l mc md"> return (<br/>  &lt;dl&gt;<br/>   {React.Children.map(children, (child, index) =&gt; {<br/>     return React.cloneElement(child, {<br/>      isOpen: isOpen(index),<br/>      onToggle: () =&gt; onToggle(index)<br/>     });<br/>    }<br/>   )}<br/>  &lt;/dl&gt;<br/> );<br/>}</span></pre><p id="129b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">搞定了。</p><p id="3603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经实现了FAQ组件的基本版本。</p><p id="d75b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看<a class="ae lp" href="https://codesandbox.io/s/react-faq-component-4s7o3" rel="noopener ugc nofollow" target="_blank">这个codesandbox例子</a>的更完美的实现。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="03d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，请注意，我们没有从父组件传入answerId，这意味着我们需要在使用组件时显式地传入它，如下所示:</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="6d1c" class="ly lz iq lt b gy ma mb l mc md">&lt;FAQ&gt;<br/> &lt;FAQ.Item&gt;<br/>  &lt;FAQ.Question answerId="a1"&gt; Question 1 &lt;/FAQ.Question&gt;<br/>  &lt;FAQ.Answer id="a1"&gt; Answer 1&lt;/FAQ.Answer&gt;<br/> &lt;/FAQ.Item&gt;<br/> &lt;FAQ.Item&gt;<br/>  &lt;FAQ.Question answerId="a2"&gt; Question 2 &lt;/FAQ.Question&gt;<br/>  &lt;FAQ.Answer id="a2"&gt; Answer 2&lt;/FAQ.Answer&gt;<br/> &lt;/FAQ.Item&gt;<br/>&lt;/FAQ&gt;</span></pre><p id="daed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者像这样:</p><pre class="la lb lc ld gt lu lt lv lw aw lx bi"><span id="70b9" class="ly lz iq lt b gy ma mb l mc md">&lt;FAQ&gt;<br/> &lt;FAQ.Item answerId="a1"&gt;<br/>  &lt;FAQ.Question&gt; Question 1&lt;/FAQ.Question&gt;<br/>  &lt;FAQ.Answer&gt; Answer 1&lt;/FAQ.Answer&gt;<br/> &lt;/FAQ.Item&gt;<br/> &lt;FAQ.Item answerId="a2"&gt;<br/>  &lt;FAQ.Question&gt; Question 2 &lt;/FAQ.Question&gt;<br/>  &lt;FAQ.Answer&gt; Answer 2&lt;/FAQ.Answer&gt;<br/> &lt;/FAQ.Item&gt;<br/>&lt;/FAQ&gt;</span></pre><p id="3127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，项目组件可以将answerId传递给问题和答案组件。</p><h1 id="bfce" class="mo lz iq bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">参考资料:</h1><div class="nt nu gp gr nv nw"><a href="https://www.w3.org/TR/wai-aria-practices/examples/disclosure/disclosure-faq.html" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">常见问题答案的示例显示(显示/隐藏)</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">下面的例子演示了如何使用disclosure设计模式来创建一组常见问题…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">www.w3.org</p></div></div></div></a></div></div></div>    
</body>
</html>