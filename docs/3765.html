<html>
<head>
<title>JavaScript Solution to Minimum Depth of Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树最小深度的JavaScript解决方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-solution-to-minimum-depth-of-binary-tree-1798a8f516f0?source=collection_archive---------5-----------------------#2020-10-23">https://javascript.plainenglish.io/javascript-solution-to-minimum-depth-of-binary-tree-1798a8f516f0?source=collection_archive---------5-----------------------#2020-10-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ec8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://medium.com/javascript-in-plain-english/tree-traversal-in-javascript-9b1e92e15abb" rel="noopener"> <strong class="jm io"> <em class="kj">先决条件:JavaScript中的树遍历</em> </strong> </a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/6ccff12f961cd4116a648f345df83b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KUMioCIpBfNzuyHC"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@greg_rosenke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Greg Rosenke</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0e8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们最后的She编码数据结构和算法事件，我选择了<a class="ae ki" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">二叉树的最小深度</strong> </a>问题来与我们的参与者练习树遍历。一开始可能很有挑战性，在深度优先搜索和广度优先搜索的帮助下，我们可以很容易地解决它。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="3e22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题</strong></p><pre class="kl km kn ko gt lh li lj lk aw ll bi"><span id="cc18" class="lm ln in li b gy lo lp l lq lr">Given a binary tree, find its minimum depth.</span><span id="ac6e" class="lm ln in li b gy ls lp l lq lr">The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</span><span id="efbf" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Note:</strong> A leaf is a node with no children.</span><span id="69c2" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Example 1:</strong></span><span id="adb5" class="lm ln in li b gy ls lp l lq lr">     3<br/>    / \<br/>   9  20 <br/>      / \ <br/>     15  7</span><span id="365c" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="li io">Output:</strong> 2<br/></span><span id="ff04" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Example 2:<br/>      <br/>     </strong>2<br/>      \<br/>       3<br/>        \<br/>         4<br/>          \<br/>           5<br/>            \<br/>             6</span><span id="a168" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Input:</strong> root = [2,null,3,null,4,null,5,null,6]<br/><strong class="li io">Output:</strong> 5</span><span id="a1d4" class="lm ln in li b gy ls lp l lq lr"><strong class="li io">Constraints:<br/></strong>-- The number of nodes in the tree is in the range <!-- -->[0, 105]<!-- -->.<br/>-- <!-- -->-1000 &lt;= Node.val &lt;= 1000</span></pre><p id="3268" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入是一个二叉树，节点有val，left和right属性，如下所示。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk"><a class="ae ki" href="https://gist.github.com/GAierken/f1ab81562b141052ce18ca003da0e6b1" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/f1ab81562b141052ce18ca003da0e6b1</a></figcaption></figure><p id="6329" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出是一个整数，表示给定树的最小深度。上面的例子1，树有三条路径:3 → 9(两级)，3 → 20 →15(三级)，3 → 20 →15(三级)。所以最小深度是2。例2，树只有一条路径:2 → 3 → 4 → 5 → 6(五层)，最小深度输出为5。</p><p id="e51e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何计算每条路径的级别，并最终返回最小深度？首先遍历树，计算所有路径的级别，并在比较后不断更新最小深度。说到树的遍历，常用的方法是深度优先搜索和广度优先搜索。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="5e14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解决方案</strong></p><p id="86f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">广度优先搜索</em></p><p id="a946" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在开始遍历之前，我们需要确保root不是空值。当root为null时，没有级别，所以我们返回0。BFS逐层遍历树，我们循环遍历一层的节点，当我们到达叶节点时，我们将深度增加1并立即返回深度，最短路径将首先到达叶，因此输出深度是树的最小深度。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk"><a class="ae ki" href="https://gist.github.com/GAierken/d6d17a119e195f0660128ff971951756" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/d6d17a119e195f0660128ff971951756</a></figcaption></figure><p id="a311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">深度优先搜索</em></p><p id="2bea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像往常一样，在我们遍历树之前，确保root不为空，如果是，则没有深度，我们返回0。当根没有左孩子时，我们遍历右孩子，深度增加一级。同样，如果根没有右孩子，我们向左遍历，深度增加1。当根既有左又有右时，我们遍历两条路径，选择较小的深度并增加一个，返回最后的最小深度。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk"><a class="ae ki" href="https://gist.github.com/GAierken/8746b29ef2ccb577100d49ef9070dc26.js" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/8746b29ef2ccb577100d49ef9070dc26.js</a></figcaption></figure><p id="097c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这能帮助你更好地理解如何解决类似的问题。</p><p id="626c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ki" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jm io">！</strong></p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="2bf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">资源:资源:</strong></p><div class="lv lw gp gr lx ly"><a href="https://medium.com/javascript-in-plain-english/tree-traversal-in-javascript-9b1e92e15abb" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd io gy z fp md fr fs me fu fw im bi translated">JavaScript中的树遍历</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">呼吸优先搜索vs深度优先搜索</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ku ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd io gy z fp md fr fs me fu fw im bi translated">二叉树的最小深度- LeetCode</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">给定一棵二叉树，求其最小深度。最小深度是从…沿最短路径的节点数</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">leetcode.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm ku ly"/></div></div></a></div></div></div>    
</body>
</html>