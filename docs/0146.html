<html>
<head>
<title>Creating Micro-frontends using Web Components (with support for Angular and React)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web组件创建微前端(支持Angular和React)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-micro-frontends-using-web-components-with-support-for-angular-and-react-2d6db18f557a?source=collection_archive---------0-----------------------#2019-05-09">https://javascript.plainenglish.io/create-micro-frontends-using-web-components-with-support-for-angular-and-react-2d6db18f557a?source=collection_archive---------0-----------------------#2019-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/cb5bf1c0bd4856632cd3513bb7d3d8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqASkpXFv5pWoej8jjFsCw.png"/></div></div></figure><div class=""/><p id="c713" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于现代UI开发人员来说，你的“<em class="kw">选择框架”</em>是根深蒂固的东西，它以某种方式定义了你的身份，也许限制了你解决问题的能力。我之前说过，<a class="ae kx" href="https://medium.com/javascript-in-plain-english/could-web-components-actually-compliment-javascript-frameworks-5-reasons-why-i-think-so-971eee82ee85" rel="noopener"> <em class="kw">大家都好好相处不是更好吗？</em> </a></p><figure class="kz la lb lc gt is gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/ecd64d6a9a42175f9416377de3f5c8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*O98WkpThtemT3arI.gif"/></div></figure><h1 id="d48d" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">如果你是React或Angular，Ember或Vue，让我们使用web组件创建一个地方，让他们可以和谐共处。</h1><p id="b1dc" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">使用web组件作为Angular和React组件的包装器，我将展示它们在单个应用程序中的协同工作。我还将把数据从父容器传递给两个组件，然后再传递回来。<em class="kw">我们的成品会是这样的:</em></p><figure class="kz la lb lc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/5dd7e94d842e3b918c4ab1d0c21cfe6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJkWm5tKQb8vfsA-q5wvVg.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk"><a class="ae kx" href="https://github.com/chriskitson/micro-frontends-with-web-components" rel="noopener ugc nofollow" target="_blank">https://github.com/chriskitson/micro-frontends-with-web-components</a></figcaption></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0f96" class="ld le jb bd lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw mw ly lz ma bi translated">先决条件</h1><p id="b46e" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">为了让我们能够专注于重要的部分，我已经将所有内容编码并上传到我的github:</p><div class="ip iq gp gr ir mx"><a href="https://github.com/chriskitson/micro-frontends-with-web-components" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jc gy z fp nc fr fs nd fu fw ja bi translated">chriskitson/带web组件的微前端</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">通过在GitHub上创建一个帐户，为chriskitson/micro-frontends-with web-components开发做贡献。</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ix mx"/></div></div></a></div><p id="7e51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，这不是一个深入的探讨，但是我将在Angular和React中介绍web组件支持的重要部分。</p><p id="df58" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="kw"> *如果您想完成其他一些框架(Vue、Ember等)，请随时在我的回购上创建一个拉取请求！</em>T12】</strong></p><p id="02c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经使用Angular CLI为我们的Angular项目生成了一个起点。您至少应该熟悉这个工具，以便能够浏览代码:</p><div class="ip iq gp gr ir mx"><a href="https://cli.angular.io/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jc gy z fp nc fr fs nd fu fw ja bi translated">角度CLI</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">Angular CLI使得创建开箱即用的应用程序变得容易。它已经跟随我们的…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">cli.angular.io</p></div></div></div></a></div><p id="0f25" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们在这里的最终目标是<strong class="ka jc"> web组件</strong>，所以我们将把静态JavaScript文件组合成微服务。为此，我将在我的本地环境中使用<strong class="ka jc"> serve </strong>，这是一个使用node:</p><div class="ip iq gp gr ir mx"><a href="https://www.npmjs.com/package/serve" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jc gy z fp nc fr fs nd fu fw ja bi translated">服务</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">静态文件服务和目录列表</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">www.npmjs.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl ix mx"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="8d0b" class="ld le jb bd lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw mw ly lz ma bi translated">作为自定义元素的角度组件</h1><p id="ec1a" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">由于Angular似乎采用了web组件(<a class="ae kx" href="https://angular.io/guide/elements" rel="noopener ugc nofollow" target="_blank"> <em class="kw">带Angular元素</em> </a>)，您可以将Angular组件作为web组件，只需对默认Angular CLI生成的项目做一些小的调整。</p><p id="3987" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe nn no np nq b">/micro-fe-ng</code>目录中，一切都应该正常工作，您需要做的就是安装依赖项并运行启动脚本:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="c522" class="nv le jb nq b gy nw nx l ny nz">cd micro-fe-ng/<br/>npm i<br/>npm start</span></pre><p id="3a1d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们定义自定义元素为<code class="fe nn no np nq b">&lt;ng-el /&gt; </code>的角度微前端应该在<code class="fe nn no np nq b"><a class="ae kx" href="http://localhost:5001/main.js" rel="noopener ugc nofollow" target="_blank">http://localhost:5001/main.js</a></code>运行。</p><p id="a4e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">注意:我们通过本地主机在不同的端口上提供我们的文件，但是它们可以很容易地位于共享相同DNS的多个微服务中。</em></p><figure class="kz la lb lc gt is gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/63249863b2aa8674c2af8c98e75cb4c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*aQSzS88JXN9UPPPz.png"/></div></figure><p id="849e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">如果你对这是如何实现的感兴趣，这里是所需更改的概要:</em></p><p id="9b08" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要几个新的依赖项:</p><p id="62da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">angular对定制元素(<strong class="ka jc"> @angular/elements </strong>)和<strong class="ka jc"> ngx-build-plus </strong>的支持，后者是Angular的替代构建工具(<em class="kw">它对Angular元素的支持还不错</em>):</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="8299" class="nv le jb nq b gy nw nx l ny nz">npm i @angular/elements ngx-build-plus -D</span></pre><p id="6512" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要对我们的<strong class="ka jc"> package.json </strong>进行一些更改，以构建我们的Angular项目并作为定制元素服务于我们的项目:</p><p id="522d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">微fe-ng/package.json: </em></p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="d4ac" class="nv le jb nq b gy nw nx l ny nz">"start": "npm run build &amp;&amp; serve -l 5001 dist/micro-fe-ng",<br/>"build": "ng build --prod --output-hashing none --single-bundle true",</span></pre><p id="def3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要在我们的<strong class="ka jc"> app.module.ts </strong>中定义定制元素如下:</p><p id="3aa8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">micro-Fe-ng/src/app/app . module . ts:</em></p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="5703" class="nv le jb nq b gy nw nx l ny nz">import { BrowserModule } from '@angular/platform-browser';<br/>import { NgModule, <strong class="nq jc">Injector</strong> } from '@angular/core';<br/><strong class="nq jc">import { createCustomElement } from '@angular/elements';</strong></span><span id="d3bd" class="nv le jb nq b gy ob nx l ny nz">import { AppComponent } from './app.component';<br/><strong class="nq jc">import { CustomelementComponent } from './customelement/customelement.component';</strong></span><span id="cadf" class="nv le jb nq b gy ob nx l ny nz">@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/><strong class="nq jc">    CustomelementComponent</strong><br/>  ],<br/>  imports: [<br/>    BrowserModule<br/>  ],<br/>  providers: [],<br/><strong class="nq jc">  bootstrap: [],</strong><br/>  entryComponents: [<br/>    AppComponent,<br/><strong class="nq jc">    CustomelementComponent</strong><br/>  ]<br/>})</span><span id="f184" class="nv le jb nq b gy ob nx l ny nz">export class AppModule {</span><span id="af6a" class="nv le jb nq b gy ob nx l ny nz">  constructor(<strong class="nq jc">private injector: Injector</strong>) {}</span><span id="ba95" class="nv le jb nq b gy ob nx l ny nz"><strong class="nq jc">  ngDoBootstrap(): void {<br/>    const { injector } = this;</strong></span><span id="7ae2" class="nv le jb nq b gy ob nx l ny nz"><strong class="nq jc">    // create custom elements from angular components<br/>    const ngCustomElement = createCustomElement(CustomelementComponent, { injector });</strong></span><span id="b3ac" class="nv le jb nq b gy ob nx l ny nz"><strong class="nq jc">    // define in browser registry<br/>    customElements.define('ng-el', ngCustomElement);</strong></span><span id="1b04" class="nv le jb nq b gy ob nx l ny nz"><strong class="nq jc">  }</strong></span><span id="fa79" class="nv le jb nq b gy ob nx l ny nz">}</span></pre><p id="6b23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要告诉Angular使用<strong class="ka jc"> ngx-build-plus </strong>构建工具，方法是在<strong class="ka jc"> angular.json </strong>中的三个地方指定它，如下所示:</p><p id="e52d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Ngx-build-plus将构建的项目作为单个JS文件返回，这是web组件作为单个服务工作的要求。 </p><p id="ffe4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">微-fe-ng/angular.json: </em></p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="e447" class="nv le jb nq b gy nw nx l ny nz">...</span><span id="af82" class="nv le jb nq b gy ob nx l ny nz">"architect": {<br/>  "build": {<br/>   <strong class="nq jc"> "builder": "ngx-build-plus:build",</strong><br/>    ....</span><span id="5f22" class="nv le jb nq b gy ob nx l ny nz">  "serve": {<br/><strong class="nq jc">    "builder": "ngx-build-plus:dev-server",</strong><br/>    ...</span><span id="73e5" class="nv le jb nq b gy ob nx l ny nz">  "test": {<br/><strong class="nq jc">    "builder": "ngx-build-plus:karma",</strong></span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="8da0" class="ld le jb bd lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw mw ly lz ma bi translated">将组件作为自定义元素进行反应</h1><p id="e477" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">由于React没有现成的对web组件的支持，我们将不得不编写比以前多一点的代码来包装一个标准的React组件，并将其作为本机web组件呈现(<em class="kw"> custom elemen </em> t)。</p><p id="6bee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与React组件非常相似，定制元素(web组件)也有生命周期挂钩，您可以通过回调方法访问这些挂钩。</p><p id="9f63" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用定制元素API的<code class="fe nn no np nq b">connectedCallback()</code>和<code class="fe nn no np nq b">disconnectedCallback()</code>生命周期方法，我们可以将它们分别映射到React组件的<code class="fe nn no np nq b">render()</code>和<code class="fe nn no np nq b">unmount()</code>，如下所示:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="eb4e" class="nv le jb nq b gy nw nx l ny nz">class MyCustomElement extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>  }</span><span id="5e74" class="nv le jb nq b gy ob nx l ny nz">  connectedCallback() {<br/>    ReactDOM.render(&lt;MyReactComponent /&gt;, this);<br/>  }</span><span id="9dbc" class="nv le jb nq b gy ob nx l ny nz">  disconnectedCallback(){<br/>    ReactDOM.unmountComponentAtNode(this);<br/>  }<br/>}</span></pre><p id="0feb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还通过映射反应道具和事件对此进行了更深入的研究。如果你想了解一下，那就看看<strong class="ka jc">/micro-Fe-react/src/index . js</strong>。</p><p id="49f8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例存储库中的一切都应该运行良好，因此您可以执行以下操作来启动和运行React微服务:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="2205" class="nv le jb nq b gy nw nx l ny nz">cd micro-fe-react/<br/>npm i<br/>npm start</span></pre><p id="4e56" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的React微前端将我们的自定义元素定义为<code class="fe nn no np nq b">&lt;react-el /&gt;</code>，应该在<code class="fe nn no np nq b"><a class="ae kx" href="http://localhost:5001/main.js" rel="noopener ugc nofollow" target="_blank">http://localhost:5002/main.js</a></code>运行</p><figure class="kz la lb lc gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/261f26a66cbabd5d9999eadf90ea1378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*91Xvsytjzl4_Gcnb.jpg"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="e3c0" class="ld le jb bd lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw mw ly lz ma bi translated">微前端包装器</h1><p id="6514" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们有两个微前端服务；一个用于角度分量，一个用于反作用分量。</p><p id="87e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">现在，让我们创造一个他们可以和睦相处的世界……</em></p><p id="ee94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe nn no np nq b">/micro-fe-wrapper</code>目录中，一切都应该正常工作，您需要做的就是安装依赖项并运行启动脚本:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="b58a" class="nv le jb nq b gy nw nx l ny nz">cd micro-fe-wrapper/<br/>npm i<br/>npm start</span></pre><p id="b477" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的微前端包装器应该在<code class="fe nn no np nq b"><a class="ae kx" href="http://localhost:5001/main.js" rel="noopener ugc nofollow" target="_blank">http://localhost:500</a>0</code>运行。</p><p id="a5af" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于其工作原理的解释，请继续阅读。</p><p id="e37c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于web组件是原生HTML规范的一部分，我们不需要做什么太花哨的事情就能把它们组合在一起。</p><p id="3bfc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">在现实世界中，你可能希望使用一个框架来实现更好的代码结构和数据绑定等。，但是为了简单起见，让我们继续使用普通的HTML/JS。</em></p><p id="6d0c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">micro-Fe-wrapper/index . html:</em></p><p id="34fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要包含一些来自CDN的外部依赖关系:</p><ul class=""><li id="1537" class="od oe jb ka b kb kc kf kg kj of kn og kr oh kv oi oj ok ol bi translated"><strong class="ka jc"> zone.js </strong>是Angular所要求的。最好在包装应用程序中包含一次，因为在同一个页面上不能有多个版本。</li><li id="64d4" class="od oe jb ka b kb om kf on kj oo kn op kr oq kv oi oj ok ol bi translated"><strong class="ka jc">Custom-elements-es5-adapter . js</strong>为我们的浏览器提供了自定义元素支持。</li></ul><p id="a0f0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我们应该包括来自组件服务的JS文件，这些文件是我们在前面的步骤中构建和部署的:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="3eab" class="nv le jb nq b gy nw nx l ny nz">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/zone.js/0.9.1/zone.min.js"&gt;&lt;/script&gt;</span><span id="b706" class="nv le jb nq b gy ob nx l ny nz">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/2.2.10/custom-elements-es5-adapter.js"&gt;&lt;/script&gt;</span><span id="2ea0" class="nv le jb nq b gy ob nx l ny nz">&lt;script src="http://localhost:5001/main.js"&gt;&lt;/script&gt;<br/>&lt;script src="http://localhost:5002/main.js"&gt;&lt;/script&gt;</span></pre><p id="a5c6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我定义了一个名为<code class="fe nn no np nq b">tellComponents()</code>的方法，它应该将自定义元素标签:<code class="fe nn no np nq b">&lt;ng-el /&gt;</code>用于Angular，而<code class="fe nn no np nq b">&lt;react-el /&gt;</code>用于React到我们的页面中。</p><p id="50d6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还使用<code class="fe nn no np nq b">setAttribute()</code>传递了一个属性<code class="fe nn no np nq b">name</code>来模拟包装应用程序与组件的对话。</p><p id="e9dc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还使用<code class="fe nn no np nq b">addEventListener()</code>监听一个名为<code class="fe nn no np nq b">helloEvt</code>的事件，该事件将监听来自我们组件的事件，使它们能够与我们的父应用程序和潜在的其他组件对话。相当酷！</p><p id="f37b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【React和Angular的 <code class="fe nn no np nq b">helloEvt()</code> <em class="kw">属性名称略有不同。这是因为框架之间的约定不同。稍后我会详细解释… </em></p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="fe51" class="nv le jb nq b gy nw nx l ny nz">function tellComponents() {</span><span id="edfb" class="nv le jb nq b gy ob nx l ny nz">  const name = document.getElementById('yourName').value;</span><span id="0b49" class="nv le jb nq b gy ob nx l ny nz"><strong class="nq jc">const reactEl = document.createElement('react-el');<br/>  reactEl.setAttribute('name', name);<br/>  reactEl.setAttribute('onHelloEvt', 'onHelloEvt');<br/>  reactEl.addEventListener('onHelloEvt', (e) =&gt; helloEvent('react'));</strong></span><span id="0e04" class="nv le jb nq b gy ob nx l ny nz">  const reactElContainer =  document.getElementById('react-container')</span><span id="d9d6" class="nv le jb nq b gy ob nx l ny nz">  if (reactElContainer.children.length &gt; 0) {<br/>    reactElContainer.removeChild(reactElContainer.children[0]);<br/>  }</span><span id="a99b" class="nv le jb nq b gy ob nx l ny nz">  reactElContainer.appendChild(reactEl);</span><span id="95bb" class="nv le jb nq b gy ob nx l ny nz"><strong class="nq jc">const ngEl = document.createElement('ng-el');<br/>  ngEl.setAttribute('name', name);<br/>  ngEl.addEventListener('helloEvt', (e) =&gt; helloEvent('angular'));</strong></span><span id="f541" class="nv le jb nq b gy ob nx l ny nz">  const ngElContainer =  document.getElementById('ng-container');</span><span id="2f74" class="nv le jb nq b gy ob nx l ny nz">  if (ngElContainer.children.length &gt; 0) {<br/>    ngElContainer.removeChild(ngElContainer.children[0]);<br/>  }</span><span id="d93c" class="nv le jb nq b gy ob nx l ny nz">  ngElContainer.appendChild(ngEl);</span><span id="2f91" class="nv le jb nq b gy ob nx l ny nz">}</span></pre><figure class="kz la lb lc gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/a75313f90c6c6218b87fd78bc0853598.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*4OnbcR-93W9pYT1s.jpg"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="f18c" class="ld le jb bd lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw mw ly lz ma bi translated">向组件传递值和从组件传递值</h1><p id="ad27" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">还记得我们传递给自定义元素的<code class="fe nn no np nq b">name</code>属性吗？在组件中读取这个值实际上非常简单。</p><p id="f427" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc">角度</strong>中，我们简单地引用一个<strong class="ka jc">输入</strong>:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="a332" class="nv le jb nq b gy nw nx l ny nz">export class CustomelementComponent implements OnInit {<br/><strong class="nq jc">  @Input() name: string;</strong><br/>  ...<br/>}</span></pre><p id="4cb2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得该值在我们的模板中可用:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="367d" class="nv le jb nq b gy nw nx l ny nz">&lt;p&gt;Hello &lt;strong&gt;<strong class="nq jc">{{name}}</strong>&lt;/strong&gt; from your friendly Angular component.&lt;/p&gt;</span></pre><p id="e371" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc"> React </strong>中，它将作为道具传递给组件:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="ecdd" class="nv le jb nq b gy nw nx l ny nz">export class ExampleComponent extends React.Component {<br/>  <br/><strong class="nq jc">  static propTypes = {<br/>    name: PropTypes.string<br/>  }</strong></span><span id="6528" class="nv le jb nq b gy ob nx l ny nz"><strong class="nq jc">  static defaultProps = {<br/>    name: "Chris"<br/>  }</strong></span><span id="32b0" class="nv le jb nq b gy ob nx l ny nz">  render() {<br/>    const { name } = this.props;<br/>    return (<br/>      &lt;div className="exampleComponent"&gt;<br/>        &lt;p&gt;Hello &lt;strong&gt;<strong class="nq jc">{name}</strong>&lt;/strong&gt; from your friendly React component.&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="741e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从我们的组件发送事件几乎和我们监听<code class="fe nn no np nq b">helloEvt</code>一样简单。</p><p id="e3d0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc">角度</strong>中，我们需要做的就是指定一个<strong class="ka jc">输出:</strong></p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="f3ed" class="nv le jb nq b gy nw nx l ny nz">export class CustomelementComponent implements OnInit {<br/>  @Input() name: string;<br/>  <strong class="nq jc">@Output() helloEvt: EventEmitter&lt;string&gt; = new EventEmitter();</strong><br/>  ...<br/>}</span></pre><p id="f7fc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们可以从模板中调用这个事件:</p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="5113" class="nv le jb nq b gy nw nx l ny nz">&lt;button type="submit" <strong class="nq jc">(click)="helloEvt.next()</strong>"&gt;Say hello&lt;/button&gt;</span></pre><p id="0ac0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">注意，EventEmitter在Angular中创建了一个可观察对象，因此我们需要调用</em> <code class="fe nn no np nq b"><em class="kw">next()</em></code> <em class="kw">。</em></p><p id="6efd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka jc"> React </strong>中，我们的组件包装器(<em class="kw">micro-Fe-React/src/index . js</em>)将寻找前缀为“on”的<strong class="ka jc"> props </strong>，并将它们视为事件，例如本地事件的<code class="fe nn no np nq b">onClick()</code>、<code class="fe nn no np nq b">onFocus()</code>等。这就是为什么我们称我们的自定义事件<code class="fe nn no np nq b"><strong class="ka jc">on</strong>HelloEvt()</code>为React。</p><p id="9b1e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React中，事件被视为道具，所以我们需要做的就是定义道具，并将其作为<code class="fe nn no np nq b">onClick()</code>处理程序调用。<em class="kw">就是这样！</em></p><pre class="kz la lb lc gt nr nq ns nt aw nu bi"><span id="2b14" class="nv le jb nq b gy nw nx l ny nz">export class ExampleComponent extends React.Component {</span><span id="44c0" class="nv le jb nq b gy ob nx l ny nz">  static propTypes = {<br/>    name: PropTypes.string,<br/><strong class="nq jc">    onHelloEvt: PropTypes.func</strong><br/>  }</span><span id="dd5b" class="nv le jb nq b gy ob nx l ny nz">  static defaultProps = {<br/>    name: "Chris"<br/>  }</span><span id="9b12" class="nv le jb nq b gy ob nx l ny nz">  render() {</span><span id="267d" class="nv le jb nq b gy ob nx l ny nz">    const { name, onHelloEvt } = this.props;<br/>    <br/>    return (<br/>      &lt;div className="exampleComponent"&gt;<br/><strong class="nq jc">        &lt;button type="submit" onClick={onHelloEvt}&gt;Say hello&lt;/button&gt;</strong><br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><figure class="kz la lb lc gt is gh gi paragraph-image"><div class="gh gi os"><img src="../Images/525d95ebe50b5fd03183be69a4a11214.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/0*qrGgXzCovW1s4UR9.jpg"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="6620" class="ld le jb bd lf lg ms li lj lk mt lm ln lo mu lq lr ls mv lu lv lw mw ly lz ma bi translated">结论</h1><p id="9298" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">使用这些概念，您应该能够创建一些真正强大的应用程序，通过使用Web组件定制元素规范来混合Angular和React组件。许多大型网络平台已经调用类似的技术来构建微前端。</p><p id="e68b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么混合框架可能是有益的或有问题的，这有许多利弊(<em class="kw">取决于您的用例</em>)；考虑适应性、可伸缩性、性能、安全性、资源、浏览器支持等。</p><p id="1fcb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还没有看过我的github，这里有一个提醒。尽情享受吧！！</p><div class="ip iq gp gr ir mx"><a href="https://github.com/chriskitson/micro-frontends-with-web-components" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jc gy z fp nc fr fs nd fu fw ja bi translated">chriskitson/带web组件的微前端</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">通过在GitHub上创建一个帐户，为chriskitson/micro-frontends-with web-components开发做贡献。</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="ot l ni nj nk ng nl ix mx"/></div></div></a></div><blockquote class="ou ov ow"><p id="545b" class="jy jz kw ka b kb kc kd ke kf kg kh ki ox kk kl km oy ko kp kq oz ks kt ku kv ij bi translated">感谢您花时间阅读我的文章。</p></blockquote></div></div>    
</body>
</html>