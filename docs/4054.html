<html>
<head>
<title>Should You Use MobX Instead of Redux?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应该用MobX而不是Redux吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-state-should-you-use-mobx-instead-of-redux-ccbbc1418b21?source=collection_archive---------13-----------------------#2020-11-12">https://javascript.plainenglish.io/javascript-state-should-you-use-mobx-instead-of-redux-ccbbc1418b21?source=collection_archive---------13-----------------------#2020-11-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e4b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MobX是流行的状态管理库之一，它使用非常流行的发布-订阅模式在整个前端应用程序中存储数据。其实MobX和前端代码无关，你可以用它来做任何JavaScript代码。</p><p id="70d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Redux library因其冗长的启动时间而闻名，因为需要样板代码。它有一些基本的概念，比如:提供者、动作、商店和全能的<code class="fe ki kj kk kl b">connect()</code>功能。然而，设置所有这些通常需要几个文件和对所有这些部分如何连接在一起的深入理解。</p><h2 id="cf7f" class="km kn in bd ko kp kq dn kr ks kt dp ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">逐步演练</h2><p id="b97d" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">如果您更喜欢MobX的演示视频，您也可以观看这个视频，在这个视频中，我为我的React应用程序创建了一个“TodoStore ”:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lp lq l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Step by step walkthrough for Todo List</figcaption></figure><h1 id="2af5" class="lv kn in bd ko lw lx ly kr lz ma mb ku mc md me kx mf mg mh la mi mj mk ld ml bi translated">MobX有什么不同？</h1><p id="5386" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">MobX努力做到“神奇”。不完全是。它只是很好地使用了观察者-可观察(发布-订阅)模式，并为您抽象出细节。所以假装很神奇。例如，假设您需要一个跨整个应用程序的全局数组。您可以只使用这几行简单的代码:</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="2a1c" class="km kn in kl b gy mq mr l ms mt"><strong class="kl io">import</strong> { observable } <strong class="kl io">from</strong> "mobx"<br/><br/><strong class="kl io">export const</strong> todos = observable([])</span></pre><p id="b33a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">稍后，如果您需要用新的todo项更新数组，您只需<strong class="jm io">改变</strong>可观察对象:</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="043a" class="km kn in kl b gy mq mr l ms mt">todos.push({<br/>  item: ’Read more today’,<br/>  id: 0, <br/>  completed: false <br/>});<br/>todos[0].completed = true;</span></pre><p id="3980" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，没错。您可以将一个新项目推送到现有的todos对象，整个应用程序(无论它在哪里被观察)都会得到通知。在非react代码中，这可能涉及到使用<code class="fe ki kj kk kl b">autorun</code>函数，当<code class="fe ki kj kk kl b">todos</code>更新时，无论何时您需要执行一个任务。注意“todos”还是同一个对象，每当todos更新时，<em class="mu"> autorun </em>函数负责运行这段代码。</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="daaf" class="km kn in kl b gy mq mr l ms mt">autorun(() =&gt; {<br/>  if (todos.length &gt; 5) {<br/>    // do something if todos is more than 5<br/>  } <br/>});</span></pre><h2 id="3057" class="km kn in bd ko kp kq dn kr ks kt dp ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">数据突变</h2><p id="60d5" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">注意这里发生的事情很重要:我们实际上是在“改变”数据(todos数组),而不是创建一个全新的对象。通常，在redux库中，不允许改变状态，因为库不会跟踪您对现有数据所做的更改。它能知道的唯一方法是旧对象是否被销毁，一个新对象是否被创建。</p><h2 id="7967" class="km kn in bd ko kp kq dn kr ks kt dp ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">基于类的状态</h2><p id="be72" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">在MobX中，您还可以使用ES6类来保存您的所有状态。例如，我们可以创建一个类来保存我们所有的待办事项，并定义我们的状态所需的所有动作。</p><p id="fbd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果使用TypeScript，我们可以为我们的Todos创建一个接口，并用一个空数组初始化它。我们还将有另外两个动作——添加一个待办事项，并切换完成或未完成。</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="8d86" class="km kn in kl b gy mq mr l ms mt">import {observable, action, computed} from ’mobx’;<br/>interface TodoItem {<br/>  title: string;<br/>  id: number;<br/>  completed: boolean;<br/>}<br/>class TodoStore {</span><span id="3316" class="km kn in kl b gy mv mr l ms mt">  todos: TodoItem[] = [];</span><span id="798e" class="km kn in kl b gy mv mr l ms mt">  constructor() {<br/>    makeObservable(this, {<br/>      todos: observable,<br/>      addTodo: action,<br/>      toggleCompleted: action,<br/>    });<br/>  }</span></pre><p id="7d53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">makeObservable</code>方法用MobX类型初始化我们的状态:动作是方法，可观察的是你需要在状态中保持的任何对象；在我们的例子中，它是我们的todos数组。动作可以定义为改变原始状态的简单方法:</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="1ad2" class="km kn in kl b gy mq mr l ms mt">  addTodo(title: string) {<br/>    this.todos.push({<br/>      title,<br/>      id: Date.now(),<br/>      completed: false<br/>    })<br/>  }</span><span id="b001" class="km kn in kl b gy mv mr l ms mt">  toggleCompleted(index: number) {<br/>    this.todos[index].completed = this.todos[index].completed;<br/>  }</span></pre><p id="0e10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还可以通过向构造函数中的对象添加一个新属性来拥有一个“计算”类型:<code class="fe ki kj kk kl b">countCompleted: computed</code>(这也是从mobx导入的)</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="ec7a" class="km kn in kl b gy mq mr l ms mt">  countCompleted() {<br/>    return this.todos.filter(i =&gt; i.completed).length;<br/>  }<br/>}</span></pre><p id="3551" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要做的最后一件事是在我们的应用程序中维护一个实例，它可以从文件中导出。我们将永远只有这个商店的一个实例。这可以简化你的应用状态，除非你真的需要多个商店实例。</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="2fe9" class="km kn in kl b gy mq mr l ms mt">export const TodoStoreInstance = new TodoStore();</span></pre><h1 id="90a9" class="lv kn in bd ko lw lx ly kr lz ma mb ku mc md me kx mf mg mh la mi mj mk ld ml bi translated">React MobX集成</h1><p id="f910" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">React和MobX配合得很好——实际上有一个名为<code class="fe ki kj kk kl b">mobx-react</code>的包可以帮助你将React <em class="mu">组件</em>集成到你的MobX商店中。在本文中，我们将使用MobX商店创建一个“Todo”应用程序。</p><p id="4719" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个新包，有一个高阶函数叫做<code class="fe ki kj kk kl b">observer</code>。这个高阶函数负责用MobX存储中的最新值更新组件。不管它只是一个观察者对象，还是一个类实例。</p><h2 id="0082" class="km kn in bd ko kp kq dn kr ks kt dp ku jv kv kw kx jz ky kz la kd lb lc ld le bi translated">考虑视图层</h2><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="175b" class="km kn in kl b gy mq mr l ms mt">import {observer} from ’mobx-react’;7<br/>const TodoList: React.FC = observer(props =&gt; {<br/>  const { todoStore } = props;</span><span id="dc78" class="km kn in kl b gy mv mr l ms mt">  // Use TodoStoreInstance here<br/>  return &lt;div&gt;<br/>    {todoStore.todos.map(item =&gt; {<br/>      return &lt;div&gt;item.title&lt;/div&gt;<br/>    })<br/>  &lt;/div&gt;<br/>});</span></pre><p id="4206" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，我们需要在props中获得TodoStoreInstance。这与我们在上面创建的类文件中导出的TodoStoreInstance相同。将它作为一个属性传递并使用observer函数，将确保您的商店属性在视图层中得到更新。</p><pre class="lk ll lm ln gt mm kl mn mo aw mp bi"><span id="a6d0" class="km kn in kl b gy mq mr l ms mt">&lt;TodoList todoStore={TodoStoreInstance} /&gt;</span></pre><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><h1 id="7d1c" class="lv kn in bd ko lw lx ly kr lz ma mb ku mc md me kx mf mg mh la mi mj mk ld ml bi translated">概括起来</h1><p id="47bc" class="pw-post-body-paragraph jk jl in jm b jn lf jp jq jr lg jt ju jv lh jx jy jz li kb kc kd lj kf kg kh ig bi translated">如果您正在寻找一个轻量级的库来处理您的React状态(或任何其他框架)，MobX可能是一个非常好的选择。减少了样板代码，真的很容易上手。您也可以从其他库慢慢过渡到MobX，因为它独立于应用程序的任何其他部分来处理状态。</p><p id="f94b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以阅读更多关于MobX的内容，并在<a class="ae nd" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> MobX文档中找到更多示例。</a></p></div></div>    
</body>
</html>