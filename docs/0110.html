<html>
<head>
<title>Build a Drag and Drop (DnD) layout builder with React and ImmutableJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React和ImmutableJS构建一个拖放(DnD)布局生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-drag-and-drop-dnd-layout-builder-with-react-and-immutablejs-78a0797259a6?source=collection_archive---------0-----------------------#2019-03-25">https://javascript.plainenglish.io/build-a-drag-and-drop-dnd-layout-builder-with-react-and-immutablejs-78a0797259a6?source=collection_archive---------0-----------------------#2019-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6c0af289d46bdaceaa1131103544b0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fSiTsc1lvObuewgJH1J7A.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Drag and Drop in React!</figcaption></figure><div class=""/><p id="1169" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于“<em class="la">拖放</em>”类型的行为，比如建立网站(<em class="la"> Wix </em>)或交互式应用(<em class="la"> Trello </em>)有着巨大的用户需求。毫无疑问，这种类型的交互创造了非常酷的用户体验。再加上一些最新的用户界面技术，我们可以创造出一些非常好的软件。</p><h1 id="094c" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这篇文章的最终目标是什么？</h1><p id="0a9d" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我想创建一个拖放布局生成器，让用户能够从一系列可定制的用户界面组件构建布局，最终组成是一个网站或web应用程序。</p><h1 id="e58e" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">我们将使用哪些工具？</strong></h1><ol class=""><li id="8a2c" class="me mf jf ke b kf lz kj ma kn mg kr mh kv mi kz mj mk ml mm bi translated"><strong class="ke jg">反应</strong></li><li id="045f" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><strong class="ke jg">不变的</strong></li></ol><p id="cd09" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们花一点时间来解释他们在构建这个过程中的角色。</p><h1 id="ea57" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">反应</strong></h1><p id="72a4" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated"><a class="ae ms" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>是基于声明式编程的，这意味着它从状态中导出它的呈现。State实际上只是一个JSON对象，它包含的属性告诉React事物应该是什么样子和行为。不像jQuery这样的DOM操作库，我们不直接改变DOM，我们改变状态并由React处理DOM(我们稍后将讨论这个问题)。</p><p id="dc27" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个项目中，我设想我们将有一个父组件，它将保存我们的布局(JSON)的状态，这个状态将被传递给我们的每个组件，这些组件将是无状态的React组件。</p><p id="8b67" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">组件的作用是从父组件获取状态，并根据属性呈现自身。</p><p id="8357" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个包含三个链接对象的状态的快速示例:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7534" class="nc lc jf my b gy nd ne l nf ng">{<br/>  links:  [{<br/>    name: "Link 1",<br/>    url: "http://link.one",<br/>    selected: false<br/>  }, {<br/>    name: "Link 2",<br/>    url: "http://link.two",<br/>    selected: true<br/>  }, {<br/>    name: "Link 3",<br/>    url: "http://link.three",<br/>    selected: false<br/>  }]<br/>}</span></pre><p id="f619" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的例子中，我们可以遍历links数组，并为每个链接创建一个无状态的React组件:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d9f9" class="nc lc jf my b gy nd ne l nf ng">interface ILink {<br/>  name: string;<br/>  url: string;<br/>  selected: boolean;<br/>}</span><span id="62e3" class="nc lc jf my b gy nh ne l nf ng">const LinkComponent = ({ name, url, selected }: ILink) =&gt;<br/>&lt;a href={url} className={selected ? 'selected': ''}&gt;{name}&lt;/a&gt;;</span></pre><p id="1b22" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以看到我们是如何基于state中保存的选定属性将css类“selected”应用于链接组件的。这是将呈现给浏览器的内容:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c775" class="nc lc jf my b gy nd ne l nf ng">&lt;a href="http://link.two" class="selected"&gt;Link 2&lt;/a&gt;</span></pre><h1 id="d04e" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不变的</h1><p id="6e2c" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我们已经了解了状态在我们的项目中的重要性，它是关于应该如何使用React组件呈现事物的<em class="la">唯一真实来源</em>。React中的状态保存在不可变的数据结构中。</p><p id="3028" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简单地说，这意味着一旦数据对象被创建，它<strong class="ke jg">就不能被直接</strong>改变。相反，我们必须用更改后的状态创建一个新对象。</p><p id="a74e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我用另一个简单的例子来说明不变性:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4f60" class="nc lc jf my b gy nd ne l nf ng">interface ILink {<br/>  name: string;<br/>  url: string;<br/>  selected: boolean;<br/>}</span><span id="f99e" class="nc lc jf my b gy nh ne l nf ng">const link: ILink = {<br/>    name: "Link 1",<br/>    url: "http://link.one",<br/>    selected: false<br/>}</span></pre><p id="a573" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">传统上，在Javascript中，您可以执行如下操作来更新链接对象:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="80da" class="nc lc jf my b gy nd ne l nf ng">link.name = 'New name';</span></pre><p id="db0b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们的状态是不可变的，这是不可能的，相反，我们必须创建一个新的对象，并更改其名称:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7a53" class="nc lc jf my b gy nd ne l nf ng">link = {...link, name: 'New name' };</span></pre><p id="e199" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">注意:为了支持不变性，React提供了一个名为</em> <code class="fe ni nj nk my b"><em class="la">this.setState()</em></code> <em class="la">的方法，我们可以用它来告诉组件状态已经改变，如果有任何改变，就重新呈现它自己。</em></p><p id="9904" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面的例子很简单，但是如果我们想改变一个嵌套在复杂JSON状态结构中几层的属性，会发生什么呢？</p><p id="28c3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">ECMA脚本6给了我们一些方便的操作符和方法来改变对象，但是它们对于复杂的结构来说并不是很好，这就是为什么我们需要<a class="ae ms" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank"> ImmutableJS </a>来简化任务。</p><p id="e1f0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们稍后会用到ImmutableJS，但是现在你只需要知道它在给我们提供奇特的方法来改变复杂状态中的作用。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7656eb34fcc34bf8987cd6823116b61c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*IugEwe6Lkm5iFB-Q9zvc5w.jpeg"/></div></figure><h1 id="4ded" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">HTML5拖放(DnD)</h1><p id="d498" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我们知道我们的状态是一个不可变的JSON对象，React负责组件，但是我们需要有趣的用户交互，对吗？</p><p id="02da" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">多亏了HTML5，这实际上非常简单，因为它公开了我们可以用来检测组件何时被拖动以及被放到何处的方法。由于React向浏览器公开了原生HTML元素，我们可以只使用原生事件，从而使我们的生活更加简单。</p><p id="2c3d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">注意:我知道使用DnD的HTML5实现可能会有些奇怪，但如果没有别的，这可能是一个发现课程，如果证明有问题，我们可以稍后将其切换。</em></p><p id="0f1d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个项目中，我将有组件(HTML divs)用户可以拖动。我将把它们称为<strong class="ke jg">拖后腿的东西</strong>。</p><p id="fcfe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还将有一些区域允许用户放置组件，我将把它们称为<strong class="ke jg">dropboables</strong>。</p><p id="65bb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用本机HTML5事件，即<code class="fe ni nj nk my b">onDragStart</code>、<code class="fe ni nj nk my b">onDragOver</code>和<code class="fe ni nj nk my b">onDragDrop</code>，我们应该有了根据DnD交互改变应用程序状态所需的东西。</p><p id="c4b5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">这里有一个可拖动组件的例子:</em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="e5ec" class="nc lc jf my b gy nd ne l nf ng">export interface IDraggableComponent {<br/>  name: string;<br/>  type: string;<br/>  draggable?: boolean;<br/>  onDragStart: (ev: React.DragEvent&lt;HTMLDivElement&gt;, name: string, type: string) =&gt; void;<br/>}</span><span id="9a7c" class="nc lc jf my b gy nh ne l nf ng">export const DraggableComponent = ({<br/>  name,<br/>  type,<br/>  onDragStart,<br/>  draggable = true<br/>}: IDraggableComponent) =&gt;<br/>&lt;div className='draggable-component' draggable={draggable} onDragStart={(ev) =&gt; onDragStart(ev, name, type)}&gt;{name}&lt;/div&gt;;</span></pre><p id="7ec2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的代码片段中，我们呈现了一个React组件，它使用<code class="fe ni nj nk my b">onDragStart</code>事件告诉我们的父组件我们开始拖动该组件了。我们也可以通过传递<code class="fe ni nj nk my b">draggable</code>道具来切换拖动它的能力。</p><p id="7acb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">这里有一个可丢弃组件的例子:</em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="05d7" class="nc lc jf my b gy nd ne l nf ng">export interface IDroppableComponent {<br/>  name: string;<br/>  onDragOver: (ev: React.DragEvent&lt;HTMLDivElement&gt;) =&gt; void;<br/>  onDrop: (ev: React.DragEvent&lt;HTMLDivElement&gt;, componentName: string) =&gt; void;<br/>}</span><span id="dc35" class="nc lc jf my b gy nh ne l nf ng">export const DroppableComponent = ({<br/>  name,<br/>  onDragOver,<br/>  onDrop<br/>}: IDroppableComponent) =&gt;<br/>&lt;div className='droppable-component'<br/>  onDragOver={(ev: React.DragEvent&lt;HTMLDivElement&gt;) =&gt; onDragOver(ev)}<br/>  onDrop={(ev: React.DragEvent&lt;HTMLDivElement&gt;) =&gt; onDrop(ev, name)}&gt;<br/>  &lt;span&gt;Drop components here!&lt;/span&gt;<br/>&lt;/div&gt;;</span></pre><p id="81a3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的组件中，我们正在监听<code class="fe ni nj nk my b">onDrop</code>事件，因此我们可以基于新组件被放入可放下组件来更新状态。</p><p id="f905" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">好了，在把所有这些放在一起之前，是时候快速回顾一下了:</em></p><p id="3d65" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">我们将使用React来渲染整个布局，使用一些基于状态对象的解耦无状态组件。用户交互将由HTML5 DnD事件处理，该事件将通过使用ImmutableJS触发对状态对象的更改。</em></p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ce072bc7defade1b3ff1ca4e23d5e90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*06515Z0luWKxNzfsz8tKBw.gif"/></div></figure><h1 id="eddc" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一起拖动它</h1><p id="ff5c" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">现在我们已经对我们要做什么以及如何实现它有了一个坚实的理解，让我们来考虑这个难题的一些最重要的部分:</p><ol class=""><li id="dc1f" class="me mf jf ke b kf kg kj kk kn nn kr no kv np kz mj mk ml mm bi translated">布局状态</li><li id="a32f" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">拖放构建器组件</li><li id="3448" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">在网格中呈现嵌套组件</li></ol><h1 id="ae4a" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.布局状态</h1><p id="e8c3" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">为了使用我们的组件表示无限的布局组合，状态需要是灵活的和可伸缩的。我们还需要记住，我们本质上想要表示任何给定布局的DOM树，这意味着许多可爱的递归来支持嵌套结构！</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/de2a262342652a4d9158d490d079d0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*6v0VjyiKNaLp0ounI3pNbA.jpeg"/></div></figure><p id="7bfe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的状态需要存储大量组件，这些组件可以由以下接口表示:</p><p id="3009" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">如果你不熟悉JavaScript中的接口，你应该看看</em><a class="ae ms" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"><em class="la">TypeScript</em></a><em class="la">——你可能会说我是个粉丝。它与React一起工作也很好。</em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8c6f" class="nc lc jf my b gy nd ne l nf ng">export interface IComponent {<br/>  name: string;<br/>  type: string;<br/>  renderProps?: {<br/>    size?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12<br/>  };<br/>  children?: IComponent[];<br/>}</span></pre><p id="363d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我保持了组件定义的最小化，但是您可以根据需要扩展它。我在这里定义了一个<code class="fe ni nj nk my b">renderProps</code>对象，这样我们就可以为组件提供道具来告诉它们如何渲染。这里的<code class="fe ni nj nk my b">children</code>属性给了我们递归。</p><p id="5b74" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在更高的层次上，我想创建一个对象数组来保存组件，这些组件将出现在状态的根中。</p><p id="1b94" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了说明这一点，让我们提出以下用HTML标记的有效布局:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6737" class="nc lc jf my b gy nd ne l nf ng">&lt;div class="content-panel-1"&gt;<br/>  &lt;div class="component"&gt;<br/>    Component 1<br/>  &lt;/div&gt;<br/>  &lt;div class="component"&gt;<br/>    Component 2<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;div class="content-panel-2"&gt;<br/>  &lt;div class="component"&gt;<br/>    Component 3<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="fa06" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了在状态中表示这一点，我们可以为内容面板定义如下所示的接口:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="501f" class="nc lc jf my b gy nd ne l nf ng">export interface IContent {<br/>  id: string;<br/>  cssClass: string;<br/>  components: IComponent[];<br/>}</span></pre><p id="798b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的状态于是变成了一个像这样的<code class="fe ni nj nk my b">IContent</code>阵列:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0b2d" class="nc lc jf my b gy nd ne l nf ng">const state: IContent[] = [<br/>  {<br/>    id: 'content-panel-1',<br/>    cssClass: 'content-panel-1',<br/>    components: [{<br/>      type: 'component1',<br/>      renderProps: {},<br/>      children: []<br/>    },<br/>    {<br/>      type: 'component2',<br/>      renderProps: {},<br/>      children: []<br/>    }]<br/>  },<br/>  {<br/>    id: 'content-panel-2',<br/>    cssClass: 'content-panel-2',<br/>    components: [{<br/>      type: 'component3',<br/>      renderProps: {},<br/>      children: []<br/>    }]<br/>  }<br/>];</span></pre><p id="b728" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过在<code class="fe ni nj nk my b">children</code>数组属性中加入额外的组件，我们可以定义额外的组件来创建嵌套的类似DOM的树结构:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7117" class="nc lc jf my b gy nd ne l nf ng">[0]<br/>  components:<br/>    [0]<br/>      children:<br/>        [0]<br/>          children:<br/>            [0]<br/>               ...</span></pre><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f841fc997b711685a4592b71ef3453b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*S6XF_dPgkDax70QjkXLNVQ.jpeg"/></div></figure><h1 id="0b95" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.拖放布局生成器</h1><p id="0206" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">布局生成器组件将执行一系列功能，例如:</p><ul class=""><li id="b2e0" class="me mf jf ke b kf kg kj kk kn nn kr no kv np kz ns mk ml mm bi translated">保持和更新组件状态</li><li id="1070" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz ns mk ml mm bi translated">渲染<em class="la">可拖拉物</em>和<em class="la">可掉落物</em></li><li id="12eb" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz ns mk ml mm bi translated">呈现我们的嵌套布局结构</li><li id="dce6" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz ns mk ml mm bi translated">触发DaD HTML5事件</li></ul><p id="ea2d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看它可能是什么样子:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6cf8" class="nc lc jf my b gy nd ne l nf ng">export class BuilderLayout extends React.Component {</span><span id="1aa4" class="nc lc jf my b gy nh ne l nf ng">  public state: IBuilderState = {<br/>    dashboardState: []<br/>  };</span><span id="4e71" class="nc lc jf my b gy nh ne l nf ng">  constructor(props: {}) {<br/>    super(props);</span><span id="bceb" class="nc lc jf my b gy nh ne l nf ng">    this.onDragStart = this.onDragStart.bind(this);<br/>    this.onDragDrop = this.onDragDrop.bind(this);<br/>  }</span><span id="5afd" class="nc lc jf my b gy nh ne l nf ng">  public render() {</span><span id="0d90" class="nc lc jf my b gy nh ne l nf ng">  }</span><span id="f925" class="nc lc jf my b gy nh ne l nf ng">  private onDragStart(event: React.DragEvent &lt;HTMLDivElement&gt;, name: string, type: string): void {<br/>    event.dataTransfer.setData('id', name);<br/>    event.dataTransfer.setData('type', type);<br/>  }</span><span id="7ad3" class="nc lc jf my b gy nh ne l nf ng">  private onDragOver(event: React.DragEvent&lt;HTMLDivElement&gt;): void {<br/>    event.preventDefault();<br/>  }</span><span id="2460" class="nc lc jf my b gy nh ne l nf ng">  private onDragDrop(event: React.DragEvent &lt;HTMLDivElement&gt;, containerId: string): void {</span><span id="23a4" class="nc lc jf my b gy nh ne l nf ng">  }</span><span id="aec7" class="nc lc jf my b gy nh ne l nf ng"><br/>}</span></pre><p id="2875" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们暂时忽略<code class="fe ni nj nk my b">render()</code>,因为我们很快就会看到它。</p><p id="fd5a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有三个事件，我们将绑定到我们的draggables和droppables。</p><p id="02c0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ni nj nk my b">onDragStart()</code> —这里我们设置一些关于<code class="fe ni nj nk my b">event</code>对象中组件的细节，即<code class="fe ni nj nk my b">name</code>和<code class="fe ni nj nk my b">type</code>。</p><p id="7123" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ni nj nk my b">onDragOver()</code> —我们现在没有对此事件做任何事情，事实上我们正在使用<code class="fe ni nj nk my b">.preventDefault()</code>禁用默认的浏览器行为。</p><p id="6ca1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就剩下<code class="fe ni nj nk my b">onDragDrop()</code>了，这就是改变不可变状态对象的神奇之处。为了改变状态，我们需要几条信息:</p><ul class=""><li id="f1bf" class="me mf jf ke b kf kg kj kk kn nn kr no kv np kz ns mk ml mm bi translated">在<code class="fe ni nj nk my b">event</code>对象<code class="fe ni nj nk my b">onDragStart()</code>中设置的要删除的组件名称<code class="fe ni nj nk my b">name</code>。</li><li id="a84d" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz ns mk ml mm bi translated">要删除的组件的类型—<code class="fe ni nj nk my b">event</code>对象<code class="fe ni nj nk my b">onDragStart()</code>中设置的<code class="fe ni nj nk my b">type</code>。</li><li id="6283" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz ns mk ml mm bi translated">它被放入的地方— <code class="fe ni nj nk my b">containerId</code>从droppable传递到这个方法。</li></ul><p id="91b3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ni nj nk my b">containerId</code>必须告诉我们必须在状态中的什么地方添加新组件。可能有一种更简洁的方法，但是为了描述这个位置，我将使用一个由下划线分隔的索引列表。</p><p id="91e0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回到我们的状态模型:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d100" class="nc lc jf my b gy nd ne l nf ng">[index]<br/>  components:<br/>    [index]<br/>      children:<br/>        [index]<br/>          children:<br/>            [index]<br/>               ...</span></pre><p id="2f36" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这可以用字符串格式<code class="fe ni nj nk my b">cb_index_index_index_index</code>来表示。</p><p id="57ea" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里的索引数量描述了组件在嵌套结构中应该被删除多少层。</p><p id="0b51" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们需要调用<a class="ae ms" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank"><strong class="ke jg">immutableejs</strong></a>的力量来帮助我们改变应用程序的状态。我们将在我们的<code class="fe ni nj nk my b">onDragDrop()</code>方法中这样做，它可能看起来像这样:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="33cc" class="nc lc jf my b gy nd ne l nf ng">private onDragDrop(event: React.DragEvent &lt;HTMLDivElement&gt;, containerId: string) {<br/>  const name = event.dataTransfer.getData('id');<br/>  const type = event.dataTransfer.getData('type');</span><span id="5dd4" class="nc lc jf my b gy nh ne l nf ng">  const newComponent: IComponent =  this.generateComponent(name, type);</span><span id="f74b" class="nc lc jf my b gy nh ne l nf ng">  const containerArray: string[] = containerId.split('_');<br/>  containerArray.shift(); // ignore first param, it is string prefix</span><span id="d329" class="nc lc jf my b gy nh ne l nf ng">  const componentsPath: Array&lt;number | string&gt; = []   containerArray.forEach((id: string, index: number) =&gt; {<br/>  componentsPath.push(parseInt(id, INT_LENGTH));<br/>  componentsPath.push(index === 0 ? 'components' : 'children');<br/>});</span><span id="75e4" class="nc lc jf my b gy nh ne l nf ng">  const { dashboardState } = this.state;<br/>  let componentState = fromJS(dashboardState);</span><span id="c9b5" class="nc lc jf my b gy nh ne l nf ng">  componentState = componentState.setIn(componentsPath,       componentState.getIn(componentsPath).push(newComponent));</span><span id="85a5" class="nc lc jf my b gy nh ne l nf ng">  this.setState({ dashboardState: componentState.toJS() });</span><span id="2335" class="nc lc jf my b gy nh ne l nf ng">}</span></pre><p id="846d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里的力量来自ImmutableJS给我们的<code class="fe ni nj nk my b">.setIn()</code>和<code class="fe ni nj nk my b">.getIn()</code>方法。</p><p id="3e4c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它们接受一个字符串/值数组来标识您想要在嵌套状态模型中的何处获取或设置值。这非常符合我们生成可丢弃id的方式。是不是很酷？</p><p id="07ea" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ni nj nk my b">fromJS()</code>和<code class="fe ni nj nk my b">toJS()</code>方法将我们的JSON转换成一个ImmutableJS对象，然后再转换回来。</p><p id="0c99" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">有太多不可改变的事情，所以将来我可能会专门写一篇关于它的文章。抱歉，这只是一次短暂的拜访！</em></p><h1 id="556f" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.在网格中呈现嵌套组件</h1><p id="6b5e" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">最后让我们快速看一下我们之前提到的渲染方法。我想支持一个CSS网格系统，如<a class="ae ms" href="https://material.io/design/layout/responsive-layout-grid.html#breakpoints" rel="noopener ugc nofollow" target="_blank">材料响应网格</a>使我们的布局灵活。它规定了使用12列网格的HTML布局，如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a7e3" class="nc lc jf my b gy nd ne l nf ng">&lt;div class="mdc-layout-grid"&gt;<br/>  &lt;div class="mdc-layout-grid__inner"&gt;<br/>    &lt;div class="mdc-layout-grid__cell mdc-layout-grid__cell--span-6"&gt;<br/>      Left column<br/>    &lt;/div&gt;<br/>    &lt;div class="mdc-layout-grid__cell mdc-layout-grid__cell--span-6"&gt;<br/>      Right column<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="6d18" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将它与由状态表示的嵌套结构结合起来，我们应该拥有一个非常强大的布局生成器。</p><p id="0d76" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我只是将网格的大小固定为两列布局(即两列在一个递归的droppable中)。</p><p id="460f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了实现这一点，我想有一个网格可拖动，将包含两个下拉(每列一个)。</p><p id="3d59" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">这是我之前做的一个:</em></p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/3f8ed5306e8e84b38b62e80c0cdd1d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k92aZrAjmFEeH_TqJYdXxQ.png"/></div></div></figure><p id="8677" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面我有一个<strong class="ke jg">网格</strong>组件，第一列中有一个<strong class="ke jg">卡</strong>，第二列中有一个<strong class="ke jg">标题</strong>。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/7b9c3d9aa8b4f3cf1897ed4cde6386b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeocyMzF3J2iIEHGFRISiw.png"/></div></div></figure><p id="9724" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我已经在第一列中放置了另一个<strong class="ke jg">网格</strong>，第一列中有一个<strong class="ke jg">标题</strong>，第二列中有一个<strong class="ke jg">卡片</strong>。</p><p id="8112" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你明白了吗？</p><p id="e7dc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">让我举例说明如何使用伪React代码实现这一点:</em></p><ol class=""><li id="2f1f" class="me mf jf ke b kf kg kj kk kn nn kr no kv np kz mj mk ml mm bi translated">遍历内容项(我们状态的根)并呈现一个<code class="fe ni nj nk my b">ContentBuilderDraggableComponen</code>和一个<code class="fe ni nj nk my b">DroppableComponent</code>。</li><li id="b461" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">确定组件是否属于网格类型，然后渲染<code class="fe ni nj nk my b">ContentBuilderGridComponent</code>，否则渲染正常<code class="fe ni nj nk my b">DraggableComponent</code>。</li><li id="2c96" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">呈现带有X个子元素的网格标记，每个子元素中有一个<code class="fe ni nj nk my b">ContentBuilderDraggableComponen</code>和一个<code class="fe ni nj nk my b">DroppableComponent</code>。</li></ol><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="eeb4" class="nc lc jf my b gy nd ne l nf ng">class ContentBuilderComponent... {<br/>  render() {<br/>    return (<br/>      &lt;ContentComponent&gt;<br/>        components.map(...) {<br/>          &lt;ContentBuilderDraggableComponent... /&gt;<br/>        }<br/>        &lt;DroppableComponent... /&gt;<br/>      &lt;/ContentComponent&gt;<br/>    )<br/>  }<br/>}</span><span id="846b" class="nc lc jf my b gy nh ne l nf ng">class ContentBuilderDraggableComponent... {<br/>  render() {<br/>    if (type === GRID) {<br/>      return &lt;ContentBuilderGridComponent... /&gt;<br/>    } else {<br/>      return &lt;DraggableComponent ... /&gt;<br/>    }<br/>  }<br/>}</span><span id="6032" class="nc lc jf my b gy nh ne l nf ng">class ContentBuilderGridComponent... {<br/>  render() {<br/>    &lt;GridComponent...&gt;<br/>      children.map(...) {<br/>        &lt;GridItemComponent...&gt;<br/>          gridItemChildren.map(...) {<br/>            &lt;ContentBuilderDraggableComponent... /&gt;<br/>            &lt;DroppableComponent... /&gt;<br/>          }<br/>        &lt;/GridItemComponent&gt;<br/>      }<br/>    &lt;/GridComponent&gt;<br/>  }<br/>}</span></pre><h1 id="5416" class="lb lc jf bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">下一步是什么？</h1><p id="5206" class="pw-post-body-paragraph kc kd jf ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我们已经完成了这篇文章，但是我会在以后继续阐述。以下是一些想法:</p><ul class=""><li id="cce2" class="me mf jf ke b kf kg kj kk kn nn kr no kv np kz ns mk ml mm bi translated">为组件配置渲染属性</li><li id="abf6" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz ns mk ml mm bi translated">使网格组件可配置</li><li id="12c4" class="me mf jf ke b kf mn kj mo kn mp kr mq kv mr kz ns mk ml mm bi translated">使用服务器端呈现从保存的状态对象生成HTML布局</li></ul><p id="f0bb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望你能够跟上，但是如果不能，这里有一个我的GitHub的工作示例，请欣赏！！</p><div class="ip iq gp gr ir nv"><a href="https://github.com/chriskitson/react-drag-drop-layout-builder" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd jg gy z fp oa fr fs ob fu fw je bi translated">chriskitson/react-拖放-布局-生成器</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">使用React和immutable ejs-chriskitson/React-drag-drop-layout-builder的拖放(DnD) UI布局生成器</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ix nv"/></div></div></a></div><blockquote class="ok ol om"><p id="c321" class="kc kd la ke b kf kg kh ki kj kk kl km on ko kp kq oo ks kt ku op kw kx ky kz ij bi translated">感谢您花时间阅读我的文章。</p></blockquote></div></div>    
</body>
</html>