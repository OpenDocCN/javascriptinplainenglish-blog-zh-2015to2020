<html>
<head>
<title>The Advanced Way to Style with Styled Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用样式化组件进行样式化的高级方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-advanced-way-to-style-with-styled-components-98fb70c1eecc?source=collection_archive---------1-----------------------#2020-09-16">https://javascript.plainenglish.io/the-advanced-way-to-style-with-styled-components-98fb70c1eecc?source=collection_archive---------1-----------------------#2020-09-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6e61" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">更深入地了解样式化组件的威力</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e89ced0d53e7e296a1e93898fdbf5ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tFt9-0-RroNi1vQc"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Austin Distel</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cfa9" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="0d4d" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我喜欢<a class="ae ks" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">风格的组件</a>。它使得React中的样式如此简单。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="e132" class="mm ku in mi b gy mn mo l mp mq">import styled from 'styled-components';</span><span id="24b5" class="mm ku in mi b gy mr mo l mp mq">const Button = styled.button`<br/>  display: inline-block;<br/>  padding: 6px 12px;<br/>  font-size: 16px;<br/>  font-family: Arial, sans-serif;<br/>  line-height: 1.5;<br/>  color: white;<br/>  background-color: #6c757d;<br/>  border: none;<br/>  border-radius: 4px;</span><span id="5ea2" class="mm ku in mi b gy mr mo l mp mq">  :not(:disabled) {<br/>    cursor: pointer;<br/>  }</span><span id="dd78" class="mm ku in mi b gy mr mo l mp mq">  :hover {<br/>    background-color: #5a6268;<br/>  }<br/>`;</span><span id="4a7d" class="mm ku in mi b gy mr mo l mp mq">const App = () =&gt; {<br/>  return (<br/>    &lt;Button onClick={() =&gt; alert('clicked!')} type="button"&gt;<br/>      Button<br/>    &lt;/Button&gt;<br/>  );<br/>};</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/0191cc13eb43a15687de2edd2e3edfab.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*eKhZlI1WH59MqtEowHGLTA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Styled Components Button</figcaption></figure><p id="1328" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">在<a class="ae ks" href="https://medium.com/@changmander/the-modern-way-to-style-with-styled-components-c3c51b750b5f" rel="noopener">学习了基础知识</a>之后，我开始将我的代码库移植到样式化的组件中。在这样做的过程中，我逐渐发现了一些问题和低效之处。这里那里都有我想做的小事，但是以我所拥有的知识却做不到。其中许多，我用迂回的方式解决了，所以它们不是主要问题。但是，对我来说，深入研究样式化组件文档已经足够了。幸运的是，样式化组件的贡献者已经发现了它们。</p><h1 id="44a4" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">样式对象</h1><p id="d4fa" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">有时我们被迫通过<code class="fe my mz na mi b">style</code>道具使用样式对象。这可能是因为代码库只是部分迁移到样式化的组件，或者因为一些第三方库使用它，这在基于钩子的库中很常见，如<a class="ae ks" href="https://github.com/react-dropzone/react-dropzone" rel="noopener ugc nofollow" target="_blank"> React Dropzone </a>或<a class="ae ks" href="https://github.com/tannerlinsley/react-table" rel="noopener ugc nofollow" target="_blank"> React Table </a>。样式组件可以将这些样式对象合并到样式组件样式中。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="3314" class="mm ku in mi b gy mn mo l mp mq">const StylePropButton = styled(Button)`<br/>  ${props =&gt; props.$style ?? {}}<br/>`;</span><span id="6e8e" class="mm ku in mi b gy mr mo l mp mq">const App = () =&gt; {<br/>  return (<br/>    &lt;StylePropButton<br/>      $style={{ backgroundColor: '#007bff' }}<br/>      onClick={() =&gt; alert('clicked!')}<br/>      type="button"<br/>    &gt;<br/>      Primary<br/>    &lt;/StylePropButton&gt;<br/>  );<br/>};</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/838d52e94235e4598dd13fc8e5aedfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*S9ifZlJ2nNS-LCjz95ukpQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Style Prop Button</figcaption></figure><p id="babc" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">该组件接受一个内联样式对象，然后通过简单地将该对象返回到模板文本中，将该对象合并到样式化的组件样式中。结果是两种截然不同的反应样式之间的无缝集成。</p><p id="d08e" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">注意，我把道具命名为<code class="fe my mz na mi b">$style</code>而不是<code class="fe my mz na mi b">style</code>。这可以防止样式被应用两次。如果道具名是<code class="fe my mz na mi b">style</code>，按钮也将通过内联样式进行样式化，因为样式化组件将道具传递给底层组件。名称以<code class="fe my mz na mi b">$</code>为前缀的道具，称为瞬态道具，仅由定义的样式组件使用，不会传递给底层组件。</p><p id="ca75" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">那么为什么要这样做呢？你可以直接使用<code class="fe my mz na mi b">style</code>属性，而不是将样式对象合并到样式组件样式中。主要优势是处理特异性。通过样式化的组件，内联样式总是比外部CSS具有更高的优先级。该方法将阻止使用内联样式，而是通过样式化的组件将它们转换成外部CSS。然后，您可以轻松地覆盖那些您认为合适的样式，而不需要使用<code class="fe my mz na mi b">!important</code>。</p><h1 id="500b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">动态组件</h1><p id="574b" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">有时，您希望应用相同的样式，但应用于不同的底层组件(DOM元素、React组件或样式化组件)。您可以用<code class="fe my mz na mi b">css</code>定义一个可组合的样式，并用该可组合的样式创建一个新的样式化组件。但是有一个更简单的方法！样式化的组件带有一个特殊的<code class="fe my mz na mi b">as</code>属性，允许你重新定义使用相同样式渲染的组件。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="96bb" class="mm ku in mi b gy mn mo l mp mq">const App = () =&gt; {<br/>  return (<br/>    &lt;Button as="a" href="https://styled-components.com/"&gt;<br/>      Link<br/>    &lt;/Button&gt;<br/>  );<br/>};</span></pre><p id="f825" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">这将向DOM呈现以下内容。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="7945" class="mm ku in mi b gy mn mo l mp mq">&lt;a<br/>  href="<a class="ae ks" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">https://styled-components.com/</a>"<br/>  class="sc-bdnylx bPvsWA"<br/>&gt;<br/>  Link<br/>&lt;/a&gt;</span></pre><p id="4312" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">就像这样，用一个单独的道具，你已经渲染了一个锚标签而不是一个与<code class="fe my mz na mi b">Button</code>风格相同的按钮！</p><h1 id="a1ef" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">属性</h1><p id="37ff" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">有时候某些道具会一遍又一遍的重复。在我们的例子中，<code class="fe my mz na mi b">type</code>几乎总是<code class="fe my mz na mi b">button</code>，所以不必每次都定义它会很有帮助。这个问题可以通过定义一个React组件<code class="fe my mz na mi b">Button</code>来解决，该组件返回默认类型为prop的样式化组件<code class="fe my mz na mi b">Button</code>。但是，像以前一样，有一个本地风格的组件方法来实现这一点。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="71a3" class="mm ku in mi b gy mn mo l mp mq">const AttributeButton = styled(Button).attrs(props =&gt; {<br/>  const { type = 'button' } = props;<br/>  return { type };<br/>})`...`;</span><span id="ff61" class="mm ku in mi b gy mr mo l mp mq">const App = () =&gt; {<br/>  return (<br/>    &lt;AttributeButton onClick={() =&gt; alert('clicked!')}&gt;<br/>      Button<br/>    &lt;/AttributeButton&gt;<br/>  );<br/>};</span></pre><p id="a8ec" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">Styled Components <code class="fe my mz na mi b">attrs</code>函数允许您定义Styled Components将拥有的附加属性，而无需在使用时显式定义它。在这种情况下，如果没有设置，type将默认为<code class="fe my mz na mi b">button</code>。</p><p id="d5bf" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated"><code class="fe my mz na mi b">attrs</code>函数也可以接受静态道具的对象。但是，如果以这种方式定义，则用户不能覆盖该值，因为属性优先。</p><h1 id="fe2e" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">属性类型</h1><p id="f02f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">由于样式化组件是有效的React组件，它们也支持<code class="fe my mz na mi b">propTypes</code>和<code class="fe my mz na mi b">defaultProps</code>！</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="8a5a" class="mm ku in mi b gy mn mo l mp mq">const PropTypesButton = styled(Button)`...`;<br/>PropTypesButton.propTypes = {<br/>  onClick: PropTypes.func.isRequired,<br/>  type: PropTypes.oneOf(['button', 'submit', 'reset']),<br/>};<br/>PropTypesButton.defaultProps = {<br/>  type: 'button',<br/>};</span><span id="44ce" class="mm ku in mi b gy mr mo l mp mq">const App = () =&gt; {<br/>  return (<br/>    &lt;PropTypesButton onClick={() =&gt; alert('clicked!')}&gt;<br/>      Button<br/>    &lt;/PropTypesButton&gt;<br/>  );<br/>};</span></pre><p id="33b8" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">就像React组件一样，这将有助于验证正确数据，并在样式化组件无效时发出警告。</p><h1 id="fa6e" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">全局样式表</h1><p id="a803" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在将我的代码库迁移到样式化组件时，我仍然为我的全局样式导入了一个CSS样式表。这是我代码库中剩下的最后一个非风格组件样式，作为一个喜欢一致性的人，我必须找到一个替代品。原来，样式化组件使用<code class="fe my mz na mi b">createGlobalStyle</code>支持全局样式。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="1528" class="mm ku in mi b gy mn mo l mp mq">import { createGlobalStyle } from 'styled-components';</span><span id="97c9" class="mm ku in mi b gy mr mo l mp mq">const GlobalStyle = createGlobalStyle`<br/>  *, *::before, *::after {<br/>    box-sizing: border-box;<br/>  }<br/><br/>  a {<br/>    text-decoration: none;<br/>  }<br/>`;</span><span id="4bb4" class="mm ku in mi b gy mr mo l mp mq">const App = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;GlobalStyle /&gt;<br/>      &lt;Button onClick={() =&gt; alert('clicked!')} type="button"&gt;<br/>        Link<br/>      &lt;/Button&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="a041" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">问题解决了。请注意，与常规样式的组件不同，全局样式不接受子样式。毕竟是全球<strong class="ln io">风格。</strong></p><h1 id="cfe0" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">巴别塔整合</h1><p id="8b0f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">通过样式化组件进行样式化的最大优势之一是通过一些独特的、自动生成的类名来实现样式的本地化。然而，这确实引入了一个不幸的副作用——在一个完全通过样式化组件进行样式化的复杂应用程序中，很难知道哪个DOM元素是由JSX的哪一行生成的。幸运的是，Styled Components提供了一个名为<code class="fe my mz na mi b"><a class="ae ks" href="https://www.npmjs.com/package/babel-plugin-styled-components" rel="noopener ugc nofollow" target="_blank">babel-plugin-styled-components</a></code>的babel插件。这个插件将使用文件名和样式化组件变量名为你的每个样式化组件添加一个开发者友好的类名，允许你容易地跟踪你的组件。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="4b85" class="mm ku in mi b gy mn mo l mp mq">&lt;button<br/>  type="button"<br/>  class="App__Button-sc-1r1t5ph-0 iFtKFk"<br/>&gt;<br/>  Button<br/>&lt;/button&gt;</span></pre><p id="6be8" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">要启用这个插件，只需将其添加到您的<code class="fe my mz na mi b">babel.config.js</code>中。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="f12a" class="mm ku in mi b gy mn mo l mp mq">module.exports = {<br/>  presets: [],<br/>  plugins: ['babel-plugin-styled-components'],<br/>};</span></pre><p id="56f3" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">对于基于零配置项目构建的代码库，如<a class="ae ks" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a>，Styled Components还提供了一个babel宏，可以达到同样的效果。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="a8ee" class="mm ku in mi b gy mn mo l mp mq">import styled from 'styled-components/macro';</span><span id="4775" class="mm ku in mi b gy mr mo l mp mq">const Button = styled.button`...`;</span></pre><h1 id="09d5" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">Jest集成</h1><p id="77d6" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为了测试，Styled Components还有一个叫做<code class="fe my mz na mi b"><a class="ae ks" href="https://www.npmjs.com/package/jest-styled-components" rel="noopener ugc nofollow" target="_blank">jest-styled-components</a></code>的Jest插件。这非常有用，因为唯一自动生成的类名使得快照测试非常容易失败。有了这个插件，可预测的类名和CSS样式一起被创建。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="3bbd" class="mm ku in mi b gy mn mo l mp mq"><em class="nc">// Button.test.js</em><br/>import React from 'react';<br/>import { render } from '@testing-library/react';<br/>import 'jest-styled-components';<br/><br/>import Button from '../Button';<br/><br/>test('snapshot', () =&gt; {<br/>  const { container } = render(&lt;Button /&gt;);<br/>  expect(container.firstChild).toMatchSnapshot();<br/>});</span><span id="af2a" class="mm ku in mi b gy mr mo l mp mq"><em class="nc">// __snapshots__/Button.test.js.snap</em><br/>exports[`snapshot 1`] = `<br/>.c0 {<br/>  display: inline-block;<br/>  padding: 6px 12px;<br/>  font-size: 16px;<br/>  font-family: Arial, sans-serif;<br/>  line-height: 1.5;<br/>  color: white;<br/>  background-color: #6c757d;<br/>  border: none;<br/>  border-radius: 4px;<br/>}</span><span id="33d4" class="mm ku in mi b gy mr mo l mp mq">.c0:not(:disabled) {<br/>  cursor: pointer;<br/>}</span><span id="68c9" class="mm ku in mi b gy mr mo l mp mq">.c0:hover {<br/>  background-color: #5a6268;<br/>}</span><span id="55fa" class="mm ku in mi b gy mr mo l mp mq">&lt;button<br/>  class="c0"<br/>/&gt;<br/>`;</span></pre><p id="20be" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">如果您不喜欢快照，更喜欢直接测试单个样式，<code class="fe my mz na mi b">jest-styled-components</code>用<code class="fe my mz na mi b">toHaveStyleRule</code>匹配器扩展了Jest的<code class="fe my mz na mi b">expect</code>，这样您可以手动检查一个元素是否具有预期的样式。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="c78d" class="mm ku in mi b gy mn mo l mp mq">test('should have style', () =&gt; {<br/>  const { container } = render(&lt;Button /&gt;);<br/>  expect(container.firstChild).toHaveStyleRule(<br/>    'background-color',<br/>    '#6c757d'<br/>  );<br/>  expect(container.firstChild).toHaveStyleRule(<br/>    'background-color',<br/>    '#5a6268',<br/>    {<br/>      modifier: ':hover',<br/>    }<br/>  );<br/>});</span></pre><h1 id="c4b9" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">Stylelint集成</h1><p id="b727" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">最后是林挺。Styled Components提供了几个库来与<code class="fe my mz na mi b"><a class="ae ks" href="https://stylelint.io/" rel="noopener ugc nofollow" target="_blank">stylelint</a></code>集成，确保你用最好的CSS标准编写。<code class="fe my mz na mi b"><a class="ae ks" href="https://www.npmjs.com/package/stylelint-processor-styled-components" rel="noopener ugc nofollow" target="_blank">stylelint-processor-styled-component</a>s</code>从样式化组件中提取样式，用于<code class="fe my mz na mi b">stylelint</code>到lint，<code class="fe my mz na mi b"><a class="ae ks" href="https://www.npmjs.com/package/stylelint-config-styled-components" rel="noopener ugc nofollow" target="_blank">stylelint-config-styled-components</a></code>禁用与样式化组件冲突的<code class="fe my mz na mi b">stylelint</code>规则。要集成，将这两个库添加到您的<code class="fe my mz na mi b">stylelint.config.js</code>中。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="9c41" class="mm ku in mi b gy mn mo l mp mq">module.exports = {<br/>  extends: ['stylelint-config-styled-components'],<br/>  processors: ['stylelint-processor-styled-components'],<br/>};</span></pre><p id="3eb3" class="pw-post-body-paragraph ll lm in ln b lo mt jo lq lr mu jr lt lu mv lw lx ly mw ma mb mc mx me mf mg ig bi translated">要运行，将以下内容添加到您的<code class="fe my mz na mi b">package.json</code>并运行<code class="fe my mz na mi b">npm run test:css</code>。</p><pre class="kd ke kf kg gt mh mi mj mk aw ml bi"><span id="603c" class="mm ku in mi b gy mn mo l mp mq">{<br/>  "scripts": {<br/>    "lint:css": "stylelint './src/**/*.js'",<br/>  },<br/>}</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="e513" class="kt ku in bd kv kw nk ky kz la nl lc ld jt nm ju lf jw nn jx lh jz no ka lj lk bi translated">最后的想法</h1><p id="cfce" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">这就是你想要知道的关于风格化组件的一切！它为各种你甚至不知道将要面对的场景提供了造型解决方案。它提供了与React生态系统中常用工具的集成。它提供了一个成熟的样式框架，简化并增强了开发人员的体验。现在你知道了，开始像专家一样使用样式化的组件吧！</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="17cb" class="kt ku in bd kv kw nk ky kz la nl lc ld jt nm ju lf jw nn jx lh jz no ka lj lk bi translated">资源</h1><ul class=""><li id="6033" class="np nq in ln b lo lp lr ls lu nr ly ns mc nt mg nu nv nw nx bi translated"><a class="ae ks" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">官方风格组件文档</a></li><li id="bfff" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated"><a class="ae ks" href="https://github.com/mjchang/medium/tree/master/styled-components-2" rel="noopener ugc nofollow" target="_blank">本文Github回购</a></li><li id="49ab" class="np nq in ln b lo ny lr nz lu oa ly ob mc oc mg nu nv nw nx bi translated"><a class="ae ks" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/styled-components-2" rel="noopener ugc nofollow" target="_blank">本文的code sandbox</a></li></ul></div></div>    
</body>
</html>