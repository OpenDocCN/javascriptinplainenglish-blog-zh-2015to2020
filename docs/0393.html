<html>
<head>
<title>Async Concurrency in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步并发</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/async-concurrency-in-javascript-3d128c3e0a53?source=collection_archive---------2-----------------------#2019-10-04">https://javascript.plainenglish.io/async-concurrency-in-javascript-3d128c3e0a53?source=collection_archive---------2-----------------------#2019-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/009a48cfdf2fc0e125d90cc12f8bc4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3x1qzp29p8eS6JWexK3s3Q.jpeg"/></div></div></figure><p id="f012" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我最近的任务是构建一个微服务，它需要发出数千个HTTP请求并处理响应。为了创建一个简单的模拟场景，我将使用一个假的<code class="fe kt ku kv kw b">request</code>函数，该函数接受一个任意值并返回一个<code class="fe kt ku kv kw b">Promise</code>，该函数解析为一个包含值和间隔的对象:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="6b23" class="lf lg in kw b gy lh li l lj lk"><strong class="kw io">const </strong>{promisify} = require('util')<br/><strong class="kw io">const </strong>sleep = promisify(setTimeout)</span><span id="9b5f" class="lf lg in kw b gy ll li l lj lk"><strong class="kw io">const </strong>request = <strong class="kw io">async</strong>(data) =&gt; {<br/>  <strong class="kw io">let </strong>time = Math.random() * 1000<br/>  <strong class="kw io">await </strong>sleep(time)<br/>  <strong class="kw io">return </strong>{data, time}<br/>}</span></pre><p id="b8a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我有一堆包含请求参数数据的记录，所以我做的第一件事就是查询这些记录。对于这个例子，我们将使用一个整数数组来模拟记录。我的第一个直觉(因为我没有经验)是遍历记录数组，发出每个HTTP请求并将结果推送到一个新的数组:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="b545" class="lf lg in kw b gy lh li l lj lk"><strong class="kw io">async function </strong>main() {<br/>  <strong class="kw io">const </strong>records = Array.from(<strong class="kw io">new </strong>Array(10)).map((e, i) =&gt; i)<br/>  <strong class="kw io">let </strong>responses = []<br/>  console.time('Inline')<br/>  <strong class="kw io">for </strong>(<strong class="kw io">let </strong>i = 0; i &lt; records.length; i++) {<br/>    <strong class="kw io">let </strong>response = <strong class="kw io">await </strong>request(records[i])<br/>    responses.push(response)<br/>  }<br/>  console.log(JSON.stringify(responses, null, 2))<br/>  console.timeEnd('Inline')<br/>}</span></pre><p id="1680" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做很好，但是我们必须在发出下一个请求之前等待每个响应，这意味着可能需要10秒钟来执行。结果将如下所示:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="66e6" class="lf lg in kw b gy lh li l lj lk">[<br/>  {     <br/>    "data": 0,<br/>    "time": 48.95140139293264<br/>  },<br/>  {<br/>    "data": 1,<br/>    "time": 351.42969859007377<br/>  },<br/>  ...<br/>]<br/>Inline: 5210.4460449ms</span></pre><p id="a12a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">5秒钟是一段很长的时间。现在让我们看看如何并发地执行这些请求。我们可以将每个<code class="fe kt ku kv kw b">request</code>调用放入一个数组，并使用Promise.all()等待它们全部解析:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="dd61" class="lf lg in kw b gy lh li l lj lk"><strong class="kw io">async function </strong>main() {<br/>  <strong class="kw io">const </strong>records = Array.from(<strong class="kw io">new </strong>Array(10)).map((e, i) =&gt; i)<br/>  console.time('Concurrent')<br/>  let promises = []<br/>  for (let i = 0; i &lt; records.length; i++) {<br/>    promises.push(request(records[i]))<br/>  }<br/>  let responses = await Promise.all(promises)<br/>  console.log(JSON.stringify(responses, null, 2))<br/>  console.timeEnd('Concurrent')<br/>}</span></pre><p id="24a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧，我们刚刚将服务速度提高了<code class="fe kt ku kv kw b">records.length</code>倍！结果看起来像这样:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="2ac3" class="lf lg in kw b gy lh li l lj lk">[<br/>  {<br/>    "data": 0,<br/>    "time": 160.08417354131944<br/>  },<br/>  {<br/>    "data": 1,<br/>    "time": 560.08495847237463<br/>  },<br/>  ...,<br/>  {<br/>    "data": 9,<br/>    "time": 223.39482395749209<br/>  }<br/>]<br/>Concurrent: 560.08495847237463ms</span></pre><p id="a84a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用这种非阻塞方法<code class="fe kt ku kv kw b">responses</code>可以在所有承诺完成后立即得到它们的结果，所以总的执行时间只比最慢的HTTP请求多几毫秒。同样的技术可以用于任何异步操作的集合。</p><p id="4815" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只是为了好玩，让我们用<code class="fe kt ku kv kw b">Array.map:</code>在一行中做同样的事情</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="65c9" class="lf lg in kw b gy lh li l lj lk">let responses = await Promise.all(records.map(record =&gt; request(record)))</span></pre><p id="3dc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这有所帮助，编码愉快。</p></div></div>    
</body>
</html>