<html>
<head>
<title>Module Resolution or Import Alias: The Final Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模块解析或导入别名:最终指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/module-resolution-or-import-alias-the-final-guide-ffda4766be31?source=collection_archive---------18-----------------------#2020-11-29">https://javascript.plainenglish.io/module-resolution-or-import-alias-the-final-guide-ffda4766be31?source=collection_archive---------18-----------------------#2020-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4af" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">如何在(几乎)任何JS/TS项目中启用该功能的指南。</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f6cbc151d7e7134c13252ee35a662988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErLISu9uL_yvqSN96lMWRw.png"/></div></div></figure><p id="b9f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你好，德夫斯。</p><p id="803e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可能是一个老话题，但我认为当您尝试进行这种配置时，仍然会有点困惑:</p><blockquote class="ln lo lp"><p id="239b" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">如何向我的导入添加别名？</em></p></blockquote><p id="5682" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的想法是不要缝合任何特定的框架/工具，而是根据您的应用程序设置，让您知道做什么和如何做。</p><p id="7abd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们检查一下我们试图解决什么问题，一个更抽象的解决方案，以及如何配置你的项目来支持它。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="d4cf" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">问题</h1><p id="906e" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在结构良好的JavaScript应用程序中，我们通常以一种方式组织我们的代码库，使得这些文件做什么或者它们属于哪个领域变得显而易见。</p><p id="7ff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管我们没有“如何构建”的标准，但我们总是试图像<code class="fe my mz na nb b">components</code>、<code class="fe my mz na nb b">helpers</code>、<code class="fe my mz na nb b">models</code>等那样进行组织。有时，在这些文件夹中创建子文件夹，从而创建一个深度嵌套的结构。</p><p id="a966" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看一个小而不太嵌套的应用程序文件夹结构的例子:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="e969" class="ng mc iq nb b gy nh ni l nj nk">.<br/>├── package.json<br/>├── src<br/>│   ├── components<br/>│   │   └── Button<br/>│   │       ├── Button.js<br/>│   │       └── index.js<br/>│   ├── helpers<br/>│   │   └── text.js<br/>│   └── index.js<br/>└── yarn-error.log</span></pre><p id="2822" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常基本的设置，其中:</p><ol class=""><li id="04e7" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">我们有我们的<code class="fe my mz na nb b">src</code>(源)，它保存了我们的应用程序代码；</li><li id="c204" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm nq nr ns nt bi translated"><code class="fe my mz na nb b">src/components</code>保存了我们所有的应用组件；</li><li id="2802" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm nq nr ns nt bi translated"><code class="fe my mz na nb b">src/helpers</code>，它保存了我们所有的助手/实用程序，可以在我们代码的任何地方使用</li></ol><p id="ea3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，假设我们要从按钮组件内的助手文本中导入一个名为<code class="fe my mz na nb b">sanitizeText</code>的函数。我们会这样做:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="0f85" class="ng mc iq nb b gy nh ni l nj nk">import React from "react";<br/>import { sanitizeText } from "../../helpers/text";</span><span id="a67b" class="ng mc iq nb b gy nz ni l nj nk">export const Button = ({ text }) =&gt; {<br/>  return &lt;button&gt;{sanitizeText(text)}&lt;/button&gt;;<br/>};</span></pre><p id="4e4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还不算太糟，但是一旦你开始有越来越多来自不同文件夹和级别的导入，它就开始变得更加混乱。</p><p id="8473" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，你总是需要猜测你要经过多少层才能导入你的代码。当然，现代的代码编辑器可以帮你解决这个问题，只需要显示你是哪一级的，有时甚至可以帮你完成，但是。</p><p id="21f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个问题是，如果您最终创建了一个子文件夹(无论出于什么原因)，您需要通过在路径中添加另一个“向上”级别来修复所有导入。</p><p id="e551" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这不是太多的工作，但也不是最理想的。我们有一个更好的方法，那就是通过<code class="fe my mz na nb b">module resolution</code>或<code class="fe my mz na nb b">import alias</code></p><h1 id="2c84" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">解决办法</h1><p id="ef2d" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">模块解析或导入别名是一种我们可以模拟的方法，与我们导入<code class="fe my mz na nb b">node_modules</code>的方法相同，但是使用我们的内部代码。</p><p id="9b91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以对我们正在使用的工具说:</p><blockquote class="ln lo lp"><p id="9719" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">哎，遇到“帮手/文”的时候，能不能考虑一下”。/src/helpers/text "拜托？</em></p></blockquote><p id="731b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的同一个示例中，我们会有如下代码:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="08be" class="ng mc iq nb b gy nh ni l nj nk">import React from "react";<br/>import { sanitizeText } from "helpers/text";</span><span id="88d0" class="ng mc iq nb b gy nz ni l nj nk">export const Button = ({ text }) =&gt; {<br/>  return &lt;button&gt;{sanitizeText(text)}&lt;/button&gt;;<br/>};</span></pre><p id="b5b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">酷多了，对吧？</p><p id="9ce5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你将从<code class="fe my mz na nb b">helpers</code>导入，不管你在你的应用程序结构中有多深。即使您移动这个文件，导入也总是正确的。</p><p id="2e3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最终，这就像在我们的项目中导入一个库。想象一下，如果你不得不每次都在<code class="fe my mz na nb b">node_modules</code>里上上下下，直到找到你的依赖:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="56bd" class="ng mc iq nb b gy nh ni l nj nk">import React from "react";<br/>import { sanitizeText } from "helpers/text";<br/>import { camelCase } from '../../../node_modules/lodash'</span><span id="5f39" class="ng mc iq nb b gy nz ni l nj nk">export const Button = ({ text }) =&gt; {<br/>  return &lt;button&gt;{camelCase(sanitizeText(text))}&lt;/button&gt;;<br/>};</span></pre><p id="2e4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将是地狱。导航到代码会浪费很多精力。</p><h1 id="1cbe" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">配置</h1><p id="7384" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">JavaScript本身不允许我们在本地进行这些导入。但幸运的是，我们一直在使用支持该功能的工具(例如Babel、Webpack等)。</p><p id="106a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能会想:</p><blockquote class="ln lo lp"><p id="b13d" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">太好了，我只需要做一次这样的配置！</em></p></blockquote><p id="28f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答案是:视情况而定……但很可能不是。</p><p id="22c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您在应用程序中引入的工具越多，配置它就变得越复杂。这里有一些例子，这可能是棘手的:</p><ul class=""><li id="09eb" class="nl nm iq kt b ku kv kx ky la nn le no li np lm of nr ns nt bi translated">如果你只使用<strong class="kt ir"> Babel </strong>和添加<strong class="kt ir"> jest </strong>来测试你的应用，你需要在<strong class="kt ir">和</strong>两个地方都添加别名。</li><li id="8e4a" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">如果你在一个带有内置<strong class="kt ir"> Webpack </strong>配置的JS项目中工作，并且你添加了<strong class="kt ir"> Storybook </strong>，你将需要在<code class="fe my mz na nb b">webpack.config.js</code>和自定义Storybook <code class="fe my mz na nb b">babel.config.js</code>中添加一个别名。</li><li id="131d" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">如果你正在用所有这些配置做一个JS项目，并且想要转移到<strong class="kt ir"> TypeScript </strong>，你将需要到处保存这个配置，并且配置<code class="fe my mz na nb b">tsconfig.json</code>文件，让TS知道如何解析那些别名。</li></ul><p id="84cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，这可能令人困惑，但在这里我想让你了解每一个可能的工具。之后，您将检查您的项目是如何工作的，并做所有需要的配置，以便在您的项目中启用这个特性。</p><h1 id="2613" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">编辑器完成</h1><p id="841f" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在我们深入研究配置之前，我们先来谈谈开发人员体验(DX)。</p><p id="18df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您使用VSCode，您可能已经注意到，当您需要导入一些东西时，因为VSCode使用TS，并且它做了很多推理，通常可以自动导入您尝试使用的方法，或者对导入进行自动完成，对吗？</p><p id="807f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">举例来说，当你在Babel中配置别名时，你可能会丢失它，这很糟糕。</p><p id="3247" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想让VSCode知道如何建议这些模块，我们需要创建一个名为<code class="fe my mz na nb b">jsconfig.json</code>(在根级别)的文件，它是<code class="fe my mz na nb b">tsconfig.json</code>的JavaScript版本，并在那里声明那些别名:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="627f" class="ng mc iq nb b gy nh ni l nj nk">{<br/>  "compilerOptions": {<br/>    "baseUrl": ".",<br/>    "paths": {<br/>      "*": [<br/>        "./src"<br/>      ],<br/>      // Your custom aliases here<br/>      "helpers/*": [<br/>        "helpers"<br/>      ],<br/>      "models/*": [<br/>        "models"<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="2d64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次你添加一个新的别名到你的项目中，你需要做的就是到这个文件中添加你的新别名。</p><p id="a648" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您使用Typescript，您不需要这个文件，因为这个配置将在那里进行。</p><p id="4abb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们深入研究一下细节。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="3dc3" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">巴比伦式的城市</h1><h2 id="2202" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">描述</h2><p id="6959" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">如果您的项目在根级别有一个<code class="fe my mz na nb b">babel.config.js</code>或<code class="fe my mz na nb b">.babelrc</code>文件，您可能需要做这个配置。</p><h2 id="f28d" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">配置</h2><p id="8a09" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">首先，你需要安装插件<code class="fe my mz na nb b">babel-plugin-module-resolver</code>:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="cc83" class="ng mc iq nb b gy nh ni l nj nk">yarn install -D babel-plugin-module-resolver</span></pre><p id="d5a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，将这个插件添加到您的babel配置文件中:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="d849" class="ng mc iq nb b gy nh ni l nj nk">{<br/>  "presets": [<br/>    // ....<br/>  ],<br/>  "plugins": [<br/>    // ....<br/>    [<br/>      "babel-plugin-module-resolver",<br/>      {<br/>        "root": [<br/>          "./src"<br/>        ],<br/>        "alias": {<br/>		  // Add your aliases here<br/>          "helpers": "./src/helpers",<br/>          "models": "./src/models"<br/>        }<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><p id="68a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，您可以从<code class="fe my mz na nb b">helpers/&lt;file&gt;</code>和<code class="fe my mz na nb b">models/&lt;file&gt;</code>导入文件。</p><h2 id="34ff" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">资源</h2><ul class=""><li id="7fbd" class="nl nm iq kt b ku mt kx mu la or le os li ot lm of nr ns nt bi translated">仅巴别塔演示:<a class="ae ou" href="https://github.com/raulfdm/aliases-post-demo/tree/main/babel-only" rel="noopener ugc nofollow" target="_blank">https://git hub . com/raulfdm/别名-演示后/tree/main/仅巴别塔</a></li><li id="d571" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">巴别塔插件模块解析器:<a class="ae ou" href="https://www.npmjs.com/package/babel-plugin-module-resolver" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/babel-plugin-module-resolver</a></li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="0444" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">卷曲</h1><h2 id="b6ff" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">描述</h2><p id="76a1" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">汇总是进行这种配置最烦人的工具之一。这是因为官方插件没有足够的智能识别<code class="fe my mz na nb b">index.js</code>进口。</p><p id="4d58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你尝试做类似<code class="fe my mz na nb b">models/User/</code>的事情，插件会抱怨说“模型/用户”是一个文件夹，而不是一个文件。从这个意义上说，您需要完全导入，就像<code class="fe my mz na nb b">models/User/index</code>一样。</p><p id="5a66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">经过一些测试，我意识到这不一定是插件的错。如果我们试图通过<code class="fe my mz na nb b">@rollup/plugin-babel</code>启用该功能，我们仍然需要在导入结束时导入<code class="fe my mz na nb b">index</code>。这似乎是汇总处理导入的方式，我们对此无能为力。</p><h2 id="3fc1" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">配置</h2><p id="e0d2" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">第一步是安装<code class="fe my mz na nb b">@rollup/plugin-alias</code>。</p><p id="93ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，在您的<code class="fe my mz na nb b">rollup.config.js</code>中导入并设置:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="2463" class="ng mc iq nb b gy nh ni l nj nk">import alias from "@rollup/plugin-alias";<br/>import path from "path";</span><span id="e09e" class="ng mc iq nb b gy nz ni l nj nk">export default {<br/>  input: "src/index.js",<br/>  output: {<br/>    format: "cjs",<br/>    dir: "dist",<br/>  },<br/>  plugins: [<br/>    alias({<br/>      /**<br/>       * For custom files extension you might want to add "customerResolver"<br/>       * https://github.com/rollup/plugins/tree/master/packages/alias#custom-resolvers<br/>       *<br/>       * By doing that this plugin can read different kind of files.<br/>       */<br/>      entries: [<br/>        {<br/>          find: "models",<br/>          replacement: path.resolve(__dirname, "src/models"),<br/>        },<br/>        {<br/>          find: "helpers",<br/>          replacement: path.resolve(__dirname, "src/helpers"),<br/>        },<br/>      ],<br/>    }),<br/>  ],<br/>};</span></pre><blockquote class="ln lo lp"><p id="8b32" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">记住:从</em> <code class="fe my mz na nb b"><em class="iq">index.js</em></code> <em class="iq">导入的文件确实需要完全导入</em></p></blockquote><h2 id="0659" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">资源</h2><ul class=""><li id="1f31" class="nl nm iq kt b ku mt kx mu la or le os li ot lm of nr ns nt bi translated">汇总演示:<a class="ae ou" href="https://github.com/raulfdm/aliases-post-demo/tree/main/rollup" rel="noopener ugc nofollow" target="_blank">https://github . com/raulfdm/alias-后期演示/tree/main/汇总</a></li><li id="9ce7" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">汇总+巴贝尔演示:<a class="ae ou" href="https://github.com/raulfdm/aliases-post-demo/tree/main/rollup-babel" rel="noopener ugc nofollow" target="_blank">https://github . com/raulfdm/别名-后期演示/tree/main/汇总-巴贝尔</a></li><li id="d4cb" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">@ roll up/plugin-alias:<a class="ae ou" href="https://github.com/rollup/plugins/tree/master/packages/alias#readme" rel="noopener ugc nofollow" target="_blank">https://git hub . com/roll up/plugins/tree/master/packages/alias # readme</a></li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="773a" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">Webpack</h1><h2 id="b2c1" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">描述</h2><p id="ee04" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">Webpack允许我们做和Babel一样的事情，但是通过它的配置。如果你正在做的项目在代码的某个地方已经有了一个<code class="fe my mz na nb b">webpack.config.js</code>,你需要调整它。</p><h2 id="90b3" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">配置</h2><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="ec94" class="ng mc iq nb b gy nh ni l nj nk">const path = require('path');</span><span id="1826" class="ng mc iq nb b gy nz ni l nj nk">module.exports = {<br/>  // ...<br/>  resolve: {<br/>    alias: {<br/>      // Your custom aliases here<br/>      // __dirname will stands for your root directory level<br/>      // path.resolve will concatenate your project folder location with the aliased folder<br/>      helpers: path.resolve(__dirname, 'src/helpers/'),<br/>      models: path.resolve(__dirname, 'src/models/')<br/>    }<br/>  }<br/>};</span></pre><p id="26ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您正在使用一个框架/平台，该框架/平台在幕后与Webpack一起工作，并允许您扩展其配置，那么解决方案将略有不同，但概念相同。</p><p id="84f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我将向您展示来自NextJS的一个<code class="fe my mz na nb b">next.config.js</code>文件，它允许我们扩展他们的配置:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="7d8e" class="ng mc iq nb b gy nh ni l nj nk">const path = require('path');</span><span id="d0b5" class="ng mc iq nb b gy nz ni l nj nk">module.exports = {<br/>  webpack: (config) =&gt; {<br/>    // Mutate the alias configuration<br/>    config.resolve.alias = {<br/>      // Spread everything to avoid remove any alias they might have<br/>      ...config.resolve.alias,<br/>      // Your custom aliases here<br/>      helpers: path.resolve(__dirname, 'src/helpers/'),<br/>      models: path.resolve(__dirname, 'src/models/')<br/>    }</span><span id="7ab7" class="ng mc iq nb b gy nz ni l nj nk">    // Important: return the modified config<br/>    return config<br/>  },<br/>}</span></pre><h2 id="1ee0" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">资源</h2><ul class=""><li id="0217" class="nl nm iq kt b ku mt kx mu la or le os li ot lm of nr ns nt bi translated">仅演示web pack:<a class="ae ou" href="https://github.com/raulfdm/aliases-post-demo/tree/main/webpack" rel="noopener ugc nofollow" target="_blank">https://github . com/Raul FDM/aliases-post-demo/tree/main/web pack</a></li><li id="f72a" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">扩展web pack next js:<a class="ae ou" href="https://github.com/raulfdm/aliases-post-demo/tree/main/next-webpack" rel="noopener ugc nofollow" target="_blank">https://github . com/Raul FDM/aliases-post-demo/tree/main/next-web pack</a></li><li id="28ba" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">Webpack文档:<a class="ae ou" href="https://webpack.js.org/configuration/resolve/#resolvealias" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/configuration/resolve/#resolvealias</a></li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="38b5" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">玩笑</h1><h2 id="b63a" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">描述</h2><p id="1918" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">现在我们已经有了在常规环境中工作的别名，让我们看看如何让Jest知道如何解析我们的别名</p><p id="8c4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，他们的API是迄今为止最复杂的API之一。这是因为它们用于剔除模拟和测试内容，而不是用于我们有组织的代码。但幸运的是我们能抓住它。</p><p id="0a68" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，首先，您需要了解jest配置在哪里。它可以在<code class="fe my mz na nb b">package.json</code>中，也可以在你的根目录下的一个<code class="fe my mz na nb b">jest.config.js</code>文件中。</p><h2 id="d1d3" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">配置</h2><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="8cf2" class="ng mc iq nb b gy nh ni l nj nk">module.exports = {<br/>  // ...<br/>  moduleNameMapper: {<br/>    // Your custom aliases here<br/>    "^helpers/(.*)": "&lt;rootDir&gt;/src/helpers/$1",<br/>    "^modules/(.*)": "&lt;rootDir&gt;/src/modules/$1",<br/>  },<br/>};</span></pre><h2 id="3b7f" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">资源</h2><ul class=""><li id="c778" class="nl nm iq kt b ku mt kx mu la or le os li ot lm of nr ns nt bi translated">jest Docs:<a class="ae ou" href="https://jestjs.io/docs/en/configuration.html#modulenamemapper-objectstring-string--arraystring" rel="noopener ugc nofollow" target="_blank">https://jest js . io/Docs/en/configuration . html # modulename mapper-object string-string-array string</a></li><li id="1ac1" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">笑话演示:<a class="ae ou" href="https://github.com/raulfdm/aliases-post-demo/tree/main/jest" rel="noopener ugc nofollow" target="_blank">https://github.com/raulfdm/aliases-post-demo/tree/main/jest</a></li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="ea93" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">以打字打的文件</h1><h2 id="c27a" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">描述</h2><p id="f27f" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">对于TS项目，我们通常要从两方面入手:</p><ol class=""><li id="2636" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated">配置transpiler/compiler/bundler工具(如Webpack、Babel)</li><li id="2fad" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm nq nr ns nt bi translated">配置<code class="fe my mz na nb b">tsconfig.json</code></li></ol><p id="1c8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为这些工具使用许多内部工具和Typescript来生成您的最终文件，对于Typescript来说，重要的是您的<code class="fe my mz na nb b">tsconfig.json</code>文件。</p><p id="4269" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，您可能想要添加<code class="fe my mz na nb b">tsc --noEmit</code>作为一个奇特的linter，以确保至少您的代码没有错误并且将正确编译。</p><h2 id="52fa" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">配置</h2><p id="86ff" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">打开你的<code class="fe my mz na nb b">tsconfig.json</code>文件，设置一个<code class="fe my mz na nb b">baseUrl</code>和<code class="fe my mz na nb b">paths</code>:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="d0c3" class="ng mc iq nb b gy nh ni l nj nk">{<br/>  "compilerOptions": {<br/>    // ...</span><span id="2f8f" class="ng mc iq nb b gy nz ni l nj nk">    /* Base URL is a MUST. */<br/>    "baseUrl": ".",<br/>    /* Your aliases will live here */<br/>    "paths": {<br/>      "models/*": [<br/>        "src/models/*"<br/>      ],<br/>      "helpers/*": [<br/>        "src/helpers/*"<br/>      ],<br/>    }<br/>  }<br/>}</span></pre><blockquote class="ln lo lp"><p id="0364" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">提示:如果您正在使用VSCode，通常您可能需要重启它才能导航这些别名导入。</em></p></blockquote><p id="6c35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了明确起见，<code class="fe my mz na nb b">baseUrl: "."</code>将告诉Typescript考虑项目的<strong class="kt ir">根级别</strong>来构建路径。从这个意义上来说，TS会找到“模型”并考虑类似于<code class="fe my mz na nb b">&lt;root&gt;/src/models/*</code>的东西。</p><p id="c39f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">人们把<code class="fe my mz na nb b">baseUrl</code>定义为<code class="fe my mz na nb b">src</code>也很常见。如果这样做，您可以从路径中删除<code class="fe my mz na nb b">src</code>:</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="0cc0" class="ng mc iq nb b gy nh ni l nj nk">{<br/>  "compilerOptions": {<br/>    // ...</span><span id="f4e6" class="ng mc iq nb b gy nz ni l nj nk">    /* Base URL is a MUST. */<br/>    "baseUrl": "src",<br/>    /* Your aliases will live here */<br/>    "paths": {<br/>      "models/*": [<br/>        "models/*"<br/>      ],<br/>      "helpers/*": [<br/>        "helpers/*"<br/>      ],<br/>    }<br/>  }<br/>}</span></pre><h2 id="30d3" class="ng mc iq bd md og oh dn mh oi oj dp ml la ok ol mn le om on mp li oo op mr oq bi translated">资源</h2><ul class=""><li id="5653" class="nl nm iq kt b ku mt kx mu la or le os li ot lm of nr ns nt bi translated">Typescript演示:<a class="ae ou" href="https://github.com/raulfdm/aliases-post-demo/tree/main/typescript" rel="noopener ugc nofollow" target="_blank">https://github . com/Raul FDM/aliases-post-demo/tree/main/typescript</a></li><li id="622f" class="nl nm iq kt b ku nu kx nv la nw le nx li ny lm of nr ns nt bi translated">typescript Docs:<a class="ae ou" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#base-url" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/Docs/handbook/release-notes/typescript-2-0 . html # base-URL</a></li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="9f67" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">其他工具</h1><p id="7dd4" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我试图把重点放在我们独立使用的最常用的工具上，一个特定的框架，但是每一个都有一些关于如何以一种简单的方式扩展或做这件事的特性。</p><p id="5185" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我给你的建议是:总是在谷歌上搜索<code class="fe my mz na nb b">&lt;framework-or-tool-name&gt; import alias</code>。通常，你会在前3个结果中找到答案。</p><h1 id="7353" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">前缀策略</h1><p id="1be7" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">在所有的例子中，我只是使用普通的名字作为我们的别名，但是通常的做法是在它们前面加一个前缀(一个字符)。</p><p id="83f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就我个人而言，我非常喜欢前缀<code class="fe my mz na nb b">@</code>只是因为它真的很好读<code class="fe my mz na nb b">import something "at" components</code>但是有些人不喜欢这种策略，因为这种特殊字符对于<code class="fe my mz na nb b">orgs</code>来说非常受欢迎，就像<code class="fe my mz na nb b">@babel</code>、<code class="fe my mz na nb b">@rollup</code>，它会误导开发人员认为这种导入来自外部资源。</p><p id="25a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所注意到的，这是可选的。请随意使用或不使用任何特殊字符来更清楚地说明内部X外部导入。</p><h1 id="a37b" class="mb mc iq bd md me oa mg mh mi ob mk ml jw oc jx mn jz od ka mp kc oe kd mr ms bi translated">结论</h1><p id="9347" class="pw-post-body-paragraph kr ks iq kt b ku mt jr kw kx mu ju kz la mv lc ld le mw lg lh li mx lk ll lm ij bi translated">我希望在这篇文章结束时，如果你觉得有用的话，你可以调整你的配置并启用这个特性。</p></div></div>    
</body>
</html>