<html>
<head>
<title>Use SQL Query Builder Knex.js with Node.js and Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将SQL查询构建器Knex.js与Node.js和Express.js一起使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-sql-query-builder-knex-js-with-node-js-and-express-js-4373e8d3ed33?source=collection_archive---------1-----------------------#2020-12-19">https://javascript.plainenglish.io/use-sql-query-builder-knex-js-with-node-js-and-express-js-4373e8d3ed33?source=collection_archive---------1-----------------------#2020-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aac8c89fadd30c55e8c9883ef3f2f81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PPPNmaubHqooiILhC887w.png"/></div></div></figure><p id="5a7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我第一次了解<a class="ae kt" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Knex.js </strong> </a>是在一次技术面试中，这是我第一次使用除了<strong class="jx io"> ORM Sequelize.js </strong>之外的另一种抽象来与数据库交互，这是我在<a class="ae kt" href="https://www.gracehopper.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">格蕾丝·赫柏项目</strong> </a>学习期间学到的。<strong class="jx io"> <em class="ku"> Knex.js </em> </strong> <em class="ku">是一个用于JavaScript的</em> <strong class="jx io"> <em class="ku"> SQL查询生成器</em> </strong> <em class="ku">，</em> <strong class="jx io"> <em class="ku">一个位于</em> </strong> <em class="ku"> </em> <strong class="jx io"> <em class="ku">数据库驱动程序</em> </strong> <em class="ku">之上的抽象，用于关系数据库，包括PostgreSQL、MySQL、SQLite2和Oracle。它支持事务、连接池、流式查询、全面的测试套件以及在浏览器中运行的能力。Knex可以在两个节点中使用。Js和浏览器，只受WebSQL的约束。</em></p><p id="2517" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我很好奇，花了一些时间玩它。这很有趣，所以我决定写一篇关于它的文章作为参考，如果有人想自己尝试一下的话。</p><h2 id="fef2" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">步骤1。安装Knex.js和迁移CLI </strong></h2><p id="fd17" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">Knex最好的特性之一是它强大的迁移支持。</p><p id="d256" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">全局安装Knex.js <strong class="jx io">以获得迁移CLI。迁移CLI与knex安装捆绑在一起，由<a class="ae kt" href="https://github.com/tkellen/node-liftoff" rel="noopener ugc nofollow" target="_blank"> node_liftoff </a>模块驱动。</strong></p><p id="06f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行<code class="fe lt lu lv lw b">$ npm install knex -g</code>命令。这将安装软件包和CLI。</p><h2 id="8350" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">第二步。数据库配置</strong></h2><p id="2eee" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">运行<code class="fe lt lu lv lw b">$ knex init</code>创建一个<strong class="jx io"> knexfile.js </strong>。该文件将预先填充一些默认的数据库配置。Knex迁移工具使用<strong class="jx io"> knexfile.js </strong>在指定目录中创建迁移文件，因此您将需要该文件来运行迁移命令。</p><p id="705c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开<strong class="jx io"> knexfile.js </strong>，输入您的数据库匹配不同开发阶段的配置。它有三个默认阶段，<strong class="jx io">开发、试运行和生产</strong>。</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="f387" class="kv kw in lw b gy mf mg l mh mi">const pkg = require('./package.json')<br/>const path = require('path')<br/>const databaseName = pkg.name + (process.env.NODE_ENV === 'test' ? '-test' : '')</span><span id="5cc4" class="kv kw in lw b gy mj mg l mh mi">module.exports = {<br/>  development: {<br/>    client: 'pg',<br/>    connection: `postgres://localhost:5432/${databaseName}`,<br/>    <strong class="lw io">migrations</strong>: {<br/>      directory: path.join(__dirname, './server/db/models/migrations'),<br/>    }<br/>  },<br/> production :{<br/>    client: 'pg',<br/>    connection: process.env.DATABASE_URL,<br/>    pool: {min: 2, max: 10},<br/>    <strong class="lw io">migrations</strong>: {<br/>      directory: path.join(__dirname, './server/db/models/migrations'),<br/>    }<br/>  }<br/>}</span></pre><p id="c484" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保指定迁移目录的路径。这是迁移文件将存在的地方。</p><h2 id="9f0f" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">第三步。使用迁移CLI进行迁移</strong></h2><p id="3134" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">接下来，运行<code class="fe lt lu lv lw b">$ knex migrate:make migration_name</code>命令。</p><p id="6519" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在查看您之前指定的迁移目录，您应该会看到创建了一个新文件，文件名开头有一系列数字，类似于<code class="fe lt lu lv lw b">20201202222750_user.js</code>。它们表示文件创建的年份、日期和时间，以及迁移名称。因为<strong class="jx io">顺序关系到</strong>，所以一个好的经验法则是，您的<strong class="jx io">第一次</strong>迁移应该是不依赖于其他表或数据的表，因为迁移是按时间顺序运行的，并且这个时间戳保持了该顺序。</p><h2 id="c240" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">第四步。定义表格</strong></h2><p id="b558" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">在迁移文件中，有两个函数，<code class="fe lt lu lv lw b">exports.up</code>函数和<code class="fe lt lu lv lw b">exports.down</code>函数。在<code class="fe lt lu lv lw b">exports.up</code>函数中，我们指定对数据库的更改，比如使用<code class="fe lt lu lv lw b">knex.schema.createTable()</code>创建一个表，在<code class="fe lt lu lv lw b">exports.down</code>函数中，我们可以回滚或撤销<code class="fe lt lu lv lw b">exports.up</code>所做的更改，比如使用<code class="fe lt lu lv lw b">knex.schema.dropTable()</code>删除表。您还可以在这里插入、删除列等。请看下面我为我的项目创建的<code class="fe lt lu lv lw b">user</code>表:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="c880" class="kv kw in lw b gy mf mg l mh mi">exports.up = function (knex) {<br/>  return knex.schema.createTable('user', function (table) {<br/>    table.increments('id').primary()<br/>    table.string('firstName').notNullable()<br/>    table.string('lastName').notNullable()<br/>    table.string('email').notNullable()<br/>    table.string('password')<br/>    table.string('googleId')<br/>    table.timestamps(true, true)<br/>  })<br/>}</span><span id="5691" class="kv kw in lw b gy mj mg l mh mi">exports.down = function (knex) {<br/>  return knex.schema.dropTable('user')<br/>}</span></pre><h2 id="51c9" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">第五步。使用迁移CLI更新数据库</strong></h2><p id="6386" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">运行<code class="fe lt lu lv lw b">$ knex migrate:latest</code>命令更新数据库。检查您的数据库，您应该看到一个新创建的<code class="fe lt lu lv lw b">user</code>表。</p><p id="f511" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，要回滚到最后一批迁移:运行<code class="fe lt lu lv lw b">$ knex migrate:rollback</code>命令，它应该删除您刚刚创建的表并回滚到之前的状态。</p><h2 id="430c" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">第六步。应用程序配置和会话存储</strong></h2><p id="4a57" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">通过要求来自<strong class="jx io"> knexfile </strong>的配置，创建一个<code class="fe lt lu lv lw b">db.js</code>文件和一个数据库实例。每当我们需要与数据库交互时，我们将在整个应用程序中使用这个文件。</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="2e0b" class="kv kw in lw b gy mf mg l mh mi">const environment = process.env.NODE_ENV || 'development';   <br/>const configuration = require('../knexfile')[environment];   <br/>const db = require('knex')(configuration);</span><span id="b8da" class="kv kw in lw b gy mj mg l mh mi">module.exports = db</span></pre><p id="0058" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们建立我们的主应用程序文件<code class="fe lt lu lv lw b">app.js</code>。这里，我们将使用另一个节点模块<code class="fe lt lu lv lw b">connect-session-knex</code>和用户会话的快速会话。运行<code class="fe lt lu lv lw b">$ npm install connect-session-knex</code>，将包导入为<code class="fe lt lu lv lw b">KnexStore</code>，用<code class="fe lt lu lv lw b">KnexStore</code>的实例初始化一个会话存储，参数应该将数据库实例作为其<code class="fe lt lu lv lw b">knex</code>属性。基本设置如下所示，但可以随意添加更多中间件和功能:</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="b044" class="kv kw in lw b gy mf mg l mh mi">const express = require('express')<br/>const session = require('express-session')<br/>const KnexStore = require('connect-session-knex')(session)<br/>const db = require('./db')<br/>if (process.env.NODE_ENV !== 'production') require('dotenv').config()<br/>const PORT = process.env.PORT || 8080<br/>const sessionStore = new KnexStore({knex: db})<br/>const app = express()<br/>module.exports = app</span><span id="b242" class="kv kw in lw b gy mj mg l mh mi">if (process.env.NODE_ENV === 'test') {<br/>  after('close the session store', () =&gt; sessionStore.stopExpiringSessions())<br/>}</span><span id="56f5" class="kv kw in lw b gy mj mg l mh mi">app.use(<br/>  session({<br/>    secret: process.env.SESSION_SECRET || 'my best friend is Marley',<br/>    store: sessionStore,<br/>    resave: false,<br/>    saveUninitialized: false,<br/>  })<br/>)</span><span id="a6c4" class="kv kw in lw b gy mj mg l mh mi">app.listen(PORT, () =&gt; console.log(`Mixing it up on port ${PORT}`))</span></pre><h2 id="f9a2" class="kv kw in bd kx ky kz dn la lb lc dp ld kg le lf lg kk lh li lj ko lk ll lm ln bi translated"><strong class="ak">第七步。创建一些API路径</strong></h2><p id="b40e" class="pw-post-body-paragraph jv jw in jx b jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ls kq kr ks ig bi translated">现在让我们用快速路由器写一些API路由。Knex.js查询语法类似于原始SQL，但我们实际上是在编写JavaScript。这里有一个有用的<a class="ae kt" href="https://devhints.io/knex#select-1" rel="noopener ugc nofollow" target="_blank">小抄</a>。我们将在这里分配<code class="fe lt lu lv lw b">req.session.user</code>并使用<code class="fe lt lu lv lw b">bcrypt</code>加密用户密码(抱歉，不在本文范围内，但<a class="ae kt" href="https://medium.com/@jengopockets/encrypting-seeded-passwords-with-node-js-knex-and-bcrypt-e2efe56f745e" rel="noopener">这篇中型文章</a>是一个很好的参考。)</p><p id="4389" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如下图所示，我们创建了两条<code class="fe lt lu lv lw b">post</code>路线、<code class="fe lt lu lv lw b">/signup</code>和<code class="fe lt lu lv lw b">/login</code>。主要区别是对于<code class="fe lt lu lv lw b">/signup</code>，数据库中还不存在用户，所以我们需要使用<code class="fe lt lu lv lw b">.insert()</code>在数据库中创建用户。Knex的<code class="fe lt lu lv lw b">.insert()</code>不会自动返回新创建的记录，我们需要包含<code class="fe lt lu lv lw b">.returning()</code>或传递一个返回数组参数来取回插入的数据，这给我们一个数组带来了不便。从那里，你可以传播它，或者在我们的例子中，我们析构它，因为我们需要分配<code class="fe lt lu lv lw b">req.session.user</code>给用户。</p><p id="b031" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe lt lu lv lw b">/login</code>路线中，注意我们使用<code class="fe lt lu lv lw b">.first('*')</code>而不是<code class="fe lt lu lv lw b">.select('*')</code>从<code class="fe lt lu lv lw b">user</code>表中查询数据库。<code class="fe lt lu lv lw b">.select('*')</code>用记录的<strong class="jx io">数组</strong>解析，而<code class="fe lt lu lv lw b">.first('*')</code>用查询的<strong class="jx io">第一个</strong>记录解析，这给了我们一个<strong class="jx io">对象</strong>。</p><pre class="lx ly lz ma gt mb lw mc md aw me bi"><span id="5229" class="kv kw in lw b gy mf mg l mh mi">const router = require('express').Router()<br/>const db = require('../db')<br/>const bcrypt = require('bcrypt')</span><span id="35bb" class="kv kw in lw b gy mj mg l mh mi">module.exports = router</span><span id="8db9" class="kv kw in lw b gy mj mg l mh mi">router.post('/signup', async (req, res, next) =&gt; {<br/>  try {<br/>    const {email, password} = req.body<br/>    const hash = await bcrypt.hashSync(password, 10)<br/>    const <strong class="lw io">[user]</strong> = await db('user').insert({email, hash}).returning('*')<br/>    <strong class="lw io">req.session.user = user</strong><br/>    res.json(user)<br/>  } catch (err) {<br/>    if (err) {<br/>      res.status(401).send('User already exists')<br/>    } else {<br/>      next(err)<br/>    }<br/>  }<br/>})</span><span id="f3d9" class="kv kw in lw b gy mj mg l mh mi">router.post('/login', async (req, res, next) =&gt; {<br/>  try {<br/>    const {email, password} = req.body<br/>    const user = await db('user').first('*').where({email})<br/>    if (!user) {<br/>      console.log('No such user found:', req.body.email)<br/>      res.status(401).send('Wrong username and/or password')<br/>    } else {<br/>      const validPass = await bcrypt.compare(password, user.hash)<br/>      if (validPass) {<br/>        <strong class="lw io">req.session.user = user</strong><br/>        res.json(user)<br/>      } else {<br/>        console.log('Incorrect password for user:', email)<br/>        res.status(401).send('Wrong username and/or password')<br/>      }<br/>    }<br/>  } catch (err) {<br/>    next(err)<br/>  }<br/>})</span></pre><p id="d08d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">差不多就是这样。现在，您可以在后台使用<strong class="jx io"> Knex.js、Node.js </strong>和<strong class="jx io"> Express.js </strong>在我们刚刚创建的样板文件的基础上构建您的应用程序。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="a99d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总的来说，raw SQL的使用仍然更广泛，可移植性也更高。Knex这样的查询捆绑器允许动态查询，但它仍然是基于语言/项目/平台的。我认为，在尝试使用<strong class="jx io">抽象</strong>或<strong class="jx io"> ORM </strong>如<strong class="jx io"> Knex.js </strong>或<strong class="jx io"> Sequelize.js </strong>之前，首先知道如何使用<strong class="jx io">数据库驱动程序</strong>如<code class="fe lt lu lv lw b">pg</code>库和原始SQL与数据库进行交互是很重要的。不仅学习曲线会变得更加直观，因为这些抽象通常具有大量现成的特性，而且如果招聘公司使用不同的工具与他们的关系数据库进行交互，您也可以总是依赖原始的SQL。</p></div></div>    
</body>
</html>