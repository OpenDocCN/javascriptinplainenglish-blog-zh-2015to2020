<html>
<head>
<title>Firebase — Firestore Database Realtime Updates with React Hooks — useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase — Firestore数据库实时更新与React挂钩—使用效果</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/firebase-firestore-database-realtime-updates-with-react-hooks-useeffect-346c1e154219?source=collection_archive---------1-----------------------#2020-02-03">https://javascript.plainenglish.io/firebase-firestore-database-realtime-updates-with-react-hooks-useeffect-346c1e154219?source=collection_archive---------1-----------------------#2020-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1bdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我按照Robin Wieruch的一个很棒的教程<a class="ae kl" href="https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial#provide-firebase-in-react" rel="noopener ugc nofollow" target="_blank">来用React应用程序设置Firebase。</a></p><p id="1369" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程设置用户验证并创建了一个<code class="fe km kn ko kp b">withFirebase</code>高阶组件(HOC)，提供Firebase配置和初始化。</p><p id="0801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的问题是，教程中的所有内容都是用类编写的(写于2018年)，我想尝试用钩子设置订阅！</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/d955aa9db8f249231bf72c162814a59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p-eQbzXKIG-V5Hjo"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk"><a class="ae kl" href="https://unsplash.com/photos/UKX_DwNKXSA" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/UKX_DwNKXSA</a></figcaption></figure><h2 id="c21b" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">使用useEffect订阅更新</h2><p id="f754" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">传统上，通过<code class="fe km kn ko kp b">componentDidMount()</code>订阅实时更新，然后在<code class="fe km kn ko kp b">componentWillUnmount()</code>取消订阅。</p><p id="106f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用React的useEffect钩子，我们可以设置对Firebase Firestore数据库的订阅，并通过取消订阅进行清理。</p><pre class="kr ks kt ku gt me kp mf mg aw mh bi"><span id="4a54" class="lg lh iq kp b gy mi mj l mk ml">useEffect(() =&gt; {<br/>  const unsubscribe = props.firebase<br/>    .db.collection('myCollectionName')<br/>    .onSnapshot(snapshot =&gt; {<br/>      if (snapshot.size) {<br/>        // we have something<br/>        ** <strong class="kp ir">Handle returned data **</strong><br/>      } else {<br/>        // it's empty<br/>      }<br/>    })</span><span id="8d7c" class="lg lh iq kp b gy mm mj l mk ml">return () =&gt; {<br/>    unsubscribe()<br/>  }<br/>}, [props.firebase])</span></pre><p id="3eb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们声明一个名为unsubscribe的常量，它调用firebase prop，使用<a class="ae kl" href="https://firebase.google.com/docs/firestore/query-data/listen?authuser=0" rel="noopener ugc nofollow" target="_blank"> onSnapshot() </a>订阅更新。</p><p id="f865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">useEffect中的<code class="fe km kn ko kp b">return</code>调用处理清理。这里我们称之为<code class="fe km kn ko kp b">unsubscribe()</code>，它在组件卸载时运行。</p><p id="5796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做的最后一件事是<a class="ae kl" href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" rel="noopener ugc nofollow" target="_blank">优化挂钩</a>，仅在<code class="fe km kn ko kp b">[props.firebase]</code>改变时重新运行。也可以使用空数组<code class="fe km kn ko kp b">[]</code>在组件第一次挂载时只运行一次。</p><h2 id="5f93" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">处理返回的数据</h2><p id="b9e4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果我们的Firebase Firestore系列有文档，那么<code class="fe km kn ko kp b">snapshot.size</code>将等同于<code class="fe km kn ko kp b">true</code>。</p><p id="2188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们可以处理返回的结果。</p><p id="f0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以声明一个数组变量，遍历快照，将数据推送到数组，并将新的数据数组存储在state:</p><pre class="kr ks kt ku gt me kp mf mg aw mh bi"><span id="9531" class="lg lh iq kp b gy mi mj l mk ml">let myDataArray = []</span><span id="56f7" class="lg lh iq kp b gy mm mj l mk ml">snapshot.forEach(doc =&gt;<br/>  myDataArray.push({ ...doc.data() })<br/>)</span><span id="66d1" class="lg lh iq kp b gy mm mj l mk ml">setData(myDataArray)</span></pre><h2 id="aec2" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">否则…</h2><p id="5bf5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果<code class="fe km kn ko kp b">snapshot.size</code>等同于<code class="fe km kn ko kp b">false</code>，则提取出现了问题。</p><p id="8d3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能只是因为集合是空的。</p><h2 id="a255" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">搬运装载</h2><p id="be04" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">对于这个组件，我想显示一个加载微调器，直到我从Firestore返回一个结果。</p><p id="a6d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，将加载变量存储在state中，并将其初始化为<code class="fe km kn ko kp b">true</code>——我们正在加载，直到Firestore告诉我们其他方法。</p><p id="8509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">const [loading, setLoading] = useState(true)</code></p><p id="aa9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的组件内部，我们可以测试加载状态，显示一个<code class="fe km kn ko kp b">&lt;Loader /&gt;</code>或<code class="fe km kn ko kp b">null</code>:</p><p id="9bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">{ loading ? &lt;Loader /&gt; : null }</code></p><p id="4d03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的useEffect方法中，当我们从Firebase获得响应时，我们可以将loading设置为false:</p><pre class="kr ks kt ku gt me kp mf mg aw mh bi"><span id="28ff" class="lg lh iq kp b gy mi mj l mk ml">useEffect(() =&gt; {<br/>  const unsubscribe = props.firebase<br/>    .db.collection('myDbName')<br/>    .onSnapshot(snapshot =&gt; {<br/>      if (snapshot.size) {<br/>        // we have something<br/>        <strong class="kp ir">setLoading(false)   </strong>  <br/>      } else {<br/>        // it's empty<br/>       <strong class="kp ir"> setLoading(false)</strong><br/>      }<br/>    })</span><span id="f3ad" class="lg lh iq kp b gy mm mj l mk ml">return () =&gt; {<br/>    unsubscribe()<br/>  }<br/>}, [props.firebase])</span></pre><p id="e3df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果快照返回一些东西或者什么也不返回，无论哪种方式我们都已经完成了加载，所以我们使用<code class="fe km kn ko kp b">setLoading</code>钩子来设置它。</p><h2 id="bd42" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">…就是这样！</h2><p id="9592" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">目前，Firebase HOC是一个很好的设置，我觉得没有必要用钩子重写。</p><h2 id="9611" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">参考链接</h2><ul class=""><li id="36ab" class="mn mo iq jp b jq lz ju ma jy mp kc mq kg mr kk ms mt mu mv bi translated">用React设置Firebase教程，Robin wie ruch—<a class="ae kl" href="https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial/#provide-firebase-in-react" rel="noopener ugc nofollow" target="_blank">https://www . Robin wie ruch . de/complete-Firebase-authentic ation-React-Tutorial/# provide-fire base-in-React</a></li><li id="086b" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">Google Firebase Firestore Docs—<a class="ae kl" href="https://firebase.google.com/docs/firestore/query-data/listen?authuser=0" rel="noopener ugc nofollow" target="_blank">https://Firebase . Google . com/Docs/Firestore/query-data/listen？authuser=0 </a></li><li id="e6e5" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">反应使用效果文档—<a class="ae kl" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-effect.html</a></li></ul></div></div>    
</body>
</html>