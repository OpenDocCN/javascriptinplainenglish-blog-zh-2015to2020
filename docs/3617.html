<html>
<head>
<title>Best of Modern JavaScript — Well-Known Symbols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——众所周知的符号</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-well-known-symbols-242176a5c67b?source=collection_archive---------16-----------------------#2020-10-12">https://javascript.plainenglish.io/best-of-modern-javascript-well-known-symbols-242176a5c67b?source=collection_archive---------16-----------------------#2020-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/433f8957ee7be851fbd2ccb46236c268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OPcoXycExJ7wJcON"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@waldemarbrandt67w?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Waldemar Brandt</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d8f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript中新的OOP特性。</p><h1 id="3ad2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">How to use __proto__?</code></h1><p id="5c6a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了获得对象的原型，我们使用<code class="fe lz ma mb mc b">Object.getPrototypeOf</code>。</p><p id="2a56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一个具有给定原型的对象，我们可以使用<code class="fe lz ma mb mc b">Object.create</code>。</p><p id="7ce5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">被弃用，它阻止了许多浏览器的优化。</p><p id="9ea9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">__proto__</code>可以用来获取和设置一个对象的原型。</p><h1 id="4ef5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可数性</h1><p id="7cd4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">for-in循环遍历自己的和继承的可枚举属性的字符串键。</p><p id="8463" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.keys</code>返回一个可枚举自身属性的字符串键。</p><p id="520a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有字符串化的可枚举对象拥有属性和字符串键。</p><p id="fcbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES6中，<code class="fe lz ma mb mc b">Object.assign</code>只复制可枚举的自身字符串和符号属性。</p><p id="46dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript对象中有许多不可枚举的属性。</p><p id="62c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内置类的所有属性都是不可枚举的。</p><p id="31fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="910a" class="mq lc iq mc b gy mr ms l mt mu">const desc = Object.getOwnPropertyDescriptor.bind(Array);<br/>console.log(desc(Object.prototype, 'toString').enumerable)</span></pre><p id="6054" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe lz ma mb mc b">Array.prototype.toString</code>方法中获得属性描述符。</p><p id="84b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe lz ma mb mc b">enumerable</code>属性，它将记录<code class="fe lz ma mb mc b">false</code>。</p><h1 id="dd11" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将属性标记为不可复制</h1><p id="1f92" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们将一个属性标记为可枚举的，我们可以将它标记为不可复制。</p><p id="187f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ae8e" class="mq lc iq mc b gy mr ms l mt mu">const obj = Object.defineProperty({}, 'foo', {<br/>  value: 'bar',<br/>  enumerable: false<br/>});</span></pre><p id="bd5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe lz ma mb mc b">enumerable</code>属性设置为<code class="fe lz ma mb mc b">false</code>，这样它就不会被<code class="fe lz ma mb mc b">Object.assign</code>或扩展操作符拾取。</p><h1 id="0777" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b"><strong class="ak">Object.assign()</strong></code></h1><p id="112a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.assign</code>可用于将对象源合并到目标中。</p><p id="315e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">源中所有自己的可枚举属性都将被复制到目标中。</p><p id="ff38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不考虑继承的属性。</p><h1 id="c3d6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对<code class="fe lz ma mb mc b">JSON.stringify()</code>隐藏自己的属性</h1><p id="b615" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">对<code class="fe lz ma mb mc b">JSON.stringify</code>隐藏自己的属性可以通过使属性不可枚举来实现。</p><p id="db03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将使<code class="fe lz ma mb mc b">JSON.stringify</code>跳过属性。</p><p id="f76f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以指定<code class="fe lz ma mb mc b">toJSON</code>方法来返回我们想要stringify的对象。</p><p id="3ea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ee28" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  foo: 'bar',<br/>  toJSON() {<br/>    return {<br/>      bar: 'baz'<br/>    };<br/>  },<br/>};</span><span id="ad72" class="mq lc iq mc b gy mv ms l mt mu">console.log(JSON.stringify(obj))</span></pre><p id="c72e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后控制台日志会记录<code class="fe lz ma mb mc b">{“bar”:”baz”}</code>。</p><h1 id="b3ee" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过众所周知的符号定制基本语言操作</h1><p id="f0c5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用熟知的符号自定义基本的语言操作。</p><p id="5a02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Symbol.hasInstance</code>方法让一个对象定制<code class="fe lz ma mb mc b">instanceof</code>操作符的行为。</p><p id="6ece" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Symbol.toPrimitive</code>是一种让我们自定义如何将其转换为原始值的方法。</p><p id="3a7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Symbol.toStringTag</code>方法让我们调用<code class="fe lz ma mb mc b">Object.prototype.toString</code>来计算对象的字符串描述。</p><p id="462f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Symbol.unscopables</code>让我们从<code class="fe lz ma mb mc b">with</code>语句中隐藏一些属性。</p><p id="e708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">obj instanceof C</code>通过做一些检查来工作。</p><p id="1d58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lz ma mb mc b">C</code>不是一个对象，那么它抛出一个<code class="fe lz ma mb mc b">TypeError</code>。</p><p id="c723" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果该方法存在，那么它调用<code class="fe lz ma mb mc b">C[Symbol.hasInstance](obj)</code>。</p><p id="6b14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将结果强制转换为布尔值并返回它。</p><p id="0af2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，它根据常规算法通过检查可伸缩性、<code class="fe lz ma mb mc b">C.prototype</code>在<code class="fe lz ma mb mc b">obj</code>的原型链中等等来计算并返回结果。</p><p id="4649" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标准库中唯一有<code class="fe lz ma mb mc b">Symbol.hasInstance</code>的方法是<code class="fe lz ma mb mc b">Function.prototype</code>。</p><p id="cf80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来检查对象中的值:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="92fe" class="mq lc iq mc b gy mr ms l mt mu">const ObjType = {<br/>  [Symbol.hasInstance](value) {<br/>    return (value !== null &amp;&amp;<br/>      (typeof value === 'object' ||<br/>        typeof value === 'function'));<br/>  }<br/>};</span></pre><p id="120d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lz ma mb mc b">Symbol.hasInstance</code>方法创建自己的<code class="fe lz ma mb mc b">ObjType</code>对象。</p><p id="f81e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要我们要检查的<code class="fe lz ma mb mc b">value</code>。</p><p id="ad20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后检查是否不是<code class="fe lz ma mb mc b">bull</code>,<code class="fe lz ma mb mc b">value</code>的类型是<code class="fe lz ma mb mc b">'object'</code>还是<code class="fe lz ma mb mc b">'function'</code>。</p><p id="c6fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="76ae" class="mq lc iq mc b gy mr ms l mt mu">{} instanceof ObjType</span></pre><p id="7993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe lz ma mb mc b">true</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/397225374af819eb26be0d03e9cd1d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2fwbXpi4X7Lutacr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Glen Carrie</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="29a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0af3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">可以更改和检查对象的可枚举性。</p><p id="b40f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过用众所周知的符号覆盖方法来改变or <code class="fe lz ma mb mc b">instanceof</code>和其他操作符的行为。</p><p id="5230" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>