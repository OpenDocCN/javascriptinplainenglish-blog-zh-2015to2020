<html>
<head>
<title>Let’s Build a Real-Time Chat Application using Socket.IO, React, Node.js and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们使用Socket构建一个实时聊天应用程序。IO、React、Node.js和MongoDB</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-web-sockets-building-a-real-time-chat-application-9cf1002e1398?source=collection_archive---------1-----------------------#2020-08-24">https://javascript.plainenglish.io/introduction-to-web-sockets-building-a-real-time-chat-application-9cf1002e1398?source=collection_archive---------1-----------------------#2020-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d0c5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">web套接字介绍</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dbe391da4f08422d8641cc52c6fcff17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rZuC-AsKF4azT_fD.jpeg"/></div></div></figure><h1 id="604b" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">为什么是web套接字？</h1><p id="9353" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">随着网络的发展，支持它的技术也在发展。虽然<strong class="li io"> REST </strong>仍然是web服务架构的默认选择，但是大多数现代应用程序需要一些<strong class="li io"> REST </strong>无法可靠提供的特性。这些功能有一个共同点，<strong class="li io">实时</strong>。无论是通知系统、聊天室还是活动跟踪器，都需要源源不断的信息。这正是套接字的亮点，它能够来回发送数据，而不必为每个动作重新初始化连接。处理web sockets最好的库之一是<a class="ae mc" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> Socket。IO </strong> </a>。</p><h1 id="3285" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">堆栈</h1><p id="f9d2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们将使用<a class="ae mc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> React </strong> </a>作为前端，<a class="ae mc" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> Node.js </strong> </a>作为后端，<a class="ae mc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> Express </strong> </a>作为web框架，<a class="ae mc" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> MongoDB </strong> </a>作为数据库，<a class="ae mc" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank"><strong class="li io">mongose</strong></a>作为ODM。然后我们将能够使用<a class="ae mc" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io">插座连接两端。IO</strong>T33】惊人的API。<br/>我会假设你已经安装了最新版本的<strong class="li io"> Node.js </strong>，以及自己OS的特定<strong class="li io"> MongoDB </strong>发行版。或者，你可以简单地使用</a><a class="ae mc" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> <strong class="li io">图集</strong> </a>。</p><h1 id="7a31" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">项目结构</h1><p id="3a1d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">让我们继续创建一个新文件夹，<em class="md"> chat-demo/ </em>。在其中，我们可以创建两个子文件夹:<em class="md"> frontend/ </em>和<em class="md"> backend/ </em>，它们将包含各自的源代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi me"><img src="../Images/9ad17b6102feee6aa9e6ae6bf7ed6c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*AJNibYrgKhj2c73k4Pv0Wg.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">You can name the folders however you’d like, of course.</figcaption></figure><h1 id="5c3c" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">设置React</h1><p id="10c5" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们将使用<a class="ae mc" href="https://create-react-app.dev/docs/getting-started" rel="noopener ugc nofollow" target="_blank"><strong class="li io">create-React-app</strong></a>创建一个新的React应用程序。在<em class="md"> frontend/ </em>文件夹中键入以下命令:</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="c1a4" class="mo kp in mk b gy mp mq l mr ms">$ npx create-react-app .</span></pre><p id="b3a5" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们可以删除一些我们不需要的文件。<br/>里面<em class="md">公/ </em>，我们把除了<em class="md">index.html</em>之外的都删掉吧。<br/>在<em class="md"> src/ </em>里面，删除除<em class="md"> App.js </em>、<em class="md"> index.css </em>和<em class="md"> index.js </em>以外的所有内容。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/454cdc63bbc25845986e5fa14b1bc937.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*oze93ILfOt2gVPbQdQTRkw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Deleting said files is not mandatory either, but will leave us with a cleaner structure.</figcaption></figure><h1 id="afb3" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">创建我们的聊天组件</h1><p id="3ed2" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">首先，我们通过在<em class="md"> frontend/ </em>文件夹中键入以下命令来安装<strong class="li io"> socket.io-client </strong>包:</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="1e91" class="mo kp in mk b gy mp mq l mr ms">$ npm i socket.io-client</span></pre><p id="a199" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们现在可以在<em class="md"> App.js </em>中编写我们的聊天组件了。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">This is quite a lot to take in so let’s explain everything as best we can!</figcaption></figure><p id="7088" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们在第6行全局声明我们的套接字实例。我们传递的参数是服务器的URL和一个包含选项的对象。在这种情况下，我们将通过的唯一选项是<strong class="li io"> autoConnect: false </strong>，以便延迟连接，直到我们的所有组件都设置好。这里我们有三个React组件，<strong class="li io">聊天</strong>、<strong class="li io">消息</strong>和<strong class="li io">消息框:</strong></p><p id="a5a7" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated"><strong class="li io">聊天</strong>组件是主组件，它有状态，即消息列表。<br/> <strong class="li io">在第51行</strong>，我们定义了<strong class="li io"> addMessage </strong>，这是一个允许我们向状态添加一个或多个消息的方法。<br/> <strong class="li io">在第55行</strong>处，我们添加了一个<strong class="li io"> useEffect钩子</strong>，它只会运行一次，就在我们的组件已经安装好并准备就绪之后。这是我们初始化套接字连接的最佳位置。<br/> <strong class="li io">在第57行</strong>，我们在我们的套接字上添加了一个处理程序，在“latest”路径上。成功连接后，服务器将在所述路径上发回最新消息。<br/> <strong class="li io">在第61行</strong>，我们在我们的套接字上添加了另一个处理程序，在路径“message”上。每当有新消息发送到聊天室时，服务器将使用此路径通知我们。我们所要做的就是使用<strong class="li io"> addMessage </strong>方法将新消息添加到我们的列表中。<br/> <strong class="li io">线65 </strong>，我们连接到插座。<br/><strong class="li io">聊天</strong>组件返回一个包含消息列表的视图，由单独的<strong class="li io">消息</strong>组件以及<strong class="li io"> MessageBox </strong>组件表示，我们可以在其中输入我们的消息。</p><p id="12f2" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated"><strong class="li io">消息</strong>组件接受一个参数，消息。它没有状态，返回一个格式良好的日期，以及消息的内容。</p><p id="d185" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated"><strong class="li io">消息框</strong>不接受任何参数。它有状态，即我们在框中输入的当前消息的值。它返回一个文本输入表单，在提交时调用<strong class="li io"> postMessage </strong>。因为表单的默认行为是在提交时刷新页面，所以我们必须在事件上调用<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> preventDefault </strong> </a>。<strong class="li io"> postMessage </strong>的目的是传达我们想要发送给服务器的消息。我们通过<strong class="li io">在“消息”路径上发送</strong>我们的消息来实现这一点。在通知服务器之后，我们可以重置组件的状态，这样用户就可以轻松地输入新消息。</p><p id="2a55" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">这可能需要理解很多内容，但让我们继续将index.js更改为以下内容:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Nothing interesting here, just importing our component and rendering it inside the root element in our html view.</figcaption></figure><p id="349a" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们还可以在运行应用程序之前为其添加一些样式:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">This isn’t mandatory, but it will make the UI more interesting for testing.</figcaption></figure><p id="6347" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">一切看起来都很好，让我们用下面的命令运行我们的应用程序:</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="c7f2" class="mo kp in mk b gy mp mq l mr ms">$ npm start</span></pre><p id="b72f" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">您的浏览器中应该会打开一个选项卡，页面应该是这样的，我们可以键入消息并按enter键发送它们，尽管不会更新任何内容，因为我们也需要让后端工作。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/71c5033a0c022008fb45be3abd34cb7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3geeJaklpWZOK1UGPXqOA.png"/></div></div></figure><h1 id="d1f4" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">设置后端</h1><p id="ea64" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">转到<em class="md"> backend/ </em>文件夹，使用命令<em class="md"> npm init </em>创建项目。接下来，我们将安装所需的依赖项:</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="dae7" class="mo kp in mk b gy mp mq l mr ms">npm i express mongoose socket.io cors</span></pre><p id="de17" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated"><strong class="li io"> Cors </strong>是我们之前没有提到的依赖项。它有助于我们轻松处理跨来源请求。在我们的例子中，这些请求将来自我们的前端。<br/>我们创建两个子文件夹，命名为<em class="md"> db/ </em>和<em class="md"> models/ </em>。在<em class="md"> db/ </em>中，我们创建一个名为<em class="md"> db.js </em>的文件。在<em class="md"> models/ </em>中创建另一个名为<em class="md"> message.js. <br/>的文件。最后，创建index.js </em>，这是我们的主文件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/6ede1f211345e1d8d3bec9fdc5ad9f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*RQZ82plUYIfWhD0MFUjD0w.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">The project should now look like this.</figcaption></figure><h1 id="9df5" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">数据库连接和模型</h1><p id="3d0b" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们将在db.js中处理数据库连接:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">By the way, you could simply add the connect function in your main file and be done with it, but separating components is always a good idea, even if they are not large.</figcaption></figure><p id="379b" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们从导入mongoose模块开始。然后，我们可以为某些事件添加一些处理程序，比如当我们连接到数据库时(不是强制的)。最后，我们创建了connect函数，该函数在被调用时会尝试将我们的应用程序连接到数据库。</p><p id="199e" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们将在<em class="md"> message.js: </em>中定义我们的消息模式</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">You can always add more entries, such as the name of the user who sent the message.</figcaption></figure><p id="2d33" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们的模式将有两个字段，日期和内容。我们为我们的模式定义了一些静态方法。Latest将返回我们数据库中插入的最新消息。Create将帮助我们轻松地向数据库添加新消息。</p><h1 id="d85d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">服务器</h1><p id="1042" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">我们将处理<em class="md"> index.js </em>中的所有内容:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">By making main an asynchronous function we are able to wait for the database connection before starting the server.</figcaption></figure><p id="0350" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">我们首先导入我们的依赖项，以及<em class="md"> db.js </em>和<em class="md"> message.js </em>。<br/>在main内部，我们开始尝试连接到我们的数据库，如果不成功，程序将出错退出。接下来，我们使用cors中间件创建express实例。我们可以通过监听定义的端口来启动服务器。<br/>剩下的就是处理套接字了。让我们彻底解释一下我们是如何做到这一点的:</p><p id="8a0a" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">在第28行，我们通过将服务器实例传递给构造函数来创建一个新的套接字。套接字现在将监听我们服务器上的连接。<br/> <strong class="li io">在第29行</strong>，我们为连接创建了一个<strong class="li io">处理程序</strong>。每当<strong class="li io">客户端连接</strong>时，<strong class="li io">处理程序就会运行</strong>。处理程序有一个参数<strong class="li io"> client </strong>，它是服务器和连接的客户端之间的一个新的<strong class="li io">套接字。就像主socket对象一样，我们可以用它来添加更多的处理程序或者<strong class="li io">向每个连接的客户端发送</strong>数据。<br/> <strong class="li io"> Line 32 </strong>，我们为新连接的客户端创建一个处理程序，每当他们发送消息时，该处理程序就会运行，将所述消息添加到数据库中，并通过主套接字上的<strong class="li io">而不是客户端套接字上的</strong>向所有连接的用户广播新消息。第37行</strong>我们从数据库中收集最新的消息，以便在客户端连接时将它们发送回客户端。我们通过客户端套接字上的<strong class="li io">发射来做到这一点。</strong></p><h1 id="c96d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">测试事物</h1><p id="fbb3" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在我们完成了，我们可以测试我们的应用程序。确保您的数据库连接工作正常。使用以下命令启动后端服务器:</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="e342" class="mo kp in mk b gy mp mq l mr ms">$ node index.js</span></pre><p id="ada5" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">如果与数据库的连接成功，您应该会在终端中看到以下消息:</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="d54c" class="mo kp in mk b gy mp mq l mr ms">Connection Established<br/>Server running on port 8463.</span></pre><p id="169f" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">接下来，让我们也启动前端服务器:</p><pre class="kd ke kf kg gt mj mk ml mm aw mn bi"><span id="a9e4" class="mo kp in mk b gy mp mq l mr ms">$ npm start</span></pre><p id="532a" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">就像以前一样，应该会打开一个浏览器选项卡，但这次应用程序将实际工作！你可以对它稍加改动，也许打开另一个浏览器标签，并注意消息在另一个标签上的显示方式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/65dc75448a8122a30eac699e5d5ec699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*K736kzvP_97JWWBaRvJH-A.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Maybe the interface isn’t that good looking, but that’s where you come in! Make it cool!</figcaption></figure><h1 id="afff" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">扩展项目</h1><p id="f64d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">现在您已经有了一个运行的基本应用程序，您可以添加新的特性并改进现有的特性。以下是你接下来可以尝试的几件事:</p><ul class=""><li id="57ff" class="ne nf in li b lj mt lm mu lp ng lt nh lx ni mb nj nk nl nm bi translated"><strong class="li io">用户</strong>。就像标准的身份验证系统一样，只是您必须在套接字消息有效负载中发送身份验证令牌。</li><li id="440a" class="ne nf in li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">允许用户<strong class="li io">修改</strong>，<strong class="li io">删除</strong> <strong class="li io">消息</strong>。</li><li id="5979" class="ne nf in li b lj nn lm no lp np lt nq lx nr mb nj nk nl nm bi translated">为你的用户创建<a class="ae mc" href="https://socket.io/docs/rooms/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io">聊天室</strong> </a>。</li></ul><h1 id="c016" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">源代码</h1><p id="5bac" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">整个项目可在<a class="ae mc" href="https://github.com/phase-services/chat-demo" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> Github </strong> </a>上获得。</p><h1 id="1143" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">关于我们</h1><p id="c12d" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在阶段服务，我们帮助您实现卓越与我们的专用解决方案，专业制作，以刺激增长和提供成功。</p><p id="c219" class="pw-post-body-paragraph lg lh in li b lj mt jo ll lm mu jr lo lp mv lr ls lt mw lv lw lx mx lz ma mb ig bi translated">请登录https://phase.services/<a class="ae mc" href="https://phase.services/" rel="noopener ugc nofollow" target="_blank">网站</a>了解我们提供的服务和我们的专业领域。</p></div></div>    
</body>
</html>