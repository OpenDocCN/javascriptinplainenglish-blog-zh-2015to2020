<html>
<head>
<title>Building Short-lived mobile Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建短期移动应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-short-lived-mobile-apps-41f2ed41ec18?source=collection_archive---------6-----------------------#2020-07-18">https://javascript.plainenglish.io/building-short-lived-mobile-apps-41f2ed41ec18?source=collection_archive---------6-----------------------#2020-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e04a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript如何允许构建需要运行几天的跨平台应用程序，但不能有一点瑕疵</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7d7478cb26ab6b548b44c1eb8648a2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGGUD6cwdTJYrb49gn06Dw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Image by <a class="ae lb" href="https://www.pexels.com/it-it/@tatianasyrikova?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Tatiana Syrikova</a> from <a class="ae lb" href="https://www.pexels.com/it-it/foto/marketing-smartphone-laptop-notebook-3975575/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><h1 id="a439" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">没时间修理它</h1><p id="5e5b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在过去的两三年里，我越来越多地参与开发一种特定类型的移动应用程序，这需要在大多数其他应用程序中不需要的特殊技术预防措施。这些应用程序支持公共或私人活动的所有参与者，如公司会议、婚礼、校友会议、导游等。</p><p id="c9ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像这样的应用程序有一个特点，就是在活动开始前几天才可用，活动一结束(或几天后)就停止工作。它们短暂的“保质期”有一个显著的后果:它们只能在应用商店上发布一次，如果在它们的内容或功能中发现任何缺陷，通过提交新版本来修复它不是一个选项。</p><h1 id="5fd5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我的一点技术史</h1><p id="ae35" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我从2008年开始为iOS开发应用程序，首先是在家里，然后作为一份固定工作。最初拥抱原生平台(XCode和Android SDK)，我逐渐转向跨平台工具，经历了几个不同的解决方案(Appcelerator、ExtJS、Xamarin、React Native)。我从未完全满意过。自2001年以来，我在构建web应用程序时或多或少地经历了同样的失望:所有这些框架都是好东西吗？当恼人的和永无止境的维护任务发生时，第一个时刻的兴奋感是否还站在远处？<br/>长话短说:我说服自己和我的同事，只需要一个极小的平台就足以开发一切，这里“极小”意味着HTML、CSS和jQuery。<br/>这听起来可能很奇怪，但与React或Flutter等高级工具相比，使用这些基础工具确实有优势。但是我将在以后的文章中详细阐述这一点。</p><p id="a234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里值得一提的是，我们的选择对解决我们遇到的问题至关重要:如何修复一个应用程序而不需要重新构建它。</p><h1 id="6df0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">活动管理应用程序的功能</h1><p id="3c87" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，这么短命的App是做什么的？它为用户提供</p><ul class=""><li id="0e7c" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">关于活动的信息(时间表、联系人、地点等。)</li><li id="3040" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">通知</li><li id="e7f1" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">关于这个城市和邻近地区的暗示和好奇</li><li id="edcf" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">地图</li><li id="d512" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">预订额外服务和订阅额外活动的功能</li><li id="018c" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">聊天或其他联系渠道</li></ul><p id="d4be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在大多数情况下，提供了后台web应用程序，其中事件“管理员”可以控制流入和流出用户设备的信息。</p><h1 id="4197" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">编码一次，随时改变</h1><p id="8f4a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们有三个挑战要应对。</p><p id="de63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">首先</strong>，我们的客户可能需要随时修改页面内容。<br/>在应用程序发布后，由于不可预见的情况，他或她可能想要更改、添加或删除任何文本、图像、样式和导航树本身。</p><p id="875e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">其次</strong>，即使在活动开始后，应用程序逻辑的某些方面也可能发生变化(例如，由于组织限制，预订功能的某些行为)。</p><p id="c9ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三</strong>，我们必须能够修复发布后出现的任何bug，而无需发布新版本。</p><p id="39e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，我们找到的解决方案依赖于一种机制，在这种机制中，应用程序与驻留在后端服务器上的数据保持同步，其中“数据”包括实际内容，但也包括软件块(HTML、CSS和javascript)。</p><p id="2e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何做到这一点。</p><h1 id="387e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">软件平台</h1><p id="40e3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们编写的应用程序很像一个标准的单页应用程序，以HTML、CSS和jQuery为骨干。为了将它转换成iOs和Android包，我们使用了<a class="ae lb" href="http://Let%27s%20see%20how%20we%20do%20that." rel="noopener ugc nofollow" target="_blank"> Apache Cordova </a>。这种架构的一个优点是，我们可以使用浏览器(通常是Google Chrome)完成95%的开发和测试:需要省略的几件事情是设备专用功能，如推送通知或照片库浏览。</p><p id="aa96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">典型Cordova应用程序的目录树具有以下结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d5366ea9212707194952ea3440ebd406.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ptsxwC5uBp2_FwYybPg3cw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Structure of a Cordova project</figcaption></figure><p id="ec64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，<strong class="jp ir"> <em class="mu"> www </em> </strong>文件夹包含整个应用程序源代码，而所有其他文件夹和文件都为Cordova builder服务，以生成打包同一应用程序的Android、iOs和浏览器版本所需的所有附加组件。<em class="mu"> www </em>文件夹的典型(最少)内容可能是:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/aa8e61bad60da5e8c0e6762fdd695b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*wiFJBoBna7hcY2ARr-geIA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Content of the www folder</figcaption></figure><p id="c10e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建时，Cordova将整个文件夹复制到Android和XCode资产中，成为最终包的一部分。index.html文件是应用程序的入口点，和一个简单的网络应用程序一样。在我们的应用程序中，我们还使用了SQLite数据库，适当的Cordova插件(cordova-sqlite-ext)将该数据库复制到设备的可写区域，而所有其他文件都不能由程序写入。</p><p id="eef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何利用这个简单的结构来获得一个应用程序，我们可以改变它而不用重新构建它，更不用说发布它了。</p><h1 id="d74f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第一:数据同步</h1><p id="f0c4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们的应用程序可以在线和离线模式下工作，这要归功于它自己的本地SQLite数据库，其中包含所有相关的基本数据(活动计划、参与者、地址、预订等)。).当我们第一次将应用程序上传到商店时。包中的sqlite文件包含当时可用数据的最新版本。之后，应用程序会在适当的时候调用后端服务器来保持更新:</p><ul class=""><li id="18be" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">开始时</li><li id="3c51" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">当用户从后台恢复时</li><li id="e755" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">当它出于其他目的(如预订服务)调用服务器时</li></ul><p id="d366" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当调用服务器时，我们的应用程序向它发送“最后更新”的时间戳，并负责将新的时间戳保存在应用程序的本地存储中。在服务器端，服务器选择此后所做的所有更改，并以SQLite语句的形式返回给应用程序。稍后我们将看到更多细节。</p><h1 id="43f1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第二:内容同步</h1><p id="ff8e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了让用户完全控制应用程序页面的内容，整个应用程序根据保存在其SQLite数据库中的数据动态构建页面，我们称之为CMS或<em class="mu">内容管理系统</em>。CMS包含</p><ul class=""><li id="2a84" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">文本(HTML格式，可能包括CSS部分)</li><li id="3bdb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">图像和图像库</li><li id="0263" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">页面之间的关系和转换的定义</li></ul><p id="e02b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为同一个数据库的一部分，数据同步机制也适用于CMS数据。我们创建了一个非常先进的后台工具，让非技术用户在网络后台维护那些CMS数据。</p><h1 id="cdcd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第三:覆盖HTML和CSS</h1><p id="e895" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">CMS允许用户以广泛的自主权处理大多数应用程序页面。图像、文本和链接由用户通过web后端定义，并由应用程序的javascript代码放入正确的HTML上下文中。然后，通过插入表单、按钮等小工具来完成该内容。，由应用程序设计者和开发者计划。</p><p id="a9f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序的这种预先设计的部分由HTML模板和CSS定义组成，分别驻留在静态文件夹www/html和www/css中。因此，在需要时不能直接覆盖它。</p><p id="aa42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对预定义的HTML和CSS进行不可预见的更改不太常见，但确实会发生。为了克服这个障碍，我们决定</p><ul class=""><li id="c3ed" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">在用于数据库的同一通道上传送对HTML模板的任何更新</li><li id="9fbb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">通过在HTML文件中插入<em class="mu">脚本</em>标签，使用相同的通道覆盖CSS定义</li><li id="8b13" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">将所有更新的HTML保存到本地存储</li><li id="af62" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">动态加载所有HTML，从本地存储中获取，或者如果缺少，从内置文件中获取。</li></ul><h1 id="0dd7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">第四:覆盖Javascript函数</h1><p id="e14d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如何修复或更改我们应用程序的javascript部分？</p><p id="2456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们构建了我们的代码，使它由小的javascript函数组成:主初始对象(“app”，因为它是一个Cordova应用程序)，有几个映射我们的应用程序的逻辑子部分的属性(例如，app.program、app.reservation、app.contact、app.map等)。).每个函数都是其父对象的<em class="mu">属性</em>(例如app.reservation.listServices、app.contact.sendMsg等)。</p><p id="38b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩下的就简单了:</p><ul class=""><li id="94d7" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">我们在用于数据库和HTML模板的同一通道上传送对javascript函数的更正</li><li id="003d" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">我们按照它们出现的顺序将它们保存到本地存储中</li><li id="1ed3" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">当应用程序启动时，它从本地存储中读取所有的函数重定义并执行它们，从而覆盖之前在静态javascript文件中找到的任何同名函数。</li></ul><p id="5562" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看一些代码。</p><h1 id="e987" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在服务器上:“get updates”API</h1><p id="6c78" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们的后端服务器提供了一个RESTful API，它接收一个时间戳并返回一个JSON响应，该响应包含一个新的时间戳和三个可能的空数组:</p><ul class=""><li id="aea2" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">命名的HTML文件列表</li><li id="f207" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">javascript文件列表，按照它们必须执行的顺序排列</li><li id="81fc" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">SQLite语句的列表，按必须执行的顺序排列</li></ul><p id="bff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个收集javascript和HTML文件更新的PHP代码示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Example code collecting javascript and HTML updates</figcaption></figure><p id="a07f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它扫描一个目录，收集在给定日期之前更改过的所有文件。对于javascript文件，它只返回文件的内容。对于HTML文件，它返回文件名及其内容，并且每个文件必须与它要替换的项目文件完全相同。</p><p id="7ba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于数据库，我们采取了以下策略:</p><ul class=""><li id="e170" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">应用程序以<strong class="jp ir"> SQL语句</strong>的形式接收所有数据库更新</li><li id="f44a" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">对于每个可更新的SQLite表<strong class="jp ir"> <em class="mu"> x </em> </strong>，在MySql数据库中存在一个<strong class="jp ir"> <em class="mu"> sync_x </em> </strong>视图，与表<strong class="jp ir"> <em class="mu"> x </em> </strong>具有相同的列</li><li id="9a65" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">每个<strong class="jp ir"> <em class="mu"> sync_x </em> </strong>包括时间戳和主键</li><li id="56c6" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir"> <em class="mu">触发器</em> </strong>拦截表行的物理删除并产生相应的SQL语句；典型的触发器是</li></ul><pre class="km kn ko kp gt my mz na nb aw nc bi"><span id="b00a" class="nd ld iq mz b gy ne nf l ng nh">DELIMITER $$</span><span id="62e2" class="nd ld iq mz b gy ni nf l ng nh">CREATE TRIGGER IF NOT EXISTS `deleted_from_mytable` AFTER DELETE <br/>ON mytable FOR EACH ROW BEGIN</span><span id="eb60" class="nd ld iq mz b gy ni nf l ng nh">INSERT INTO app_sql (SqlStatement) VALUES( CONCAT('DELETE FROM mytable WHERE MyTable_Id=',old.MyTable_Id) );</span><span id="2b13" class="nd ld iq mz b gy ni nf l ng nh">END;</span><span id="b519" class="nd ld iq mz b gy ni nf l ng nh">$$</span></pre><ul class=""><li id="a2bc" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">一个临时的表(上例中的<em class="mu"> app_sql </em>)收集了触发器生成的所有sql语句和手动构建的语句(在紧急维护SQLite数据库的情况下)</li></ul><p id="e015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是处理这个问题的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Example code preparing SQLite updates</figcaption></figure><p id="9efe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，在后端处理所有人员所需的代码是多么的简短。</p><h1 id="4ad4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在应用程序中:接收更新</h1><p id="3286" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">处理更新的客户端代码也很简单。我们的应用程序调用后端API并处理响应，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切处理完毕后，我们有</p><ul class=""><li id="4bd6" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">最新的数据库</li><li id="9e84" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">最新的javascript函数，也保存在本地存储中</li><li id="5eee" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">保存到本地存储中的已更改HTML文件的新副本</li></ul><p id="a51d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当程序想要使用一个HTML文件时，它总是动态地加载它，有一个非常简单的函数，就像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要一件事来完成任务:每次我们的应用程序启动时，它必须恢复固定的javascript定义。这是微不足道的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="78ee" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="a283" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">注意，使这种解决方案可行的是普通javascript和HTML的使用。我不认为目前的主流工具(如Ionic、React Native、Flutter等。)可以做同样的事情，即动态更新应用程序代码。如果我错了，请告诉我。</p><p id="650d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以称这些应用程序为“自我修复”。即使不正确，也好像是。我们记得，当我们成功地解决了用户智能手机上的意外问题，没有造成任何伤害，用户甚至没有注意到时，我们取得了巨大的成功。</p><p id="017a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种魔法。</p></div></div>    
</body>
</html>