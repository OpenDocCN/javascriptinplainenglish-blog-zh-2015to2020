<html>
<head>
<title>JavaScript Best Practices — More About Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—关于数组的更多信息</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-more-about-arrays-ca794d7cebc2?source=collection_archive---------11-----------------------#2020-05-27">https://javascript.plainenglish.io/javascript-best-practices-more-about-arrays-ca794d7cebc2?source=collection_archive---------11-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/016113eb6998d0e2a30322bd96e90019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dHssX4G2hk2Y6CwS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ondrejmachart?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ondrej Machart</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4e0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="dc41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将探讨用JavaScript操作数组条目的最佳方式。</p><h1 id="4b53" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用<code class="fe lz ma mb mc b">Array.from</code>代替Spread运算符来映射Iterables</h1><p id="6589" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Array.from</code>方法让我们将一个iterable对象转换成一个数组。此外，它还允许我们映射iterable对象的值，而无需创建中间数组。</p><p id="73ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该用它来代替spread操作符和<code class="fe lz ma mb mc b">map</code>一起将一个iterable对象映射到一个新的数组。</p><p id="866b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a677" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  0: 1,<br/>  1: 2,<br/>  length: 2<br/>}<br/>const arr = Array.from(obj, (a) =&gt; a * 2);</span></pre><p id="c4f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个对象<code class="fe lz ma mb mc b">obj</code>，它有整数键的条目和<code class="fe lz ma mb mc b">length</code>属性，所以我们可以用<code class="fe lz ma mb mc b">Array.from</code>方法将它转换成一个数组。</p><p id="b338" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过传入一个回调来映射条目，将条目映射到我们希望作为第二个参数的内容中。</p><p id="ae91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不必使用spread操作符将一个iterable对象转换成一个数组，然后像下面这样对它调用<code class="fe lz ma mb mc b">map</code>:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ad6f" class="mq lc iq mc b gy mr ms l mt mu">function* foo() {<br/>  yield 1;<br/>  yield 2;<br/>}<br/>const arr = [...foo()].map((a) =&gt; a * 2);</span></pre><p id="069c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们定义了一个生成器函数，然后调用它将返回的条目转换成一个数组。然后我们调用<code class="fe lz ma mb mc b">map</code>将它映射到我们想要的条目中。</p><p id="4684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不好，因为我们必须创建一个数组，然后在上面调用<code class="fe lz ma mb mc b">map</code>。</p><h1 id="6b4c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在数组方法回调中使用Return语句，单行箭头函数除外</h1><p id="437e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该总是在我们的数组方法回调中返回一些东西，除非我们为<code class="fe lz ma mb mc b">forEach</code>或者在单行箭头函数中定义了一个回调，它隐式地返回一些东西。</p><p id="9839" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该编写下面的代码来调用<code class="fe lz ma mb mc b">map</code>,用回调函数返回一些东西:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="0c72" class="mq lc iq mc b gy mr ms l mt mu">const arr = [1, 2].map((a) =&gt; a * 2);</span></pre><p id="133b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们的回调是返回<code class="fe lz ma mb mc b">a * 2</code>的<code class="fe lz ma mb mc b">(a) =&gt; a * 2</code>。</p><p id="7a7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以这样写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ccb7" class="mq lc iq mc b gy mr ms l mt mu">const arr = [1, 2].map((a) =&gt; {<br/>  return a * 2;<br/>});</span></pre><p id="91e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样一来，<code class="fe lz ma mb mc b">return</code>的表述就更清晰了。</p><p id="62d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该写像下面这样的东西:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="84b1" class="mq lc iq mc b gy mr ms l mt mu">const arr = [];<br/>[1, 2].map((a) =&gt; {<br/>  arr.push(a * 2);<br/>});</span></pre><p id="1752" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，回调没有返回任何东西。相反，它只是在回调函数之外的<code class="fe lz ma mb mc b">arr</code>数组上调用<code class="fe lz ma mb mc b">push</code>。它产生了一个副作用，没有返回任何东西，这两者都不好。</p><p id="ae06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该让它像<code class="fe lz ma mb mc b">map</code>方法期望的那样在我们的回调中返回一些东西。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/0f455c80b387142f0500b87e7fd79787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BYShcmeoLxvfH4sC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@adam_29063?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adam Bignell</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b10d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果数组有多行，请在数组括号开始后和结束前使用换行符</h1><p id="b23f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果一个数组条目有多行，那么我们应该在左括号之后和右括号之前添加一个换行符来分隔条目和括号。</p><p id="4073" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这提高了数组条目的可读性，因为我们知道它们的开始和结束位置。</p><p id="3e3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来实现这一点:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5c34" class="mq lc iq mc b gy mr ms l mt mu">const arr = [<br/>  {<br/>    a: 1<br/>  },<br/>  {<br/>    b: 2<br/>  }<br/>]</span></pre><p id="06a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个包含对象的数组，在数组的第一个条目之前和最后一个条目之后都有换行符，以使条目更容易阅读。</p><p id="5644" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们可以在一行中写下所有的内容，那么我们就不需要在数组代码中使用换行符来分隔条目和括号。</p><p id="a7df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下内容:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="bf91" class="mq lc iq mc b gy mr ms l mt mu">const arr = [1, 2, 3];</span></pre><p id="1109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们把所有的东西都放在一行中，因为每个条目都很短，我们可以在一行中写下整个数组。</p><h1 id="dd27" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="54b9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Array.from</code>方法适用于将可迭代和不可迭代的类似数组的对象转换成数组，并同时将每个条目映射到新值。</p><p id="bb11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好，因为我们不必创建一个中间数组和调用它的<code class="fe lz ma mb mc b">map</code>,就像我们必须使用spread操作符一样。</p><p id="0192" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的数组条目很长，那么我们应该把它们写在各自的行中。</p><h1 id="4d3d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">简明英语团队的笔记</strong></h1><p id="843f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="8c2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的英语频道</strong> </a>来支持我们</p><p id="65f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>