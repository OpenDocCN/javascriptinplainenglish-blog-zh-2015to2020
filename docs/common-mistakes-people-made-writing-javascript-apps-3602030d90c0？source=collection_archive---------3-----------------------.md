# 开发人员在编写 JavaScript 应用程序时的常见错误

> 原文：<https://javascript.plainenglish.io/common-mistakes-people-made-writing-javascript-apps-3602030d90c0?source=collection_archive---------3----------------------->

![](img/5eb0753e64c75b5be8df9ac1c319ea90.png)

Photo by [Gabriel Gabriel](https://unsplash.com/@osomax?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

每个开发人员在编写应用程序时都会犯一些错误。这是开发过程的正常部分。有些错误比其他错误更容易犯。意识到这些问题是有好处的，这样就可以在问题产生之前纠正它们。一旦我们能够做到这一点，那么我们就可以更容易地开发应用程序，并成为一名熟练的 JavaScript 开发人员，因为我们可以开发出错误更少的应用程序。我们将讨论一些更常见的错误，这样我们可以在这里避免它们

# 混淆平等

在 JavaScript 中，single equal、double equal 和 tripe equal 都有各自的含义。单等号是赋值运算符，它将右边的值赋给左边的变量。双等号是相等检查运算符，它检查对象的内容是否相等，而不检查其类型。三重等于运算符检查对象的内容和类型是否相等。

我们使用单个相等赋值运算符，如下所示:

```
let a = 1
```

这是用来设置变量值的，所以我们在不应该使用的地方使用了 single equal，比如:

```
if (a = 1){ ... }
```

那么我们将把 1 赋给`a`，它总是`true`。这意味着`if`语句中的代码总是运行的。这绝对不是我们想要的。

双等号不应该太多，因为它在检查相等性时不检查对象的类型，所以类似于:

```
1 == '1'
```

如果`true`。这就产生了问题，因为如果我们只检查数字 1，而我们得到的是包含 1 的字符串，它仍然是真的。我们希望将它们转换成相同的类型，然后与`===`进行比较，以检查是否相等，从而避免歧义。因此，如果我们想要比较 1 的所有形式是否都相等，我们首先使用以下公式将它们转换为数字:

```
Number(1) === Number('1')
```

`1`不等于`'1'`，因为它们是不同的类型。这会让事情变得更清楚。如果我们想确定某些东西彼此不相等，那么我们可以使用`!==`来检查它们是否具有相同的内容或相同的类型，所以:

```
1 !== '1'
```

会是`true`。

# 括号不匹配

相互嵌套的语句和函数意味着每个文件中有多层括号。通常情况下，应用程序非常复杂，所以级别会增加。这意味着，如果您使用的文本编辑器不支持语法高亮显示或检查不匹配的括号，那么不匹配的括号很容易出现。使用 Visual Studio Code、Atom 和 Sublime 等现代文本编辑器可以很容易地避免这种情况。如果我们想使用更简单的文本编辑器，那么就使用 linters 和代码格式化工具，比如 ESLint 和 Prettier，来检测这些问题。它们还允许我们自动格式化代码，并检测可能出现的常见样式问题，如引用样式不一致、一行中的字符数、可以缩短的函数等。

# 不匹配的报价

JavaScript 允许我们对字符串使用单引号、双引号和反引号。它们是等价的。但是，我们应该以同样的性格来打开和关闭。所以如果我们用单引号开始一个字符串，然后用单引号结束一个字符串，如果我们用双引号或反勾号开始，然后分别用它们结束字符串。此外，在某些情况下，像引号这样的特殊字符必须转义才能包含在字符串中。如果你用单引号打开一个字符串，那么如果你在一个字符串中使用单引号，那么你必须对它进行转义，以将它包含在字符串中。这也适用于双引号和反斜线。如果你在双引号字符串中使用双引号，那么你必须对它进行转义。如果你在模板字符串中使用反勾号，那么你必须对反勾号进行转义。

# 圆括号

在`if`语句中，圆括号总是必须包围整个条件。例如，类似于:

```
if (x > y) && (y < 10) {...}
```

行不通。写这句话的正确方法是:

```
if ((x > y) && (y < 10)) {...}
```

如果我们想检查两个条件是否都为真。

# 分号

分号在 JavaScript 行尾是可选的。然而，为了让其他人更清楚，我们应该包括它，这样人们就知道一行在哪里结束。我们可以使用一个代码 linter 或者格式化程序，比如 ESLint 或者更漂亮的来自动完成这个任务。许多文本编辑器也有插件来自动修复它。

# 资本化

JavaScript 代码是区分大小写的，所以大小写不同的东西即使拼写相同也会被认为是不同的。引用它们的任何内容也必须正确大写。例如，`getElementsByTagName`应该总是用完全相同的大写字母拼写。JavaScript 中的一般惯例是，我们用 camel 大小写拼写变量和函数名，所以如果我们定义自己的变量，我们应该坚持这样做以保持一致性。

![](img/f1c06a850356e80ff5f5e8b85f34820e.png)

Photo by [Clément H](https://unsplash.com/@clemhlrdt?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 引用尚未加载的代码

为了使用代码，我们参考已经预先定义和加载的代码是很重要的。如果我们使用脚本标签，那么在引用代码之前，我们必须先加载代码。因此，引用包含我们想要使用的变量的脚本的脚本标记应该在引用包含我们想要引用的代码的脚本的脚本标记之前。

幸运的是，如今 JavaScript 模块更加普遍，所以我们只需记住导出您想要在另一个模块中使用的代码，并在引用变量之前将导出的变量导入到您想要使用的模块中。JavaScript 模块解决了很多脚本标签的问题。全局变量不再需要使用太多来让不同的脚本引用同一个变量，而且我们可以在不使用闭包的情况下使变量私有，因为我们只需要导出其他地方需要的变量。

# 变量名

在 JavaScript 中，有许多保留字不能用作变量名。它们不应该用作变量名，因为它们与保留字的名称冲突，给 JavaScript 解释器造成混乱。为了避免这种情况，我们应该使用描述性的名字，比如`firstName`、`lastName`等等。

# 范围

我们不应该尽可能使用全局变量。这意味着我们声明的所有变量应该分别使用`let`或`const`关键字作为变量和常量。这避免了全局变量范围和覆盖全局变量数据的问题。它还可以让我们避免错误，不要给应该是常量的实体赋值，也不要意外地给全局赋值。

# 缺少或意外的参数

当调用缺少预期参数的函数时，可能会返回意外的结果，因为您向函数传递了意外的输入。我们必须确保将正确的参数传递给函数，这样才能得到正确的结果。如果函数用在很多地方，比如库中的函数，检查意外参数也是一个好主意，这样我们就可以优雅地处理意外参数，比如当传入的参数是无效类型或`null`或`undefined`时，结束函数的执行。

# 索引错误

JavaScript 数组从索引 0 开始，所以数组的最后一个索引总是比数组的`length`小 1。当你传入一个超出长度或者像负数一样无效的索引时，我们得到`undefined`，所以如果我们试图获取无效的条目并对其进行处理，我们会得到 ReferenceErrors。

# 空且未定义

`null`和`undefined`是往往是变量值的东西。这意味着当我们通过遍历对象的嵌套属性或循环数组来获取某些东西时，我们必须检查这些。当我们遇到`null`或`undefined`时，我们希望优雅地处理它们。这意味着我们应该经常检查它们。因此，如果我们有一个名为`foo`的对象，我们想访问其中的深层嵌套属性，那么我们应该在每个级别检查`null`或`undefined`，就像这样:

```
if (foo && foo.bar && foo.bar.baz){ ... }
```

这样我们就知道所有的属性都被定义了，这样我们就可以访问`baz`属性。对于数组，如果我们想访问索引`i`，我们应该检查它是否是通过写:

```
if (arr[i]){...}
```

这样我们就不会遇到意外的未定义错误。

可选的链接操作符(`?.`)正在开发中，所以希望它能很快完成，我们可以用它来访问一个对象中深度嵌套的属性，并且我们不再需要处理未定义的属性。此外，Lodash 有一个`get`函数，它可以尝试访问数组和对象的深层属性，并获取值(如果它存在),或者返回`null`(如果在对象的层次结构中间有任何未定义的内容)。这比一长串的`undefined`或`null`检查要好得多。