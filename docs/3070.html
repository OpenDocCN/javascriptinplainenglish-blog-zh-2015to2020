<html>
<head>
<title>Unit testing React components with Enzyme and Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试用酶和Jest反应成分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-testing-react-components-using-enzyme-and-jest-testing-frameworks-b6c834c56c24?source=collection_archive---------11-----------------------#2020-08-25">https://javascript.plainenglish.io/unit-testing-react-components-using-enzyme-and-jest-testing-frameworks-b6c834c56c24?source=collection_archive---------11-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a718957fb08d369ff14764573feb8504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*152X1HUSPpakuxd-FIa3xQ.jpeg"/></div></div></figure><p id="d3eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将使用Jest和React为一个基本的todo应用程序编写单元测试。</p><p id="30a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始吧！</p><h1 id="6cde" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">笑话</strong></h1><p id="aa49" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Jest是一个JavaScript测试框架，旨在确保任何JavaScript代码库的正确性。它允许你用一个平易近人的、熟悉的、功能丰富的API来编写测试，并快速给出结果。</p><p id="6187" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jest有很好的文档记录，需要很少的配置，并且可以扩展以满足您的需求。关于Jest的更多信息，请查看其官方文档。<a class="ae lz" href="https://jestjs.io/docs/en/getting-started" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/en/getting-started</a></p><h1 id="6b64" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">酶</strong></h1><p id="ecd3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Enzyme是React的一个JavaScript测试工具，它使测试React组件的输出变得更加容易。您还可以操纵、遍历和以某种方式模拟给定输出的运行时。欲了解更多信息，请查阅酵素官方文档。</p><p id="18ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lz" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank">https://enzymejs.github.io/enzyme/</a></p><h1 id="4386" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置</h1><p id="67c1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在本教程中，我们将利用create-react-app CLI工具来设置我们的项目。因此，转到您将存储这个项目的目录，并在终端中键入以下内容</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d773" class="mj kx iq mf b gy mk ml l mm mn">create-react-app note-redux-app</span></pre><p id="dd4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您没有create-react-app install，请在终端中键入以下命令进行全局安装。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1bef" class="mj kx iq mf b gy mk ml l mm mn">npm install -g create-react-app</span></pre><h1 id="e268" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安装酶</h1><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f1e9" class="mj kx iq mf b gy mk ml l mm mn">npm install --save-dev enzyme enzyme-adapter-react-16 enzyme-to-json</span></pre><p id="d151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jest测试框架默认捆绑在create-react-app中。</p><p id="fcf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在src文件夹中，创建一个包含以下内容的<strong class="ka ir"> tempPolyfills.js </strong>文件。这对于在旧浏览器上进行测试是必要的。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="ebf5" class="mj kx iq mf b gy mk ml l mm mn">const raf = global.requestAnimationFrame = (cb) =&gt; {<br/>  setTimeout(cb, 0);<br/>};</span><span id="2496" class="mj kx iq mf b gy mo ml l mm mn">export default raf;</span></pre><p id="2943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在src文件夹中，创建一个<strong class="ka ir"> setupTests.js </strong>文件，内容如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8686" class="mj kx iq mf b gy mk ml l mm mn">import raf from './tempPolyfills'<br/>import Enzyme  from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';<br/>Enzyme.configure({ adapter: new Adapter() });</span></pre><p id="4d0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于todo应用程序的样式，我们将利用语义ui库。在我们项目的<strong class="ka ir">index.html</strong>文件中，我们将使用CDN链接添加语义UI库。</p><p id="d7a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir"> app.js </strong>文件中，添加以下代码片段:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8da8" class="mj kx iq mf b gy mk ml l mm mn">import React from 'react';<br/>class App extends React.Component {<br/>  render() {<br/>    return(<br/>      &lt;div<br/>        className='ui text container'<br/>        id='app'<br/>      &gt;<br/>        &lt;table className='ui selectable structured large table'&gt;<br/>          &lt;thead&gt;<br/>            &lt;tr&gt;<br/>              &lt;th&gt;Items&lt;/th&gt;<br/>            &lt;/tr&gt;<br/>          &lt;/thead&gt;<br/>          &lt;tbody&gt;<br/>            items<br/>          &lt;/tbody&gt;<br/>          &lt;tfoot&gt;<br/>            &lt;tr&gt;<br/>              &lt;th&gt;<br/>                &lt;form<br/>                  className='ui form'<br/>                &gt;<br/>                &lt;div className='field'&gt;<br/>                  &lt;input<br/>                    className='prompt'<br/>                    type='text'<br/>                    placeholder='Add item...'<br/>                  /&gt;<br/>                &lt;/div&gt;<br/>                &lt;button<br/>                  className='ui button'<br/>                  type='submit'<br/>                &gt;<br/>                  Add item<br/>                &lt;/button&gt;<br/>                &lt;/form&gt;<br/>              &lt;/th&gt;<br/>            &lt;/tr&gt;<br/>          &lt;/tfoot&gt;<br/>        &lt;/table&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}<br/>export default App;</span></pre><p id="5981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样我们就可以查看todo应用程序的静态版本。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/2ad0db6042f358d6dba642dc6ddc24a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lUOzZ6ifXzR5L6oo.png"/></div></div></figure><p id="4507" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用下面的代码片段让我们的todo应用程序起反应</p><p id="a17b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们的todo应用程序需要一个状态来存储todo项和一个todo项。</p><p id="4ab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面这段代码应该添加到<strong class="ka ir"> app.js </strong>中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="16d7" class="mj kx iq mf b gy mk ml l mm mn">state = {<br/>    items: [],<br/>    item: '',<br/>};</span></pre><p id="e8fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将把输入绑定到状态的item属性。因此，<strong class="ka ir"> app.js </strong>中的输入标签应更新如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8cbd" class="mj kx iq mf b gy mk ml l mm mn">&lt;input<br/>    className='prompt'<br/>    type='text'<br/>    placeholder='Add item...'<br/>    value={this.state.item}<br/>    onChange={this.onItemChange}<br/>/&gt;</span></pre><p id="97c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe mq mr ms mf b">onChange</code>事件被绑定到<code class="fe mq mr ms mf b">onItemChange</code>方法，为了用<code class="fe mq mr ms mf b">input</code>字段的值更新我们状态中的项目属性。<code class="fe mq mr ms mf b">onItemChange</code>方法应该如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7c39" class="mj kx iq mf b gy mk ml l mm mn">onItemChange = (e) =&gt; {<br/>    this.setState({<br/>      item: e.target.value,<br/>    });<br/>  };</span></pre><h1 id="3f7f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">提交表单</h1><p id="3275" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果输入字段为空，则提交按钮被禁用。对于此功能，请在render方法后立即添加下面的代码片段:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="900d" class="mj kx iq mf b gy mk ml l mm mn">const submitDisabled = !this.state.item;</span></pre><p id="0859" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的“添加项目”按钮应该更新如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="457b" class="mj kx iq mf b gy mk ml l mm mn">&lt;button<br/>  className='ui button'<br/>  type='submit'<br/>  disabled={submitDisabled}<br/>&gt;</span></pre><p id="6b77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了提交我们的todo项，我们将向表单添加一个onSubmit事件侦听器，它将触发addItem函数的执行。</p><p id="cebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<code class="fe mq mr ms mf b">onsubmit</code>事件应该添加到表单标签中，如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8a7b" class="mj kx iq mf b gy mk ml l mm mn">onSubmit={this.addItem}</span></pre><p id="3fe1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mf b">addItem</code>功能应该如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="aba7" class="mj kx iq mf b gy mk ml l mm mn">addItem = (e) =&gt; {<br/>    e.preventDefault();<br/>    this.setState({<br/>      items: this.state.items.concat(<br/>        this.state.item<br/>      ),<br/>      item: '',<br/>    });<br/>  };</span></pre><h1 id="8476" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">列出所有待办事项</h1><p id="5977" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要列出所有的待办事项，我们需要迭代items数组中的每个待办事项。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4617" class="mj kx iq mf b gy mk ml l mm mn">&lt;tbody&gt;<br/>  {<br/>    this.state.items.map((item, idx) =&gt; (<br/>      &lt;tr<br/>        key={idx}<br/>      &gt;<br/>        &lt;td&gt;{item}&lt;/td&gt;<br/>      &lt;/tr&gt;<br/>    ))<br/>  }<br/>&lt;/tbody&gt;</span></pre><p id="6250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们的todo应用程序应该是下面的代码片段。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6c65" class="mj kx iq mf b gy mk ml l mm mn">import React from 'react';<br/>class App extends React.Component {<br/>  state = {<br/>    items: [],<br/>    item: '',<br/>  };<br/>  onItemChange = (e) =&gt; {<br/>    this.setState({<br/>      item: e.target.value,<br/>    });<br/>  };<br/>  addItem = (e) =&gt; {<br/>    e.preventDefault();<br/>    this.setState({<br/>      items: this.state.items.concat(<br/>        this.state.item<br/>      ),<br/>      item: '',<br/>    });<br/>  };<br/>  render() {<br/>    const submitDisabled = !this.state.item;<br/>    return(<br/>      &lt;div<br/>        className='ui text container'<br/>        id='app'<br/>      &gt;<br/>        &lt;table className='ui selectable structured large table'&gt;<br/>          &lt;thead&gt;<br/>            &lt;tr&gt;<br/>              &lt;th&gt;Items&lt;/th&gt;<br/>            &lt;/tr&gt;<br/>          &lt;/thead&gt;<br/>          &lt;tbody&gt;<br/>            {<br/>              this.state.items.map((item, idx) =&gt; (<br/>                &lt;tr<br/>                  key={idx}<br/>                &gt;<br/>                  &lt;td&gt;{item}&lt;/td&gt;<br/>                &lt;/tr&gt;<br/>              ))<br/>            }<br/>          &lt;/tbody&gt;<br/>          &lt;tfoot&gt;<br/>            &lt;tr&gt;<br/>              &lt;th&gt;<br/>                &lt;form<br/>                  className='ui form'<br/>                  onSubmit={this.addItem}<br/>                &gt;<br/>                &lt;div className='field'&gt;<br/>                  &lt;input<br/>                    className='prompt'<br/>                    type='text'<br/>                    placeholder='Add item...'<br/>                    value={this.state.item}<br/>                    onChange={this.onItemChange}<br/>                  /&gt;<br/>                &lt;/div&gt;<br/>                &lt;button<br/>                  className='ui button'<br/>                  type='submit'<br/>                  disabled={submitDisabled}<br/>                &gt;<br/>                  Add item<br/>                &lt;/button&gt;<br/>                &lt;/form&gt;<br/>              &lt;/th&gt;<br/>            &lt;/tr&gt;<br/>          &lt;/tfoot&gt;<br/>        &lt;/table&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}<br/>export default App;</span></pre><h1 id="1fb9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用Jest和Enzyme测试我们的待办事项应用</h1><p id="32b9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">create-react-app在<code class="fe mq mr ms mf b">app.test.js</code>文件中为我们设置了一个虚拟测试。让我们使用项目文件夹中的以下命令来执行项目的初始测试。</p><p id="bcd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mf b">npm test</code></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/1bf7f3d112307c4a19db1b260b5d7e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/0*BCv1V_YTPsJKmFhc.png"/></div></figure><p id="b881" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<strong class="ka ir"> App.test.js </strong>并清空文件。在该文件的顶部，我们首先导入想要测试的react组件，从React导入React，从Enzyme导入<code class="fe mq mr ms mf b">shallow()</code>。<code class="fe mq mr ms mf b">shallow()</code>功能将用于在测试期间浅渲染组件。</p><p id="0f7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的第一个测试案例中，我们将断言我们的表应该使用标题“items”来呈现。为了编写这个断言，我们需要:</p><p id="3aa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">浅层呈现组件<br/>遍历虚拟DOM，挑选出第一个<code class="fe mq mr ms mf b">th</code>元素<br/>断言<code class="fe mq mr ms mf b">th</code>元素包含一个文本值“<code class="fe mq mr ms mf b">Items</code>”</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fa1d" class="mj kx iq mf b gy mk ml l mm mn">import App from './App';<br/>import React from 'react';<br/>import { shallow } from 'enzyme';<br/>describe('App', () =&gt; {<br/>  it('should have the `th` "Items"', () =&gt; {<br/>    const wrapper = shallow(<br/>      &lt;App /&gt;<br/>    );<br/>    expect(<br/>      wrapper.contains(&lt;th&gt;Items&lt;/th&gt;)<br/>    ).toBe(true);<br/>  });<br/>});</span></pre><p id="b9e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mf b">shallow()</code>函数返回酶调用的<code class="fe mq mr ms mf b">wrapper</code>对象，浅层包装器。该包装包含浅呈现组件。Enzyme提供给我们的包装器对象有许多有用的方法，我们可以用它们来编写我们的断言。一般来说，这些助手方法<strong class="ka ir">帮助我们遍历和选择虚拟DOM上的元素</strong>。其中一个辅助方法是<code class="fe mq mr ms mf b">contains()</code>。它用于断言虚拟DOM上元素的存在。</p><p id="3a75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mf b">contains()</code>接受一个React元素，在本例中，JSX代表一个HTML元素。它返回一个布尔值，表明呈现的组件是否包含该HTML。</p><p id="295c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">写完我们的第一份酶说明书后，让我们来验证一下是否一切正常。<code class="fe mq mr ms mf b">SaveApp.test.js</code>并使用以下命令从控制台运行测试命令:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5626" class="mj kx iq mf b gy mk ml l mm mn">npm test</span></pre><p id="9192" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们断言该组件包含一个名为“添加项目”的按钮元素</p><p id="0581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前一个<code class="fe mq mr ms mf b">it</code>块之后添加下面的代码片段</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0219" class="mj kx iq mf b gy mk ml l mm mn">it('should have a `button` element', () =&gt; {<br/>    const wrapper = shallow(<br/>      &lt;App /&gt;<br/>    );<br/>    expect(<br/>      wrapper.containsMatchingElement(<br/>        &lt;button&gt;Add item&lt;/button&gt;<br/>      )<br/>    ).toBe(true);<br/>  });</span></pre><p id="8143" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意到新的东西了吗？我们没有使用<code class="fe mq mr ms mf b">contains() </code>酶包装方法，而是使用了containsMatchingElement酶包装方法。如果我们使用contains，我们需要传递<code class="fe mq mr ms mf b">contains()</code>一个具有完全相同的属性集的ReactElement。但通常这是过度的。对于这个规范，只需断言按钮在页面上就足够了。我们可以使用酶的<code class="fe mq mr ms mf b">containsMatchingElement()</code>法。这将检查组件输出中的任何内容<strong class="ka ir">是否看起来像</strong>预期的元素。</p><p id="bfde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不必使用<code class="fe mq mr ms mf b">containsMatchingElement()</code>方法来匹配属性对属性。</p><p id="c3c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将断言输入字段也存在:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="dbea" class="mj kx iq mf b gy mk ml l mm mn">it('should have an `input` element', () =&gt; {<br/>    const wrapper = shallow(<br/>      &lt;App /&gt;<br/>    );<br/>    expect(<br/>      wrapper.containsMatchingElement(<br/>        &lt;input /&gt;<br/>      )<br/>    ).toBe(true);<br/>  });</span></pre><p id="f420" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将断言按钮元素被禁用:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7f67" class="mj kx iq mf b gy mk ml l mm mn">it('`button` should be disabled', () =&gt; {<br/>    const wrapper = shallow(<br/>      &lt;App /&gt;<br/>    );<br/>    const button = wrapper.find('button').first();<br/>    expect(<br/>      button.props().disabled<br/>    ).toBe(true);<br/>  });</span></pre><p id="5571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【T4法】是另一种酶包裹法。它需要一个<strong class="ka ir">酶选择器</strong>作为参数。本例中的选择器是CSS选择器“按钮”。CSS选择器只是一种受支持的酶选择器。有关酶选择器的更多信息，请参见酶文档。我们首先返回第一个匹配的元素。读取按钮上的禁用属性或任何其他属性，我们使用<code class="fe mq mr ms mf b">props()</code>。<code class="fe mq mr ms mf b">props()</code>返回一个对象，该对象指定HTML元素上的属性或反应组件上设置的道具。</p><h1 id="e5ba" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">每次使用beforeEach</h1><p id="4fc2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在所有流行的JavaScript测试框架中，有一个函数我们可以用来帮助测试设置:before每个。before每个都是一个代码块，它将在每个代码块之前运行<strong class="ka ir"/>。我们可以使用这个函数在每个规格之前渲染我们的组件。</p><p id="d511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们的测试套件有一些重复的代码。在我们之前的断言中，我们在每个it块中呈现了组件。为了避免这些重复，我们将重构我们的断言。我们<em class="mu">将</em>仅浅渲染我们的描述块顶部的组件:</p><p id="a964" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们重构的测试套装应该如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b89d" class="mj kx iq mf b gy mk ml l mm mn">describe('App', () =&gt; {<br/>  let wrapper;<br/>  beforeEach(() =&gt; {<br/>    wrapper = shallow(<br/>      &lt;App /&gt;<br/>    );<br/>  });<br/>  it('should have the `th` "Items"', () =&gt; {<br/>    expect(<br/>      wrapper.contains(&lt;th&gt;Items&lt;/th&gt;)<br/>    ).toBe(true);<br/>  });<br/>  it('should have a `button` element', () =&gt; {<br/>    expect(<br/>      wrapper.containsMatchingElement(<br/>        &lt;button&gt;Add item&lt;/button&gt;<br/>      )<br/>    ).toBe(true);<br/>  });<br/>  it('should have an `input` element', () =&gt; {<br/>    expect(<br/>      wrapper.containsMatchingElement(<br/>        &lt;input /&gt;<br/>      )<br/>    ).toBe(true);<br/>  });<br/>  it('`button` should be disabled', () =&gt; {<br/>    const button = wrapper.find('button').first();<br/>    expect(<br/>      button.props().disabled<br/>    ).toBe(true);<br/>  });<br/>});</span></pre><h1 id="8809" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用户交互测试</h1><p id="788b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">用户可以与我们的应用程序进行的第一个交互是填写输入字段以添加新项。我们将在当前的描述块中声明另一个描述块，以便为用户交互将测试用例分组。描述块是我们如何“分组”所有需要相同上下文的规格。</p><p id="35f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们为内部描述编写的before每个将在外部上下文中声明的before每个之后运行<em class="mu">。因此，在此<code class="fe mq mr ms mf b">beforeEach</code>运行时，包装将已经被浅渲染。正如预期，这个<code class="fe mq mr ms mf b">beforeEach</code>将只运行，因为它阻塞在我们的内部描述块中。</em></p><p id="48d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用模拟方法来模拟用户交互。</p><p id="0482" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">simulate方法接受两个参数:</p><ol class=""><li id="156e" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">要模拟的事件(如“更改”或“单击”)。这决定了使用哪个事件处理程序(如onChange或onClick)。</li><li id="e725" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">事件对象(可选)</li></ol><p id="bf0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，在我们的todo应用程序中，当用户刚刚填充输入字段时，按钮不再被禁用。</p><p id="3a0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们现在可以编写与用户刚刚填充输入字段的上下文相关的规范。我们将编写两个规格:</p><p id="2a01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">状态属性项已更新以匹配输入字段。按钮不再被禁用。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="bccf" class="mj kx iq mf b gy mk ml l mm mn">describe('the user populates the input', () =&gt; {<br/>    const item = 'Laundry';<br/>    beforeEach(() =&gt; {<br/>      const input = wrapper.find('input').first();<br/>      input.simulate('change', {<br/>        target: { value: item }<br/>      })<br/>    });<br/>    it('should update the state property `item`', () =&gt; {<br/>      expect(<br/>        wrapper.state().item<br/>      ).toEqual(item);<br/>    });<br/>    it('should enable `button`', () =&gt; {<br/>      const button = wrapper.find('button').first();<br/>      expect(<br/>        button.props().disabled<br/>      ).toBe(false);<br/>    });<br/>  });</span></pre><p id="612a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一个规范中，我们使用<code class="fe mq mr ms mf b">wrapper.state()</code>来获取状态对象。我们使用<code class="fe mq mr ms mf b">state()</code>方法从组件中检索状态属性。在第二个例子中，我们再次使用<code class="fe mq mr ms mf b">props()</code>来读取按钮上的禁用属性。</p><p id="32bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户填写输入字段后，用户可以从这里采取两个操作，我们可以为其编写规格:</p><ol class=""><li id="e51e" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">用户清除输入字段</li><li id="cc51" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">用户点击“添加项目”按钮</li></ol><h1 id="2127" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">清除输入字段</h1><p id="cb7b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当用户清除输入字段时，我们希望按钮再次被禁用。我们将在描述“用户填充输入”的现有上下文的基础上，在其中嵌套新的描述:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a9ae" class="mj kx iq mf b gy mk ml l mm mn">describe('and then clears the input', () =&gt; {<br/>  beforeEach(() =&gt; {<br/>    const input = wrapper.find('input').first();<br/>    input.simulate('change', {<br/>      target: { value: '' }<br/>    })<br/>  });<br/>  it('should disable `button`', () =&gt; {<br/>    const button = wrapper.find('button').first();<br/>    expect(<br/>      button.props().disabled<br/>    ).toBe(true);<br/>  });<br/>});</span></pre><p id="246e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用beforeEach再次模拟一个更改事件，这次将value设置为一个空字符串。我们将写一个断言:按钮再次被禁用。<br/>当字段为空时，按钮应被禁用。</p><p id="20d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以验证我们所有的测试都通过了。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/05776154f6dd2081308deff0e96507b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*tNiugWJRMyk9R47g.png"/></div></figure><p id="f448" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将模拟用户提交表单。</p><h1 id="1e94" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">模拟表单提交</strong></h1><p id="5cff" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">用户提交表单后，我们将断言:</p><p id="c920" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.新项目处于状态(项目)</p><p id="6480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.新项目位于呈现的表格中</p><p id="c47a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.输入字段为空</p><p id="8e33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.“添加项目”按钮被禁用</p><p id="fb3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们将在“用户填充输入”中编写describe块，作为“然后清除输入”的兄弟:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3bbc" class="mj kx iq mf b gy mk ml l mm mn">describe('and then submits the form', () =&gt; {<br/>      beforeEach(() =&gt; {<br/>        const form = wrapper.find('form').first();<br/>        form.simulate('submit', {<br/>          preventDefault: () =&gt; {},<br/>        });<br/>      });<br/>      it('should add the item to state', () =&gt; {</span><span id="c728" class="mj kx iq mf b gy mo ml l mm mn">      });<br/>      it('should render the item in the table', () =&gt; {</span><span id="bb88" class="mj kx iq mf b gy mo ml l mm mn">      });<br/>      it('should clear the input field', () =&gt; {</span><span id="0381" class="mj kx iq mf b gy mo ml l mm mn">      });<br/>      it('should disable `button`', () =&gt; {</span><span id="099b" class="mj kx iq mf b gy mo ml l mm mn">      });<br/>    });</span></pre><p id="0792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的beforeEach将模拟表单提交。回想一下，addItem需要一个具有preventDefault()方法的对象。<br/>我们将模拟一个submit事件类型，传入一个具有addItem期望的形状的对象。我们将preventDefault设置为一个空函数:</p><p id="d4d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了beforeEach()函数，我们首先断言新项目处于状态:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5ca5" class="mj kx iq mf b gy mk ml l mm mn">it('should add the item to state', () =&gt; {<br/>  expect(<br/>    wrapper.state().items<br/>  ).toContain(item);<br/>});</span></pre><p id="33c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jest附带了一些处理数组的特殊匹配器。我们使用匹配器toContain()来断言数组items包含item。</p><p id="9057" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们断言该项在表中。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c215" class="mj kx iq mf b gy mk ml l mm mn">it('should render the item in the table', () =&gt; {<br/>  expect(<br/>    wrapper.containsMatchingElement(<br/>      &lt;td&gt;{item}&lt;/td&gt;<br/>    )<br/>  ).toBe(true);<br/>});</span></pre><p id="de45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将断言输入字段已经被清除。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7634" class="mj kx iq mf b gy mk ml l mm mn">it('should clear the input field', () =&gt; {<br/>  const input = wrapper.find('input').first();<br/>  expect(<br/>    input.props().value<br/>  ).toEqual('');<br/>});</span></pre><p id="fa2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将断言按钮再次被禁用:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3fd7" class="mj kx iq mf b gy mk ml l mm mn">it('should disable `button`', () =&gt; {<br/>  const button = wrapper.find('button').first();<br/>  expect(<br/>    button.props().disabled<br/>  ).toBe(true);<br/>});</span></pre><p id="bf30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们的<code class="fe mq mr ms mf b">app.test.js</code>文件应该包含以下内容</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7f18" class="mj kx iq mf b gy mk ml l mm mn">import App from './App';<br/>import React from 'react';<br/>import { shallow } from 'enzyme';<br/>describe('App', () =&gt; {<br/>  let wrapper;<br/>  beforeEach(() =&gt; {<br/>    wrapper = shallow(<br/>      &lt;App /&gt;<br/>    );<br/>  });<br/>  it('should have the `th` "Items"', () =&gt; {<br/>    expect(<br/>      wrapper.contains(&lt;th&gt;Items&lt;/th&gt;)<br/>    ).toBe(true);<br/>  });<br/>  it('should have a `button` element', () =&gt; {<br/>    expect(<br/>      wrapper.containsMatchingElement(<br/>        &lt;button&gt;Add item&lt;/button&gt;<br/>      )<br/>    ).toBe(true);<br/>  });<br/>  it('should have an `input` element', () =&gt; {<br/>    expect(<br/>      wrapper.containsMatchingElement(<br/>        &lt;input /&gt;<br/>      )<br/>    ).toBe(true);<br/>  });<br/>  it('`button` should be disabled', () =&gt; {<br/>    const button = wrapper.find('button').first();<br/>    expect(<br/>      button.props().disabled<br/>    ).toBe(true);<br/>  });<br/>  describe('the user populates the input', () =&gt; {<br/>    const item = 'Vancouver';<br/>    beforeEach(() =&gt; {<br/>      const input = wrapper.find('input').first();<br/>      input.simulate('change', {<br/>        target: { value: item }<br/>      });<br/>    });<br/>    it('should update the state property `item`', () =&gt; {<br/>      expect(<br/>        wrapper.state().item<br/>      ).toEqual(item);<br/>    });<br/>    it('should enable `button`', () =&gt; {<br/>      const button = wrapper.find('button').first();<br/>      expect(<br/>        button.props().disabled<br/>      ).toBe(false);<br/>    });<br/>    describe('and then clears the input', () =&gt; {<br/>      beforeEach(() =&gt; {<br/>        const input = wrapper.find('input').first();<br/>        input.simulate('change', {<br/>          target: { value: '' }<br/>        })<br/>      });<br/>      it('should disable `button`', () =&gt; {<br/>        const button = wrapper.find('button').first();<br/>        expect(<br/>          button.props().disabled<br/>        ).toBe(true);<br/>      });<br/>    });<br/>    describe('and then submits the form', () =&gt; {<br/>      beforeEach(() =&gt; {<br/>        const form = wrapper.find('form').first();<br/>        form.simulate('submit', {<br/>          preventDefault: () =&gt; {},<br/>        });<br/>      });<br/>      it('should add the item to state', () =&gt; {<br/>        expect(<br/>          wrapper.state().items<br/>        ).toContain(item);<br/>      });<br/>      it('should render the item in the table', () =&gt; {<br/>        expect(<br/>          wrapper.containsMatchingElement(<br/>            &lt;td&gt;{item}&lt;/td&gt;<br/>          )<br/>        ).toBe(true);<br/>      });<br/>      it('should clear the input field', () =&gt; {<br/>        const input = wrapper.find('input').first();<br/>        expect(<br/>          input.props().value<br/>        ).toEqual('');<br/>      });<br/>      it('should disable `button`', () =&gt; {<br/>        const button = wrapper.find('button').first();<br/>        expect(<br/>          button.props().disabled<br/>        ).toBe(true);<br/>      });<br/>    });<br/>  });<br/>});</span></pre><p id="b6b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以验证我们所有的测试都通过了。</p><h1 id="2958" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">正在寻找React仪表板？</h1><ul class=""><li id="769f" class="mv mw iq ka b kb lu kf lv kj nk kn nl kr nm kv nn nb nc nd bi translated">尝试我们的<a class="ae lz" href="https://www.wrappixel.com/templates/category/react-templates/" rel="noopener ugc nofollow" target="_blank"> React仪表板</a>，为无限的客户项目和个人项目创建令人惊叹的web应用程序。</li><li id="1dcd" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv nn nb nc nd bi translated">使用我们的<a class="ae lz" href="https://www.wrappixel.com/templates/category/react-templates/" rel="noopener ugc nofollow" target="_blank">免费模板</a>开始构建网络应用和产品，无需任何投资。</li></ul><h1 id="c312" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">结论</strong></h1><p id="32f4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">总之，到目前为止，我们已经学会了如何以行为驱动方式组织我们的测试代码，用酶进行浅层渲染。如何使用浅层包装器方法来遍历虚拟DOM，如何使用Jest匹配器来编写不同种类的断言(比如针对数组的<code class="fe mq mr ms mf b">toContain()</code>)。最后，我们看到了如何在react中使用Jest和Enzyme测试框架，使用行为驱动的方法来驱动测试套件的组合。</p></div></div>    
</body>
</html>