<html>
<head>
<title>React Tips — Dispatch and Navigate, useCallback, and Cleanup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—分派和导航、使用回调和清理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-dispatch-and-navigate-usecallback-and-cleanup-f095985ff228?source=collection_archive---------5-----------------------#2020-10-28">https://javascript.plainenglish.io/react-tips-dispatch-and-navigate-usecallback-and-cleanup-f095985ff228?source=collection_archive---------5-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6cd10e83f3c9bd2ba9bfe3e6911da2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l-CFSvgL4pU_QPcH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@carlflor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Carl Flor</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cbdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="23eb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React.useState不从Props重新加载状态</h1><p id="1f4e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">React.useState</code>不从道具重新加载状态。</p><p id="9d3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只能设置初始状态。</p><p id="ad43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要在道具改变时更新状态，那么我们需要使用<code class="fe me mf mg mh b">useEffect</code>钩子。</p><p id="6c35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7305" class="mq lc iq mh b gy mr ms l mt mu">function Avatar({ username }) {<br/>  const [name, setName] = React.useState(username);</span><span id="1f2d" class="mq lc iq mh b gy mv ms l mt mu">  React.useEffect(() =&gt; {<br/>    setName(name);<br/>  }, [username])</span><span id="696a" class="mq lc iq mh b gy mv ms l mt mu">  return &lt;img src={`${name}.png`}/&gt;<br/>}</span></pre><p id="b7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe me mf mg mh b">username</code>道具。</p><p id="c01c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且我们用<code class="fe me mf mg mh b">useState</code>把它设为<code class="fe me mf mg mh b">name</code>状态的初始值。</p><p id="c919" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">useEffect</code>钩子来观察<code class="fe me mf mg mh b">name</code>值的变化。</p><p id="6aa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们观察它的变化，然后调用<code class="fe me mf mg mh b">setName</code>用<code class="fe me mf mg mh b">username</code>的最新值设置名称作为<code class="fe me mf mg mh b">name</code>的新值。</p><p id="76b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在我们渲染的JSX中使用<code class="fe me mf mg mh b">name</code>。</p><h1 id="ba73" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用于useCallback</h1><p id="77a9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">useCallback</code>来缓存回调，这样我们就不会在每次渲染时都调用创建回调函数的新实例。</p><p id="289b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b30b" class="mq lc iq mh b gy mr ms l mt mu">function Foo() {<br/>  const handleClick = () =&gt; {<br/>    console.log('clicked');<br/>  }<br/>  &lt;button onClick={handleClick}&gt;click me&lt;/button&gt;;<br/>}</span></pre><p id="82f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1802" class="mq lc iq mh b gy mr ms l mt mu">function Foo() {<br/>  const memoizedHandleClick = useCallback(<br/>    () =&gt; console.log('clicked'), [],<br/>  );</span><span id="4f56" class="mq lc iq mh b gy mv ms l mt mu">  return &lt;Button onClick={memoizedHandleClick}&gt;Click Me&lt;/Button&gt;;<br/>}</span></pre><p id="6479" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useCallback</code>钩子缓存点击回调，以便在每次渲染时使用相同的实例，而不是创建一个新的。</p><h1 id="5686" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测反应组分与反应元素</h1><p id="0e2d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过检查一个对象是否是一个函数以及它是否包含<code class="fe me mf mg mh b">'return React.createElement'</code>代码来检查它是否是一个函数组件。</p><p id="92ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4d9d" class="mq lc iq mh b gy mr ms l mt mu">const isFunctionComponent = (component) =&gt; {<br/>  return (<br/>    typeof component === 'function' &amp;&amp; <br/>    String(component).includes('return React.createElement')<br/>  )<br/>}</span></pre><p id="6cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查类组件，我们可以检查类型<code class="fe me mf mg mh b">'function'</code>。</p><p id="b97a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在组件的<code class="fe me mf mg mh b">prototype</code>中检查<code class="fe me mf mg mh b">isReactComponent</code>属性。</p><p id="559f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c4c7" class="mq lc iq mh b gy mr ms l mt mu">const isClassComponent = (component) =&gt; {<br/>  return (<br/>    typeof component === 'function' &amp;&amp; <br/>    !!component.prototype.isReactComponent<br/>  )<br/>}</span></pre><p id="ddf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查一个变量是否是一个有效的元素，我们可以使用<code class="fe me mf mg mh b">React.isValidElement</code>方法来完成。</p><p id="9da1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1219" class="mq lc iq mh b gy mr ms l mt mu">const isElement = (element) =&gt; {<br/>  return React.isValidElement(element);<br/>}</span></pre><h1 id="efe7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">当组件卸载时，React挂钩useEffect()清理</h1><p id="8ef3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在<code class="fe me mf mg mh b">useEffect</code>回调中返回一个函数来返回一个运行清理代码的函数。</p><p id="34dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9ca8" class="mq lc iq mh b gy mr ms l mt mu">const { useState, useEffect } = React;</span><span id="9649" class="mq lc iq mh b gy mv ms l mt mu">const ForExample = () =&gt; {<br/>  const [name, setName] = useState("");<br/>  const [username, setUsername] = useState("");</span><span id="71c6" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(<br/>    () =&gt; {<br/>      console.log("do something");<br/>    },<br/>    [username]<br/>  );</span><span id="4e7e" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    return () =&gt; {<br/>      console.log("cleaned up");<br/>    };<br/>  }, []);</span><span id="f23a" class="mq lc iq mh b gy mv ms l mt mu">  const handleName = e =&gt; {<br/>    const { value } = e.target;<br/>    setName(value);<br/>  };</span><span id="dd83" class="mq lc iq mh b gy mv ms l mt mu">  const handleUsername = e =&gt; {<br/>    const { value } = e.target;<br/>    setUsername(value);<br/>  };</span><span id="dd6e" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;<br/>        &lt;input value={name} onChange={handleName} /&gt;<br/>        &lt;input value={username} onChange={handleUsername} /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="8e34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有自己的变更事件处理程序。</p><p id="78a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有我们的<code class="fe me mf mg mh b">useEffect</code>电话。</p><p id="716e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">都有自己的试镜。</p><p id="aa25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个观察<code class="fe me mf mg mh b">username</code>功能的变化。</p><p id="d74f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二个例子中，回调函数返回一个在组件卸载时运行代码的函数。</p><h1 id="d897" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Redux操作后反应路由器重定向</h1><p id="fd58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在Redux操作提交后重定向。</p><p id="733b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们安装了<code class="fe me mf mg mh b">history</code>包。</p><p id="b372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2035" class="mq lc iq mh b gy mr ms l mt mu">npm install --save history</span></pre><p id="6065" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以创建一个函数，比如:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c45f" class="mq lc iq mh b gy mr ms l mt mu">import { createBrowserHistory } from 'history';</span><span id="632c" class="mq lc iq mh b gy mv ms l mt mu">const browserHistory = createBrowserHistory();</span><span id="af09" class="mq lc iq mh b gy mv ms l mt mu">const actionName = () =&gt; (dispatch) =&gt; {<br/>  axios<br/>    .post('url', { body })<br/>    .then(response =&gt; {        <br/>       dispatch({<br/>         type: ACTION_TYPE_NAME,<br/>         payload: payload<br/>       });      <br/>       browserHistory.push('/foo');<br/>    })<br/>    .catch(err =&gt; {<br/>      // Process error code<br/>    });<br/>  });<br/>};</span></pre><p id="88aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向Axios发出POST请求。</p><p id="6d34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">then</code>回调中，我们调用<code class="fe me mf mg mh b">dispatch</code>来调度我们的动作。</p><p id="fa18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们呼叫<code class="fe me mf mg mh b">browserHistory.push</code>来导航。</p><p id="c8fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">createBrowserHistory</code>来获取<code class="fe me mf mg mh b">browserHistory</code>对象。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ddd3d2e9d06573e5ce7d9146e4b33883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2kC7fZ22ZDMpZ5nZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@smileprem?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Premkumar Masilamani</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8b82" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="baf0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">useEffect</code>钩子来更新我们的值。</p><p id="1bbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还可以用于在组件卸载时运行清理代码。</p><p id="8185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要在Redux动作完成后导航到另一条路线，我们可以在分派动作后使用<code class="fe me mf mg mh b">browserHistory.push</code>方法来完成。</p><p id="514b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>