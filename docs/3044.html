<html>
<head>
<title>How to implement JWT User Authentication in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中实现JWT用户认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-jwt-user-authentication-in-node-js-b6d093f6fa4?source=collection_archive---------3-----------------------#2020-08-23">https://javascript.plainenglish.io/how-to-implement-jwt-user-authentication-in-node-js-b6d093f6fa4?source=collection_archive---------3-----------------------#2020-08-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7233ea8c5f7b243620b2cd5606edcb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyWB11D2Eh3sgi4BdIQVbQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="c7f1" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">使用JWT实现用户认证的分步指南</h2></div><h2 id="b885" class="kn ko iy bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">先决条件</h2><p id="da14" class="pw-post-body-paragraph lj lk iy ll b lm ln jz lo lp lq kc lr kw ls lt lu la lv lw lx le ly lz ma mb ig bi translated">为了理解本文，您需要对express和node.js有一个基本的了解。</p><h2 id="493c" class="kn ko iy bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">JWT简介</h2><p id="a4ea" class="pw-post-body-paragraph lj lk iy ll b lm ln jz lo lp lq kc lr kw ls lt lu la lv lw lx le ly lz ma mb ig bi translated">JWT代表JSON网络令牌。这是一种紧凑而安全的传输JSON数据的方式。JWT很容易被验证，因为它是数字签名的。JWT可用于授权或交换信息。</p><p id="5a4a" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">在本文中，我们将使用JWT进行授权。</p><h2 id="a5cd" class="kn ko iy bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我们开始工作吧！</h2><p id="b3ff" class="pw-post-body-paragraph lj lk iy ll b lm ln jz lo lp lq kc lr kw ls lt lu la lv lw lx le ly lz ma mb ig bi translated">在主项目目录中打开终端，并编写以下命令:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="56d8" class="kn ko iy mm b gy mq mr l ms mt">npm init -y</span></pre><p id="3d6f" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">这里的<code class="fe mu mv mw mm b">-y</code>标志有助于将每个值设置为默认值。</p><p id="6bc1" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">现在让我们安装我们需要的软件包。为此，让我们在主项目目录的终端中编写以下命令:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b3a3" class="kn ko iy mm b gy mq mr l ms mt">npm i express jsonwebtoken express-validator mongoose bcrypt dotenv</span></pre><p id="80c4" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">随着上面的命令，我们安装了<code class="fe mu mv mw mm b">express</code>、<code class="fe mu mv mw mm b">jsonwebtoken</code>、<code class="fe mu mv mw mm b">express-validator</code>、<code class="fe mu mv mw mm b">mongoose</code>、<code class="fe mu mv mw mm b">bcrypt</code>、<code class="fe mu mv mw mm b">dotenv</code>。你显然知道<code class="fe mu mv mw mm b">express</code>是干什么的。这里，<code class="fe mu mv mw mm b">jsonwebtoken</code>用于生成和验证JWT。我们一会儿会用到它。<code class="fe mu mv mw mm b">express-validator</code>包将帮助我们验证数据。同样，<code class="fe mu mv mw mm b">dotenv</code>将帮助我们访问<strong class="ll iz">。env </strong>文件。</p><p id="8428" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">现在让我们创建一个名为<strong class="ll iz">的文件。env </strong>放在我们的主项目目录中，并在文件中写入以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="770c" class="kn ko iy mm b gy mq mr l ms mt">MONGO_URI=             // add mongo URI here<br/>SECRET=               // add secret here</span></pre><p id="e905" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated"><code class="fe mu mv mw mm b">MONGO_URI</code>应该包含MongoDB数据库的URL。<code class="fe mu mv mw mm b">SECRET</code>应该包含一些秘密值。<code class="fe mu mv mw mm b">SECRET</code>可以是任意一组随机的字符串。</p><p id="e563" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">输入值后，让我们在主项目目录中创建一个名为<strong class="ll iz"> index.js </strong>的文件，并编写以下代码行:</p><figure class="mh mi mj mk gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2000" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">在上面的代码中，前几行只是导入。在第1行，我们已经导入并配置了<code class="fe mu mv mw mm b">dotenv</code>。在第3行，我们导入了<code class="fe mu mv mw mm b">express</code>。然后，在第4行，我们导入了<code class="fe mu mv mw mm b">mongoose</code>。在第6行，我们导入了<code class="fe mu mv mw mm b">AuthRoute</code>。在第8行，我们初始化了express应用程序。然后，在第10行，我们使用了<code class="fe mu mv mw mm b">express.json()</code>中间件。这个中间件帮助我们识别从客户端接收的JSON数据。在第11行，我们为<em class="mz"> api/auth </em>创建了一个路由，并使用<code class="fe mu mv mw mm b">AuthRoute</code>作为该路由的路由器。在第13行，我们创建了一个名为<code class="fe mu mv mw mm b">PORT</code>的常量。<code class="fe mu mv mw mm b">PORT</code>存储环境变量<code class="fe mu mv mw mm b">PORT</code>的值，如果存在，则存储<code class="fe mu mv mw mm b">5000</code>。在第14行，我们在<code class="fe mu mv mw mm b">PORT</code>启动了我们的服务器。从第16行到第22行，我们连接到MongoDB数据库。在第17行，我们输入了<code class="fe mu mv mw mm b">MONGO_URI</code>的值来建立连接。连接完成后，我们<code class="fe mu mv mw mm b">console.log</code>它(在第21行)。如果出现任何错误，我们在第22行记录该错误。</p><p id="2a7d" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">现在让我们来研究路线。为此，让我们在主项目目录中创建一个名为<em class="mz"> routes </em>的目录。然后，在<em class="mz"> routes </em>目录下创建一个名为<strong class="ll iz"> Auth.js </strong>的文件。现在让我们打开文件<strong class="ll iz"> Auth.js </strong>，并在文件中写入以下代码行:</p><figure class="mh mi mj mk gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b623" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">前几行只是导入。在第1行，我们导入了<code class="fe mu mv mw mm b">express</code>。在第2行，我们从<code class="fe mu mv mw mm b">express-validator</code>导入了<code class="fe mu mv mw mm b">check</code>和<code class="fe mu mv mw mm b">validationResult</code>。在第4行，我们导入了<code class="fe mu mv mw mm b">login</code>、<code class="fe mu mv mw mm b">signup</code>和<code class="fe mu mv mw mm b">me</code>控制器。在第6行，我们创建了<code class="fe mu mv mw mm b">router</code>常量并将<code class="fe mu mv mw mm b">express.Router()</code>存储在其中。</p><p id="3abe" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第9行到第45行，我们创建了<em class="mz"> /api/auth/signup </em>路由。从11到43，我们在<code class="fe mu mv mw mm b">express-validator</code>的帮助下增加了验证。如果你对<code class="fe mu mv mw mm b">express-validator</code>没有基本的了解，你可能想看看我写的一篇文章:</p><div class="im in gp gr io na"><a href="https://medium.com/javascript-in-plain-english/getting-started-with-express-validator-fae0bbeeb0f9" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iz gy z fp nf fr fs ng fu fw ix bi translated">快速验证器入门</h2><div class="nh l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn iu na"/></div></div></a></div><p id="c3df" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">让我们快速浏览第9行到第45行。</p><p id="2287" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第12行到第15行，我们添加了对<code class="fe mu mv mw mm b">"name"</code>字段的验证，这样它的最小长度应该是3。我们还借助于<code class="fe mu mv mw mm b">.withMessage()</code>(在第14行)指定了验证错误消息应该是什么。然后我们修剪数据(在第15行)。</p><p id="5de3" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第17行到第20行，我们向<code class="fe mu mv mw mm b">"email"</code>字段添加了验证。我们检查了<code class="fe mu mv mw mm b">"email"</code>字段是否有实际的电子邮件地址。我们指定了验证错误消息应该是什么(在第19行)，然后我们序列化了电子邮件(在第20行)。</p><p id="f7ba" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第22行到第28行，我们添加了对<code class="fe mu mv mw mm b">"password"</code>字段的验证。我们已经指定密码的最小长度为8，最大长度为15。我们还指定密码字段应该至少有一个数字和一个特殊字符。我们还指定了验证错误消息应该是什么。</p><p id="c528" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">然后从第30行到第35行，我们在自定义验证的帮助下检查了<code class="fe mu mv mw mm b">"password"</code>和<code class="fe mu mv mw mm b">"confirmPassword"</code>是否匹配。</p><p id="8819" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">现在让我们看一下第37到43行。在第38行，我们将格式化的错误存储在<code class="fe mu mv mw mm b">error</code>常量中。然后，我们检查第40行是否存在<code class="fe mu mv mw mm b">error</code>。如果<code class="fe mu mv mw mm b">error </code>存在，我们发送错误数组和状态码422，否则我们运行<code class="fe mu mv mw mm b">next()</code>。之后，在第44行，我们定义了控制器应该是<code class="fe mu mv mw mm b">signup</code>。</p><p id="8dbb" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第48行到第66行，我们为<em class="mz"> /api/auth/login </em>创建了一个路由。从第50行到第64行，我们使用<code class="fe mu mv mw mm b">express-validator</code>添加了验证。让我们把这些台词讲得快一点。从第50行到第56行，我们添加了对<code class="fe mu mv mw mm b">"email"</code>和<code class="fe mu mv mw mm b">"password"</code>字段的验证。我们检查了<code class="fe mu mv mw mm b">"email"</code>字段是否有有效的电子邮件地址，并在第51行定义了验证错误消息。然后，从第53行到第55行，我们定义了<code class="fe mu mv mw mm b">"password"</code>字段的最小和最大长度以及验证错误消息。在第58行，我们格式化了错误并将其存储在<code class="fe mu mv mw mm b">error</code>变量中。然后，在第60行，我们检查了<code class="fe mu mv mw mm b">error</code>是否存在。如果<code class="fe mu mv mw mm b">error</code>存在，我们向用户发送一组错误消息和一个状态代码422(在第61行)。如果<code class="fe mu mv mw mm b">error</code>不存在，我们运行<code class="fe mu mv mw mm b">next()</code>。然后，我们在第65行指定了<code class="fe mu mv mw mm b">login</code>控制器。</p><p id="ba95" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">类似地，在第69行，我们为<em class="mz"> /api/auth/me </em>创建了一个路由，并指定了<code class="fe mu mv mw mm b">me</code>控制器。</p><p id="f6a2" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">最后，在第71行，我们导出了<code class="fe mu mv mw mm b">router</code>。</p><p id="bb2b" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">既然我们已经研究了路线，现在让我们研究模型。为此，让我们在主项目目录中创建一个名为<em class="mz"> models </em>的目录。然后，让我们在<em class="mz">模型</em>目录中创建一个名为<strong class="ll iz"> User.js </strong>的文件。现在，让我们在文件中编写以下代码行:</p><figure class="mh mi mj mk gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="717c" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">前几行是导入。在第1行，我们导入了<code class="fe mu mv mw mm b">mongoose</code>。在第2行，我们导入了<code class="fe mu mv mw mm b">bcrypt</code>。</p><p id="75be" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第4行到第8行，我们创建了<code class="fe mu mv mw mm b">UserSchema</code>。模式中有<code class="fe mu mv mw mm b">name</code>、<code class="fe mu mv mw mm b">email</code>和<code class="fe mu mv mw mm b">password</code>字段。它们都有<code class="fe mu mv mw mm b">String</code>的类型，并且是必需的。</p><p id="eded" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">在第10行，我们使用了<code class="fe mu mv mw mm b">pre</code>方法。这在保存用户模型之前运行。在第14行，我们检查用户模型中的<code class="fe mu mv mw mm b">"password"</code>字段是否被修改。如果<code class="fe mu mv mw mm b">"password"</code>字段没有被修改，我们运行<code class="fe mu mv mw mm b">next()</code>。如果它被修改，我们散列<code class="fe mu mv mw mm b">"password"</code>字段的数据并将其存储在<code class="fe mu mv mw mm b">hash</code>变量中(在第16行)。然后我们在第17行将<code class="fe mu mv mw mm b">hash</code>存储在<code class="fe mu mv mw mm b">user.password</code>中。之后，我们在第19行运行<code class="fe mu mv mw mm b">next()</code>。如果在这个过程中发生了一些错误，我们在第21行记录这个错误。然后，我们在第22行运行<code class="fe mu mv mw mm b">next(e)</code>。</p><p id="b933" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第26行到第36行，我们在<code class="fe mu mv mw mm b">UserSchema</code>中创建了<code class="fe mu mv mw mm b">comparePassword</code>方法。在第28行，我们比较了纯文本密码(<code class="fe mu mv mw mm b">password</code>)和散列密码(<code class="fe mu mv mw mm b">this.password</code>)并将其存储在<code class="fe mu mv mw mm b">result</code>变量中。然后我们在第30行返回了<code class="fe mu mv mw mm b">result</code>。如果在这个过程中出现任何错误，我们在第32行记录错误。然后我们在第34行返回<code class="fe mu mv mw mm b">false</code>。</p><p id="13cf" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">我们最终在第38行导出了<code class="fe mu mv mw mm b">"user"</code>模型。</p><p id="7a93" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">到目前为止，我们一直在研究模型。现在让我们来研究控制器。为此，让我们在主项目目录中创建一个名为<em class="mz">控制器</em>的目录。之后，让我们在<em class="mz">控制器</em>目录中创建一个名为<strong class="ll iz"> AuthController.js </strong>的文件。现在让我们打开文件<strong class="ll iz"> AuthController.js </strong>，并编写下面几行代码:</p><figure class="mh mi mj mk gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5d54" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">前几行是导入。在第1行，我们导入了<code class="fe mu mv mw mm b">jsonwebtoken</code>。然后，在第3行，我们导入了<code class="fe mu mv mw mm b">User</code>模型。</p><p id="a4c0" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第5行到第26行，我们创建了<code class="fe mu mv mw mm b">signup</code>控制器。在第6行，我们存储了来自<code class="fe mu mv mw mm b">req.body</code>的<code class="fe mu mv mw mm b">name</code>、<code class="fe mu mv mw mm b">email</code>和<code class="fe mu mv mw mm b">password</code>的值。在第9行，我们用<code class="fe mu mv mw mm b">email</code>过滤了<code class="fe mu mv mw mm b">User</code>。如果具有该电子邮件地址的用户已经存在，我们将向该用户发送状态代码422和一条错误消息(从第19行到第21行)。如果拥有这个<code class="fe mu mv mw mm b">email</code>的用户不存在，我们创建一个新的<code class="fe mu mv mw mm b">User</code>实例，并将其存储在第12行的<code class="fe mu mv mw mm b">newUser</code>变量中。之后，在第14行，我们保存了<code class="fe mu mv mw mm b">newUser</code>。保存<code class="fe mu mv mw mm b">newUser</code>后，我们向用户发送成功消息和状态代码200(在第16行)。如果在这个过程中出现任何错误，我们在第23行记录这个错误。然后，我们在第24行发送一个状态代码500和一个错误消息。</p><p id="9bd7" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第28行到第49行，我们创建了<code class="fe mu mv mw mm b">login</code>控制器。在第29行，我们存储了来自<code class="fe mu mv mw mm b">req.body</code>的<code class="fe mu mv mw mm b">email</code>和<code class="fe mu mv mw mm b">password</code>的值。在第32行，我们用<code class="fe mu mv mw mm b">email</code>查询了<code class="fe mu mv mw mm b">User</code>，并将其存储在<code class="fe mu mv mw mm b">user</code>变量中。如果<code class="fe mu mv mw mm b">user</code>不存在，我们向用户发送状态代码422和第34行的错误消息。如果<code class="fe mu mv mw mm b">user</code>存在，我们继续比较密码。在第36行，我们借助我们在<code class="fe mu mv mw mm b">User</code>模型中创建的<code class="fe mu mv mw mm b">comparePassword</code>方法检查密码是否匹配。如果<code class="fe mu mv mw mm b">password</code>不匹配，我们向用户发送状态代码403和第44行的错误消息。如果<code class="fe mu mv mw mm b">password</code>匹配，我们在第37行使用<code class="fe mu mv mw mm b">jwt.sign</code>创建JSON Web令牌，并将其存储在<code class="fe mu mv mw mm b">token</code>常量中。<code class="fe mu mv mw mm b">jwt.sign</code>接受三个参数。第一个参数接受一个对象。这个对象必须包含一些关于<code class="fe mu mv mw mm b">user</code>的独一无二的东西，这样我们才能识别这个令牌属于谁。在我们的例子中，我们有一个对象<code class="fe mu mv mw mm b">{id: user._id}</code>作为第一个参数。类似地，第二个参数接受一个密钥。在我们的例子中，我们使用了<code class="fe mu mv mw mm b">process.env.SECRET</code>。记得我们之前已经创建了这个<code class="fe mu mv mw mm b">SECRET</code>变量。第三个参数接受options对象。在我们的例子中，我们使用了<code class="fe mu mv mw mm b">expiresIn</code>选项，并将其设置为<code class="fe mu mv mw mm b">"24h"</code>。它的作用是，指定<code class="fe mu mv mw mm b">jwt</code>这个令牌只在24小时内有效。这意味着，用户在登录24小时后会自动注销。之后，我们编写了代码，在第41行向用户发送状态代码200、成功消息和令牌。如果在这个过程中出现任何错误，我们在第46行记录这个错误。然后，我们编写了代码，在第47行向用户发送状态代码500和一条错误消息。</p><p id="0ed8" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">从第51行到第68行，我们创建了一个<code class="fe mu mv mw mm b">me</code>控制器。该控制器有助于获取登录用户的一些信息。让我们仔细看看。在第52行，我们存储了来自<code class="fe mu mv mw mm b">"X-Auth"</code>头的令牌，并将其存储在<code class="fe mu mv mw mm b">token</code>变量中。这个头应该不一定是<code class="fe mu mv mw mm b">"X-Auth"</code>。您也可以选择其他标题进行授权。但是您必须足够小心，以免覆盖其他标题。对此还有其他几种方法。如何处理就看你自己了。但在我们的情况下，我们会坚持这一点，好吗？</p><p id="2dfe" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">如果令牌不存在，我们在第56行向用户发送状态代码403和错误消息。在第58行，我们解码了JWT并将其存储在<code class="fe mu mv mw mm b">decoded</code>变量中。为了解码，我们使用了<code class="fe mu mv mw mm b">jwt.verify</code>。这个<code class="fe mu mv mw mm b">verify</code>方法接受两个参数。第一个参数应该是<code class="fe mu mv mw mm b">token</code>，第二个参数应该是密钥。在我们的例子中，密钥是<code class="fe mu mv mw mm b">process.env.SECRET</code>。</p><p id="e18c" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">解码令牌后，我们通过id查询<code class="fe mu mv mw mm b">User</code>，并将其存储在<code class="fe mu mv mw mm b">user</code>变量的第60行。在通过id进行查询时，我们使用了<code class="fe mu mv mw mm b">decoded.id</code>。这里的<code class="fe mu mv mw mm b">decoded</code>包含一个对象。该对象与我们签名时使用的对象相同。在给JWT签名时，在第37行，我们有一个对象作为<code class="fe mu mv mw mm b">jwt.sign</code>方法的第一个参数。该对象与我们在<code class="fe mu mv mw mm b">decoded</code>变量中的对象相同。</p><p id="935d" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">在查询了<code class="fe mu mv mw mm b">User</code>之后，我们检查了<code class="fe mu mv mw mm b">user</code>是否存在。如果<code class="fe mu mv mw mm b">user</code>不存在，我们在第62行发送状态代码403和错误消息。如果<code class="fe mu mv mw mm b">user</code>存在，我们在第64行发送<code class="fe mu mv mw mm b">user</code>和状态码200以及用户信息。</p><p id="7463" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">如果在这个过程中出现任何错误，我们在第66行记录这个错误。然后，我们在第67行发送一个状态代码为500的错误消息。</p><p id="b67d" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">然后，我们最终导出了<code class="fe mu mv mw mm b">login</code>、<code class="fe mu mv mw mm b">signup</code>和<code class="fe mu mv mw mm b">me</code>函数(从第71行到第75行)。</p><p id="55fc" class="pw-post-body-paragraph lj lk iy ll b lm mc jz lo lp md kc lr kw me lt lu la mf lw lx le mg lz ma mb ig bi translated">这意味着，我们已经使用JWT完成了认证过程。你可能想用postman试试这个。</p><h2 id="3155" class="kn ko iy bd kp kq kr dn ks kt ku dp kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="43ee" class="pw-post-body-paragraph lj lk iy ll b lm ln jz lo lp lq kc lr kw ls lt lu la lv lw lx le ly lz ma mb ig bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae no" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll iz">寻找一切的链接plainenglish.io </strong> </a>！</p></div></div>    
</body>
</html>