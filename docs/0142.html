<html>
<head>
<title>Introduction to React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-react-hooks-e0102c038bf1?source=collection_archive---------0-----------------------#2019-05-07">https://javascript.plainenglish.io/introduction-to-react-hooks-e0102c038bf1?source=collection_archive---------0-----------------------#2019-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f16" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在React中使用状态挂钩</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/982739a7a2450d5e9b5e3c77190d0541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcRFxuCdENmqhgVKwYMmsQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/photos/dC6Pb2JdAqs" rel="noopener ugc nofollow" target="_blank">Fabian Grohs </a>on <a class="ae kv" href="https://unsplash.com/photos/dC6Pb2JdAqs" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="03c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/channel/UCo-h1M-5M6Y5D4Lgut8ge4w" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">techno funnel</strong></a><strong class="ky ir"/>带来了另一篇关于<strong class="ky ir"> React钩子</strong>的文章，这是React在16.8.0版本中的最新加入，许多React开发者对这一加入感到兴奋。在这篇文章中，我们将讨论<strong class="ky ir"> React状态钩子</strong>，它使用户能够创建没有类的状态变量。React中有多个钩子可用，但本文主要关注<code class="fe ls lt lu lv b">useState</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/afb1ba469fc923978f6afe9bb4b86d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nVUi8poCDxpp1CUX8aRSg.png"/></div></div></figure><p id="61c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在发布<strong class="ky ir">钩子</strong>之前，根据组件是基于类还是基于函数，React组件被分为两大类。</p><p id="d787" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类组件能够定义状态属性和生命周期方法，但是功能组件不能使用状态或访问React生命周期。两个组件都将<code class="fe ls lt lu lv b">props</code>作为输入参数，其中包含从父组件传播的数据。由于功能组件不创建自己的状态属性，它们依赖于父组件的输入数据，这使它们成为“无状态组件”</p><ol class=""><li id="0d61" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">有状态组件(使用类创建)。</li><li id="8b4e" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">无状态组件(使用函数创建)。</li></ol><p id="01b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关挂钩的快速教程，请参考以下视频教程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.youtube.com/watch?v=383oe-B-QGA" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=383oe-B-QGA</a></figcaption></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="a6e9" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">有状态组件</h1><p id="cc14" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">让我们来看一个使用类的<strong class="ky ir">有状态组件</strong>的简单实现。在下面给出的例子中，我们正在创建一个简单的组件，并使用<code class="fe ls lt lu lv b">this.state</code>为其添加一些状态属性。</p><p id="9b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该组件定义了以下状态属性(“姓名”、“年龄”和“职务”)，这些细节作为组件UI的一部分呈现。代码还为我们提供了使用<code class="fe ls lt lu lv b">this.setState</code>更新状态变量的能力。状态更新可用于整个组件和子组件。传递给子组件的状态被接收为<code class="fe ls lt lu lv b">props</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mm l"/></div></figure><p id="449f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码创建了一个包含三个状态变量的有状态组件:<code class="fe ls lt lu lv b">name</code>、<code class="fe ls lt lu lv b">age</code>和<code class="fe ls lt lu lv b">designation</code>。它还包含一个将state属性递增1的函数。由于状态变量已经被修改，显示<code class="fe ls lt lu lv b">age</code>属性的组件将在组件中更新，并触发UI的相应变化。</p><div class="ns nt gp gr nu nv"><a href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">状态和生命周期-反应</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">本页介绍了React组件中状态和生命周期的概念。你可以找到详细的组件API…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">reactjs.org</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="545d" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">使用无状态组件</h1><p id="25c8" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">创建组件的另一种方法是将其创建为无状态组件。这些简单的组件将<code class="fe ls lt lu lv b">props</code>作为它们的输入参数，并像我们之前所做的那样在UI中显示它们。无状态组件不能定义自己的状态变量，也不能更新收到的任何props <strong class="ky ir"> </strong>值。任何更新属性的尝试都将导致错误。下面是一个简单的无状态组件的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mm l"/></div></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="de68" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">使用React挂钩</h1><h2 id="bfdf" class="ok mv iq bd mw ol om dn na on oo dp ne lf op oq ng lj or os ni ln ot ou nk ov bi translated"><em class="ow">使用函数创建有状态组件</em></h2><p id="a7ea" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">既然我们已经看到了在React的最新版本之前组件是如何创建的，那么让我们看看如何使用状态钩子来创建它们。</p><p id="d2c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着<strong class="ky ir">钩子</strong>的引入，我们可以在不使用类的情况下创建有状态组件。我们可以使用函数来创建有状态的组件。因为我们在函数内部定义状态，所以我们将这些组件称为“<strong class="ky ir">有状态的</strong> <strong class="ky ir">函数组件。</strong>“我们可以使用<code class="fe ls lt lu lv b">useState</code>钩子来管理功能组件内部的状态属性。</p><p id="79c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看使用钩子的相同代码是什么样子的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mm l"/></div></figure><p id="ac2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码使用钩子来创建一个有状态的组件。我们使用关键字<code class="fe ls lt lu lv b">useState</code>来定义组件的状态。<code class="fe ls lt lu lv b">useState</code>将一个参数作为输入，定义状态变量的初始值。</p><p id="3d03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用带参数的<code class="fe ls lt lu lv b">useState</code>函数时，它执行以下操作:</p><ol class=""><li id="67a0" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">创建一个名为“name”的新状态变量</li><li id="7754" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">将默认值指定为参数中传递的值。</li><li id="52ae" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">返回新创建的状态属性以及“setter”函数。</li></ol><p id="c372" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们分析下面这段代码来理解<code class="fe ls lt lu lv b">useState</code>钩子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mm l"/></div></figure><p id="d6e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用一个默认参数调用<code class="fe ls lt lu lv b">useState</code>函数，该参数是一个名为“Mayank”的字符串。该函数创建一个新的状态属性，并为其分配一个默认值。此函数返回包含以下元素的数组:</p><ol class=""><li id="8fe6" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">第一个元素是新创建的“state”值。</li><li id="6305" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">第二个元素是同一属性的“setter函数”。</li></ol><p id="1dc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们使用析构并将第一个索引处的元素赋给变量<code class="fe ls lt lu lv b">name</code>，setter被赋给变量<code class="fe ls lt lu lv b">setName</code>。现在，这个name属性充当状态变量(<code class="fe ls lt lu lv b">this.state.name</code>)，而<code class="fe ls lt lu lv b">setName</code>是属性设置器——它更新类似于我们在类组件(<code class="fe ls lt lu lv b">this.setState</code>)中使用的值。用更新后的值作为参数调用<code class="fe ls lt lu lv b">setName</code>会将该值更新为状态属性<code class="fe ls lt lu lv b">name</code>。</p><p id="8f07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码相当于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mm l"/></div></figure><p id="8008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用有状态功能组件的一个优点是，您不再需要以下面的方式访问状态属性:<code class="fe ls lt lu lv b">{this.state.name}</code> <strong class="ky ir">。</strong>为了访问功能组件中的状态属性，我们只需要引用<code class="fe ls lt lu lv b">{name}</code>状态变量<strong class="ky ir">。</strong></p><p id="bd4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">功能组件提供了一个巨大的优势，因为我们可以摆脱复杂的类逻辑，并且我们也不需要担心在组件的任何地方添加<code class="fe ls lt lu lv b">this</code>关键字。功能组件基于闭包的概念。</p><p id="f95b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它使应用程序保持一致。您不需要使用函数定义一半的组件，而将另一半的组件定义为类。使用钩子，所有的组件都可以用“函数”的形式来表示因此，这是向函数式编程和提供跨应用程序一致性迈出的一大步。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="3960" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">使用钩子的更多好处</h1><h2 id="f276" class="ok mv iq bd mw ol om dn na on oo dp ne lf op oq ng lj or os ni ln ot ou nk ov bi translated">1.类是复杂的</h2><p id="2aed" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">班级很难处理和管理。类通常没有被很好地缩小，并且它们也使得热重载难以处理。钩子包含了函数式编程并提供了简单性。我们不需要拥有类型为<code class="fe ls lt lu lv b">class</code>的组件和类型为<code class="fe ls lt lu lv b">function</code>的其他组件。</p><p id="06cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它提供了整个反应组件的一致性。</p><h2 id="83eb" class="ok mv iq bd mw ol om dn na on oo dp ne lf op oq ng lj or os ni ln ot ou nk ov bi translated">2.随着时间的推移，类组件变得难以理解</h2><p id="29df" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">随着应用程序的增长，我们向类组件中添加了大量代码，这导致了复杂性。这使得分解成相关的功能变得困难。</p><p id="1c00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此<strong class="ky ir">类组件的规模和复杂性不断增长</strong>。</p><p id="d1d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关这方面的更多详细信息，请参考React的官方网站:</p><div class="ns nt gp gr nu nv"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">介绍钩子-反应</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">reactjs.org</p></div></div><div class="oe l"><div class="ox l og oh oi oe oj kp nv"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oy mm l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">React’s “useState” Hooks</figcaption></figure><p id="682d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">作者其他文章:</strong></p><div class="ns nt gp gr nu nv"><a href="https://levelup.gitconnected.com/introduction-to-reacts-higher-order-components-hocs-c42182fb634" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">React高阶组件(hoc)介绍</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">简单地说，高阶函数是要么接受一个函数作为参数，要么返回一个新的…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="oz l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://levelup.gitconnected.com/introduction-to-rxjs-3f17e1009527" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">RxJS和反应式编程简介</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">反应式编程是JavaScript世界的新热点。在本文中，我们将讨论基础知识…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="pa l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://levelup.gitconnected.com/creating-custom-observable-with-rxjs-379692f08f76" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">RxJS自定义可观察对象介绍</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在我之前的文章中，我们谈到了RxJS的基础知识。本库给出了许多创建可观察对象的方法。在这个…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="pb l og oh oi oe oj kp nv"/></div></div></a></div><p id="20b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pc">更多内容尽在</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="pc">plain English . io</em></a></p></div></div>    
</body>
</html>