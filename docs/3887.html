<html>
<head>
<title>Best of Modern JavaScript — Typed Array Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最好的现代JavaScript类型数组方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-typed-array-methods-6624cd1b9599?source=collection_archive---------8-----------------------#2020-10-31">https://javascript.plainenglish.io/best-of-modern-javascript-typed-array-methods-6624cd1b9599?source=collection_archive---------8-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b96b79cc3066a707f1cd8005eccdaaaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0bnWFLPmOFRl9VxD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@isiparente?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Isi Parente</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8df9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript类型化数组方法。</p><h1 id="ca9b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">静态方法</h1><p id="bede" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">静态方法让我们将类似数组或可迭代的对象转换成类型化数组。</p><p id="7ecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是我们要转换成类型化数组的iterable对象。</p><p id="2f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是回调函数，它将条目的值和索引作为数组的参数，让我们返回我们想要的东西。</p><p id="b2e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个参数是我们希望在第二个参数的回调中使用的<code class="fe me mf mg mh b">this</code>的值。</p><p id="4555" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个和第三个参数是可选的。</p><p id="2a42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6459" class="mq lc iq mh b gy mr ms l mt mu">const typedArr = Uint16Array.from([0, 1, 2]);</span></pre><p id="6ead" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入数组值并返回一个包含数组中条目的<code class="fe me mf mg mh b">Uint16Array</code>。</p><p id="3b7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">映射条目的回调让我们创建一个不会溢出的新数组，而不是让它们溢出。</p><p id="d074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="27e2" class="mq lc iq mh b gy mr ms l mt mu">const arr = Int8Array.of(200, 201, 202).map(x =&gt; 2 * x)</span></pre><p id="9432" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并得到值为<code class="fe me mf mg mh b">[-112, -110, -108]</code>的<code class="fe me mf mg mh b">Int8Array</code>。<br/>我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a473" class="mq lc iq mh b gy mr ms l mt mu">const arr = Int32Array.from(Int8Array.of(120, 121, 122), x =&gt; x * 2)</span></pre><p id="9278" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在一个<code class="fe me mf mg mh b">Int32Array</code>中得到<code class="fe me mf mg mh b">[240, 242, 244]</code>。</p><h1 id="3c57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实例属性</h1><p id="7437" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组包含许多实例属性。</p><p id="5d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性是一个getter，它返回存储类型化数组数据的缓冲区。</p><p id="525a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">byteLength</code>属性是一个以字节为单位返回类型化数组缓冲区大小的数字。</p><p id="6656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">byteOffset</code>返回ArrayByffr中类型化数组开始的偏移量。</p><p id="3f52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">set</code>将数组或类型化数组的所有元素复制到给定的类型化数组中。</p><p id="c36b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是一个普通数组，那么所有的元素都被转换成数字。</p><p id="21b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果参数是类型化数组，则每个元素都被转换为适合类型化数组的类型。</p><p id="49ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">subarray</code>返回一个新的类型化数组，该数组与调用它的类型化数组具有相同的缓冲区。</p><p id="349c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将起始索引作为第一个参数。该值的默认值为0。</p><p id="113d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">end索引是它的第二个参数。这个的默认值是数组的<code class="fe me mf mg mh b">length</code>。</p><p id="f24c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些值可以是负数。</p><h1 id="4a63" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组方法</h1><p id="6c4c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组可以使用<code class="fe me mf mg mh b">copyWithin</code>、<code class="fe me mf mg mh b">entries</code>、<code class="fe me mf mg mh b">every</code>、<code class="fe me mf mg mh b">fill</code>、<code class="fe me mf mg mh b">find</code>、<code class="fe me mf mg mh b">findIndex</code>、<code class="fe me mf mg mh b">forEach</code>、<code class="fe me mf mg mh b">indexOf</code>、<code class="fe me mf mg mh b">join</code>、<code class="fe me mf mg mh b">keys</code>、<code class="fe me mf mg mh b">lastIndexOf</code>、<code class="fe me mf mg mh b">length</code>、<code class="fe me mf mg mh b">map</code>、<code class="fe me mf mg mh b">reduce</code>、<code class="fe me mf mg mh b">reduceRight</code>、<code class="fe me mf mg mh b">reverse</code>、<code class="fe me mf mg mh b">slice</code>、<code class="fe me mf mg mh b">some</code>、<code class="fe me mf mg mh b">sort</code>、<code class="fe me mf mg mh b">toLocaleString</code>、<code class="fe me mf mg mh b">toString</code>、<code class="fe me mf mg mh b">values</code>等数组方法。</p><p id="86b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们与常规数组方法采用相同的参数并具有相同的返回值。</p><h1 id="7334" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造器</h1><p id="7461" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组构造函数包括<code class="fe me mf mg mh b">Int8Array</code>、<code class="fe me mf mg mh b">Uint8Array</code>、<code class="fe me mf mg mh b">Uint8ClampedArray</code>、<code class="fe me mf mg mh b">Int16Array</code>、<code class="fe me mf mg mh b">Uint16Array</code>、<code class="fe me mf mg mh b">Int32Array</code>、<code class="fe me mf mg mh b">Uint32Array</code>、<code class="fe me mf mg mh b">Float32Array</code>、<code class="fe me mf mg mh b">Float64Array</code>。</p><p id="2d6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们可以有签名<code class="fe me mf mg mh b">(buffer, byteOffset=0, length?)</code>、<code class="fe me mf mg mh b">(length)</code>、<code class="fe me mf mg mh b">(typedArray)</code>、<code class="fe me mf mg mh b">(arrayLikeObject)</code>或<code class="fe me mf mg mh b">()</code>。</p><p id="77ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">buffer</code>是类型化数组的缓冲区。</p><p id="0091" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ByteOffset</code>是从索引0开始的偏移量。</p><p id="f6d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">length</code>是类型化数组的长度。</p><p id="c68d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">typedArray</code>是另一个类型化数组。</p><p id="c0a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">arrayLikeObject</code>是类数组或可迭代对象。</p><p id="1b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似数组的对象是具有<code class="fe me mf mg mh b">length</code>属性和整数键的对象。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/633954b2c41c48a949f2dfaf6d9b2767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oyKMT24JRGdfjcVU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bamin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pierre Bamin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="aee3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9deb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组有许多数组方法。</p><p id="7886" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该构造函数不同于常规的<code class="fe me mf mg mh b">Array</code>构造函数。</p><p id="fbf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>