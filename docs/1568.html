<html>
<head>
<title>Linear Search Algorithm 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性搜索算法101</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/linear-search-algorithms-101-38eb2a0e8240?source=collection_archive---------10-----------------------#2020-04-01">https://javascript.plainenglish.io/linear-search-algorithms-101-38eb2a0e8240?source=collection_archive---------10-----------------------#2020-04-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c404" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">掌握线性搜索算法以及如何用JavaScript实现</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e26fa152050db46c1932161f301249a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y2QCBGTvelfaE2I_"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@dariusbashar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Darius Bashar</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9175" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">被恐吓？害怕吗？不要害怕，基础并不像有些人想象的那么差。根据我的经验，文章和在线指南对于初级开发人员来说有点太快，难以消化，并且包含了许多不像一些高级开发人员认为的那样常见的假设。</p><p id="1648" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="lp">所以我们先从基础说起。</em>T3】</strong></p><p id="58dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">这是给谁的？</strong>本文旨在帮助初级开发人员牢固掌握线性搜索算法以及如何用JavaScript实现。如果您不是JS开发人员，不要担心，语法非常容易理解，我将详细地指导您完成每个步骤。</p><p id="8c0f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">什么是算法？</strong>好问题，算法是帮助解决问题或完成任务的非常具体的指令或步骤的列表。重要的是要明白，算法是一个相当严格的概念，没有解释或主观性的空间。<strong class="kv io">每次我给一个算法输入一个特定的输入，我都能确定它会产生完全相同的结果。这实际上是一个算法的全部要点:获取一个输入值，通过一系列编程步骤运行它，并产生一个始终可重复的最终结果。</strong></p><p id="c480" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">作为一名开发人员，你将很快学会爱上算法和它们给你的代码带来的效率。任何人都不愿意花4个小时<strong class="kv io"> <em class="lp">手动</em> </strong>在数据库中查找一条信息。随着算法的力量在你的指尖，你不会有！</p><p id="4c9e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有一个逐步的例子来进一步说明这一点。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="5095" class="lv lw in lr b gy lx ly l lz ma">1. You need to find out whether a data set includes a specific value.</span><span id="fe79" class="lv lw in lr b gy mb ly l lz ma">*If the data set only included 10 elements it wouldn't be a big deal. You could do that manually in a few seconds. But if the data set grew to 100,000 elements that would take a lot longer. Regardless of size, an algorithm is going help you find that value in some data set way faster.</span><span id="2534" class="lv lw in lr b gy mb ly l lz ma">2. Give your algorithm an input (the value you want find).</span><span id="c104" class="lv lw in lr b gy mb ly l lz ma">3. The algorithm will check the data set, step by step, to see if it has the input value you asked for.</span><span id="4434" class="lv lw in lr b gy mb ly l lz ma">4. After running through the data set, it will return true or false letting you know if the value exists in the data set.</span></pre></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><p id="d72b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太好了，我们对什么是算法以及它们要做什么有了更高层次的理解。<strong class="kv io"> <em class="lp">现在…什么是线性搜索算法，我们如何构建？</em> </strong></p><p id="d1c3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">线性搜索算法</strong>是一组指令，它遍历/移动一个数据集，并检查集合中的每个元素，直到它找到您要求的任何值，或者直到整个数据集都被搜索完。</p><p id="b75c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">再一次，让我们看一个<em class="lp">演练</em>来真正挖掘这个概念。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="f33d" class="lv lw in lr b gy lx ly l lz ma">[1, 2, 3, 4, 5] &lt;-- an array in JavaScript (our data set)</span><span id="1d6d" class="lv lw in lr b gy mb ly l lz ma">We need to create an algorithm that checks each element in the array. In most coding languages there are simple ways of checking or comparing the value of two elements. These conditional lines of code are executed every time the algorithm moves to a new element in the array.</span><span id="18b4" class="lv lw in lr b gy mb ly l lz ma">Example of a conditional:</span><span id="4db7" class="lv lw in lr b gy mb ly l lz ma">if (element === 4) { <br/>  // do something!<br/>}</span><span id="4aea" class="lv lw in lr b gy mb ly l lz ma">*Remember array's start at index 0.  </span><span id="965f" class="lv lw in lr b gy mb ly l lz ma">1) Check element at index 0 (the number 1)<br/>2) Check element at index 1 (the number 2)<br/>3) Check element at index 2 (the number 3)</span><span id="0b84" class="lv lw in lr b gy mb ly l lz ma">... moving all the way through the array until we find the number we are looking for OR we just keep moving to the end of the array</span></pre></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="7edf" class="mj lw in bd mk ml mm mn mo mp mq mr ms jt mt ju mu jw mv jx mw jz mx ka my mz bi translated">履行</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/4ea1434a6b381338d03ee65aa649bc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fXMczjSPUobDZkHr"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@lidyanada?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lidya Nada</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5678" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">干得好，跟着我！接下来，我们将看看这个算法在JavaScript中的具体实现。</p><p id="ce8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如您可能已经猜到的，这不是一个理解或实现起来过于复杂的算法。事实上，很有可能你已经在一个项目中实现了它，甚至不知道。</p><p id="c534" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将介绍在一个值数组中移动的三种方式，并向您展示如何用每种方式实现这个算法:</p><ul class=""><li id="1dc6" class="nb nc in kv b kw kx kz la lc nd lg ne lk nf lo ng nh ni nj bi translated"><strong class="kv io">循环</strong></li><li id="8317" class="nb nc in kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated"><strong class="kv io">方法</strong></li><li id="1f24" class="nb nc in kv b kw nk kz nl lc nm lg nn lk no lo ng nh ni nj bi translated"><strong class="kv io">递归</strong></li></ul><p id="b14a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请记住，这个列表并不详尽，强烈建议您尝试下面没有讨论的各种模式和技术。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="19c7" class="mj lw in bd mk ml mm mn mo mp mq mr ms jt mt ju mu jw mv jx mw jz mx ka my mz bi translated"><strong class="ak">循环</strong></h1><p id="aab2" class="pw-post-body-paragraph kt ku in kv b kw np jo ky kz nq jr lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated"><strong class="kv io">老派的回环</strong></p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="8d01" class="lv lw in lr b gy lx ly l lz ma">const array = [1, 2, 3, 4, 5];</span><span id="6880" class="lv lw in lr b gy mb ly l lz ma">for (let i = 0; i &lt; array.length; i++) { <br/>  // some code...<br/>};</span><span id="63e4" class="lv lw in lr b gy mb ly l lz ma">A straight forward way of iterating though an array that every JS developer must know.</span><span id="a23a" class="lv lw in lr b gy mb ly l lz ma">const OldForLoop = (arr, target) =&gt; {<br/>  for (let i = 0; i &lt; arr.length; i++) {<br/>    if (arr[i] === target) {<br/>      return true;<br/>    }<br/>  }<br/>  return false;<br/>};</span></pre><p id="84f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">While循环</strong></p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="4def" class="lv lw in lr b gy lx ly l lz ma">const array = [1, 2, 3, 4, 5];</span><span id="e523" class="lv lw in lr b gy mb ly l lz ma">while (count &lt; array.length) { <br/>  // some code...<br/>};</span><span id="7f17" class="lv lw in lr b gy mb ly l lz ma">A common alternative to the old school for loop that achieves the same thing.</span><span id="1274" class="lv lw in lr b gy mb ly l lz ma">const WhileLoop = (arr, target) =&gt; {<br/>  let count = 0;<br/>  while (count &lt; arr.length) {<br/>    if (arr[count] === target) {<br/>      return true;<br/>    }<br/>    count++;<br/>  }<br/>  return false<br/>};</span></pre><p id="36ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">循环的形成</strong></p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="e2bb" class="lv lw in lr b gy lx ly l lz ma">const array = [1, 2, 3, 4, 5];</span><span id="b083" class="lv lw in lr b gy mb ly l lz ma">for (let element of array) { <br/>  // some code...<br/>};</span><span id="ca4e" class="lv lw in lr b gy mb ly l lz ma">A newer for loop that was introduced with ES6. Simple, clean and easy to read.</span><span id="7805" class="lv lw in lr b gy mb ly l lz ma">const ForOfLoop = (arr, target) =&gt; {<br/>  for (let element of arr) {<br/>    if (element === target) {<br/>      return true;<br/>    }<br/>  }<br/>  return false;<br/>};</span></pre><h1 id="ad75" class="mj lw in bd mk ml nu mn mo mp nv mr ms jt nw ju mu jw nx jx mw jz ny ka my mz bi translated"><strong class="ak">方法</strong></h1><p id="c602" class="pw-post-body-paragraph kt ku in kv b kw np jo ky kz nq jr lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated"><strong class="kv io">。forEach() </strong></p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="f1be" class="lv lw in lr b gy lx ly l lz ma">const array = [1, 2, 3, 4, 5];</span><span id="1519" class="lv lw in lr b gy mb ly l lz ma">array.forEach(element =&gt; { <br/>  // some code...<br/>};</span><span id="b1ed" class="lv lw in lr b gy mb ly l lz ma">A built in method that is easy to use, versatile and quick to write.</span><span id="1d7d" class="lv lw in lr b gy mb ly l lz ma">const forEachMethod = (arr, target) =&gt; {<br/>  let result = false;<br/>  arr.forEach(element =&gt; {<br/>    if (element === target) {<br/>      result = true;<br/>    }<br/>  }); <br/>  return result;<br/>};</span></pre><h1 id="d83f" class="mj lw in bd mk ml nu mn mo mp nv mr ms jt nw ju mu jw nx jx mw jz ny ka my mz bi translated">递归</h1><p id="4f4c" class="pw-post-body-paragraph kt ku in kv b kw np jo ky kz nq jr lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated"><strong class="kv io">递归函数</strong></p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="9aa6" class="lv lw in lr b gy lx ly l lz ma">const array = [1, 2, 3, 4, 5];</span><span id="630f" class="lv lw in lr b gy mb ly l lz ma">const recursiveFun () =&gt; { <br/>  // some code... <br/>  recursiveFun(); // the function is called again<br/>};</span><span id="ce5a" class="lv lw in lr b gy mb ly l lz ma">A useful technique that allows functions to call themselves in order to move through a data set.</span><span id="b6f1" class="lv lw in lr b gy mb ly l lz ma">const recursion = (arr, target, i = 0) =&gt; {<br/>  let len = arr.length - 1;<br/>  if (i &gt; len) { <br/>    return false<br/>  };<br/>  if (arr[i] === target) { <br/>    return true <br/>  };<br/>  recursion(arr, target, i + 1);<br/>};</span></pre></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><p id="145f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太棒了。我们做到了，我们用JavaScript实现了线性搜索算法。一个小问题。</p><blockquote class="nz oa ob"><p id="1412" class="kt ku lp kv b kw kx jo ky kz la jr lb oc ld le lf od lh li lj oe ll lm ln lo ig bi translated"><strong class="kv io">线性搜索算法相当慢……</strong></p></blockquote><p id="e987" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">抱歉，坏消息是他们不太好。事实上，许多面试官会期望你用更快、更高效的算法来解决技术测试。使用像线性搜索这样的强力 方法实际上可能会在技术性工作面试中对你不利。</p><p id="fdc1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它们被设计成从一端到另一端检查整个数据集(它们也可以反向运行)。这基本上意味着，对于足够大的数据集，线性搜索可能需要很长时间来执行。</p><blockquote class="nz oa ob"><p id="ccaa" class="kt ku lp kv b kw kx jo ky kz la jr lb oc ld le lf od lh li lj oe ll lm ln lo ig bi translated"><strong class="kv io">简单线性搜索算法的时间复杂度为O(n)。</strong></p></blockquote><p id="6dd2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不去探究关于大O符号或时间和空间复杂性的太多细节(<strong class="kv io"> <em class="lp">肯定是另一篇文章</em> </strong>的主题)，我们可以有把握地说，给线性搜索的输入越大，将直接增加算法完成所需的时间。</p><p id="3b95" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有一个简单的图表，可以帮助你在线性搜索算法中可视化时间和输入大小(或长度)之间的关系。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/2d412579747bafa6de7c8a597d46b74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yajAx27IwspJ3D5iNO3tg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">An Introduction to the Time Complexity of Algorithms (<a class="ae ks" href="https://www.freecodecamp.org/news/author/bw99214/" rel="noopener ugc nofollow" target="_blank">Aditya Dehal</a> @ freeCodeCamp)</figcaption></figure><p id="cd8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于时间复杂度的更多信息，请查看<a class="ae ks" href="https://www.freecodecamp.org/news/author/bw99214/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">【Aditya Dehal】</strong></a>关于<a class="ae ks" href="https://www.freecodecamp.org/news/time-complexity-of-algorithms/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">【FreeCodeCamp.com】</strong></a>的这篇 精彩文章。</p><blockquote class="nz oa ob"><p id="e4ea" class="kt ku lp kv b kw kx jo ky kz la jr lb oc ld le lf od lh li lj oe ll lm ln lo ig bi translated">你可能想知道为什么我给你展示了线性搜索算法的五个实现，如果它们都有相同的(慢的)时间复杂度？</p></blockquote><p id="0444" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事实是，有时候你不得不用蛮力的方法来完成事情。也许你正在开发一个新的应用程序原型，需要快速完成一些事情，或者你确信你正在使用的数据集不会变得很大。<strong class="kv io"> <em class="lp">无论是哪种情况，总有另一种方法可以提高应用程序的效率和速度。</em>T45】</strong></p><p id="c777" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是为什么使用不同的实现会有很大的不同。要查看每个实现的执行时间的完整示例，请点击这里查看我的Github Repo:<a class="ae ks" href="https://github.com/twjsanderson/linearSearchPerformance" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">linearSearchPerformance</strong></a>。</p><p id="bca1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我编写了一个简单的Node.js应用程序，它将帮助Junior处理不同代码实现的时间性能。</p><p id="9d21" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是线性搜索算法和JavaScript实现的全部内容。感谢阅读！</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><p id="bdcb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于想要了解更多信息的人，这里有一些补充资源:</p><p id="53be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">亚当·霍瓦特关于搜索性能比较的优秀论文:</strong></p><p id="697f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://www.researchgate.net/publication/284494241_Two_way_Linear_Search_Algorithm" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/publication/284494241 _ Two _ way _ Linear _ Search _ Algorithm</a></p><p id="a730" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">时间和空间复杂度的伟大概述:</strong></p><div class="og oh gp gr oi oj"><a href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd io gy z fp oo fr fs op fu fw im bi translated">时间和空间复杂性教程&amp;笔记|基础编程|黑客地球</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">有时候，解决问题的方法不止一种。我们需要学习如何比较不同的性能…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">www.hackerearth.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox km oj"/></div></div></a></div><p id="7d37" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">Nitin Arora</strong><a class="ae ks" href="https://www.researchgate.net/profile/Nitin_Arora16" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">关于线性搜索算法的有趣论文</strong> </a> <strong class="kv io"> : </strong></p><p id="253b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://www.researchgate.net/publication/284494241_Two_way_Linear_Search_Algorithm" rel="noopener ugc nofollow" target="_blank">https://www . research gate . net/publication/284494241 _ Two _ way _ Linear _ Search _ Algorithm</a></p><h2 id="49e6" class="lv lw in bd mk oy oz dn mo pa pb dp ms lc pc pd mu lg pe pf mw lk pg ph my pi bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="eda3" class="pw-post-body-paragraph kt ku in kv b kw np jo ky kz nq jr lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ks" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kv io">AI in Plain English</strong></a>，<a class="ae ks" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kv io">UX in Plain English</strong></a>，<a class="ae ks" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kv io">Python in Plain English</strong></a><strong class="kv io"/>——谢谢，继续学习！</p><p id="2360" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ks" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">submissions @ plain English . io</strong></a><strong class="kv io"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>