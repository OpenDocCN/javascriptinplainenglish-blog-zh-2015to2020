<html>
<head>
<title>Binary Search Trees with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有JavaScript的二分搜索法树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-search-trees-with-javascript-715df954b33?source=collection_archive---------8-----------------------#2020-12-06">https://javascript.plainenglish.io/binary-search-trees-with-javascript-715df954b33?source=collection_archive---------8-----------------------#2020-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6f28" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用JavaScript的数据结构系列的第5部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b1667bc03cb54ded7525be9f248a0c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MScnHTcPzMz2HSX9"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@gillystewart?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gilly Stewart</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将介绍使用JavaScript的二分搜索法树。如果您错过了我们构建双链表并将其与单链表进行比较的系列文章的第4部分，请查看下面的文章。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/doubly-linked-lists-with-javascript-9c20a9dc4fb3" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">带有JavaScript的双链表</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">使用JavaScript的数据结构系列的第4部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="4d0c" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">树、二叉树和二分搜索法树</h1><p id="a2a8" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在我们深入研究二分搜索法树之前，让我们先了解一下树和二叉树。</p><p id="2327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">树是由具有父子关系的节点组成的数据结构。每个树只能有一个根节点(即最上面的节点)。每个节点可以有任意数量的子节点。但是请记住，每个节点只能有一个父节点(没有父节点的根节点除外)。在下图中，值为2的节点是我们的根节点。2岁，然后有两个孩子，7岁和5岁。7，然后有3个孩子，2，10，6等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/840549a6fec5b2e9ac332264b64dd5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gKTyb2Vzdik8_NF4xJ0Rw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Tree_(data_structure)</a></figcaption></figure><p id="0ff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二叉树是一种树，其中每个节点最多可以有两个子节点。在下图中，您可以看到每个节点都有0个、1个或2个子节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/337d4537e35d495229eb255123899a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpIrwWA3BkpS15051EI3zg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_tree</a></figcaption></figure><p id="644c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二分搜索法树是一种对数据进行排序的二叉树。这些可用于搜索或插入。二分搜索法树的规则是，对于每个父节点，左侧的每个值必须小于父节点，右侧的每个值必须大于父节点。在下图中，我们可以看到8(我们的根节点)有两个子节点，3和10。在左侧，3小于8，在右侧，10大于8。然后，我们可以查看每个节点，并沿着树向下执行相同的检查。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/1ca2ec51d0798ddb6d54c88d0f3cb427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4u0ZE_LZHKEYb2d3sNP4g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_search_tree</a></figcaption></figure><p id="922f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于二分搜索法树，请记住左边的每个值必须小于父值，右边的每个值必须大于父值。例如，在上面的图像中，如果我们将值为7的节点更改为9，这将不是有效的二叉查找树，因为9将大于8。请记住，左侧的每个节点值都必须小于8，右侧的每个节点值都必须大于8。</p><h1 id="59cd" class="mr ms iq bd mt mu np mw mx my nq na nb jw nr jx nd jz ns ka nf kc nt kd nh ni bi translated">建设二叉查找树</h1><p id="605d" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">首先，让我们创建节点类和二叉查找树类。我们的节点类构造函数将接受一个值，并将它设置为节点的值。然后，我们将左和右值设置为空。我们的二叉查找树类将有一个根值，我们将设置为null。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="af2d" class="nz ms iq nv b gy oa ob l oc od">class Node {<br/>  constructor(value) {<br/>    this.value = value;<br/>    this.left = null;<br/>    this.right = null;<br/>  }<br/>}</span><span id="833c" class="nz ms iq nv b gy oe ob l oc od">class BinarySearchTree {<br/>  constructor() {<br/>    this.root = null;<br/>  }<br/>}</span></pre><h2 id="d040" class="nz ms iq bd mt of og dn mx oh oi dp nb lf oj ok nd lj ol om nf ln on oo nh op bi translated">插入节点</h2><p id="32ab" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">现在让我们来处理如何将节点插入到树中。我们将为我们的二叉查找树类创建一个插入方法，它将接受一个值。首先，我们将使用该值创建一个新节点。有一个边缘情况，即如果树是空的(没有根)，那么我们将把树的根设置为新节点，返回树，我们就完成了。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="102f" class="nz ms iq nv b gy oa ob l oc od">insert(value) {<br/>  const newNode = new Node(value);<br/>  if (!this.root) {<br/>    this.root = newNode;<br/>    return this;<br/>  }</span></pre><p id="5903" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们需要将新节点的值与根节点的值进行比较。让我们首先创建一个当前变量来跟踪我们正在比较的节点。然后，我们将首先处理左侧，在这种情况下，新节点的值小于当前节点的值。</p><p id="1a21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将设置一个while循环，继续将新节点值与当前节点值进行比较。一旦我们将节点插入到树中的正确位置，我们就可以通过返回树来打破循环。如果当前节点没有左值，我们会将该值设置为新节点并返回树。否则，我们需要将当前节点更新为左侧节点(记住，当前节点是我们要比较的节点)。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="016e" class="nz ms iq nv b gy oa ob l oc od">insert(value) {<br/>  const newNode = new Node(value);<br/>  if (!this.root) {<br/>    this.root = newNode;<br/>    return this;<br/>  } else {<br/>    let current = this.root;<br/>    while(true) {<br/>      if (value &lt; current.value) {<br/>        if (!current.left) {<br/>          current.left = newNode;<br/>          return this;<br/>        } else {<br/>          current = current.left<br/>        }</span></pre><p id="6a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要处理右侧，在新节点大于当前节点的情况下。除右侧外，我们将进行与上述相同的检查。如果没有正确的节点，我们将正确的节点设置为新节点，并返回树。否则，我们将更新当前节点为正确的节点。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="ffbc" class="nz ms iq nv b gy oa ob l oc od">insert(value) {<br/>  const newNode = new Node(value);<br/>  if (!this.root) {<br/>    this.root = newNode;<br/>    return this;<br/>  } else {<br/>    let current = this.root;<br/>    while(true) {<br/>      if (value &lt; current.value) {<br/>        if (!current.left) {<br/>          current.left = newNode;<br/>          return this;<br/>        } else {<br/>          current = current.left;<br/>        }<br/>      } else if (value &gt; current.value) {<br/>        if (!current.right) {<br/>          current.right = newNode;<br/>          return this;<br/>        } else {<br/>          current = current.right;<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="a629" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的示例中，我们正在检查新节点值是否小于当前值，以及新节点值是否大于当前值。但是，如果新的节点值等于树中已经存在的值呢？有不同的方法来处理这个问题，但是在我们的例子中，我们将简单地返回未定义的。让我们在下面添加这一行代码，作为while循环的第一个检查。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="33bc" class="nz ms iq nv b gy oa ob l oc od">if (value === current.value) return undefined;</span></pre><p id="14b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终的代码应该是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="5773" class="nz ms iq bd mt of og dn mx oh oi dp nb lf oj ok nd lj ol om nf ln on oo nh op bi translated">查找节点</h2><p id="fe1b" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们将添加到二叉查找树类中的第二个方法是如何检查树中是否存在值。让我们命名这个方法find，它将接受一个值作为参数。这个值将是我们在树中寻找的值。类似于插入方法，我们将首先检查我们的树是否是空的(没有根)。如果是这样，那么我们将简单地返回undefined。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="add1" class="nz ms iq nv b gy oa ob l oc od">find(value) {<br/>  if (!this.root) return undefined;<br/>}</span></pre><p id="2781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们将使用while循环来处理这个问题。首先，我们将创建两个变量，current和find。当前变量将帮助我们跟踪我们在树中的位置，找到的变量将告诉我们是否找到值。</p><p id="6aa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要有电流值，我们的while循环就会运行，而且我们还没有找到节点。我们将在两种情况下打破循环:</p><ol class=""><li id="bf15" class="os ot iq ky b kz la lc ld lf ou lj ov ln ow lr ox oy oz pa bi translated">如果我们找到了节点，我们将设置发现为真。</li><li id="f43d" class="os ot iq ky b kz pb lc pc lf pd lj pe ln pf lr ox oy oz pa bi translated">如果没有当前值，这意味着我们的树不包含该节点。</li></ol><p id="3152" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先检查我们正在搜索的值是否小于当前值。如果是这样，我们将通过将当前值设置为current.left，移动到树的左边。然后我们将对右边做同样的事情。如果我们正在搜索的值大于当前值，我们将把当前值设置为当前值。最后，如果值等于当前值，我们找到了我们的节点，我们将把find设置为true。</p><p id="ca3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在while循环之后，我们将做最后一次检查。如果found仍然等于false，这意味着该值不在我们的树中，我们将返回undefined。否则，我们将通过返回current返回带有我们正在搜索的值的节点。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="2a00" class="nz ms iq nv b gy oa ob l oc od">find(value) {<br/>  if (!this.root) return undefined;<br/>  let current = this.root;<br/>  let found = false;<br/>  while(current &amp;&amp; !found) {<br/>    if (value &lt; current.value) {<br/>      current = current.left;<br/>    } else if (value &gt; current.value) {<br/>      current = current.right;<br/>    } else {<br/>      found = true;<br/>    }<br/>  }<br/>  if (!found) return undefined;<br/>  return current;<br/>}</span></pre><p id="cdec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的最终代码，包括插入和查找方法，如下所示。在代码的最后一行，我们创建了一个新的二叉查找树作为变量Tree。现在，您可以使用tree.insert(value)将值插入到树中，并使用tree.find(value)检查树是否包含值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1db1" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">包扎</h1><p id="0e70" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">树木在很多地方都被广泛使用。例如，您的计算机文件系统、HTML DOM和JSON都是使用树的例子。二叉树是树的一种，二分搜索法树是二叉树的一种。二分搜索法树可以有一个根节点，每个节点最多可以有两个子节点。父节点左边的值必须小于父节点的值，父节点右边的值必须大于父节点的值。</p><p id="3f83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果树是平衡的，那么二分搜索法树的大O对于插入和搜索都是O(log n)。然而，在最坏的情况下，大O可以变成O(n)。如果树不平衡，就会发生这种情况，因为我们可能必须遍历所有元素。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="0877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pg">感谢阅读！如果您错过了我们比较堆栈和队列的系列文章的第3部分，请查看下面的文章。</em></p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/stacks-vs-queues-with-javascript-eeb33ae4c93c" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用JavaScript的堆栈与队列</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JavaScript数据结构系列的第3部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="ph l mg mh mi me mj kp lv"/></div></div></a></div><p id="9b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pg">请关注本系列的第6部分，在那里我们将了解树遍历。</em></p></div></div>    
</body>
</html>