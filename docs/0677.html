<html>
<head>
<title>How to Approach State Management in React, Vue and Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理React、Vue和Angular中的状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-art-of-the-state-e19816732530?source=collection_archive---------3-----------------------#2019-11-25">https://javascript.plainenglish.io/the-art-of-the-state-e19816732530?source=collection_archive---------3-----------------------#2019-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8552" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">同样好的架构适用于任何地方</h2></div><p id="14b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管React、Angular和Vue之间存在显著差异，但它们共享架构基础。我们可以这样看待这种统一:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d24889a40191ea895529fce3205547dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZER3NHTpVRfxjUR9BvZ-Q.png"/></div></div></figure><p id="01fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种高层次同样适用于三大巨头React、Angular和Vue(可能还有新兴事物如<a class="ae ln" href="https://lit-html.polymer-project.org/" rel="noopener ugc nofollow" target="_blank"> lit-html </a>)。</p><p id="3985" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">三者共有的一个核心改进是上面提到的DOM绑定概念，在这里<a class="ae ln" href="https://medium.com/@matthewcarltyson/modern-ui-explained-in-4-paragraphs-and-2-pictures-2494042b3847" rel="noopener">会有更全面的描述。</a></p><p id="8f43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些框架的应用程序的一个关键复杂性领域是应用程序状态。我问的问题是，处理状态反应的最佳方式是什么<a class="ae ln" href="https://medium.com/better-programming/react-state-of-the-state-e30e98abdb01" rel="noopener">这里</a>。我已经得出了我认为这个问题的理想设计原则，跨越了所有三个框架。</p><p id="a04f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，我提出的原则是:</p><blockquote class="lo"><p id="3449" class="lp lq iq bd lr ls lt lu lv lw lx la dk translated">对于业务数据，支持集中状态，对于UI状态，支持组件状态。</p></blockquote><p id="9c3a" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">让我强调一下这个想法中有利于T7的部分。倾向于这种想法，不要把业务状态放在组件中，因为这在伦理上是错误的。</p><p id="61ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我肯定没有在所有三个框架上工作过足够多的应用程序，所以直接告诉我你的经历。</p><p id="7863" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这三个方面的经验告诉我，这是一个很好的指导原则，可以处理非常大和复杂的应用程序。</p><h2 id="fa20" class="me mf iq bd mg mh mi dn mj mk ml dp mm ko mn mo mp ks mq mr ms kw mt mu mv mw bi translated">两种状态</h2><p id="904b" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">如果你告诉我屏幕元素的位置，你就是在告诉我用户界面的状态。</p><p id="4ada" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您告诉我account total小部件中有多少钱，您就在谈论业务数据。</p><p id="9dd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不是一个严格的区别，因为您可能会将小部件的位置保存到后端，从而将UI状态转换成一种业务数据。</p><p id="e60b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，业务数据总是驱动UI的内容。</p><p id="8ee7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看待业务数据的一种更完美的方式是将其视为远程持久数据。</p><p id="24dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，来自远程API并通过远程API返回的数据。出于讨论的目的，我认为业务数据几乎等同于持久API数据。</p><p id="ef0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，这个想法是这样的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/d04a28dbd525405ca674770d5c522454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*pAyWby31PdbTdvZZMfKhGQ.png"/></div></figure><p id="fc95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们试图<strong class="kh ir"> <em class="md">避免</em> </strong>的主要事情是这样的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0a79840b31abb7a9f143fc6bb4206014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*q0q2l64KtfrvWD0quJMCVQ.png"/></div></figure><p id="2e0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再说一次，不是因为它是错的或者注定要彻底失败。</p><p id="c175" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们避免让持久数据经过多个角色，仅仅是因为它违反了应用程序设计一个基本原则，这个原则几十年来一直使复杂性易于管理:将数据问题隔离到层。</p><p id="0155" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为大多数经验丰富的软件开发人员会看到这一点，并本能地知道在整个组件中散布后端API调用将导致难以理解的数据流。</p><h1 id="bfa2" class="nd mf iq bd mg ne nf ng mj nh ni nj mm jw nk jx mp jz nl ka ms kc nm kd mv nn bi translated">将后端调用集中到一个层</h1><p id="d875" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">因此，我们希望从众多组件中真正调用一个集中且一致的中央数据存储，代表数据层。</p><h2 id="58fc" class="me mf iq bd mg mh mi dn mj mk ml dp mm ko mn mo mp ks mq mr ms kw mt mu mv mw bi translated">正规商店</h2><p id="72e0" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">有各种各样的方法可以实现这一点。在Vue、React和Angular中，有一个标准且相似的方式:</p><ul class=""><li id="8da8" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">反应:Redux</li><li id="c44a" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">角度:<a class="ae ln" href="https://blog.usejournal.com/redux-angular-style-ngrx-store-b2876280708e" rel="noopener ugc nofollow" target="_blank"> ngrx/store </a></li><li id="9512" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">Vue: Vuex</li></ul><p id="ee66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中的每一个都创建了一个以正式方式交互的中央存储，并且包括处理后端API交互的能力。</p><h2 id="8086" class="me mf iq bd mg mh mi dn mj mk ml dp mm ko mn mo mp ks mq mr ms kw mt mu mv mw bi translated">指挥观察员</h2><p id="274d" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">每个中央商店都像是<a class="ae ln" href="https://en.wikipedia.org/wiki/Command_pattern#:~:targetText=In%20object%2Doriented%20programming%2C%20the,values%20for%20the%20method%20parameters." rel="noopener ugc nofollow" target="_blank">命令模式</a>的实现，或者在简单的情况下，像是<a class="ae ln" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>。Flux是应用于UI架构的一般概念的名称。</p><p id="f77e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每种情况下，事情都是这样的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/56c0e07db77de99d27e9a2b6af43eada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsEBUlxFlzV3oxAwVSRH4Q.png"/></div></div></figure><p id="004a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来像是商店概念的一个相当合理的抽象，在所有三个框架中都有体现。</p><p id="1fc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，Flux-like Store实现提供了一种标准化和严格的方法来加强数据访问层。</p><p id="109b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们还通过命令观测器给出了更多的形式化的状态变化。简而言之，使用正式的商店比使用直接的集中商店更复杂。</p><p id="b75a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你真的需要那些额外的东西吗？</p><p id="7486" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是我对此的看法:不，你可能不需要所有这些，但你也可能不会找到比直接使用中央商店更简单或更快的中央设置，<em class="md">Angular中的</em>除外。</p><p id="b267" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Angular中，如果我可以说的话，中央存储有点笨重，并且其RxJS框架架构的控制反转和可观察性使得创建自己的中央状态管理变得很容易。</p><h2 id="88b6" class="me mf iq bd mg mh mi dn mj mk ml dp mm ko mn mo mp ks mq mr ms kw mt mu mv mw bi translated">中央商场的简单例子</h2><p id="d18d" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">下面是每个框架使用其官方中心存储的非常简单的例子。</p><ul class=""><li id="3e46" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">简单的<strong class="kh ir">vuex</strong>:<a class="ae ln" href="https://jsfiddle.net/n9jmu5v7/1269/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/n9jmu5v7/1269/</a></li><li id="5dcf" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">简单<strong class="kh ir">重复</strong>:<a class="ae ln" href="https://jsfiddle.net/hganz/gk9kaopr/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/hganz/gk9kaopr/</a></li><li id="723a" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">简单<strong class="kh ir">ngrx/store</strong>:<a class="ae ln" href="https://stackblitz.com/angular/ybkjvpbengb" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/angular/ybkjvpbengb</a></li></ul><p id="b0dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意Vuex和Redux是简单的单页JSFiddles，而ngrx/store是多文件app。不好，有棱角，<a class="ae ln" href="https://blog.usejournal.com/redux-angular-style-ngrx-store-b2876280708e" rel="noopener ugc nofollow" target="_blank">一点都不好</a>。</p><h1 id="5485" class="nd mf iq bd mg ne nf ng mj nh ni nj mm jw nk jx mp jz nl ka ms kc nm kd mv nn bi translated">作为全局范围和API层的根组件</h1><p id="19c3" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">在缺少全局状态的情况下，视图的根组件倾向于充当这个角色。</p><p id="e288" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的视图是指随着应用的增长，你会把它分成多个单独加载的页面，每个页面都有一个根组件。默认情况下，根组件充当全局变量空间。</p><p id="77c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，根组件将负责与树中的子组件交互，以通过从子组件返回到父组件的道具和事件来保持它们与状态同步。</p><p id="d066" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概是这样的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi od"><img src="../Images/536c0c386b26387c6cb51154efff056c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*rZmozHacJ_WkGkju-SrHyA.png"/></div></figure><p id="bd84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这是一个公平的妥协:它将API交互集中在根组件中。同样，我们正在努力避免API调用分散在代码库中。</p><p id="a99c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您使用的框架，这看起来会有很大的不同。最尴尬的将是React(见<a class="ae ln" href="https://medium.com/better-programming/react-state-of-the-state-e30e98abdb01" rel="noopener">这里</a>)，因为你将使用“渲染道具”来处理向上的沟通。</p><p id="e8fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae ln" href="https://angular.io/api/core/EventEmitter" rel="noopener ugc nofollow" target="_blank"> Angular </a>和<a class="ae ln" href="https://medium.com/@sky790312/about-vue-2-parent-to-child-props-af3b5bb59829" rel="noopener"> Vue </a>中，有强大的事件支持可以减少管理孩子与父母沟通的难度。这些比渲染道具更干净，但是当事件在组件中跟踪时，你仍然要小心爆炸式的复杂性。</p><h1 id="b8b0" class="nd mf iq bd mg ne nf ng mj nh ni nj mm jw nk jx mp jz nl ka ms kc nm kd mv nn bi translated">无状态组件</h1><h2 id="1e28" class="me mf iq bd mg mh mi dn mj mk ml dp mm ko mn mo mp ks mq mr ms kw mt mu mv mw bi translated">也就是功能组件，也就是“纯”组件</h2><p id="991e" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">一个有趣的方法是无状态组件。在这种情况下，您采取了极端的做法，从组件中完全消除了状态。组件只是变成了行为声明者。</p><p id="4d0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的想法是让组件非常容易思考。我的感觉是，这实际上可能会推高复杂性，而不是消除它，但我没有足够的实际经验来肯定地说。</p><p id="2833" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些也被称为“功能组件”,以突出它们没有被建模为对象的事实。(也称为“纯”组件，这是一个非常无用和令人困惑的名称，IMO)。</p><p id="5182" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些类型的组件是可能的:</p><ul class=""><li id="b750" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">in React:<a class="ae ln" href="https://itnext.io/react-component-class-vs-stateless-component-e3797c7d23ab" rel="noopener ugc nofollow" target="_blank">https://it next . io/React-component-class-vs-stateless-component-e 3797 c 7d 23 ab</a></li><li id="8e62" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">在Vue中:<a class="ae ln" href="https://blog.logrocket.com/how-to-use-stateless-components-in-vue-js/" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/how-to-use-stateless-components-in-Vue-js/</a></li><li id="43f6" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">在Angular:<a class="ae ln" href="https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/" rel="noopener ugc nofollow" target="_blank">https://blog . Angular-university . io/Angular-2-smart-components-vs-presentation-components-what-the-difference-when-use-each-and-why/</a></li></ul><p id="6686" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(在Angular中，它们被称为“表象组件”，我觉得这是一个不错的描述符。)</p><h1 id="e566" class="nd mf iq bd mg ne nf ng mj nh ni nj mm jw nk jx mp jz nl ka ms kc nm kd mv nn bi translated">保持敏捷</h1><p id="07ba" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">我推动集中式状态/API访问的最大缺点是，在开始一个新的应用程序时，人们可能会试图强制执行这一硬性规则，从而减缓开发，因为人们处理商店，而不是提供功能。</p><blockquote class="lo"><p id="2324" class="lp lq iq bd lr ls lt lu lv lw lx la dk translated">软件生存的基本规则是:让应用程序工作，这样它才能生存，然后在必要时重构。</p></blockquote><p id="fa71" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">开发一个有缺陷的应用比让它死掉要好。</p><p id="6902" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在软件领域，理想总是在你的前面——这是它最迷人的地方之一。</p><p id="ca2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，一旦你在你的架构上安排好了事情，一些客户或项目经理就会走进来把一切都搞砸。</p><p id="5199" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，我想在这里提出的要点是:</p><ul class=""><li id="8eac" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">整体设计选项在Vue、React和Angular之间是相似的</li><li id="8045" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">尝试将API调用集中在一个层中</li><li id="f764" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">尝试只在组件树中共享UI状态</li><li id="8e3e" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">如果不使用存储，则使用根组件作为API层和中央状态</li><li id="e45e" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">如果您/您的团队/您的时间表能够支持复杂性，请使用商店</li></ul></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="c60c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">小附录。</p><p id="bde0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有几个选项可供选择。这些提供了容易获得的中央存储，但是相当于全局变量。谨慎小心地使用:</p><p id="2411" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">window.myState</p><p id="83ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">localStorage.setItem("myState "，" foo ")</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="1833" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">马特·泰森是T4网站的首席技术官</p><div class="ol om gp gr on oo"><a href="https://twitter.com/matttyson" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">马特·泰森</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">马特·泰森(@matttyson)的最新推文:“我喜欢@springframework的原因:几乎所有你需要添加的东西…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">twitter.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ll oo"/></div></div></a></div></div></div>    
</body>
</html>