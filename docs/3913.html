<html>
<head>
<title>Best of Modern JavaScript — Iterables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华— Iterables</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-iterables-e6150406ba3e?source=collection_archive---------10-----------------------#2020-11-02">https://javascript.plainenglish.io/best-of-modern-javascript-iterables-e6150406ba3e?source=collection_archive---------10-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7825a4b35a0462fd8f4a8eb3dfe92ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KFYqnxPD3vUuJkPU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@xoxxai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Woldai Wagner</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e320" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript可迭代对象。</p><h1 id="5805" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可迭代值</h1><p id="483b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript有各种类型的可迭代对象。</p><p id="25d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括数组、字符串、映射、集合和节点列表。</p><h1 id="80ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">支持迭代的构造</h1><p id="d04f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有各种各样的构造使得使用iterable对象更加容易。</p><p id="481f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中之一是析构语法。</p><p id="70ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将任何可迭代的对象条目析构为变量。</p><p id="8599" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0b30" class="mn lc iq mj b gy mo mp l mq mr">const [a, b] = new Set(['a', 'b', 'c']);</span></pre><p id="0552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe ms mt mu mj b">'a'</code>分配给<code class="fe ms mt mu mj b">a</code>，将<code class="fe ms mt mu mj b">'b'</code>分配给<code class="fe ms mt mu mj b">b</code>。</p><p id="cfa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-of循环让我们可以轻松地遍历iterable对象中的条目。</p><p id="314b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2474" class="mn lc iq mj b gy mo mp l mq mr">for (const x of ['foo', 'bar', 'baz']) {<br/>  console.log(x);<br/>}</span></pre><p id="640d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">循环遍历数组。</p><p id="d0b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Array.from</code>静态方法让我们从可迭代对象中创建一个数组。</p><p id="e541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容将集合转换为数组:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2cd4" class="mn lc iq mj b gy mo mp l mq mr">const arr = Array.from(new Set(['a', 'b', 'c']));</span></pre><p id="1eff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">arr</code>就是<code class="fe ms mt mu mj b">[‘a’, ‘b’, ‘c’]</code>。</p><p id="14a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">spread操作符让我们做与<code class="fe ms mt mu mj b">Array.from</code>相同的事情</p><p id="ec7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="643b" class="mn lc iq mj b gy mo mp l mq mr">const arr = [...new Set(['a', 'b', 'c'])];</span></pre><p id="54cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将集合的项目分散到数组中。</p><p id="8f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Map</code>和<code class="fe ms mt mu mj b">Set</code>构造函数让我们从数组中创建地图和集合。</p><p id="81c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Map</code>构造函数将一个带有键值数组的数组作为条目，并将它们转换成一个对象中的一组键值对。</p><p id="73c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c18e" class="mn lc iq mj b gy mo mp l mq mr">const map = new Map([<br/>  ['foo', 'no'],<br/>  ['bar', 'yes']<br/>]);</span></pre><p id="897f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一个集合，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b9f6" class="mn lc iq mj b gy mo mp l mq mr">const set = new Set(['a', 'b', 'c']);</span></pre><p id="8f6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从数组中创建它。</p><p id="27df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Promise.all()</code>让我们并行运行多个承诺。</p><p id="64bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9b84" class="mn lc iq mj b gy mo mp l mq mr">Promise.all([<br/>  Promise.resolve(1),<br/>  Promise.resolve(2),<br/>]).then(() =&gt; {<br/>  //...<br/>});</span></pre><p id="2366" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并行运行数组中的两个承诺。</p><p id="2622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Promise.race</code>解析为完成运行的第一个承诺的值。</p><p id="6d32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7d9b" class="mn lc iq mj b gy mo mp l mq mr">Promise.race([<br/>  Promise.resolve(1),<br/>  Promise.resolve(2),<br/>]).then(() =&gt; {<br/>  //...<br/>});</span></pre><p id="45ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从承诺集中得到第一个值。</p><p id="0025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关键字<code class="fe ms mt mu mj b">yield*</code>让我们从另一个生成器函数中运行生成器函数。</p><p id="6906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f4b6" class="mn lc iq mj b gy mo mp l mq mr">yield*<!-- --> <!-- -->gen;</span></pre><h1 id="4db1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">迭代性</h1><p id="74fc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">任何使用<code class="fe ms mt mu mj b">Symbol.iterator</code>方法的对象都是可迭代对象。</p><p id="bdae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该方法必须是一个生成器函数。</p><p id="9bd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码从数组中获取该方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fc63" class="mn lc iq mj b gy mo mp l mq mr">const arr = ['foo', 'bar', 'baz'];<br/>const iter = arr[Symbol.iterator]();</span></pre><p id="11fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过从返回的迭代器中调用<code class="fe ms mt mu mj b">next</code>方法来逐个获取条目:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="49e2" class="mn lc iq mj b gy mo mp l mq mr">iter.next()</span></pre><p id="b84f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e285" class="mn lc iq mj b gy mo mp l mq mr">{value: "foo", done: false}</span></pre><p id="6940" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们第一次运行时。</p><p id="f1fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们再次运行时:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7b3b" class="mn lc iq mj b gy mo mp l mq mr">iter.next()</span></pre><p id="efc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a937" class="mn lc iq mj b gy mo mp l mq mr">{value: "bar", done: false}</span></pre><p id="3b74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们再次运行它时，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c031" class="mn lc iq mj b gy mo mp l mq mr">{value: "baz", done: false}</span></pre><p id="6a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当我们最后一次运行它时，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b5d0" class="mn lc iq mj b gy mo mp l mq mr">{value: undefined, done: true}</span></pre><p id="7004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">value</code>是从iterable对象返回的值。而<code class="fe ms mt mu mj b">done</code>表示是否有任何值要返回。</p><p id="4365" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">next</code>返回包装在对象中的每个项目。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/771dd301c591ed3aaaff11581aa4da66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9-5Yz87IZcK1sg5Z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@she_sees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Charlotte Coneybeer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7dd3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8b6e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript有各种类型的可迭代对象。</p><p id="d629" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都有<code class="fe ms mt mu mj b">Symbol.iterator</code>属性，这是一个按顺序返回下一个值的方法。</p><p id="56d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>