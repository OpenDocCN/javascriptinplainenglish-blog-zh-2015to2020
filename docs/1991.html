<html>
<head>
<title>Learning JavaScript by Implementing Lodash Methods — Transforming Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现Lodash方法学习JavaScript转换对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-transforming-objects-fecd408cd3a5?source=collection_archive---------18-----------------------#2020-05-09">https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-transforming-objects-fecd408cd3a5?source=collection_archive---------18-----------------------#2020-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b27caedd0ee19e7b80cd338c59ea9372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1PYhQ2rvOdchZaRz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rcrazy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ricardo Rocha</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aef7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="4afa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何用普通JavaScript实现一些对象方法。</p><h1 id="33e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">toPlainObject</code></h1><p id="c7cb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash的<code class="fe lz ma mb mc b">toPlainObject</code>方法通过将继承的可枚举属性合并到对象本身来将对象转换为普通对象。</p><p id="fa8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用<code class="fe lz ma mb mc b">Object.create</code>方法来实现它</p><p id="d510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe lz ma mb mc b">Object.getPrototypeOf</code>方法，然后将它们合并到对象自己的属性中。</p><p id="9c96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下实现它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2931" class="mq lc iq mc b gy mr ms l mt mu">const toPlainPObject = (obj) =&gt; {<br/>  let plainObj = Object.create(null);<br/>  plainObj = {<br/>    ...obj<br/>  };<br/>  let prototype = Object.getPrototypeOf(obj)<br/>  while (prototype) {<br/>    plainObj = {<br/>      ...plainObj,<br/>      ...prototype<br/>    }<br/>    prototype = Object.getPrototypeOf(prototype)<br/>  }<br/>  return plainObj;<br/>}</span></pre><p id="918d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有我们的<code class="fe lz ma mb mc b">toPlainObject</code>函数，它接受包含我们想要转换成普通对象的对象的<code class="fe lz ma mb mc b">obj</code>参数。</p><p id="a942" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们用带有参数<code class="fe lz ma mb mc b">null</code>的<code class="fe lz ma mb mc b">Object.create</code>创建一个新对象，它通过创建一个没有原型的对象来创建一个普通对象。</p><p id="5515" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用spread运算符将<code class="fe lz ma mb mc b">obj</code>自己的属性合并到<code class="fe lz ma mb mc b">plainObj</code>中。</p><p id="e95f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们调用传入了<code class="fe lz ma mb mc b">obj</code>的<code class="fe lz ma mb mc b">Object.getPrototypeOf</code>来获取<code class="fe lz ma mb mc b">obj</code>的原型。然后我们使用一个<code class="fe lz ma mb mc b">while</code>循环将原型的属性合并到<code class="fe lz ma mb mc b">plainObj</code>中，并沿着原型链向上:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="753c" class="mq lc iq mc b gy mr ms l mt mu">prototype = Object.getPrototypeOf(prototype)</span></pre><p id="d92d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们返回<code class="fe lz ma mb mc b">plainObj</code>。</p><p id="7a68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在当我们这样称呼它时:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8c72" class="mq lc iq mc b gy mr ms l mt mu">function Foo() {<br/>  this.a = 1;<br/>}</span><span id="a4a9" class="mq lc iq mc b gy mv ms l mt mu">Foo.prototype.b = 2;<br/>console.log(toPlainPObject(new Foo()));</span></pre><p id="cdf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到的控制台日志输出是<code class="fe lz ma mb mc b">{a: 1, b: 2}</code>。</p><h1 id="6b3a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">toSafeInteger</code></h1><p id="776b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash的<code class="fe lz ma mb mc b">toSafeInteger</code>方法将一个值转换成一个安全的整数。它通过检查<code class="fe lz ma mb mc b">Infinity</code>和<code class="fe lz ma mb mc b">-Infinity</code>来做到这一点，然后分别返回最大安全整数和乘以1的最大安全整数。</p><p id="ead2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7832" class="mq lc iq mc b gy mr ms l mt mu">const toSafeInteger = val =&gt; {<br/>  if (val === Infinity) {<br/>    return Number.MAX_SAFE_INTEGER<br/>  } else if (val === -Infinity) {<br/>    return -1 * Number.MAX_SAFE_INTEGER<br/>  }<br/>  return isNaN(+val) ? 0 : Math.round(+val);<br/>}</span></pre><p id="c715" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们检查了<code class="fe lz ma mb mc b">val</code>是<code class="fe lz ma mb mc b">Infinity</code>还是<code class="fe lz ma mb mc b">-Infinity</code>。如果是<code class="fe lz ma mb mc b">Infinity</code>，那么我们返回<code class="fe lz ma mb mc b">Number.MAX_SAFE_INTEGER</code>。如果<code class="fe lz ma mb mc b">val</code>是<code class="fe lz ma mb mc b">-Infinity</code>，那么我们返回<code class="fe lz ma mb mc b">-Number.MAX_SAFE_INTEGER</code>。</p><p id="4f5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们通过调用<code class="fe lz ma mb mc b">isNaN</code>来检查<code class="fe lz ma mb mc b">val</code>是否可以转换成数字。如果它返回<code class="fe lz ma mb mc b">true</code>,那么我们返回0，否则，我们在将<code class="fe lz ma mb mc b">+val</code>转换成数字后用<code class="fe lz ma mb mc b">Math.round</code>调用它。</p><p id="cda9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4cb1" class="mq lc iq mc b gy mr ms l mt mu">console.log(toSafeInteger(3.2));<br/>console.log(toSafeInteger(Number.MIN_VALUE));<br/>console.log(toSafeInteger(Infinity));<br/>console.log(toSafeInteger('3.2'));</span></pre><p id="49e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们分别从每个中获得以下输出:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9dec" class="mq lc iq mc b gy mr ms l mt mu">3<br/>0<br/>9007199254740991<br/>3</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2c72cbb1070765f9348984f8f2869734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NWMdr91HttuHJuSB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">freestocks</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="13d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">toString</code></h1><p id="2a83" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash的<code class="fe lz ma mb mc b">toString</code>方法将给定的值转换成字符串。为<code class="fe lz ma mb mc b">null</code>和<code class="fe lz ma mb mc b">undefined</code>值返回一个空字符串。</p><p id="2201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下实现它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="544a" class="mq lc iq mc b gy mr ms l mt mu">const toString = val =&gt; {<br/>  if (Object.is(val, -0)) {<br/>    return '-0'<br/>  } else if (Object.is(val, +0)) {<br/>    return '+0'<br/>  } else if (Object.is(val, null) || Object.is(val, undefined)) {<br/>    return ''<br/>  } else if (Array.isArray(val)) {<br/>    return val.join(',');<br/>  }<br/>  return JSON.stringify(val);<br/>}</span></pre><p id="da0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用了<code class="fe lz ma mb mc b">Object.is</code>来检查<code class="fe lz ma mb mc b">val</code>是否是列出的值之一。我们使用<code class="fe lz ma mb mc b">Object.is</code>而不是<code class="fe lz ma mb mc b">===</code>，因为<code class="fe lz ma mb mc b">-0</code>和<code class="fe lz ma mb mc b">+0</code>被认为与<code class="fe lz ma mb mc b">Object.is</code>不同。</p><p id="58c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lz ma mb mc b">val</code>不是<code class="fe lz ma mb mc b">-0</code>、<code class="fe lz ma mb mc b">+0</code>、<code class="fe lz ma mb mc b">null</code>或<code class="fe lz ma mb mc b">undefined</code>，那么我们使用<code class="fe lz ma mb mc b">JSON.stringify</code>将对象转换为字符串。</p><p id="d7b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3bcf" class="mq lc iq mc b gy mr ms l mt mu">console.log(toString(null));<br/>console.log(toString(-0));<br/>console.log(toString([1, 2, 3]));</span></pre><p id="92f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从第一个控制台日志中得到一个空字符串，从第二个控制台日志中得到<code class="fe lz ma mb mc b">'-0'</code>，从最后一个控制台日志中得到<code class="fe lz ma mb mc b">1,2,3</code>。</p><h1 id="a6da" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">invert</code></h1><p id="7a4a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">方法翻转一个对象的键和值。如果两个属性具有相同的值，则后一个属性会覆盖前一个属性。</p><p id="cdbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以自己用<code class="fe lz ma mb mc b">Object.keys</code>方法来获取键，用键和值填充一个新对象，如下所示:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fc69" class="mq lc iq mc b gy mr ms l mt mu">const invert = (obj) =&gt; {<br/>  let invertedObj = {};<br/>  for (const key of Object.keys(obj)) {<br/>    invertedObj[obj[key]] = key;<br/>  }<br/>  return invertedObj;<br/>}</span></pre><p id="4283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们创建了<code class="fe lz ma mb mc b">invertedObj</code>对象。然后，我们通过用<code class="fe lz ma mb mc b">Object.keys</code>方法获取这些键，然后用<code class="fe lz ma mb mc b">for...of</code>循环遍历它们，从而循环遍历这些键。</p><p id="7cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe lz ma mb mc b">obj</code>的值填充为<code class="fe lz ma mb mc b">invertedobj</code>的键，将<code class="fe lz ma mb mc b">obj</code>的键填充为<code class="fe lz ma mb mc b">invertedObj</code>的值。</p><p id="68a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当我们这样称呼它时:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3d9f" class="mq lc iq mc b gy mr ms l mt mu">const object = {<br/>  'a': 1,<br/>  'b': 2,<br/>  'c': 1<br/>};</span><span id="66c5" class="mq lc iq mc b gy mv ms l mt mu">console.log(invert(object));</span></pre><p id="00d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从控制台日志输出中获取<code class="fe lz ma mb mc b">{1: “c”, 2: “b”}</code>日志。</p><h1 id="a804" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3d2f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了实现<code class="fe lz ma mb mc b">toPlainObject</code>方法，我们可以使用<code class="fe lz ma mb mc b">Object.getPrototype</code>方法来遍历一个对象的原型链。</p><p id="2678" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">toString</code>和<code class="fe lz ma mb mc b">toSafeInteger</code>方法的相似之处在于，它们都对传入的参数进行一系列检查，然后相应地返回一些值。</p><p id="d763" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以使用<code class="fe lz ma mb mc b">Object.keys</code>来获取一个对象的键来实现<code class="fe lz ma mb mc b">invert</code>。</p><h2 id="3dfc" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">来自简明英语团队的通知</strong></h2><p id="9e1c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！</p><p id="e920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>