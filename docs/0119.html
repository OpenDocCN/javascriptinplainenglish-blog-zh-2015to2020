<html>
<head>
<title>A common sense explanation of JavaScript array methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数组方法的常识性解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-common-sense-explanation-of-javascript-array-methods-1205b2d2790e?source=collection_archive---------0-----------------------#2019-03-31">https://javascript.plainenglish.io/a-common-sense-explanation-of-javascript-array-methods-1205b2d2790e?source=collection_archive---------0-----------------------#2019-03-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/77f205ea6dc5d455598839997eb0426d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*dmCbrjpGuBcAtPN1J6f3bQ.jpeg"/></div></figure><p id="e412" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">数组方法<code class="fe kp kq kr ks b">filter</code>、<code class="fe kp kq kr ks b">map</code>、<code class="fe kp kq kr ks b">reduce </code>已经存在了一段时间，它们使数组的使用变得更加容易。但是有时候，新的JavaScript开发人员很难决定他们需要使用哪种数组方法。</p><p id="d6e6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一些开发人员仍然继续编写更长的代码，如果他们使用一个或多个数组方法，这些代码本来会更短，因为他们发现它们令人困惑。下面是我的一个Javascript领主的推文:</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="21f3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这篇文章中，我将简单解释一下前面提到的数组方法。看完这篇文章后，选择使用哪一个将是小菜一碟。</p><h1 id="33dc" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">数组里有什么？</h1><p id="5625" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">考虑这个数组:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="2d25" class="mg la in ks b gy mh mi l mj mk">const balls = [<br/> {brand: 'Adidas', color: 'blue', rating: 5},<br/> {brand: 'Konami', color: 'red', rating: 4},<br/> {brand: 'Verah', color: 'blue', rating: 2},<br/> {brand: 'Adidas', color: 'green', rating: 3}<br/>]</span></pre><p id="7649" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在上面的球数组中，长度是4(我们可以通过<code class="fe kp kq kr ks b">balls.length</code>得到这个)。每件商品都有一个形状:一个品牌、一种颜色和一个等级。</p><p id="8eb5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当我们使用任何提到的数组方法时，我们将处理数组的<strong class="jt io">长度</strong> <em class="ml">和/或</em><strong class="jt io">形状</strong>。</p><h1 id="c59d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">请记住…</h1><p id="9811" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">当我们使用<code class="fe kp kq kr ks b">filter</code>、<code class="fe kp kq kr ks b">map </code>和<code class="fe kp kq kr ks b">reduce </code>数组方法时，我们<strong class="jt io">循环</strong>通过数组。在循环的每一次迭代中，我们'<strong class="jt io">挑选</strong>数组中的每个成员，并对其进行<strong class="jt io">处理</strong>。为了对数组的一个元素“做点什么”,我们向数组方法传递了一个<code class="fe kp kq kr ks b">callback </code>。回调只是一个指定我们想要对数组元素做什么的函数。例如，如果<code class="fe kp kq kr ks b">arr </code>是一个数组:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="c4fb" class="mg la in ks b gy mh mi l mj mk">arr.map(callback)// callback is a function<br/>arr.filter(callback) </span></pre><h1 id="5097" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">该过滤方法</h1><p id="98aa" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">当我们在一个数组上使用filter方法时，我们<strong class="jt io">改变了数组的大小</strong>，但没有改变数组的形状。</p><p id="7526" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">想象一下，你有一个物理盒子，里面装着上面阵列描述的4个球，每个球都有一个标签，标明其等级。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/8f866679d3094c3cc8f8f213d7780c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwZ-d0mOSwb_Cddz5vrDXQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">Box containing 4 balls</figcaption></figure><p id="4a82" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，想象我给你另一个盒子，让你把蓝色的球放进这个新盒子里。如果你决定遵循我的指示，你会得到一个由两个球组成的盒子:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mm"><img src="../Images/bf1f5c9a1bb33fc69441208d41854a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SESOQPlNulqXEPUM8LGAow.png"/></div></div></figure><p id="bb49" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们要用代码来表示这个新盒子，您需要:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="95ed" class="mg la in ks b gy mh mi l mj mk">[<br/> {brand: 'Adidas', color: 'blue', rating: 5},<br/> {brand: 'Verah', color: 'blue', rating: 2}<br/>]</span></pre><p id="b4d1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">记住，在你过滤盒子之前，我必须给你一个<em class="ml">条件来检查</em> : <strong class="jt io">球必须是蓝色的</strong>。同样，返回的数组是原始数组的子集。</p><p id="6d58" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在让我们用JavaScript写一个<code class="fe kp kq kr ks b">filter</code>方法:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="cbc9" class="mg la in ks b gy mh mi l mj mk">let blueBalls = balls.filter(ball =&gt; ball.color === 'blue')</span></pre><p id="536a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">简单。</p><p id="c5df" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们循环遍历“球”框，<em class="ml">挑选</em>每个“球”并检查它是否是蓝色的(<code class="fe kp kq kr ks b">ball.color === blue</code>)，如果是，我们将它转储到新的框中(<code class="fe kp kq kr ks b">blueballs</code>)！</p><p id="d440" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">更准确地说，在循环的每一次迭代中，任何为<code class="fe kp kq kr ks b">ball.color === 'blue'</code>返回true的项都将在新数组中返回。</p><p id="fb9d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">最好的部分是，我们原来的球阵列仍然完好无损。如果我们<code class="fe kp kq kr ks b">console.log(balls)</code>我们仍然有原来的4个球。<code class="fe kp kq kr ks b">filter</code>(像<code class="fe kp kq kr ks b">map </code>和<code class="fe kp kq kr ks b">reduce</code> ) <strong class="jt io">不要改变</strong>他们工作的数组！他们返回的结果没有对数组进行<em class="ml">变异</em>(也就是改变)。</p><h1 id="7abe" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">映射方法</h1><p id="7411" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">map方法<strong class="jt io">改变数组的形状</strong>，但<strong class="jt io">不改变其大小</strong>。也就是说，当你需要<em class="ml">修改</em>一个数组的每个成员并返回修改后的数组时，你可以使用它。</p><p id="3496" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">例如，假设我再次将球“盒子”交给您，并要求您将我们每个球的评级放入另一个盒子中。即:你<strong class="jt io"> <em class="ml">挑选</em> </strong> <em class="ml">每个</em>球，去掉评分标签，转储到<strong class="jt io"> <em class="ml">另一个</em> </strong> <em class="ml">箱</em>。</p><p id="bcaf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你会得到这样的东西:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mv"><img src="../Images/dd8c66d1917f1bd96e0c7d1c45d8e08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vi8lJfahWfeCQuj-5Vdh6w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk">4 tags in a box</figcaption></figure><p id="3a5a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你的箱子里还有4件物品，但是现在它们已经被修改了。形状变了，但大小没变。</p><p id="7659" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们用代码编写<code class="fe kp kq kr ks b">map</code>函数。</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="0ffa" class="mg la in ks b gy mh mi l mj mk">let tags = balls.map(ball =&gt; ball.rating)</span><span id="010f" class="mg la in ks b gy mw mi l mj mk">console.log(tags)</span><span id="82fa" class="mg la in ks b gy mw mi l mj mk">// returns [5, 4, 2, 3]</span></pre><p id="e6ee" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">啊哈！</p><p id="813c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们的<code class="fe kp kq kr ks b">map</code>方法(就像<code class="fe kp kq kr ks b">filter</code>一样)通过‘盒子’运行一个循环，‘<em class="ml">拾取’</em>一个球，然后移除评级标签！(<code class="fe kp kq kr ks b">ball.rating</code>的意思是‘给我这个球的rating属性值’)。</p><p id="371a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们运行<code class="fe kp kq kr ks b">console.log(balls)</code>，我们的球数组仍然保持原样。同样，<code class="fe kp kq kr ks b">map </code>方法不会<em class="ml">改变</em>原始数组！厉害！。</p><h1 id="6488" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">该简化方法</h1><p id="02d9" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated"><code class="fe kp kq kr ks b">reduce</code>数组方法相当棘手却又强大，这是因为当我们使用它时，我们有双重能力:我们可以改变数组的<strong class="jt io">形状</strong>和它的<strong class="jt io">长度</strong>。就像<code class="fe kp kq kr ks b">filter</code>和<code class="fe kp kq kr ks b">map</code>一样，reduce方法不会改变我们应用它的数组，它返回一个新的数组。</p><h2 id="26c7" class="mg la in bd lb mx my dn lf mz na dp lj kc nb nc ln kg nd ne lr kk nf ng lv nh bi translated"><strong class="ak">还记得复利吗？</strong></h2><p id="b322" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">我从复利的角度考虑reduce函数。在复利中，每次计算利息时，投入的资金(也叫本金)都会增加。例如，如果你以10%的复利投资10，000元(本金)5年。在第一年末，你有一笔利息(10% * 10，000)，这是N1 000。这个利息加到原来的本金上。</p><p id="2df0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以，第二年初，本金是11000奈拉。到第二年末，利息是10% * 11，000也就是N1，100。这又加到本金上，变成(11，000 + 1，100) N12，100。这成为第三年的新校长！这样校长成长！这样一直持续到第五年年底！</p><p id="8895" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">旁注</strong>:爱因斯坦称复利为“自然界最强大的力量之一”🤓</p><h2 id="81ba" class="mg la in bd lb mx my dn lf mz na dp lj kc nb nc ln kg nd ne lr kk nf ng lv nh bi translated"><strong class="ak">回到reduce方法… </strong></h2><p id="3242" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">让我们离开复利的数学世界，回到<code class="fe kp kq kr ks b">reduce</code>方法。你应该从复利世界中得到的是，我们有一个本金，它在我们每次计算利息时都会增加，增加的值<em class="ml">成为新投资年度的本金</em>。</p><p id="cf2a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">就像<code class="fe kp kq kr ks b">filter</code>和<code class="fe kp kq kr ks b">map</code>方法一样，我们也传递一个回调函数给<code class="fe kp kq kr ks b">reduce</code>方法，这个回调函数叫做<strong class="jt io">缩减器</strong>函数。reducer函数有四个参数，但我们将讨论两个参数，即<strong class="jt io">累加器</strong>和<strong class="jt io">当前值</strong>。</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="5a6c" class="mg la in ks b gy mh mi l mj mk">the_array.reduce(callback)</span></pre><p id="7a7d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请记住，在复利中，我们从一个初始本金开始，类似地，reduce方法在回调函数后采用一个可选的第二个参数，这是累加器的<strong class="jt io">初始值。</strong></p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="d386" class="mg la in ks b gy mh mi l mj mk">the_array.reduce(callback , initialValue)</span></pre><p id="e193" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">初始值是可选的。如果我们不指定，reduce方法会将数组的第一个元素作为累加器的初始值<strong class="jt io">。</strong></p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="b589" class="mg la in ks b gy mh mi l mj mk">the_array.reduce(function(acc, cur){</span><span id="38cd" class="mg la in ks b gy mw mi l mj mk">// do some stuff...</span><span id="340a" class="mg la in ks b gy mw mi l mj mk">}, initialValue)</span><span id="fd2a" class="mg la in ks b gy mw mi l mj mk">// <strong class="ks io">using arrow functions instead </strong></span><span id="0250" class="mg la in ks b gy mw mi l mj mk">the_array.reduce((acc, cur) =&gt; {</span><span id="8130" class="mg la in ks b gy mw mi l mj mk">// do some stuff...</span><span id="ba03" class="mg la in ks b gy mw mi l mj mk">}, initialValue)</span></pre><p id="ef45" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">累加器</strong>类似于复利的<strong class="jt io">本金</strong>，在这个意义上，在每次迭代之后，它都会改变。新值成为下一次迭代的累加器。<strong class="jt io">当前值</strong>类似于复利中的利息，在这个意义上，每次迭代后，它都被“添加”到<strong class="jt io">累加器</strong>中。(注意:我们可以执行除加法之外的其他操作)。</p><h1 id="82ce" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">请给我一些代码！</h1><p id="087e" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">如果你还在读这篇文章，那么我必须称赞你的耐心。那是一堆无代码的文本。现在让我们编写一些代码来实现reduce方法。</p><p id="4d76" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">要使用<code class="fe kp kq kr ks b">reduce</code>方法，让我们尝试获取<code class="fe kp kq kr ks b">balls</code>数组中所有评级的总和。为了简化，让我们从上面map方法中的tags数组开始。</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="be39" class="mg la in ks b gy mh mi l mj mk">console.log(tags)<br/>// returns [5, 4, 2, 3]</span></pre><p id="3cb2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">简化方法应用如下:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="d49b" class="mg la in ks b gy mh mi l mj mk">let sumOfRatings = tags.reduce((acc, cur) =&gt; acc + cur, 0)</span><span id="6555" class="mg la in ks b gy mw mi l mj mk">console.log(sumOfRatings)<br/>// returns 14</span></pre><p id="94ab" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">累加器的初始值(<code class="fe kp kq kr ks b">acc</code>)为0，当我们遍历数组时，数组中的每个元素都是当前值(<code class="fe kp kq kr ks b">cur</code>)，这个值被添加到累加器中。累加器的新值将用于循环的下一次迭代，到循环结束时，累加器的值将被返回。</p><p id="d204" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">简单测验</strong>:如果初始值设为6会返回什么？</p><h1 id="e241" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">请再举一个例子…</h1><p id="4e08" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">假设我们有一个更大的球阵列:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="f526" class="mg la in ks b gy mh mi l mj mk">const balls = [<br/> {brand: 'Adidas', color: 'blue', rating: 5},<br/> {brand: 'Konami', color: 'red', rating: 4},<br/> {brand: 'Verah', color: 'blue', rating: 2},<br/> {brand: 'Adidas', color: 'green', rating: 3},<br/> {brand: 'Konami', color: 'white', rating: 1},<br/> {brand: 'Adidas', color: 'blue', rating: 2},<br/> {brand: 'Verah', color: 'yellow', rating: 1},<br/> {brand: 'Verah', color: 'green', rating: 2},<br/> {brand: 'Adidas', color: 'blue', rating: 5},<br/> {brand: 'Konami', color: 'red', rating: 4},<br/> {brand: 'Adidas', color: 'green', rating: 3},<br/> {brand: 'Konami', color: 'pink', rating: 1},<br/>]</span></pre><p id="c0c7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">假设我们想要获得每个品牌出现的次数，我们可以使用reduce方法:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="013b" class="mg la in ks b gy mh mi l mj mk">const brandFrequency = balls.reduce((acc, cur)=&gt; {<br/>let count = acc[cur.brand] || 0 <br/>  return {<br/>    ...acc,<br/>    [cur.brand]: count + 1<br/>  }<br/>}, {})</span><span id="7c0b" class="mg la in ks b gy mw mi l mj mk">console.log(brandFrequency)<br/>//returns <em class="ml">{Adidas: 5, Konami: 4, Verah: 3}</em></span></pre><p id="48dc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意，初始值是一个空对象。这是<code class="fe kp kq kr ks b">acc</code>论点的第一个价值。</p><p id="70d6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我对下面的每一行都做了解释:</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="484b" class="mg la in ks b gy mh mi l mj mk">...<br/>let count = acc[cur.brand] || 0<br/>...</span></pre><p id="67c7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这一行意味着，每次我们都要检查一个品牌是否已经“累积”到<code class="fe kp kq kr ks b">acc</code>中，并且有一个计数值，如果没有，我们将其计数设置为0。</p><pre class="kt ku kv kw gt mc ks md me aw mf bi"><span id="9100" class="mg la in ks b gy mh mi l mj mk">return {<br/>    ...acc,<br/>    [cur.brand]: count + 1<br/>  }</span></pre><p id="af0c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上面的行意味着在每次迭代后，我们返回一个包含累加器当前值的对象<strong class="jt io">并且</strong>我们包含一个品牌并增加它的计数1。如果品牌已经存在于acc对象中，则不会重新包括它，它的计数只增加1。</p><h1 id="339e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="9407" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated"><code class="fe kp kq kr ks b">filter</code>、<code class="fe kp kq kr ks b">map</code>和<code class="fe kp kq kr ks b">reduce</code>数组方法使得编写简洁的代码成为可能。它们是为了使开发人员的工作更容易而不是让他沮丧而引入的工具。</p><p id="8582" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我希望我能帮助澄清一些事情。</p><p id="7278" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">快乐编码。</p><p id="2d2c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">感谢您阅读至此。如果你喜欢这篇文章，请分享、评论并发表👏几次(最多50次)。。。也许会对某个人有帮助。</strong></p><p id="80e8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">关注我的</strong><a class="ae ni" href="https://twitter.com/solathecoder" rel="noopener ugc nofollow" target="_blank"><strong class="jt io">Twitter</strong></a><strong class="jt io">和Medium，如果你将来对这些更深入、更翔实的报道感兴趣的话！</strong></p></div></div>    
</body>
</html>