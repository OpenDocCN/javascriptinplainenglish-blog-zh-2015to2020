<html>
<head>
<title>Differences between Redux and MobX in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中Redux和MobX的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/my-take-on-redux-and-mobx-in-react-7585470429f9?source=collection_archive---------3-----------------------#2020-01-30">https://javascript.plainenglish.io/my-take-on-redux-and-mobx-in-react-7585470429f9?source=collection_archive---------3-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7172" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React应用中Redux和MobX的状态管理有何不同？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/19cc94c2ba0223b7730b678084516e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zyrhe4IvFKJTPGps"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@greg_rosenke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Greg Rosenke</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6b4e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><blockquote class="lo lp lq"><p id="be25" class="lr ls lt lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">用于构建用户界面的JavaScript库</p></blockquote><p id="98a9" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">这是React登录页面的副标题，巧妙地表达了它的主要关注点——以高效的方式呈现组件，如果你在他们的主页上做更多的阅读，也会强调这一点。</p><blockquote class="lo lp lq"><p id="c057" class="lr ls lt lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">为应用程序中的每个状态设计简单的视图，当数据发生变化时，React将有效地更新和呈现正确的组件。</p></blockquote><p id="37bc" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">对于开发人员来说，这意味着框架不提供管理应用程序状态的实际方式，而只提供本地组件状态。这可能是一件好事，也可能是一件坏事，这取决于你的经历——高年级学生可以自由地做他喜欢的事情，而新手则必须努力，因为国家管理可能是一项非常艰巨的任务。</p><p id="ef1a" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">对于小型应用程序来说，只使用本地组件状态可能没什么问题，特别是添加了<code class="fe mr ms mt mu b">Context API</code>之后，我们就不用再深入到单个组件了。但是仍然有一个缺点——状态仍然依赖于单个组件，如果应用程序超出了最初的小范围，这可能会变成一堆蠕虫。</p><p id="dd07" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">在<code class="fe mr ms mt mu b">React</code>应用程序中有两个流行的管理状态的库:<code class="fe mr ms mt mu b">Redux</code>和<code class="fe mr ms mt mu b">MobX</code>，每个都有自己的方法，但是有一个共同的目标——用一个不太麻烦的工作流将状态从单个组件中分离出来。</p><p id="b49d" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">让我们看一下每个图书馆的购物车示例。用户可以查看可用的商品并将它们添加到购物车中。可以添加多个相同类型的商品，它们可以从商品视图和购物车视图中删除。为了简单起见，两个视图都在一个页面上，尽管它们在不同的页面上不会改变任何事情。完整的源代码可以在<a class="ae kv" href="https://github.com/MustSeeMelons/react-state-party" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/06d4e464ea05a172a3716e400d5aa967.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*QNF9dN7x6L5exXpFceD7xQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">the greatly designed app</figcaption></figure><h1 id="0487" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Redux</h1><p id="3671" class="pw-post-body-paragraph lr ls iq lu b lv mw jr lx ly mx ju ma mo my md me mp mz mh mi mq na ml mm mn ij bi translated">它提供了一种严格但简单的管理状态的方法，要使一切工作正常，需要创建相当多的文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/dd0e74c25a0a9e61b36406e3b8aab057.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*81SSjrFROtv9usWDF-jWJA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">all the required files</figcaption></figure><p id="9ff9" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">流程本身非常简单:</p><ul class=""><li id="72a7" class="nc nd iq lu b lv lw ly lz mo ne mp nf mq ng mn nh ni nj nk bi translated">用户界面是从包含状态的单个store对象派生的</li><li id="4332" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated">该接口分派动作来发出状态变化的信号</li><li id="1d50" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated">动作由派生新状态的reducers处理</li><li id="b1bd" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated">用户界面是从更新后的状态中导出的</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/adb91289f5f545b6bc79f575de53d731.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*v003AP04chB75oZYL970rQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">redux flow</figcaption></figure><p id="8109" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">有几件事要记住，否则，你可能会过得不好:</p><ul class=""><li id="90fd" class="nc nd iq lu b lv lw ly lz mo ne mp nf mq ng mn nh ni nj nk bi translated">还原剂必须是纯功能的，没有副作用</li><li id="4794" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated">状态不能在还原器内(或任何其他地方)突变</li></ul><p id="5425" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">现在是编写代码的时候了，让我们看看如何向购物车添加商品，从以下操作开始:</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="e921" class="nv kx iq mu b gy nw nx l ny nz">export <strong class="mu ir">const</strong> addToCart = <strong class="mu ir">function</strong>(item) {<br/>    return {<br/>        type: "add_to_cart",<br/>        payload: {<br/>            item<br/>        }<br/>    };<br/>};</span></pre><p id="6428" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">当我们将一个组件连接到商店时，返回一个可分派的动作，稍后使用，下一步—缩减器:</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="08ac" class="nv kx iq mu b gy nw nx l ny nz"><strong class="mu ir">const</strong> cartReducer = <strong class="mu ir">function</strong>(state = {<br/>    items: {}<br/>}, action) {<br/>    <strong class="mu ir">const</strong> itemId = action.payload &amp;&amp; action.payload.item.id;<br/>    if (itemId === undefined) {<br/>        return state;<br/>    }</span><span id="973a" class="nv kx iq mu b gy oa nx l ny nz"><strong class="mu ir">const</strong> item = state.items[itemId];<br/>    switch (action.type) {<br/>        case "add_to_cart":<br/>            if (item) {<br/>                <strong class="mu ir">const</strong> copy = {<br/>                    ...state<br/>                };<br/>                copy.items[itemId].count++;<br/>                return copy;<br/>            } else {<br/>                <strong class="mu ir">const</strong> copy = {<br/>                    ...state<br/>                };<br/>                copy.items[itemId] = {<br/>                    ...action.payload.item,<br/>                    count: 1<br/>                };<br/>                return copy;<br/>            }<br/>        default:<br/>            return state;<br/>    }<br/>};</span><span id="f6d4" class="nv kx iq mu b gy oa nx l ny nz">export { cartReducer };</span></pre><p id="adf7" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">在reducer中，我们检查动作类型，然后在我们的状态中添加一个新的条目，或者更新现有的条目，非常重要的是不要更新传入的状态对象，而是返回一个新的。</p><p id="910c" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">差不多了，现在我们必须创建商店，这是一个非常简单的考验，我们只需将所有的reducers传递给它。</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="3e74" class="nv kx iq mu b gy nw nx l ny nz">export <strong class="mu ir">const</strong> store = createStore(<br/>    combineReducers({<br/>        itemReducer,<br/>        cartReducer<br/>    })<br/>);</span></pre><p id="d64b" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">接下来，我们需要将我们的应用程序封装在一个<code class="fe mr ms mt mu b">Provider</code>组件中，该组件将我们的存储作为一个参数，目前它本身并没有做太多事情。</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="16d1" class="nv kx iq mu b gy nw nx l ny nz"><strong class="mu ir">function</strong> ReduxApp() {<br/>    return (<br/>        &lt;Provider store={store}&gt;<br/>            &lt;div className="App"&gt;<br/>            &lt;header className="App-header"&gt;<br/>                &lt;div&gt;This is the Redux barn&lt;/div&gt;<br/>            &lt;/header&gt;<br/>            &lt;ReduxList /&gt;<br/>            &lt;ReduxCart /&gt;<br/>            &lt;/div&gt;<br/>        &lt;/Provider&gt;<br/>    );<br/>}</span></pre><p id="a076" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">我们需要从状态中获取某些东西的组件，或者需要能够分派动作的组件必须被包装在<code class="fe mr ms mt mu b">connect</code>组件中，这将把我们想要的一切注入到我们的<code class="fe mr ms mt mu b">props</code>中。</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="6508" class="nv kx iq mu b gy nw nx l ny nz"><strong class="mu ir">// A component like any other component<br/>const</strong> ReduxItemList = props <strong class="mu ir">=&gt;</strong> {<br/>    return (<br/>        &lt;div&gt;<br/>        {props.items.map((item, index) <strong class="mu ir">=&gt;</strong> {<br/>            return (<br/>                &lt;Item<br/>                    key={index}<br/>                    item={item}<br/>                    onAdd={props.addToCart}<br/>                    onRemove={props.removeFromCart}<br/>                    contained={props.contains[item.id]}<br/>                    amounts={props.amounts}<br/>                /&gt;<br/>            );<br/>        })}<br/>        &lt;/div&gt;<br/>    );<br/>};</span><span id="9315" class="nv kx iq mu b gy oa nx l ny nz"><strong class="mu ir">// helper for creating props, from the state<br/>const</strong> mapStateToProps = state <strong class="mu ir">=&gt;</strong> {<br/>    return {<br/>        items: state.itemReducer.items,<br/>        contains: ItemInCartCheckSelector(state),<br/>        amounts: CartItemAmountSelector(state)<br/>    };<br/>};</span><span id="decb" class="nv kx iq mu b gy oa nx l ny nz"><strong class="mu ir">// helper for creating props, which can dispatch actions<br/>const</strong> mapDispatchToProps = dispatch <strong class="mu ir">=&gt;</strong> {<br/>    return {<br/>        addToCart: item <strong class="mu ir">=&gt;</strong> <br/>          dispatch({ type: "add_to_cart", payload: { item } }),<br/>    };<br/>};</span><span id="06ae" class="nv kx iq mu b gy oa nx l ny nz"><strong class="mu ir">// putting it all together, and exporting<br/>const</strong> ConnectedReduxItemList = connect(<br/>    mapStateToProps,<br/>    mapDispatchToProps<br/>)(ReduxItemList);</span><span id="8057" class="nv kx iq mu b gy oa nx l ny nz">export { ConnectedReduxItemList as ReduxList };</span></pre><p id="ba1f" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated"><em class="lt">重要提示:由于我们有多个reducer，我们必须使用</em> <code class="fe mr ms mt mu b"><em class="lt">combineReducers</em></code> <em class="lt">函数，它将从reducer子状态创建整个应用程序状态，映射到每个reducer的名称。</em></p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="3d65" class="nv kx iq mu b gy nw nx l ny nz">state = {<br/>    itemReducer: { items: []},<br/>    cartReducer: {items: {}<br/>}</span></pre><p id="c843" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">您可能已经注意到我们也有一个<code class="fe mr ms mt mu b">selectors</code>文件，这个文件有可选的函数，用于从状态中导出一些东西，例如，我们在购物车中有多少每种类型的商品。</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="8cc7" class="nv kx iq mu b gy nw nx l ny nz">export <strong class="mu ir">const</strong> CartItemAmountSelector = state <strong class="mu ir">=&gt;</strong> {<br/>    return state.itemReducer.items.reduce((acc, cartItem) <strong class="mu ir">=&gt;</strong> {<br/>        acc[cartItem.id] = state.cartReducer.items[cartItem.id]<br/>          ? state.cartReducer.items[cartItem.id].count<br/>          : 0;</span><span id="7c90" class="nv kx iq mu b gy oa nx l ny nz">return acc;<br/>    }, {});<br/>};</span></pre><p id="9958" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">咻，这么简单的事情却有这么多代码！在现实世界中，每个reducer都有自己的动作和选择器文件，进一步增加了样板代码。</p><h1 id="81ac" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">MobX</h1><blockquote class="lo lp lq"><p id="56c6" class="lr ls lt lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">任何可以从应用程序状态派生的东西都应该被派生。自动地。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/58b4bc8225ba589f1a6c73b5990f5d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W30WDoSgLxkJ-104IRy0Eg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">nice flow diagram from the documentation</figcaption></figure><p id="ba2b" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">乍看之下，流程看起来非常相似:</p><ul class=""><li id="30b4" class="nc nd iq lu b lv lw ly lz mo ne mp nf mq ng mn nh ni nj nk bi translated">该接口是从状态派生的</li><li id="2309" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated">动作改变状态</li><li id="21db" class="nc nd iq lu b lv nl ly nm mo nn mp no mq np mn nh ni nj nk bi translated">一个新的接口被导出</li></ul><p id="ec86" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">从完全相同的功能所需的文件开始，执行过程有很大的不同:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c4c48ada246767e1c53030651f221119.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*iayttLOQJFiSLKRvpKDGWA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">huh, one file?</figcaption></figure><p id="5e06" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">MobX也需要一个存储来存储数据，尽管您并不局限于一个——您可以创建任意多个，甚至可以是单例。</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="ecb0" class="nv kx iq mu b gy nw nx l ny nz">import { observable, action, toJS, computed } from "mobx";</span><span id="917b" class="nv kx iq mu b gy oa nx l ny nz"><strong class="mu ir">class</strong> CartState {<br/>    @observable items = {};<br/>    <br/>    @action addItem = item <strong class="mu ir">=&gt;</strong> {<br/>        <strong class="mu ir">const</strong> itemCopy = toJS(this.items);<br/>        if (itemCopy[item.id]) {<br/>            itemCopy[item.id].count++;<br/>        } else {<br/>           itemCopy[item.id] = {<br/>               ...item,<br/>               count: 1<br/>           };<br/>        }<br/>        <br/>        this.items = itemCopy;<br/>    };</span><span id="2c12" class="nv kx iq mu b gy oa nx l ny nz">@action removeItem = item <strong class="mu ir">=&gt;</strong> {<br/>        <strong class="mu ir">const</strong> itemCopy = toJS(this.items);<br/>        if (itemCopy[item.id].count === 1) {<br/>            delete itemCopy[item.id];<br/>        } else {<br/>            itemCopy[item.id].count--;<br/>        }<br/>        this.items = itemCopy;<br/>    };</span><span id="ebf7" class="nv kx iq mu b gy oa nx l ny nz">@computed <strong class="mu ir">get</strong> totalAmount() {<br/>        return (<br/>            Object.keys(this.items).reduce((acc, key) <strong class="mu ir">=&gt;</strong> {<br/>                <strong class="mu ir">const</strong> item = this.items[key];<br/>                return acc + item.price * item.count;<br/>            }, 0) || 0);<br/>    }<br/>}</span><span id="1600" class="nv kx iq mu b gy oa nx l ny nz"><strong class="mu ir">const</strong> instance = new CartState();<br/>export { instance as CartState };</span></pre><p id="f490" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">理想情况下，我们使用<code class="fe mr ms mt mu b">decorators</code>来标记函数，但是它们也可以被包装。我们希望组件能够观察的属性必须标记为<code class="fe mr ms mt mu b">observable</code>。如果一个方法改变了状态，它必须用<code class="fe mr ms mt mu b">action</code>标记，如果我们想从状态中计算一些东西，我们将getter函数标记为<code class="fe mr ms mt mu b">computed</code>。我们正在实现同样的功能，但是代码要少得多。</p><p id="1116" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">如果存储是单例的，那么组件中的用法可能太简单了:</p><pre class="kg kh ki kj gt nr mu ns nt aw nu bi"><span id="7d4a" class="nv kx iq mu b gy nw nx l ny nz"><strong class="mu ir">const</strong> MobXItemList = observer(() <strong class="mu ir">=&gt;</strong> {<br/>    return (<br/>        &lt;div&gt;<br/>        {ItemListState.items.map((item, index) <strong class="mu ir">=&gt;</strong> {<br/>             return (<br/>                 &lt;Item<br/>                     key={index}<br/>                     item={item}<br/>                     amounts={ItemListState.itemAmounts}<br/>                     onAdd={() <strong class="mu ir">=&gt;</strong> {<br/>                         CartState.addItem(item);<br/>                     }}<br/>                     onRemove={() <strong class="mu ir">=&gt;</strong> {<br/>                         CartState.removeItem(item);<br/>                     }}<br/>                 /&gt;<br/>             );<br/>         })}<br/>        &lt;/div&gt;<br/>    );<br/>});</span></pre><h1 id="f674" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="693c" class="pw-post-body-paragraph lr ls iq lu b lv mw jr lx ly mx ju ma mo my md me mp mz mh mi mq na ml mm mn ij bi translated">看完这些代码样本后，可能看起来<code class="fe mr ms mt mu b">MobX</code>是正确的选择，但是生活中总是如此——它并不那么简单，有一些事情需要记住。</p><p id="2945" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">虽然<code class="fe mr ms mt mu b">Redux</code>的明确性对于这样一个简单的购物车应用程序来说有些过分，但它对于大型应用程序来说却是天赐之物，因为它更容易跟踪数据流，因为您知道自己在寻找什么:<code class="fe mr ms mt mu b">actions</code>、<code class="fe mr ms mt mu b">reducers</code>、<code class="fe mr ms mt mu b">selectors</code>。</p><p id="2411" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">对于<code class="fe mr ms mt mu b">MobX</code>来说，情况正好相反——对于参与人员较少的小型应用程序，如果他们都同意如何实例化和使用存储，它可以加快开发速度并保持代码非常整洁和少量——灵活性带来了更多的责任。</p><p id="e977" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">然而，这并不意味着应该避免使用本地状态——在必要的时候仍然应该使用本地状态，但在redux/mobx中，例如表单输入字段，除非某些业务需求强制使用本地状态。</p><p id="e52a" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated">重要提示——<code class="fe mr ms mt mu b">Redux</code>有一个令人惊叹的Chrome/FF插件叫做<code class="fe mr ms mt mu b">ReduxDevTools</code>，用于检查应用程序状态、分派的动作，甚至是整个状态的树形图，与之相对应的<code class="fe mr ms mt mu b">MobX</code>也存在，但相比之下就相形见绌了。</p><p id="7b60" class="pw-post-body-paragraph lr ls iq lu b lv lw jr lx ly lz ju ma mo mc md me mp mg mh mi mq mk ml mm mn ij bi translated"><strong class="lu ir"><em class="lt">TL；DR: </em> </strong> <em class="lt">小型应用程序可以从</em> <code class="fe mr ms mt mu b"><em class="lt">MobX</em></code> <em class="lt">中获得健康的生产力提升，而</em> <code class="fe mr ms mt mu b"><em class="lt">Redux</em></code> <em class="lt">将帮助您在处理大型应用程序时保持头脑清醒。</em></p></div></div>    
</body>
</html>