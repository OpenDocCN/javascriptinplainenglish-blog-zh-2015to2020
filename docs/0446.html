<html>
<head>
<title>Comparing Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较JavaScript中的对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/comparing-objects-in-javascript-ce2dc1f3de7f?source=collection_archive---------0-----------------------#2019-10-17">https://javascript.plainenglish.io/comparing-objects-in-javascript-ce2dc1f3de7f?source=collection_archive---------0-----------------------#2019-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么可行，什么不可行，为什么。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/99f919282e3a410a27229bf942d7ebae.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*E9UjeNpqRaHlgki6losYYw.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Photo courtesy of theubercloud.com</figcaption></figure><blockquote class="kr"><p id="7588" class="ks kt iq bd ku kv kw kx ky kz la lb dk translated">比较对象是否相等很容易，但判断它们是否包含相同的键和值就不那么容易了。但是为什么呢？</p></blockquote><blockquote class="lc ld le"><p id="be88" class="lf lg lh li b lj lk jr ll lm ln ju lo lp lq lr ls lt lu lv lw lx ly lz ma lb ij bi translated">我的目标是解释为什么确定两个对象是否包含相同的值会很困难。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="2fbf" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">为什么解释一个问题。就给我解决方案？</h2><p id="34de" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated">因为了解什么是困难的或不起作用的，可以让我们更深刻地理解为什么，并经常引导我们寻找或开发将起作用的解决方案。这个故事的结尾有一个很棒的视频链接。</p><h2 id="d1cb" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">原始数据类型与引用(非原始)类型</h2><p id="4f02" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated">本质上，它与JavaScript原语和JavaScript非原语(对象)有关。</p><blockquote class="lc ld le"><p id="99f2" class="lf lg lh li b lj nj jr ll lm nk ju lo lp nl lr ls lt nm lv lw lx nn lz ma lb ij bi translated">正如我将要演示的，通过代码和类比，包含原始类型的变量在内存中被赋予一个<strong class="li ir">值</strong>。包含非原始类型的变量在内存中被赋予一个<strong class="li ir">引用</strong>。</p></blockquote><h2 id="fb3b" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated"><strong class="ak">原语类型和内存分配</strong></h2><p id="fe24" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated"><strong class="li ir">例1 </strong></p><p id="2b99" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">简单来说，基本类型是数字、字符串、布尔、未定义和空。完整列表可在<a class="ae no" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/37c2f87a08c412602403c227b4526f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*L_Yn89Ntf9iJU4iV2H4S0Q.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Primitives have a value in memory</figcaption></figure><p id="037a" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">发生什么事了？对于任何原语，都会分配内存，原语的值存储在该内存位置。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="23ab" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">借用一个常见的类比，假设我把数字1写在一张便笺条上，并把它放在白板上。它提醒我自己，我今天有一个任务。(当然，我可以编写任务，但让我们保持简单。)</p><p id="1e42" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">我的办公室伙伴在便利贴上写下数字1来提醒自己开会的时间，并把它写在白板上。</p><p id="1317" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">便笺是不同的，每个便笺都包含自己的值。</p><p id="629e" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><em class="lh">把每张便笺想象成分配的内存，把数字想象成存储在分配的内存中的值。在这种情况下，进行比较时，它们包含相同的值1。</em></p><blockquote class="lc ld le"><p id="c119" class="lf lg lh li b lj nj jr ll lm nk ju lo lp nl lr ls lt nm lv lw lx nn lz ma lb ij bi translated">当我们比较原语时，我们比较存储在内存位置的值。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="cdbd" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">如果我得到一个新任务，并将我的便笺条更改为2，那么它不会影响其他便笺条。他们各有各的价值。</p><p id="69cb" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><strong class="li ir">例2 </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/bbe0cddcfc744d4d9a3bc6b261ce35ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*UnCG-FYeMX_KGx4Wf0yqxQ.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Each has their own memory allocation</figcaption></figure><p id="3646" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">变量a被分配了内存，并被赋予值1。变量b有自己的内存空间，变量a的值为1。<strong class="li ir">它不指向a，它独立于a，包含它自身的价值。</strong></p><p id="153f" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">所以当变量a改变时，变量b保持不变。</p><blockquote class="lc ld le"><p id="2544" class="lf lg lh li b lj nj jr ll lm nk ju lo lp nl lr ls lt nm lv lw lx nn lz ma lb ij bi translated">在JavaScript中，每个原语在声明时都有自己的内存空间。当分配一个值时，该值进入内存空间。</p></blockquote><h2 id="aa30" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">引用类型和内存分配</h2><p id="3175" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated">简单地说，引用类型是对象、函数和数组，统称为对象。更多信息可在<a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="e99f" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><strong class="li ir">例三</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/cc793b5423741a254ffe51557ad34c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*lohNpaT86RFwhVgGlfdYUw.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">The variables obj1 and obj2 contain a reference. Each to a separate memory location.</figcaption></figure><p id="0d63" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">这里需要理解的重要一点是，变量obj1和obj2(可以是对象、数组或函数)都只包含对内存中某个位置的引用。而不是对象的值。</p><p id="430a" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><em class="lh">地点分开，所以参照物不一样，比较失败。我们不是在比较对象的值，而是比较对它们的内存位置的引用。</em></p><blockquote class="lc ld le"><p id="5e7a" class="lf lg lh li b lj nj jr ll lm nk ju lo lp nl lr ls lt nm lv lw lx nn lz ma lb ij bi translated">所以对于JavaScript引用类型，当对象被声明时，我们得到内存中的分配，但是变量只得到对内存中对象位置的引用，而不是它的值。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="c7bc" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">回到我们的便利贴类比。</p><p id="919d" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">如果我决定创建一个任务列表(不是原始的)并把它放在我的桌子上，白板上的便笺包含了告诉我去哪里找列表的信息，而不是列表本身。</p><p id="3922" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">便利贴包含类似“看桌子上，左下角”的信息</p><p id="72d1" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">如果我决定创建第二个任务列表，并把它放在我的桌子上，另一个便利贴被放在白板上，告诉我在哪里可以找到第二个列表，“在桌子上，右下角。)</p><p id="8ac8" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><strong class="li ir">如果我比较白板上的便条信息，它们是不相等的。</strong></p><p id="5a86" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">因此，即使任务列表2与任务列表1相同(相同或不同的顺序)，引用也是不同的，它们也不会相等。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h2 id="9b5f" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">分配引用类型</h2><p id="2c60" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated">如果你还记得在例子2中，我们给变量a赋了一个原语，然后给变量b赋了变量a中的值。</p><p id="2fcc" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">因为每个都有自己的内存空间，改变变量a的值，并不会改变变量b的值。</p><p id="e924" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">对于引用类型，情况就不同了。</p><p id="838b" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><strong class="li ir">例4 </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/20f32e86b1601c836d1edeca22e4fd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*DKlWGwRjnKqLKhbPU2q8LQ.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Both variables contain the same information, a reference to the object’s location.</figcaption></figure><p id="24dd" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">在这种情况下，它们是相等的，因为变量包含相同的信息，对内存中对象位置的相同引用。</p><p id="7c92" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><em class="lh">用便利贴类比，就好像我在白板上有两张便利贴告诉我去哪里找原来的清单(在书桌上，左下角。)它们包含相同的信息，所以是相等的。</em></p><p id="cf08" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><strong class="li ir">例5 </strong></p><p id="cac2" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">更改obj1或obj2的值会更改另一个，因为它们都指向同一个对象。(与实施例2相比。)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/cb0d1d1a08d65e5d5a2880177fd9b40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*zxTqSt274KzZ-bcWuYhXUQ.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">They both have the same reference to the same object.</figcaption></figure><h2 id="67b4" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">我们如何比较物体？</h2><p id="cecd" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated"><strong class="li ir"> <em class="lh">比较对象</em> </strong> <em class="lh"> </em>很容易，用===或<a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank"> Object.is() </a>。如果它们具有相同的引用，则该函数返回true，否则返回false。</p><p id="40a9" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">让我再次强调，这是比较对对象的引用，而不是对象的键和值。</p><p id="893b" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">所以，从例3来看，<em class="lh"> Object.is(obj1，obj 2)；会返回false </em>。例4中，<em class="lh"> Object.is(obj1，obj 2)；会返回true </em>。</p><p id="4831" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">因此，即使两个对象包含相同的数据，除非变量包含对同一对象的引用，否则===和Object.is()将返回false。</p><p id="d84c" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><strong class="li ir"> <em class="lh">比较对象键和值</em> </strong>比较复杂。</p><h2 id="1543" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">可能简单的解决方案</h2><p id="d9e2" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated">一个可能的简单解决方案是JSON.stringify将对象格式化，然后比较字符串。如果键的顺序相同，这样做很好。然而，这不能保证。此外，您正在比较字符串，而不是对象。</p><h2 id="d3fd" class="mi mj iq bd mk ml mm dn mn mo mp dp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">另一个想法</h2><p id="9ec4" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated">正确的一步是使用<a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" rel="noopener ugc nofollow" target="_blank"> Object.keys() </a>和<a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Object/values" rel="noopener ugc nofollow" target="_blank"> Object.values() </a>。或者<a class="ae no" href="https://javascript.info/keys-values-entries" rel="noopener ugc nofollow" target="_blank"> Object.entries()。</a></p><h1 id="0ac1" class="nu mj iq bd mk nv nw nx mn ny nz oa mq jw ob jx mu jz oc ka my kc od kd nc oe bi translated">结论</h1><p id="e52c" class="pw-post-body-paragraph lf lg iq li b lj ne jr ll lm nf ju lo mr ng lr ls mv nh lv lw mz ni lz ma lb ij bi translated">所以我们已经看到，比较两个对象不仅仅是看变量。这些变量只包含引用。</p><p id="20d6" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">确定它们是否包含相同的值可能是一个复杂的过程。</p><p id="67da" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">我强烈推荐这个关于以编程方式确定两个对象值是否相等的视频。</p><p id="4467" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated"><a class="ae no" href="https://www.youtube.com/watch?v=GgfIby_T8yg" rel="noopener ugc nofollow" target="_blank"> JS教程:求两个对象值是否相等</a></p><p id="2be1" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">以及查看下面的npm包。<a class="ae no" href="https://www.npmjs.com/package/lodash.isequal" rel="noopener ugc nofollow" target="_blank"> Lodash </a>的，_。isEqual()。</p><p id="c515" class="pw-post-body-paragraph lf lg iq li b lj nj jr ll lm nk ju lo mr nl lr ls mv nm lv lw mz nn lz ma lb ij bi translated">感谢阅读和快乐编码！</p></div></div>    
</body>
</html>