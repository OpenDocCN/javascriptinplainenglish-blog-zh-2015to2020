<html>
<head>
<title>The 6 phases of the Node.js event loop explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了Node.js事件循环的6个阶段</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-event-loop-explained-d27647ec8d53?source=collection_archive---------0-----------------------#2020-09-29">https://javascript.plainenglish.io/node-js-event-loop-explained-d27647ec8d53?source=collection_archive---------0-----------------------#2020-09-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="64c0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">不同的阶段和每个阶段处理的任务</h2></div><p id="1e05" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们先来看一段代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="830d" class="lh li in ld b gy lj lk l ll lm">setImmediate(()=&gt; console.log('setImmediate'));</span><span id="58f3" class="lh li in ld b gy ln lk l ll lm">fs.readFile('/etc/passwd',(err, data)=&gt;{<br/>  console.log('reading file');<br/>}); </span><span id="a4c4" class="lh li in ld b gy ln lk l ll lm">console.log('start');</span><span id="edba" class="lh li in ld b gy ln lk l ll lm">process.nextTick(()=&gt; console.log('nextTick'));</span><span id="1963" class="lh li in ld b gy ln lk l ll lm">setTimeout(()=&gt;console.log('setTimeout 1'), 0);</span><span id="a25d" class="lh li in ld b gy ln lk l ll lm">setTimeout(()=&gt;console.log('setTimeout 2'), 3);</span><span id="2439" class="lh li in ld b gy ln lk l ll lm">let counter = 0;<br/>const timeout = setInterval(() =&gt; {<br/>    console.log('setInterval');<br/>    if (counter &gt;= 3) {<br/>        console.log('exiting setInterval');<br/>        clearInterval(timeout);<br/>    }<br/>    counter++;<br/>}, 0);</span><span id="330f" class="lh li in ld b gy ln lk l ll lm">new Promise((resolve, reject)=&gt; {<br/>  console.log('start promise 1');<br/>  resolve('Promise 1');<br/>}).then(data=&gt; {<br/>  console.log(data);<br/>})</span><span id="1a15" class="lh li in ld b gy ln lk l ll lm">console.log('end');</span></pre><p id="2feb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个程序的输出会是什么？</p><p id="8ef0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了回答这个问题，我们需要了解两件事:</p><ul class=""><li id="40f0" class="lo lp in ke b kf kg ki kj kl lq kp lr kt ls kx lt lu lv lw bi translated">事件循环中的不同阶段。</li><li id="8ae1" class="lo lp in ke b kf lx ki ly kl lz kp ma kt mb kx lt lu lv lw bi translated">每个阶段将处理的任务。</li></ul><h1 id="7e95" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">6个阶段</h1><p id="34ca" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">当Node.js在主线程中执行完index.js时，Node.js事件循环开始执行在主线程运行时注册的回调。</p><figure class="ky kz la lb gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi my"><img src="../Images/99652a41a7116cf8b0cdc2135a1b1768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZlD-iqmcgSWEHptT.png"/></div></div></figure><h1 id="087f" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">回调队列</h1><p id="ec19" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">每个阶段都有一个回调队列，存储该阶段要执行的回调。和浏览器提供的<a class="ae ng" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" rel="noopener ugc nofollow" target="_blank">任务队列</a>很像。</p><h1 id="6da7" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">定时器</h1><p id="9a29" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">这是事件循环的第一阶段。它在每次迭代(也称为Tick)中查找过期的计时器，并执行由<code class="fe nh ni nj ld b">setTimout</code>和<code class="fe nh ni nj ld b">setInterval</code>创建的计时器回调。</p><p id="89bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7b91" class="lh li in ld b gy lj lk l ll lm">setTimeout(() =&gt; console.log('Timeout 1'), 0);</span><span id="7124" class="lh li in ld b gy ln lk l ll lm">setTimeout(() =&gt; console.log('Timeout 2'), 10);</span></pre><p id="3f3b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nh ni nj ld b">Timeout 1</code>将在第一次迭代中打印，因为第一个计时器在0毫秒后到期。但是，<code class="fe nh ni nj ld b">Timeout 2</code>将在另一次迭代中打印(不一定在第二次迭代中)，因为第二个定时器在10ms后到期。</p><h1 id="649b" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">待定回调</h1><p id="6135" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">它处理推迟到下一次迭代的I/O回调，例如处理TCP套接字连接错误。</p><h1 id="e2fb" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">空闲，准备</h1><p id="4d01" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">它只在内部使用。</p><h1 id="c65c" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">投票</h1><p id="7c3d" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">轮询阶段计算每次迭代中处理I/O回调的阻塞时间。在这个阶段，调用<code class="fe nh ni nj ld b">epoll_wait()</code>系统调用(在Linux中)。</p><h1 id="0689" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">支票</h1><p id="fb81" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">这个阶段处理<code class="fe nh ni nj ld b">setImmediate()</code>安排的回调，一旦轮询阶段空闲，回调就会被执行。</p><h1 id="b039" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">关闭回拨</h1><p id="236c" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">如果套接字或句柄突然关闭，这个阶段将处理回调，并且将发出“close”事件。</p><h1 id="5bb6" class="mc li in bd md me mf mg mh mi mj mk ml jt mm ju mn jw mo jx mp jz mq ka mr ms bi translated">微任务队列</h1><p id="579c" class="pw-post-body-paragraph kc kd in ke b kf mt jo kh ki mu jr kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">微任务队列存储由以下各项创建的微任务(回调):</p><ul class=""><li id="140b" class="lo lp in ke b kf kg ki kj kl lq kp lr kt ls kx lt lu lv lw bi translated"><code class="fe nh ni nj ld b">process.nextTick()</code></li><li id="5a62" class="lo lp in ke b kf lx ki ly kl lz kp ma kt mb kx lt lu lv lw bi translated"><code class="fe nh ni nj ld b">then()</code>和<code class="fe nh ni nj ld b">catch()</code>处理已解决和拒绝的承诺</li></ul><p id="ee7e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">微任务在主线程和事件循环的每个阶段之后执行。由<code class="fe nh ni nj ld b">process.nextTick()</code>创建的微任务在由<code class="fe nh ni nj ld b">then()</code>和<code class="fe nh ni nj ld b">catch()</code>创建的微任务之前执行。</p><p id="ffa1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d5e1" class="lh li in ld b gy lj lk l ll lm">Promise.reject(() =&gt; {}).catch(() =&gt; {<br/>  console.log('rejected promise');<br/>});<br/>setTimeout(() =&gt; console.log('Timeout 1'), 0);<br/>process.nextTick(() =&gt; console.log('nextTick'));<br/>setTimeout(() =&gt; console.log('Timeout 2'), 10);</span></pre><p id="6347" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出是:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6243" class="lh li in ld b gy lj lk l ll lm">nextTick // the callback created by process.nextTick() executed before catch()<br/>rejected promise<br/>Timeout 1<br/>Timeout 2</span></pre><p id="7c5f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Node.js事件循环工作流最终如下所示:</p><figure class="ky kz la lb gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nk"><img src="../Images/449bfbf4eb7a29f551534045ea97ea78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3KzxMxOA4H6h_Uzy.png"/></div></div></figure><p id="7841" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们再来看看这个例子。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0615" class="lh li in ld b gy lj lk l ll lm">setImmediate(() =&gt; console.log('setImmediate'));</span><span id="e2f9" class="lh li in ld b gy ln lk l ll lm">fs.readFile('/etc/passwd', (err, data) =&gt; {<br/>  console.log('reading file');<br/>});</span><span id="a9d7" class="lh li in ld b gy ln lk l ll lm">console.log('start');</span><span id="aeb6" class="lh li in ld b gy ln lk l ll lm">process.nextTick(() =&gt; console.log('nextTick'));</span><span id="2c2e" class="lh li in ld b gy ln lk l ll lm">setTimeout(() =&gt; console.log('setTimeout 1'), 0);</span><span id="5fb3" class="lh li in ld b gy ln lk l ll lm">setTimeout(() =&gt; console.log('setTimeout 2'), 3);</span><span id="880d" class="lh li in ld b gy ln lk l ll lm">let counter = 0;<br/>const timeout = setInterval(() =&gt; {<br/>  console.log('setInterval');<br/>  if (counter &gt;= 3) {<br/>    console.log('exiting setInterval');<br/>    clearInterval(timeout);<br/>  }<br/>  counter++;<br/>}, 0);</span><span id="8bd7" class="lh li in ld b gy ln lk l ll lm">new Promise((resolve, reject) =&gt; {<br/>  console.log('start promise 1');<br/>  resolve('Promise 1');<br/>}).then((data) =&gt; {<br/>  console.log(data);<br/>});</span><span id="58de" class="lh li in ld b gy ln lk l ll lm">console.log('end');</span></pre><p id="5f12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先同步执行主线程中的JavaScript代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a155" class="lh li in ld b gy lj lk l ll lm">console.log('start');<br/>console.log('start promise 1');<br/>console.log('end');</span></pre><p id="ed86" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后由主线程中的<code class="fe nh ni nj ld b">process.nextTick()</code>、<code class="fe nh ni nj ld b">then()</code>和<code class="fe nh ni nj ld b">catch()</code>注册的微任务队列中的回调:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="edfb" class="lh li in ld b gy lj lk l ll lm">console.log('nextTick');<br/>console.log(data); // Promise 1</span></pre><p id="91eb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦主线程清除了微任务队列，执行就进入事件循环的计时器阶段，并执行计时器过期的回调:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9b1a" class="lh li in ld b gy lj lk l ll lm">console.log('setTimeout 1');<br/>console.log('setInterval');</span></pre><p id="bfb8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">第二个回调可能不会在第一次迭代中执行，因为它在3毫秒后到期，所以它的执行将被推迟到下一次迭代。</em></p><p id="1b00" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nl">在定时器阶段，有一个</em> <code class="fe nh ni nj ld b"><em class="nl">setInterval()</em></code> <em class="nl">调度的回调，以0ms为间隔重复触发(4次直到定时器取消)。但是，每次回调都是在单独的迭代中执行的。</em></p><p id="97c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，应该执行轮询阶段的回调。但是在<code class="fe nh ni nj ld b">/etc/passwd</code>上完成文件读取操作需要一些时间。因此，轮询阶段将会空闲一段时间，事件循环将会进入检查阶段，因为有一个由<code class="fe nh ni nj ld b">setImmediate()</code>安排的定时器。</p><p id="f0de" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在检查阶段，将执行由<code class="fe nh ni nj ld b">setImmediate()</code>安排的回调:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="66d7" class="lh li in ld b gy lj lk l ll lm">console.log('setImmediate');</span></pre><p id="b442" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">至此，事件循环的第一次迭代已经完成。</p><p id="b778" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，事件循环继续第二次迭代，并再次进入计时器阶段，以执行其回调队列中的剩余回调:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="51f7" class="lh li in ld b gy lj lk l ll lm">console.log('setTimeout 2');<br/>console.log('setInterval');</span></pre><p id="5792" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后它进入轮询阶段，由于<code class="fe nh ni nj ld b">setImmediate</code>不再调度定时器，它等待文件读取操作的回调并执行回调:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="afe0" class="lh li in ld b gy lj lk l ll lm">console.log('reading file');</span></pre><p id="cedc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且事件循环重复迭代，直到无事可做，于是Node.js过程结束。</p><p id="c6e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该示例的最终输出:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2413" class="lh li in ld b gy lj lk l ll lm">start<br/>start promise 1<br/>end<br/>nextTick<br/>Promise 1<br/>setTimeout 1<br/>setInterval<br/>setImmediate<br/>setTimeout 2<br/>setInterval<br/>reading file<br/>setInterval<br/>setInterval<br/>exiting setInterval</span></pre><figure class="ky kz la lb gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nm"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk"><a class="ae ng" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>