<html>
<head>
<title>Web Optimization using Intersection Observer API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交叉点观察器API的网页优化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-optimization-using-intersection-observer-api-68367c4bf9ee?source=collection_archive---------2-----------------------#2020-06-09">https://javascript.plainenglish.io/web-optimization-using-intersection-observer-api-68367c4bf9ee?source=collection_archive---------2-----------------------#2020-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dda1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用示例学习交叉点观察器API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e28e0f783a53369aa4be0b5023b6be69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wUsrEFnQRjvastj2.jpg"/></div></div></figure><h2 id="db3a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">用例子深入学习</h2><p id="3902" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">isInterSecting属性:检测被观察元素在框架中是否可见</p><h1 id="fa78" class="mg ks iq bd kt mh mi mj kw mk ml mm kz jw mn jx ld jz mo ka lh kc mp kd ll mq bi translated">接口:</h1><h2 id="829e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">示例1:根据相交率更改背景颜色</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/93bd2521f49f025d25cf18053eb643d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*r8Iea933dOa39YwJe1bxHg.gif"/></div></figure><h2 id="2e89" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">示例2:当前部分的突出显示</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3ac50f376e0c49454abd379aa6b87cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JURoEFmDpYiNG6fU-GaLLg.gif"/></div></figure><h2 id="2896" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">示例3:图像惰性加载</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/b2f5a421b67a993c6f40dbcd112570e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*x0xg8Tlha_DxxU4dIgfKbw.gif"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="1577" class="mg ks iq bd kt mh mz mj kw mk na mm kz jw nb jx ld jz nc ka lh kc nd kd ll mq bi translated">为什么？什么？怎么会？</h1><h2 id="a648" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是懒装？</h2><p id="d6e4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">随着图像成为网络上最流行的内容类型，网站的页面加载时间很容易成为一个问题</p><ul class=""><li id="f2d7" class="ne nf iq lp b lq ng lt nh la ni le nj li nk mf nl nm nn no bi translated">延迟加载图像意味着异步加载网站上的图像——也就是说，只有当上面的内容出现在浏览器的视窗中时，它们才会被完全加载</li><li id="76d4" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">这意味着如果用户不一直向下滚动，位于页面底部的图像甚至不会被加载</li><li id="037e" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">例如，<a class="ae nu" href="https://medium.com/" rel="noopener"> medium </a>使用延迟加载:将页面的该部分滚动到视图中会触发用全分辨率照片替换占位符</li></ul><h2 id="882b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">为什么要在意懒装？</h2><ul class=""><li id="b3cb" class="ne nf iq lp b lq lr lt lu la nv le nw li nx mf nl nm nn no bi translated"><strong class="lp ir">用户体验；</strong>快速加载DOM可以让用户留下来享受增强的用户体验</li><li id="2c6c" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated"><strong class="lp ir">节省带宽</strong>；加载某些只在视口内可见的图像意味着节省带宽；大多数用户，尤其是那些通过移动设备和慢速连接访问网络的用户将从中受益</li></ul><h2 id="f1eb" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是交叉点观察器API</h2><p id="d97d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">根据<a class="ae nu" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> MDN </a>的说法，交集观察器API提供了一种异步观察目标元素与祖先元素或顶层文档视窗交集变化的方法</p><p id="e6ee" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">换句话说，<code class="fe ob oc od oe b">IntersectionObserver</code>异步观察一个元素与另一个元素的重叠</p><h2 id="223c" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">为什么选择交叉点观察器API</h2><p id="c014" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在名为<a class="ae nu" href="https://www.sitepoint.com/five-techniques-lazy-load-images-website-performance/" rel="noopener ugc nofollow" target="_blank"> <em class="of">的文章中描述了5种以上的延迟加载图片的方法，5种延迟加载图片以提高网站性能的方法</em> </a> <em class="of">。</em></p><p id="21ef" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">出于以下原因，我将把重点放在由交叉点观察器API实现的延迟加载上</p><ul class=""><li id="5117" class="ne nf iq lp b lq ng lt nh la ni le nj li nk mf nl nm nn no bi translated">根据MDN的说法，交叉点观察器API目前(截至2020年6月)处于<strong class="lp ir">工作草案</strong>的状态，并且很可能在不久的将来成为JavaScript的新标准</li><li id="6365" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">交集观察者API非常强大，易于实现；<code class="fe ob oc od oe b">intersectionObserver</code>在内部完成大多数困难的计算</li><li id="ef39" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated">交叉点观察器API非常兼容浏览器；大多数浏览器在其最新版本中都支持它；如果没有，可以使用多填充物</li></ul><h2 id="ea0d" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">观察者与事件</h2><p id="d996" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">常规事件和观察者之间的区别在于，默认情况下，前者对事件的每一次发生都作出同步<strong class="lp ir">反应，影响主线程的响应，而后者应该异步<strong class="lp ir">反应</strong>而不会对性能产生太大影响</strong></p><p id="eb1f" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">Observer的异步特性导致几个可观察对象同时被传递给一个回调函数。因此，这个回调函数不应该期望一个条目，而应该期望一个<code class="fe ob oc od oe b">Array</code>条目</p><p id="2f7a" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><a class="ae nu" href="https://medium.com/javascript-in-plain-english/google-javascript-technical-interview-7a20accd6ddf" rel="noopener">一篇关于回调实践的好文章</a></p><h2 id="41cb" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">如何计算交集</h2><p id="d30d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><strong class="lp ir"> 1。所有区域都被识别为矩形</strong></p><p id="fcea" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">交叉点观察器API考虑的所有区域都是矩形；形状不规则的元素被认为占据了包围元素所有部分的最小矩形</p><p id="69cb" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> 2。根与根边缘的交点</strong></p><p id="8164" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir">根</strong></p><p id="e32f" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><code class="fe ob oc od oe b">root</code>是用于观察的根元素。默认情况下，<code class="fe ob oc od oe b">root</code>是浏览器的<strong class="lp ir">视窗</strong>，但实际上可以是DOM中的任何元素(类似于<code class="fe ob oc od oe b">document.getElementByID('your-element'))</code></p><p id="166b" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"><em class="of">*重要* </em> </strong> <em class="of">你要观察的元素多“活”在</em> <code class="fe ob oc od oe b"><em class="of">root</em></code> <em class="of">的DOM树</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/cd6b397cfb4ccdf022d50aaa9d880836.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*XxACHwUVt1A6sFot.jpg"/></div></figure><p id="43b2" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir">根缘</strong></p><p id="1f58" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><code class="fe ob oc od oe b">rootMargin</code>定义<code class="fe ob oc od oe b">root</code>元素周围的边距，当<code class="fe ob oc od oe b">root</code>的尺寸没有提供足够的灵活性时，该边距会扩展或收缩“捕捉帧”</p><p id="177c" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">该配置值的选项与CSS中的<code class="fe ob oc od oe b">margin</code>类似，例如<code class="fe ob oc od oe b">rootMargin: '50px 20px 10px 40px'</code>(上、右、下、左)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/72290c8f81019f3c51c05a4085a4e403.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*3C8FuTCYZ7eL8aDR.jpg"/></div></figure><p id="53e9" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> 3。阈值</strong></p><p id="b6d4" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">交叉点观察器API使用<strong class="lp ir">阈值，而不是报告目标元素可见程度的每一个微小变化。</strong>当您创建一个观察者时，您可以提供一个或多个数值来表示可见的目标元素的百分比</p><p id="c2d2" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">然后，API只报告跨越这些阈值的可见性变化</p><p id="a621" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">例如:</p><p id="097e" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir">第一个框</strong>非常敏感，因为它对可见性的每个百分点都有一个<strong class="lp ir">阈值</strong>，例如</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="ea92" class="kr ks iq oe b gy ol om l on oo">[0.00, 0.01, 0.02, 0.03, ... , 1.00]</span></pre><p id="a922" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">而<strong class="lp ir">最后一个框</strong>的反应性较低，因为其每25%的可见度具有<strong class="lp ir">阈值</strong>:</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="39bb" class="kr ks iq oe b gy ol om l on oo">0%, 25%, 50% etc...</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/509d63e371e2e72e5856657fcf7d71fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/1*MtPsOSERiAooOkABVWJ0Yw.gif"/></div></figure><h2 id="26db" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建交叉点观察器</h2><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="c55b" class="kr ks iq oe b gy ol om l on oo">let <strong class="oe ir">options</strong> = { <strong class="oe ir">// (1)</strong></span><span id="e10f" class="kr ks iq oe b gy oq om l on oo">root: document.querySelector('#scrollArea'),</span><span id="1d29" class="kr ks iq oe b gy oq om l on oo">rootMargin: '0px',</span><span id="1cf8" class="kr ks iq oe b gy oq om l on oo">threshold: 1.0<br/>}</span><span id="21df" class="kr ks iq oe b gy oq om l on oo">let <strong class="oe ir">callback</strong> = (entries, observer) =&gt; { <strong class="oe ir">// (2)</strong></span><span id="edfc" class="kr ks iq oe b gy oq om l on oo">entries.forEach(entry =&gt; {</span><span id="82e1" class="kr ks iq oe b gy oq om l on oo">});</span><span id="fb2f" class="kr ks iq oe b gy oq om l on oo">};<br/></span><span id="76a6" class="kr ks iq oe b gy oq om l on oo">let observer = new IntersectionObserver(<strong class="oe ir">callback // (2)</strong>, <strong class="oe ir">options // (1) </strong>);</span></pre><p id="be8e" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">现在我们应该给<code class="fe ob oc od oe b">IntersectionObserver</code>实际的元素去观察</p><p id="c885" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">这仅仅通过将元素传递给<code class="fe ob oc od oe b">observe()</code>函数来实现</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="2c56" class="kr ks iq oe b gy ol om l on oo">const img = document.getElementById('image-to-observe');<br/>observer.observe(image);</span></pre><p id="884f" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir">关于观察元素</strong>有几点需要注意</p><ul class=""><li id="d684" class="ne nf iq lp b lq ng lt nh la ni le nj li nk mf nl nm nn no bi translated">如果将<code class="fe ob oc od oe b">root</code>设置为DOM中的一个元素，那么观察到的元素应该位于<code class="fe ob oc od oe b">root</code>的DOM树中</li><li id="c0d0" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated"><code class="fe ob oc od oe b">IntersectionObserver</code>一次只能接受一个要素进行观察，不支持批量供应进行观察。如果你需要观察几个元素(比如说一个页面上的几个图像)，你必须迭代所有的元素并分别观察它们</li></ul><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="80e7" class="kr ks iq oe b gy ol om l on oo">const images = document.querySelectorAll('img');<br/>images.forEach(image =&gt; {<br/>  observer.observe(image);<br/>});</span></pre><p id="e689" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir">浏览器兼容性</strong></p><p id="0980" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><code class="fe ob oc od oe b">Intersection Observer API</code>具有相当好的浏览器兼容性；它对除IE(互联网浏览器)之外的所有浏览器都有很好的服务</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/acadc8262450fc2702e94fc10fadc535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHQJKPkPS2zB5E3rio3c8w.png"/></div></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="bb95" class="mg ks iq bd kt mh mz mj kw mk na mm kz jw nb jx ld jz nc ka lh kc nd kd ll mq bi translated">通过示例深入学习</h1><h2 id="e482" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> isInterSecting属性:检测观察到的元素在框架中是否可见</strong></h2><p id="19a9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><code class="fe ob oc od oe b">isIntersecting</code>是指示所观察的元素当前是否与“捕捉帧”相交的便利属性</p><p id="1f86" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">当然，我们可以通过观察<code class="fe ob oc od oe b">intersectionRect</code>(如果这个矩形不是0 x 0，那么元素与“捕捉帧”相交)来获得这个信息，但是为我们预先计算这个是非常方便的</p><p id="74b8" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">下面的代码片段显示了一个回调，该回调使用<code class="fe ob oc od oe b">isintersecting</code>、<code class="fe ob oc od oe b">intersectionRatio</code>属性记录元素从不与根相交转变为至少75%相交的次数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><h2 id="00e1" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">接口</h2><p id="7d4b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><strong class="lp ir">intersecionobserver</strong></p><p id="4655" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">交集观察者API的主要介面。每个观察者可以异步地观察一个或多个目标元素与共享的祖先元素之间或与它们的顶层<code class="fe ob oc od oe b">Document</code>的视口的交集中的变化</p><p id="43cc" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir">intersectionobserver renty</strong></p><p id="3dba" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">描述目标元素与其根容器之间在特定转换时刻的交集。它只能通过两种方式获得；</p><ol class=""><li id="2082" class="ne nf iq lp b lq ng lt nh la ni le nj li nk mf ou nm nn no bi translated">对<code class="fe ob oc od oe b">IntersectionObserver</code>回调的输入</li><li id="e0c0" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf ou nm nn no bi translated">通过调用<code class="fe ob oc od oe b">IntersectionObserver.takeRecords()</code></li></ol><h2 id="e2c6" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">例1:根据交点率改变背景颜色</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/93bd2521f49f025d25cf18053eb643d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*r8Iea933dOa39YwJe1bxHg.gif"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ot l"/></div></figure><p id="eab1" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> HTML </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="b97d" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> CSS </strong></p><p id="f09e" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">它对元素进行了布局，并确定了<code class="fe ob oc od oe b">background-color</code>和<code class="fe ob oc od oe b">border</code>属性可以参与CSS转换，当元素变得或多或少模糊时，我们将使用它们来影响对元素的更改</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="6eb9" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> JavaScript </strong></p><p id="5077" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">设置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="b41f" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">创建交叉点观察点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="8de8" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">构建阈值比率数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="b789" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">处理交叉点变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="d11f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">示例2:当前部分的突出显示</h2><p id="6ae7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">让我们用<code class="fe ob oc od oe b">IntersectionObserver</code>代替<code class="fe ob oc od oe b">scroll</code>事件。在这个例子中，我们应该根据文档的滚动位置突出显示当前部分</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3ac50f376e0c49454abd379aa6b87cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JURoEFmDpYiNG6fU-GaLLg.gif"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ot l"/></div></figure><p id="33fb" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> HTML </strong></p><p id="1d2f" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">简单的导航<code class="fe ob oc od oe b">navbar</code>和<code class="fe ob oc od oe b">div</code>的HTML标记。<code class="fe ob oc od oe b">data-ref</code>指向每个<code class="fe ob oc od oe b">div</code>的<code class="fe ob oc od oe b">id</code>，例如，</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="c374" class="kr ks iq oe b gy ol om l on oo">data-ref="first-screen" --&gt; &lt;div id="first-screen"&gt; <br/>...<br/>data-ref="third-screen" --&gt; &lt;div id="third-screen"&gt;</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="41aa" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> CSS </strong></p><p id="749e" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">CSS给出了<code class="fe ob oc od oe b">min-height</code>和<code class="fe ob oc od oe b">background-color</code>来区分每个<code class="fe ob oc od oe b">div</code> s</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="da08" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> JavaScript </strong></p><p id="d094" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><code class="fe ob oc od oe b">IntersectionObserver</code>配置，适用于所有类名为<code class="fe ob oc od oe b">screen</code>的<code class="fe ob oc od oe b">div</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="0035" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><code class="fe ob oc od oe b">intersectionHandler</code>处理器逻辑</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="1f39" class="kr ks iq oe b gy ol om l on oo">function intersectionHandler(entry) {<br/> <br/>  const currentlyActive = document.querySelector('nav li.active');<br/>  const shouldBeActive = <br/>    document.querySelector('nav li[data-ref=' + id + ']');</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="d71a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">示例3:图像惰性加载</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/b2f5a421b67a993c6f40dbcd112570e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*x0xg8Tlha_DxxU4dIgfKbw.gif"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ot l"/></div></figure><p id="e7a1" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> HTML </strong></p><p id="f3b1" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">一堆图像缠绕着<code class="fe ob oc od oe b">image-container</code> &amp; <code class="fe ob oc od oe b">image-wrapper</code>类</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="ff1c" class="kr ks iq oe b gy ol om l on oo">&lt;div class="image-container"&gt;<br/>    &lt;div class="image-wrapper"&gt;<br/>     ...</span><span id="4bbd" class="kr ks iq oe b gy oq om l on oo">    &lt;img data-src="IMG-SOURCE" class="lazyload" /&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="5078" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> CSS </strong></p><p id="498b" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><code class="fe ob oc od oe b">lazyload</code>具有基本过渡效果的类</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="b955" class="kr ks iq oe b gy ol om l on oo">.lazyload {<br/>  opacity: 0;<br/>  width: 100%;<br/>  height: 360px;<br/>  transition: opacity 0.5s ease;<br/>  vertical-align: middle;<br/>}<br/>.lazyload.loaded {<br/>  opacity: 1;<br/>  height: auto;<br/>}</span></pre><p id="668e" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir"> JavaScript </strong></p><p id="da39" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">未提供具体的<code class="fe ob oc od oe b">config</code>；因此，</p><p id="9d0c" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">…(如上所述)</p><p id="3af8" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><code class="fe ob oc od oe b">root</code>是用于观察的根元素。默认情况下，<code class="fe ob oc od oe b">root</code>是浏览器的<strong class="lp ir">视窗</strong>，但实际上可以是DOM中的任何元素(类似于<code class="fe ob oc od oe b">document.getElementByID('your-element'))</code></p><p id="c1b6" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi">…</p><p id="fe41" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">当<code class="fe ob oc od oe b">div</code>为<code class="fe ob oc od oe b">intersecting</code>时</p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="febb" class="kr ks iq oe b gy ol om l on oo">if (entry.isIntersecting) { ... }</span></pre><p id="dd3a" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated">然后添加一个类名<code class="fe ob oc od oe b">loaded</code></p><pre class="kg kh ki kj gt oh oe oi oj aw ok bi"><span id="f12f" class="kr ks iq oe b gy ol om l on oo">entry.target.classList.add('loaded');</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="33cd" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h2><p id="c3c0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在现代浏览器中有很好的支持，并且易于使用</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/acadc8262450fc2702e94fc10fadc535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHQJKPkPS2zB5E3rio3c8w.png"/></div></div></figure><p id="e13c" class="pw-post-body-paragraph ln lo iq lp b lq ng jr ls lt nh ju lv la ny lx ly le nz ma mb li oa md me mf ij bi translated"><strong class="lp ir">的好处</strong>的好处<code class="fe ob oc od oe b"><strong class="lp ir">IntersectionObserver</strong></code></p><ul class=""><li id="2b15" class="ne nf iq lp b lq ng lt nh la ni le nj li nk mf nl nm nn no bi translated"><code class="fe ob oc od oe b">IntersectionObserver</code>是一个异步非阻塞API</li><li id="62ba" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated"><code class="fe ob oc od oe b">IntersectionObserver</code>在<code class="fe ob oc od oe b">scroll</code>或<code class="fe ob oc od oe b">resize</code>活动中替代昂贵的听众</li><li id="df4f" class="ne nf iq lp b lq np lt nq la nr le ns li nt mf nl nm nn no bi translated"><code class="fe ob oc od oe b">IntersectionObserver</code>遵循其他观察者的结构模式，所以理论上，如果你熟悉其他观察者的工作方式，应该很容易理解</li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><blockquote class="ow"><p id="c920" class="ox oy iq bd oz pa pb pc pd pe pf mf dk translated">享受用<code class="fe ob oc od oe b">IntersectionObserver</code> API编码的乐趣！</p></blockquote><h2 id="4fa7" class="kr ks iq bd kt ku pg dn kw kx ph dp kz la pi lc ld le pj lg lh li pk lk ll lm bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="5af4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae nu" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">订阅我们的YouTube频道</strong> </a> <strong class="lp ir">获取更多类似内容！</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/88f7731845bc2c3d0d9cc226f939a36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CPidlOfU8NYlb-vg"/></div></div><figcaption class="pm pn gj gh gi po pp bd b be z dk">Photo by <a class="ae nu" href="https://unsplash.com/@kobuagency?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">KOBU Agency</a> on <a class="ae nu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>