<html>
<head>
<title>Next.js — Client-Side Navigation and API Routes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js —客户端导航和API路线</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-client-side-navigation-and-api-routes-e535eabff1f9?source=collection_archive---------4-----------------------#2020-12-28">https://javascript.plainenglish.io/next-js-client-side-navigation-and-api-routes-e535eabff1f9?source=collection_archive---------4-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c9afbd46cb121ba7cbadcc20619aedb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LaDQ3MDfpx1G9WIm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@officestock?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sebastian Herrmann</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9f43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以轻松地创建服务器端呈现的React应用程序和静态站点。</p><p id="b37f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看使用Next.js的路由。</p><h1 id="26c2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">客户端导航</h1><p id="325a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了在服务器端进行路由，我们还可以使用Next.js进行客户端导航。</p><p id="4a77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="a95d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pages/links.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c457" class="mq lc iq mh b gy mr ms l mt mu">import { useRouter } from 'next/router'</span><span id="0baa" class="mq lc iq mh b gy mv ms l mt mu">function Links() {<br/>  const router = useRouter()</span><span id="1405" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;ul&gt;<br/>      &lt;li&gt;<br/>        &lt;span onClick={() =&gt; router.push('/foo')}&gt;foo&lt;/span&gt;<br/>      &lt;/li&gt;<br/>      &lt;li&gt;<br/>        &lt;span onClick={() =&gt; router.push('/bar')}&gt;bar&lt;/span&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  )<br/>}</span><span id="94f5" class="mq lc iq mh b gy mv ms l mt mu">export default Links</span></pre><p id="6c73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pages/foo.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9e00" class="mq lc iq mh b gy mr ms l mt mu">import Links from './links';</span><span id="69de" class="mq lc iq mh b gy mv ms l mt mu">function Foo() {<br/>  return &lt;div&gt;<br/>    &lt;Links /&gt;<br/>    &lt;p&gt;foo&lt;/p&gt;<br/>  &lt;/div&gt;<br/>}</span><span id="70c5" class="mq lc iq mh b gy mv ms l mt mu">export default Foo</span></pre><p id="e65f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pages/bar.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f33b" class="mq lc iq mh b gy mr ms l mt mu">import Links from './links';</span><span id="c347" class="mq lc iq mh b gy mv ms l mt mu">function Bar() {<br/>  return &lt;div&gt;<br/>    &lt;Links /&gt;<br/>    &lt;p&gt;bar&lt;/p&gt;<br/>  &lt;/div&gt;<br/>}<br/>export default Bar</span></pre><p id="ccf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有跨度为的<code class="fe me mf mg mh b">pages/links.js</code>文件，它在点击时运行<code class="fe me mf mg mh b">router.push</code>方法。</p><p id="eeb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">router</code>对象来自Next.js的<code class="fe me mf mg mh b">useRouter</code>钩子。</p><h1 id="3230" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浅层布线</h1><p id="aaf4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">浅层路由让我们无需再次运行类似<code class="fe me mf mg mh b">getServerSideProps</code>、<code class="fe me mf mg mh b">getStaticProps</code>和<code class="fe me mf mg mh b">getInitialProps</code>的数据获取方法就可以更改URL。</p><p id="bd06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过<code class="fe me mf mg mh b">router</code>对象获得更新后的<code class="fe me mf mg mh b">pathname</code>和<code class="fe me mf mg mh b">query</code>。</p><p id="13d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="504c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pages/count.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d634" class="mq lc iq mh b gy mr ms l mt mu">import { useEffect } from 'react'<br/>import { useRouter } from 'next/router'</span><span id="6584" class="mq lc iq mh b gy mv ms l mt mu">function Count() {<br/>  const router = useRouter()</span><span id="4342" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    router.push('/count?count=10', undefined, { shallow: true })<br/>  }, [])</span><span id="8067" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>  }, [router.query.count])</span><span id="9e0f" class="mq lc iq mh b gy mv ms l mt mu">  return &lt;p&gt;{router.query.count}&lt;/p&gt;<br/>}</span><span id="c9d1" class="mq lc iq mh b gy mv ms l mt mu">export default Count</span></pre><p id="432c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加一个带有<code class="fe me mf mg mh b">useEffect</code>钩子的<code class="fe me mf mg mh b">Count</code>组件，该钩子调用<code class="fe me mf mg mh b">router.push</code>向URL添加一个查询字符串。</p><p id="10e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">shallow: true</code>表示我们启用浅层路由。</p><p id="497b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该看到显示10，因为当我们转到<a class="ae kc" href="http://localhost:3000/count" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/count</a>时，从查询字符串中可以看到<code class="fe me mf mg mh b">router.query.count</code>是10。</p><p id="d2d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浅层路由仅适用于相同页面的URL更改。</p><p id="818b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="19d2" class="mq lc iq mh b gy mr ms l mt mu">router.push('/?count=10', '/about?count=10', { shallow: true })</span></pre><p id="4a9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后从零开始加载<code class="fe me mf mg mh b">about</code>页面。</p><h1 id="0a2a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">API路线</h1><p id="fbde" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用API routes用Next.js构建一个API。</p><p id="8444" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以将JavaScrtipt文件放在<code class="fe me mf mg mh b">pages/api</code>文件夹中。</p><p id="eb11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后里面的文件将被映射到<code class="fe me mf mg mh b">/api/*</code>的网址。</p><p id="33fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="1944" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pages/api/hello.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="068d" class="mq lc iq mh b gy mr ms l mt mu">export default (req, res) =&gt; {<br/>  res.statusCode = 200<br/>  res.json({ name: 'hello world' })<br/>}</span></pre><p id="8612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">req</code>有请求数据，而<code class="fe me mf mg mh b">res</code>是一个我们可以用来创建响应的对象。</p><p id="455b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">res.statusCode</code>设置响应状态代码，并用<code class="fe me mf mg mh b">res.json</code>方法创建我们的JSON响应。</p><p id="c588" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们用任何http动词向<a class="ae kc" href="http://localhost:3000/api/hello" rel="noopener ugc nofollow" target="_blank">HTTP://localhost:3000/API/hello</a>发出请求时，我们会看到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1eb7" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  "name": "hello world"<br/>}</span></pre><p id="73c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已退回。</p><p id="6b95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了处理不同的HTTP方法，在API路由中，我们可以使用<code class="fe me mf mg mh b">req.method</code>属性。</p><p id="356e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c13e" class="mq lc iq mh b gy mr ms l mt mu">export default (req, res) =&gt; {<br/>  res.statusCode = 200<br/>  res.json({ name: 'hello world', method: req.method })<br/>}</span></pre><p id="275a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们向<a class="ae kc" href="http://localhost:3000/api/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/hello</a>发出PUT请求时，我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4a2a" class="mq lc iq mh b gy mr ms l mt mu">{<br/>    "name": "hello world",<br/>    "method": "PUT"<br/>}</span></pre><p id="c5aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已退回。</p><p id="03e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API路由不指定CORS头，所以我们只能在请求来自与API路由相同的来源时发出这些请求。</p><h1 id="aa32" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="eb68" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Next.js做API路由。</p><p id="a6f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">useRouter</code>钩子可以从客户端进行导航。</p><p id="36b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>