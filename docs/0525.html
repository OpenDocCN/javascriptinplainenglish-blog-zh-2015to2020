<html>
<head>
<title>Algorithms 101: Group Anagrams in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:JavaScript中的分组字谜</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-group-anagrams-in-javascript-b3e3c10d211e?source=collection_archive---------1-----------------------#2019-11-03">https://javascript.plainenglish.io/algorithms-101-group-anagrams-in-javascript-b3e3c10d211e?source=collection_archive---------1-----------------------#2019-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="07bf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉算法#18:散列的乐趣</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b684df263344071dbda804451827c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0CPTc1gYWjlKcZWzhagkA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image from wordsmith.org</figcaption></figure><p id="224e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">前几天碰到<a class="ae lr" href="https://leetcode.com/problems/group-anagrams/" rel="noopener ugc nofollow" target="_blank">这个来自LeetCode的挑战:</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/ca1e7b680892dc23e3def858f5ff9d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0gUuHjfQ0dP1e7nszGwXw.png"/></div></div></figure><p id="a46d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我原以为会相当困难，但我惊喜地发现！</p><h1 id="c863" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">变位词的定义如何帮助我们排序？</h1><p id="d192" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">你已经知道什么是变位词，但是考虑一下这里的细节是值得的。互为变位词的单词都有相同的字母。</p><p id="8251" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用上面的例子…</p><p id="f6b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们有一个标有<code class="fe mq mr ms mt b">“a” “e” “t”</code>的篮子，我们可以把单词<code class="fe mq mr ms mt b">“ate”, “eat” </code>和<code class="fe mq mr ms mt b">“tea”</code>放进里面。</p><p id="edc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，如果我们有一个标有<code class="fe mq mr ms mt b">"t" "a" "n"</code>的篮子，我们可以把单词<code class="fe mq mr ms mt b">"nat"</code>和<code class="fe mq mr ms mt b">"tan"</code>放在里面，等等。</p><p id="1de4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着我们可以通过将每个字符串简化为字母，然后以某种方式将每个字母集连接到每个只包含这些字母的字符串来解决这个难题。</p><p id="7e20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将如何连接它们？用哈希！</p><p id="dcf7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将构建一个如下所示的散列:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/dba562d0bba17ea726cd1b0788b27b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cjsw5uLL5645tnqS_vOUlw.png"/></div></div></figure><p id="b407" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的输入如下所示:</p><p id="b055" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mq mr ms mt b">[“eat”,”tea”,”tan”,”ate”,”nat”,”bat”]</code></p><p id="f4af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要将其转换为散列，我们需要遵循以下步骤。</p><h2 id="98f7" class="mv lu iq bd lv mw mx dn lz my mz dp md le na nb mf li nc nd mh lm ne nf mj ng bi translated">1.设置一个空散列</h2><p id="6ef9" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><code class="fe mq mr ms mt b">let hash = {}</code></p><h2 id="1e43" class="mv lu iq bd lv mw mx dn lz my mz dp md le na nb mf li nc nd mh lm ne nf mj ng bi translated">2.从每个字符串中提取字母，并使它们成为我们新散列中的一个键</h2><p id="62b5" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">例如，要从“eat”中获取字母，我们可以使用JavaScript的。split()方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ee7b12031c64ff6f53c9ee8a5bb7fa7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*xGAzaCMIiLcmHSdk5TmJvA.png"/></div></figure><p id="b135" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们把那个键添加到我们的hash中，我们就可以让那个键指向一个数组来保存使用这些字母的字谜。评估完“吃”之后，我们会得到这样的结果:</p><pre class="kg kh ki kj gt ni mt nj nk aw nl bi"><span id="ab94" class="mv lu iq mt b gy nm nn l no np">hash = {<br/>     ["e", "a", "t"]: ["eat"]</span><span id="6c7a" class="mv lu iq mt b gy nq nn l no np">}</span></pre><p id="1d8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是当我们说到“茶”这个词时，我们就有问题了。它是“吃”的变位词，所以我们应该将其添加到同一个数组中。相反，当我们运行split时，我们以不同的顺序结束相同的字母…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/4c2bf444a2258d598a0261f7ce8ead17.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*V2x0l0-JLF8ZiezKc4d8Zw.png"/></div></figure><p id="f883" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以代替这个的是:</p><pre class="kg kh ki kj gt ni mt nj nk aw nl bi"><span id="9c68" class="mv lu iq mt b gy nm nn l no np">hash = {<br/>     ["e", "a", "t"]: ["eat", "tea" ]</span><span id="0623" class="mv lu iq mt b gy nq nn l no np">}</span></pre><p id="2985" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们以此结束:</p><pre class="kg kh ki kj gt ni mt nj nk aw nl bi"><span id="cca7" class="mv lu iq mt b gy nm nn l no np">hash = {<br/>     ["e", "a", "t"]: ["eat"],</span><span id="b82d" class="mv lu iq mt b gy nq nn l no np">     ["t", "e", "a"]: ["tea"]</span><span id="7c32" class="mv lu iq mt b gy nq nn l no np">}</span></pre><p id="62a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了避免这个问题，在我们将字符串拆分成字母后，我们可以按字母顺序排列这些字母。如果我们对“吃”和“茶”都这样做，我们最终会得到这样的结果:</p><pre class="kg kh ki kj gt ni mt nj nk aw nl bi"><span id="b141" class="mv lu iq mt b gy nm nn l no np">hash = {<br/>     ["a", "e", "t"]: ["eat", "tea ]</span><span id="de46" class="mv lu iq mt b gy nq nn l no np">}</span></pre><p id="f925" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这正是我们想要的！</p><h2 id="04f5" class="mv lu iq bd lv mw mx dn lz my mz dp md le na nb mf li nc nd mh lm ne nf mj ng bi translated">3.建立一个循环来构建我们的散列</h2><p id="14af" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">现在我们知道了我们想要的散列是什么样子，让我们建立一个循环来构建我们的散列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/08db87d3983433cf177f7341d9c50a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRd_LDvFwdbUFEALC7p85g.png"/></div></div></figure><p id="55c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们打开它。在第4行，我们使用了一个forEach循环，它接受一个回调函数。</p><p id="048f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回调函数告诉我们拆分每个字符串，对字母进行排序，并将结果保存为变量<em class="nt"> letters。</em></p><p id="8831" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第7行，我们使用一个三元函数来检查我们的hash是否已经有了一个<em class="nt">字母的键。</em></p><p id="1a81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果它还没有一个<em class="nt">字母</em>的键，我们添加这个键，并将字符串(我们刚刚从中获得字母的那个)压入这个键的值:</p><pre class="kg kh ki kj gt ni mt nj nk aw nl bi"><span id="6ecc" class="mv lu iq mt b gy nm nn l no np">hash[letters].push(str)</span></pre><p id="2832" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果密钥确实存在，我们就不需要添加密钥。相反，我们继续将字符串推入键值。</p><p id="0752" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的循环完成对每个字符串的评估后，我们的哈希如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/07ac286ddca8323af1f7eb021f1edca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiXSpiIv4Q5CLZVEvIm0dQ.png"/></div></div></figure><h2 id="edae" class="mv lu iq bd lv mw mx dn lz my mz dp md le na nb mf li nc nd mh lm ne nf mj ng bi translated">最后一步:用Object.keys()格式化输出</h2><p id="2994" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">现在我们有了散列，我们需要使它看起来像我们想要的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/917e53a6bf89bef7a36ee28714d687ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raXhD1mssgxu6nTcXXe2_w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">note: the order of the nested arrrays does not matter</figcaption></figure><p id="d132" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们不需要钥匙了。我们只需要把我们的值放入一个数组中。(如果我们使用的是Ruby，我们可以简单地运行<code class="fe mq mr ms mt b">hash.values() )</code>。</p><p id="243d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在JavaScript中，我们可以将所有的键放入一个数组中，然后映射这些键以返回一个包含所有值的数组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/6641d80f944be29dfe031ea6cb926487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ljDmkW3QU2_Xm_Munet0Iw.png"/></div></div></figure><p id="f14f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在一起:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/5b4d10933a0aabe312249d5ea954c4d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfL8M0DZr1yZwjifMgWMEg.png"/></div></div></figure><p id="ffe2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在repl.it上玩这个代码:</p><p id="c7f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://repl.it/@Joan_IndianaInd/group-anagrams" rel="noopener ugc nofollow" target="_blank">https://repl.it/@Joan_IndianaInd/group-anagrams</a></p><p id="3a4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae lr" href="http://www.pythontutor.com/" rel="noopener ugc nofollow" target="_blank">PythonTutor.com</a>上玩也总是很有趣(PythonTutor是一个使用多种语言的代码可视化工具，不仅仅是Python！)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/6472593d0fa3c0695aa4a2b043539b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MX4VP3bG2tHUUfMvzReRw.png"/></div></div></figure><p id="0772" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是PythonTutor 上代码的<a class="ae lr" href="http://www.pythontutor.com/visualize.html#code=%0Alet%20strs%20%3D%20%5B%22eat%22,%22tea%22,%22tan%22,%22ate%22,%22nat%22,%22bat%22%5D%0A%0Avar%20groupAnagrams%20%3D%20function%28strs%29%20%7B%0A%20%20%20%20let%20hash%20%3D%20%7B%7D%0A%0A%20%20%20%20strs.forEach%28str%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20letters%20%3D%20str.split%28''%29.sort%28%29%0A%0A%20%20%20%20%20%20%20%20hash%5Bletters%5D%20%3F%20hash%5Bletters%5D.push%28str%29%20%3A%20hash%5Bletters%5D%20%3D%20%5Bstr%5D%0A%20%20%20%20%7D%29%0A%0A%20%20%20%20const%20keys%20%3D%20Object.keys%28hash%29%3B%0A%20%20%20%20const%20values%20%3D%20keys.map%28function%28v%29%20%7B%20return%20hash%5Bv%5D%3B%20%7D%29%3B%0A%20%20%20%20return%20values%0A%0A%7D%3B%0A%0AgroupAnagrams%28strs%29%0A&amp;cumulative=false&amp;curInstr=29&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=js&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="noopener ugc nofollow" target="_blank">链接。</a></p><p id="2321" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺便说一下，我们的算法在LeetCode上的表现比大多数算法都要好:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/c20e4a16aa4f4b076a844a2bb0005685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PHQZryoYPMC4GNub1xttg.png"/></div></div></figure><p id="618a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">琼·印第安纳·莱内斯2019</p><p id="c920" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">万一你错过了:<a class="ae lr" href="https://medium.com/javascript-in-plain-english/algorithms-101-count-primes-in-javascript-97f1ff85e040" rel="noopener"> <em class="nt">算法101 #17，在JavaScript中数素数</em> </a></p><p id="6a81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来:<a class="ae lr" href="https://medium.com/@joanrigdon/algorithms-101-level-patio-in-javascript-c9e98696694e" rel="noopener"> <em class="nt">算法101 #19、JavaScript中的水平天井</em> </a></p></div></div>    
</body>
</html>