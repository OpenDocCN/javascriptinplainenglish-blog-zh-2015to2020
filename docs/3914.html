<html>
<head>
<title>Should You Stop Using Objects and Arrays to Store Data?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是否应该停止使用对象和数组来存储数据？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/stop-using-objects-and-arrays-to-store-data-289c3edaaa33?source=collection_archive---------0-----------------------#2020-11-03">https://javascript.plainenglish.io/stop-using-objects-and-arrays-to-store-data-289c3edaaa33?source=collection_archive---------0-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4df5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ES6以集合和映射的形式有其他处理数据结构和值的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/039eb101b34710e6dbc8eb39033c1091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tW6-oO4cvj4IfBHn"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@alvarordesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alvaro Reyes</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="88df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多年来，程序员一直使用对象和数组来存储数据。这种趋势不仅仅局限于JavaScript。</p><p id="814f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了这两种存储多值和处理数据结构的方法之外，根本没有其他选择。</p><p id="96ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在使用对象和数组时有一些限制，例如:</p><ol class=""><li id="69c1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">数组可以存储重复的元素。</li><li id="7a15" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">没有方法可以像数组一样找到对象的长度。</li><li id="76dd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">只有字符串可以存储在对象中，它不记得插入顺序。</li><li id="fae6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">开发人员必须根据他们的用例选择数组或对象。</li><li id="a133" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">像<a class="ae kv" href="https://lodash.com/docs/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>这样的第三方库被用来增强阵列的功能</li></ol><p id="8768" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是随着2015年ES6的推出，事情变得更好了。</p><p id="53a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES6引入了对Map和Set的支持，旨在克服上述限制。</p><h2 id="21a5" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">什么是集合和映射？</h2><p id="07bd" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如前所述，这两者都是在JavaScript的ES6版本中引入的。</p><p id="d7af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集合是唯一元素的有序集合。“唯一元素”是主要的要点，因为它意味着集合中不能存储重复的元素。但是它没有键值对系统。</p><p id="f72d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，映射是数组和对象数据结构的组合。它是一个类似对象的键-值对的集合，但是它还记得插入格式，并且有一个length( <code class="fe ne nf ng nh b">.size</code>)属性。</p><p id="1b39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我会先看一遍布景，然后看地图。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h2 id="8b26" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">集合的声明和初始化</h2><p id="4287" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">集合可以这样初始化:</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="4589" class="mg mh iq nh b gy nt nu l nv nw">const set = new Set();</span></pre><h2 id="69a9" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">从集合中添加和移除元素</h2><p id="e3d3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">您可以使用<code class="fe ne nf ng nh b">.add()</code>方法轻松地将元素插入集合中。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="84f8" class="mg mh iq nh b gy nt nu l nv nw">const set = new Set();</span><span id="b899" class="mg mh iq nh b gy nx nu l nv nw">set.add('John');</span><span id="e665" class="mg mh iq nh b gy nx nu l nv nw">set.add('Martha')</span><span id="02b3" class="mg mh iq nh b gy nx nu l nv nw">set.add('Bryan');</span><span id="9209" class="mg mh iq nh b gy nx nu l nv nw">set.add('John');</span><span id="3b9b" class="mg mh iq nh b gy nx nu l nv nw">// set = {'John','Martha','Bryan'}</span></pre><p id="3daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是事情变得有点有趣的地方。JavaScript中的集合借用了数学集合的许多属性，并且只包含唯一的元素。</p><p id="f548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">删除元素也非常简单，使用<code class="fe ne nf ng nh b">.delete()</code>方法删除单个元素，使用<code class="fe ne nf ng nh b">.clear()</code>方法删除所有元素</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="6a13" class="mg mh iq nh b gy nt nu l nv nw">set.add('John');</span><span id="a4b8" class="mg mh iq nh b gy nx nu l nv nw">set.add('Martha')</span><span id="2067" class="mg mh iq nh b gy nx nu l nv nw">set.add('Bryan');</span><span id="686b" class="mg mh iq nh b gy nx nu l nv nw">set.delete('Martha')</span><span id="f576" class="mg mh iq nh b gy nx nu l nv nw">//set = {'John','Bryan'}</span><span id="f951" class="mg mh iq nh b gy nx nu l nv nw">set.clear(); // removes all the element</span></pre><h2 id="8abc" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">集合的大小</h2><p id="c88f" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">使用<code class="fe ne nf ng nh b">.size</code>方法，人们可以很容易地找到有帮助的集合的大小。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="54df" class="mg mh iq nh b gy nt nu l nv nw">set.add('a')</span><span id="2f62" class="mg mh iq nh b gy nx nu l nv nw">set.add('b');</span><span id="1c18" class="mg mh iq nh b gy nx nu l nv nw">set.add('c');</span><span id="0130" class="mg mh iq nh b gy nx nu l nv nw">console.log(set.size) // =&gt; 3</span></pre><h2 id="f2d4" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">访问集合中的元素</h2><p id="7c47" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">Set在尝试记录或访问其值时表现不同。您可以记录数组并查看元素，但对于集合来说就不一样了。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="eb89" class="mg mh iq nh b gy nt nu l nv nw">var arr=[1,2,3];</span><span id="e883" class="mg mh iq nh b gy nx nu l nv nw">const set = new Set(arr);</span><span id="481b" class="mg mh iq nh b gy nx nu l nv nw">console.log(set) // =&gt; [object Set]</span><span id="0882" class="mg mh iq nh b gy nx nu l nv nw">console.log(arr) // =&gt; (3) [1,2,3]</span></pre><p id="0802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了访问Set，我们需要一个<code class="fe ne nf ng nh b">SetIterator()</code>来获取所有的值。</p><p id="7bab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript提供了一个属性<code class="fe ne nf ng nh b">.values()</code>来获取一个迭代器，然后我们可以结合一个循环来检索所有的值。</p><p id="f14e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码片段演示了这一点:</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="d4da" class="mg mh iq nh b gy nt nu l nv nw">var arr=[1,2,3];</span><span id="3439" class="mg mh iq nh b gy nx nu l nv nw">const set = new Set(arr);</span><span id="caf5" class="mg mh iq nh b gy nx nu l nv nw">var iterator=set.values()</span><span id="b5b7" class="mg mh iq nh b gy nx nu l nv nw">console.log(iterator.next().value) //1</span></pre><p id="fa70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检索所有元素的更简单方法是使用<code class="fe ne nf ng nh b">.forEach()</code>，如下所示:</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="6b31" class="mg mh iq nh b gy nt nu l nv nw">var arr=[1,2,3];</span><span id="8ee4" class="mg mh iq nh b gy nx nu l nv nw">const set = new Set(arr);</span><span id="a912" class="mg mh iq nh b gy nx nu l nv nw">set.forEach(<em class="ny">v</em>=&gt;console.log(v))</span></pre><p id="8195" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="5223" class="mg mh iq nh b gy nt nu l nv nw">1<br/>2<br/>3</span></pre><p id="a294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，您可以使用<code class="fe ne nf ng nh b">.has()</code>方法检查一个值是否存在，如果找到该元素，该方法将返回true。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="c740" class="mg mh iq nh b gy nt nu l nv nw">var arr=[1,2,3];</span><span id="3049" class="mg mh iq nh b gy nx nu l nv nw">const set = new Set(arr);</span><span id="c6ba" class="mg mh iq nh b gy nx nu l nv nw">console.log(set.has(1)); // true</span></pre><p id="ad72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得一提的是，像<code class="fe ne nf ng nh b">keys() </code>和<code class="fe ne nf ng nh b">entries()</code>这样的方法对于Set是可用的，尽管Set不支持键值对元素。</p><h2 id="0682" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">集合与数组</h2><p id="9fcb" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">集合和数组倾向于执行和处理相同的操作，但是存在一些差异。</p><p id="1caa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最大的区别是Set不能有像Array一样的重复项，Set提供了一个更简单的方法来删除项。</p><p id="bbc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，集合中的元素在插入顺序上是可迭代的。</p><p id="ee12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与数学集合一样，JavaScript中的集合也可用于执行并集和交集等操作，这些操作可在合并数据或查找两个集合中的公共元素时使用。</p><p id="1e7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在此查看设置<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">的方法和指南的完整列表。</a></p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h2 id="b5f2" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">初始化和声明映射</h2><p id="e00c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">与Set类似，Map也可以用同样的方式声明。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="6cf3" class="mg mh iq nh b gy nt nu l nv nw">const map = new Map();</span></pre><h2 id="3813" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">从地图中添加和移除元素</h2><p id="12c2" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">该映射支持类似对象的键值对。因此，在增加价值时，我们也需要提供一个密钥。</p><p id="664a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与我们在电视上看到的不同。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="fddd" class="mg mh iq nh b gy nt nu l nv nw">const map = new Map();</span><span id="1c96" class="mg mh iq nh b gy nx nu l nv nw">map.set('Name', 'iPhone'); // map.set(key,value) format</span><span id="8cc1" class="mg mh iq nh b gy nx nu l nv nw">map.set('Brand', 'Apple');</span><span id="b480" class="mg mh iq nh b gy nx nu l nv nw">map.set('Price', '$1000');</span></pre><p id="a0e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要从映射中删除一个值，我们可以简单地将键传递给<code class="fe ne nf ng nh b">.delete() </code>属性。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="7769" class="mg mh iq nh b gy nt nu l nv nw">const map = new Map();</span><span id="4dd1" class="mg mh iq nh b gy nx nu l nv nw">map.set('Name', 'iPhone'); </span><span id="08af" class="mg mh iq nh b gy nx nu l nv nw">map.set('Brand', 'Apple');</span><span id="301a" class="mg mh iq nh b gy nx nu l nv nw">map.set('Price', '$1000');</span><span id="2b7f" class="mg mh iq nh b gy nx nu l nv nw">map.delete('Price'); //removes the element with key 'Price'</span></pre><p id="1812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像Set一样，我们可以使用<code class="fe ne nf ng nh b">.clear()</code>来移除所有的元素。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="f2d9" class="mg mh iq nh b gy nt nu l nv nw">map.clear() // removes all the element</span></pre><h2 id="dafc" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">地图大小</h2><p id="a8f5" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">使用<code class="fe ne nf ng nh b">.size</code>属性可以很容易地检索地图的大小(长度)。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="29e6" class="mg mh iq nh b gy nt nu l nv nw">const map = new Map();</span><span id="0229" class="mg mh iq nh b gy nx nu l nv nw">map.set('Name', 'iPhone');</span><span id="fdad" class="mg mh iq nh b gy nx nu l nv nw">map.set('Brand', 'Apple');</span><span id="89c5" class="mg mh iq nh b gy nx nu l nv nw">map.set('Price', '$1000');</span><span id="d3a5" class="mg mh iq nh b gy nx nu l nv nw">console.log(map.size)//=&gt; 3</span></pre><h2 id="7e1a" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">访问地图中的元素</h2><p id="ce72" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">Map为我们提供了一个. get()方法，通过在方法中将键作为参数传递来快速获取值。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="fd61" class="mg mh iq nh b gy nt nu l nv nw">const map = new Map();</span><span id="aaa2" class="mg mh iq nh b gy nx nu l nv nw">map.set('Name', 'iPhone');</span><span id="5127" class="mg mh iq nh b gy nx nu l nv nw">map.set('Brand', 'Apple');</span><span id="fc8c" class="mg mh iq nh b gy nx nu l nv nw">map.set('Price', '$1000');</span><span id="3a27" class="mg mh iq nh b gy nx nu l nv nw">console.log(map.get('Name')); //iPhone</span><span id="abf5" class="mg mh iq nh b gy nx nu l nv nw">console.log(map.get('Brand')); // Apple</span></pre><p id="5e9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果您只想要键、值或者键和值都想要呢？</p><p id="cdbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Map分别有<code class="fe ne nf ng nh b">.keys()</code>、<code class="fe ne nf ng nh b">.values()</code>和<code class="fe ne nf ng nh b">.entries()</code>用于实现相同的功能。</p><p id="8d91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用上面代码中的同一张地图，</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="9ce6" class="mg mh iq nh b gy nt nu l nv nw">console.log(map.keys());<br/>// iterator {'Name','Brand',Price'}</span><span id="4686" class="mg mh iq nh b gy nx nu l nv nw">console.log(map.values());<br/>// iterator {'iPhone','Apple','$1000'}</span><span id="6130" class="mg mh iq nh b gy nx nu l nv nw">console.log(map.entries());<br/>//iterator {'Name':'iPhone','Brand':'Apple',Price':'$1000'}</span></pre><p id="e684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迭代地图也很简单。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="ad6a" class="mg mh iq nh b gy nt nu l nv nw">//with for-each<br/>map.forEach((value, key) =&gt; {<br/>   console.log(`${key} is ${value} years old!`);<br/>});<br/><br/>// with for-of<br/>for(const [key, value] of map) {<br/>  console.log(`${key} : ${value}`);<br/>}</span></pre><p id="cc20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，使用<code class="fe ne nf ng nh b">.has()</code>属性并传递键，可以很容易地检查元素是否存在。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="c3a9" class="mg mh iq nh b gy nt nu l nv nw">var map = new Map();<br/>map.set('age',19);</span><span id="c29b" class="mg mh iq nh b gy nx nu l nv nw">console.log(map.has('age')) // true since 'age' key is present</span></pre><h2 id="e002" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">将对象转换为地图</h2><p id="4351" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">如果您决定将对象转换成地图，JavaScript会帮您解决。</p><p id="d062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们之前已经使用了<code class="fe ne nf ng nh b">.entries()</code>来获取所有的键值对，但是这次我们将使用<code class="fe ne nf ng nh b">Object</code>上的方法。</p><pre class="kg kh ki kj gt np nh nq nr aw ns bi"><span id="0cf3" class="mg mh iq nh b gy nt nu l nv nw">const myObject= {<br/>  'Age': '25',<br/>  'Gender': 'Male',<br/>  'Nationality': 'Australian'<br/>};<br/><br/>const myMap = new Map(Object.entries(myObject)); //object to map</span><span id="e3e5" class="mg mh iq nh b gy nx nu l nv nw">const anotherObject = Object.fromEntries(myMap) // map to object</span></pre><p id="32f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以很容易地将一张地图转换成一个物体，如上所示。</p><p id="4c45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要将地图转换成数组，我们可以使用<code class="fe ne nf ng nh b">Array.from(myMap)</code>。</p><h2 id="ee4b" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">贴图与数组和对象</h2><p id="72d5" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这个图似乎解决了数组和对象的很多缺点，比如能够处理复杂得多的操作。</p><p id="b12a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">地图就像是数组和对象的混合体。它有一个类似array的size属性，可以用键值对格式存储元素。</p><p id="9dcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，它还提供了类似于<code class="fe ne nf ng nh b">.has()</code>的方法来检查一个元素是否存在，这可以节省您大量的时间。</p><p id="9f6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它不一定需要密钥是字符串类型。你甚至可以使用一个对象作为一个键来帮助你写更好的代码。</p><p id="a429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到更详细的指南<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h2 id="aac9" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">最后的想法</h2><p id="066c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">虽然数组和对象已经成为存储集合和键值对元素的事实上的标准，但是随着Map和Set的引入，您可以为您的代码提供一种有趣的方法。</p><p id="3f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Set和Map是JavaScript为存储复杂数据结构提供的新标准。</p><p id="e5cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，使用这些数据结构还消除了使用像<a class="ae kv" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>这样的第三方库的需要，因为这些新的数据结构默认提供了像<code class="fe ne nf ng nh b">.has()</code>和<code class="fe ne nf ng nh b">.delete()</code>这样的方法。</p><p id="cb9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数组和对象在任何意义上都没有过时，但是，使用集合和映射肯定是处理数据的更好的方法，尤其是在构建巨大、复杂的应用程序时。</p><p id="2ca2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>