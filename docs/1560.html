<html>
<head>
<title>Server-Side Rendering in React — react-router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-React-router中的服务器端渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/server-side-rendering-in-react-redux-ab0af31c9c4b?source=collection_archive---------2-----------------------#2020-04-01">https://javascript.plainenglish.io/server-side-rendering-in-react-redux-ab0af31c9c4b?source=collection_archive---------2-----------------------#2020-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="04c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将基于react-router库的路由添加到服务器呈现的react应用程序中。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/90ce9b45d9a5359688ead1cf3b3f952c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZLg0pPm5g5iOt6GAHEieg.jpeg"/></div></div></figure><p id="9ac9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的“React中的服务器端呈现”系列文章中，我已经描述了如何配置一个应用程序在服务器和客户机上呈现。我还向<a class="ae ln" href="https://medium.com/javascript-in-plain-english/server-side-rendering-in-react-redux-8d6209fbfed" rel="noopener">展示了如何将Redux </a>添加到服务器渲染的应用程序中。<strong class="kt ir">今天，我们将通过路由丰富我们的示例。</strong>为此，我们将使用<a class="ae ln" href="https://reacttraining.com/react-router" rel="noopener ugc nofollow" target="_blank"> react-router库</a>，因为它是react生态系统中最流行的路由解决方案。</p><blockquote class="lo lp lq"><p id="93dc" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">在我以前的SSR文章中，我假设您已经熟悉了react-router库。如果没有，请看看这个伟大图书馆的文档。</p></blockquote><h1 id="6d90" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">软件包安装</h1><p id="47cf" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在今天的文章中，我们将继续我前两篇文章中已经创建的代码。在我们开始修改我们的例子之前，让我们安装<code class="fe ms mt mu mv b">react-router-dom</code>包。我们可以使用以下命令来实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/09c3cc1611638ced9071145f87ab19aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgXi4EfSNpvma9DTcfeIZg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Add the react-router-dom package</figcaption></figure><p id="3a05" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的命令和<code class="fe ms mt mu mv b">react-router-dom</code>一起，也安装了<code class="fe ms mt mu mv b">react-router</code>库，这在我们的例子中很有用。</p><h1 id="a6f0" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">组件结构变化</h1><p id="4afa" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在我们已经安装了所有必要的包，我们可以继续对我们的应用程序进行修改。我们的计划是将我们的<code class="fe ms mt mu mv b">App.js</code>组件重命名为<code class="fe ms mt mu mv b">Home.js</code>，并在<code class="fe ms mt mu mv b">/</code>路线中使用它。我们还将添加<code class="fe ms mt mu mv b">About.js</code>组件，并在<code class="fe ms mt mu mv b">/about</code>路径中使用它。然后我们将创建新的<code class="fe ms mt mu mv b">App.js</code>组件，它将是我们应用程序的根React元素，也是路由配置的地方。在本文的后面，我们将对在服务器和客户机上呈现我们的应用程序的代码进行修改。</p><h2 id="25e6" class="nb lw iq bd lx nc nd dn mb ne nf dp mf la ng nh mh le ni nj mj li nk nl ml nm bi translated">主页和关于组件</h2><p id="bfbd" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">让我们从将<code class="fe ms mt mu mv b">App</code>组件的名称改为<code class="fe ms mt mu mv b">Html</code>开始——实际上，我们所要做的就是用<strong class="kt ir">来重命名</strong>组件函数和文件。请查看以下修改后的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/a052cfbeccd7765f2ff2aacaa234e2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWVcCy8uhbCJgOLMhnGpig.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Home.js</figcaption></figure><p id="f6cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们创建<code class="fe ms mt mu mv b">About.js</code>组件。它可以按如下方式实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/525aae9716c303bbc04821658892441d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QwC8InJiRq-AMo7S6QR-3g.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">About.js</figcaption></figure><p id="0ed7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，它是一个简单的组件，只呈现一些静态信息。出于示例目的，我不需要它更复杂，也不需要它与Redux连接。</p><h2 id="59b5" class="nb lw iq bd lx nc nd dn mb ne nf dp mf la ng nh mh le ni nj mj li nk nl ml nm bi translated">应用程序组件和路由配置</h2><p id="7e9d" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">对于<code class="fe ms mt mu mv b">/</code>和<code class="fe ms mt mu mv b">/about</code>路径，将分别显示<code class="fe ms mt mu mv b">Home.js</code>和<code class="fe ms mt mu mv b">About.js</code>组件。我们将在即将添加的<code class="fe ms mt mu mv b">App.js</code>组件中配置它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/f73a60e9225ae77d6b0a67ef71315e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuAiSX1VUj2egxT3Kk8ZYQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">App.js</figcaption></figure><p id="b7fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码非常简单——它只是呈现链接列表以使导航更容易。它还使用<code class="fe ms mt mu mv b">react-router-dom</code>封装的<code class="fe ms mt mu mv b">Switch</code>和<code class="fe ms mt mu mv b">Route</code>组件来配置我们的路由。</p><h1 id="6f97" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">对服务器端呈现代码的更改</h1><p id="b7c0" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">好了，所有组件结构的必要改变都完成了。现在，让我们转到在服务器上执行渲染的<code class="fe ms mt mu mv b">server.js</code>文件。</p><p id="42b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想在这里实现什么？当用户在浏览器中打开我们的应用程序的一个路径时(或者只是刷新页面)，我们的服务器应该呈现正确的组件树并将其发送到浏览器。</p><p id="74a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请参见下面对<code class="fe ms mt mu mv b">server.js</code>文件所做的更改:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/795518f3900559617f7b1dff5a59e76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpfcts3VmTh7F__KV8HyOg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">server.js</figcaption></figure><p id="3bf3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实际上，我们没有做太多的改变。在上面的代码中首先要考虑的是<code class="fe ms mt mu mv b">StaticRouter</code>组件的导入。请注意，它是从<code class="fe ms mt mu mv b">react-router</code>(不是<code class="fe ms mt mu mv b">react-router-dom</code>)包中导入的。</p><p id="96bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，请看看我们是如何使用这个组件的——我们刚刚用<code class="fe ms mt mu mv b">StaticRouter</code>组件包装了传递给<code class="fe ms mt mu mv b">renderToString</code>方法的组件。为了让它起作用，我们必须给它的参数分配两件事。首先，也是最重要的，我们已经将<code class="fe ms mt mu mv b">req.url</code>值赋给了<code class="fe ms mt mu mv b">location</code>属性。得益于此，react-router <strong class="kt ir">将能够将来自浏览器地址栏的路由与在<code class="fe ms mt mu mv b">App.js</code>组件中分配给该路由的合适组件进行配对</strong>。</p><p id="d31e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ms mt mu mv b">StaticRouter</code>组件需要的第二个属性是<code class="fe ms mt mu mv b">context</code>。我们在其中传递了一个空对象。该对象将被添加到为匹配路线渲染的组件的<code class="fe ms mt mu mv b">props</code>对象中。这样，我们可以在渲染时向该组件提供一些附加信息。</p><h1 id="9ba2" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">客户端呈现代码的更改</h1><p id="66c6" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">最后(但并非最不重要)要做的事情是改变客户端代码的呈现方式。让我们稍微修改一下<code class="fe ms mt mu mv b">client.js</code>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/9db9bbeedb7a8e0d7d651fff9a662814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPw4cJNC-_yp45KRTaktaA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">client.js</figcaption></figure><p id="70ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们在这里所做的所有更改都非常简单。我们刚刚从<code class="fe ms mt mu mv b">react-router-dom</code>包中导入了<code class="fe ms mt mu mv b">BrowserRouter</code>组件。接下来，我们用它包装了现有的组件树。</p><p id="3e5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仅此而已——我们的路由在服务器和客户端上都有效！</p><blockquote class="lo lp lq"><p id="5208" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">可以通过运行这个项目来测试:<code class="fe ms mt mu mv b"><em class="iq">yarn start</em></code>；以及访问<a class="ae ln" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>地址。</p></blockquote><h1 id="86fa" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">摘要</h1><p id="d601" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">将<code class="fe ms mt mu mv b">react-router</code>引入到服务器端渲染React项目中，正如你已经看到的那样，<strong class="kt ir">相当容易。在本系列的下一篇文章中，我将向您展示如何在这种类型的应用程序中处理从外部API获取的数据。这样，我们将涵盖SSR主题的所有重要方面，并完成整个系列。</strong></p><blockquote class="lo lp lq"><p id="dd97" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">我们今天讨论的例子是我的GitHub库中的<a class="ae ln" href="https://github.com/burczu/react-router-server-side-rendering-example" rel="noopener ugc nofollow" target="_blank">。我鼓励你克隆它，然后自己玩。</a></p></blockquote></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="2775" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">附言</strong>本帖是关于使用React进行服务器端渲染的系列文章的一部分。请查看以下系列所有项目的列表:</p><ul class=""><li id="4df7" class="nu nv iq kt b ku kv kx ky la nw le nx li ny lm nz oa ob oc bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-an-introduction-55f4c7fa274b" rel="noopener">React中的服务器端渲染—简介</a></li><li id="9917" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-expressjs-8a87af0edba4" rel="noopener">React-express . js中的服务器端渲染</a></li><li id="0c21" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-redux-8d6209fbfed" rel="noopener">React-Redux中的服务器端渲染</a></li><li id="466d" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-redux-ab0af31c9c4b" rel="noopener">React-React-router中的服务器端渲染</a></li><li id="18c4" class="nu nv iq kt b ku od kx oe la of le og li oh lm nz oa ob oc bi translated">React中的服务器端渲染—处理真实数据</li></ul><p id="0cb5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">用简单的英语写的JavaScript的注释:</strong>我们总是对帮助推广高质量的内容感兴趣。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到<a class="ae ln" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>给我们，我们会把你添加为作者。</p></div></div>    
</body>
</html>