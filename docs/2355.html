<html>
<head>
<title>JavaScript Engine Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去神秘化的JavaScript引擎</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-engine-demystified-1b3b87b22495?source=collection_archive---------5-----------------------#2020-06-16">https://javascript.plainenglish.io/javascript-engine-demystified-1b3b87b22495?source=collection_archive---------5-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce72c550eee1bf6531e1e50413db7cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxIJ9lXbOZRbYQCNAkXusQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@wolfi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Wolfgang Lutz</a> on <a class="ae kc" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6b83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的上一篇文章中，我讨论了什么是函数，并介绍了函数式编程。但是在深入研究之前，我认为明智的做法是稍微了解一下JavaScript引擎是如何形成的，以及它作为一个整体是如何工作的。我说的是调用堆栈、执行上下文、内存堆、垃圾收集器…是的，今天我们将揭开其他<a class="ae kc" href="https://www.youtube.com/watch?v=Ml70cWWfESw" rel="noopener ugc nofollow" target="_blank">新奇词汇</a>的神秘面纱。</p><p id="5e4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，JavaScript引擎是由什么构成的？</p><p id="a47d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要是两件事:一个调用栈和一个内存堆。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="746e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内存堆:</h1><ul class=""><li id="77db" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">内存中的一个大空间，我们以无序的方式随机存储<strong class="kf ir">变量和函数</strong>。</li><li id="c0aa" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">一个可以分配、使用和释放内存空间的地方。</li><li id="27b5" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">每个内存空间都以某种方式被引用。</li><li id="5a4b" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">一个内存空间可以引用另一个内存空间，使其成为其子空间。</li><li id="ad98" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">如果引用被破坏，内存空间将被垃圾回收器回收。</li></ul><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/6ec000881ea30b077b614a4c719ee3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5lzy5Tcc5sP0a6Xa5_wOkA.gif"/></div></div></figure><p id="e244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论内存堆空间有多大，都是有限的，超过限制就会导致内存泄漏，进而导致页面崩溃。</p><p id="3a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们一直分配空间而不释放它时，这很容易发生。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2866911c097c872d8c12f84e72690fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_FtV9jnwYiF4FRiOshdeug.gif"/></div></div></figure><p id="7c06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢天谢地，由于垃圾收集器，JavaScript在释放空间方面做得非常好。不像C，例如你从来没有释放内存释放空间，这一切都发生在后台自动，<strong class="kf ir">自动内存管理宝贝！</strong></p><p id="c3a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">垃圾收集器的工作方式非常简单:正如我所说的，每个内存空间都以某种方式被引用，所以对于内存中每个已用的空间，都存在一个引用它的链接。一旦链接断开，垃圾收集器就会收集该值，并释放内存空间。</p><p id="2ebf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> &gt; </strong>我们称之为<strong class="kf ir">标记和扫描</strong>算法，下面是它是如何进行的:</p><ol class=""><li id="1734" class="mg mh iq kf b kg kh kk kl ko nb ks nc kw nd la ne mo mp mq bi translated">垃圾收集器创建一个引用内存堆中某个空间的所有根变量的列表。</li><li id="02b1" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">它标记了所有的根、它们引用的内存空间以及它们的子节点。</li><li id="ae39" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">它会清除(丢弃)所有未标记的值，并释放它们所占用的空间。</li></ol><p id="1bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">&gt;因此，当一个内存空间的链接断开时，它将不再被垃圾收集器标记，而是被清除和释放。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/a040ef7666cab579c6c147f4d08a96ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*85p-8VU9_h4LY-hsyZO1cQ.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Garbage collector Representation</figcaption></figure><p id="8da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，如果垃圾收集器那么聪明，我们怎么还能得到内存泄漏呢？通过编写糟糕的代码！我们可以通过许多方式编写糟糕的代码并导致内存泄漏，这里有两个例子:</p><p id="f28f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">设置定时器并忘记它们:</strong></p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ed23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们创建了一个带有处理程序的时间间隔，该处理程序检查某个条件是否为真，如果为真，我们执行一些操作。interval的处理程序占用了内存堆中的空间，只要条件成立，它就会被执行。</p><p id="c399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是一旦页面上不再存在<em class="ni"> saiyan </em>元素，这意味着if条件不再为真，处理程序将会过时，并且会不必要地占用堆中的空间。除非我们记得清除间隔！</p><p id="7ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用错误或过多的全局变量:</strong></p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="64d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为全局变量总是链接到全局对象，所以它们永远不会被垃圾收集器收集。广泛或错误地使用它们可能会耗费大量内存。</p><p id="3adf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们使用了一个全局变量attackWarning，它在逻辑上只用于攻击函数内部。因此，在attack()执行完毕后，attackWarning变量将仍然存在于内存堆中，即使不再需要它。</p><p id="21d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不像attackResult变量和攻击者参数只存在于attack()内部，当它们的引用在函数执行完成后被破坏时由垃圾收集器收集。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="fd9a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">调用栈</strong></h1><p id="f60a" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">在JavaScript中，无论何时运行代码，它都是在一个“<strong class="kf ir">执行上下文</strong>中运行的，一个包含信息的包装器帮助我们知道我们在代码中的位置，我们需要什么变量…等等。每次执行一个函数时，都会创建一个新的执行上下文，并将其置于之前的执行上下文之上，从而创建一个堆栈:<strong class="kf ir">执行堆栈</strong>，也称为<strong class="kf ir">调用堆栈</strong>。当函数完成执行时，它的执行上下文被弹出堆栈。</p><p id="73c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，调用堆栈是内存中的一个特殊位置，它以后进先出的逻辑有序地存储包含代码信息的包装器。这些包装器有许多名称(因为开发人员喜欢让其他开发人员感到困惑)，您可以将它们称为执行上下文、堆栈帧或堆栈状态。让我们看一个例子:</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/823b30c6fc18fd30ac050f17e1a4f809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Yk07j41EmR4BJ1CGrjhXTA.gif"/></div></div></figure><p id="e7c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行上下文有两个阶段:创建阶段和执行阶段。</p><p id="23b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">创建阶段:</strong></p><p id="87da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建阶段，首先创建以下所有内容:</p><ul class=""><li id="a14c" class="mg mh iq kf b kg kh kk kl ko nb ks nc kw nd la mn mo mp mq bi translated">全局对象:当前正在执行的代码所属的对象，如果代码不属于特定的对象，默认情况下是全局对象窗口。</li><li id="c3b4" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">一个<strong class="kf ir">这个</strong>变量引用了全局对象</li><li id="119d" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">变量环境:列出所有变量和函数的空间，这些变量和函数在词汇上直接位于函数内部</li><li id="29cc" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">对外部环境的引用:函数在代码中的词法位置。</li><li id="f130" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">arguments对象:包含传递给函数的参数(如果存在的话)</li></ul><p id="7e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，吊装发生。你可以在这里详细了解它的所有内容<a class="ae kc" href="https://medium.com/javascript-in-plain-english/what-is-hoisting-in-javascript-7ad4f391c40e" rel="noopener">，但总而言之这意味着内存空间是为变量和函数分配的。JavaScript引擎将检查您的代码，每次发现变量或函数声明时，它都会添加一个对变量环境的引用，指向内存堆上的一个空白空间，并保留它。</a></p><p id="9efe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有点像“是的，我知道我需要一个空间来存放变量，这里和那里，所以让我在我的变量环境中创建引用，并在内存堆中保留空白空间”。</p><p id="6ec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">执行阶段:</strong></p><p id="6a1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这时，您的代码开始逐行执行。</p><p id="1ec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个例子:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="37a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，每次我们运行JavaScript代码时，第一个创建并添加到调用堆栈的执行上下文总是全局执行上下文。在我们的示例中，全局执行上下文如下所示:</p><ul class=""><li id="0ea9" class="mg mh iq kf b kg kh kk kl ko nb ks nc kw nd la mn mo mp mq bi translated">全局对象:<strong class="kf ir">窗口</strong></li><li id="ffe8" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir">该</strong>变量:参照<strong class="kf ir">窗口</strong></li><li id="cbaa" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">变量environment:具有指向存储在内存堆中的函数<strong class="kf ir"> attack( ) </strong>和<strong class="kf ir"> getAttackName( ) </strong>的引用。</li><li id="70ad" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">对外部环境的引用:<strong class="kf ir"> null </strong>，因为我们在最外层。</li></ul><p id="c803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当调用attack()时，在全局执行上下文之上创建一个新的执行上下文，其内容如下:</p><ul class=""><li id="7ee0" class="mg mh iq kf b kg kh kk kl ko nb ks nc kw nd la mn mo mp mq bi translated">全局对象:因为attack()没有直接的父对象，所以默认情况下，attack()内部运行的代码属于全局对象窗口</li><li id="9df1" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir">该</strong>变量:参照<strong class="kf ir">窗口</strong></li><li id="0880" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">变量environment:引用了内存堆中的变量attackName</li><li id="b685" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">对外部环境的引用:<strong class="kf ir">引用全局执行上下文</strong>，因为attack()物理上位于“外部”，意思是不在另一个函数内部。</li><li id="d218" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">Arguments:对位于内存堆上的参数攻击者的引用</li></ul><p id="d3b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当调用getAttackName()时，会创建第三个执行上下文:</p><ul class=""><li id="9d6b" class="mg mh iq kf b kg kh kk kl ko nb ks nc kw nd la mn mo mp mq bi translated">全局对象:因为getAttackName()没有直接的父对象，所以在getAttackName()中运行的代码默认属于全局对象窗口</li><li id="f17e" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir">本</strong>变量:参照<strong class="kf ir">窗口</strong></li><li id="ca20" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">变量环境:为空</li><li id="f9e9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">对外部环境的引用:<strong class="kf ir">引用全局执行上下文</strong>，因为getAttackName()物理上位于“外部”，意味着不在另一个函数内部。</li></ul><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/812275226733be4829080cda04b71ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zI1-S9Pv1awPpfOgmE3O_g.png"/></div></div></figure><p id="fbec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是几乎相同的一段代码的另一个例子，有一点小小的变化，getAttackName()函数是在attack()函数内部声明的:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为getAttackName()函数是在attack()函数内部按词汇声明的，所以getAttackName()的外部环境现在将是attack()的执行上下文。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/799f785935fa3b2593d19e47a8d8563e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBjnMZ9SYv33e2rCYE5B-A.png"/></div></div></figure><p id="9ed7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用堆栈，就像内存堆一样，在空间方面有一些限制，如果我们超过这些限制，我们会得到一个堆栈溢出错误(抛出一个错误，但浏览器不会像在内存泄漏的情况下那样崩溃)。例如，当我们调用递归函数(调用自身的函数)时，可以做到这一点，而无需添加任何break来中断递归。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/c84c72e824d159c9f9a54e8a51046909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/1*xjhPcM027gMRApCCMdRUFw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Stack Overflow</figcaption></figure><p id="62ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是JavaScript引擎的内容:</p><ul class=""><li id="857b" class="mg mh iq kf b kg kh kk kl ko nb ks nc kw nd la mn mo mp mq bi translated">一个内存堆，用来存储你使用的东西，比如变量，对象，函数…</li><li id="d411" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir">一个调用栈</strong>来存储并跟踪你在代码中的位置，你需要什么变量，之前发生了什么，以及接下来会发生什么。</li></ul><p id="1e01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">&gt;两者都是存放东西的<strong class="kf ir">内存空间</strong>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="c896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个概念，任何人都可以制作自己的JavaScript引擎，而且每个人都这么做了……有这么多的JavaScript引擎，看看这个维基百科页面就知道了。最著名的JavaScript引擎是谷歌开发的，Chrome运行在这个名为<strong class="kf ir"> V8 </strong>的引擎上。V8也是Node.js和Deno使用的JavaScript引擎。有运行Firefox的SpiderMonkey，Safari的JavaScriptCore，还有许多其他的……</p><p id="0e3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有这么多的JavaScript引擎，必须有某种指导方针来规范它们！对，那就是ECMA标准<a class="ae kc" href="https://www.ecma-international.org/publications/standards/Standard.htm" rel="noopener ugc nofollow" target="_blank"/>。因此，如果您想创建自己的JavaScript引擎，尽一切办法去做吧，只要遵循ECMA标准中列出的规范即可。</p><p id="c1ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在结束这篇越来越长的文章之前，我想补充最后一点。因为ECMA标准没有定义<strong class="kf ir">如何</strong>或<strong class="kf ir">在哪里</strong>存储数据(在堆或调用堆栈中)，您可能会惊讶地发现，有时变量可以直接存储在调用堆栈中执行上下文的变量环境中！</p><p id="ea23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果一个JavaScript引擎开发人员认为，仅仅为了获得一个简单的数字值而将一个引用存储在调用堆栈的一个内存空间中，而这个内存空间指向堆中的另一个内存空间，那就太麻烦了！他可以简单地决定直接将数字存储在调用堆栈中(在当前执行上下文的可变环境中)。</p><p id="3626" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于“变量存储在哪里，在堆中还是在调用堆栈中？”这个问题，没有正确或错误的答案。这真的取决于JavaScript引擎开发团队的喜好。</p><p id="dce8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是大多数人会这样想:</p><ul class=""><li id="881f" class="mg mh iq kf b kg kh kk kl ko nb ks nc kw nd la mn mo mp mq bi translated">像数字、布尔值、字符串这样的简单变量将直接存储在调用堆栈中。</li><li id="ed6a" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">复杂的对象或复杂的结构会存储在堆中。</li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="f67a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">TL；速度三角形定位法(dead reckoning)</h1><ol class=""><li id="03fc" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la ne mo mp mq bi translated">JavaScript引擎由两部分组成:内存堆和调用栈</li><li id="df1a" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">内存堆是一个我们可以以无序方式存储变量和函数的地方</li><li id="4078" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">如果我们一直在内存堆中分配空间，使其永远不会被释放，这可能会导致浏览器崩溃的内存泄漏。</li><li id="3070" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">堆上未使用的内存空间由垃圾收集器收集并释放</li><li id="206b" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">垃圾收集器使用标记和清除方法</li><li id="273a" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">调用堆栈是一个我们可以存储包装器的地方，这些包装器以有序的后进先出方式跟踪我们在代码中的位置</li><li id="cdaa" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">每个包装器被称为一个执行上下文、一个堆栈帧或一个堆栈状态</li><li id="6d5e" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">每次调用一个函数时，都会创建一个新的执行上下文并将其添加到堆栈中</li><li id="2489" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">堆栈中的第一个执行上下文将始终是全局执行上下文</li><li id="0451" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">如果调用堆栈上添加了太多的执行上下文，可能会导致堆栈溢出错误(浏览器不会崩溃)</li><li id="484b" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">任何人都可以创建自己的JavaScript引擎</li><li id="a792" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">ECMA标准是创建新JavaScript引擎的指导方针</li><li id="3d44" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">ECMA标准没有定义数据存储的方式和位置，这取决于JavaScript引擎开发人员的喜好。</li><li id="6385" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la ne mo mp mq bi translated">通常简单的数据直接存储在每个执行上下文的变量环境中的调用栈上，复杂的对象存储在堆上。</li></ol></div></div>    
</body>
</html>