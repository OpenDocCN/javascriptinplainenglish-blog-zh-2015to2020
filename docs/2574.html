<html>
<head>
<title>Why You Keep Getting “Null” After Running setState() in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在React中运行setState()后总是得到“Null”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-keep-getting-null-after-running-setstate-in-react-299e1835bd92?source=collection_archive---------3-----------------------#2020-07-06">https://javascript.plainenglish.io/why-you-keep-getting-null-after-running-setstate-in-react-299e1835bd92?source=collection_archive---------3-----------------------#2020-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/555a19e062d60309e69bb76df7761a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIzNp-TiXtc4-OpvCiU8-w.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@blakeconnally?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Blake Connally</a> on <a class="ae jz" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bb05" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我最近开始学习React，我已经认定它是我最喜欢的JavaScript库。在我的第一个React项目(构建一个简单的游戏)中，我在使用this.setState更改组件状态时遇到了一个问题。我没有选择我的玩家的武器，也没有在DOM中忠实地弹出获胜的玩家，而是一直得到一个巨大的“空”为什么？因为<strong class="kc io"> React的setState有时候是异步的</strong>。</p><p id="5db9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是文档对setState()的描述:</p><blockquote class="ky kz la"><p id="8888" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">把<code class="fe lf lg lh li b">setState()</code>看作是一个<em class="in">请求</em>而不是一个立即更新组件的命令。为了获得更好的性能，React可能会延迟它，然后一次更新几个组件。React不保证立即应用状态更改。</p><p id="702e" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><code class="fe lf lg lh li b">setState()</code>并不总是立即更新组件。它可以批处理或推迟更新，直到以后。这使得在调用<code class="fe lf lg lh li b">setState()</code>之后立即读取<code class="fe lf lg lh li b">this.state</code>成为一个潜在的陷阱。相反，使用<code class="fe lf lg lh li b">componentDidUpdate</code>或<code class="fe lf lg lh li b">setState</code>回调(<code class="fe lf lg lh li b">setState(updater, callback)</code>)，这两种方法都保证在应用更新后触发。如果您需要根据之前的状态来设置状态，请阅读下面的<code class="fe lf lg lh li b">updater</code>参数。</p></blockquote><p id="e5bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为这不能保证立即更新，所以如果您在调用setState()后直接依赖更新后的状态，就会遇到麻烦。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="fca5" class="lr ls in li b gy lt lu l lv lw">play = () =&gt; { <br/>  //function setting state of computer move<br/>  this.random();</span><span id="0522" class="lr ls in li b gy lx lu l lv lw">  //setting state of player move based on input value <br/>  this.setState({      <br/>    playerMove: document.querySelector('.move-input').value,    <br/>  });</span><span id="7907" class="lr ls in li b gy lx lu l lv lw">  //this function did not work because the player value returned <br/>  "null" <br/>  this.whoWins(); <br/>}</span></pre></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="43ec" class="lr ls in bd mf mg mh dn mi mj mk dp ml kl mm mn mo kp mp mq mr kt ms mt mu mv bi translated">异步与同步</h2><p id="2660" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated"><strong class="kc io">同步功能</strong>以“一次一个客户”的态度处理，直到功能完成或弹出错误才继续。<strong class="kc io">异步函数</strong>将开始执行代码，但是让函数在后台做它的事情，而你的代码继续运行，只有当异步函数中的代码已经完成运行时才返回(通过像回调或承诺这样的方法)。异步函数对于像API请求这样的较长流程非常有用，因为您不希望用户在您的代码运行时无所事事，试图找到正确的数据或文件。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="99a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">那么有什么解决办法呢？</strong></p><p id="429e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">了解到setState是异步的，您需要确保您的后续代码在状态完成更改之前不会运行。有多种方法可以告诉你的代码“嘿，在上面的异步函数停止运行之前，不要启动这个函数。”这些包括回调、承诺、async/await、componentDidUpdate…因为我的程序非常简单，所以我用回调解决了我的问题。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="5246" class="lr ls in li b gy lt lu l lv lw">play = () =&gt; { <br/>  //function setting state of computer move <br/>  this.random();</span><span id="bd5f" class="lr ls in li b gy lx lu l lv lw">//setting state of player move basec on input value <br/>  this.setState({      <br/>    playerMove: document.querySelector('.move-input').value,    <br/>  }, </span><span id="50d0" class="lr ls in li b gy lx lu l lv lw">  //using a callback, this function now works!<br/>  () =&gt; this.whowins());<br/>}</span></pre><p id="ac71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！我很乐意听到您的反馈或替代解决方案。</p><h2 id="e713" class="lr ls in bd mf mg mh dn mi mj mk dp ml kl mm mn mo kp mp mq mr kt ms mt mu mv bi translated">延伸阅读:</h2><p id="bdb8" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated"><a class="ae jz" href="https://reactjs.org/docs/react-component.html#setstate" rel="noopener ugc nofollow" target="_blank">反应文件</a></p><p id="15c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">小帕特里克·布朗的<a class="ae jz" href="https://medium.com/@pjbrn26/async-vs-sync-d369a4ef95e5" rel="noopener">异步vs同步</a></p><p id="67d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/@wereHamster/beware-react-setstate-is-asynchronous-ce87ef1a9cf3" rel="noopener">当心:React setState是异步的！</a>托马斯·卡尼基</p><p id="35ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing" rel="noopener ugc nofollow" target="_blank">MDN web docs引入异步JavaScript </a></p><p id="7f78" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Flavio Copes的JavaScript异步编程和回调</p></div></div>    
</body>
</html>