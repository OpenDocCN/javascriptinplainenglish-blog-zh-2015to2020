<html>
<head>
<title>Understanding Angular Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解角度视图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/views-in-angular-390c3906b988?source=collection_archive---------1-----------------------#2019-11-06">https://javascript.plainenglish.io/views-in-angular-390c3906b988?source=collection_archive---------1-----------------------#2019-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/16273a9fefbd893b9c5f5f2dfeb2bc69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMMRrHM1TfqAV6MJ-GbeCA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@pawelskor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Paul Skorupskas</a> on <a class="ae jz" href="https://unsplash.com/s/photos/view?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="eab8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">什么是视图？</strong></p><p id="3191" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以一起创建和销毁的最小显示元素组。</p><p id="599e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">响应于用户动作，视图中元素的属性可以动态改变；视图中元素的结构(数量和顺序)不能。可以通过在视图容器中插入、移动或删除嵌套视图来更改元素的结构。— <a class="ae jz" href="https://angular.io/guide/glossary#view" rel="noopener ugc nofollow" target="_blank"> <em class="ky">根据</em> </a> <em class="ky">角度文件。</em></p><p id="ab18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">视图基本上是由视图节点组成的数据结构，视图节点保存对相应DOM元素的引用。每个组件都有一个与之关联的组件视图。</p><p id="ef6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">变化检测循环在视图上运行，当angular在组件视图状态中发现变化时，DOM中相应的节点元素会再次呈现。</p><p id="952b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个视图的结构:</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/698d6ccb5caaa2804efcfb337e5a0ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbfVLOw-Vb63WvUpwolsVg.png"/></div></div></figure><p id="5ac8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">组件模板中的元素被添加为<strong class="kc io">节点</strong>数组。上面的视图在其模板中有5个节点。<strong class="kc io">组件</strong>属性保存相关组件的状态。</p><p id="40ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与视图相关的类别:</p><p id="d1aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">changeedetorref—</strong>角度视图的基类，提供变化检测功能。该类提供了与更改检测相关的各种方法。</p><p id="a636" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> ViewRef — </strong>代表一个角度视图，特别是由一个组件定义的主视图。这个类扩展了<strong class="kc io">changededetorref。</strong>除了从父类继承的方法，它还提供了与组件/组件视图相关的方法。</p><p id="f4f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> EmbeddedViewRef — </strong>表示视图容器中的角度<a class="ae jz" href="https://angular.io/guide/glossary#view" rel="noopener ugc nofollow" target="_blank">视图</a>。一个<a class="ae jz" href="https://angular.io/guide/glossary#view-tree" rel="noopener ugc nofollow" target="_blank">嵌入视图</a>可以从一个组件引用，而不是从其模板定义它的宿主组件引用，或者它可以由一个<code class="fe le lf lg lh b"><a class="ae jz" href="https://angular.io/api/core/TemplateRef" rel="noopener ugc nofollow" target="_blank">TemplateRef</a></code>独立定义。</p><p id="bf41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> ViewContainerRef — </strong>表示一个容器，其中可以将一个或多个视图附加到一个组件。它可以包含<em class="ky">宿主视图</em>(通过用<code class="fe le lf lg lh b">createComponent()</code>方法实例化一个组件创建)，以及<em class="ky">嵌入视图</em>(通过用<code class="fe le lf lg lh b">createEmbeddedView()</code>方法实例化一个<code class="fe le lf lg lh b"><a class="ae jz" href="https://angular.io/api/core/TemplateRef" rel="noopener ugc nofollow" target="_blank">TemplateRef</a></code>创建)。</p><p id="e2d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个视图容器实例可以包含其他视图容器，创建一个<a class="ae jz" href="https://angular.io/guide/glossary#view-tree" rel="noopener ugc nofollow" target="_blank">视图层次</a>。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/eadb219672756f971ef16d6e5f5dffe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-x5zVXtfRxj7xDFY9esDA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">View Classes Hierarchy</figcaption></figure><h1 id="1247" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">视图类型</h1><p id="875f" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">视图有两种类型:<strong class="kc io">嵌入式</strong>和<strong class="kc io">主机</strong></p><p id="5815" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嵌入视图链接到模板，而主体视图链接到构件。</p><p id="4670" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">创建嵌入式视图</strong></p><p id="f17e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的例子中，我们从组件模板中插入的模板创建一个嵌入式视图。</p><p id="4996" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe le lf lg lh b">&lt;ng-container&gt;&lt;/ng-container&gt;</code>标签被用作嵌入视图的视图容器(通过使用@ViewChild查询将其作为view container读取)。它充当锚定元素，视图将在其下方插入到组件模板中。</p><p id="2e48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">容器的<strong class="kc io"> createEmbeddedView() </strong>方法被传递模板引用来创建视图。</p><pre class="la lb lc ld gt mm lh mn mo aw mp bi"><span id="2122" class="mq lk in lh b gy mr ms l mt mu">import { Component, AfterViewInit, ViewChild,<br/>ViewContainerRef, TemplateRef } from '@angular/core';</span><span id="96e7" class="mq lk in lh b gy mv ms l mt mu">@Component({<br/>  selector: 'app-embedded-view',<br/>  template: `<br/>  &lt;h1&gt;Application Content&lt;/h1&gt;<br/>  &lt;ng-container #vc&gt;&lt;/ng-container&gt; <br/>  &lt;h3&gt;End of Application&lt;/h3&gt;</span><span id="0a1f" class="mq lk in lh b gy mv ms l mt mu">  &lt;ng-template #tpl&gt;<br/>    &lt;h1&gt;Template Header&lt;/h1&gt;<br/>  &lt;/ng-template&gt;<br/>  `<br/>})<br/>export class EmbeddedViewComponent implements AfterViewInit {<br/>  @ViewChild("tpl", { read: TemplateRef }) tpl: TemplateRef&lt;any&gt;;<br/>  @ViewChild("vc", { read: ViewContainerRef }) container: ViewContainerRef;</span><span id="4c98" class="mq lk in lh b gy mv ms l mt mu">  constructor() { }</span><span id="21a7" class="mq lk in lh b gy mv ms l mt mu">  ngAfterViewInit() {<br/>    this.container.createEmbeddedView(this.tpl);<br/>  }<br/>}</span></pre><p id="9414" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">创建主机视图</strong></p><p id="3265" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">主体视图与构件相关。它们是在动态创建组件时创建的。下面的<strong class="kc io">动态组件</strong>是使用其工厂动态创建的。</p><p id="18ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用注入到组件构造函数中的<strong class="kc io">componentffactoryresolver实例</strong>来解析工厂。</p><p id="cc7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，通过使用容器的<strong class="kc io"> createComponent() </strong>方法并传递<strong class="kc io"> DynamicComponent </strong>工厂，组件视图被添加到视图容器中。</p><pre class="la lb lc ld gt mm lh mn mo aw mp bi"><span id="f591" class="mq lk in lh b gy mr ms l mt mu">@Component({<br/>  template: `&lt;h1&gt;I am dynamically used component element.&lt;/h1&gt;`<br/>})</span><span id="859a" class="mq lk in lh b gy mv ms l mt mu">export class DynamicComponent { }</span><span id="f53b" class="mq lk in lh b gy mv ms l mt mu">import { AfterViewInit, Component, ViewChild,<br/>ViewContainerRef, ComponentFactoryResolver } from '@angular/core';<br/>import { DynamicComponent} from './dynamic.component';</span><span id="a633" class="mq lk in lh b gy mv ms l mt mu">@Component({<br/>  selector: 'app-host-view',<br/>  template: `<br/>  &lt;h1&gt;Host View example&lt;/h1&gt;<br/>  &lt;ng-container #container&gt;&lt;/ng-container&gt;<br/>  `,<br/>  entryComponents: [ DynamicComponent]<br/>})<br/>export class HostViewComponent implements AfterViewInit {<br/>  @ViewChild("container", { read: ViewContainerRef }) ctr: ViewContainerRef;</span><span id="5274" class="mq lk in lh b gy mv ms l mt mu">  constructor(private resolver: ComponentFactoryResolver) { }</span><span id="ea0f" class="mq lk in lh b gy mv ms l mt mu">  ngAfterViewInit() {<br/>    const factory = this.resolver.resolveComponentFactory(DynamicComponent);<br/>    this.ctr.createComponent(factory);<br/>  }<br/>}</span></pre><p id="c367" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">应该确保要动态创建的组件应该被添加到<strong class="kc io"> entryComponents </strong>数组中，以便在编译时创建组件的工厂。</p><blockquote class="mw mx my"><p id="28d1" class="ka kb ky kc b kd ke kf kg kh ki kj kk mz km kn ko na kq kr ks nb ku kv kw kx ig bi translated">谢谢你的时间…:)</p></blockquote></div></div>    
</body>
</html>