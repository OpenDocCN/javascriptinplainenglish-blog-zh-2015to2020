<html>
<head>
<title>Getting Started with express-validator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速验证器入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-express-validator-fae0bbeeb0f9?source=collection_archive---------1-----------------------#2020-07-11">https://javascript.plainenglish.io/getting-started-with-express-validator-fae0bbeeb0f9?source=collection_archive---------1-----------------------#2020-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a99bd3c785a43a36f5827d82e9794be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TSUYcTo2u-EpK7Gf"/></div></div></figure><p id="cf86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我们将学习express-validator。我们还将学习自定义错误处理和自定义验证器。要阅读本文，您应该对express.js有一些基本的了解。</p><h1 id="d3c0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">快速验证器简介</h1><p id="0e70" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Express-validator是一个Express中间件，它为我们提供了验证和净化功能。实际上，Express validator是建立在validator.js之上的。Validator.js是一个帮助我们验证几种不同类型的数据的库。</p><h1 id="3241" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么要验证？</h1><p id="c52a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">你可能会想“为什么我们需要验证？”这个问题问得好。假设我们有一个强大的应用程序，具有多种丰富的功能。比方说，这个功能丰富的应用程序可以让用户拨打世界上任何一个电话号码。要打电话，我们显然需要用户的电话号码。如果用户给了我们一个无效格式的电话号码或者只是一个随机的字符串会怎么样？在这种情况下，我们的应用程序可能会失灵。但是这个健壮的应用程序的开发者已经实现了验证，所以如果用户输入无效，应用程序会用一些错误消息来响应。这只是验证有用的一个例子。</p><p id="82ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lw">谨记“从客户端接收的数据不应盲目信任。”因此，添加一个验证检查。简单！</em></p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><p id="935d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们进入有趣的部分！我们将通过为用户注册创建验证来学习express-validator。现在，跳过工作目录中的终端，编写以下命令:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dcfb" class="mn ku in mj b gy mo mp l mq mr">npm init -y</span></pre><p id="002c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们在主项目目录中创建一个名为<strong class="jx io"> index.js </strong>的文件。之后，在工作目录中创建两个目录，分别名为routes和controller。在routes目录中，创建一个名为<strong class="jx io"> appRoute.js </strong>的文件。同样，在控制器目录中创建<strong class="jx io"> appController.js </strong>文件。这应该使我们的文件夹结构看起来像这样:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/322707612f5781df242bfe84f167a51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*P4U-Z-nJsGfwgtSDH4V1lQ.png"/></div></figure><p id="0c91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们安装我们需要的包。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="edb0" class="mn ku in mj b gy mo mp l mq mr">npm i express express-validator</span></pre><p id="4e3f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经安装了包，让我们也安装Nodemon作为我们的开发依赖项。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d868" class="mn ku in mj b gy mo mp l mq mr">npm i -D nodemon</span></pre><p id="1303" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Nodemon是一个包，它通过在每次更改后自动重启服务器来帮助我们简化开发过程。标志帮助我们将这个包作为一个开发依赖包来安装。</p><p id="4695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们打开文件<strong class="jx io"> package.json </strong>并对脚本进行一些修改，这样我们就可以使用Nodemon了。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1067" class="mn ku in mj b gy mo mp l mq mr">"scripts": {</span><span id="d082" class="mn ku in mj b gy mw mp l mq mr">  "dev": "nodemon index.js",</span><span id="2f77" class="mn ku in mj b gy mw mp l mq mr">  "start": "node index.js"</span><span id="0827" class="mn ku in mj b gy mw mp l mq mr">}</span></pre><p id="18f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该使我们的<strong class="jx io"> package.json </strong>文件看起来像这样:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/d9f4b32ea05775610e00579769de99bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YROIcZXPgO8UcbC6ceRJng.png"/></div></div></figure><p id="3bf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在命令行中，键入以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="efde" class="mn ku in mj b gy mo mp l mq mr">npm run dev</span></pre><p id="2097" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将启动我们的开发服务器，它也会在每次更改时自动重启。</p><p id="5dc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们转到主项目目录中的文件<strong class="jx io"> index.js </strong>并编写以下代码行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3d60" class="mn ku in mj b gy mo mp l mq mr">const express = require("express");</span><span id="c076" class="mn ku in mj b gy mw mp l mq mr">const AppRoute = require("./routes/appRoute");</span><span id="48f3" class="mn ku in mj b gy mw mp l mq mr">const app = express();</span><span id="46db" class="mn ku in mj b gy mw mp l mq mr">const PORT = process.env.PORT || 3000;</span><span id="bf7a" class="mn ku in mj b gy mw mp l mq mr">app.use(express.json());</span><span id="0840" class="mn ku in mj b gy mw mp l mq mr">app.use("/api/", AppRoute);</span><span id="a78f" class="mn ku in mj b gy mw mp l mq mr">app.listen(PORT, () =&gt; console.log(`listening on port ${PORT}`));</span></pre><p id="25ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，我们已经导入了<code class="fe mt mu mv mj b">AppRoute</code>并初始化了app。我们使用<code class="fe mt mu mv mj b">express.json()</code>中间件来处理JSON数据。然后，我们增加了一条<code class="fe mt mu mv mj b">/api/</code>路线。之后，我们在<code class="fe mt mu mv mj b">PORT </code>上启动了我们的服务器。</p><p id="1b28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们转到routes目录并打开<strong class="jx io"> appRoute.js </strong>。我们的<strong class="jx io"> appRoute.js </strong>文件应该有以下几行代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d305" class="mn ku in mj b gy mo mp l mq mr">const express = require("express");</span><span id="4a90" class="mn ku in mj b gy mw mp l mq mr">const { signupController } = require("../controller/appController");</span><span id="7789" class="mn ku in mj b gy mw mp l mq mr">const router = express.Router();</span><span id="28d5" class="mn ku in mj b gy mw mp l mq mr">router.post("/signup", signupController);</span><span id="95cd" class="mn ku in mj b gy mw mp l mq mr">module.exports = router;</span></pre><p id="0510" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里没什么特别的。我们进口了<code class="fe mt mu mv mj b">appController</code>，增加了一条<code class="fe mt mu mv mj b">/api/signup</code>的路线。</p><p id="d570" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们转到控制器目录中的文件<strong class="jx io"> appController.js </strong>。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ea17" class="mn ku in mj b gy mo mp l mq mr">const signupController = (<em class="lw">req</em>, <em class="lw">res</em>) =&gt; {</span><span id="24fc" class="mn ku in mj b gy mw mp l mq mr"><em class="lw">  // add the user to the database</em></span><span id="d906" class="mn ku in mj b gy mw mp l mq mr">  return res.status(200).json({ msg: "success" });</span><span id="1ade" class="mn ku in mj b gy mw mp l mq mr">};</span><span id="792c" class="mn ku in mj b gy mw mp l mq mr">module.exports = { signupController };</span></pre><p id="9ad5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，我们向用户发送状态为200的消息。您显然知道这个函数只有在数据被验证时才起作用。请注意，我没有添加注册功能的代码，这里只写了伪代码。这是因为我们在这里的重点是实现验证。</p><p id="c8f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们实现express-validator。为此，让我们打开routes文件夹中的文件<strong class="jx io"> appRoute.js </strong>，并编写以下代码行:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="918d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们加了很多东西。一个一个说吧。我们从<code class="fe mt mu mv mj b">express-validator</code>导入了<code class="fe mt mu mv mj b">check</code>和<code class="fe mt mu mv mj b">validationResult </code>。然后我们实现了一个<code class="fe mt mu mv mj b">check</code>。<code class="fe mt mu mv mj b">check</code>方法用于向字段添加验证。在我们的例子中，我们为<code class="fe mt mu mv mj b">name</code>、<code class="fe mt mu mv mj b">email</code>、<code class="fe mt mu mv mj b">password</code>、<code class="fe mt mu mv mj b">confirmPassword</code>添加了<code class="fe mt mu mv mj b">check</code>验证。也可以用<code class="fe mt mu mv mj b">body</code>方法代替<code class="fe mt mu mv mj b">check</code>方法。但是在我们的例子中，我们将使用<code class="fe mt mu mv mj b">check</code>而不是<code class="fe mt mu mv mj b">body</code>，好吗？</p><p id="c37c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们仔细看看<code class="fe mt mu mv mj b">check("name")</code>。在这里，我们实现了<code class="fe mt mu mv mj b">.isLength({min:3})</code>。它的功能是告诉express-validator,<code class="fe mt mu mv mj b">name </code>字段的最小长度应该是3个字符。如果需要，您也可以设置最大长度。以下是使用<code class="fe mt mu mv mj b">max</code>的方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f1d6" class="mn ku in mj b gy mo mp l mq mr"><strong class="mj io">check("name").isLength({ min:3, max:20 })</strong></span></pre><p id="ed9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要不要实施，看你自己了。</p><p id="5341" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们就有了<code class="fe mt mu mv mj b">.withMessage()</code> <em class="lw">。它帮助我们告诉express-validator错误信息应该是什么。默认情况下，Express-validator确实为我们提供了错误消息，但是express-validator提供的消息并不清楚。这个错误信息必须提供给我们的用户。为了让消息更容易理解和用户友好，我们使用了<code class="fe mt mu mv mj b">.withMessage()</code>。你明白了，对吧？</em></p><p id="6ce8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们来看看<code class="fe mt mu mv mj b">check(“email”)</code>。我们需要检查我们在该字段中收到的数据是否是电子邮件。幸运的是，express-validator提供了<code class="fe mt mu mv mj b">.isEmail()</code>功能，帮助我们检查数据是否是电子邮件。之后，我们使用了<code class="fe mt mu mv mj b">.normalizeEmail()</code>，它可以帮助我们规范从用户那里收到的电子邮件。</p><p id="28ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来看看<code class="fe mt mu mv mj b">check(“password”)</code>。您可以决定希望用户输入什么类型的数据作为密码。我希望用户至少有一个数字，至少有一个特殊字符，最小长度为8，最大长度为15。你可以看到我们用<code class="fe mt mu mv mj b">.isLength()</code>表示最小和最大长度。然后，我们用了<code class="fe mt mu mv mj b">.matches(/\d/)</code>。该命令告诉express-validator它应该至少包含一个数字。<code class="fe mt mu mv mj b">matches()</code>命令实际上接受regex。如果你不明白<code class="fe mt mu mv mj b">/\d/</code>是做什么的，它只是正则表达式。我推荐你看一下regex。然后，我们实现了<code class="fe mt mu mv mj b">.matches(/[!@#$%^&amp;*(),.?":{}|&lt;&gt;]/)</code>。这有助于我们检查密码是否包含至少一个特殊字符。</p><p id="9a4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来看看<code class="fe mt mu mv mj b">check("confirmPassword")</code>。这里我们实现了<code class="fe mt mu mv mj b">.custom()</code>，这意味着我们创建了一个定制的验证器。<code class="fe mt mu mv mj b">.custom()</code>带<code class="fe mt mu mv mj b">value </code>和<code class="fe mt mu mv mj b">{req}</code>。<code class="fe mt mu mv mj b">value</code>是我们在<code class="fe mt mu mv mj b">confirmPassword</code>字段中从用户那里收到的数据，而<code class="fe mt mu mv mj b">req</code>让我们可以访问请求。然后我们比较了<code class="fe mt mu mv mj b">confirmPassword</code>(也就是<code class="fe mt mu mv mj b">value</code>)和<code class="fe mt mu mv mj b">password</code>(也就是<code class="fe mt mu mv mj b">req.body.password</code>)是否匹配。如果<code class="fe mt mu mv mj b">confirmPassword</code>不匹配，我们将抛出一个新的带有错误信息的<code class="fe mt mu mv mj b">Error()</code>，否则我们返回<code class="fe mt mu mv mj b">true</code>。</p><p id="baf4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，您可以在验证检查之后立即看到一个功能/中间件，如下所示:<code class="fe mt mu mv mj b">(req,res,next)=&gt;{...}</code>，对吗？在函数内部你可以看到<code class="fe mt mu mv mj b">validationResult(req)</code>。这个命令返回给我们错误。这个错误返回多个值，我们可能不需要这些值。在某些情况下，我们确实需要它。</p><p id="7f30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，在本文中，我假设我们只需要错误消息。所以，我使用了<code class="fe mt mu mv mj b">.formatWith()</code>命令。这个命令帮助我们格式化错误消息。正如我之前所说的，我们将返回一个错误消息<code class="fe mt mu mv mj b">msg</code>。我们可以使用<code class="fe mt mu mv mj b">.formatWith()</code>接收和格式化多种其他数据。分别是:<code class="fe mt mu mv mj b">location</code>、<code class="fe mt mu mv mj b">msg</code>、<code class="fe mt mu mv mj b">param</code>、<code class="fe mt mu mv mj b">value</code>、<code class="fe mt mu mv mj b">nestedErrors</code>。您可以在express-validator文档中了解更多信息。好吗？</p><p id="17e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后可以看到命令<code class="fe mt mu mv mj b">!error.isEmpty()</code>。这将返回<code class="fe mt mu mv mj b">true</code>或<code class="fe mt mu mv mj b">false</code>。很简单，对吧？然后我们将布尔值存储在<code class="fe mt mu mv mj b">hasError</code>变量中。</p><p id="0722" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们执行了上面代码中的一个条件。如果<code class="fe mt mu mv mj b">hasError</code>为<code class="fe mt mu mv mj b">true</code>，用户会收到状态422和错误信息。注意，我们使用了<code class="fe mt mu mv mj b">error.array()</code>，它帮助我们创建一个错误消息数组。该数组被发送给用户。非常简单，对吗？如果<code class="fe mt mu mv mj b">hasError</code>是<code class="fe mt mu mv mj b">false</code>，我们使用<code class="fe mt mu mv mj b">next()</code>。我希望你知道<code class="fe mt mu mv mj b">next()</code>是做什么的。</p></div><div class="ab cl lx ly hr lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ig ih ii ij ik"><h2 id="b2bc" class="mn ku in bd kv na nb dn kz nc nd dp ld kg ne nf lh kk ng nh ll ko ni nj lp nk bi translated">这意味着您已经成功实现了express-validator！</h2><p id="4da7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这篇文章肯定会让你开始使用express-validator。现在，我建议你一定要查看一下express-validator的<a class="ae nl" href="https://express-validator.github.io/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>以深入了解。</p></div></div>    
</body>
</html>