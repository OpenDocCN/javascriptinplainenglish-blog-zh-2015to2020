<html>
<head>
<title>Why Should We Be Careful of JavaScript Type Coercion?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么要小心JavaScript类型强制？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-should-we-be-careful-of-javascript-type-coercion-ba9c471f16cd?source=collection_archive---------8-----------------------#2019-12-09">https://javascript.plainenglish.io/why-should-we-be-careful-of-javascript-type-coercion-ba9c471f16cd?source=collection_archive---------8-----------------------#2019-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a4f0408d8453efb830bacc3069728c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zUI_r_rqXxDU0NgK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sleblanc01?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephanie LeBlanc</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e663" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于JavaScript是一种动态类型的编程语言，对象和变量的数据类型可以动态改变。这是我们在编写越来越多的JavaScript程序时经常会遇到的问题。关于类型强制，需要注意一些事情，类型强制是指在程序执行过程中动态地转换数据类型。</p><h1 id="2deb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型强制</h1><p id="0a9e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">正如我们提到的，类型强制是动态地改变数据类型。当数据与预期类型不匹配时，就会发生这种情况。例如，如果我们想要操作数字和数字串，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f9dc" class="mn lc iq mj b gy mo mp l mq mr">2*'5'</span></pre><p id="a9e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们能拿回10美元。</p><p id="0397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这似乎是一个非常方便的特性，但是它也设置了很多我们可能会陷入的陷阱。例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7a14" class="mn lc iq mj b gy mo mp l mq mr">1 +'1'</span></pre><p id="07c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f619" class="mn lc iq mj b gy mo mp l mq mr">"11"</span></pre><p id="9299" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是我们想要的。</p><p id="8947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript具有类型强制，也是因为这种语言原本没有异常，所以在执行无效操作时会返回一些值。这些值的例子包括<code class="fe ms mt mu mj b">Infinity</code>或<code class="fe ms mt mu mj b">NaN</code>，当我们将一个数除以0或试图将一些没有数字内容的东西分别转换为一个数时，这些值就会返回。</p><p id="3aad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">NaN</code>代表非数字。</p><p id="086b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3d81" class="mn lc iq mj b gy mo mp l mq mr">+'abc'</span></pre><p id="97a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ms mt mu mj b">NaN</code>因为它试图将字符串<code class="fe ms mt mu mj b">'abc'</code>转换成数字不成功，所以它没有抛出异常，而是返回<code class="fe ms mt mu mj b">NaN</code>。</p><p id="6e50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript更现代的部分确实会抛出异常。例如，如果我们试图运行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="31fe" class="mn lc iq mj b gy mo mp l mq mr">undefined.foo</span></pre><p id="d4a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到“未捕获的类型错误:无法读取未定义的属性“foo”</p><p id="152d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个例子是在算术运算中混合数字和BigInt操作数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c424" class="mn lc iq mj b gy mo mp l mq mr">6 / 1n</span></pre><p id="8c02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到“未捕获的类型错误:不能混合BigInt和其他类型，使用显式转换。”</p><h1 id="4218" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JavaScript类型强制是如何工作的？</h1><p id="8a3f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型强制在JavaScript解释器中完成。几乎所有的浏览器都内置了这样的功能。我们有<code class="fe ms mt mu mj b">Boolean</code>用于将值转换为布尔值，<code class="fe ms mt mu mj b">Number</code>用于将值转换为数字等等。</p><h1 id="8ec7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免类型强制陷阱</h1><p id="6195" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了避免落入类型强制导致的陷阱，我们应该检查对象的类型，并在对它们进行操作之前将其转换为相同的类型。</p><h2 id="334d" class="mn lc iq bd ld mv mw dn lh mx my dp ll ko mz na lp ks nb nc lt kw nd ne lx nf bi translated">数字</h2><p id="2201" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">例如，我们使用<code class="fe ms mt mu mj b">Number</code>函数将任何东西转换成数字。例如，我们可以如下使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d93f" class="mn lc iq mj b gy mo mp l mq mr">Number(1) // 1<br/>Number('a') // NaN<br/>Number('1') // 1<br/>Number(false) // 0</span></pre><p id="f6f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Number</code>函数将任何类型的对象作为参数，并尝试将其转换为数字。如果不能，那么它将返回<code class="fe ms mt mu mj b">NaN</code>。</p><p id="df5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以在变量或值前面使用<code class="fe ms mt mu mj b">+</code>操作符，尝试将其转换为数字。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3efe" class="mn lc iq mj b gy mo mp l mq mr">+'a'</span></pre><p id="1c72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe ms mt mu mj b">NaN</code>。如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8049" class="mn lc iq mj b gy mo mp l mq mr">+'1'</span></pre><p id="448f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们得到1。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/a9826dc0a20edbd7ed499b5fc7b04aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZSfKp_rnriEbHr2r"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@detpho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Francesco De Tommaso</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="495b" class="mn lc iq bd ld mv mw dn lh mx my dp ll ko mz na lp ks nb nc lt kw nd ne lx nf bi translated">线</h2><p id="4143" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要将对象转换成字符串，我们可以使用<code class="fe ms mt mu mj b">String</code>函数。它还接受一个对象，并尝试将其转换为字符串。</p><p id="5d17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们传入一个对象，我们返回:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0617" class="mn lc iq mj b gy mo mp l mq mr">"[object Object]"</span></pre><p id="6a88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0216" class="mn lc iq mj b gy mo mp l mq mr">String({})</span></pre><p id="01dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会帮我们找到的。</p><p id="9464" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原始值将得到与原始值内容相同的字符串。例如，如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9590" class="mn lc iq mj b gy mo mp l mq mr">String(123)</span></pre><p id="86b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe ms mt mu mj b">“123”</code>。</p><p id="0f03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了那些我们专门移除原型的对象，所有的对象都有一个<code class="fe ms mt mu mj b">toString</code>方法。</p><p id="1137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7e12" class="mn lc iq mj b gy mo mp l mq mr">({}).toString()</span></pre><p id="04f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把<code class="fe ms mt mu mj b">“[object Object]”</code>拿回来。</p><p id="6e5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b7df" class="mn lc iq mj b gy mo mp l mq mr">2..toString()</span></pre><p id="afa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们回到<code class="fe ms mt mu mj b">“2”</code>。注意，我们有两个点，因为第一个点将数字指定为数字对象，然后第二个点让我们调用数字对象上的方法。</p><p id="6927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他涉及字符串的不可思议的转换包括:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="27b1" class="mn lc iq mj b gy mo mp l mq mr">"number" + 1 + 3        // 'number13'<br/>1 + 3 + "number"        // '4number'<br/>"foo" + + "bar"         // 'fooNaN'<br/>{}+[]+{}                // '[object Object][object Object]'<br/>!+[]+[]+![]             // '<!-- -->truefalse'<br/>[] + null + 2           // 'null2'</span></pre><h2 id="08da" class="mn lc iq bd ld mv mw dn lh mx my dp ll ko mz na lp ks nb nc lt kw nd ne lx nf bi translated"><code class="fe ms mt mu mj b">Symbol.toPrimitive</code></h2><p id="f2eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象也有将对象转换成相应原始值的<code class="fe ms mt mu mj b">Symbol.toPrimitve</code>方法。当使用<code class="fe ms mt mu mj b">+</code>一元操作符或者将一个对象转换为原始字符串时，就会调用这个函数。例如，我们可以编写自己的<code class="fe ms mt mu mj b">Symbol.toPrimitive</code>方法来将各种值转换为原始值:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="99d8" class="mn lc iq mj b gy mo mp l mq mr">let obj = {<br/>    [Symbol.toPrimitive](hint) {<br/>        if (hint == 'number') {<br/>            return 10;<br/>        }<br/>        if (hint == 'string') {<br/>            return 'hello';<br/>        }<br/>        if (hint == 'true') {<br/>            return true;<br/>        }<br/>        if (hint == 'false') {<br/>            return false;<br/>        }<br/>        return true;<br/>    }<br/>};<br/>console.log(+obj);     <br/>console.log(`${obj}`); <br/>console.log(!!obj);<br/>console.log(!obj);</span></pre><p id="fe17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8577" class="mn lc iq mj b gy mo mp l mq mr">10<br/>hello<br/>true<br/>false</span></pre><p id="8a27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自代码底部的<code class="fe ms mt mu mj b">console.log</code>语句。</p><h2 id="5c35" class="mn lc iq bd ld mv mw dn lh mx my dp ll ko mz na lp ks nb nc lt kw nd ne lx nf bi translated">避免松散的平等</h2><p id="bd28" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">宽松相等比较由<code class="fe ms mt mu mj b">==</code>运算符完成。它通过在比较前转换为相同的类型来比较两个操作数的内容是否相等。举个例子，</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e8d6" class="mn lc iq mj b gy mo mp l mq mr">1 == '1'</span></pre><p id="fce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将评估为<code class="fe ms mt mu mj b">true</code>。</p><p id="95fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更令人困惑的例子是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7e5f" class="mn lc iq mj b gy mo mp l mq mr">1 == true</span></pre><p id="2539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe ms mt mu mj b">true</code>是真的，在比较它们之前，它将首先被转换成一个数字。所以<code class="fe ms mt mu mj b">true</code>在比较之前会先转换为1，使得表达式为真。</p><p id="3ca5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种混乱的情况，我们使用了<code class="fe ms mt mu mj b">===</code>比较操作符。</p><p id="136a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f0e3" class="mn lc iq mj b gy mo mp l mq mr">1 === '1'</span></pre><p id="94d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3b4d" class="mn lc iq mj b gy mo mp l mq mr">1 === true</span></pre><p id="e450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">都将是<code class="fe ms mt mu mj b">false</code>，这更有意义，因为它们的类型不同。<code class="fe ms mt mu mj b">===</code>操作符不会对操作数进行类型强制。比较类型和内容。</p><p id="031e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们上面提到的比较问题适用于原始值。对象通过它们的引用进行比较，所以如果操作数有不同的引用，那么无论我们使用哪个操作符，它的计算结果都是<code class="fe ms mt mu mj b">false</code>。</p><p id="8a8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些函数，我们将变量和值转换为我们显式编写的类型。这使得代码更加清晰，我们不必担心JavaScript解释器试图将东西转换成我们不想要的类型。同样，我们应该使用<code class="fe ms mt mu mj b">===</code>操作符而不是<code class="fe ms mt mu mj b">==</code>操作符来比较原始值。</p></div></div>    
</body>
</html>