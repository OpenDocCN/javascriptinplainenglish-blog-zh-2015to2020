<html>
<head>
<title>Dynamic Programming made simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程变得简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dynamic-programming-made-simple-part-2-longest-common-subsequence-7059862431c5?source=collection_archive---------5-----------------------#2020-05-05">https://javascript.plainenglish.io/dynamic-programming-made-simple-part-2-longest-common-subsequence-7059862431c5?source=collection_archive---------5-----------------------#2020-05-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="040a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第1部分中，我们讨论了比较两个字符串时最长的公共子串是什么。概括地说，子串就是它所说的那样。给定一个字符串“ABCDEFG”，“ABC”被认为是子串吗？“BCDEF”怎么样？</p><p id="5c2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“ABC”和“BCDEF”都是字符串“ABCDEFG”的子字符串，因为它们满足一个重要的属性:它们之间不能有<strong class="jm io">空格</strong>。例如，“ACD”不是子字符串，因为您跳过了“B”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34a9fa54cfa6b80b3b6e650de5523fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgR-aTi0J54MgXsFzc1e6g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig A. ‘ACD’ is a subsequence while ‘ABC’ is a substring.</figcaption></figure><p id="3870" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，如果‘ACD’不是‘ABCDEFG’的子串，那么它是什么呢？嗯，准确的说法应该是一个<strong class="jm io">子序列</strong>。子序列与子串的不同之处在于:</p><ol class=""><li id="005b" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">可以有<strong class="jm io">间隔</strong>(即‘ACD’是子序列，但不是子串，因为你跳过了字符‘B’)</li><li id="1e78" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated"><strong class="jm io">顺序很重要</strong>。在给定的字符串中，A - &gt; B - &gt; C - &gt; … - &gt; G。(即“BAD”不是子序列，因为它不满足顺序)</li></ol><p id="041d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们理解了子串和子序列之间的细微差别，我们可以继续了。</p><p id="b9aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在动态编程中，有几个关键的注意事项:</p><ol class=""><li id="3c17" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">这个主要问题可以分解成几个子问题。每一个子问题都可以被解决，存储在某个地方，然后用于导出主问题的完整解决方案。</li><li id="b6aa" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">它总是包含一个网格或表格(即数组的数组)。</li></ol><p id="652c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来做一个简单的问题。给定字符串“鱼”和“FOSH”，找出最长的公共子序列。</p><p id="728a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">直觉上，你可能已经得出答案是“FSH ”,但是你如何将这种直觉转化为计算机可以理解的代码呢？后退一步。你可能已经在脑子里把“鱼”的每个字符和“FOSH”的每个字符进行了比较，直到两个字符串中的所有字符都进行了比较。</p><p id="7795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能还存储了“鱼”和“FOSH”之间的常见字符列表，并随后计算了这两个字符串中常见字符的总数。</p><p id="fec4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">知道了这一点，让我们将直觉转化为代码。</p><p id="5c39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，创建一个网格来存储我们的比较，并将所有内容初始化为零。在这里，我将空单元格的<strong class="jm io">隐含</strong>为<strong class="jm io">零</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lm"><img src="../Images/c0c577ef18233db3b75352169404ffd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoXWfZozEDZlxsEbwwy1Nw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 1. Create a table and compare each char from both strings.</figcaption></figure><p id="ba62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在图1中，我们比较了“鱼”和“FOSH”中的第一个字符，即f。由于该字符匹配，我们递增1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ln"><img src="../Images/7c77c32c073cdd179721107dd3c6ed0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMGWVNK3iSNTF6Th1EWqYw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 2. Comparing the first character ‘F’ from ‘FOSH’ with ‘FISH’.</figcaption></figure><p id="0c71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们将“FOSH”中的第一个字符与“鱼”中的所有字符进行比较(即我们逐行比较)。你会注意到，即使“鱼”后面的字母——即“I”、“S”和“H”——与“FOSH”中的“F”不匹配，我们仍将其保留为1(图2)。</p><p id="90c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">仔细想想，这是有道理的。问问自己‘F’和‘F’之间最长的公共字符串是什么，然后是‘F’和‘FI’，然后是‘F’和‘FIS’，最后是‘F’和‘鱼’？答案是F，因此它的长度是1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lo"><img src="../Images/3003b8c670e87004d4a67a4022ab5a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Y8YwhTsFnPxvlKil_Jiow.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 3. Comparing the second character in ‘FOSH’ with all the characters in ‘FISH’.</figcaption></figure><p id="85a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将《FOSH》中的“O”与《鱼》中的所有角色进行了比较(图3)。为什么我们在所有这些单元格中输入1，即使‘O’与‘FISH’中的任何字符都不匹配？好吧，记住在动态编程中，我们使用之前比较的结果来进行当前的比较。</p><p id="950c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">直观地说，在第二行，我们可以通过问自己“FO”和“F”之间最长的公共字符串是什么来逐步得到结果？“FO”和“FI”呢？“佛”和“FIS”怎么样？最后，“FO”和“FISH”？</p><p id="03f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">答案是“FO”和“FISH”之间只有一个共同的字符，即“F”。请记住，当我们比较“F”和“FISH”时，我们使用了存储在前一行中的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lp"><img src="../Images/cabff30b15904966ae0bd78da5024d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wH0HiTIoow0wjx9asZe-WA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 4. Comparing ‘S’ in ‘FOSH’ with ‘FISH’</figcaption></figure><p id="8497" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，事情开始变得有趣。你会注意到“FOSH”中的“S”与“鱼”中的“S”相匹配，所以你加1(图5)。但是，在这里，您在先前已知的基础上增加1。你知道，以前当你比较“FO”和“FISH”时，只有一个共同的字符是“F”。因此，在此基础上，当两个字符串之间存在另一个匹配时，您将加1。(也就是说，现在“FOS”和“FISH”之间共有两个字符)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lq"><img src="../Images/03feb332c194e7178a99ccfc23359fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EsxQxTkW1wpN9aCObn3cg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 5. Comparing ‘S’ in and up to ‘FOS’ with ‘FISH’.</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/bce70bb8aa7946c0e1f64ff5825077ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkEA8nqdq3L-uV4ZJmihqQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 6. Comparing ‘H’ in ‘FOSH’ with ‘FISH’.</figcaption></figure><p id="ffb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在图6中，有两个要点需要注意。最后一行的前两个单元格(即“FOSH”中的“H”)是1，而不是2。举个例子，如果你比较“鱼”中的第一列“F”和“FOSH”中的所有字符，最长的公共字符串是“F”。如果你把《FOSH》中的所有人物进行比较，那么《鱼》中的第二列“我”也是如此。</p><p id="4e58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第三列中，当你比较“鱼”中的“S”和“FOSH”中的所有字符时，有两个字符在两个字符串中是共同的(即“F”和“S”)。您可以在代码中使用一个公式来检查以前的比较，并且每当两个字符串中有一个字符匹配时，计数就增加1。该公式将在下面的代码中实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/9e7cd0899c30cd1bdc34c0462591fd6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qc8m-ZHKj6ev0No1j06Oog.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 7. Comparing ‘H’ in ‘FOSH’ with all the characters in ‘FISH’.</figcaption></figure><p id="b6dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，在这里我们比较了最后一行“FOSH”中的“H”和“鱼”中的所有字符。最终答案在最后一个单元格<strong class="jm io">中，通常是</strong>，但不总是如此。因此,“FOSH”和“鱼”之间的最长公共子序列是3，这是有意义的，因为“FSH”是公共的，并且在两个字符串的序列中。</p><p id="5662" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">咻，这是一个很长的概念性概述。下面是Javascript代码。我敦促你在考虑解决方案之前先自己实施它。</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="295f" class="ly lz in lu b gy ma mb l mc md">const create2DMatrix = (A, B) =&gt; {<br/>  const table = [];</span><span id="e5fe" class="ly lz in lu b gy me mb l mc md">  for (let i = 0; i &lt;= A.length; i += 1) {<br/>    table.push([]);<br/>  }</span><span id="c51d" class="ly lz in lu b gy me mb l mc md">  for (let j = 0; j &lt;= A.length; j += 1) {<br/>    for (let k = 0; k &lt;= B.length; k += 1) {<br/>       table[j].push(0);<br/>    }<br/>   }<br/>  return table;<br/>}</span><span id="20b5" class="ly lz in lu b gy me mb l mc md">// Basically creating an array of arrays. Given A = 'FISH' and B = 'FOSH':</span><span id="4ab9" class="ly lz in lu b gy me mb l mc md">table = [   #  F  I  S  H<br/>         # [0, 0, 0, 0, 0],<br/>         F [0, 0, 0, 0, 0],<br/>         O [0, 0, 0, 0, 0],<br/>         S [0, 0, 0, 0, 0],<br/>         H [0, 0, 0, 0, 0]<br/>         ]</span></pre><p id="19cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，我们创建了一个额外的行和列。这是<strong class="jm io">非常重要的</strong>。如果不创建额外的行和列，您的代码将无法工作，尤其是javascript。</p><p id="2bcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，让我们创建最长的公共子序列函数。</p><pre class="kj kk kl km gt lt lu lv lw aw lx bi"><span id="32fb" class="ly lz in lu b gy ma mb l mc md">const longestCommonSubsequence = (A, B) =&gt; {<br/>  const table = create2DMatrix(A, B);<br/>  <br/>  for (let i = 1; i &lt; A.length+1; i += 1) {<br/>    for (let j = 1; j &lt; B.length+1; j += 1) {<br/>      if (A[j-1] === B[i-1]) {<br/>         table[i][j] = table[i-1][j-1] + 1;<br/>      } else {<br/>         table[i][j] = Math.max(table[i-1][j], table[i][j-1]);<br/>      }<br/>    }<br/>  }<br/> return table;<br/>}</span><span id="7515" class="ly lz in lu b gy me mb l mc md">console.log(longestCommonSubsequence('FISH', FOSH'));</span><span id="095a" class="ly lz in lu b gy me mb l mc md">// Output will be:</span><span id="4d74" class="ly lz in lu b gy me mb l mc md">table = [   #  F  I  S  H<br/>         # [0, 0, 0, 0, 0],<br/>         F [0, 1, 1, 1, 1],<br/>         O [0, 1, 1, 1, 1],<br/>         S [0, 1, 1, 2, 2],<br/>         H [0, 1, 1, 2, 3]<br/>         ]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/568e7ed1ba4988aba22e7e3a8df70898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMDuxtuGdjB3hIknJcTXzg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 8. If the characters do not match, you compare the values from the cell above and the previous cell, take the maximum value and store it in the current cell.</figcaption></figure><p id="1592" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面的代码中，您会注意到，如果字符不匹配，那么我们通过比较上面的单元格和前面的单元格来取最大值，而不是将其设置为零(图8)。</p><p id="8d49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:如果你想找到最长的公共子串，你必须检查是否有缺口。如果有差距，我们必须从零开始。相比之下，对于最长的公共子序列，我们不关心是否有缺口。这是有意义的，因为我们只希望两个字符串之间匹配的最大字符数达到该字符。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/5988d740e9437c0a5d126c8ba7dbe3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKSA2-aBqIrR5zwUvG2BTw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Fig 9. If the characters do match, then you take the preceding diagonal and increment it by 1 and store it in the current cell.</figcaption></figure><p id="b025" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上图中，如果字符匹配，那么使用之前计算和存储的结果，并将其递增1。如果我们不得不从头开始重新比较“FIS”和“福斯”,这就违背了拥有“表格”的目的。</p><h1 id="c1f9" class="mh lz in bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated"><strong class="ak">总结</strong></h1><p id="a931" class="pw-post-body-paragraph jk jl in jm b jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">总之，以下是我们在本文中讨论的要点:</p><ol class=""><li id="eb22" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">如果您可以将问题分解成子问题，或者如果您看到重复的计算，这可能意味着您可以使用动态编程。</li><li id="cc11" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">动态编程总是涉及到表格或网格。</li><li id="af47" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">动态规划的最终答案通常在表格的最后一个单元格中找到，但并不总是如此。有一些边缘情况将在另一篇文章中讨论。</li><li id="7102" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">时间复杂度是O(N ),因为我们必须循环两次(即遍历字符串1中的所有字符和字符串2中的所有字符)。</li><li id="ad16" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">在这种情况下，空间复杂度是O(N ),因为我们创建了和字符一样多的单个单元。</li><li id="ade7" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">总是在表中创建附加的行和列。</li></ol><p id="cf59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">动态编程比较难，如果看完这篇文章没有完全理解，没关系。我也不得不努力，拼凑我能找到的所有文章和视频。</p><p id="81e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完全内化和理解DP的最好方法是在回到本文之前，先练习把它画出来并自己编码。阅读和重读对你没有帮助，因为它会欺骗你的大脑，让你以为你知道。</p><p id="21d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你能轻松地向任何人——或者向一只橡皮鸭——解释，你就会知道你真正理解了。</p><h2 id="21a8" class="ly lz in bd mi nj nk dn mm nl nm dp mq jv nn no mu jz np nq my kd nr ns nc nt bi translated"><strong class="ak">简明英语笔记</strong></h2><p id="9889" class="pw-post-body-paragraph jk jl in jm b jn ne jp jq jr nf jt ju jv ng jx jy jz nh kb kc kd ni kf kg kh ig bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意:<a class="ae nu" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="jm io">JavaScript in Plain English</strong></a><a class="ae nu" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="jm io">AI in Plain English</strong></a><a class="ae nu" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="jm io">UX in Plain English</strong></a><a class="ae nu" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="jm io">Python in Plain English</strong></a><strong class="jm io"/>——谢谢，继续学习！</p><p id="3c11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae nu" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">submissions @ plain English . io</strong></a><strong class="jm io"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>