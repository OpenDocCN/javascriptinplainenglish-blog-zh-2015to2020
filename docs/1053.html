<html>
<head>
<title>Building a Chatroom using ReactJS and Pusher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ReactJS和Pusher建立聊天室</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-chatroom-using-reactjs-and-pusher-ec8c33b5f660?source=collection_archive---------1-----------------------#2020-01-22">https://javascript.plainenglish.io/building-a-chatroom-using-reactjs-and-pusher-ec8c33b5f660?source=collection_archive---------1-----------------------#2020-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1c02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在数字时代，实时通信工具为我们的许多个人和职业互动提供了便利。2014年，蒂姆·库克表示，苹果在全球范围内“每天处理大约400亿条<a class="ae kl" href="https://www.businessinsider.com/eddy-cue-200k-imessages-per-second-2016-2" rel="noopener ugc nofollow" target="_blank"> iMessage通知</a>”。鉴于iMessage中的每个对话本质上都是一个微型聊天室，我们将通过使用ReactJS和Pusher构建一个聊天室来探索聊天室的内部工作方式。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/906ab474dc07f70dbad5d5ae09d6babe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aRU8pgLdLHVV54qMFyizYA.gif"/></div></div></figure><p id="b5a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能想象写消息却不能实时看到你的聊天室吗？如果无法通过客户端和服务器进行双向通信，就会发生这种情况。大多数解决方案使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank"> Websockets </a>进行双向通信，但是需要手动部署和配置。今天，我们将使用Pusher的<a class="ae kl" href="https://pusher.com/chatkit" rel="noopener ugc nofollow" target="_blank">聊天工具API </a>来实时更新聊天室。</p><p id="8720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一步:下载并打开Pusher的ReactJS模板</strong> <br/>本教程将主要以Pusher的<a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit" rel="noopener ugc nofollow" target="_blank"> repo中列出的模板和说明为指导</a>。repo预先配置了Node.js服务器的指令，用于处理客户端和服务器端聊天室请求。</p><p id="2152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第2步:创建Pusher Chatkit实例<br/> </strong>转到Pusher的<a class="ae kl" href="https://dash.pusher.com/chatkit" rel="noopener ugc nofollow" target="_blank">仪表板</a>创建Chatkit实例。一旦你创建了你的实例，保存你的<strong class="jp ir">实例定位器</strong>和<strong class="jp ir">密钥</strong>值。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4775cd58369a68cb29aab31dea92f295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VqHStofBjniuT7aoAvrpiA.gif"/></div></div></figure><p id="c2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三步:为Chatkit API服务器端交互<br/> </strong>设置Node.js服务器在Pusher的<a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit#step-3-setup-a-basic-node-server" rel="noopener ugc nofollow" target="_blank">第三步</a>中，客户端交互仅限于用户能够加入聊天室，发送消息，查看其他用户何时在打字。只有当我们通过<code class="fe ky kz la lb b">npm install --save @pusher/chatkit-server</code>安装<code class="fe ky kz la lb b"><a class="ae kl" href="https://www.npmjs.com/package/@pusher/chatkit-server" rel="noopener ugc nofollow" target="_blank">@pusher/chatkit-server</a></code>并用步骤2中的值更新<code class="fe ky kz la lb b">./server.js</code>时，服务器端的交互(创建和管理用户账户)才会发生。</p><p id="dcc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第四步:创建登录流程<br/> </strong>参见第四步说明<a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit#step-4-identifying-the-user" rel="noopener ugc nofollow" target="_blank">此处</a>。通过在<code class="fe ky kz la lb b">./src/components/</code>文件夹中创建一个名为<code class="fe ky kz la lb b">UsernameForm.js</code>的组件来创建一个受控表单。在<code class="fe ky kz la lb b">UsernameForm.js.</code>状态下追踪用户名</p><p id="5393" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，用一个名为<code class="fe ky kz la lb b">onUsernameSubmitted(username)</code>的函数更新父组件<code class="fe ky kz la lb b">App.js</code>，该函数从<code class="fe ky kz la lb b">UsernameForm.js</code>接收用户名，并向/users route发出POST请求，以创建新的聊天室用户。POST请求还悲观地将<code class="fe ky kz la lb b">App.js currentUser</code>的状态设置为存储在<code class="fe ky kz la lb b">UsernameForm.js</code>状态中的用户名值。</p><p id="4805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，将<code class="fe ky kz la lb b">onUsernameSubmitted(username)</code>作为道具传递给<code class="fe ky kz la lb b">UsernameForm.js</code>，并将道具添加到表单中的onSubmit监听器，使循环完整。</p><p id="f642" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第五步:有条件地呈现聊天室组件<br/> </strong>在<code class="fe ky kz la lb b">./src</code>文件夹中创建一个<code class="fe ky kz la lb b">ChatScreen.js</code>组件，最终显示用户的消息。为名为<code class="fe ky kz la lb b">currentScreen</code>的<code class="fe ky kz la lb b">App.js</code>组件中的状态创建一个切换，默认为“登录”。然后，当调用步骤4中的<code class="fe ky kz la lb b">onUsernameSubmitted(username)</code>函数时，将<code class="fe ky kz la lb b">currentScreen</code>更新为“ChatScreen”。只有在登录表单中提交用户名时，才会调用它。更新<code class="fe ky kz la lb b">App.js</code>以呈现以下代码:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="5305" class="lg lh iq lb b gy li lj l lk ll"><strong class="lb ir">// App.js component</strong></span><span id="426e" class="lg lh iq lb b gy lm lj l lk ll">render() {<br/>   if (this.state.currentScreen === 'Login') {<br/>      return &lt;UsernameForm onSubmit={this.onUsernameSubmitted} /&gt;<br/>   }<br/>   if (this.state.currentScreen === 'ChatScreen') {<br/>      return &lt;ChatScreen currentUsername=    <br/>      {this.state.currentUsername} /&gt;<br/>   }<br/>}</span></pre><p id="7e4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤6:连接您的Chatkit实例<br/> </strong>在步骤2中，我们创建了一个Chatkit实例，现在，我们准备通过Pusher的客户端API连接到我们的实例。通过<code class="fe ky kz la lb b">npm install --save @pusher/chatkit-client</code>安装<code class="fe ky kz la lb b"><a class="ae kl" href="https://www.npmjs.com/package/@pusher/chatkit-client" rel="noopener ugc nofollow" target="_blank">@pusher/chatkit-client</a></code>并用以下代码更新<code class="fe ky kz la lb b">./ChatScreen.js</code>:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="fc19" class="lg lh iq lb b gy li lj l lk ll"><strong class="lb ir">// ChatScreen.js component</strong></span><span id="1d23" class="lg lh iq lb b gy lm lj l lk ll">componentDidMount () {<br/>   const chatManager = new Chatkit.ChatManager({<br/>      instanceLocator: 'YOUR INSTANCE LOCATOR',<br/>      userId: this.props.currentUsername,<br/>      tokenProvider: new Chatkit.TokenProvider({<br/>        url: 'http://localhost:3001/authenticate',<br/>      }),<br/>    })<br/><br/>    chatManager<br/>      .connect()<br/>      .then(currentUser =&gt; {<br/>        this.setState({ currentUser })<br/>     })<br/>     .catch(error =&gt; console.error('error', error))<br/>}</span></pre><p id="1fa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用实例定位器实例化、userId(您的用户名)和token创建一个chatManager对象，该对象将允许用户加入聊天室、发送消息和查看其他用户何时输入。</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="c53b" class="lg lh iq lb b gy li lj l lk ll"><strong class="lb ir">Note:</strong> If you encounter the <strong class="lb ir">TOKEN EXPIRY TOO FAR AHEAD</strong> error, this means your Node.js server time is ahead of the current time. An easy fix is updating your local machine's time. Click on the time in the upper righthand corner and click "Open Date &amp; Time Preferences" to update your local time. Then, restart your server with npm install.</span></pre><p id="190a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤7:在Pusher Chatkit <br/> </strong>中创建聊天室在一个更强大的应用程序中，通过客户端或服务器创建聊天室的功能应该是默认存在的，但是我们在这里通过Chatkit <a class="ae kl" href="https://dash.pusher.com/chatkit" rel="noopener ugc nofollow" target="_blank">仪表盘创建一个聊天室</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ln"><img src="../Images/553342b25595c617af7027a1a02b5474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4hRBC20oGe_u229bd2X8w.png"/></div></div></figure><p id="2645" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单击您在步骤2中创建的实例。然后，单击页面中上部区域的Console选项卡。然后，稍微向左点击房间选项卡，并点击<strong class="jp ir">创建新房间</strong>按钮。创建房间后，记下出现在房间名称下的ID。您将在步骤8中使用ID。</p><p id="e2cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤8:订阅新消息<br/> </strong>从概念上讲，如果没有“订阅”或加入聊天室，你就看不到聊天室，所以我们将使用下面的代码更新<code class="fe ky kz la lb b">./ChatScreen.js</code>:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="ca4b" class="lg lh iq lb b gy li lj l lk ll"><strong class="lb ir">// ChatScreen.js component</strong></span><span id="8fd6" class="lg lh iq lb b gy lm lj l lk ll">state = {<br/>   currentUser: {},<br/>   currentRoom: {},<br/>   messages: []<br/>}</span><span id="d673" class="lg lh iq lb b gy lm lj l lk ll">componentDidMount () {<br/>const chatManager = new Chatkit.ChatManager({<br/>   instanceLocator: 'YOUR INSTANCE LOCATOR',<br/>   userId: this.props.currentUsername,<br/>   tokenProvider: new Chatkit.TokenProvider({<br/>      url: 'http://localhost:3001/authenticate',<br/>   }),<br/>})</span><span id="bb09" class="lg lh iq lb b gy lm lj l lk ll">chatManager<br/>   .connect()<br/>   .then(currentUser =&gt; {<br/>      this.setState({ currentUser })<br/>         return currentUser.subscribeToRoom({<br/>            roomId: "YOUR ROOM ID",<br/>            messageLimit: 100,<br/>            hooks: {<br/>               onMessage: message =&gt; {<br/>                  this.setState({<br/>                     messages: [...this.state.messages, message],<br/>                  })<br/>               },<br/>            },<br/>         })<br/>      })<br/>      .then(currentRoom =&gt; {<br/>         this.setState({ currentRoom })<br/>      })<br/>}</span></pre><p id="45b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将“您的房间ID”替换为步骤9中的房间ID。当用户登录时，将呈现ChatScreen组件，该组件将初始化ChatManager对象，该对象使您能够执行客户端和服务器端的操作。我们将向状态添加一个空的currentRoom对象和空的messages数组。</p><p id="e9e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Chatkit API有一个<strong class="jp ir">subscribe room</strong>方法，该方法将用户添加到聊天室，并为他们订阅聊天室中发生的所有和任何行为。<code class="fe ky kz la lb b">subscribeToRoom</code>采用一个名为<code class="fe ky kz la lb b">onMessage</code>的事件处理程序，每次通过Chatkit的webhooks功能发布新消息时，都会实时调用这个事件处理程序。当一个消息被发布时，它被附加到处于<code class="fe ky kz la lb b">./ChatScreen.js</code>状态的消息数组中。</p><p id="7af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤9:在聊天室</strong>中渲染消息<br/>在步骤8中，我们在<code class="fe ky kz la lb b">./ChatScreen.js</code>中创建了一个消息数组，所以现在，我们将在<code class="fe ky kz la lb b">./src/components</code>文件夹中创建一个名为<code class="fe ky kz la lb b">MessageList.js</code>的组件，它将接收消息数组作为道具。然后,<code class="fe ky kz la lb b">MessageList.js</code>组件将遍历数组来呈现chatbox中的每条消息。按照<a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit#step-9-subscribe-to-new-messages" rel="noopener ugc nofollow" target="_blank">这里的消息列表步骤</a>在您的聊天室呈现消息。</p><p id="a130" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第10步:允许用户发送消息<br/> </strong>与第4步类似，我们可以复制一个<code class="fe ky kz la lb b">UsernameForm.js</code>组件，将其重新用作<code class="fe ky kz la lb b">SendMessageForm.js</code>。新组件应该有一个“文本”状态，所以onChange事件可以更新this.state.text和onSubmit事件，后者调用一个名为<code class="fe ky kz la lb b">sendMessage(text)</code>的新函数。新函数将被传递给<code class="fe ky kz la lb b">SendMessageForm.js</code>作为表单提交的道具。</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="574f" class="lg lh iq lb b gy li lj l lk ll"><strong class="lb ir">// SendMessageForm.js component</strong></span><span id="7098" class="lg lh iq lb b gy lm lj l lk ll">state = {<br/>   text: '',<br/>}<br/><br/>onSubmit(e) {<br/>   e.preventDefault()<br/>   this.props.onSubmit(this.state.text)<br/>   this.setState({ text: '' })<br/>}<br/><br/>onChange(e) {<br/>   this.setState({ text: e.target.value })<br/>   if (this.props.onChange) {<br/>      this.props.onChange()<br/>   }<br/>}</span><span id="d7e3" class="lg lh iq lb b gy lm lj l lk ll">&lt;form onSubmit={this.onSubmit}&gt;<br/>   &lt;input<br/>      type="text"<br/>      placeholder="Type a message here then hit ENTER"<br/>      onChange={this.onChange}<br/>      value={this.state.text}<br/>   /&gt;<br/>&lt;/form&gt;<br/></span><span id="2d55" class="lg lh iq lb b gy lm lj l lk ll"><strong class="lb ir">// ChatScreen.js component</strong></span><span id="a617" class="lg lh iq lb b gy lm lj l lk ll">sendMessage(text) {<br/>   this.state.currentUser.sendMessage({<br/>      text,<br/>      roomId: this.state.currentRoom.id,<br/>   })<br/>}</span><span id="6c93" class="lg lh iq lb b gy lm lj l lk ll">render (<br/>   &lt;SendMessageForm onSubmit={this.sendMessage} /&gt;<br/>)</span></pre><p id="d69e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，第8步中的<code class="fe ky kz la lb b">subscribeToRoom</code>方法采用一个名为<code class="fe ky kz la lb b">onMessage</code>的事件处理程序，每次发布新消息时都会实时调用该处理程序，因此新消息将出现在第9步中创建的MessageList.js组件中。</p><p id="bfac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤11:添加实时打字指示器<br/> </strong>在<code class="fe ky kz la lb b">./src/components</code>文件夹中创建一个<code class="fe ky kz la lb b">TypingIndicator.js</code>组件，在这里使用Pusher的<a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit#step-11-add-realtime-typing-indicators" rel="noopener ugc nofollow" target="_blank">文档中的指令</a>。在这一步的最后，您将在<code class="fe ky kz la lb b">ChatScreen.js</code>中得到usersWhoAreTyping的状态和下面的代码:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="a938" class="lg lh iq lb b gy li lj l lk ll"><strong class="lb ir">// ChatScreen.js component</strong></span><span id="2f81" class="lg lh iq lb b gy lm lj l lk ll">state = {<br/>   currentUser: {},<br/>   currentRoom: {},<br/>   messages: [],<br/>   <strong class="lb ir">usersWhoAreTyping: [],</strong><br/>}</span><span id="561f" class="lg lh iq lb b gy lm lj l lk ll">sendTypingEvent() {<br/>   this.state.currentUser<br/>      <strong class="lb ir">.isTypingIn({ roomId: this.state.currentRoom.id })</strong><br/>      .catch(error =&gt; console.error('error', error))<br/>}</span><span id="d8f9" class="lg lh iq lb b gy lm lj l lk ll">return(<br/><strong class="lb ir">&lt;TypingIndicator usersWhoAreTyping={this.state.usersWhoAreTyping} /&gt;</strong><br/>&lt;SendMessageForm<br/>onSubmit={this.sendMessage}<br/><strong class="lb ir">onChange={this.sendTypingEvent}</strong>/&gt;<br/>)</span></pre><p id="3bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤12:添加谁的在线名单<br/> </strong>使用这里的指令<a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit#step-12-add-a-whos-online-list" rel="noopener ugc nofollow" target="_blank"/>在<code class="fe ky kz la lb b">/src/components</code>文件夹中创建一个<code class="fe ky kz la lb b">WhosOnlineList.js</code>组件。</p><p id="8b9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤13:为新消息添加自动滚动<br/></strong>message list . js组件呈现用户发送的所有消息，但我惊讶地看到聊天室没有在我的屏幕底部自动显示最近的消息。我进一步研究了如何让消息列表自动向下滚动到最新的消息，得出了以下代码:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="309c" class="lg lh iq lb b gy li lj l lk ll"><strong class="lb ir">// ChatScreen.js component</strong></span><span id="1acd" class="lg lh iq lb b gy lm lj l lk ll">state = {<br/>   currentUser: {},<br/>   currentRoom: {},<br/>   messages: [],<br/>   usersWhoAreTyping: [],<br/>   scrolled: false,<br/>}</span><span id="bbb2" class="lg lh iq lb b gy lm lj l lk ll">sendMessage = (text) =&gt; {<br/>   this.state.currentUser.sendMessage({<br/>   roomId: this.state.currentRoom.id,<br/>   text: text<br/>   })<br/>   <br/>   this.setState({<br/>      scrolled: false<br/>   })<br/>}</span><span id="a442" class="lg lh iq lb b gy lm lj l lk ll">onScroll = () =&gt; {<br/>   this.setState({<br/>      scrolled: true<br/>   })<br/>}</span><span id="f57f" class="lg lh iq lb b gy lm lj l lk ll"><strong class="lb ir">// MessageList.js component</strong></span><span id="780e" class="lg lh iq lb b gy lm lj l lk ll">componentDidUpdate() {<br/>   setInterval(this.updateScroll,1000);<br/>}</span><span id="8c9e" class="lg lh iq lb b gy lm lj l lk ll">updateScroll = () =&gt; {<br/>   let element = document.querySelector('.message-list-container')<br/>   if (this.props.scrolled === false) {<br/>      element.scrollTop = element.scrollHeight;<br/>   }<br/>}</span><span id="0a64" class="lg lh iq lb b gy lm lj l lk ll">//update the div for message-list-container with onScroll event<br/>&lt;div className="message-list-container" onScroll={() =&gt; this.props.onScroll()}&gt;</span></pre><p id="1a8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第14步:装饰性插件</strong> <br/> <strong class="jp ir">改变用户帖子的颜色<br/> </strong>我喜欢将登录用户的名字渲染得与其他用户不同，以使帖子易于识别。为了实现这个目标，我在MessageList.js组件中编写了下面的三元语句。</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="ea1d" class="lg lh iq lb b gy li lj l lk ll">// MessageList.js component</span><span id="a614" class="lg lh iq lb b gy lm lj l lk ll">{ this.props.currentUser.id === message.senderId <br/>  ? &lt;font className="special-text"&gt;{message.senderId}&lt;/font&gt; <br/>  : {message.senderId}}</span></pre><p id="8e39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当您或其他用户发布消息时，该消息的senderId将被设置为您的用户名。currentUser.id被设置为等于登录人的用户名。如果三元组为真，则登录人的用户名被包装在一个名为“special-text”的类名中，该类名在步骤15中使用CSS对用户名进行样式化。</p><p id="01b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在用户帖子旁边显示时间<br/> 这个功能是任何聊天室应用程序的必备功能，但实现起来并不像看起来那么容易。Chatkit API以UTC时间返回消息的时间，格式不像HH:MM那么简单。我必须编写一个名为parseTime的函数来将UTC转换为军用时间，然后将军用时间转换为AM/PM指定的标准时间。</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="de40" class="lg lh iq lb b gy li lj l lk ll">&lt;span className="message-list-time"&gt;{this.parseTime(message.createdAt)}&lt;/span&gt;</span><span id="de19" class="lg lh iq lb b gy lm lj l lk ll">parseTime = (createdMessage) =&gt; {<br/>   let date = new Date(createdMessage);<br/>   let hours = date.getHours();<br/>   let mins = date.getMinutes();<br/>   let merid = " AM"</span><span id="a531" class="lg lh iq lb b gy lm lj l lk ll">   if (hours &gt; 12 &amp;&amp; mins &lt; 10) {<br/>      hours = hours - 12<br/>      mins = "0" + mins<br/>      merid = " PM"<br/>      return hours + ':' + mins + merid<br/>   } else if (hours &gt; 12 &amp;&amp; mins &gt; 10) {<br/>      hours = hours - 12<br/>      merid = " PM"<br/>      return hours + ':' + mins + merid<br/>   } else if (hours &lt; 12 &amp;&amp; mins &lt; 10) {<br/>      mins = "0" + mins<br/>     return hours + ':' + mins + merid<br/>   } else {<br/>     return hours + ':' + mins + merid<br/>   }<br/>}</span></pre><p id="06c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">当长度大于2 <br/>时显示“点击返回提交”</strong> Slack有一个非常酷的功能，设计巧妙，但让经验最少的用户知道当他们键入特定数量的字符时如何在应用程序中交流。</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="1af3" class="lg lh iq lb b gy li lj l lk ll">// SendMessageForm.js component</span><span id="c947" class="lg lh iq lb b gy lm lj l lk ll">{<br/>   this.state.text.length &gt; 2 ? <br/>   &lt;div className="message-form-return"&gt;hit return to send&lt;/div&gt; :    <br/>   ""<br/>}</span></pre><p id="9c22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤15:设计聊天室组件的样式聊天室的标准是在左侧面板上指定一个导航菜单，在同一个左侧面板上显示用户的信息。在面板的右边，聊天室应该显示所有的聊天信息，并在底部有一个文本字段来提交信息。点击这里查看我的样式表来更新你的聊天室应用程序的样式。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="cf3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你已经有了一个内置的聊天室应用程序，你现在对我们社会中最强大的交流工具之一有了更好的理解。聊天室在设计和代码上看起来很简单，但是要满足用户的期望和用户的设计要求，它的功能非常复杂。随意下载Pusher的JS模板<a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit" rel="noopener ugc nofollow" target="_blank">这里</a>或者查看我的repo和所有的附加功能<a class="ae kl" href="https://github.com/hdp2112/react-pusher-chatroom" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="56f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来源:<br/><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank">web sockets API MDN</a><br/><a class="ae kl" href="https://www.youtube.com/watch?v=a-JKj7m2LIo" rel="noopener ugc nofollow" target="_blank">搭建一个类似Slack </a> <br/> <a class="ae kl" href="https://github.com/pusher/build-a-slack-clone-with-react-and-pusher-chatkit" rel="noopener ugc nofollow" target="_blank"> Pusher的Slack克隆模板</a></p></div></div>    
</body>
</html>