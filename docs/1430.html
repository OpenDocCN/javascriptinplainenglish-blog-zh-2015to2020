<html>
<head>
<title>Inheritance vs. Composition in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的继承与组合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/inheritance-is-a-vs-composition-has-a-in-javascript-98fb96dfa0e6?source=collection_archive---------2-----------------------#2020-03-15">https://javascript.plainenglish.io/inheritance-is-a-vs-composition-has-a-in-javascript-98fb96dfa0e6?source=collection_archive---------2-----------------------#2020-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4dd2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个是“是”,另一个是“有”——但你知道区别吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/868f37a5af8a1c7792a1ac5229fcea33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-n0G31Cjfm3Eg-cbBYv-Cg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A man with a laptop</figcaption></figure><p id="9b7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">面向对象编程中的组合优先于继承的原则是，类通过它们的组合而不是继承来实现多态行为和代码重用。使用组合模式，您可以根据模型的功能来设计模型，而使用继承模式，您可以根据模型的功能来创建模型。</p><p id="ca17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继承更加严格，对象通常会完成很多他们不使用的功能。你将以著名的“香蕉-大猩猩-丛林”问题结束，在这个问题中，你想要一只香蕉，但你得到的是一只大猩猩拿着香蕉和整个丛林。</p><p id="78ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在接下来的示例中，我们将使用继承和组合来创建相同的功能，以查看它们的差异，为此，请记住以下注意事项:</p><ol class=""><li id="52f5" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">魔术师会不会游泳。在这种情况下，我们希望哈利不会游泳，但丽芙会。</li><li id="ff84" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">我们希望哈利能够变魔术，但是我们不希望丽芙变魔术。</li></ol><h1 id="8905" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">遗产</h1><p id="8b5c" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">各种对象的典型属性用于形成彼此之间的关系。抽象和公共属性存储在超类中，超类可用于更具体的子类。</p><p id="df49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，使用类，丽芙可以变戏法，而哈利可以游泳，但是因为丽芙和哈利是魔术师，他们继承自人类，你不能避免丽芙变戏法而哈利可以游泳。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="51c4" class="nh mg iq nd b gy ni nj l nk nl">class Person  {<br/>    eat() {<br/>        console.log('I am eating');<br/>    }<br/>    breathe(){<br/>        console.log('I am breathing');<br/>    }    <br/>    swim(){<br/>        console.log('I am swimming');<br/>    } <br/>}</span><span id="0883" class="nh mg iq nd b gy nm nj l nk nl">class Magician  extends Person{<br/>    trick() {<br/>        console.log('I am doing a trick');<br/>    }<br/>}</span><span id="4293" class="nh mg iq nd b gy nm nj l nk nl">let liv= new Magician();<br/>let harry = new Magician();</span><span id="ebb3" class="nh mg iq nd b gy nm nj l nk nl">//Liv can:<br/>liv.eat();<br/>liv.breathe();<br/>liv.swim();<br/>liv.trick();<br/>//I am eating<br/>//I am breathing<br/>//I am swimming<br/>//I am doing a trick</span><span id="00c8" class="nh mg iq nd b gy nm nj l nk nl">//Harry can:<br/>harry.eat();<br/>harry.breathe();<br/>harry.swim();<br/>harry.trick();<br/>//I am eating<br/>//I am breathing<br/>//I am swimming<br/>//I am doing a trick</span></pre><h1 id="af2a" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">作文</h1><p id="0da6" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">不同的抽象提供了特定的功能，这些功能需要与其他对象相结合来表示更大的抽象。您可以从其他较小的对象创建一个对象。</p><p id="9f18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用Composition，您可以通过使用ES6 Object.assign()来决定向每个对象添加什么功能。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="b173" class="nh mg iq nd b gy ni nj l nk nl">const eat = function () {<br/>    return {<br/>        eat: () =&gt; { console.log('I am eating'); }<br/>    }<br/>}</span><span id="2f8a" class="nh mg iq nd b gy nm nj l nk nl">const breathe = function () {<br/>    return {<br/>        breathe: () =&gt; { console.log('I am breathing'); }<br/>    }<br/>}</span><span id="69d2" class="nh mg iq nd b gy nm nj l nk nl">const swim = function () {<br/>    return {<br/>        swim: () =&gt; { console.log('I am swimming'); }<br/>    }<br/>}</span><span id="2560" class="nh mg iq nd b gy nm nj l nk nl">const trick = function () {<br/>    return {<br/>        trick: () =&gt; { console.log('I am doing a trick'); }<br/>    }<br/>}</span><span id="625c" class="nh mg iq nd b gy nm nj l nk nl">const superMagician = <!-- -->()=&gt; <!-- -->{<br/> return Object.assign(<br/>     {},<br/>     eat(),<br/>     breathe(),<br/>     trick()<br/>   );<br/>}</span><span id="6735" class="nh mg iq nd b gy nm nj l nk nl">const noviceMagician = () =&gt; {<br/> return Object.assign(<br/>     {},<br/>     eat(),<br/>     breathe(),<br/>     swim()<br/>   );<br/>}</span></pre><p id="9ebf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，哈利不会游泳，丽芙不会变戏法。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="acd9" class="nh mg iq nd b gy ni nj l nk nl">let harry = superMagician();<br/>harry.eat();<br/>harry.breathe();<br/>harry.trick();<br/>//I am eating<br/>//I am breathing<br/>//I am doing a trick</span><span id="7bdc" class="nh mg iq nd b gy nm nj l nk nl">let liv = noviceMagician();<br/>harry.eat();<br/>harry.breathe();<br/>harry.swim();<br/>//I am eating<br/>//I am breathing<br/>//I am swimming</span></pre><h1 id="8900" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="28e6" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">在某些情况下，很难在两者之间做出选择。重要的是要记住，没有什么是银弹。继承的问题是你必须预测未来，你必须在项目的早期构建你的对象的结构，这是一件复杂的事情，因为软件产品的需求是变化的。使用组合模式，代码更容易更改，耦合性更低，因为它更灵活，所以如果可能的话，更喜欢组合而不是继承。</p><p id="6642" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总而言之:</p><ul class=""><li id="1a1c" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nn lx ly lz bi translated">当关系是“A具有X能力”时，使用组合</li><li id="60ae" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nn lx ly lz bi translated">当关系为“A属于X类型”时，使用继承</li></ul><p id="9bbc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望你喜欢这篇文章。谢谢你阅读它。</p></div></div>    
</body>
</html>