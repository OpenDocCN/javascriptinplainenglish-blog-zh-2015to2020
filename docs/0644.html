<html>
<head>
<title>A Quick Guide To Queues In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript队列快速指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-quick-guide-to-queues-in-javascript-4367354ca005?source=collection_archive---------5-----------------------#2019-11-20">https://javascript.plainenglish.io/a-quick-guide-to-queues-in-javascript-4367354ca005?source=collection_archive---------5-----------------------#2019-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="654d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解和实现队列</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8facb851934216f4d96c6235abfc48d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2sLVHm0SrOjqvf-u-kQfA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Queues — image by Gabriela Rivera Mejias © 2019</figcaption></figure><h2 id="13ea" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是队列？</h2><p id="c73a" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">队列非常类似于<a class="ae mk" href="https://medium.com/javascript-in-plain-english/a-quick-guide-to-stacks-in-javascript-ecbf78515dc1" rel="noopener">栈</a>。他们经常一起学习，因为他们有很多相似之处。队列是一种组织数据的方式。它们基于先进先出的概念。它们可以通过各种方式实现(稍后将会介绍)，但其思想是有两种与数据交互的方式:在列表末尾添加一个元素(<strong class="lt ir">入队</strong>)和从列表开头删除一个元素(<strong class="lt ir">出列</strong>)。</p><h2 id="aee6" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么使用队列？</h2><p id="d21b" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">为了处理FIFO逻辑，队列有一个大的O:</p><ol class=""><li id="425a" class="ml mm iq lt b lu mn lx mo le mp li mq lm mr mj ms mt mu mv bi translated">插入O(1)</li><li id="3a5a" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj ms mt mu mv bi translated">移除O(1)</li><li id="9779" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj ms mt mu mv bi translated">查找元素O(n)</li><li id="6ead" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj ms mt mu mv bi translated">存取元素O(n)</li></ol><p id="2338" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">使用它们是因为它们几乎可以即时插入和移除元素。同样，与<a class="ae mk" href="https://medium.com/javascript-in-plain-english/a-quick-guide-to-stacks-in-javascript-ecbf78515dc1" rel="noopener">栈</a>非常相似，它们都几乎即时地处理元素的插入和移除。区别在于，队列用于需要FIFO(先进先出)逻辑的数据，而堆栈用于需要LIFO(后进先出)逻辑的数据。</p><h2 id="93db" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">队列用在哪里？</h2><ul class=""><li id="81a9" class="ml mm iq lt b lu lv lx ly le ne li nf lm ng mj nh mt mu mv bi translated">将你和其他用户配对的游戏服务器(任何处理拥塞的网络)</li><li id="dec1" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj nh mt mu mv bi translated">有等候的队伍吗</li><li id="468a" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj nh mt mu mv bi translated">后台任务</li><li id="2c88" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj nh mt mu mv bi translated">打印机进程</li><li id="3814" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj nh mt mu mv bi translated">遍历二叉查找树或图形</li><li id="f96e" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj nh mt mu mv bi translated">编程面试</li></ul><h2 id="fa68" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">JavaScript数组作为队列</h2><p id="2f62" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">使用队列最简单的方法是使用数组。您不需要实现任何代码，因为JavaScript数组已经有了移除和插入元素的方法。重要的是你遵循先进先出的逻辑。添加的第一个元素必须是第一个输出的元素。</p><p id="d7e4" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">下面是使用数组处理队列的两种不同方式:</p><ol class=""><li id="35a2" class="ml mm iq lt b lu mn lx mo le mp li mq lm mr mj ms mt mu mv bi translated">您可以使用Array的push和shift方法(添加到列表的末尾，从列表的开头删除)</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Array as Queue example with push and shift</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/7f4cd4313f781726f5f74be4ea9bdf68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5PBOJCjvWIDu3Vm9BHOkrQ.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Arrays as queues example with push and shift— GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="d821" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">2.您可以使用Array的unshift和pop方法(添加到列表的开头，从列表的结尾移除)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Array as Queue example with unshift and pop</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/6d05151e7499b63b82524127ad7efa1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IWzYa5rMyNUGy7Qj61asOw.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Arrays as queues example with unshift and pop — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><h1 id="b3c8" class="nl kw iq bd kx nm nn no la np nq nr ld jw ns jx lh jz nt ka ll kc nu kd lp nv bi translated">用链表创建你自己的队列</h1><p id="51ba" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">对链表使用队列比对数组更难。你必须自己实现代码，这比较难，但是值得。链表在内存方面比数组更有效。你可以在这里阅读更多关于那个<a class="ae mk" href="https://medium.com/javascript-in-plain-english/a-quick-guide-to-linked-lists-in-javascript-27ea7046bc56" rel="noopener">的内容。</a></p><h2 id="dfb8" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现节点类</h2><p id="54f0" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">一个节点有两个属性:<strong class="lt ir">数据</strong>和<strong class="lt ir">下一个</strong>。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Node class example</figcaption></figure><h2 id="fdae" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现队列类</h2><p id="4be7" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">队列有三个属性:第<strong class="lt ir">个</strong>节点、最后<strong class="lt ir">个</strong>节点和队列的<strong class="lt ir">长度</strong>。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Queue constructor example</figcaption></figure><h1 id="e90e" class="nl kw iq bd kx nm nn no la np nq nr ld jw ns jx lh jz nt ka ll kc nu kd lp nv bi translated">队列入队和出队方法</h1><p id="b839" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">处理<strong class="lt ir">入队</strong>和<strong class="lt ir">出列</strong>有两种方式。类似于数组，我们可以在末尾插入并从开头移除，或者我们可以在开头插入并从末尾移除</p><p id="706a" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">他们之间有巨大的<strong class="lt ir">差异。他们在这里:</strong></p><ol class=""><li id="2769" class="ml mm iq lt b lu mn lx mo le mp li mq lm mr mj ms mt mu mv bi translated">在链表的末尾插入并从开头移除(想想数组的push和shift方法)</li></ol><ul class=""><li id="5bbc" class="ml mm iq lt b lu mn lx mo le mp li mq lm mr mj nh mt mu mv bi translated">插入O(1)</li><li id="09a7" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj nh mt mu mv bi translated">移除O(1)</li></ul><p id="532a" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">2.在链表的开头插入并从末尾移除(想想数组的unshift和pop方法)</p><ul class=""><li id="8d34" class="ml mm iq lt b lu mn lx mo le mp li mq lm mr mj nh mt mu mv bi translated">插入O(1)</li><li id="2c16" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj nh mt mu mv bi translated">去除O(n)</li></ul><p id="0bcf" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">从链表的末尾移除需要O(n)。要从末尾移除，您必须将队列的最后一个属性重新分配为它的前一个节点。因为它是一个单链表，如果不遍历整个队列，你就不能访问前一个元素，因此，O(n)。</p><p id="46f4" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">因此，Queue类的<strong class="lt ir">入队</strong>和<strong class="lt ir">出列</strong>的实现类似于Array的push和shift方法，也就是将新节点添加到列表的末尾，并从列表的开头删除节点。这样，插入和移除都是O(1)。</p><h2 id="84a8" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现队列入队(推送)方法</h2><p id="9210" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">向队列添加元素时，有两种不同的情况需要处理:</p><ol class=""><li id="f7fd" class="ml mm iq lt b lu mn lx mo le mp li mq lm mr mj ms mt mu mv bi translated">队列是空的。</li><li id="b833" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj ms mt mu mv bi translated">队列中有个元素。</li></ol><p id="0a32" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">在这两种情况下，您都必须用给定的数据创建一个新节点，并将队列的<strong class="lt ir">长度</strong>增加1。</p><p id="6489" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">在代码中，<strong class="lt ir"> enqueue </strong> (push)如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Queue enqueue example</figcaption></figure><p id="c76f" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">情况1:当队列为空时</p><p id="1757" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">使队列的<strong class="lt ir">第一个</strong>和<strong class="lt ir">最后一个</strong>属性成为新节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/69e97acef251ddee2b3336684206b31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5RbMItGOhhbgFivN0_YIgA.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 1: enqueue with no elements in the Queue— GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="9fac" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">情况2:当队列有元素时</p><p id="5ed7" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">将队列的下一个<strong class="lt ir">最后一个</strong>节点设为新节点，然后将<strong class="lt ir">最后一个</strong>节点设为新节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/f45e114af03a27bca4ee69755363b948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ND_BqU5HHa2Ngqw_WEvs8w.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 2: enqueue with elements in the Queue — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><h2 id="ece2" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现队列出列(移位)方法</h2><p id="11d8" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">从队列中删除元素有三种不同的情况:</p><ol class=""><li id="69e3" class="ml mm iq lt b lu mn lx mo le mp li mq lm mr mj ms mt mu mv bi translated">队列中没有元素。</li><li id="d5c0" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj ms mt mu mv bi translated">队列中只有一个元素。</li><li id="9e15" class="ml mm iq lt b lu mw lx mx le my li mz lm na mj ms mt mu mv bi translated">队列中有多个元素。</li></ol><p id="fcd0" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">在代码中，<strong class="lt ir">出列</strong> (shift)看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Queue dequeue example</figcaption></figure><p id="2681" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">情况1:当队列中没有项目时</p><p id="16e6" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">什么都不做，返回null。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/34e0359968477802a9fca4ce5a920207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*J-ByCwy8bOxTBDvYM3dpCA.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 1: dequeue with no elements in the Queue — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="6475" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">情况2:当队列中只有一个元素时</p><p id="d2b7" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">通过将第<strong class="lt ir">个</strong>和最后<strong class="lt ir">个</strong>都设置为空，删除包含该元素的节点。将队列的<strong class="lt ir">长度</strong>减一，并返回被移除节点中的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/9e1d4f1876474a21410d33b6a1729e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mxOhjWRxU5oCGyRdZlkB7A.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 2: dequeue with one element in the Queue — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><p id="0557" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">情况3:当队列中有多个元素时</p><p id="1311" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">通过将队列的<strong class="lt ir"> first </strong>属性设置为列表中的下一个节点来删除第一个节点。将队列的<strong class="lt ir">长度</strong>减一，并返回被移除节点中的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/11a5571fb000acf7d24a6092cafc2633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kcUEpxCxFhT4oQnx2zvzvw.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Case 3: dequeue with elements in the Queue — GIF by Gabriela Rivera Mejias © 2019</figcaption></figure><h2 id="2107" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">完整的队列代码</h2><p id="1b16" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">总之，用链表实现的堆栈看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Queue class example</figcaption></figure><p id="4c7b" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">如果你想玩代码，这里有一个<a class="ae mk" href="https://repl.it/@KennethYoung/Queues" rel="noopener ugc nofollow" target="_blank"> repl链接</a>。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="9264" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">谢谢你能走到这一步！这是JavaScript中队列的快速指南。如果您对未来的主题或问题有任何想法，请在下面回复！如果你觉得这有帮助，这里是我以前的一些文章，都是gif格式的！</p><p id="7ae7" class="pw-post-body-paragraph lr ls iq lt b lu mn jr lw lx mo ju lz le nb mb mc li nc me mf lm nd mh mi mj ij bi translated">以前的文章:</p><div class="od oe gp gr of og"><a href="https://medium.com/javascript-in-plain-english/a-quick-guide-to-stacks-in-javascript-ecbf78515dc1" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">JavaScript堆栈快速指南</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">理解和实现堆栈</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kp og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://medium.com/javascript-in-plain-english/a-quick-guide-to-linked-lists-in-javascript-27ea7046bc56" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">JavaScript中链表的快速指南</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">理解链表</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="ov l or os ot op ou kp og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://medium.com/javascript-in-plain-english/recursion-explained-with-example-62473f311230" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">递归举例说明</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">大部分程序员都听说过这个概念，都很恐惧。他们倾向于远离它。这是一个可怕的话题，但它…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="ow l or os ot op ou kp og"/></div></div></a></div></div></div>    
</body>
</html>