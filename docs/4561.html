<html>
<head>
<title>How To Use The useContext API In React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中使用useContext API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-the-usecontext-api-in-react-ba2da7dab9e4?source=collection_archive---------7-----------------------#2020-12-21">https://javascript.plainenglish.io/how-to-use-the-usecontext-api-in-react-ba2da7dab9e4?source=collection_archive---------7-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa54" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从头开始反应中常见的使用上下文挂钩</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2332298bc413ce1b08cd112ac872d8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNQRWlgldCFdgMF_NGUrqw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@enrapture?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Enrapture Captivating Media</a> on <a class="ae kv" href="https://unsplash.com/s/photos/roads?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3e4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要为React组件树中的每个组件定义一个通用的全局变量，您会怎么做？厌倦了搜索？别担心。你在正确的轨道上！停留这短短的10分钟，我保证你不会后悔，我会带你穿过这个神奇的国家管理世界。</p><p id="e23d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章不仅会让你了解上下文API是如何工作的，还会让你了解你可能遗漏了什么&amp;隐藏在背景中，最重要的是状态管理中的概念。我想提供react-router和包管理器的额外知识。所以我的意图不仅是让你在主要内容上变得更好，也是让与此相关的一切变得完美。请记住，总有另一个世界隐藏在表面之外，我们必须挖掘得更深才能看到那个世界的美丽。</p><p id="5a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你很急或者很快想学习这个<code class="fe ls lt lu lv b">useContext</code>钩子来应用正在进行的项目问题，请跳转到<a class="ae kv" href="https://medium.com/p/ba2da7dab9e4#e783" rel="noopener"> <strong class="ky ir">第五节</strong> </a>继续进行。但请务必阅读整篇文章，以获得100%的清除。</p><p id="9455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是代码沙箱中的工作示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Get the real experience from code-sandbox</figcaption></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="6f67" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">1.什么是国家管理？</h1><p id="7d2e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果你熟悉一些旧的react(就在引入hooks -v16.8之前)，我们使用状态作为内存来保存我们在类中使用的任何变量。用最简单的术语来说，它是一个JavaScript对象，表示组件的一部分，可以根据用户的操作而改变。</p><p id="d6d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一个典型的React应用程序中，当用户执行一个动作并改变一个组件的状态时，它可能也会影响其他组件的状态。当应用程序很简单时，这并不是很糟糕。然而，它变得越复杂，跟踪所有依赖关系就变得越困难。</p><p id="79d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常我们在组件中传递数据作为道具。但是想象一下，你必须从所有的组件中获得一些价值，如果你从道具中传递，你会发疯的。这不是在这种情况下的做法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a75048e87be6d0a7921db2270fcd8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zD-8Q72hjjCScphOhqyvbQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Bad way of managing the state</figcaption></figure><p id="3f95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是所谓的<strong class="ky ir"> prop drilling </strong>，你将数据从一个组件传递到另一个组件，最终你通过props将数据传递到甚至不需要它们的中间组件。</p><p id="734c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么解决方案是什么呢？在这里，上下文关系到行动。Context API提供了一种更好的方式来在组件之间共享值，而不必显式地通过组件树的每个不同嵌套级别传递一个属性。</p><h1 id="a3f8" class="mf mg iq bd mh mi nc mk ml mm nd mo mp jw ne jx mr jz nf ka mt kc ng kd mv mw bi translated">2.管理国家的更好方法</h1><p id="d451" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">根据React官方文档:</p><blockquote class="nh ni nj"><p id="4df8" class="kw kx nk ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性</p></blockquote><p id="6e97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上下文API是一种将数据从顶层组件传递到底层组件的方法，而不需要通过props手动传输。当一些数据需要由不同嵌套级别的许多组件访问时，这是最基本的用途。结合使用上下文API和钩子可以为你的应用提供非常简单和终极的全局状态管理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b814e6dc8a02408b662cdca94463965e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWoYkzwAllMSbHoqy4qgLA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Right way of managing the state</figcaption></figure><p id="4714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在图中看到的，只有需要的组件正在获取数据。这将最终提高你的应用程序的性能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/060869f718b03045b0fa36eeab30d5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md0cTkL3pOtIpfYQLYmASw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">How Context API works</figcaption></figure><p id="2afc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上下文API可以应用在很多场景中。这是它的使用案例，你可以看到这个小东西覆盖了巨大的面积。</p><ul class=""><li id="1f7d" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">主题改变</li><li id="bfd4" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">多语言应用</li><li id="f565" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">身份验证提供商</li><li id="89a2" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">通知提供者</li></ul><p id="4766" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那Redux呢。难道它没有提供比上下文更好的解决方案吗？战斗开始了！</p><h1 id="2c11" class="mf mg iq bd mh mi nc mk ml mm nd mo mp jw ne jx mr jz nf ka mt kc ng kd mv mw bi translated">3.冗余与语境</h1><p id="5c67" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">有人怀疑这个上下文API看起来像Redux。有人说这是一种迷你还原。让我们深入研究一下，把事情搞清楚。</p><p id="62ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从技术上来说，Redux并不局限于React应用中的使用。它实际上是另一个开源库，可以与任何其他视图库一起使用，如Angular、Vue、Polymer、Ember、Backbone等。但是大多数开发者把Redux和React联系在一起。因此，为了在react应用程序中使用redux，您必须安装额外的包。</p><p id="ab78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Context API是专门为React制作和优化的，并作为内置工具出现。因此，我们不需要安装任何额外的依赖项，可以直接在React中使用，但不能在其他库/框架中使用。</p><p id="c724" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redux有3个主要构件</p><ol class=""><li id="e721" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr od nv nw nx bi translated">存储—保存应用程序状态。在任何Redux应用程序中，只有一个商店。</li><li id="1cb3" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">action——描述应用程序中发生的事件(用户交互、API调用、表单提交等)并将新数据传输到商店的普通JavaScript对象。每个动作必须有一个类型和一个包含数据的可选有效载荷键。</li><li id="10cf" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">reducer——获取应用程序的当前状态、执行操作并返回新状态的函数。</li></ol><p id="2f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上下文API减少了Redux中的复杂结构，并尽可能简单地提供相同的功能。</p><ol class=""><li id="1226" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr od nv nw nx bi translated">上下文—维护状态的全局数据容器。</li><li id="a166" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">提供者—允许使用者订阅上下文更改。</li><li id="bc2e" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">消费者—上下文的获取者。</li></ol><p id="1101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你现在可以理解Redux的复杂性(打包了高级而沉重的组件结构)和Context API有多简单了。</p><p id="2bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，Redux是一个有点复杂的工具，有一个相对陡峭的学习曲线。它主要用于大规模应用，被认为是行业标准。(但这些事情可能会发生变化，因为会有更多的竞争对手加入进来，如GraphQL和Apollo Client。)理解、记忆、习惯它的模式是需要时间的。</p><p id="fd35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是否意味着我们作为设计师应该远离它？绝对没有！你绝对应该尝试一下，以增加你的知识。我想为Redux写一篇单独的文章，希望它能帮助你获得更多关于Redux的知识。</p><p id="89de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得一提的是，大多数人都在尖叫redux需要太多的样板代码，必须添加很多包才能得到Redux …就像这样。针对这些常见问题的解决方案<strong class="ky ir"> Redux Toolkit </strong>推出了。它将提高Redux开发的效率，并且可以作为Redux的入门工具包。试用redux toolkit官方文档了解更多信息。</p><div class="oe of gp gr og oh"><a href="https://redux-toolkit.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">Redux工具包| Redux工具包</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">官方的、固执己见的、包含电池的高效Redux开发工具集</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">redux-toolkit.js.org</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div><p id="7b5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是最新的带钩子的上下文API是最重要的，我们可以很容易地设置它，它和Redux一样有效。此外，Context API是内置的解决方案，因此您不需要担心第三方实现新的更改，也不会增加您的包大小。</p><p id="e352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把事情变得实际！</p><h1 id="9a58" class="mf mg iq bd mh mi nc mk ml mm nd mo mp jw ne jx mr jz nf ka mt kc ng kd mv mw bi translated">4.入门指南</h1><p id="9064" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">好吧！让我们构建一个简单的应用程序来更好地理解这些概念。我创建了一个主题转换器应用程序，它可以根据我们的愿望改变背景主题。</p><p id="3f56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用TypeScript模板创建新的React项目，可以运行:</p><pre class="kg kh ki kj gt ow lv ox oy aw oz bi"><span id="b02f" class="pa mg iq lv b gy pb pc l pd pe">npx create-react-app theme-changer--template typescript</span></pre><p id="5e8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则</p><pre class="kg kh ki kj gt ow lv ox oy aw oz bi"><span id="0082" class="pa mg iq lv b gy pb pc l pd pe">yarn create react-app theme-changer --template typescript</span></pre><p id="f581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包经理来了。你可以使用npm或Yarn。这两个包管理器在功能上更接近，但是我更喜欢yarn，</p><ol class=""><li id="96e4" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr od nv nw nx bi translated">性能—安装依赖项的速度。</li><li id="bd04" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">安全性—以您期望的方式处理锁定文件。</li></ol><p id="3aaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在net和Yarn中找到比npm表现更好的基准测试。然而，这最终是你的选择。随便挑一个你喜欢的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/292378de7919d0e6cb6d1f4a9dbeae9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*w2h_WsGaH34mWEiyOiycdA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc" rel="noopener ugc nofollow" target="_blank">NPM vs Yarn Cheat Sheet</a> — Credits shift.infinite.red</figcaption></figure><p id="bd37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧！让我们通过移除样板代码来继续应用程序。我为这个应用程序创建了一个侧边栏和几个组件，使其更加优雅和易于理解。</p><p id="b654" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于侧栏，我添加了react-router来路由我的组件。正如我承诺的那样，我将指导你使用React路由器，现在是时候了。</p><p id="a2f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装react-router包并为typescript添加类型。</p><pre class="kg kh ki kj gt ow lv ox oy aw oz bi"><span id="be18" class="pa mg iq lv b gy pb pc l pd pe">yarn add react-router-dom<br/>yarn add @types/react-router-dom</span></pre><p id="3a55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您必须用<code class="fe ls lt lu lv b">BrowserRouter</code>包装应用程序，以添加路由组件的能力。然后，您需要定义路由并添加一个交换机，用于匹配组件之间的路由。同样，你可以为此单独制作一个<code class="fe ls lt lu lv b">router.tsx</code>。但是我坚持做最小的改动。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="1cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我创建了三个组件。首先，我创建了左侧导航，它将为所有其他组件所共有。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="e1b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用链接导航到相关的路径，它将呈现一个完全可访问的锚标记，并带有适当的<code class="fe ls lt lu lv b">href</code>为什么我们使用它，因为如果我们使用<code class="fe ls lt lu lv b">&lt;a href&gt;</code>标记而不是它，当导航到URL时，页面会重新加载。因为react是一个单页面应用程序，所以这不是正确的导航方式。因此，使用链接导航，避免麻烦。</p><p id="4ac1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有在这里包括样式，因为CSS文件有更多的行，在阅读时可能会分心。您可以简单地从<a class="ae kv" href="https://github.com/Yasas4D/ThemeChanger/tree/master/src/componenets/body/left-navigation-pannel" rel="noopener ugc nofollow" target="_blank">这里</a>复制样式和类名。确保也添加类名。</p><p id="fbb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我的主页，我创建了一个简单的欢迎页面，对于about页面也是如此。希望不需要在这里附上，你可以在这里找到双组分<a class="ae kv" href="https://github.com/Yasas4D/ThemeChanger/tree/master/src/componenets/body" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="bc51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，等一下，那个叫做<code class="fe ls lt lu lv b">ThemeChanger</code>的组件是什么？😕啊，别担心！这个我会在文末描述。</p><p id="715c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您已经完成了环境的设置，让我们转到主要内容。😍</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="e783" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">5.发布beast |上下文API</h1><p id="ac3b" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">好吧。现在是最精彩的部分！您必须创建2个(可选3个)东西来实现这个上下文API。</p><ol class=""><li id="4fc0" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr od nv nw nx bi translated">首先，我们需要创造环境。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="5d6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我为此创建了一个主题上下文。基本上，为了创建一个上下文，我们使用<code class="fe ls lt lu lv b">React.createContext</code>来创建一个上下文对象。在typescript中，我们需要为我们的上下文定义一个类型。</p><p id="ebf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在类型内部指定变量和函数。那么应该在泛型类型中提及。另外，请注意，这个上下文最初可能是未定义的。</p><p id="8256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.我们应该创建一个提供者来获取上下文</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="8720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我使用<code class="fe ls lt lu lv b">ReactNode</code>作为子类型，因为我的主题上下文组件接受任何有效的反应子类型。(<code class="fe ls lt lu lv b">ReactNode</code>是潜在DOM节点的表示。)所以任何组件都可以在这里传递，最终它将由提供者包装。</p><p id="9320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了<code class="fe ls lt lu lv b">useState</code>钩子来保持状态(至于初始主题，我使用了黑暗主题),它会将值传递给传入的组件。</p><p id="2679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.[可选]我们可以创建一个自定义挂钩来轻松访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="bdf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我只是用自定义名称返回了<code class="fe ls lt lu lv b">useContext</code>钩子。</p><p id="d742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于最后一步，我们需要在<code class="fe ls lt lu lv b">index.tsx</code>文件中将主题上下文提供者包装为应用程序的包装器。这将为我们的上下文提供对任何组件的访问。</p><pre class="kg kh ki kj gt ow lv ox oy aw oz bi"><span id="00eb" class="pa mg iq lv b gy pb pc l pd pe">&lt;ThemeContextProvider&gt; <br/>       &lt;App /&gt; <br/>&lt;/ThemeContextProvider&gt;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/a4383ebc85b9a10f9feec9bf1d12062d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAMwLcGYy40Rlu04HwsGiQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Folder Structure of the App</figcaption></figure><p id="fac9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切就绪！现在我们可以在任何组件中设置值，并且可以在组件树中的任何位置访问。看那多酷啊！</p><p id="01a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在移动到我们的应用程序时，我创建了一个新的<code class="fe ls lt lu lv b">theme.css</code>文件，并添加了一些漂亮的主题。你可以从下面检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="26a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您需要将这个<code class="fe ls lt lu lv b">css</code>文件添加到<code class="fe ls lt lu lv b">app.tsx</code>文件中，并访问上下文。然后获取类名，动态绑定到app。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="54cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在第7行和第8行看到的，我正在进口<code class="fe ls lt lu lv b">css</code>和我们定制的<code class="fe ls lt lu lv b">useContext</code>吊钩。在第13行，我从全局定义的上下文存储中获取<code class="fe ls lt lu lv b">themeName</code>，并将名称绑定到<code class="fe ls lt lu lv b">classname</code>(第16行)</p><p id="d418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经到了申请的末尾。唯一需要的部分是动态地改变主题。为此，我使用了另一个组件<code class="fe ls lt lu lv b">ThemeChanger</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg lx l"/></div></figure><p id="8a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正在使用我们的自定义钩子访问上下文，在选择主题后，它将更新状态。这最终会在主<code class="fe ls lt lu lv b">app.tsx </code>中更新，并且会导致主题的改变。</p><p id="2209" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以从任何组件中更改主题。只是你想补充。</p><pre class="kg kh ki kj gt ow lv ox oy aw oz bi"><span id="ecfb" class="pa mg iq lv b gy pb pc l pd pe">const { themeName, setThemeName } = useThemeContextCustomHook()!;</span></pre><p id="935c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从任何组件，你可以改变值，并从另一个更深的层次或任何组件。您只需根据自己的偏好更改创建上下文。(AuthToken，setAuthToken，setLocale…等等)想象一下在你的应用程序中实现这个的广阔领域。</p><p id="d068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们最终的旅程就要结束了。享受应用程序！您也可以创建更漂亮的主题。</p><h1 id="0119" class="mf mg iq bd mh mi nc mk ml mm nd mo mp jw ne jx mr jz nf ka mt kc ng kd mv mw bi translated">6.结论</h1><p id="0d97" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">React的上下文API是一个强大的工具，并且易于实现。这是一个干净的解决方案，可以支持钻取案例和生成顶级存储，而不必实现像Redux这样的大型库，并提供更好的状态管理方式。</p><p id="6ac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它让我们有可能在整个应用程序中共享变量，甚至功能，而不用在每次需要的时候把道具放下来。这使得我们的工作更快、更容易，因为我们可以访问应用程序中任何地方的数据，并最终提高应用程序的性能。</p><p id="efec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的源代码可以在下面的git-hub仓库中看到。</p><div class="oe of gp gr og oh"><a href="https://github.com/Yasas4D/ThemeChanger" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">Yasas4D/ThemeChanger</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">这个应用程序提供了一个与useContext相关的主题转换器。这将有助于更好地理解使用上下文…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="pi l os ot ou oq ov kp oh"/></div></div></a></div><p id="f3e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们今天所做的演示视频。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pj lx l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Theme changer application demonstration</figcaption></figure><p id="3cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我假设我已经公开了React的上下文API和<code class="fe ls lt lu lv b">useContext</code>钩子的值，这样您就可以在自己的React项目中成功地使用它。如果你有任何问题，请随时回复。感谢大家的阅读和快乐编码！</p></div></div>    
</body>
</html>