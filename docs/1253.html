<html>
<head>
<title>Implementing a Binary Search Tree with Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript实现二叉查找树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-binary-search-tree-163587006d42?source=collection_archive---------8-----------------------#2020-02-18">https://javascript.plainenglish.io/implementing-binary-search-tree-163587006d42?source=collection_archive---------8-----------------------#2020-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">去年，我有机会在Udemy上参加了一个名为<strong class="jp ir">掌握编码面试:数据结构+算法</strong>的课程，由<strong class="jp ir"> Andrei Neagoie </strong>教授(* <em class="kl">你可以在下面找到链接</em> <strong class="jp ir"> <em class="kl"> * </em> </strong>)。这位教师擅长使用<strong class="jp ir">类比</strong>、<strong class="jp ir">视觉</strong>和<strong class="jp ir">实际</strong>例子将数据结构和算法的简洁概念分解成可理解的块。</p><p id="1476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数组</strong>、<strong class="jp ir">哈希表</strong>、<strong class="jp ir">单双链表</strong>、<strong class="jp ir">树</strong>和<strong class="jp ir">图</strong>详细讲解。<strong class="jp ir">数据结构</strong>的利与弊以及它们应该应用到的适当问题也会被详细讨论。</p><p id="4582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有主要分类算法的讲座都有实例和时间复杂性分析的支持。诸如<strong class="jp ir">空间和时间复杂度</strong>的概念是响应于对这些数据结构采取的动作而被评估的；诸如<strong class="jp ir">添加/追加、移除、搜索</strong>等操作。</p><p id="a8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">退一步说，<strong class="jp ir">掌握编码面试:数据结构+算法</strong>是我上过的最好的在线编程课程之一。</p><p id="401b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我将<strong class="jp ir">总结一下</strong>我对实施<strong class="jp ir">二叉查找树</strong>的了解。我还将创建一个<strong class="jp ir">插入</strong> <strong class="jp ir">方法</strong>，该方法将获取一个节点并将其放置在<strong class="jp ir">二叉查找树</strong>的层次结构中的适当位置。</p><h1 id="c95e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">二叉查找树</h1><p id="d98d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir">二叉查找树</strong>是以<strong class="jp ir">倒排树</strong>的形式存储和组织数据的数据结构。树的<strong class="jp ir">根</strong>位于顶部，而叶子在它下面。树上的每个元素称为一个<strong class="jp ir">节点</strong>。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/571a63ff8e39ca11fa8713db5147779c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cdqi2xXL7vQ5oSRmtAbsxw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Inverted tree</figcaption></figure><h1 id="a266" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">结节</h1><p id="a1d9" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一个<strong class="jp ir">节点</strong>是二叉查找树的基本构建模块。一个节点有三个属性；<strong class="jp ir">值</strong>、<strong class="jp ir">左</strong>和<strong class="jp ir">右</strong>。</p><p id="eda0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的类是创建将插入到树中的节点的蓝图。当创建一个将被插入到树中的新节点时，您将创建这个<strong class="jp ir">节点</strong> <strong class="jp ir">类</strong>的一个<strong class="jp ir">实例</strong>。</p><pre class="lq lr ls lt gt mf mg mh mi aw mj bi"><span id="cdec" class="mk kn iq mg b gy ml mm l mn mo">class Node {<br/>   constructor(value) { <br/>      this.value = value;<br/>      this.left = null;<br/>      this.right = null;    <br/>  }<br/>}</span></pre><p id="372e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">value属性保存节点的<strong class="jp ir">值</strong>，而<strong class="jp ir"> left </strong>和<strong class="jp ir"> right </strong>属性分别保存对节点左侧和右侧节点的引用。</p><h1 id="4bed" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">根节点</h1><p id="5cda" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">添加到树中的第一个节点称为根节点。因为它是第一个节点，并且在创建时没有节点，所以只有value属性有值，而left和right属性有<code class="fe mp mq mr mg b">null</code>值。</p><h1 id="4b08" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">左节点和右节点</h1><p id="c1f1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><strong class="jp ir">二叉查找树</strong>的一个独特方面是，给定一个节点，其左侧节点的值应该较小，而其右侧节点的值应该较大。</p><p id="5be7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了一个二叉查找树。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ms"><img src="../Images/087ccee7b4712d34a3e34bb31672c290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzSjVsbntUD9yAjzpdmbfA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">A Binary Search Tree with 7 nodes</figcaption></figure><h1 id="fd3b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">二叉查找树</h1><p id="0272" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在让我们进入这个数据结构的核心。</p><p id="1cf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个名为<strong class="jp ir"> BinarySearchTree </strong>的类(蓝图)。我们稍后将创建的带有节点的树将是这个<strong class="jp ir">类</strong>的一个<strong class="jp ir">实例</strong>。</p><p id="44e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有多种方法可以添加到BinarySearchTree类中。有一部分是<code class="fe mp mq mr mg b">insert(val), remove(val) and search(val)</code>。但是，对于本文，我们将只关注实现<code class="fe mp mq mr mg b">insert(val)</code>方法，它将帮助我们向树结构中插入新的节点。</p><p id="e98e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们创建一个构造函数，在这个函数中我们将用null初始化根节点。这是因为，在这个阶段没有节点，没有根，显然也没有树。</p><pre class="lq lr ls lt gt mf mg mh mi aw mj bi"><span id="ebc3" class="mk kn iq mg b gy ml mm l mn mo">class BinarySearchTree {<br/>   constructor() {<br/>      this.root = null;<br/>   }<br/>}</span></pre><p id="6380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将创建我们的<code class="fe mp mq mr mg b">insert</code>方法，该方法将一个整数作为参数，创建一个新的节点实例，并在树上找到节点的正确位置，然后将其插入到那里。</p><p id="81be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们之前创建的<strong class="jp ir">节点</strong>类在这里开始起作用。我们将简单地从它创建一个新的实例，它将把值传递给树的insert方法。</p><p id="0be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有可能树还没有被创建(根为空)。如果是这样，我们将刚刚创建的<strong class="jp ir"> newNode </strong>实例分配给<code class="fe mp mq mr mg b">this.root</code>。这样我们就可以确定树有一个根(没有根就没有树:)，这是数据结构中的第一个节点。</p><pre class="lq lr ls lt gt mf mg mh mi aw mj bi"><span id="3307" class="mk kn iq mg b gy ml mm l mn mo">class BinarySearchTree {<br/>   constructor() {<br/>      this.root = null;<br/>   }</span><span id="9947" class="mk kn iq mg b gy mt mm l mn mo">insert(val) {<br/>     const newNode = new Node(val);<br/>     <br/>     if (!this.root) {<br/>       this.root = newNode;   <br/>     } else {</span><span id="21c0" class="mk kn iq mg b gy mt mm l mn mo">}  <br/>   }<br/>}</span></pre><h1 id="2c36" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">插入节点</strong></h1><p id="e0db" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果根已经存在，我们需要<strong class="jp ir">遍历</strong>树，找到可以插入新节点的适当位置。为此，我们将创建一个新方法，它将接受两个参数，一个是我们遍历树时正在查看的<strong class="jp ir">当前节点</strong>，另一个是我们想要插入到树中的<strong class="jp ir">节点</strong>。</p><p id="c8fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个我们称之为<code class="fe mp mq mr mg b">insertNode(currentNode, newNode) </code>的方法将把<code class="fe mp mq mr mg b">this.root</code>和<code class="fe mp mq mr mg b">newNode</code>作为参数。如果树只有一个节点(根节点)，left和right属性将为null，因此基于newNode的值和根节点的值，我们将新节点放在根节点的左边或右边。否则，我们将从根节点开始对每个节点进行递归检查，以查看新节点是否适合树中节点的左侧或右侧。</p><p id="1f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mp mq mr mg b">insertNode(currentNode, newNode) </code>函数中，我们需要检查newNode的值是否小于<em class="kl"> currentNode </em>的值？如果是这种情况，我们需要检查currentNode的left属性的值。如果值为null，我们将newNode赋给left属性。否则，如果左边的属性有一个值，我们需要递归调用<code class="fe mp mq mr mg b">insertNode(currentNode, newNode)</code>方法，并传递给它currentNode.left和newNode。</p><p id="e016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr mg b">this.insertNode(node.left, newNode)</code>。</p><p id="5bac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果你回到第一个if块，你可以观察到它包含了我们的基本情况。当当前节点的左属性的值为<code class="fe mp mq mr mg b">null</code>时，递归将停止。</p><pre class="lq lr ls lt gt mf mg mh mi aw mj bi"><span id="3961" class="mk kn iq mg b gy ml mm l mn mo">class BinarySearchTree {<br/>    constructor() {<br/>      this.root = null;<br/>   }<br/>   <br/>   insert(val) {<br/>      const newNode = new Node(val);<br/>      <br/>      if (!this.root) {<br/>        this.root = newNode;   <br/>      } else { <br/>        this.insertNode(this.root, newNode)     <br/>     }<br/>   }  <br/>   <br/>   insertNode(currentNode, newNode) {<br/>    if (currentNode.value &gt; newNode.value) {<br/>        if (currentNode.left === null) {<br/>            currentNode.left = newNode;<br/>        } else {<br/>            this.insertNode(currentNode.left, newNode);<br/>        }<br/>     }  else {<br/>        if (currentNode.right === null) {<br/>            currentNode.right = newNode;<br/>        } else {<br/>            this.insertNode(currentNode.right, newNode);<br/>        }<br/>      }     <br/>   }<br/>}</span></pre><p id="892f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以从BinarySearchTree类创建一个新的树实例，并根据需要多次调用实例上的insert方法，并将值传递给它。</p><pre class="lq lr ls lt gt mf mg mh mi aw mj bi"><span id="ebd6" class="mk kn iq mg b gy ml mm l mn mo">const myTree = new BinarySearchTree();</span><span id="0ee0" class="mk kn iq mg b gy mt mm l mn mo">myTree.insert(3);</span><span id="546b" class="mk kn iq mg b gy mt mm l mn mo">myTree.insert(10)<br/>myTree.insert(2)<br/>myTree.insert(3)<br/>myTree.insert(7)<br/>myTree.insert(-11)<br/>myTree.insert(18)<br/>myTree.insert(14)<br/>myTree.insert(12)<br/>myTree.insert(19)<br/>myTree.insert(21)</span><span id="9e3a" class="mk kn iq mg b gy mt mm l mn mo">console.log(JSON.stringify(myTree));</span></pre><p id="a6c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://vanya.jp.net/vtree/有一个很棒的工具可以帮助你可视化JSON BST数据结构。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mv"><img src="../Images/d70e61db32e3f008b6efd12756436337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jId1ZEhLkIHyl5CxriLkg.png"/></div></div></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="91a3" class="km kn iq bd ko kp nd kr ks kt ne kv kw kx nf kz la lb ng ld le lf nh lh li lj bi translated">摘要</h1><p id="7ef7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">课程<a class="ae mu" href="https://www.udemy.com/master-the-coding-interview-data-structures-algorithms/?ranMID=39197&amp;ranEAID=JAsBp5BFozE&amp;ranSiteID=JAsBp5BFozE-28H3FUxSzbSuGGq3hx33RQ&amp;LSNPUBID=JAsBp5BFozE" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">掌握编码面试:数据结构+算法</strong> </a> <strong class="jp ir"> </strong>是一门教授基本计算机科学概念的伟大课程。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><a href="https://click.linksynergy.com/link?id=JAsBp5BFozE&amp;offerid=507388.1917546&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fmaster-the-coding-interview-data-structures-algorithms%2F"><div class="gh gi ni"><img src="../Images/67c58ec3da047070a6867131192e589c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TUqLJDvdS6WvKAOA08AIog.png"/></div></a></figure><p id="f0d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将带你深入了解数据结构和算法。<strong class="jp ir">二分搜索法树</strong>是讨论的数据结构之一。BST用于在不同环境下高效存储和检索数据。</p><p id="d817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BST的基本构造块称为节点。一个节点有三个属性(值、左和右)。left和right属性保存有关节点左侧和右侧节点的信息。</p><p id="462f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">树底部的所有节点的左值和右值都为null。当您向树中插入一个新节点时，首先需要查看该值是小于还是大于根的值。如果它更小，你需要递归地寻找左边的节点，如果它更大，则相反。</p><p id="3cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结帐<a class="ae mu" href="https://hired.com/x/fd35d132f87b1210edf7a5fc32ad79a9" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">应聘</strong> </a> <strong class="jp ir"> </strong>软件工程岗位:<a class="ae mu" href="https://hired.com/x/fd35d132f87b1210edf7a5fc32ad79a9" rel="noopener ugc nofollow" target="_blank">https://hired.com/x/fd35d132f87b1210edf7a5fc32ad79a9</a></p></div></div>    
</body>
</html>