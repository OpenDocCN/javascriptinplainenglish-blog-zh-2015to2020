<html>
<head>
<title>Const and Identity Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常数和单位单子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/const-and-identity-monads-6cbeca88fc85?source=collection_archive---------9-----------------------#2020-10-24">https://javascript.plainenglish.io/const-and-identity-monads-6cbeca88fc85?source=collection_archive---------9-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3429" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">意想不到的有用构造</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ef60a672c5b682516382342c38e1cfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jPt3DoPfQHjPiTGF"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kelli_mcclintock?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelli McClintock</a> on <a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="73ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天我要谈谈我最喜欢的两个单子——<em class="ls">恒等式</em>和<em class="ls">常量。这些是基本单位单子，只保存一个值。它们可能是最容易理解的单子，但是它们有强大的含义和用途。如果你还不了解单子，可以在这里查看我对单子作为<em class="ls">接口</em> <a class="ae kv" href="https://rossketeer.medium.com/the-monad-interface-2045e5810851" rel="noopener">的简单解释。</a></em></p><p id="983f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先说身份单子。单位单子是通过将一个简单的值放入其中构造的，可以是数字、字符串或对象。它不会对那个值做任何特别的事情，它只是把它放在我们漂亮的一元盒子里，从这里我们可以<em class="ls">映射</em>到内容，<em class="ls">链接</em>内容到一个新的一元类型，或者打开盒子找出我们得到的值是什么。我们可以简单地定义它，就像这样(我喜欢把单子的内容藏在一个符号键里):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/7ab6b05699396c724b66961225b0f0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoYTl-n4dmibCA-ZSmH4pA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Simple Identity Monad definition.</figcaption></figure><p id="f747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们通过定义<em class="ls"> map、chain、</em>和<em class="ls"> unwrap </em>方法来坚持我们的Monad接口。我们使用我们的秘密值来实现这些方法。如您所见，Identity只是秘密值的包装器，并不做任何其他特殊的事情。注意我们如何定义<em class="ls">展开。我们将<code class="fe lu lv lw lx b">identity</code>函数链接起来。identity函数是Identity monad的姊妹函数——它返回您输入的任何内容。因为chain在Identity实例的秘密值上调用它提供的函数<code class="fe lu lv lw lx b">f</code>，它将有效地返回那个秘密值。这可以应用于任何单子，以实现展开。这是单子的数学对称性质的一部分，我们通过我们的链定义得到了展开的自由定义。它也以另一种方式工作，(因此对称)。我们可以通过重用map和unwrap中的定义来定义chain，就像这样:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/dcea30819114b6a519fe6b58a3fa7ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNGzb-m7G15-fP0XSDvlGA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Alternative chain definition.</figcaption></figure><p id="5e48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，<em class="ls">将</em>映射到Identity实例上，然后<em class="ls">展开</em>其内容，本质上与将<code class="fe lu lv lw lx b">f</code>应用于展开的值是完全相同的结果。这使得单位单子完美地说明了单子的数学对称性。所有的单子都应该能够通过互相结合使用map来交换chain或unwrap的定义。这种巧妙的可互换性是单子成为单子的根本原因！</p><p id="bc29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们知道了所有关于同一性的东西，让我们继续讨论常数单子。Const真的很像Identity，除了你放入Const monad的东西是不可改变的。您可以随意对其进行映射，但结果将始终与您最初输入的内容完全相同。我们可以这样定义它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/a7ba4e2e243af479e24d8aa082de0e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnM9oGaiTXaesmrpvRJ9TQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The Const Monad, defined simply.</figcaption></figure><p id="d1e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，映射Const Monad总是产生它自己，没有修改，就像链接它一样。这背后的事实是，从技术上讲，它本身并不是一个单子。但是如果你看任一单子的左边部分，你会注意到它看起来完全像Const——那是因为它是Const！</p><p id="d725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么这有什么好处呢？让我们写一个小例子来说明一个简单的用法——函数getters和setters。这是“透镜”的一个例子，但是被大大简化了。镜头是一个函数，通过劫持Identity和Const构造，它可以充当getter和setter。不过，我将简单地说明如何通过使用Const或Identity来阻止或允许对象属性的设置。首先，如果您正在使用codepen或您自己的IDE，请复制我将提供的curry的定义:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/c0e87596f27f3bba10f7ed5951f3b058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qg2R6I6ky3SA5u9dwYG5Eg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A super light helper to define an auto-curried function.</figcaption></figure><p id="2a62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还不知道的话，curry 是一种为函数提供少于所需参数总数的方法，用来创建一个叫做<em class="ls">的部分应用程序。</em>人们一般把局部涂抹的过程称为<em class="ls">涂抹。这是函数式编程的一个主要特点。我将在另一个时间写更多关于咖喱的东西，现在这就是你继续这个例子所需要的。</em></p><p id="2ea5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们定义一些无指针样式的<em class="ls"> get </em>和<em class="ls"> set </em>函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/5316b0b6892383272bc79a2ec451dc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkLkzE9pFXFk6TS1Hh-byg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Curried Get and Set functions…we’ll use these shortly.</figcaption></figure><p id="dfbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们编写了一些函数，这些函数看着一个<code class="fe lu lv lw lx b">obj</code>，我们假设它是一个带有<code class="fe lu lv lw lx b">map</code>的单子。然后，我们使用<code class="fe lu lv lw lx b">set</code>转换基础值，或者使用<code class="fe lu lv lw lx b">get</code>返回请求的属性。涂抹它们可以让我们像这样做一些功能性的魔法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/36ab2ece0cc942b3379a3ffe15dbc831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xz61nshkdsLhuc4loUhYzw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">How to use curried functions to make specialized functions.</figcaption></figure><p id="5c77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个定制的<code class="fe lu lv lw lx b">get</code>函数允许我们预加载一个参数，返回一个接受剩余参数的函数。酷！继续看一些用法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/d967b9859aa168f4ccda49a5b3146cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIw_qV3k0vcRxzlQLXBO5w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Some examples of our Monads in action.</figcaption></figure><p id="7225" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我把自己定义为一个例子。我们使用<code class="fe lu lv lw lx b">...</code> spread语法复制<code class="fe lu lv lw lx b">me</code>对象，因为否则我们将引用原始的<code class="fe lu lv lw lx b">me</code>对象，导致我们的Const和Identity实例都指向该原始对象，这不是我们想要的行为。那么，当我们试图分别设置Const和Identity的内部值时，您认为会发生什么呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/6b63f6d52245fc4da5f28c965ea408c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Md1oQPphYer_itXTOEPiqg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Seeing the results of our Const and Identity Monads contents.</figcaption></figure><p id="dfd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你认为我们不能修改Const，但是我们可以修改Identity，那你就对了！如果您继续学习单子，您将会理解Identity和Const只是其他单子和函数运算的构建块。这里有一支笔展示我的作品:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="619d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望您喜欢另一次函数式编程冒险。请继续关注更多内容，继续关注FP！</p></div></div>    
</body>
</html>