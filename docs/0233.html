<html>
<head>
<title>How to add Password Reset functionality to your App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何向您的应用程序添加密码重置功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-password-reset-functionality-to-your-app-5d1a18bc9dd8?source=collection_archive---------1-----------------------#2019-08-31">https://javascript.plainenglish.io/how-to-add-password-reset-functionality-to-your-app-5d1a18bc9dd8?source=collection_archive---------1-----------------------#2019-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/76035f5c9453710375be5d8ec660b28a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*g-sa7rhp3MJV0c_CoMQEWw.gif"/></div></div></figure><h1 id="4841" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">随着单页面前端应用程序和移动应用程序比以往任何时候都更受欢迎，前端与后端分离。</h1><p id="93c7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于几乎所有的web应用程序都需要身份验证，因此前端或移动应用程序需要一种安全的方式来存储用户身份数据。</p><h2 id="c7c4" class="lu jz iq bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">由于许多用户最终会忘记他们的密码，大多数应用程序都有密码重置功能。</h2><p id="f2bf" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">幸运的是，这是一个很容易添加的特性。为了确保密码重置功能的安全，我们会在用户请求重置密码时即时生成一个密码重置令牌，然后我们会向用户注册时使用的电子邮件地址发送一封包含重置密码链接的电子邮件，用户可以打开该电子邮件，单击该链接，如果密码重置令牌有效，他们就可以重置密码。</p><p id="b887" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">对于身份验证特性，我们发布并验证JSON Web令牌，以便客户端Web应用程序、移动应用程序和其他后端应用程序可以使用带有令牌的API。</p><h1 id="45c9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概观</h1><p id="4d02" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于后端，我们将使用运行在Node.js上的Express框架，对于前端，我们将使用Angular框架。两者都有自己的JWT插件。在后端，我们有用于生成和验证令牌的<code class="fe ml mm mn mo b">jsonwebtoken</code>包。</p><p id="babf" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在前端，我们有用于角度的<code class="fe ml mm mn mo b">@auth0/angular-jwt</code>模块。在我们的应用程序中，当用户输入用户名和密码，并且它们在我们的数据库中时，就会从我们的密钥中生成一个JWT，返回给用户，并存储在本地存储的前端应用程序中。每当用户需要访问后端经过身份验证的路由时，他们都需要令牌。</p><p id="8ad7" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在后端应用程序中会有一个名为中间件的功能来检查有效的令牌。一个有效的令牌是一个没有过期的令牌，并且根据我们的秘密密钥验证是有效的。除了登录页面之外，还将有注册和用户凭证设置页面。</p><h1 id="6cbd" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">构建应用程序</h1><p id="0ed7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有了这个计划，我们就可以开始了。</p><p id="2bda" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">首先，我们创建前端和后端应用程序文件夹。每人做一个。</p><p id="08f6" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">然后我们开始写后端的app。首先，我们安装一些包并生成我们的Express框架代码。我们运行<code class="fe ml mm mn mo b">npx express-generator</code>来生成代码。然后我们必须安装一些软件包。我们通过运行<code class="fe ml mm mn mo b">npm i @babel/register express-jwt sequelize bcrypt sequelize-cli dotenv jsonwebtoken body-parser cors crypto @sendgrid/mail</code>来做到这一点。<code class="fe ml mm mn mo b">@babel/register</code>允许我们使用最新的JavaScript特性。</p><p id="29f9" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><code class="fe ml mm mn mo b">express-jwt</code>生成JWT并根据密钥进行验证。<code class="fe ml mm mn mo b">bcrypt</code>对我们的密码进行哈希和加盐处理。<code class="fe ml mm mn mo b">sequelize</code>是我们做CRUD的ORM。<code class="fe ml mm mn mo b">cors</code>通过允许跨域通信，允许我们的Angular app与我们的后端进行通信。<code class="fe ml mm mn mo b">dotenv</code>允许我们在一个<code class="fe ml mm mn mo b">.env</code>文件中存储环境变量。Express需要使用<code class="fe ml mm mn mo b">body-parser</code>来解析JSON请求。我们使用<code class="fe ml mm mn mo b">crypto</code>库来生成我们的密码重置令牌。我们使用<code class="fe ml mm mn mo b"> @sendgrid/mail</code>通过SendGrid发送电子邮件。这项服务使发送电子邮件变得非常容易。你不必自己做邮件服务器。</p><p id="925a" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">然后我们进行数据库迁移。首先，我们运行<code class="fe ml mm mn mo b">npx sequelize-cli init</code>来生成数据库到对象映射的框架代码。然后我们运行:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="3af7" class="lu jz iq mo b gy mx my l mz na">npx sequelize-cli model:generate --name User --attributes username:string, password:string, email:string, passwordResetToken:string</span></pre><p id="8ca4" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">我们进行另一次迁移，并输入:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="7e4c" class="lu jz iq mo b gy mx my l mz na">'use strict';</span><span id="eee2" class="lu jz iq mo b gy nb my l mz na">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return Promise.all([<br/>      queryInterface.addConstraint(<br/>        "Users",<br/>        ["email"],<br/>        {<br/>          type: "unique",<br/>          name: 'emailUnique'<br/>        }),queryInterface.addConstraint(<br/>        "Users",<br/>        ["userName"],<br/>        {<br/>          type: "unique",<br/>          name: 'userNameUnique'<br/>        }),<br/>  },</span><span id="370e" class="lu jz iq mo b gy nb my l mz na">  down: (queryInterface, Sequelize) =&gt; {<br/>    return Promise.all([<br/>      queryInterface.removeConstraint(<br/>        "Users",<br/>        'emailUnique'<br/>      ),queryInterface.removeConstraint(<br/>        "Users",<br/>        'userNameUnique'<br/>      ),<br/>    ])<br/>  }<br/>};</span></pre><p id="d67e" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这确保我们不会有两个相同用户名或电子邮件的条目。</p><p id="7945" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这将创建用户模型，并在我们运行<code class="fe ml mm mn mo b">npx sequelize-cli db:migrate</code>时创建用户表。</p><p id="cf04" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">然后我们写一些代码。首先，我们将以下内容放入<code class="fe ml mm mn mo b">app.js</code>:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="1e62" class="lu jz iq mo b gy mx my l mz na">require("<a class="ae nc" href="http://twitter.com/babel/register" rel="noopener ugc nofollow" target="_blank">@babel/register</a>");<br/>require("babel-polyfill");<br/>require('dotenv').config();<br/>const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const cors = require('cors');<br/>const user = require('./controllers/userController');<br/>const app = express();app.use(cors())<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>app.use(bodyParser.json());</span><span id="7b27" class="lu jz iq mo b gy nb my l mz na">app.use((req, res, next) =&gt; {<br/>  res.locals.session = req.session;<br/>  next();<br/>});</span><span id="dc76" class="lu jz iq mo b gy nb my l mz na">app.use('/user', user);app.get('*', (req, res) =&gt; {<br/>  res.redirect('/home');<br/>});</span><span id="0e23" class="lu jz iq mo b gy nb my l mz na">app.listen((process.env.PORT || 8080), () =&gt; {<br/>  console.log('App running on port 8080!');<br/>});</span></pre><p id="be10" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">我们需要:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="25af" class="lu jz iq mo b gy mx my l mz na">require("<a class="ae nc" href="http://twitter.com/babel/register" rel="noopener ugc nofollow" target="_blank">@babel/register</a>");<br/>require("babel-polyfill");</span></pre><p id="1275" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">使用JavaScript的最新特性。</p><p id="97c9" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">我们需要:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="a56d" class="lu jz iq mo b gy mx my l mz na">require('dotenv').config();</span></pre><p id="b0f2" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">读取我们在<code class="fe ml mm mn mo b">.env</code>文件中的配置。</p><p id="a9c9" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这是切入点。我们将很快在<code class="fe ml mm mn mo b">controllers</code>文件夹中创建<code class="fe ml mm mn mo b">userController</code>。</p><p id="5c22" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><code class="fe ml mm mn mo b">app.use(‘/user’, user);</code>将任何以<code class="fe ml mm mn mo b">user</code>开头的URL路由到<code class="fe ml mm mn mo b">userController</code>文件。</p><p id="a7cb" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">接下来，我们添加<code class="fe ml mm mn mo b">userController.js</code>文件:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="84e4" class="lu jz iq mo b gy mx my l mz na">const express = require('express');<br/>const bcrypt = require('bcrypt');<br/>const router = express.Router();<br/>const models = require('../models');<br/>const jwt = require('jsonwebtoken');<br/>import { saltRounds } from '../exports';<br/>import { authCheck } from '../middlewares/authCheck';</span><span id="08a0" class="lu jz iq mo b gy nb my l mz na">router.post('/login', async (req, res) =&gt; {<br/>    const secret = process.env.JWT_SECRET;<br/>    const userName = req.body.userName;<br/>    const password = req.body.password;<br/>    if (!userName || !password) {<br/>        return res.send({<br/>            error: 'User name and password required'<br/>        })<br/>    }<br/>    const users = await models.User.findAll({<br/>        where: {<br/>            userName<br/>        }<br/>    })    </span><span id="1739" class="lu jz iq mo b gy nb my l mz na">    const user = users[0];<br/>    if (!user) {<br/>        res.status(401);<br/>        return res.send({<br/>            error: 'Invalid username or password'<br/>        });<br/>    }    try {<br/>        const compareRes = await bcrypt.compare(password, user.hashedPassword);<br/>        if (compareRes) {<br/>            const token = jwt.sign(<br/>                {<br/>                    data: {<br/>                        userName,<br/>                        userId: user.id<br/>                    }<br/>                },<br/>                secret,<br/>                { expiresIn: 60 * 60 }<br/>            );<br/>            return res.send({ token });<br/>        }<br/>        else {<br/>            res.status(401);<br/>            return res.send({<br/>                error: 'Invalid username or password'<br/>            });<br/>        }<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(401);<br/>        return res.send({<br/>            error: 'Invalid username or password'<br/>        });<br/>    }});</span><span id="2627" class="lu jz iq mo b gy nb my l mz na">router.post('/signup', async (req, res) =&gt; {<br/>    const userName = req.body.userName;<br/>    const email = req.body.email;<br/>    const password = req.body.password;<br/>    try {<br/>        const hashedPassword = await bcrypt.hash(password, saltRounds)<br/>        await models.User.create({<br/>            userName,<br/>            email,<br/>            hashedPassword<br/>        })<br/>        return res.send({ message: 'User created' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(400);<br/>        return res.send({ error: ex });<br/>    }<br/>});</span><span id="e469" class="lu jz iq mo b gy nb my l mz na">router.put('/updateUser', authCheck, async (req, res) =&gt; {<br/>    const userName = req.body.userName;<br/>    const email = req.body.email;<br/>    const token = req.headers.authorization;<br/>    const decoded = jwt.verify(token, process.env.JWT_SECRET);<br/>    const userId = decoded.data.userId;<br/>    try {<br/>        await models.User.update({<br/>            userName,<br/>            email<br/>        }, {<br/>                where: {<br/>                    id: userId<br/>                }<br/>            })<br/>        return res.send({ message: 'User created' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(400);<br/>        return res.send({ error: ex });<br/>    }});</span><span id="6398" class="lu jz iq mo b gy nb my l mz na">router.put('/updatePassword', authCheck, async (req, res) =&gt; {<br/>    const token = req.headers.authorization;<br/>    const password = req.body.password;<br/>    const decoded = jwt.verify(token, process.env.JWT_SECRET);<br/>    const userId = decoded.data.userId;<br/>    try {<br/>        const hashedPassword = await bcrypt.hash(password, saltRounds)<br/>        await models.User.update({<br/>            hashedPassword<br/>        }, {<br/>                where: {<br/>                    id: userId<br/>                }<br/>            })<br/>        return res.send({ message: 'User created' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.status(400);<br/>        return res.send({ error: ex });<br/>    }});</span><span id="51be" class="lu jz iq mo b gy nb my l mz na">router.post('/passwordResetRequest', async (req, res) =&gt; {<br/>    const email = req.body.email;<br/>    const buffer = await crypto.randomBytes(32);<br/>    const passwordResetToken = buffer.toString("hex");<br/>    try {<br/>        await models.User.update(<br/>            {<br/>                passwordResetToken<br/>            }, {<br/>                where: {<br/>                    email<br/>                }<br/>            }<br/>        )<br/>        const passwordResetUrl = `${process.env.FRONTEND_URL}/passwordReset?passwordResetToken=${passwordResetToken}`;<br/>        sgMail.setApiKey(process.env.SENDGRID_API_KEY);<br/>        const msg = {<br/>            to: email,<br/>            from: process.env.FROM_EMAIL,<br/>            subject: 'Password Reset Request',<br/>            text: `<br/>            Dear user,</span><span id="d5f2" class="lu jz iq mo b gy nb my l mz na">You can reset your password by going to ${passwordResetUrl}<br/>        `,<br/>            html: `<br/>            &lt;p&gt;Dear user,&lt;/p&gt;</span><span id="a6f6" class="lu jz iq mo b gy nb my l mz na">&lt;p&gt;<br/>                You can reset your password by going to<br/>                &lt;a href="${passwordResetUrl}"&gt;this link&lt;/a&gt;<br/>            &lt;/p&gt;<br/>        `,<br/>        };<br/>        sgMail.send(msg);<br/>        res.send({ message: 'Successfully sent email' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.send(ex, 500);<br/>    }<br/>});</span><span id="fdb9" class="lu jz iq mo b gy nb my l mz na">router.post('/passwordReset', async (req, res) =&gt; {<br/>    const password = req.body.password;<br/>    const passwordResetToken = req.body.passwordResetToken;<br/>    const hashedPassword = await bcrypt.hash(password, saltRounds);<br/>    const buffer = await crypto.randomBytes(32);<br/>    const newPasswordResetToken = buffer.toString("hex");<br/>    try {<br/>        await models.User.update(<br/>            {<br/>                hashedPassword,<br/>                passwordResetToken: newPasswordResetToken<br/>            }, {<br/>                where: {<br/>                    passwordResetToken<br/>                }<br/>            }<br/>        )<br/>        res.send({ message: 'Successfully reset password' });<br/>    }<br/>    catch (ex) {<br/>        logger.error(ex);<br/>        res.send(ex, 500);<br/>    }</span><span id="ca9f" class="lu jz iq mo b gy nb my l mz na">});</span><span id="a893" class="lu jz iq mo b gy nb my l mz na">module.exports = router;</span></pre><p id="fee6" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><code class="fe ml mm mn mo b">login</code>路线搜索用户输入。如果找到了，它就用<code class="fe ml mm mn mo b">bcrypt</code>的<code class="fe ml mm mn mo b">compare </code>函数检查散列密码。如果两者都成功，则生成一个JWT。<code class="fe ml mm mn mo b">signup</code>路由获取用户名和密码的JSON负载并保存。</p><p id="bda9" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">请注意，在保存之前，会对密码进行哈希和加盐处理。密码不应以纯文本形式存储。</p><p id="8c81" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这第一个是纯文本密码，第二个是一些盐轮。</p><p id="7dfd" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><code class="fe ml mm mn mo b">updatePassword</code>路由是经过认证的路由。它检查令牌，如果它是有效的，它将通过从解码的令牌中搜索带有用户id的<code class="fe ml mm mn mo b">User</code>来继续保存用户的密码。</p><p id="b443" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">当路由被调用时，<code class="fe ml mm mn mo b">passwordResetRequest</code>路由生成密码重置令牌，并将其保存到我们的<code class="fe ml mm mn mo b">Users</code>表的<code class="fe ml mm mn mo b">passwordResetToken</code>列中。然后发送一封电子邮件，在URL中包含密码重置令牌。由于电子邮件发送到用户的注册电子邮件，只有用户可以看到电子邮件，并使用电子邮件中的链接来重置他们的密码。</p><p id="1d13" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">然后，当调用<code class="fe ml mm mn mo b">passwordReset</code>时，用户的密码在使用该块检查其密码重置令牌后被重置:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="670d" class="lu jz iq mo b gy mx my l mz na">where: {<br/>  passwordResetToken<br/>}</span></pre><p id="75fe" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在<code class="fe ml mm mn mo b">await models.User.update</code>函数调用中。如果找不到带<code class="fe ml mm mn mo b">passwordResetToken</code>的用户，密码不会被重置。当用户重置其密码时，还会生成一个新的密码重置令牌，以便旧的密码无法再次使用。</p><p id="ff9f" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">接下来我们将添加<code class="fe ml mm mn mo b">authCheck</code>中间件。我们创建一个<code class="fe ml mm mn mo b">middlewares</code>文件夹，并在其中创建<code class="fe ml mm mn mo b">authCheck.js</code>。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="9d71" class="lu jz iq mo b gy mx my l mz na">const jwt = require('jsonwebtoken');<br/>const secret = process.env.JWT_SECRET;export const authCheck = (req, res, next) =&gt; {<br/>    if (req.headers.authorization) {<br/>        const token = req.headers.authorization;<br/>        jwt.verify(token, secret, (err, decoded) =&gt; {<br/>            if (err) {<br/>                res.send(401);<br/>            }<br/>            else {<br/>                next();<br/>            }<br/>        });<br/>    }<br/>    else {<br/>        res.send(401);<br/>    }<br/>}</span></pre><p id="57c8" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">您应该使用相同的<code class="fe ml mm mn mo b">process.env.JWT_SECRET</code>来生成和验证令牌。否则，验证将失败。这个秘密不应该在任何地方共享，也不应该签入版本控制。</p><p id="785a" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这允许我们在经过身份验证的路由中检查身份验证，而无需重复代码。我们通过导入和引用它，将它放在每个认证路由的URL和主路由代码之间。</p><p id="ed67" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">我们做一个后端app文件夹根目录的<code class="fe ml mm mn mo b">.env</code>文件，内容如下。(这不应该签入版本控制。)</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="8d75" class="lu jz iq mo b gy mx my l mz na">DB_HOST='localhost'<br/>DB_NAME='login-app'<br/>DB_USERNAME='db-username'<br/>DB_PASSWORD='db-password'<br/>JWT_SECRET='secret'</span></pre><p id="cf44" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">后端应用程序现在已经完成。现在我们可以使用前端应用程序、移动应用程序或任何HTTP客户端进行登录。如果需要，他们还可以安全地重置密码。</p><p id="45e1" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><strong class="ky ir">现在就在</strong><a class="ae nc" href="http://jauyeung.net/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">http://jauyeung.net/subscribe/</strong></a><strong class="ky ir">订阅我的邮箱列表获取更多教程。</strong></p><p id="6cf4" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><strong class="ky ir">在推特上关注我</strong>【https://twitter.com/AuMayeung】<strong class="ky ir"/></p></div></div>    
</body>
</html>