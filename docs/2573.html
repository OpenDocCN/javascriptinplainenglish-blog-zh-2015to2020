<html>
<head>
<title>Working With Bits In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript中的位</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/working-with-bits-edbe4daeac6c?source=collection_archive---------2-----------------------#2020-07-06">https://javascript.plainenglish.io/working-with-bits-edbe4daeac6c?source=collection_archive---------2-----------------------#2020-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b1549b3b6b5de613f29a11e113a7afdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kP64AXOI_oml41Xj_NxPLA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">01000110 01101001 01110110 01100101 00100000 01110000 01100001 01100011 00101101 01100100 01101111 01110100 01110011 00100000 01100001 01110111 01100001 01111001 00100000 01100110 01110010 01101111 01101101 00100000 01110011 01101111 01101101 01100101 00100000 01100010 01101111 01101110 01110101 01110011 00100000 01100110 01110010 01110101 01101001 01110100 00100001</figcaption></figure><h2 id="f8a0" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">我最近做了一个叫做<a class="ae kv" href="https://www.hackerrank.com/challenges/flipping-bits/problem" rel="noopener ugc nofollow" target="_blank"> <em class="kw">翻转位</em> </a>的黑客银行代码挑战，玩得很开心！</h2><p id="1c70" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh ki li lj lk km ll lm ln kq lo lp lq lr ig bi translated">这是一个非常简单的问题，但是它引发了对<a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_data#:~:text=Binary%20data%20is%20data%20whose,numeral%20system%20and%20Boolean%20algebra." rel="noopener ugc nofollow" target="_blank">二进制数据</a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Algebra" rel="noopener ugc nofollow" target="_blank">代数</a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="noopener ugc nofollow" target="_blank">位运算</a>的一些探索和实现。我在做这个挑战的时候在<code class="fe ls lt lu lv b">JavaScript</code>中编程。因此，本文中的代码示例将出现在<code class="fe ls lt lu lv b">JavaScript</code>和特定于该语言的按位运算符中。然而，按位运算大多是通用的。许多编程语言都以相同的方式使用按位运算符，或者主要在语法上有所不同，所以这些知识应该很容易转移。</p><p id="5ed2" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">二进制数据在计算机科学中被称为位，由两种状态之一表示:<code class="fe ls lt lu lv b">0</code>和<code class="fe ls lt lu lv b">1</code>。您可以将其视为开关:<code class="fe ls lt lu lv b">OFF</code>和<code class="fe ls lt lu lv b">ON</code>。在一个非常低的水平上，二进制数据负责几乎每一个甜蜜的计算机消遣你参与。比特类似于身体的细胞。我们用手指打字，用眼睛阅读，但是，在我们内心深处，细胞构成了产生我们身体过程、运动等等的引擎。</p><p id="e633" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">比特是有用的，强大的数据。大多数程序员都从事高层次的工作，尤其是框架和API所提供的出色的抽象和便利很容易被采用和构建。在底层，代码需要有坚实的基础，按位运算对于涉及硬件通信、网络协议、图形、加密和权限的现实场景非常有用。力量来自二进制的简单逻辑。在二进制级别，解释或改变一段数据就像打开一些0和1一样简单。</p><p id="441b" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">我们不会跟随蚁人到量子领域，不会太远……但是我们会深入到二进制领域来解决这个代码挑战，并学习按位运算。对于这个解决方案，我将演示一种编程方法，然后继续优化代码，直到函数缩减为27个字符长的单行代码。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="20ac" class="mj ka in bd kb mk ml mm ke mn mo mp kh mq mr ms kl mt mu mv kp mw mx my kt mz bi translated">翻转位</h1><h2 id="3187" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">问题陈述:</h2><p id="0a7d" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh ki li lj lk km ll lm ln kq lo lp lq lr ig bi translated">给定<code class="fe ls lt lu lv b">n</code>，一个32位无符号整数，翻转其二进制表示(<code class="fe ls lt lu lv b">0 -&gt; 1 | 1 -&gt; 0</code>)的位，并将结果打印为无符号整数。例如:</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="817a" class="jz ka in lv b gy ni nj l nk nl">n = 123456</span><span id="081b" class="jz ka in lv b gy nm nj l nk nl">00000000000000011110001001000000<em class="mb">₂</em> = 123456<em class="mb">₁₀</em><br/>11111111111111100001110110111111<em class="mb">₂</em> = 4294843839<em class="mb">₁₀</em></span><span id="fbbc" class="jz ka in lv b gy nm nj l nk nl">result = 4294843839</span></pre><p id="a218" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated"><em class="mb">*每个整数的基数表示其与十进制(基数</em> <code class="fe ls lt lu lv b"><em class="mb">₁₀</em></code>)或二进制(基数 <code class="fe ls lt lu lv b"><em class="mb">₂</em></code> <em class="mb">)的关系。十位数字，像十进制，或者两位，如二进制:</em> <code class="fe ls lt lu lv b">0</code> <em class="mb">和</em> <code class="fe ls lt lu lv b">1</code> <em class="mb">。</em></p><p id="250d" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated"><em class="mb">*无符号整数<a class="ae kv" href="https://www.ibm.com/support/knowledgecenter/ssw_aix_72/commprogramming/int_dat_typ.html" rel="noopener ugc nofollow" target="_blank"><em class="mb"/></a>* T37是一个32位数据，用于编码介于</em> <code class="fe ls lt lu lv b">0</code> <em class="mb">至</em> <code class="fe ls lt lu lv b">4294967295</code> <em class="mb">之间的非负整数。出于这个挑战的目的，只需考虑我们将使用32位整数，并且只使用正值，而不是负值。</em></p><h2 id="22d0" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">功能描述:</h2><p id="78e5" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh ki li lj lk km ll lm ln kq lo lp lq lr ig bi translated"><code class="fe ls lt lu lv b">flippingBits()</code>函数应该返回一个无符号的十进制整数。</p><p id="2878" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated"><strong class="kz io">输入参数:</strong></p><ul class=""><li id="10b1" class="nn no in kz b la lw le lx ki np km nq kq nr lr ns nt nu nv bi translated"><code class="fe ls lt lu lv b">n</code>:整数</li></ul><p id="9c51" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated"><strong class="kz io">约束:</strong></p><ul class=""><li id="24dd" class="nn no in kz b la lw le lx ki np km nq kq nr lr ns nt nu nv bi translated"><code class="fe ls lt lu lv b">0 ≤ n &lt; 2²³</code></li></ul><h2 id="58aa" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">编程解决方案:</h2><p id="9d53" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh ki li lj lk km ll lm ln kq lo lp lq lr ig bi translated">逻辑非常简单:将一个十进制整数转换成二进制，将它的0和1反相，将反相转换成十进制整数。让我们查看算法，然后解释每个过程。</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="61ad" class="jz ka in lv b gy ni nj l nk nl"><strong class="lv io">function flippingBits(n) {<br/></strong><em class="mb">// declare variables for binary, inverse binary, and decimal result<br/>  </em><strong class="lv io">let lowBin = ''<br/>  let highBin= ''<br/>  let result = 0</strong></span><span id="ca52" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// convert input decimal to binary</em><br/> <strong class="lv io"> while (n &gt;= 1) {<br/>    const rem = n % 2<br/>    lowBin += rem<br/>    rem === 1 ?<br/>      n = Math.floor(n / 2) :<br/>        n /= 2<br/>  }</strong></span><span id="3e99" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// adjust binary to 32 bits<br/>  </em><strong class="lv io">while (lowBin.length &lt; 32) {<br/>    lowBin += 0<br/>  }</strong></span><span id="09e7" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// reverse and invert each bit of binary<br/>  </em><strong class="lv io">for (let i = lowBin.length - 1; i &gt;= 0; i--) {<br/>    highBin += lowBin[i] === '0' ? '1' : '0'<br/>  }</strong></span><span id="1b3a" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// convert binary to decimal output<br/> </em><strong class="lv io"><em class="mb"> </em>for (let i = 0; i &lt; highBin.length; i++) {<br/>    const expo = highBin.length - 1 - i<br/>    result += highBin[i] * (2 ** expo)<br/>  }</strong></span><span id="68b2" class="jz ka in lv b gy nm nj l nk nl"><strong class="lv io">  return result<br/>}</strong></span></pre><ol class=""><li id="022a" class="nn no in kz b la lw le lx ki np km nq kq nr lr nw nt nu nv bi translated"><strong class="kz io">为二进制、逆二进制和十进制结果声明变量:</strong></li></ol><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="edc3" class="jz ka in lv b gy ni nj l nk nl"><strong class="lv io"> let lowBin = ‘’<br/> let highBin= ‘’<br/> let result = 0</strong></span></pre><p id="fdcf" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">二进制整数从左到右表示为<em class="mb">高阶</em>位到<em class="mb">低阶</em>位。变量<code class="fe ls lt lu lv b">lowBin</code>将表示二进制的第一个状态，从低到高，这是因为我们是如何用代数方法转换输入的。变量<code class="fe ls lt lu lv b">highBin</code>将被分配一个与<code class="fe ls lt lu lv b">lowBin</code>相反的副本，因此我们有一个正确的<em class="mb">高阶</em>到<em class="mb">低阶</em>位结构。<code class="fe ls lt lu lv b">lowBin</code>、<code class="fe ls lt lu lv b">highBin</code>均为<code class="fe ls lt lu lv b">string</code>型，使用方便。变量<code class="fe ls lt lu lv b">result</code>将被赋予<code class="fe ls lt lu lv b">highBin</code>所保存的值的十进制转换，并最终用作返回值。<code class="fe ls lt lu lv b">result</code>属于类型号，在<code class="fe ls lt lu lv b">0</code>实例化，因为它将被相加计算。</p><p id="7b24" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">2.<strong class="kz io">将输入的十进制转换为二进制:</strong></p><p id="0ac9" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">首先让我们讨论如何用代数方法来执行这个过程。十进制整数可以通过不断地用整数除以二进制数来转换成二进制数，直到数值达到二进制数，并将余数按位顺序保留。用<code class="fe ls lt lu lv b">2</code>除任何一个数时，余数必须是<code class="fe ls lt lu lv b">0</code>或<code class="fe ls lt lu lv b">1</code>。考虑这个例子:</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="ca49" class="jz ka in lv b gy ni nj l nk nl">Divide 21 by 2 until the result is zero. The remainders of these divisions will be the bits used to construct the binary:</span><span id="3c34" class="jz ka in lv b gy nm nj l nk nl">21 / 2 = 10 (+) rem 1 <em class="mb">low order bit</em><br/>10 / 2 =  5 (+) rem 0<br/> 5 / 2 =  2 (+) rem 1<br/> 2 / 2 =  1 (+) rem 0<br/> 1 / 2 =  0 (+) rem 1 <em class="mb">h</em><em class="mb">igh order bit</em></span><span id="8bd9" class="jz ka in lv b gy nm nj l nk nl">Organize the remainder bits into the binary integer: 10101</span></pre><p id="83dc" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated"><code class="fe ls lt lu lv b">1 / 2 = 0 (+) rem 1</code>有点令人困惑，但是考虑到我们正在处理整数，并且，一旦值减少到<code class="fe ls lt lu lv b">1</code>，它就不能作为一个整数被均匀地划分，同时保持大于<code class="fe ls lt lu lv b">0</code>，所以值本身——<code class="fe ls lt lu lv b">1</code>——成为余数。</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="21e4" class="jz ka in lv b gy ni nj l nk nl"><em class="mb">// perform the last operation when the value 1 is passed in</em><strong class="lv io"><br/>  while (n &gt;= 1) {</strong></span><span id="780e" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// the </em><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder" rel="noopener ugc nofollow" target="_blank"><em class="mb">remainder operator</em></a><em class="mb"> (modulo operator) extracts <br/>// the remainder of n / 2 and assigns the value, the bit, to rem</em><strong class="lv io"><br/>    const rem = n % 2</strong></span><span id="d015" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// rem is appended to the lowBin string<br/>// note the importance of maintaining the binary sequence <br/>// as a string, which would be more difficult numerically<br/>// rem, a number, is coerced to a string and can be concatenated<br/>    </em><strong class="lv io">lowBin += rem</strong></span><span id="0153" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// a conditional operator is used to adjust the value of n<br/>// for the next iteration<br/>// if rem is equal to 1, n is an odd value, so n is assigned<br/>// the value of n / 2 rounded down with Math.floor()<br/>// otherwise, rem must be equal to 0, indicating an even number,<br/>// and n is assigned the value of n / 2<br/>// this always ensures a whole integer is passed into the loop<br/>    </em><strong class="lv io">rem === 1 ?<br/>      n = Math.floor(n / 2) :<br/>        n /= 2<br/>  }</strong></span></pre><p id="c339" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">3.<strong class="kz io">调整二进制为32位:</strong></p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="9138" class="jz ka in lv b gy ni nj l nk nl"><strong class="lv io">  while (lowBin.length &lt; 32) {<br/>    lowBin += 0<br/>  }</strong></span></pre><p id="edad" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">前面构造二进制字符串的while循环只创建转换十进制输入所需的位数。其余的进程需要一个32位的值，所以我们简单地使用一个带有限制条件<code class="fe ls lt lu lv b">32</code>的<code class="fe ls lt lu lv b">while loop</code>集合来将零添加到现有的二进制字符串中。<code class="fe ls lt lu lv b">lowBin += 0</code>起作用是因为<code class="fe ls lt lu lv b">0</code>被强制变成了<code class="fe ls lt lu lv b">string</code>，但你也可以直接使用<code class="fe ls lt lu lv b">lowBin += ‘0’</code>。</p><p id="ed00" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">请注意，由于前面的<code class="fe ls lt lu lv b">while loop</code>执行的操作的线性顺序，二进制字符串在这一点上的顺序是相反的——从<em class="mb">低位</em>到<em class="mb">高位</em>——因此可以通过追加零从右侧填充二进制值，而不是通常的通过预先添加零从左侧填充二进制值的过程。</p><p id="da4f" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">4.<strong class="kz io">反转二进制的每一位:</strong></p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="1864" class="jz ka in lv b gy ni nj l nk nl"><strong class="lv io">  for (let i = lowBin.length - 1; i &gt;= 0; i--) {<br/>    highBin += lowBin[i] === '0' ? '1' : '0'<br/>  }</strong></span></pre><p id="f313" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">我们使用一个递减的<code class="fe ls lt lu lv b">for loop</code>来迭代由<code class="fe ls lt lu lv b">lowBin</code>保存的二进制字符串——从结束到开始——<code class="fe ls lt lu lv b">i = 31 -&gt; i = 0</code>。在每一次迭代中，<code class="fe ls lt lu lv b">highBin</code>被追加当前值的倒数(<code class="fe ls lt lu lv b">lowBin[i]</code>，由条件运算符决定:如果<code class="fe ls lt lu lv b">0</code>，返回<code class="fe ls lt lu lv b">1</code>；如果<code class="fe ls lt lu lv b">1</code>，返回<code class="fe ls lt lu lv b">0</code>。这个过程在反转每个位的同时有效地反转二进制串。</p><p id="b380" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">5.<strong class="kz io">将二进制转换为十进制输出:</strong></p><p id="4ee3" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">再一次，让我们讨论如何用代数方法来执行这个过程。二进制整数可以转换为十进制整数，方法是将每个数字乘以其自身的<code class="fe ls lt lu lv b">2</code>次方，然后将结果求和，<em class="mb">即</em>每个位，一个<code class="fe ls lt lu lv b">0</code>或<code class="fe ls lt lu lv b">1</code>，可以乘以<code class="fe ls lt lu lv b">2</code>的<code class="fe ls lt lu lv b">n</code>次方，然后求和。<code class="fe ls lt lu lv b">2</code>对应于基数<code class="fe ls lt lu lv b">₂</code>，而<code class="fe ls lt lu lv b">n</code>对应于位的位置，就像一个索引。例如:</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="84e9" class="jz ka in lv b gy ni nj l nk nl">Convert 1001₂ to a decimal integer.<br/>__________________________________<br/>|        bit | 1  | 0  | 0  | 1  |<br/>|————————————|————|————|————|————|<br/>| power of 2 | 2³ | 2² | 2¹ | 2⁰ |<br/>——————————————————————————————————<br/>Note that the powers of 2 reflect a zero index, and <em class="mb">descend</em> because<br/>binary integers are sequenced from high order to low order.</span><span id="f2cb" class="jz ka in lv b gy nm nj l nk nl">1001₂ = (1 * 2³) + (0 * 2²) + (0 * 2¹) + (1 * 2⁰) = 9₁₀</span><span id="5a84" class="jz ka in lv b gy nm nj l nk nl">This can be further dissected like this:</span><span id="9a60" class="jz ka in lv b gy nm nj l nk nl">   1 * (2 * 2 * 2) = 8<br/> + 0 * (2 * 2)     = 0<br/> + 0 * (2)         = 0<br/> + 1 * (1)         = 1  (<em class="mb">n⁰ is always equal to 1</em>)<br/>—–––––––––––––––––––––—    <br/>                     9  </span></pre><p id="1f29" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">通过使用<code class="fe ls lt lu lv b">for loop</code>，我们可以方便地访问每一位的值和位置，或者索引。</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="e4b4" class="jz ka in lv b gy ni nj l nk nl"><em class="mb">// instead of setting the limit condition to highBin.length - 1<br/>// we set it to highBin.length (32) so we can accommodate a<br/>// decrementing bit index all the way to 0 for the variable expo<br/>// highBin.length - 1 would end the formula at n * 2¹<br/>// if the last evaluated bit was 0 (0 * 2⁰ = 0), the last addend <br/>// could be ignored, however, this condition is necessary because<br/>// the last bit evaluated could be 1 (1 * 2⁰ = 1), impacting the<br/>// result with a final addend of 1<br/>  </em><strong class="lv io">for (let i = 0; i &lt; highBin.length; i++) {</strong></span><span id="9069" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// expo is assigned a number which represents each bit's position<br/>// on the first iteration this would be: const expo = 32 - 1 - 0 = 31<br/>    </em><strong class="lv io">const expo = highBin.length - 1 - i</strong></span><span id="d8da" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// if the first bit was 0 (highBin[i] = 0), then the first <br/>// addend of the conversion formula would be: 0 * 2³¹<br/>// on each iteration the addend value is summed into result<br/>    </em><strong class="lv io">result += highBin[i] * (2 ** expo)<br/>  }</strong></span></pre><p id="7f96" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">6.<strong class="kz io">返回结果:</strong></p><p id="6ee3" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">最后，但同样重要的是，<code class="fe ls lt lu lv b">result</code>将由函数返回。</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="0c23" class="jz ka in lv b gy ni nj l nk nl">const n = 123456 </span><span id="391c" class="jz ka in lv b gy nm nj l nk nl">flippingBits(n)</span><span id="d557" class="jz ka in lv b gy nm nj l nk nl">// lowBin = 00000010010001111000000000000000<br/>// flip bits and reverse string<br/>// highBin = 11111111111111100001110110111111</span><span id="ecc2" class="jz ka in lv b gy nm nj l nk nl">//=&gt; 4294843839</span></pre><h2 id="c48b" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">优化的编程解决方案:</h2><p id="e1d3" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh ki li lj lk km ll lm ln kq lo lp lq lr ig bi translated">我用优化这个词。我的意思当然是精简的，但是我还没有测试这三种解决方案的性能差异，所以我还不能报告真正的优化。然而，我粗略的评估是，是的，这个解决方案是优化的，即将推出的超紧凑的按位解决方案似乎相当快！</p><p id="773b" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">前面的解决方案看起来需要很多代码来翻转一些位，对吗？碰巧<code class="fe ls lt lu lv b">JavaScript</code>和大多数其他语言都有一些内置的方法和函数可以精简我们的算法。</p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="6c0b" class="jz ka in lv b gy ni nj l nk nl"><strong class="lv io">function flippingBits(n) {</strong><br/><em class="mb">// the </em><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString" rel="noopener ugc nofollow" target="_blank">Number.toString()</a><em class="mb"> method conveniently transforms a number<br/>// into a string AND it can accept a radix argument to convert<br/>// the number to a string of specific base, like base ₂ for binary<br/> </em><strong class="lv io"><em class="mb"> </em>let lowBin = n.toString(2)<br/>  let highBin = ''</strong></span><span id="385e" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// </em>Number.toString()<em class="mb"> produces a binary string representation in<br/>// the correct high order to low order sequence, so zeros are <br/>// padded from the left by prepending them</em><br/>  <strong class="lv io">while (lowBin.length &lt; 32) {<br/>    lowBin = 0 + lowBin<br/>  }</strong></span><span id="13c1" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// since the high order to low order sequence is already correct<br/>// this for loop only needs to flip bits, not reverse the string</em><br/>  <strong class="lv io">for (let i = 0; i &lt; lowBin.length; i++) {<br/>    highBin += lowBin[i] === '0' ? '1' : '0'<br/>  }</strong></span><span id="59c5" class="jz ka in lv b gy nm nj l nk nl"><em class="mb">// the </em>parseInt()<em class="mb"> function conveniently transforms a string to a <br/></em>// number AND it can accept a second argument of a radix to <br/>// convert the string to a number of specific base<em class="mb">, like base ₂<br/>  </em><strong class="lv io">return parseInt(highBin, 2)<br/>}</strong></span></pre><p id="56e3" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">撇开评论不谈，这是一个比前一个更短、更简洁的函数。它利用了内置的能力，需要更少的内存，执行更少的迭代。有没有可能将这种算法压缩成一行性能代码，并获得相同的结果？请击鼓。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e7532aa1e974be1935e16c7ccc67ef9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*tPKIpbk4lDGUrngYSAgykw.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Thank you, jazz messenger!</figcaption></figure><h2 id="ab69" class="jz ka in bd kb kc kd dn ke kf kg dp kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">逐位解决方案:</h2><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="4821" class="jz ka in lv b gy ni nj l nk nl"><strong class="lv io">const flippingBits = n =&gt; ~n &gt;&gt;&gt; 0</strong></span></pre><p id="e0a4" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">你能相信吗？我差点没！<code class="fe ls lt lu lv b">ES6</code>胖箭头函数有一点帮助(没有双关语)，但是函数语句/返回值是如此简洁，令人惊叹。该函数接收一个参数，一个数字<code class="fe ls lt lu lv b">n</code>，并返回逆二进制序列<code class="fe ls lt lu lv b">n</code>的十进制整数表示。但是怎么做呢？</p><ol class=""><li id="baac" class="nn no in kz b la lw le lx ki np km nq kq nr lr nw nt nu nv bi translated"><strong class="kz io">按位非运算符:</strong></li></ol><p id="7bea" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated"><code class="fe ls lt lu lv b">Bitwise NOT</code>操作符被符号化为<code class="fe ls lt lu lv b">~</code>,它反转操作数每个位的二进制值。这意味着在引擎盖下，一个数的二进制表示是颠倒的。每个<code class="fe ls lt lu lv b">0</code>被翻转成一个<code class="fe ls lt lu lv b">1</code>，每个<code class="fe ls lt lu lv b">1</code>被翻转成一个<code class="fe ls lt lu lv b">0</code>。<code class="fe ls lt lu lv b">010100</code>会变成<code class="fe ls lt lu lv b">101011</code>。不过，有一点需要注意。</p><p id="3326" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">产生的值是一个<a class="ae kv" href="https://www.ibm.com/support/knowledgecenter/ssw_aix_72/commprogramming/int_dat_typ.html" rel="noopener ugc nofollow" target="_blank">有符号整数</a>。有符号整数的<em class="mb">高位</em>位、<em class="mb">即</em>最左边的位也称为<a class="ae kv" href="https://en.wikipedia.org/wiki/Sign_bit#:~:text=In%20computer%20science%2C%20the%20sign,significant%20bit%22%20in%20some%20contexts." rel="noopener ugc nofollow" target="_blank">符号位</a>，表示一个数的符号，<em class="mb">即</em>表示该数是正(<code class="fe ls lt lu lv b">0</code>)还是负(<code class="fe ls lt lu lv b">1</code>)。就我们的目的而言，我们的理解是符号位与所有其他位一起反转，将正输入转换为负输出。</p><p id="5803" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">我们的代码挑战要求我们返回一个正的、无符号的32位整数。在使用了<code class="fe ls lt lu lv b">Bitwise NOT</code>操作符之后，我们就没有这些了。不用担心，还有另一个按位运算符可以解决问题。</p><p id="9a3b" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">2.<strong class="kz io">补零右移运算符:</strong></p><p id="3bef" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated"><code class="fe ls lt lu lv b">Zero-fill Right Shift operator</code>被符号化为<code class="fe ls lt lu lv b">&gt;&gt;&gt;</code>，并接受一个指定移动次数的参数。它将高位<em class="mb">位向右移动指定的位数。多余的位被丢弃到右边，而零(<code class="fe ls lt lu lv b">0</code>)位被填充到左边。由于符号位变成零，所以值变成正的。</em></p><p id="eb7a" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">对于这个解决方案，指定的移位数是<code class="fe ls lt lu lv b">0</code>，这实质上创建了这样一种情况:我们的二进制序列用零填充，直到它变成32位序列，并且<code class="fe ls lt lu lv b">Zero-fill Right Shift operator</code>总是返回32位<em class="mb">无符号</em>整数。全垒打。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><p id="9c2e" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">二进制数据和按位操作让人摸不着头脑，可能很少直接使用，但在我们最喜欢的机器的肚子里有一个能力的源泉，可以帮助构建伟大的软件和硬件。我鼓励你深入二进制领域，仔细阅读<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators" rel="noopener ugc nofollow" target="_blank">位操作符</a>，享受零和一的乐趣！</p><p id="6267" class="pw-post-body-paragraph kx ky in kz b la lw lc ld le lx lg lh ki ly lj lk km lz lm ln kq ma lp lq lr ig bi translated">【github.com/dangrammer<br/>T5<a class="ae kv" href="https://github.com/dangrammer" rel="noopener ugc nofollow" target="_blank">linked.com/in/danieljromans</a><br/>T8】danromans.com</p></div></div>    
</body>
</html>