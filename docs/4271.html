<html>
<head>
<title>Developing a Memoization Library With Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用代理开发记忆库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/developing-a-memoization-library-with-proxies-86e025b6bfee?source=collection_archive---------15-----------------------#2020-11-29">https://javascript.plainenglish.io/developing-a-memoization-library-with-proxies-86e025b6bfee?source=collection_archive---------15-----------------------#2020-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e928" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">代理比较和代理记忆</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/868360b91f371a3114c11a01678bad7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eS8OC2Kc6VS4PxBu.jpg"/></div></div></figure><h1 id="af76" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="7d2a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我开始开发<a class="ae mf" href="https://github.com/dai-shi/reactive-react-redux" rel="noopener ugc nofollow" target="_blank">反应-反应-还原</a>和<a class="ae mf" href="https://github.com/dai-shi/react-tracked" rel="noopener ugc nofollow" target="_blank">反应-跟踪</a>已经有一段时间了。这些库提供所谓的<a class="ae mf" href="https://blog.axlight.com/posts/what-is-state-usage-tracking-a-novel-approach-to-intuitive-and-performant-api-with-react-hooks-and-proxy/" rel="noopener ugc nofollow" target="_blank">状态使用跟踪</a>来优化React中的渲染。我认为这种方法非常新颖，我已经花了很多精力来提高它的性能。</p><p id="6f60" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">最近，我想如果它能被更广泛地使用就更好了。我想知道它是否可以用在普通的JS中。vanilla JS中的API是什么？如果通俗易懂就好了。我的想法以记忆化告终，主要是因为主要目标是替代<a class="ae mf" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重选</a>。</p><p id="29ab" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">新库被命名为<code class="fe ml mm mn mo b">proxy-memoize</code>。</p><h1 id="ea89" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">代理记忆</h1><p id="ebb2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">GitHub:<a class="ae mf" href="https://github.com/dai-shi/proxy-memoize" rel="noopener ugc nofollow" target="_blank">https://github.com/dai-shi/proxy-memoize</a></p><p id="2b6d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe ml mm mn mo b">proxy-memoize</code>库提供了一个记忆功能。它将接受一个函数并返回一个记忆函数。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="604d" class="mt ks iq mo b gy mu mv l mw mx">import memoize from 'proxy-memoize';</span><span id="2305" class="mt ks iq mo b gy my mv l mw mx">const fn = (x) =&gt; ({ foo: x.foo });<br/>const memoizedFn = memoize(fn);</span></pre><p id="9c0f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这个图书馆有很多设计选择。要记忆的函数必须是只接受一个对象作为参数的函数。因此，不支持如下功能。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="b4b4" class="mt ks iq mo b gy mu mv l mw mx">const unsupportedFn1 = (number) =&gt; number * 2;</span><span id="45e3" class="mt ks iq mo b gy my mv l mw mx">const unsupportedFn2 = (obj1, obj2) =&gt; [obj1.foo, obj2.foo];</span></pre><p id="69c1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这将允许用<code class="fe ml mm mn mo b">WeakMap</code>缓存结果。我们可以缓存尽可能多的结果，并在它们不再有效时让JS垃圾收集。</p><p id="410b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果我们在<code class="fe ml mm mn mo b">WeakMap</code>缓存中找不到结果，就使用代理。memoized函数调用原始函数，参数对象由代理包装。代理在调用函数时跟踪对象属性的使用。跟踪的信息称为“受影响的”，这是原始对象的部分树结构。为了简单起见，我们在这篇文章中使用点符号。</p><p id="0993" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们看看下面的例子。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="e630" class="mt ks iq mo b gy mu mv l mw mx">const obj = { a: 1, b: { c: 2, d: 3 } };</span><span id="cc86" class="mt ks iq mo b gy my mv l mw mx">// initially affected is empty</span><span id="1b5a" class="mt ks iq mo b gy my mv l mw mx">console.log(obj.a) // touch "a" property</span><span id="3272" class="mt ks iq mo b gy my mv l mw mx">// affected becomes "a"</span><span id="f677" class="mt ks iq mo b gy my mv l mw mx">console.log(obj.b.c) // touch "b.c" property</span><span id="d355" class="mt ks iq mo b gy my mv l mw mx">// affected becomes "a", "b.c"</span></pre><p id="2ca5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">一旦“受影响的”被创建，如果受影响的属性被改变，它可以检查新的对象。只有当任何受影响的属性被更改时，它才会重新调用该函数。这将允许非常精细调谐的记忆。</p><p id="a906" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们看一个例子。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="3726" class="mt ks iq mo b gy mu mv l mw mx">const fn = (obj) =&gt; obj.arr.map((x) =&gt; x.num);<br/>const memoizedFn = memoize(fn);</span><span id="d3bf" class="mt ks iq mo b gy my mv l mw mx">const result1 = memoizedFn({<br/>  arr: [<br/>    { num: 1, text: 'hello' },<br/>    { num: 2, text: 'world' },<br/>  ],<br/>})</span><span id="b937" class="mt ks iq mo b gy my mv l mw mx">// affected is "arr[0].num", "arr[1].num" and "arr.length"</span><span id="7a86" class="mt ks iq mo b gy my mv l mw mx">const result2 = memoizedFn({<br/>  arr: [<br/>    { num: 1, text: 'hello' },<br/>    { num: 2, text: 'proxy' },<br/>  ],<br/>  extraProp: [1, 2, 3],<br/>})</span><span id="4442" class="mt ks iq mo b gy my mv l mw mx">// affected properties are not change, hence:<br/>result1 === result2 // is true</span></pre><p id="b80b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">使用情况跟踪和受影响的比较是由内部库“代理比较”完成的</p><h1 id="d75c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">代理比较</h1><p id="8959" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">GitHub:<a class="ae mf" href="https://github.com/dai-shi/proxy-compare" rel="noopener ugc nofollow" target="_blank">https://github.com/dai-shi/proxy-compare</a></p><p id="927f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是一个从react-tracked中提取的库，只提供与代理的比较特性。(实际上，react-tracked v2将使用这个库作为依赖项。)</p><p id="6def" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">该库导出两个主要函数:<code class="fe ml mm mn mo b">createDeepProxy</code>和<code class="fe ml mm mn mo b">isDeepChanged</code></p><p id="02c6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">它的工作原理如下:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="7fbf" class="mt ks iq mo b gy mu mv l mw mx">const state = { a: 1, b: 2 };<br/>const affected = new WeakMap();<br/>const proxy = createDeepProxy(state, affected);<br/>proxy.a // touch a property<br/>isDeepChanged(state, { a: 1, b: 22 }, affected) // is false<br/>isDeepChanged(state, { a: 11, b: 2 }, affected) // is true</span></pre><p id="a777" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe ml mm mn mo b">state</code>可以是一个嵌套的对象，只有当一个属性被触摸时，才会创建一个新的代理。值得注意的是<code class="fe ml mm mn mo b">affected</code>是从外部提供的，这将有助于将它集成到React钩子中。</p><p id="b4fb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">关于性能改进和处理边缘情况还有其他一些要点。在这篇文章中，我们不做过多的描述。</p><h1 id="e1e9" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">与React上下文一起使用</h1><p id="a57d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">正如在<a class="ae mf" href="https://blog.axlight.com/posts/4-options-to-prevent-extra-rerenders-with-react-context/" rel="noopener ugc nofollow" target="_blank">一篇过去的文章</a>中所讨论的，一种选择是使用useMemo。如果proxy-memoize与useMemo一起使用，我们将能够获得类似react-tracked的好处。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="588b" class="mt ks iq mo b gy mu mv l mw mx">import memoize from 'proxy-memoize';</span><span id="088b" class="mt ks iq mo b gy my mv l mw mx">const MyContext = createContext();</span><span id="3e52" class="mt ks iq mo b gy my mv l mw mx">const Component = () =&gt; {<br/>  const [state, dispatch] = useContext(MyContext);<br/>  const render = useMemo(() =&gt; memoize(({ firstName, lastName }) =&gt; (<br/>    &lt;div&gt;<br/>      First Name: {firstName}<br/>      &lt;input<br/>        value={firstName}<br/>        onChange={(event) =&gt; {<br/>          dispatch({ type: 'setFirstName', firstName: event.target.value });<br/>        }}<br/>      (Last Name: {lastName})<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  )), [dispatch]);<br/>  return render(state);<br/>};</span><span id="247b" class="mt ks iq mo b gy my mv l mw mx">const App = ({ children }) =&gt; (<br/>  &lt;MyContext.Provider value={useReducer(reducer, initialState)}&gt;<br/>    {children}<br/>  &lt;/MyContext.Provider&gt;<br/>);</span></pre><p id="9174" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">当上下文改变时，<code class="fe ml mm mn mo b">Component</code>将重新呈现。然而，它返回记忆化的react元素树，除非<code class="fe ml mm mn mo b">firstName</code>没有改变。所以，重新渲染到此为止。这种行为不同于react-tracked，但应该得到相当的优化。</p><h1 id="fcc8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">与React Redux一起使用</h1><p id="4141" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">它可以是重新选择的简单替换。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="42d1" class="mt ks iq mo b gy mu mv l mw mx">import { useDispatch, useSelector } from 'react-redux';<br/>import memoize from 'proxy-memoize';</span><span id="1a5d" class="mt ks iq mo b gy my mv l mw mx">const Component = ({ id }) =&gt; {<br/>  const dispatch = useDispatch();<br/>  const selector = useMemo(() =&gt; memoize((state) =&gt; ({<br/>    firstName: state.users[id].firstName,<br/>    lastName: state.users[id].lastName,<br/>  })), [id]);<br/>  const { firstName, lastName } = useSelector(selector);<br/>  return (<br/>    &lt;div&gt;<br/>      First Name: {firstName}<br/>      &lt;input<br/>        value={firstName}<br/>        onChange={(event) =&gt; {<br/>          dispatch({ type: 'setFirstName', firstName: event.target.value });<br/>        }}<br/>      /&gt;<br/>      (Last Name: {lastName})<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="1465" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这可能太简单了，无法展示proxy-memoize的强大功能，下面是一个有趣的用例。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="66af" class="mt ks iq mo b gy mu mv l mw mx">memoize((state) =&gt; state.users.map((user) =&gt; user.firstName))</span></pre><p id="6479" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">只有当<code class="fe ml mm mn mo b">users</code>的长度改变或<code class="fe ml mm mn mo b">firstName</code>之一改变时，才会重新评估。即使<code class="fe ml mm mn mo b">lastName</code>被改变，它也一直返回缓存的结果。</p><h1 id="8626" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结束语</h1><p id="e5cd" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">启发我开发这个的是MobX和Immer的关系。我对它们的实现一点都不熟悉，但我感觉Immer是MobX的一个子集，用于更广泛的用例。我想创造像Immer一样的东西。Immer让您神奇地将可变(写)操作转换为不可变对象。proxy-memoize让您能够神奇地为不可变对象创建选择器(读取)函数。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="4d54" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="ng">原载于2020年11月29日https://blog.axlight.com</em><a class="ae mf" href="https://blog.axlight.com/posts/developing-a-memoization-library-with-proxies/" rel="noopener ugc nofollow" target="_blank"><em class="ng"/></a><em class="ng">。</em></p></div></div>    
</body>
</html>