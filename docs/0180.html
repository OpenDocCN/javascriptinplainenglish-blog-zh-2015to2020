<html>
<head>
<title>Inner workings of Map, Reduce &amp; Filter in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中映射、简化和过滤的内部工作方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/inner-workings-of-map-reduce-filter-f06ba87f2509?source=collection_archive---------0-----------------------#2019-07-10">https://javascript.plainenglish.io/inner-workings-of-map-reduce-filter-f06ba87f2509?source=collection_archive---------0-----------------------#2019-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ddeb577d570a747cadc16a69d967ba85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQ74sQU51QRwA_-ZfKLqRQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">figure 1.0 : illustration of map, reduce, filter</figcaption></figure><p id="5359" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我在代码库中使用map、reduce、filter已经有一段时间了，但是阅读Luis Atencio的《Javascript中的函数式编程》一书激发了我学习它的实现的兴趣。让我们更好地理解这些“不变的”(在引号中)宝石，并特别回答<code class="fe kx ky kz la b">why</code>和<code class="fe kx ky kz la b">how</code>问题？</p><p id="b8b9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了更好地理解，让我们创建一个具有一些属性的类，我们可以在博客的其余部分引用这些属性。</p><p id="1767" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">步骤1 :构建我们的示例</p><p id="a2bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">假设XYZ公司根据某些工作要求，聘请了新一批软件工程师。所以<code class="fe kx ky kz la b">Developer</code>类被定义来捕捉那些基本属性，</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h1 id="ed53" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">地图</strong>🎯</h1><p id="4ec7" class="pw-post-body-paragraph jz ka in kb b kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">公司决定给所有新雇佣的开发人员增加奖金。如果我们想对这个进行编码，那么我们可能会遍历所有这些对象，并添加额外的数量。</p><blockquote class="mk ml mm"><p id="b712" class="jz ka mn kb b kc kd ke kf kg kh ki kj mo kl km kn mp kp kq kr mq kt ku kv kw ig bi translated">在我们的前两步中，我们可以重点回答<em class="in">为什么是</em>地图？稍后我们可以研究一下<em class="in">地图是如何工作的？</em></p></blockquote><p id="fbd2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第一步:</strong>命令式方法</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="7ce2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然我们没有改变原始数据，也就是说，开发者，我们必须计算数组的长度，然后在添加奖金数额之前遍历每个元素。但是如果我们决定使用地图，那么这些东西就会从我们身边消失。即计算长度，循环遍历一个数组，将其推送到新的数组。所以我们可以专注于编写所需的逻辑。即增加奖励金额。最重要的是，它会返回一个新的数组。</p><p id="0a06" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第二步:</strong>声明式方法</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="8e14" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第二种方法包括更强调组合的函数式编程，但在这两种情况下，循环、处理临时数组都与我们无关。也没有改动原来的<code class="fe kx ky kz la b">developers</code>阵。简而言之，它就像一个黑匣子。</p><blockquote class="mk ml mm"><p id="781a" class="jz ka mn kb b kc kd ke kf kg kh ki kj mo kl km kn mp kp kq kr mq kt ku kv kw ig bi translated">比如说；使用地图，我们创造了新的比萨饼切片🍕用普通切片上的奶酪配料。作为一名美食家，我可以在任何时候吃普通的原味(左)或带奶酪配料的(右)片<em class="in"/></p></blockquote><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/8df0772029f8892b2497a85752cc5c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2DwbxU3NWT-90Q1bz6HDA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">figure 1.1: map (black box) example</figcaption></figure><p id="a2b2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望这有助于推理为什么是谜题的一部分。接下来，我们将进一步了解地图的内部工作。</p><p id="0c0f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第三步:</strong>地图解剖</p><p id="4192" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们实现我们自己的<code class="fe kx ky kz la b">map</code>来更好地理解，但是首先在实现时我们需要考虑一些事情。(a) map作用于一个数组，(b)它不改变原始数组，而是返回一个新数组，以及(c)将function作为一个参数来作用于任何给定的数组。基于这些<em class="mn">三个</em>支柱，如果我们要实现<code class="fe kx ky kz la b">map</code>，那么它看起来会像下面这样，</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="a56f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是我们经常在一个数组上使用<code class="fe kx ky kz la b">map</code>，就像<code class="fe kx ky kz la b">array.map()</code>一样，但是在我们的例子中，我们将数组作为一个参数传递。嗯嗯…..我们能让我们的地图像ECMAScript地图一样吗？</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="9889" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们继续下一个，减少。</p><h1 id="cf23" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">减少</strong> ⚖</h1><p id="dcb6" class="pw-post-body-paragraph jz ka in kb b kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">如果我们需要找到基于经验的每年平均工资增长，那么必不可少的方法是循环通过每个对象来计算所有开发人员的总经验和总工资，然后用总经验除以工资。</p><p id="cd9f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第一步:</strong>命令式方法</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="3515" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然我们可以在一个循环中完成计算，但我们仍然要担心循环，声明临时变量来计算总数。</p><p id="6630" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">步骤2: </strong>声明式方法</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="24cb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">起初，这看起来有点吓人，但是这种方法更加模块化，并且仍然遵循不变的惯例。(<em class="mn">注:如果你有更好的方法来找出</em> <code class="fe kx ky kz la b"><em class="mn">averageSalPerYear</em></code> <em class="mn">使用reduce请告诉我，乐意学习</em>)</p><p id="cfd4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第三步:</strong>减少解剖</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="c04a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们先从更简单的例子(增加数字)开始，而不是直接解决我们的“每年平均工资增长”问题。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="da11" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">看起来不错，现在让我们利用“myReducer”来实现我们的开发人员阵列的平均工资收益。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="83de" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">很好，但是如果我们想使用<code class="fe kx ky kz la b">myReducer </code>作为原型链，那么实现将更改如下(创建新的减速器作为<code class="fe kx ky kz la b">myNewReducer</code>，以保持所有实现彼此不同)，</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="e21f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对我们最新的原型链<code class="fe kx ky kz la b">myNewReduce</code>方法应用加法和平均工资增长。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="04c1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">很好，现在让我们开始过滤。</p><h1 id="1f09" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">过滤器🔎</h1><p id="01c2" class="pw-post-body-paragraph jz ka in kb b kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">如果我们想知道所有至少有3年经验的开发人员，那么我们可以通过筛选来实现，但首先让我们从命令式方法开始。</p><p id="d2e3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第一步:</strong>命令式的方法</p><p id="609b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过开发人员数组循环查找多年的经验，如果它符合所需的经验，然后我们将它添加到结果数组。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="98ef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第二步:陈述式方法</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="f43a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">快速验证以比较过滤的数据是否与命令式过滤器数组数据相同。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="5eab" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">第三步:</strong>过滤分离</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="e944" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">正如我们之前所做的，我们将把我们的新过滤器定义为数组原型方法，这样我们就可以使用like <code class="fe kx ky kz la b">array.myNewFilter</code></p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="4f5d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">也许，如果我们想同时处理所有这些场景，而不是独立操作。然后这打开了方法<code class="fe kx ky kz la b">chaining</code>的对话。</p><h1 id="1175" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated"><strong class="ak">链接</strong>🔗</h1><p id="7e7b" class="pw-post-body-paragraph jz ka in kb b kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw ig bi translated">在这一节中，我们将研究“增加我们所有开发人员的奖金数额，他们至少有3年的经验，并最终计算这些开发人员的总工资”</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="53e8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">耶，我们完成了🙌</p><p id="7992" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">几乎，如果我们想找出初级或高级开发人员基于一些经验标准，然后我们会做如下使用地图，这将返回新的标题数组。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="cb83" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">很好，这正是我们所期望的。让我们检查一下我们的<code class="fe kx ky kz la b">developersCopy</code>数组。</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="1f01" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你注意到新的属性<code class="fe kx ky kz la b">title</code>已经被添加到每个对象中，但是<code class="fe kx ky kz la b">map</code>假设为<strong class="kb io"> <em class="mn">不可变</em> </strong>🤯。</p><figure class="lb lc ld le gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/45370df42b009c2bd794473f1274d408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0NpmYUagQu3VBTJKH9AKg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">figure 1.2: stack overflow question in 2016</figcaption></figure><blockquote class="mk ml mm"><p id="9212" class="jz ka mn kb b kc kd ke kf kg kh ki kj mo kl km kn mp kp kq kr mq kt ku kv kw ig bi translated">为什么这次对我们没用？因为对象是通过引用 访问的<strong class="kb io"> <em class="in">。所以通过引用改变对象属性会改变对象的原始数组(即不纯的)。</em></strong></p></blockquote><p id="d975" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们在应用贴图之前克隆每个对象，就有可能避免突变。更多细节你可以参考这个medium <a class="ae mt" href="https://medium.com/front-end-weekly/immutability-in-array-of-objects-using-map-method-dd61584c7188" rel="noopener">博客</a>或者栈溢出<a class="ae mt" href="https://stackoverflow.com/questions/34716651/js-array-prototype-map-happens-to-be-mutable#" rel="noopener ugc nofollow" target="_blank">问题</a>。所以函数式编程是一种实现，而不是一个框架。</p><p id="5ddb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，这些宝石非常简洁、有效，但这也伴随着<strong class="kb io"> <em class="mn">高昂的价格</em> </strong>💰当用于大型数据集时。下面是一个这样场景的模拟，</p><figure class="lb lc ld le gt jo"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="2a43" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">快乐编码🦸🏽‍♂️</p><p id="580d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我不明白这种“鼓掌”的事情，但是如果你喜欢这个博客，那么按一下也无妨👏</p></div></div>    
</body>
</html>