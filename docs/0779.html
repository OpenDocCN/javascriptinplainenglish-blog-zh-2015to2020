<html>
<head>
<title>“this” keyword in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的“this”关键字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/this-keyword-in-javascript-87f9feb89b95?source=collection_archive---------3-----------------------#2019-12-09">https://javascript.plainenglish.io/this-keyword-in-javascript-87f9feb89b95?source=collection_archive---------3-----------------------#2019-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="f2e4" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Java Script语言</h2><div class=""/><div class=""><h2 id="117e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">JavaScript中“this”关键字的解释</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/93843e0cf62362d1ca3f79ff42e5bc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bi22nEd7__ikYzEs"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@zacharykeimig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zachary Keimig</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cee4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">“this”关键字是我们每天在JavaScript中使用的。它被广泛应用于项目中的每个地方。但是你有没有把“这个”用在强理解上？你应该知道“这个”的特点，以避免潜在的副作用。在这篇文章中，我将介绍JavaScript中“this”的特性。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="d868" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">阅读前</h1><p id="ab2a" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">如果你不了解JavaScript的执行上下文，我推荐你阅读<a class="ae le" href="https://medium.com/better-programming/execution-context-lexical-environment-and-closure-in-javascript-b57c979341a5" rel="noopener">我之前关于执行上下文和词法环境的</a>来获得它们的基础知识。那么你就更容易理解“这个”关键词了。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="f295" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">“这个”是什么？</h1><p id="3607" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">首先，你要知道“这个”是什么，它在JavaScript中是做什么的。JavaScript中有一个称为“执行上下文”的区域，它是在JavaScript第一次运行代码或调用函数时创建的。如果连续调用5个函数，那么将创建6个执行上下文——全局执行上下文和其他5个函数执行上下文。每个执行上下文包含一个名为<em class="nf"> ThisBinding </em>的值，该值与“this”关键字有关。</p><p id="6ded" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">那是关于什么的？在JavaScript中，“this”是一个特殊的关键字，它允许你在当前范围内直接访问某个对象，不管你当前的函数在哪里。默认情况下，它引用全局对象。在节点中。Js，它将是<code class="fe ng nh ni nj b">global</code>，在浏览器中，它将是<code class="fe ng nh ni nj b">window</code>。</p><p id="50d2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但更重要的是要记住，“this”所指出的东西是由哪个上下文调用包含“this”的函数决定的。我马上会给你们看一些例子。</p><h1 id="344e" class="mi mj iq bd mk ml nk mn mo mp nl mr ms kf nm kg mu ki nn kj mw kl no km my mz bi translated">如何在函数中使用“this”</h1><p id="3276" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">看看如何在JavaScript中使用“this”的简单例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8147" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在函数中调用“this”有两种可能的情况。<code class="fe ng nh ni nj b">obj.foo</code>正在引用<code class="fe ng nh ni nj b">foo</code>的地址。<code class="fe ng nh ni nj b">foo</code>被<code class="fe ng nh ni nj b">obj</code>和<code class="fe ng nh ni nj b">window</code>召唤。即使没有<code class="fe ng nh ni nj b">window</code>。<code class="fe ng nh ni nj b">obj.foo</code>印出2张，<code class="fe ng nh ni nj b">window.foo</code>印出1张。那是因为“这”是由哪个上下文调用函数决定的。</p><p id="d2ef" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当<code class="fe ng nh ni nj b">foo</code>被<code class="fe ng nh ni nj b">obj</code>调用时，<code class="fe ng nh ni nj b">foo</code>执行上下文的<em class="nf"> ThisBinding </em>引用<code class="fe ng nh ni nj b">obj</code>作为其<em class="nf"> thisArg。</em>换句话说，<code class="fe ng nh ni nj b">obj</code>所称的<code class="fe ng nh ni nj b">foo</code>的“这个”就是指<code class="fe ng nh ni nj b">obj</code>。所以当执行<code class="fe ng nh ni nj b">this.x</code>时，“this”在<code class="fe ng nh ni nj b">obj</code>中寻找<code class="fe ng nh ni nj b">x</code>。但是，<code class="fe ng nh ni nj b">foo()</code>等于<code class="fe ng nh ni nj b">window.foo()</code>，所以<code class="fe ng nh ni nj b">window</code>就成了“这个”所指的对象。</p><p id="8b2c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在全局范围内，“这个”就是<code class="fe ng nh ni nj b">window</code>。</p><pre class="kp kq kr ks gt nr nj ns nt aw nu bi"><span id="0a29" class="nv mj iq nj b gy nw nx l ny nz">// In the global execution context (scope)<br/>this === window // true</span></pre><h1 id="1d10" class="mi mj iq bd mk ml nk mn mo mp nl mr ms kf nm kg mu ki nn kj mw kl no km my mz bi translated">“这个”的棘手之处</h1><p id="7453" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">尽管“this”是由调用函数的上下文决定的，但“this”并不总是遵循这个规则。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oa nq l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Image source is from <a class="ae le" href="https://giphy.com/gifs/snl-saturday-night-live-kenan-thompson-5b5OU7aUekfdSAER5I/links" rel="noopener ugc nofollow" target="_blank">GIPHY</a></figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="beca" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个例子中，函数<code class="fe ng nh ni nj b">bar</code>中的<code class="fe ng nh ni nj b">console.log</code>输出2，这是一个全局变量。即使<code class="fe ng nh ni nj b">bar</code>是在<code class="fe ng nh ni nj b">foo</code>内部声明的，并且<code class="fe ng nh ni nj b">bar</code>是在<code class="fe ng nh ni nj b">foo</code>的执行上下文中调用的，听起来<code class="fe ng nh ni nj b">bar</code>也应该打印出1，但是它的“this”指向<code class="fe ng nh ni nj b">window</code>。为什么会这样？</p><p id="f58d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">可悲的是，这是JavaScript在架构层面的一个缺陷。每个内部函数的“this”指出<code class="fe ng nh ni nj b">window</code>——它可能是一个对象的方法，一些函数的回调函数，或者上下文中的一个普通函数。没关系。他们的“这个”总是朝向<code class="fe ng nh ni nj b">window</code>。</p><h1 id="c9d0" class="mi mj iq bd mk ml nk mn mo mp nl mr ms kf nm kg mu ki nn kj mw kl no km my mz bi translated">如何避免这种瑕疵？</h1><p id="8e75" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">幸运的是，有几种方法可以避免这种情况。</p><h2 id="8c99" class="nv mj iq bd mk ob oc dn mo od oe dp ms lo of og mu ls oh oi mw lw oj ok my iw bi translated">函数.原型.绑定</h2><p id="9abc" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated"><code class="fe ng nh ni nj b">bind</code>创建一个新函数，以“this”为参数。无论你传递给<code class="fe ng nh ni nj b">bind</code>函数什么，它都是函数的“this”。它接受任何类型的值。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/007a05d492de568532f87604a8729095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jS9JK904lWMvGVQKUyLTpg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">bind takes any value for thisArg</figcaption></figure><p id="1a99" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，如果将<code class="fe ng nh ni nj b">{x: 10}</code>作为第一个参数传递给<code class="fe ng nh ni nj b">bind</code>，则<code class="fe ng nh ni nj b">bind</code>会将<code class="fe ng nh ni nj b">{x: 10}</code>绑定到原始函数的“this”并返回它。</p><p id="0fd4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">那这个怎么用？</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1ea4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意这部分。</p><pre class="kp kq kr ks gt nr nj ns nt aw nu bi"><span id="b835" class="nv mj iq nj b gy nw nx l ny nz">bar.bind(this)();</span></pre><p id="875b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于<code class="fe ng nh ni nj b">bind</code>将<code class="fe ng nh ni nj b">foo</code>的当前“this”作为其绑定到“this”的参数，所以来自<code class="fe ng nh ni nj b">bar</code>的新函数有“this”指出<code class="fe ng nh ni nj b">foo</code>的“this”。然后你应该再次运行那个函数来执行里面的代码。</p><h2 id="791e" class="nv mj iq bd mk ob oc dn mo od oe dp ms lo of og mu ls oh oi mw lw oj ok my iw bi translated">函数.原型.调用和函数.原型.应用</h2><p id="f86a" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated"><code class="fe ng nh ni nj b">call</code>和<code class="fe ng nh ni nj b">apply</code>与<code class="fe ng nh ni nj b">bind</code>类似，但是它们执行函数，而不是创建并返回一个新函数。两者都考虑“this”将引用的第一个参数<em class="nf"> thisArg </em>。</p><p id="27a1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你需要做的就是写这个。</p><pre class="kp kq kr ks gt nr nj ns nt aw nu bi"><span id="7d5e" class="nv mj iq nj b gy nw nx l ny nz">bar.call(this);<br/>bar.apply(this);</span></pre><p id="6eca" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意不像<code class="fe ng nh ni nj b">bar.bind(this)()</code>，你不用再执行一次。</p><p id="60c1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe ng nh ni nj b">call</code>和<code class="fe ng nh ni nj b">apply</code>彼此也很相似，但也有一点点不同。<code class="fe ng nh ni nj b">apply</code>接受包含所有参数的数组，<code class="fe ng nh ni nj b">call</code>则分别接受每个参数。</p><pre class="kp kq kr ks gt nr nj ns nt aw nu bi"><span id="8c62" class="nv mj iq nj b gy nw nx l ny nz">theFunction.apply(valueForThis, arrayOfArgs)</span><span id="0041" class="nv mj iq nj b gy om nx l ny nz">theFunction.call(valueForThis, arg1, arg2, ...)</span></pre><p id="74fb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个stackoverkflow问题中，有一个很好的评论。</p><blockquote class="on oo op"><p id="df5b" class="lf lg nf lh b li lj ka lk ll lm kd ln oq lp lq lr or lt lu lv os lx ly lz ma ij bi translated">想想申请参数数组中的<code class="fe ng nh ni nj b">a</code>和调用参数列中的<code class="fe ng nh ni nj b">c</code>。</p></blockquote><h2 id="6fe2" class="nv mj iq bd mk ob oc dn mo od oe dp ms lo of og mu ls oh oi mw lw oj ok my iw bi translated">范围链</h2><p id="c93f" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">这可能是避免这个问题的老方法，但这仍然受到许多开发人员的喜爱，因为它非常简单。</p><p id="7c05" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以让任何内部函数获取包含“this”的外部函数中声明的变量，如下例所示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fc58" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这种方式既方便又有用，但是缺点是你应该声明一个新的变量<code class="fe ng nh ni nj b">that</code>并且内部函数应该总是携带它。</p><h2 id="4acc" class="nv mj iq bd mk ob oc dn mo od oe dp ms lo of og mu ls oh oi mw lw oj ok my iw bi translated">箭头功能</h2><p id="8498" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">ECMAScript 2015起，发布了function的新特性。箭头函数也可以避免这个问题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="98c8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">之所以有效，是因为arrow函数的<em class="nf"> ThisBinding </em>指出了其外部执行环境的<em class="nf">词汇环境</em>，换句话说，<code class="fe ng nh ni nj b">bar</code>在调用“this”时使用了<code class="fe ng nh ni nj b">foo</code>的“this”。</p><blockquote class="on oo op"><p id="b930" class="lf lg nf lh b li lj ka lk ll lm kd ln oq lp lq lr or lt lu lv os lx ly lz ma ij bi translated">箭头功能没有自己的<code class="fe ng nh ni nj b">this</code>。使用封闭词法范围的<code class="fe ng nh ni nj b">this</code>值；箭头函数遵循正常的变量查找规则。</p></blockquote><p id="7062" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，在这种情况下，箭头函数不会按照您预期的方式工作。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="73e2" class="mi mj iq bd mk ml nk mn mo mp nl mr ms kf nm kg mu ki nn kj mw kl no km my mz bi translated">构造函数中的“this”</h1><p id="574b" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">在JavaScript中，任何函数都可以用作构造函数。但推荐的约定是第一个字母用大写字母，称为“帕斯卡格”。在构造函数中，“this”关键字的工作方式略有不同。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7bc8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当用关键字<code class="fe ng nh ni nj b">new</code>调用构造函数时，会创建一个新的原型函数对象。在内部，为返回值生成了一个新对象(<code class="fe ng nh ni nj b">{}</code>),“this”被绑定到将被新对象使用的那个对象——在本例中，它是<code class="fe ng nh ni nj b">person</code>。</p><p id="26e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以当<code class="fe ng nh ni nj b">Person</code>被调用时<code class="fe ng nh ni nj b">Person</code>中的<code class="fe ng nh ni nj b">this.name</code>被<code class="fe ng nh ni nj b">John</code>置位。<code class="fe ng nh ni nj b">John</code>被分配给新对象，如下图所示。</p><pre class="kp kq kr ks gt nr nj ns nt aw nu bi"><span id="05c7" class="nv mj iq nj b gy nw nx l ny nz">function Person() {<br/>  var this = {};<br/>  this.name = 'John';<br/>  return this;<br/>}</span></pre><p id="1e82" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">于是第一个控制台打印<code class="fe ng nh ni nj b">John</code>。并且我们在它的原型上增加了一个函数<code class="fe ng nh ni nj b">sayName</code>，而不是函数本身。绑定到原型的函数中的“this”将自动引用JavaScript引擎新创建的对象。但是，请记住，这不会像预期的那样起作用。</p><pre class="kp kq kr ks gt nr nj ns nt aw nu bi"><span id="e7cd" class="nv mj iq nj b gy nw nx l ny nz">var name = 'Jane'; // Global variable</span><span id="2a8c" class="nv mj iq nj b gy om nx l ny nz">...<br/>Person.prototype.sayName = () =&gt; {<br/>  console.log(this.name);<br/>};</span><span id="1f74" class="nv mj iq nj b gy om nx l ny nz">var person = new Person();<br/>person.sayName(); // Jane</span></pre><p id="b742" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为什么会这样？因为一个箭头函数不在乎哪个上下文调用它。此外，它没有自己的“this ”,所以当在箭头函数中调用“this”时，JavaScript开始将“this”作为范围链接来查找。全局上下文中的“这个”是<code class="fe ng nh ni nj b">window</code>，因此，箭头函数<code class="fe ng nh ni nj b">sayName</code>中的<code class="fe ng nh ni nj b">this.name</code>等于<code class="fe ng nh ni nj b">window.name</code>，也就是<code class="fe ng nh ni nj b">Jane</code>。</p><h1 id="9b5b" class="mi mj iq bd mk ml nk mn mo mp nl mr ms kf nm kg mu ki nn kj mw kl no km my mz bi translated">结论</h1><p id="0490" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated">JavaScript中的“this”关键字被许多开发人员广泛使用，实际上使用起来非常方便。但是“this”不是JS hack，所以你应该正确地意识到它的概念。我希望你记住“这”是很容易改变的，取决于你如何使用它。</p><h1 id="934f" class="mi mj iq bd mk ml nk mn mo mp nl mr ms kf nm kg mu ki nn kj mw kl no km my mz bi translated">资源</h1><ul class=""><li id="00c1" class="ot ou iq lh b li na ll nb lo ov ls ow lw ox ma oy oz pa pb bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">MDN中的“this”关键字</a></li><li id="8f43" class="ot ou iq lh b li pc ll pd lo pe ls pf lw pg ma oy oz pa pb bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener ugc nofollow" target="_blank">MDN中的function . prototype . bind</a></li><li id="9a76" class="ot ou iq lh b li pc ll pd lo pe ls pf lw pg ma oy oz pa pb bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener ugc nofollow" target="_blank">MDN中的function . prototype . call</a></li><li id="8e0d" class="ot ou iq lh b li pc ll pd lo pe ls pf lw pg ma oy oz pa pb bi translated"><a class="ae le" href="https://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply" rel="noopener ugc nofollow" target="_blank">stack overflow中的不同调用与应用</a></li><li id="e500" class="ot ou iq lh b li pc ll pd lo pe ls pf lw pg ma oy oz pa pb bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">数组函数ins MDN </a></li></ul></div></div>    
</body>
</html>