<html>
<head>
<title>JavaScript Debugging Tips: Console.trace()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript调试技巧:Console.trace()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/console-trace-javascript-debugging-tips-hungry-turtle-code-e67668244aa4?source=collection_archive---------9-----------------------#2020-11-02">https://javascript.plainenglish.io/console-trace-javascript-debugging-tips-hungry-turtle-code-e67668244aa4?source=collection_archive---------9-----------------------#2020-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4936" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">鲜为人知但功能强大的工具——console . trace()</h2></div><p id="7676" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不久前，我发布了一个关于使用console.table 作为JavaScript调试工具的帖子和视频。我得到了很大的反响，许多人说他们很震惊它并不出名。现在我将继续使用console.trace。</p><p id="b1aa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章是我的<a class="ae ky" href="https://hungryturtlecode.com/tags/javascript/" rel="noopener ugc nofollow" target="_blank">系列</a>的一部分，讲述更多你可以使用的强大工具——查看另一篇关于<a class="ae ky" href="https://hungryturtlecode.com/tutorials/console-log-table/" rel="noopener ugc nofollow" target="_blank">控制台的文章</a></p><p id="4f12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我创建了一个简单的HTML结构，允许我们调用一个<a class="ae ky" href="https://hungryturtlecode.com/tags/javascript/" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>文件。这没什么意思，但我还是会给你看代码。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d67a" class="li lj in le b gy lk ll l lm ln">&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="UTF-8"/&gt;<br/>	&lt;title&gt;Console.Trace&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;Experimenting With console.trace()&lt;/h1&gt;<br/>  <br/>  &lt;script src="script.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e006" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在是有趣的部分…</p><h1 id="725c" class="lo lj in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">JavaScript代码</h1><p id="9b3e" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">这是我开始使用的JavaScript。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="7798" class="li lj in le b gy lk ll l lm ln">function app(){<br/>    function doSomething(){<br/>        var a = 1;<br/>	var b = 2;<br/>	alert( sumFunction(a, b) );<br/>    }<br/>    function sumFunction(a, b){<br/>        return a + b;<br/>    }</span><span id="6caa" class="li lj in le b gy mk ll l lm ln">    doSomething();<br/>}</span><span id="7f09" class="li lj in le b gy mk ll l lm ln">app();</span></pre><p id="617e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这段代码有点做作，在现实世界中不是很有用，但它将很好地服务于我们的目的。重要的部分是有很多函数调用其他函数。这将创建一个称为调用堆栈的东西——一个所有被调用函数的列表，按照它们被调用的顺序排列。</p><p id="d442" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码非常简单。我们有一个在文件底部调用的app函数。app函数包含另外两个函数——do something和sumFunction。</p><p id="3e8d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在app函数的底部调用doSomething函数。doSomething然后声明两个变量，并将它们作为参数传递给sumFunction。</p><p id="c7a6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">sumFunction只是将这两个数字相加并返回结果，然后输出警报。</p><figure class="kz la lb lc gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ml"><img src="../Images/cc49e0ae38a6149bc2a614ee63c68278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uuoVfRJUABrT0bPm.jpg"/></div></div></figure><h1 id="a6d9" class="lo lj in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">Console.trace到底是做什么的？</h1><p id="8b90" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">简单地说，console.trace会将调用console.trace时存在的调用堆栈记录到控制台中。</p><p id="c587" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这为什么有用？</p><p id="2022" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，让我们假设我上面展示的JavaScript是一个巨大代码库的一小部分。有许多文件和许多不同的功能。</p><p id="71f9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经确定代码在某个地方有一个bug，但是我们不确定具体在哪里。我们已经把范围缩小到调用sumFunction之前的某个地方。</p><p id="e1db" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，sumFunction在许多不同的地方、在许多不同的文件中被调用。不可能马上知道是哪个函数调用产生了bug。</p><h1 id="fe77" class="lo lj in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">一些开发者会如何解决这个问题？</h1><p id="f266" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">我见过许多不知道console.trace的开发人员，他们通过在代码中加入大量带有不同消息的console.logs来解决这种困境。然后运行代码，当错误发生时，控制台中最后记录的消息可能是罪魁祸首。</p><p id="56dc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这种方法没有错——它很有效。但是，这确实意味着要进行大量冗余的键入、复制和粘贴工作，以便将所有的控制台日志添加到代码中，然后在完成后再将它们全部删除。更不用说，如果您在代码中忘记了一个，您可能会在生产代码中记录消息——非常混乱！</p><h1 id="90bc" class="lo lj in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">在步骤console.trace中</h1><p id="67e7" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">相反，我们可以在代码中我们想要回溯的地方调用console.trace。因此，在上面的JavaScript中，我们希望从sumFunction进行回溯，所以我们将console.trace放在那里，如下所示:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d09c" class="li lj in le b gy lk ll l lm ln">function sumFunction(a, b){<br/>  console.trace("Our First Trace");<br/><br/>  return a + b;<br/>}</span></pre><p id="af02" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们可以在一个参数中传递它，这个参数只是特定堆栈跟踪的名称。这允许我们拥有多个不同的console.trace实例，我们可以区分它们，因为它们都有唯一的名称。</p><p id="3c41" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在运行这段代码之前，让我们再看一下代码——这次是对console.trace的调用——并考虑一下堆栈跟踪应该是什么样子。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="c202" class="li lj in le b gy lk ll l lm ln">function app(){<br/>    function doSomething(){<br/>        var a = 1;<br/>	var b = 2;<br/><br/>	alert( sumFunction(a, b) );<br/>    }<br/><br/>    function sumFunction(a, b){<br/>        console.trace("Our First Trace");<br/>	return a + b;<br/>    }<br/><br/>    doSomething();<br/>}<br/><br/>app();</span></pre><p id="2608" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，在触发console.trace之前调用的最后一个函数是sumFunction。所以这将是调用堆栈的顶部。</p><p id="d56b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">sumFunction是在哪里调用的？这是在doSomething函数内部，所以这将是调用堆栈上sumFunction下面的下一个调用(记住堆栈从底部开始，任何新的东西都放在顶部。因此最新的项目在顶部，最老的项目在底部)。</p><p id="b72c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">什么叫做doSomething函数？这应该是应用程序的功能。这是堆栈的下一步。</p><p id="3066" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，什么叫app功能？这是在我们的JavaScript文件的开放空间中调用的——这是全局名称空间。所以调用app函数的是全局名称空间。</p><p id="3b96" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以调用栈应该是这样的:sumFunction，doSomething，app，全局命名空间。</p><h1 id="e0ca" class="lo lj in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">console.trace输出什么？</h1><p id="bf66" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">我们仍然在窗口中显示警告框，就像我们以前做的一样，但是有趣的事情发生在控制台中。</p><p id="862c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我们运行代码时控制台的输出。</p><figure class="kz la lb lc gt mm gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/25792b95d2bd1a36c5706ba9beb9fa00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*npVDN51bZqdcPALJ.jpg"/></div></figure><p id="8dd4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了栈底是(匿名函数)而不是全局命名空间，这正是我们所期望的。但是全局名称空间在JavaScript中只是一个未命名的函数，所以这就是为什么它告诉我们它是一个匿名函数。但是我们知道它只是全局名称空间。</p><p id="3a20" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以看到每个调用是从哪个文件发出的，以及它是从文件中的哪一行发出的。</p><figure class="kz la lb lc gt mm gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8b58c146faf5f31cb7849c92a036b2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/0*P_O1JlAy03V7uTmQ.jpg"/></div></figure><p id="3238" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些也是互动链接。我们可以单击doSomething函数调用旁边的文件名和行号，它会将我们带到Chrome Dev Tools中的sources选项卡，并直接转到doSomething函数中调用堆栈上下一个函数的那一行。在我们的例子中，它将把我们带到第6行，在那里sumFunction被调用。</p><figure class="kz la lb lc gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ml"><img src="../Images/1c7420a8df62dbec23d704752d4179d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lJDJ4b09o6K0xz4U.jpg"/></div></div></figure><p id="dcc0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，这就是在调试工作流中使用console.trace所需要知道的全部内容。清理起来非常容易，因为您已经用一个对console.trace的调用代替了JavaScript文件中对console.log的多次调用。</p><h1 id="635f" class="lo lj in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">额外的好处—最佳实践</h1><p id="72db" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">作为一个额外的奖励，我将向您展示在您的本地开发环境中使用带有Chrome开发工具的console.trace的一种很好的忍者方式，这将允许您在代码中永远不会有console.trace调用，并始终保持您的代码库干净。</p><p id="9dbd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们假设代码中不再有console.trace调用JavaScript与上面的第一个代码片段完全一样。</p><p id="f6df" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们在浏览器中运行它。打开Chrome Dev Tools并导航到sources选项卡。</p><p id="4096" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在sources选项卡中，您可以键入代码，就像在编辑器中一样。这里是您键入console.trace调用的地方。像这样:</p><figure class="kz la lb lc gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ml"><img src="../Images/33fae0bb59f1d0466868ac54be83e1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l3XRmE9_-L1lT0kQ.jpg"/></div></div></figure><h1 id="b332" class="lo lj in bd lp lq lr ls lt lu lv lw lx jt ly ju lz jw ma jx mb jz mc ka md me bi translated">断点或手动调用该函数</h1><p id="1641" class="pw-post-body-paragraph kc kd in ke b kf mf jo kh ki mg jr kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">不幸的是，当我们刷新浏览器时，我们感兴趣的代码已经运行了。您可以通过在console.trace上方设置一个断点来避免这种情况，然后再次刷新，或者您可以通过控制台手动触发app函数。</p><p id="eb3e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了给大家看，我会在控制台再次触发app功能。这将再次导致console.trace注销调用堆栈。</p><figure class="kz la lb lc gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ml"><img src="../Images/be2390b13fec0f66a5a8cf090e9d7410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pj2Pw_78VC3Mnx-k.jpg"/></div></div></figure><p id="f79b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，这里的调用堆栈略有不同。这是因为我们从控制台调用了app函数，所以调用堆栈必须进一步回溯才能到达第一个调用，因为控制台在后台添加了一些魔法。但是栈顶还是和以前一样。</p><p id="3865" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以单击链接，浏览调用堆栈中涉及的代码区域，就像以前一样。</p><p id="1120" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这次的好处是，console.trace实际上从未出现在JavaScript文件中，它只出现在dev tools内部的代码中。所以我们不必担心在部署时将它从代码中删除。少了一件需要担心的事情，这总是件好事，对吗？</p><p id="7877" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这次就这么多了。</p><p id="1cde" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我期待着在JavaScript调试技巧系列的下一篇文章中见到您。</p><p id="cb42" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但在那之前，</p><p id="2f4d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">保持饥渴，继续编码，</p><p id="3a27" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">艾德里安(男子名)</p><p id="35c6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你觉得有用，请告诉你的朋友们！</p><figure class="kz la lb lc gt mm"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6c33" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mx">最初发表于</em><a class="ae ky" href="https://hungryturtlecode.com/tutorials/console-trace/" rel="noopener ugc nofollow" target="_blank">T5【https://hungryturtlecode.com】</a><em class="mx">。</em></p></div></div>    
</body>
</html>