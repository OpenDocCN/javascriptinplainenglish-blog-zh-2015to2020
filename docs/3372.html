<html>
<head>
<title>Best Features of ES2017 — String and Object Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2017的最佳功能—字符串和对象方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-features-of-es2017-string-and-object-methods-dbe935558da1?source=collection_archive---------11-----------------------#2020-09-23">https://javascript.plainenglish.io/best-features-of-es2017-string-and-object-methods-dbe935558da1?source=collection_archive---------11-----------------------#2020-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a4ace83821e442a087e260fad3d1cd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mPtLjx5wWXkZIzjY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d49e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2017的最佳特性。</p><h1 id="f5d2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Object.entries()</code></h1><p id="5b42" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.entries()</code>是ES2017中引入的对象静态方法。</p><p id="9476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个对象的键值对数组，每个键值对都在一个数组中。</p><p id="800d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="cf15" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  foo: 1,<br/>  bar: 2<br/>};</span><span id="88e2" class="mq lc iq mc b gy mv ms l mt mu">for (const [key, value] of Object.entries(obj)) {<br/>  console.log(key, value);<br/>}</span></pre><p id="83a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.entries</code>接受一个对象并返回键值对。</p><p id="cd63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过析构键值对数组来遍历键值对。</p><h1 id="e3aa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过<code class="fe lz ma mb mc b">Object.entries()</code>地图</h1><p id="301f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">因为<code class="fe lz ma mb mc b">Object.entries</code>返回一个数组中的键值对数组，并且<code class="fe lz ma mb mc b">Map</code>构造函数接受该数组，所以我们可以用它将一个对象转换成地图。</p><p id="a3db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4e60" class="mq lc iq mc b gy mr ms l mt mu">const map = new Map(Object.entries({<br/>  foo: 1,<br/>  bar: 2,<br/>}));<br/>console.log(JSON.stringify([...map]));</span></pre><p id="cd52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="dacd" class="mq lc iq mc b gy mr ms l mt mu">[["foo",1],["bar",2]]</span></pre><h1 id="24ed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Object.values()</code></h1><p id="7c69" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.values()</code>从对象中返回一个值数组。</p><p id="0b4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也接受一个对象作为它的参数。</p><p id="fd8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5fdc" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  foo: 1,<br/>  bar: 2<br/>};</span><span id="92bf" class="mq lc iq mc b gy mv ms l mt mu">Object.values(obj)</span></pre><p id="32a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到返回的<code class="fe lz ma mb mc b">[1, 2]</code>。</p><h1 id="76f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Object.getOwnPropertyDescriptors()</code></h1><p id="7481" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.getOwnPropertyDescriptors</code>方法让我们获得对象的属性描述符。</p><p id="4fc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只返回非继承属性的描述符。</p><p id="4991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c312" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  [Symbol('foo')]: 100,<br/>  get bar() {<br/>    return 'abc'<br/>  },<br/>};<br/>console.log(Object.getOwnPropertyDescriptors(obj));</span></pre><p id="a049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="b43d" class="mq lc iq mc b gy mr ms l mt mu">{<br/>  bar: {<br/>    configurable: true<br/>    enumerable: true<br/>  },<br/>  Symbol(foo): {<br/>    configurable: true<br/>    enumerable: true<br/>    value: 100<br/>    writable: true<br/>  }<br/>}</span></pre><p id="3321" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">configurable</code>表示我们是否可以更改属性描述符。</p><p id="71e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">enumerable</code>指示属性是否与for-in循环一起列出。</p><p id="45fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">value</code>是属性值。</p><p id="87bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">writable</code>表示属性值是否可以改变。</p><p id="6d34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它将属性复制到一个对象中。</p><p id="da65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们只是复制值，那么我们就会错过所有其他的属性描述符。</p><p id="e22f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以调用<code class="fe lz ma mb mc b">Object.getOwnPropertyDescriptors</code>来获取对象。</p><p id="724a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="93f3" class="mq lc iq mc b gy mr ms l mt mu">const source = {<br/>  foo: 1<br/>};<br/>const target = {};</span><span id="de1c" class="mq lc iq mc b gy mv ms l mt mu">Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));<br/>console.log(Object.getOwnPropertyDescriptor(target, 'foo'));</span></pre><p id="8f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe lz ma mb mc b">source</code>的所有属性描述符复制到<code class="fe lz ma mb mc b">target</code>。</p><p id="4e91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以设置<code class="fe lz ma mb mc b">target.foo</code>的属性描述符来检查是否所有内容都被复制了。</p><h1 id="5f43" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">字符串方法</h1><p id="d42d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">ES2017引入了新的弦乐方法。</p><p id="e6fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新方法包括<code class="fe lz ma mb mc b">padStart</code>和<code class="fe lz ma mb mc b">padEnd</code>方法。</p><p id="77ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">padStart</code>让我们通过在字符串的开头添加一个或多个重复的字符，将字符串填充到给定的名称中。</p><p id="28a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5e80" class="mq lc iq mc b gy mr ms l mt mu">'x'.padStart(5, 'yz')</span></pre><p id="5896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4ca2" class="mq lc iq mc b gy mr ms l mt mu">"yzyzx"</span></pre><p id="c018" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，还有一个<code class="fe lz ma mb mc b">padEnd</code>方法，它将字符串填充到给定的长度，并在字符串的末尾重复一个或多个字符。</p><p id="42a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="57ec" class="mq lc iq mc b gy mr ms l mt mu">'x'.padEnd(5, 'yz')</span></pre><p id="f08b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="caf3" class="mq lc iq mc b gy mr ms l mt mu">"xyzyz"</span></pre><p id="5cab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已退回。</p><p id="7ff2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个方法中，第一个参数是长度，第二个参数是我们要用来填充原始字符串的字符串。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/f083cd85869aab49958ae72b490194df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U3B3AKGktN4neJjs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mvdheuvel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maarten van den Heuvel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="218b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5414" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">ES2017有一些我们可以使用的方便的对象和字符串方法。</p><h2 id="c4c8" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简明英语JavaScript</strong></h2><p id="f174" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>