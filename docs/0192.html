<html>
<head>
<title>Understanding React 16.8 life-cycles, Hooks, Context API, Lazy and Suspense</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解React 16.8生命周期、钩子、上下文API、懒惰和悬念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-react-16-8-life-cycles-hooks-context-api-lazy-and-suspense-d80760f1b8f2?source=collection_archive---------0-----------------------#2019-07-31">https://javascript.plainenglish.io/understanding-react-16-8-life-cycles-hooks-context-api-lazy-and-suspense-d80760f1b8f2?source=collection_archive---------0-----------------------#2019-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6d2787291b64486fe4bf9fe78cd27794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J2t6OrI4Sgm5PpvZ.png"/></div></div></figure><p id="5587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自从React出现以来，前端开发已经有了显著的创新。开发的容易程度显著提高，它使开发人员能够以非常直观的方式对应用程序的行为进行编码。它还带来了<a class="ae kw" href="https://reactjs.org/docs/design-principles.html" rel="noopener ugc nofollow" target="_blank">设计原则</a>，如组合、公共抽象、逃生舱口等。通过函数式编程。但最重要的是，它对用户体验的关注使其成为前端图书馆的领导者。</p><p id="a8e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是同样的原则，如果理解不正确，会导致某些反模式。例如，不是构建可重用的组件(组合)，而是多次构建具有微小差异的组件将会浪费精力和时间，并引入不可预测的性能问题。类似地，没有以适当的方式利用常见的React抽象，比如生命周期，或者没有明智地使用Escape Hatches，都会导致糟糕的用户体验。</p><p id="e013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个库，React并不提倡开发人员采用最佳实践。但是随着它扩散到企业应用程序中，反模式开始影响性能。因此，回应迫在眉睫，这种转变将使React更强大，在编码实践中更有影响力，并将大量新的用例集成到平台中。脸书如何对React的核心无缝和向后兼容进行结构性转变，这本身就是另一个<a class="ae kw" href="https://code.fb.com/web/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/" rel="noopener ugc nofollow" target="_blank">有趣的故事</a>。此外，脸书一直在尝试将<a class="ae kw" href="https://www.youtube.com/watch?v=nLF0n9SACd4" rel="noopener ugc nofollow" target="_blank">异步引入渲染</a>本身，这将使用户体验更好。</p><p id="7e0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">总之，维护好的设计原则和模式、酷的新特性、异步渲染、钩子、上下文管理和对代码库的彻底检查，以实现上述所有东西，这就是React v 16.8及更高版本的原因。</strong></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e2aa" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">生命周期</h1><p id="da42" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">React中的生命周期函数提供了必要的通用抽象功能，以利用React组件从安装到卸载的生命周期。但是对这些的曲解会导致糟糕的用户体验。例如，如果我们需要一个I/O调用来获取组件中显示的数据，我们通常倾向于在组件呈现之前进行。所以我们把I/O调用放在威尔蒙特。但这将导致用户盯着一个空白页面，混淆一些可能是错误的。相反，如果我们调用didMount并在初始渲染中显示一个加载器，用户就知道有事情发生了，他只需要等待。</p><p id="2c0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管逻辑表明在展示任何东西之前你需要数据，但是用户体验是前端开发的重中之重。尽管React直到15版才开始流行，但从16版开始，它要求人们使用更好的生命周期，如getDerivedStateFromProps，而不是componentWillReceiveProps。componentWillMount、componentWillReceiveProps和shouldComponentUpdate被标记为不安全，以后将不再推荐使用。</p><p id="8fdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">图片来源:<a class="ae kw" href="https://medium.com/@baphemot/understanding-react-react-16-3-component-life-cycle-23129bc7a705" rel="noopener">巴托什·什切青斯基的</a>和<a class="ae kw" href="https://hackernoon.com/reactjs-component-lifecycle-methods-a-deep-dive-38275d9d13c0" rel="noopener ugc nofollow" target="_blank">马赫什·哈尔达尔的</a>博客</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/2f3f29b6c602a406af4304acb470fd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fjq3t3yR9OxN-h4hZc1o_g.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">React 15 to 16 — Lifecycles</figcaption></figure><p id="7f7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">componentWillReceiveProps的目的是捕捉任何必要的状态操作和属性的变化。有副作用是不理想的，因为它们在更新周期中抑制了渲染。为了消除这种反模式，将willReceiveProps声明为不安全的，并使用静态getDerivedStateFromProps来操纵更新周期中的状态。因为它是静态的(你不能访问“this”)，组件特定的副作用是不可能的。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="3c82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mq">这里讨论的概念直接引用自React文档。我把我自己的理解添加到他们当中，但是只有在参考了文档的情况下，彻底的理解才是可能的。我建议浏览下面的材料，作为对每个概念是什么以及为什么会这样发展的简要概述。</em></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="d0d8" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">钩住</h1><p id="8c7e" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">钩子是React的新增功能，它让你不用写类就可以使用状态和其他React特性。沿着React组件类创建钩子的动机是—</p><ol class=""><li id="843d" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><strong class="ka ir">在组件之间重用有状态逻辑:</strong>创建模块化组件的一般趋势是将其分解成多个功能组件块，这些功能组件块又被包装在有状态组件中。尽管这是一个很好的实践，但是React DOM树显示了用状态包装的多个组件以一种令人困惑的方式连接在一起。如果我们可以将有状态逻辑本地化到每个功能组件，甚至在逻辑相似的情况下重用它，会怎么样？</li><li id="e694" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><strong class="ka ir">复杂的组件变得难以理解:</strong>随着组件规模和复杂性的增长，副作用也在增长。尤其是嵌入到生命周期中的副作用和有状态逻辑使得组件更加难以理解和扩展。分解组件也越来越难。如果我们可以构建没有生命周期的组件，但仍然使用状态，那会怎么样？</li><li id="9e6a" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><strong class="ka ir">类语法:</strong>类语法很难理解和实现，尤其是因为“this”的用法。在构造函数中绑定事件和回调上下文的必要性似乎是不必要的麻烦。如果使用功能组件，就可以完全消除。</li></ol><p id="9998" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子用一个解决方案解决了上面的问题，虽然不是直截了当的，但是一旦理解了，感觉很容易实现。</p><p id="521e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">挂钩是让您从功能组件“挂钩”React状态和生命周期特性的功能。钩子在类内部不起作用——它们让你在没有类的情况下使用React。(不建议一夜之间重写现有的组件，但是如果你愿意，可以在新的组件中使用钩子。)</p><h2 id="8dfd" class="nf lf iq bd lg ng nh dn lk ni nj dp lo kj nk nl ls kn nm nn lw kr no np ma nq bi translated">内置挂钩:</h2><ol class=""><li id="72f4" class="mr ms iq ka b kb mc kf md kj nr kn ns kr nt kv mw mx my mz bi translated"><a class="ae kw" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">状态挂钩</strong> </a> <strong class="ka ir"> : </strong></li></ol><p id="f791" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本计数器的传统React类实现如下所示:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="ed63" class="nf lf iq nv b gy nz oa l ob oc">class Example extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      count: 0<br/>    };<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;<br/>        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;<br/>          Click me<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="fc7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相同的钩子实现如下所示:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="6d16" class="nf lf iq nv b gy nz oa l ob oc">import React, { useState } from 'react';<br/><br/>function Example() {<br/>  // Declare a new state variable, which we'll call "count"<br/>  const [count, setCount] = useState(0);<br/>const [a, modifyA] = useState(1)</span><span id="c30d" class="nf lf iq nv b gy od oa l ob oc">  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="30e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们能够在功能组件中使用状态。所以我们没有任何“这个”。</p><p id="4a31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> a. </strong> useState钩子只接受一个参数——状态的初始值，在本例中为“0”。</p><p id="e11c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> b. </strong> useState返回状态变量引用和用于更新它的函数，使用数组析构将它们赋给“count”和“setCount”。</p><p id="be65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<a class="ae kw" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">效果挂钩</strong> </a> <strong class="ka ir"> : </strong></p><p id="7b60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个组件中，我们通常需要嵌入副作用，如数据获取、订阅、直接DOM操作等。这些副作用不能成为渲染的一部分，因为抑制渲染是一个糟糕的设计。所以这些曾经是其他生命周期的一部分，比如componentWillMount、componentDidMount、componentWillReceiveProps(非常糟糕的主意！)，componentWillUnmount等。</p><p id="fd20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是钩子，作为功能组件，没有生命周期。但是有一种方法可以使用Effect Hook实现所有的副作用。但是，Effect Hook并没有假设从装载到更新再到卸载的生命周期，而是只假设渲染后渲染的生命周期。这意味着初始渲染和后续渲染会触发相同的效果。</p><p id="4952" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是传统的副作用实现:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="1473" class="nf lf iq nv b gy nz oa l ob oc">class Example extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      count: 0<br/>    };<br/>  }<br/><br/>  componentDidMount() {<br/>    document.title = `You clicked ${this.state.count} times`;<br/>  }<br/><br/>  componentDidUpdate() {<br/>    document.title = `You clicked ${this.state.count} times`;<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;<br/>        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;<br/>          Click me<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="873f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，尽管效果完全相同，但是初始和后续渲染都需要设置文档的标题。现在，看看效果挂钩的实现:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="8008" class="nf lf iq nv b gy nz oa l ob oc">import React, { useState, useEffect } from 'react';<br/><br/>function Example() {<br/>  const [count, setCount] = useState(0);<br/><br/>  // Similar to componentDidMount and componentDidUpdate:<br/>  useEffect(() =&gt; {<br/>    // Update the document title using the browser API<br/>    document.title = `You clicked ${count} times`;<br/>  });<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="4b9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，useEffect钩子接受一个函数作为参数。这个功能叫做效果。它在每次渲染后运行。这是一个没有清理效果的例子。但是，当侦听器在初始渲染后被设置时，必须在卸载它之前将其删除。这是在钩子中通过将它指定为效果函数的返回值来实现的。</p><p id="1d6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是使用生命周期的实现:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="1425" class="nf lf iq nv b gy nz oa l ob oc">componentDidMount() {<br/>    ChatAPI.subscribeToFriendStatus(<br/>      this.props.friend.id,<br/>      this.handleStatusChange<br/>    );<br/>  }<br/><br/>  componentWillUnmount() {<br/>    ChatAPI.unsubscribeFromFriendStatus(<br/>      this.props.friend.id,<br/>      this.handleStatusChange<br/>    );<br/>  }</span></pre><p id="6456" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是它使用效果钩子的实现:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="0631" class="nf lf iq nv b gy nz oa l ob oc">useEffect(() =&gt; {<br/>    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);<br/>    // Specify how to clean up after this effect:<br/>    return function cleanup() {<br/>      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);<br/>    };<br/>  });</span></pre><p id="4cdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如可以观察到的，React为每个渲染创建一个新的效果，为每个渲染分解它，这不是生命周期的情况。这实际上是由设计决定的，其中效果总是被假定为每个渲染都是特定的。如果这是一个性能问题，有一个<a class="ae kw" href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" rel="noopener ugc nofollow" target="_blank">的方法来停止重复</a>每次渲染的效果。</p><p id="147e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了使用内置钩子，React还提供了一种<a class="ae kw" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">构建定制钩子</a>的方法。</p><h1 id="07ad" class="le lf iq bd lg lh oe lj lk ll of ln lo lp og lr ls lt oh lv lw lx oi lz ma mb bi translated">上下文API</h1><p id="bde3" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">当一个孩子被深深地嵌入到DOM树中时，它需要从最顶层的父节点获得的任何道具都需要作为道具不断地传递下去。为了避免这种麻烦，React提供了上下文API。它的功能类似于Redux，它维护一种全局状态，并且<a class="ae kw" href="// Context lets us pass a value deep into the component tree // without explicitly threading it through every component. // Create a context for the current theme (with &quot;light&quot; as the default). const ThemeContext = React.createContext('light');  class App extends React.Component {   render() {     // Use a Provider to pass the current theme to the tree below.     // Any component can read it, no matter how deep it is.     // In this example, we're passing &quot;dark&quot; as the current value.     return (       &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;         &lt;Toolbar /&gt;       &lt;/ThemeContext.Provider&gt;     );   } }  // A component in the middle doesn't have to // pass the theme down explicitly anymore. function Toolbar(props) {   return (     &lt;div&gt;       &lt;ThemedButton /&gt;     &lt;/div&gt;   ); }  class ThemedButton extends React.Component {   // Assign a contextType to read the current theme context.   // React will find the closest theme Provider above and use its value.   // In this example, the current theme is &quot;dark&quot;.   static contextType = ThemeContext;   render() {     return &lt;Button theme={this.context} /&gt;;   } }" rel="noopener ugc nofollow" target="_blank">将道具传递给组件，避免中间组件。</a></p><p id="7c46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有上下文:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="c269" class="nf lf iq nv b gy nz oa l ob oc">class App extends React.Component {<br/>  render() {<br/>    return &lt;Toolbar theme="dark" /&gt;;<br/>  }<br/>}<br/><br/>function Toolbar(props) {<br/>  // The Toolbar component must take an extra "theme" prop<br/>  // and pass it to the ThemedButton. This can become painful<br/>  // if every single button in the app needs to know the theme<br/>  // because it would have to be passed through all components.<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ThemedButton theme={props.theme} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>class ThemedButton extends React.Component {<br/>  render() {<br/>    return &lt;Button theme={this.props.theme} /&gt;;<br/>  }<br/>}</span></pre><p id="3aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">带上下文:</p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="c6b8" class="nf lf iq nv b gy nz oa l ob oc">// Context lets us pass a value deep into the component tree<br/>// without explicitly threading it through every component.<br/>// Create a context for the current theme (with "light" as the default).<br/>const ThemeContext = React.createContext('light');<br/><br/>class App extends React.Component {<br/>  render() {<br/>    // Use a Provider to pass the current theme to the tree below.<br/>    // Any component can read it, no matter how deep it is.<br/>    // In this example, we're passing "dark" as the current value.<br/>    return (<br/>      &lt;ThemeContext.Provider value="dark"&gt;<br/>        &lt;Toolbar /&gt;<br/>      &lt;/ThemeContext.Provider&gt;<br/>    );<br/>  }<br/>}<br/><br/>// A component in the middle doesn't have to<br/>// pass the theme down explicitly anymore.<br/>function Toolbar(props) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;ThemedButton /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>class ThemedButton extends React.Component {<br/>  // Assign a contextType to read the current theme context.<br/>  // React will find the closest theme Provider above and use its value.<br/>  // In this example, the current theme is "dark".<br/>  static contextType = ThemeContext;<br/>  render() {<br/>    return &lt;Button theme={this.context} /&gt;;<br/>  }<br/>}</span></pre><p id="5fe8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管使用起来似乎很简单，但是上下文API应该只在多个嵌套组件需要访问一个公共状态时使用。相反，如果唯一关心的是沿着中间组件多次传递props，<a class="ae kw" href="https://reactjs.org/docs/composition-vs-inheritance.html" rel="noopener ugc nofollow" target="_blank">组件组合</a>是更好的选择。</p><ol class=""><li id="0ea7" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><strong class="ka ir"> React.createContext </strong>函数创建上下文对象。它接受上下文的初始值作为参数。返回值将被赋给变量，此后称为上下文。“ThemeContext”是上例中的上下文，“light”是默认值。必要时，使用“Provider”属性在嵌套组件中覆盖该值。在上面的示例中，它被更改为“暗”。当没有匹配的提供程序时，组件采用默认的上下文值。</li><li id="0fe9" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><strong class="ka ir">上下文。提供者</strong>允许消费组件订阅上下文变化。它充当上下文变化的发布者。这种变化可以被多个消费者感知。它接受新的上下文值作为属性。在上面的例子中，每当App component运行时，主题都被提供者设置为“黑暗”。任何消费者都会听到这个消息，并触发重新呈现(不受shouldComponentUpdate的影响)。另请参见<a class="ae kw" href="https://reactjs.org/docs/context.html#classcontexttype" rel="noopener ugc nofollow" target="_blank"> Class.contextType </a>了解上下文如何绑定到特定的类。</li><li id="ad67" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><strong class="ka ir">语境。消费者</strong>允许组件订阅上下文值的变化。它需要一个函数作为子函数，该子函数接受最新的值作为参数。</li></ol><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="daf4" class="nf lf iq nv b gy nz oa l ob oc">&lt;MyContext.Consumer&gt;<br/>  {value =&gt; /* render something based on the context value */}<br/>&lt;/MyContext.Consumer&gt;</span></pre><h1 id="2bfd" class="le lf iq bd lg lh oe lj lk ll of ln lo lp og lr ls lt oh lv lw lx oi lz ma mb bi translated">懒惰和悬念</h1><p id="998a" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">惰性特性的行为类似于惰性加载的概念。但是，我们可以简单地依靠React本身在加载组件时加载特定的代码束，而不是依赖webpack来完成这项工作。这也可以应用于路由级别。</p><p id="5491" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">暂停特性有助于在代码包延迟下载的情况下退回到替代组件。例如，我们可以展示一个装载机。</p><p id="ceeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://reactjs.org/docs/code-splitting.html#route-based-code-splitting" rel="noopener ugc nofollow" target="_blank">举例</a> <em class="mq"> : </em></p><pre class="mi mj mk ml gt nu nv nw nx aw ny bi"><span id="0dc3" class="nf lf iq nv b gy nz oa l ob oc">import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';<br/>import React, { Suspense, lazy } from 'react';<br/><br/>const Home = lazy(() =&gt; import('./routes/Home'));<br/>const About = lazy(() =&gt; import('./routes/About'));<br/><br/>const App = () =&gt; (<br/>  &lt;Router&gt;<br/>    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;<br/>      &lt;Switch&gt;<br/>        &lt;Route exact path="/" component={Home}/&gt;<br/>        &lt;Route path="/about" component={About}/&gt;<br/>      &lt;/Switch&gt;<br/>    &lt;/Suspense<br/>  &lt;/Router&gt;<br/>);</span></pre><p id="2ede" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，只有在点击根路径时才加载Home组件。类似地，仅当点击about path时，才会加载About组件。当加载需要时间时，“正在加载…”文本显示为后备。</p><p id="5e85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">采用这种技术可以使初始加载速度极快，从而增强用户体验。虽然延迟加载每个组件看起来会有不必要的性能问题，但是下载和加载小组件应该只需要很短的时间。此外，这些下载是并行进行的，这是一个更大的优势。因此，总之，延迟加载每个组件可能是一种反模式，开发人员应该明智地选择在初始下载期间保留不必要的代码，并根据需要延迟加载它们，而不会牺牲用户体验。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="2aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React 16中有许多令人兴奋的功能，如门户、转发参考、备忘录、片段等。请仔细阅读React文档，以深入了解每个文档以及上面讨论的概念。</p></div></div>    
</body>
</html>