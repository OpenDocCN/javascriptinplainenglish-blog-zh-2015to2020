<html>
<head>
<title>How parsing and code execution work in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中解析和代码执行的工作方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-parsing-and-code-execution-f92a08498ec1?source=collection_archive---------2-----------------------#2019-09-30">https://javascript.plainenglish.io/javascript-parsing-and-code-execution-f92a08498ec1?source=collection_archive---------2-----------------------#2019-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d9d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript总是被托管在一些环境中执行，这些环境最初是从浏览器开始的，然后是使用Node.js的服务器端脚本，还有一些接受JavaScript代码作为输入的应用程序。这里我们将重点讨论浏览器。不同的浏览器有不同的JavaScript引擎来解析和执行我们的代码。</p><blockquote class="ki kj kk"><p id="57a3" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io"> JavaScript引擎</strong>是一个执行JavaScript (JS)代码的计算机程序。第一个JavaScript引擎仅仅是解释器，但是所有相关的现代引擎都利用即时编译来提高性能</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/570158b0b923f6433ed4a3c8d9dca2d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqeMVD0WmDcwkTjZQQFAkw.jpeg"/></div></div></figure><p id="aeb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript引擎中发生的第一件事是通过解析器解析我们的代码。一个<strong class="jm io">解析器</strong>基本上一行一行地读取我们的代码，检查它是否有错误，如果有，就停止执行，如果代码没有语法错误，解析器产生一个叫做抽象语法树的数据结构，然后被翻译成机器码，从而输出结果。</p><blockquote class="ki kj kk"><p id="7c65" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">抽象语法树</strong> ( <strong class="jm io"> AST </strong>)，或简称<strong class="jm io">语法树</strong>，是用编程语言编写的源代码的抽象语法结构的树形表示。树的每个节点表示源代码中出现的一个构造— <a class="ae lb" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="cf15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了理解JavaScript代码执行，我们需要仔细阅读并理解两个重要的概念:执行上下文和执行堆栈。</p><p id="2846" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">执行上下文:<br/> </strong>我们的代码运行的环境被称为执行上下文，定义为以下<br/> 1。全局—首次执行代码的默认环境。<br/> 2。局部/函数—函数中的代码何时执行。<br/> 3。Eval —当执行Eval中的文本时。</p><pre class="kq kr ks kt gt lc ld le lf aw lg bi"><span id="89e3" class="lh li in ld b gy lj lk l ll lm"><em class="kl">// Global context</em></span><span id="aded" class="lh li in ld b gy ln lk l ll lm"><em class="kl">var</em> person = 'john';</span><span id="2c74" class="lh li in ld b gy ln lk l ll lm"><em class="kl">const</em> func1 = <em class="kl">function</em>() {</span><span id="effd" class="lh li in ld b gy ln lk l ll lm"><em class="kl">// execution context.</em></span><span id="7160" class="lh li in ld b gy ln lk l ll lm"><em class="kl">let</em> address = 'New York';</span><span id="b8f8" class="lh li in ld b gy ln lk l ll lm">func2();</span><span id="31b1" class="lh li in ld b gy ln lk l ll lm">console.log(`${person} ${address}`);</span><span id="ab6a" class="lh li in ld b gy ln lk l ll lm">}</span><span id="f357" class="lh li in ld b gy ln lk l ll lm"><em class="kl">const</em> func2 = <em class="kl">function</em>() {</span><span id="09f3" class="lh li in ld b gy ln lk l ll lm"><em class="kl">// execution context.</em></span><span id="8cc1" class="lh li in ld b gy ln lk l ll lm"><em class="kl">let</em> designation = 'Software Developer';</span><span id="d977" class="lh li in ld b gy ln lk l ll lm"><em class="kl">let</em> address = 'Melbourne'</span><span id="cdd4" class="lh li in ld b gy ln lk l ll lm">console.log(`${person} ${designation} ${address}`);</span><span id="f91f" class="lh li in ld b gy ln lk l ll lm">}</span><span id="01d0" class="lh li in ld b gy ln lk l ll lm">func1();<br/>console.log(window.person === person)</span><span id="f904" class="lh li in ld b gy ln lk l ll lm">Output:<br/> john Software Developer Melbourne<br/> john New York<br/> true</span></pre><p id="dbef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们理解上面的例子，变量person是在全局上下文中定义的，全局上下文用于执行不属于任何函数的代码。每当调用一个函数时，就会创建一个新的执行上下文，并将其推到当前上下文之上，从而创建所谓的执行堆栈。</p><p id="308f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>这里我们看到window.person ===person给出的结果为true，但是如果我们做window.func1()，这将会给出TypeError。下面是关于这种行为的简介。</p><blockquote class="ki kj kk"><p id="beea" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><a class="ae lb" href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-global-environment-records" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">全局环境记录</strong> </a>实际上由两条环境记录组成:<br/>一条声明性环境记录和一条对象环境记录。<br/>对象环境以全局对象window为后盾，包含var声明和浏览器提供的其他全局。声明性环境包含let、const、class等声明。— <br/> <a class="ae lb" href="https://stackoverflow.com/questions/55030498/why-dont-const-and-let-statements-get-defined-on-the-window-object" rel="noopener ugc nofollow" target="_blank">学分堆栈溢出</a>。</p></blockquote><p id="73a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">执行堆栈:</strong> <br/>我们所知的JavaScript在单线程上运行其操作，这意味着一次只能发生一个动作，其余的被推到一个称为执行堆栈的堆栈上，该堆栈遵循堆栈<strong class="jm io"> LIFO的原则。<br/> </strong>简而言之，我们可以说执行堆栈的重要方面是其同步行为的本质，以及一个全局上下文和许多功能/局部上下文。</p><p id="1868" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">执行上下文阶段:<br/> </strong>执行上下文分为创建和执行两个阶段。<br/>创建阶段:在运行任何代码之前调用函数时定义该阶段。在创建阶段，首先是创建变量对象，然后是作用域链，最后是确定和设置“<strong class="jm io">this”</strong>，它们共同构成执行上下文对象的属性。<br/>按照流程中的以下步骤创建变量对象</p><ol class=""><li id="2dc0" class="lo lp in jm b jn jo jr js jv lq jz lr kd ls kh lt lu lv lw bi translated">添加包含函数调用中传递的所有对象的参数对象。</li><li id="278f" class="lo lp in jm b jn lx jr ly jv lz jz ma kd mb kh lt lu lv lw bi translated">对于每个函数，在变量对象中创建一个属性，指向该函数，即在代码开始执行之前，所有函数都将存储在对象中。</li><li id="5092" class="lo lp in jm b jn lx jr ly jv lz jz ma kd mb kh lt lu lv lw bi translated">查找变量声明，并在变量对象中为每个变量设置一个属性，并设置为未定义。</li></ol><p id="b66c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后两点一般称为吊装。函数和变量被提升，这意味着它们在执行阶段开始之前就可用，但是有一个小问题，两者的提升方式不同，变量只在执行阶段定义，而函数已经定义了。让我们看一个例子，也有点惊讶。</p><pre class="kq kr ks kt gt lc ld le lf aw lg bi"><span id="b720" class="lh li in ld b gy lj lk l ll lm"><em class="kl">// with var/ ES5</em></span><span id="8cdf" class="lh li in ld b gy ln lk l ll lm"><em class="kl">function</em> func1() {<br/>  console.log('Args:', typeof<em class="kl"> arguments</em>);</span><span id="a109" class="lh li in ld b gy ln lk l ll lm">  console.log('typeof func2:', typeof func2);</span><span id="c6f9" class="lh li in ld b gy ln lk l ll lm">  console.log('typeof variable:', typeof person);</span><span id="6a26" class="lh li in ld b gy ln lk l ll lm">  console.log('Args:',<em class="kl"> arguments</em>);</span><span id="f422" class="lh li in ld b gy ln lk l ll lm">  console.log('variable:', person);</span><span id="ca24" class="lh li in ld b gy ln lk l ll lm">  console.log('function assignment:', getName);</span><span id="2f37" class="lh li in ld b gy ln lk l ll lm">  <em class="kl">var</em> person = 'Paul';<br/>  <em class="kl">var</em> getName = _getName();</span><span id="52ef" class="lh li in ld b gy ln lk l ll lm">  <em class="kl">function</em> func2() {<br/>    console.log('USA');<br/>  }</span><span id="b3f8" class="lh li in ld b gy ln lk l ll lm">  func2();<br/>}</span><span id="70ae" class="lh li in ld b gy ln lk l ll lm"><em class="kl">function</em> _getName() {<br/>  <em class="kl">return</em> 'Steve';<br/>}</span><span id="0883" class="lh li in ld b gy ln lk l ll lm">func1('George', 1982, 'USA');</span><span id="68e1" class="lh li in ld b gy ln lk l ll lm">Output: <br/>  Args: object<br/>  typeof func2: function<br/>  typeof variable: undefined<br/>  Args: [Arguments] { '0': 'George', '1': 1982, '2': 'USA' }<br/>  variable: undefined<br/>  function assignment: undefined<br/>  USA</span><span id="02d5" class="lh li in ld b gy ln lk l ll lm">// With let/const ES6</span><span id="8199" class="lh li in ld b gy ln lk l ll lm"><em class="kl">function</em> func1(...args) {<br/>  console.log('Args:', typeof<em class="kl"> </em>args);</span><span id="93eb" class="lh li in ld b gy ln lk l ll lm">  console.log('typeof func2:', typeof func2);</span><span id="66cb" class="lh li in ld b gy ln lk l ll lm">  console.log('typeof variable:', typeof person);</span><span id="f198" class="lh li in ld b gy ln lk l ll lm">  console.log('Args:',<em class="kl"> </em>args);</span><span id="6362" class="lh li in ld b gy ln lk l ll lm">  console.log('variable:', person);</span><span id="e641" class="lh li in ld b gy ln lk l ll lm">  console.log('function assignment:', getName);</span><span id="edea" class="lh li in ld b gy ln lk l ll lm">  <em class="kl">let</em> person = 'Paul';<br/>  <em class="kl">const</em> getName = _getName();</span><span id="d225" class="lh li in ld b gy ln lk l ll lm">  <em class="kl">function</em> func2() {<br/>    console.log('USA');<br/>  }</span><span id="550c" class="lh li in ld b gy ln lk l ll lm">  func2();<br/>}</span><span id="1a61" class="lh li in ld b gy ln lk l ll lm"><em class="kl">function</em> _getName() {<br/>  <em class="kl">return</em> 'Steve';<br/>}</span><span id="e018" class="lh li in ld b gy ln lk l ll lm">func1('George', 1982, 'USA');</span><span id="f592" class="lh li in ld b gy ln lk l ll lm">Output: <br/>  Args: object<br/>  typeof func2: function<br/>  ReferenceError: Cannot access 'person' before initialization</span></pre><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mc md l"/></div></figure><blockquote class="ki kj kk"><p id="4a03" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">这个错误的答案在ECMAScript规范中。<br/> <code class="fe me mf mg ld b"><strong class="jm io">let</strong></code>和<code class="fe me mf mg ld b"><strong class="jm io">const</strong></code>声明定义了作用于<a class="ae lb" href="https://www.ecma-international.org/ecma-262/9.0/index.html#running-execution-context" rel="noopener ugc nofollow" target="_blank">运行执行上下文</a>的词汇环境的变量。变量在包含它们的<a class="ae lb" href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-lexical-environments" rel="noopener ugc nofollow" target="_blank">词法环境</a>被实例化时被创建，但是在变量的<a class="ae lb" href="https://www.ecma-international.org/ecma-262/9.0/index.html#prod-LexicalBinding" rel="noopener ugc nofollow" target="_blank">词法绑定</a>被求值之前不能以任何方式被访问— <a class="ae lb" href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-let-and-const-declarations" rel="noopener ugc nofollow" target="_blank"> ECMAScript </a></p></blockquote><p id="0f44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单地说，词汇上声明的变量保持<strong class="jm io">未初始化</strong>。这意味着当您尝试访问ReferenceError时，会引发该异常。只有当let/const语句被求值时，它才会被初始化，之前(上面)的一切都被称为时间死区。</p><p id="53e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你觉得这篇文章很有帮助并且喜欢它，请随意与你的朋友和同事分享。</p><p id="1a5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你有任何问题、建议或想要联系我吗？在LinkedIN<a class="ae lb" href="https://www.linkedin.com/in/muneer-zargar-fe-dev/" rel="noopener ugc nofollow" target="_blank">上给我留言或者在下面评论。</a></p><p id="5a1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我也可以在推特上通过@zargarmuneer90找到我。</p><p id="4e07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我在写这篇文章时参考的一些好的资源。</p><div class="mh mi gp gr mj mk"><a href="https://astexplorer.net/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">AST浏览器</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">在线AST浏览器。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">astexplorer.net</p></div></div></div></a></div><div class="mh mi gp gr mj mk"><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd io gy z fp mp fr fs mq fu fw im bi translated">JavaScript中的执行上下文&amp;栈是什么？</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">JavaScript中的执行上下文&amp;栈是什么？-在这篇文章中，我将深入探讨一个最…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">davidshariff.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my kz mk"/></div></div></a></div></div></div>    
</body>
</html>