<html>
<head>
<title>Improve Observability of NodeJS HTTP request-response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高NodeJS HTTP请求-响应的可观察性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improve-observability-of-nodejs-http-request-response-a12f8629ccd0?source=collection_archive---------2-----------------------#2019-08-10">https://javascript.plainenglish.io/improve-observability-of-nodejs-http-request-response-a12f8629ccd0?source=collection_archive---------2-----------------------#2019-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d3f0b13022a7789daa6986c1fa9c898d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tK4vzsjr1g35avXl90iZOA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thkelley?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Thomas Kelley</a> on <a class="ae kc" href="https://unsplash.com/search/photos/watch-tower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7a2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NodeJS是IO密集型的，http请求构成了应用程序生命周期的主要部分。为了监视和观察NodeJS应用程序，理解它对其他系统的请求行为是微服务体系结构不可或缺的一部分。受下面这条推文的启发，我们决定分享如何在NodeJS应用程序的HTTP请求-响应生命周期的上下文中提高可观察性。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><h2 id="5ded" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">NodeJS HTTP请求-响应阶段</h2><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/5dd9e75694ae355627da2ed0af990d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNIkp6phimsfffnVCToW7g.png"/></div></div></figure><p id="aa50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在NodeJS中，HTTP请求和响应都是<a class="ae kc" href="https://nodejs.org/api/stream.html" rel="noopener ugc nofollow" target="_blank"> NodeJS流</a>，它们实现<a class="ae kc" href="https://nodejs.org/api/events.html#events_class_eventemitter" rel="noopener ugc nofollow" target="_blank"> EventEmitter </a>接口，为特定的生命周期事件发出事件。我们可以向这些事件添加事件监听器，以便测量请求和响应的重要指标。NodeJS为上述HTTP生命周期阶段发出的事件有</p><ul class=""><li id="ed85" class="mb mc iq kf b kg kh kk kl ko md ks me kw mf la mg mh mi mj bi translated"><a class="ae kc" href="https://nodejs.org/api/http.html#http_event_socket" rel="noopener ugc nofollow" target="_blank">插座</a></li><li id="d3a6" class="mb mc iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://nodejs.org/api/net.html#net_event_lookup" rel="noopener ugc nofollow" target="_blank"> DNS查找</a></li><li id="b776" class="mb mc iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://nodejs.org/api/net.html#net_event_connect" rel="noopener ugc nofollow" target="_blank"> TCP连接</a></li><li id="a7c7" class="mb mc iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated">HTTPS连接的TLS连接(<code class="fe mp mq mr ms b">secureConnect</code>套接字上的事件)</li><li id="909f" class="mb mc iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://nodejs.org/api/stream.html#stream_event_data" rel="noopener ugc nofollow" target="_blank">响应体启动</a></li><li id="3631" class="mb mc iq kf b kg mk kk ml ko mm ks mn kw mo la mg mh mi mj bi translated"><a class="ae kc" href="https://nodejs.org/api/stream.html#stream_event_end" rel="noopener ugc nofollow" target="_blank">响应体结束</a></li></ul><p id="a280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mp mq mr ms b">request</code>始于<a class="ae kc" href="https://nodejs.org/api/net.html#net_class_net_socket" rel="noopener ugc nofollow" target="_blank">网的创建。套接字</a>对象，一旦套接字被创建，它就发出<code class="fe mp mq mr ms b">socket</code>事件。现在，这个套接字可以用来监听DNS查找、TCP和TLS事件。我们将使用标记高分辨率时间戳的<code class="fe mp mq mr ms b"><a class="ae kc" href="https://nodejs.org/api/process.html#process_process_hrtime_time" rel="noopener ugc nofollow" target="_blank">process.hrtime()</a></code>来标记事件，并找到从请求开始到每个时间戳的持续时间。</p><pre class="lb lc ld le gt mt ms mu mv aw mw bi"><span id="1cda" class="lh li iq ms b gy mx my l mz na">const request = https.request(options, callback)<br/>const startTime = process.hrtime();<br/>let dnsLookup, tcpConnection, tlsHandshake, responseBodyStart, responseBodyEnd;</span><span id="8e19" class="lh li iq ms b gy nb my l mz na">request.on("socket", socket =&gt; {<br/>    // Socket created for dnslookup<br/>    socket.on("lookup", () =&gt; {<br/>        dnsLookup = process.hrtime();<br/>    });</span><span id="e2d5" class="lh li iq ms b gy nb my l mz na">    // TCP Connection established<br/>    socket.on("connect", () =&gt; {<br/>        tcpConnection = process.hrtime();<br/>    });</span><span id="163e" class="lh li iq ms b gy nb my l mz na">    // TLS Handshake complete<br/>    socket.on("secureConnect", () =&gt; {<br/>        tlsHandshake = process.hrtime();<br/>    });<br/>});</span></pre><p id="490c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦请求完成，服务器将开始发送响应。这些响应字节可以在<a class="ae kc" href="https://nodejs.org/api/http.html#http_class_http_serverresponse" rel="noopener ugc nofollow" target="_blank"> http上监听。回应</a>对象</p><pre class="lb lc ld le gt mt ms mu mv aw mw bi"><span id="2972" class="lh li iq ms b gy mx my l mz na">https.request(requestOptions, res =&gt; {<br/>    // The first time response bytes are transferred<br/>    res.once("data", () =&gt; {<br/>        responseBodyStart = process.hrtime();<br/>    });<br/>    res.on("data", chunk =&gt; (response += chunk));<br/>    res.on("end", () =&gt; {<br/>        responseBodyEnd = process.hrtime();<br/>        callback(null, {<br/>            body: response,<br/>            duration: getEventDuration()<br/>        });<br/>    });<br/>});</span></pre><p id="7d68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以找到标记有时间戳的每个事件的持续时间，从而找到生命周期中重要部分的持续时间。</p><pre class="lb lc ld le gt mt ms mu mv aw mw bi"><span id="331a" class="lh li iq ms b gy mx my l mz na">DNS lookup = dnsLookup - startTime<br/>TCP connection = tcpConnection - (dnsLookup || startTime)<br/>TLS connection = tlsHandshake - tcpConnection<br/>First byte = responseBodyStart - tlsHandshake<br/>Content transfer = responseBodyEnd - responseBodyStart<br/>Total = responseBodyEnd - startTime</span></pre><p id="8da5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些信息现在可以添加到<em class="nc">监控</em>和<em class="nc">分布式跟踪</em>中，以帮助提高系统的<em class="nc">可观察性</em>。</p><p id="acb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个实现以npm包<code class="fe mp mq mr ms b"><a class="ae kc" href="https://www.npmjs.com/package/http-duration-client" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">http-duration-client</strong></a></code> <strong class="kf ir"> </strong>的形式发布，全部代码可从<a class="ae kc" href="https://github.com/congruencelabs/http-duration-client" rel="noopener ugc nofollow" target="_blank">github/http-duration-client</a>获得</p></div></div>    
</body>
</html>