<html>
<head>
<title>The Biggest Change in React 17 That No One Is Talking About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 17中没有人谈论的最大变化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-biggest-change-in-react-17-that-no-one-is-talking-about-b62905beb2d2?source=collection_archive---------9-----------------------#2020-12-21">https://javascript.plainenglish.io/the-biggest-change-in-react-17-that-no-one-is-talking-about-b62905beb2d2?source=collection_archive---------9-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2f4e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">尽管React 17“没有新功能”，但如果你是功能组件的粉丝，实际上有一个相当大的变化。<strong class="ak">谁不是呢？😁</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/51a8fc669a4ffd8ab0cd6f91bbe17c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxa4xgun9V2LvwU1uVDzBw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7ce9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢函数组件和反应钩子。我第一篇关于Medium <a class="ae kv" href="https://blog.usejournal.com/2019-guide-how-to-use-react-hooks-to-create-a-toggle-switch-or-counter-dd9f5cd7062a?gi=bb38dbf9a29c" rel="noopener ugc nofollow" target="_blank">的文章用的是</a> <code class="fe ls lt lu lv b"><a class="ae kv" href="https://blog.usejournal.com/2019-guide-how-to-use-react-hooks-to-create-a-toggle-switch-or-counter-dd9f5cd7062a?gi=bb38dbf9a29c" rel="noopener ugc nofollow" target="_blank">useState</a></code> <a class="ae kv" href="https://blog.usejournal.com/2019-guide-how-to-use-react-hooks-to-create-a-toggle-switch-or-counter-dd9f5cd7062a?gi=bb38dbf9a29c" rel="noopener ugc nofollow" target="_blank">钩子</a>，我还是觉得<code class="fe ls lt lu lv b">useState</code>很棒。</p><p id="4d2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我甚至不介意用我的大脑去缠绕<code class="fe ls lt lu lv b"><a class="ae kv" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>来装载数据。(当然，我们现在有了第三版的React查询<a class="ae kv" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank">作为数据获取的<code class="fe ls lt lu lv b">useEffect</code>的绝佳替代。)</a></p><p id="b208" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然有理由让你在2021年继续编写<a class="ae kv" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">类组件</a>和使用<a class="ae kv" href="https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class" rel="noopener ugc nofollow" target="_blank">生命周期方法</a>，但我不打算这么做。</p><p id="efc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我全身心投入到<a class="ae kv" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">函数组件</a>和<a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>中，当我发现React 17中的一个重大变化将影响我编写的每个新组件时，我感到很惊讶。</p><p id="cb7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能也错过了变化，因为React 17的标题是，我引用一下:“<strong class="ky ir">没有新功能</strong>”</p><blockquote class="lw lx ly"><p id="b174" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">“React 17版本不同寻常，因为它没有添加任何面向开发者的新功能。相反，这个版本主要集中在<strong class="ky ir">上，使得升级React本身</strong>更加容易。— <a class="ae kv" href="https://reactjs.org/blog/2020/10/20/react-v17.html" rel="noopener ugc nofollow" target="_blank"> React 17公告</a>由<a class="md me ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----b62905beb2d2--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>和<a class="md me ep" href="https://medium.com/u/231a32f99c21?source=post_page-----b62905beb2d2--------------------------------" rel="noopener" target="_blank">雷切尔·纳伯斯</a>发布</p></blockquote><p id="5b7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我甚至不是一个经常阅读发行说明的人。我更喜欢编写新的教程，以便与不断变化的几十种技术保持“同步”。写作让我专注于问题和用例，而不是被选择的悖论所淹没。</p><p id="098e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我很高兴我阅读了这些发行说明，因为这种变化与React如何在幕后工作的核心特性有关:由<code class="fe ls lt lu lv b">import React from "react"</code>语句产生的JSX变换。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="0857" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">什么是JSX变换？</h1><p id="53c7" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">当您编写<a class="ae kv" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX代码</a>(由React组件的<code class="fe ls lt lu lv b"><a class="ae kv" href="https://reactjs.org/docs/react-component.html#render" rel="noopener ugc nofollow" target="_blank">render()</a></code> <a class="ae kv" href="https://reactjs.org/docs/react-component.html#render" rel="noopener ugc nofollow" target="_blank">函数</a>返回的类似HTML的东西)时，React会将代码翻译成函数调用。</p><p id="0b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具体来说，React将JSX转换成对<code class="fe ls lt lu lv b"><a class="ae kv" href="https://reactjs.org/docs/react-without-jsx.html" rel="noopener ugc nofollow" target="_blank">React.createElement()</a></code>的函数调用。现在，在React 17中，JSX变换已经更改为<code class="fe ls lt lu lv b"><a class="ae kv" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-different-in-the-new-transform" rel="noopener ugc nofollow" target="_blank">jsx()</a></code>，而底层概念保持不变。</p><p id="1538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您实际上不需要改变任何东西来使用新的转换，但是当您从现在开始编写组件时，您可以选择做一些不同的事情。</p><p id="bc08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于函数组件，您可以通过不导入<code class="fe ls lt lu lv b">"React"</code>在每个组件中节省一行代码。</p><p id="8425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React 17之前，你必须在每个组件中提供对<code class="fe ls lt lu lv b">React.createElement()</code>的访问，但是现在你不需要了。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="3fe1" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">React 17有什么新行为？</h1><p id="ef8d" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">你可以在函数组件中完全删除<code class="fe ls lt lu lv b">import</code>语句，但在类组件中不能。</p><blockquote class="lw lx ly"><p id="b0f4" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">“[在React 17之前，] JSX被编译成<code class="fe ls lt lu lv b">React.createElement</code>，【所以】<code class="fe ls lt lu lv b">React</code>需要在范围内如果你用JSX的话。[…]</p><p id="5a8c" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">【现在我们的代码】<strong class="ky ir">不再需要导入React </strong>来使用JSX了！(但是我们仍然需要导入React，以便使用React提供的钩子或其他导出。)”— <a class="ae kv" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-different-in-the-new-transform" rel="noopener ugc nofollow" target="_blank"> React博客</a>作者<a class="ae kv" href="https://twitter.com/lunaruan" rel="noopener ugc nofollow" target="_blank">卢娜阮</a></p></blockquote><p id="1452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个类组件仍然需要<code class="fe ls lt lu lv b">import { Component } from "react"</code>，但是一个功能组件可能不需要导入任何东西。</p><p id="5664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，如果你正在使用React钩子，你仍然会导入它们:<code class="fe ls lt lu lv b">import { useState, useEffect } from "react"</code>。</p><p id="350c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经厌倦了整天在VS代码中输入<code class="fe ls lt lu lv b">imr</code> ( <a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=xabikos.ReactSnippets" rel="noopener ugc nofollow" target="_blank">代表<code class="fe ls lt lu lv b">import React from "react"</code>的反应片段</a>)，那么欢呼吧！</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="d4ae" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">等等，还有其他好处吗？</h1><p id="524f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">在这一点上，你可能会认为我如此兴奋以至于可以从我的React代码中删除一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">import</a></code>语句是很可笑的。</p><p id="ad7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，这难道不令人兴奋吗？毕竟，你每次都必须在每个单独的React组件中使用<code class="fe ls lt lu lv b">import React from "react"</code>。</p><p id="4b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是React 17中新JSX变换的其他优势:</p><blockquote class="lw lx ly"><p id="dd61" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">“升级到新的转换是完全可选的，但它有几个好处:</p><p id="6a2f" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">有了新的变换，你可以<strong class="ky ir">使用JSX而不用导入React </strong>。</p><p id="1bfc" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">根据您的设置，它的编译输出可能会<strong class="ky ir">稍微提高包的大小</strong>。</p><p id="fb9d" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">T21减少了你需要学习的概念数量，这将有助于未来的改进。”——<a class="ae kv" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform" rel="noopener ugc nofollow" target="_blank">React博客</a></p></blockquote><p id="9785" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名JavaScript教师，我期待着使用JSX，而不要引入React和那些模糊的未来改进。</p><p id="5760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，即使您对这两种方式一点也不关心，甚至到了像以前一样继续导入React的程度，您至少可以为“稍微改进的包大小”而感到兴奋！</p><p id="51d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">真是<strong class="ky ir"> <em class="lz">略有改进</em> </strong>！加油！！！怎样才能让你兴奋起来？！？新功能？？？我说，他们被高估了。😂</p><blockquote class="lw lx ly"><p id="a0cd" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">“我们已经<strong class="ky ir">推迟了其他的变化</strong>直到React 17之后。此版本的目标是实现逐步升级。如果升级到React 17太难，那就达不到它的目的。”— <a class="ae kv" href="https://reactjs.org/blog/2020/10/20/react-v17.html" rel="noopener ugc nofollow" target="_blank"> React 17公告</a>由<a class="md me ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----b62905beb2d2--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>和<a class="md me ep" href="https://medium.com/u/231a32f99c21?source=post_page-----b62905beb2d2--------------------------------" rel="noopener" target="_blank">雷切尔·纳伯斯</a></p></blockquote></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="b9d4" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">潜在的突破性变化</h1><p id="821a" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">不过，说真的，React 17的另一个重大变化实际上相当不错:更好的事件委托。</p><blockquote class="lw lx ly"><p id="1258" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">“在React 17中，React将不再在引擎盖下的<code class="fe ls lt lu lv b">document</code>级别附加事件处理程序。相反，它会将它们附加到根DOM容器中，React树就呈现在这个容器中[…]</p><p id="11f5" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">在React 16和更早的版本中，React会为大多数事件做<code class="fe ls lt lu lv b">document.addEventListener()</code>。反应过来的17号将改叫<code class="fe ls lt lu lv b">rootNode.addEventListener()</code>引擎盖下。“— <a class="ae kv" href="https://reactjs.org/blog/2020/10/20/react-v17.html" rel="noopener ugc nofollow" target="_blank"> React 17公告</a>由<a class="md me ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----b62905beb2d2--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>和<a class="md me ep" href="https://medium.com/u/231a32f99c21?source=post_page-----b62905beb2d2--------------------------------" rel="noopener" target="_blank">雷切尔·纳伯斯</a></p></blockquote><p id="b1fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的要点是让React 17中的事件传播更接近常规DOM。这是一个非常好的改变，因为它潜在地允许您在同一个页面上运行多个版本的React (&gt;React 17)，同时在需要时进行增量升级。</p><p id="601e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，丹和雷切尔反对渐进式改革。最好还是一次为你的应用升级React版本。</p><p id="255e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html#other-breaking-changes" rel="noopener ugc nofollow" target="_blank">React 17的其他突破性变化</a>如下:</p><ul class=""><li id="98bc" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><strong class="ky ir">与浏览器</strong>保持一致——它们通过防止<code class="fe ls lt lu lv b">onScroll</code>冒泡和<a class="ae kv" href="https://blog.saeloun.com/2021/05/14/react-17-uses-browse-focusin-focusout-for-onfocus-onblur" rel="noopener ugc nofollow" target="_blank">创建本机</a> <code class="fe ls lt lu lv b"><a class="ae kv" href="https://blog.saeloun.com/2021/05/14/react-17-uses-browse-focusin-focusout-for-onfocus-onblur" rel="noopener ugc nofollow" target="_blank">focusin</a></code> <a class="ae kv" href="https://blog.saeloun.com/2021/05/14/react-17-uses-browse-focusin-focusout-for-onfocus-onblur" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe ls lt lu lv b"><a class="ae kv" href="https://blog.saeloun.com/2021/05/14/react-17-uses-browse-focusin-focusout-for-onfocus-onblur" rel="noopener ugc nofollow" target="_blank">focusout</a></code> <a class="ae kv" href="https://blog.saeloun.com/2021/05/14/react-17-uses-browse-focusin-focusout-for-onfocus-onblur" rel="noopener ugc nofollow" target="_blank">事件</a>来与浏览器的工作方式保持一致。</li><li id="32f4" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><a class="ae kv" href="https://blog.saeloun.com/2021/07/08/react-17-event-delagation" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">无事件池</strong> </a> —他们移除了处理事件时常见的崩溃，就像在这个<code class="fe ls lt lu lv b">handleChange</code>函数中:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/410edad94a1129a0f304ef1ce59b3600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZ2GjS-AARf_k_PAWhGpgQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling</a></figcaption></figure><p id="b506" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我亲眼目睹了这一事故，一直在挠头，所以我很高兴它被修复了。🙏</p><ul class=""><li id="d6e7" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><strong class="ky ir">效果清理定时</strong>——你从<code class="fe ls lt lu lv b">useEffect</code>返回的函数(如果有的话)就是它的清理函数。因为大多数效果不需要延迟屏幕更新，所以效果清理总是异步运行——在屏幕更新之后。这是现在普遍的行为。相比之下，<code class="fe ls lt lu lv b">useLayoutEffect</code>钩子是阻止屏幕更新的同步替代物。(<a class="md me ep" href="https://medium.com/u/db72389e89d8?source=post_page-----b62905beb2d2--------------------------------" rel="noopener" target="_blank">肯特·c·多兹</a>最近在他的博客上写了两者的区别<a class="ae kv" href="https://kentcdodds.com/blog/useeffect-vs-uselayouteffect/" rel="noopener ugc nofollow" target="_blank">。)</a></li><li id="ed49" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><strong class="ky ir">返回未定义</strong>的一致错误——从渲染函数返回<code class="fe ls lt lu lv b"><a class="ae kv" href="https://medium.com/coding-at-dawn/how-to-check-for-undefined-in-javascript-bcedd62c8ad" rel="noopener">undefined</a></code>是一个错误。("<code class="fe ls lt lu lv b">Nothing was returned from render.</code>")在React 17之前有时这不是错误，但现在它总是错误。</li><li id="0da0" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><strong class="ky ir">原生组件栈</strong> —组件栈现在从原生JavaScript栈生成，产生了一个新特性:<strong class="ky ir">组件栈现在是可点击的</strong>。换句话说，您可以使用本机浏览器堆栈框架像检查常规JavaScript错误一样检查组件。这是您一直想要的React的<a class="ae kv" href="https://en.wikipedia.org/wiki/Minification_(programming)#Source_mapping" rel="noopener ugc nofollow" target="_blank">源图，帮助您更好地调试组件。</a></li><li id="ea4d" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><strong class="ky ir">移除私有导出</strong>—React原生Web项目中暴露的一些React内部构件已经被移除，对零个项目没有影响。</li></ul><p id="aa90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html#removing-private-exports" rel="noopener ugc nofollow" target="_blank">发行说明</a>以一个提示结尾，提醒您可以使用<a class="ae kv" href="https://testing-library.com/docs/dom-testing-library/api-events" rel="noopener ugc nofollow" target="_blank"> React测试库</a>来触发原生浏览器事件。<code class="fe ls lt lu lv b"><strong class="ky ir">I 💘 Testing</strong></code></p><p id="9f13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">快乐编码！</strong> <strong class="ky ir"> ⚛ </strong>👓💻💯🔥</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="5565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">德里克·奥斯汀博士是《职业规划:如何在6个月内成为成功的6位数程序员 一书的作者，该书现已在亚马逊上架。</p></div></div>    
</body>
</html>