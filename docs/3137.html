<html>
<head>
<title>Building a shopping cart in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中构建购物车</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-shopping-cart-in-node-js-bdbe02614eb9?source=collection_archive---------1-----------------------#2020-09-02">https://javascript.plainenglish.io/building-a-shopping-cart-in-node-js-bdbe02614eb9?source=collection_archive---------1-----------------------#2020-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd96f9b9d801ccdee68b193533502c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*dEpQXWPcg20uLVb4Pb5dxg.jpeg"/></div></div></figure><p id="45fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将建立一个电子商务平台，Node.js作为后端和前端，我们将有3种不同的技术(Angular，React和Vue.js)。我刚刚用Vue Vite完成了<a class="ae kw" href="https://www.wrappixel.com/build-a-shopping-cart-in-nodejs-and-vue-vite/" rel="noopener ugc nofollow" target="_blank">前端部分，你可以阅读</a>。Angular和React将很快推出。</p><p id="8c2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将这篇文章分成两部分，后端和前端。我们的应用程序将有像添加产品和添加产品到购物车的基本功能。</p><p id="9dde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">先决条件</strong></p><ul class=""><li id="ce09" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">熟悉HTML、CSS和JavaScript (ES6+)。</li><li id="eed5" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">Vs代码或安装在开发机器上的任何代码编辑器。</li><li id="0c43" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">Postman安装在您的开发机器上。</li><li id="94cd" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">React和Express.js的基础知识。</li></ul><p id="5dda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将从设置应用程序的后端开始。让我们为应用程序创建一个新目录，并初始化一个新的Node.js应用程序。打开您的终端，键入以下内容:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="193d" class="lu lv iq lq b gy lw lx l ly lz">cd desktop<br/>mkdir reactcart &amp;&amp; cd reactcart<br/>npm init -y<br/>code .</span></pre><h1 id="2145" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">安装必要的软件包</h1><p id="70bd" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">我们必须为我们的应用程序安装一些包:</p><ul class=""><li id="04e3" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><code class="fe nc nd ne lq b">body-parser</code>:是一个express中间件，它读取表单的输入，并将其存储为一个javascript对象，可通过req.body访问。</li><li id="63a6" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nc nd ne lq b">nodemon</code>:将监视我们的文件是否有任何更改，然后在发生任何更改时重启服务器。</li><li id="3a92" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nc nd ne lq b">express</code>将用于构建我们的Node.js服务器。</li><li id="7691" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nc nd ne lq b">cors</code>:这是一种机制，它使用额外的HTTP报头来告诉浏览器，让运行在一个来源的web应用程序访问来自不同来源的选定资源。</li><li id="aba7" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nc nd ne lq b">dotenv</code>:将存储我们所有的环境变量。这是我们存储电子邮件变量的地方。</li><li id="dedd" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">是一个将记录我们所有申请路线的包。</li><li id="da1c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nc nd ne lq b">mongoose</code>:用于异步查询MongoDB的对象建模工具。</li><li id="ee1a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nc nd ne lq b">multer</code>:是处理<code class="fe nc nd ne lq b">multipart/form-data</code>的Node.js中间件，主要用于上传文件。</li></ul><p id="15d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装此软件包，请打开您的终端并键入:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="e723" class="lu lv iq lq b gy lw lx l ly lz">npm i express mongoose morgan dotenv multer body-parser cors nodemon --save</span></pre><p id="2e28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行该命令将创建一个<code class="fe nc nd ne lq b">node_modules</code>文件夹。您必须创建一个<code class="fe nc nd ne lq b">.gitignore</code>文件并在其中添加<code class="fe nc nd ne lq b">node_modules</code>文件。</p><h1 id="61f4" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">设置服务器</h1><p id="35ae" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">我们将继续创建一个<code class="fe nc nd ne lq b">src/index.js</code>文件，并添加以下代码行:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="4a6c" class="lu lv iq lq b gy lw lx l ly lz">const express = require('express');<br/>const cors = require('cors');<br/>const bodyParser = require('body-parser');<br/>const morgan = require('morgan');<br/>const app = express();<br/>app.use(morgan('dev'));<br/>app.use(cors());<br/>app.use(bodyParser.json())<br/>app.get('/', (req, res) =&gt; {<br/>    res.json({<br/>        message: 'Arise MERN developers'<br/>    });<br/>});<br/>const port = process.env.PORT || 4000;<br/>app.listen(port, () =&gt; {<br/>    console.log(`Application is running on ${port}`);<br/>});</span></pre><p id="8475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加之后，我们可以通过在终端中键入<code class="fe nc nd ne lq b">nodemon src</code>来使用nodemon运行我们的应用程序。运行此命令将输出<code class="fe nc nd ne lq b">Application is running on 4000</code>。</p><p id="2bce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的服务器正在运行，我们必须设置我们的mongoDB服务器。为此，创建一个新目录<code class="fe nc nd ne lq b">src/config</code>并创建一个<code class="fe nc nd ne lq b">mongoose.js</code>文件，然后添加以下代码:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="afe6" class="lu lv iq lq b gy lw lx l ly lz">const mongoose = require("mongoose");<br/>module.exports = app =&gt; {<br/>    mongoose.connect('mongodb://localhost:27017/cart', {<br/>        useUnifiedTopology: true,<br/>        useNewUrlParser: true,<br/>        useFindAndModify: false<br/>    }).then(res =&gt; console.log("connected")).catch(err =&gt; console.log(err))<br/>    mongoose.Promise = global.Promise;<br/>    process.on("SIGINT", cleanup);<br/>    process.on("SIGTERM", cleanup);<br/>    process.on("SIGHUP", cleanup);<br/>    if (app) {<br/>        app.set("mongoose", mongoose);<br/>    }<br/>};<br/>function cleanup() {<br/>    mongoose.connection.close(function () {<br/>        process.exit(0);<br/>    });<br/>}</span></pre><p id="6f50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要在我们的<code class="fe nc nd ne lq b">index.js</code>文件中注册这个配置:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="061c" class="lu lv iq lq b gy lw lx l ly lz">require("./config/mongoose.js")(app);</span></pre><p id="40fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加它将在Node.js服务器运行时连接到数据库。</p><p id="7fa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，您必须在声明express的实例之后声明这一点。</p><p id="3a32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在必须为我们的产品和购物车创建我们的mongoDB模型和路线。</p><p id="766e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个<code class="fe nc nd ne lq b">src/app</code>目录，这是我们创建模块的地方。在此目录中，创建一个产品目录并添加以下文件:</p><ul class=""><li id="f87c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">model.js</li><li id="9c33" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">controller.js</li><li id="06db" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">知识库. js</li><li id="9f66" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">route.js</li></ul><p id="2b49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将所有DB通信放入存储库文件也是一个好主意。</p><p id="5c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过将它添加到我们的<strong class="ka ir"> model.js </strong>文件来定义我们的产品模型:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9aad" class="lu lv iq lq b gy lw lx l ly lz">const mongoose = require("mongoose");<br/>const productSchema = mongoose.Schema({<br/>  name: {<br/>    type: String,<br/>    required: [true, "Please include the product name"],<br/>  },<br/>  price: {<br/>    type: String,<br/>    required: [true, "Please include the product price"],<br/>  },<br/> image: {<br/>    type: String,<br/>    required: true,<br/>  },<br/>});<br/>const Product = mongoose.model("Product", productSchema);<br/>module.exports = Product;</span></pre><p id="fbce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的产品模型将尽可能基本，因为它包含产品名称、价格和图像。</p><p id="c6d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在需要在我们的<strong class="ka ir"> repository.js </strong>文件中定义我们的DB请求:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="2f2f" class="lu lv iq lq b gy lw lx l ly lz">const Product = require("./model");<br/>exports.products = async () =&gt; {<br/>    const products = await Product.find();<br/>    return products;<br/>};<br/>exports.productById = async id =&gt; {<br/>    const product = await Product.findById(id);<br/>    return product;<br/>}<br/>exports.createProduct = async payload =&gt; {<br/>    const newProduct = await Product.create(payload);<br/>    return newProduct<br/>}<br/>exports.removeProduct = async id =&gt; {<br/>    const product = await Product.findByIdAndRemove(id);<br/>    return product<br/>}</span></pre><p id="2ff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要定义获取所有产品、获取单个产品的详细信息、删除产品和创建产品的基本路线。逻辑是路由将与我们的控制器对话，控制器与存储库对话，存储库与我们的模型对话。</p><p id="509e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们定义我们的路线之前，我们需要为我们的图片上传配置multer。创建一个<strong class="ka ir"> multer.js </strong>文件并添加以下代码:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="5039" class="lu lv iq lq b gy lw lx l ly lz">const multer = require("multer");<br/>const path = require("path");<br/>//image upload<br/>const storage = multer.diskStorage({<br/>    destination: (req, res, cb) =&gt; {<br/>         cb(null, path.join("./files/"));<br/>    },<br/>    filename: (req, file, cb) =&gt; {<br/>        cb(null, new Date().toISOString() + file.originalname);<br/>    }<br/>});<br/>// checking file type<br/>const fileFilter = (req, file, cb) =&gt; {<br/>    if (file.mimetype.startsWith('image')) {<br/>        cb(null, true);<br/>    } else {<br/>        cb(new Error('Not an image! Please upload an image.', 400), false);<br/>    }<br/>};<br/>exports.upload = multer({<br/>    storage: storage,<br/>    limits: {<br/>        fileSize: 1024 * 1024 * 6<br/>    },<br/>    fileFilter: fileFilter<br/>});</span></pre><p id="4dd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用程序的根目录下创建一个<code class="fe nc nd ne lq b">files</code>目录。这是所有上传图像的存储位置。</p><p id="3b5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于所有图像都放在文件目录中，我们必须创建一个<code class="fe nc nd ne lq b">files</code>文件夹。要做到这一点，请转到<strong class="ka ir"> index.js </strong>文件并添加以下内容:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="f275" class="lu lv iq lq b gy lw lx l ly lz">app.use('/files', express.static("files"));</span></pre><p id="c3da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，我们现在可以提供存储在文件目录中的图像。</p><p id="246b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将此添加到<strong class="ka ir"> routes.js </strong>文件中:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="f18e" class="lu lv iq lq b gy lw lx l ly lz">const router = require("express").Router();<br/>const productController = require("./controller");<br/>const multerInstance = require('../../config/multer')<br/>router.post("/", multerInstance.upload.single('image'), productController.createProduct);<br/>router.get("/", productController.getProducts);<br/>router.get("/:id", productController.getProductById);<br/>router.delete("/:id", productController.removeProduct);<br/>module.exports = router;</span></pre><p id="0294" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在必须为这条路线定义方法。为此，创建添加到<strong class="ka ir">控制器. js </strong>文件:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="b1d3" class="lu lv iq lq b gy lw lx l ly lz">const productRepository = require('./repository')<br/>exports.createProduct = async (req, res) =&gt; {<br/>    try {<br/>        let payload = {<br/>            name: req.body.name,<br/>            price: req.body.price,<br/>            image: req.file.path<br/>        }<br/>        let product = await productRepository.createProduct({<br/>            ...payload<br/>        });<br/>        res.status(200).json({<br/>            status: true,<br/>            data: product,<br/>        })<br/>    } catch (err) {<br/>        console.log(err)<br/>        res.status(500).json({<br/>            error: err,<br/>            status: false,<br/>        })<br/>    }<br/>}<br/>exports.getProducts = async (req, res) =&gt; {<br/>    try {<br/>        let products = await productRepository.products();<br/>        res.status(200).json({<br/>            status: true,<br/>            data: products,<br/>        })<br/>    } catch (err) {<br/>        console.log(err)<br/>        res.status(500).json({<br/>            error: err,<br/>            status: false,<br/>        })<br/>    }<br/>}</span><span id="6f79" class="lu lv iq lq b gy nf lx l ly lz">exports.getProductById = async (req, res) =&gt; {<br/>    try {<br/>        let id = req.params.id<br/>        let productDetails = await productRepository.productById(id);<br/>        res.status(200).json({<br/>            status: true,<br/>            data: productDetails,<br/>        })<br/>    } catch (err) {<br/>        res.status(500).json({<br/>            status: false,<br/>            error: err<br/>        })<br/>    }<br/>}<br/>exports.removeProduct = async (req, res) =&gt; {<br/>    try {<br/>        let id = req.params.id<br/>        let productDetails = await productRepository.removeProduct(id)<br/>        res.status(200).json({<br/>            status: true,<br/>            data: productDetails,<br/>        })<br/>    } catch (err) {<br/>        res.status(500).json({<br/>            status: false,<br/>            error: err<br/>        })<br/>    }<br/>}</span></pre><p id="5dd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe nc nd ne lq b">src</code>目录中创建一个<strong class="ka ir"> routerHandler.js </strong>文件，这将是我们的全局路由处理程序:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="1ae2" class="lu lv iq lq b gy lw lx l ly lz">const productRoutes = require("./Product/routes")<br/>module.exports = app =&gt; {<br/>    app.use("/product", productRoutes);<br/>}</span></pre><p id="5f57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在<code class="fe nc nd ne lq b">index.js</code>文件中注册。确保在mongoose实例之后注册这个文件。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="ff59" class="lu lv iq lq b gy lw lx l ly lz">require('./app/routeHandler')(app)</span></pre><h1 id="dd2a" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">测试我们的路线</h1><p id="2908" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">获取所有产品</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/9b350edcc95c949d042869f588e7ce86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JpyX0zrCSSGN_KG5.png"/></div></div></figure><p id="b10f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建帖子</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/e4b6aba671fc9d280c8ec8c3f016d0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qi3M-dtXgWqtlmOh.png"/></div></div></figure><p id="fb84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按id获取产品</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/e57b6af6b854264d9e13363ee089e86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vmDh7FSDIEGEW8BY.png"/></div></div></figure><p id="5466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">移除产品</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/1b1f854205fb0d44a1b462474d8ae3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*he-0NkUFwMBCjBwH.png"/></div></div></figure><p id="4ff6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以开始开发我们的购物车功能了。在<code class="fe nc nd ne lq b">src/app</code>目录中创建一个新目录<code class="fe nc nd ne lq b">Cart</code>。就像我们对产品模块所做的那样，我们将定义模型、路线、仓库和控制器文件。</p><p id="9a4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">让我们从定义购物车模型开始:</strong></p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="f3a8" class="lu lv iq lq b gy lw lx l ly lz">const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema;<br/>let ItemSchema = new Schema({<br/>    productId: {<br/>        type: mongoose.Schema.Types.ObjectId,<br/>        ref: "Product",<br/>    },<br/>    quantity: {<br/>        type: Number,<br/>        required: true,<br/>        min: [1, 'Quantity can not be less then 1.']<br/>    },<br/>    price: {<br/>        type: Number,<br/>        required: true<br/>    },<br/>    total: {<br/>        type: Number,<br/>        required: true,<br/>    }<br/>}, {<br/>    timestamps: true<br/>})<br/>const CartSchema = new Schema({<br/>    items: [ItemSchema],<br/>    subTotal: {<br/>        default: 0,<br/>        type: Number<br/>    }<br/>}, {<br/>    timestamps: true<br/>})<br/>module.exports = mongoose.model('cart', CartSchema);</span></pre><p id="9ee3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们创建第一个模式来保存当前产品的实例，并创建第二个文件来保存购物车中的商品数组。</p><p id="c6d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们必须定义我们的<strong class="ka ir"> repository.js </strong>文件:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="7e48" class="lu lv iq lq b gy lw lx l ly lz">const Cart = require("./model");<br/>exports.cart = async () =&gt; {<br/>    const carts = await Cart.find().populate({<br/>        path: "items.productId",<br/>        select: "name price total"<br/>    });;<br/>    return carts[0];<br/>};<br/>exports.addItem = async payload =&gt; {<br/>    const newItem = await Cart.create(payload);<br/>    return newItem<br/>}</span></pre><p id="3b96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，我们编写了两个方法来获取数据库中的所有购物车商品，并将一个商品添加到购物车模型中。</p><p id="f25b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以为购物车创建控制器，我们将有3个控制器:</p><ul class=""><li id="2b4d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">获取所有购物车商品</li><li id="23be" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">将产品添加到购物车</li><li id="48ed" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">空车</li></ul><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9994" class="lu lv iq lq b gy lw lx l ly lz">const cartRepository = require('./repository')<br/>    const productRepository = require('../Product/repository');</span><span id="b6aa" class="lu lv iq lq b gy nf lx l ly lz">    exports.addItemToCart = async (req, res) =&gt; {<br/>        const {<br/>            productId<br/>        } = req.body;<br/>        const quantity = Number.parseInt(req.body.quantity);<br/>        try {<br/>            let cart = await cartRepository.cart();<br/>            let productDetails = await productRepository.productById(productId);<br/>                 if (!productDetails) {<br/>                return res.status(500).json({<br/>                    type: "Not Found",<br/>                    msg: "Invalid request"<br/>                })<br/>            }<br/>            //--If cart exists ----<br/>            if (cart) {<br/>                //---- Check if index exists ----<br/>                const indexFound = cart.items.findIndex(item =&gt; item.productId.id == productId);<br/>                //------This removes an item from the the cart if the quantity is set to zero, We can use this method to remove an item from the list  -------<br/>                if (indexFound !== -1 &amp;&amp; quantity &lt;= 0) {<br/>                    cart.items.splice(indexFound, 1);<br/>                    if (cart.items.length == 0) {<br/>                        cart.subTotal = 0;<br/>                    } else {<br/>                        cart.subTotal = cart.items.map(item =&gt; item.total).reduce((acc, next) =&gt; acc + next);<br/>                    }<br/>                }<br/>                //----------Check if product exist, just add the previous quantity with the new quantity and update the total price-------<br/>                else if (indexFound !== -1) {<br/>                    cart.items[indexFound].quantity = cart.items[indexFound].quantity + quantity;<br/>                    cart.items[indexFound].total = cart.items[indexFound].quantity * productDetails.price;<br/>                    cart.items[indexFound].price = productDetails.price<br/>                    cart.subTotal = cart.items.map(item =&gt; item.total).reduce((acc, next) =&gt; acc + next);<br/>                }<br/>                //----Check if quantity is greater than 0 then add item to items array ----<br/>                else if (quantity &gt; 0) {<br/>                    cart.items.push({<br/>                        productId: productId,<br/>                        quantity: quantity,<br/>                        price: productDetails.price,<br/>                        total: parseInt(productDetails.price * quantity)<br/>                    })<br/>                    cart.subTotal = cart.items.map(item =&gt; item.total).reduce((acc, next) =&gt; acc + next);<br/>                }<br/>                //----If quantity of price is 0 throw the error -------<br/>                else {<br/>                    return res.status(400).json({<br/>                        type: "Invalid",<br/>                        msg: "Invalid request"<br/>                    })<br/>                }<br/>                let data = await cart.save();<br/>                res.status(200).json({<br/>                    type: "success",<br/>                    mgs: "Process Successful",<br/>                    data: data<br/>                })<br/>            }<br/>            //------------ This creates a new cart and then adds the item to the cart that has been created------------<br/>            else {<br/>                const cartData = {<br/>                    items: [{<br/>                        productId: productId,<br/>                        quantity: quantity,<br/>                        total: parseInt(productDetails.price * quantity),<br/>                        price: productDetails.price<br/>                    }],<br/>                    subTotal: parseInt(productDetails.price * quantity)<br/>                }<br/>                cart = await cartRepository.addItem(cartData)<br/>                // let data = await cart.save();<br/>                res.json(cart);<br/>            }<br/>        } catch (err) {<br/>            console.log(err)<br/>            res.status(400).json({<br/>                type: "Invalid",<br/>                msg: "Something Went Wrong",<br/>                err: err<br/>            })<br/>        }<br/>    }<br/>    exports.getCart = async (req, res) =&gt; {<br/>        try {<br/>            let cart = await cartRepository.cart()<br/>            if (!cart) {<br/>                return res.status(400).json({<br/>                    type: "Invalid",<br/>                    msg: "Cart not found",<br/>                })<br/>            }<br/>            res.status(200).json({<br/>                status: true,<br/>                data: cart<br/>            })<br/>        } catch (err) {<br/>            console.log(err)<br/>            res.status(400).json({<br/>                type: "Invalid",<br/>                msg: "Something went wrong",<br/>                err: err<br/>            })<br/>        }<br/>    }</span><span id="91d3" class="lu lv iq lq b gy nf lx l ly lz">    exports.emptyCart = async (req, res) =&gt; {<br/>        try {<br/>            let cart = await cartRepository.cart();<br/>            cart.items = [];<br/>            cart.subTotal = 0<br/>            let data = await cart.save();<br/>            res.status(200).json({<br/>                type: "Success",<br/>                mgs: "Cart has been emptied",<br/>                data: data<br/>            })<br/>        } catch (err) {<br/>            console.log(err)<br/>            res.status(400).json({<br/>                type: "Invalid",<br/>                msg: "Something went wrong",<br/>                err: err<br/>            })<br/>        }<br/>    }</span></pre><p id="2702" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了方便和更好的理解，对代码片段进行了注释。</p><p id="b870" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以定义我们的模块路由，然后定义全局路由。将此添加到<strong class="ka ir"> routes.js </strong>文件中:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="7d84" class="lu lv iq lq b gy lw lx l ly lz">const router = require("express").Router();<br/>const cartController = require("./controller");<br/>router.post("/", cartController.addItemToCart);<br/>router.get("/", cartController.getCart);<br/>router.delete("/empty-cart", cartController.emptyCart);<br/>module.exports = router;</span></pre><p id="9e59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将<strong class="ka ir"> routeHandler.js </strong>文件更新为:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="92ca" class="lu lv iq lq b gy lw lx l ly lz">const productRoutes = require("./Product/routes");<br/>const cartRoutes = require('./Cart/routes')<br/>module.exports = app =&gt; {<br/>    app.use("/product", productRoutes);<br/>    app.use("/cart", cartRoutes);<br/>}</span></pre><h1 id="ffa8" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">测试购物车功能</h1><p id="0a91" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">将商品添加到购物车:</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/f7834f2f95cf5b8b6df42a758591db9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qDY1pIx0J3jSqKzq.png"/></div></div></figure><p id="4147" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取购物车商品:</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/904f483c10c83a33daa1acb8109669dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pj9n03yOwsCkf11H.png"/></div></div></figure><h1 id="0130" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">空车</h1><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/ba7a4d793d2b9a9f985144cd8f0a86d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vaFGUiqTdmLFCtT9.png"/></div></div></figure><p id="f66f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于测试目的，使用POSTMAN创建一些产品。这是我们将在前端应用程序中用于测试目的的内容。</p><h1 id="0809" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">锻炼</h1><ul class=""><li id="445f" class="kx ky iq ka b kb mx kf my kj nh kn ni kr nj kv lc ld le lf bi translated">从购物车中添加或减去产品数量</li><li id="b5ea" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">从购物车中移除单个产品</li></ul><p id="6ab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现之后，将您的工作推送到git，并在评论部分添加链接。让我们找点乐子😁</p><p id="931b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们的后端已经准备好了，我们现在可以继续我们的前端。对于前端，我打算写3种不同的前端技术，<a class="ae kw" href="https://www.wrappixel.com/build-a-shopping-cart-in-nodejs-and-vue-vite/" rel="noopener ugc nofollow" target="_blank"> Vuejs </a>，Angular和React，将很快在这里发布链接。</p><h2 id="640b" class="lu lv iq bd mb nk nl dn mf nm nn dp mj kj no np mn kn nq nr mr kr ns nt mv nu bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="668a" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">plain English . io</strong></a>找到所有内容的链接！</p></div></div>    
</body>
</html>