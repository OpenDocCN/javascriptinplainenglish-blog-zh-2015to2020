<html>
<head>
<title>TypeScript Generic Rest Parameters and Tuple Types in Practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript泛型Rest参数和元组类型在实践中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-generic-rest-parameters-and-tuple-types-in-practice-edc2bb0bdcb9?source=collection_archive---------2-----------------------#2020-09-08">https://javascript.plainenglish.io/typescript-generic-rest-parameters-and-tuple-types-in-practice-edc2bb0bdcb9?source=collection_archive---------2-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="http://nowjobs.com" rel="noopener ugc nofollow" target="_blank"> NOWJOBS </a>我们使用TypeScript和一个家庭定制的Node web框架(基于<a class="ae kl" href="https://github.com/jcoppieters/cody" rel="noopener ugc nofollow" target="_blank">科迪</a>的核心)让客户创建职位空缺并找到候选人。在这篇文章中，我们将展示如何使用<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#generic-rest-parameters" rel="noopener ugc nofollow" target="_blank">通用rest参数类型</a>和<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">元组类型</a>来键入我们的授权检查。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/78dc4415222a8598ce907f30bb4ac3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhqsH0tkzsQEHzmJz5SbQA.jpeg"/></div></div></figure><h1 id="b33a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">语境</h1><p id="3fa1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我们的框架中，处理编辑作业的请求看起来像这样:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="a0c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当发出请求时，框架找到正确的控制器，用一些请求上下文实例化它，并调用doRequest方法。在处理请求时，我们:</p><ol class=""><li id="e44f" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">检索请求和发出请求的用户的id</li><li id="3aa6" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">使用<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/enums.html#string-enums" rel="noopener ugc nofollow" target="_blank">字符串enum </a> JobRequests检查哪个请求被完成(客户端也使用它来发出请求，因为我们在客户端和服务器之间共享TypeScript代码！)</li><li id="7c62" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">获取请求参数</li><li id="f7ee" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">对参数执行授权检查</li><li id="e847" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">在doEditJob方法中进行实际编辑并生成响应</li></ol></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="c50a" class="ky kz iq bd la lb my ld le lf mz lh li lj na ll lm ln nb lp lq lr nc lt lu lv bi translated">批准</h1><p id="2a02" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在本文中，我们将关注如何处理第4步，即授权，以及通用rest参数类型如何为其提供完整的类型支持。该框架通过提供一个authorize方法来方便我们的开发人员，该方法采用一个高阶auth函数和一些参数。用这些参数调用auth函数。如果返回false，将抛出一个特定的未授权错误。然后，这被框架捕获，并向客户端返回403响应。该方法本身很简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="01e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们更仔细地看一下auth函数，它的调用方式是:</p><ol class=""><li id="fba7" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">控制器的实例化(允许函数执行db操作、日志记录等。在请求的上下文中)</li><li id="3cd6" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">给authorize函数的其他参数。这些参数使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest操作符</a>收集，然后使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread语法</a>应用于auth函数调用。基本上，我们将authorize函数的所有参数传递给auth函数，除了第一个参数。</li></ol><p id="23af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查作业是否属于给定用户的验证函数示例可以定义为:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="c01c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">类型</h1><p id="a836" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在，我们可以输入authorize函数，说明两个rest参数都是未知类型的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是当调用authorize时，我们错过了许多类型检查:</p><ol class=""><li id="71e9" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">参数的数量是必需的，因为数组类型没有固定的长度。</li><li id="fd71" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">需要参数的<em class="nd">类型，因为元素被均匀地类型化为unknown(意思是，它们都有相同的类型，unknown)。</em></li></ol><p id="3ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，对rest参数没有适当的类型检查，因此允许以下调用:</p><pre class="kn ko kp kq gt ne nf ng nh aw ni bi"><span id="edae" class="nj kz iq nf b gy nk nl l nm nn">await this.authorize(isJobOf, job)<br/>await this.authorize(isJobOf, job, "id")<br/>await this.authorize(isJobOf)</span></pre><p id="a2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们实际上想要告诉类型系统的是，authorize的rest参数中收集的参数<em class="nd">与auth函数中的参数</em>完全相同。我们可以通过使用<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型类型</a>来尝试，假设authorize函数的rest参数是P类型，auth函数的rest参数是T类型。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2b9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类型系统会抱怨args必须是array类型，因为在rest参数上使用泛型类型时，这是唯一允许的类型。这可以通过告诉它泛型类型P和T都扩展了未知的数组类型来解决。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2dd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管将rest参数类型化为数组感觉起来很自然，但它实际上是一个特殊的构造<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#generic-rest-parameters" rel="noopener ugc nofollow" target="_blank">，其中类型系统将使用</a><a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">元组类型</a>而不是同类数组类型。元组类型正好解决了我们遇到的问题，也就是说，它们为每个元素键入一个具有<em class="nd">固定长度</em>和<em class="nd">特定类型的数组。</em></p><p id="d771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用isJobOf调用authorize时，类型系统将:</p><ul class=""><li id="4d24" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk no mj mk ml bi translated">将isJobOf的签名类型与AuthFunction <t>匹配，将T设置为tuple [number，number]以匹配isJobOf的第二个和第三个参数的类型。</t></li><li id="7c35" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk no mj mk ml bi translated">因此，authorize的通用类型P也被设置为[number，number]。</li><li id="63d7" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk no mj mk ml bi translated">因此，现在类型系统强制要求authorize的其余参数必须是[number，number]类型，因此第二个和第三个参数必须是number类型。</li></ul><p id="2012" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在类型系统做了我们想要它做的事情。此外，令人惊讶的是，当使用VSCode时，它甚至会复制auth函数的正确参数名称，以在调用authorize函数时显示在authorize的类型签名中(job: number，customer: number):</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi np"><img src="../Images/f053786d63fcbeef4306fc6797b3a86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQw6xRCqwnA5JMTbJIrU4w.png"/></div></div></figure><p id="86ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个看似简单的结果都是由<em class="nd"> rest参数</em>、<em class="nd">、扩展语法</em>和<em class="nd">元组类型</em>与<em class="nd">通用rest参数</em>的内在组合实现的。多酷啊！我们对TypeScript团队的惊人工作感到非常高兴，他们最终提出了一个与我们合作而不是与我们作对的类型系统！</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="c117" class="ky kz iq bd la lb my ld le lf mz lh li lj na ll lm ln nb lp lq lr nc lt lu lv bi translated">资源</h1><ul class=""><li id="3272" class="md me iq jp b jq lw ju lx jy nq kc nr kg ns kk no mj mk ml bi translated">Rest参数:<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Functions/rest _ parameters</a></li><li id="e6a6" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk no mj mk ml bi translated">展开语法:<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Spread _ syntax</a></li><li id="4f99" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk no mj mk ml bi translated">元组类型:<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/basic-types . html # tuple</a></li><li id="3d5d" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk no mj mk ml bi translated">Typescript泛型Rest参数类型:<a class="ae kl" href="https://github.com/microsoft/TypeScript/pull/2489" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/TypeScript/pull/2489</a>和<a class="ae kl" href="https://github.com/microsoft/TypeScript/pull/24897" rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/TypeScript/pull/24897</a></li></ul><p id="e66a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nd">注意:当然你也可以对authorize和AuthFunction的泛型类型使用相同的变量名(所以都是T ),因为它们的作用域是类型本身。我们在这里用一个不同的名称来演示它，以清楚地表明它们实际上是两个不同的变量。</em></p></div></div>    
</body>
</html>