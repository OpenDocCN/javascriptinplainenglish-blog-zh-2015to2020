<html>
<head>
<title>Rxjs Operators — More Join Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rxjs运算符—更多连接运算符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-operators-more-join-operators-61aebe60baa7?source=collection_archive---------5-----------------------#2020-02-23">https://javascript.plainenglish.io/rxjs-operators-more-join-operators-61aebe60baa7?source=collection_archive---------5-----------------------#2020-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b698ea172059fb71744c383d82b49c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wWbJaAVzNJPHzyVM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@todoranb_26?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bogdan Todoran</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="5ba1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看一些连接操作符，包括<code class="fe lb lc ld le b">exhaust</code>、<code class="fe lb lc ld le b">mergeAll</code>、<code class="fe lb lc ld le b">startsWith</code>和<code class="fe lb lc ld le b">withLatestFrom</code>。</p><h1 id="9843" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">exhaust</code></h1><p id="d062" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">exhaust</code>算子通过在前一个内部可观测量未完成时丢弃内部可观测量，将高阶可观测量转换为一阶可观测量。</p><p id="cfbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不接受参数，返回一个可观察对象，该可观察对象接受源可观察对象，并从第一个可观察对象独占地传播值，直到它在订阅下一个可观察对象之前完成。</p><p id="467e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="06d8" class="mq lg iq le b gy mr ms l mt mu">import { of, interval } from "rxjs";<br/>import { map, exhaust, take } from "rxjs/operators";</span><span id="011c" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3);<br/>const higherOrderObservable = of$.pipe(map(val =&gt; interval(500).pipe(take(3))));<br/>const result = higherOrderObservable.pipe(exhaust());<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="7157" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将来自<code class="fe lb lc ld le b">of$</code>可观测值的值映射到<code class="fe lb lc ld le b">interval(500).pipe(take(3))</code>可观测值，后者每半秒发出高达2的数字。</p><p id="40c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们把<code class="fe lb lc ld le b">pipe</code>的<code class="fe lb lc ld le b">interval(500).pipe(take(3))</code>可观测量交给<code class="fe lb lc ld le b">exhaust</code>的操作者。然后，除了第一个<code class="fe lb lc ld le b">interval(500).pipe(take(3))</code>之外的所有可观测量都被丢弃，因为它已经完成发射，而下一个可观测量将被执行。</p><p id="3d5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="35dd" class="mq lg iq le b gy mr ms l mt mu">0<br/>1<br/>2</span></pre><p id="8a08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<code class="fe lb lc ld le b">console.log</code>输出。</p><h1 id="14bd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">mergeAll</h1><p id="8bd5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">mergeAll</code>将高阶可观测量转换为一阶可观测量，一阶可观测量同时传递内部可观测量发出的所有值。</p><p id="2348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它采用可选的<code class="fe lb lc ld le b">concurrent</code>参数，默认为<code class="fe lb lc ld le b">Number.INFINITY</code>来表示并发订阅的内部可观察对象的最大数量。</p><p id="5b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">mergeAll</code>订阅高阶可观测值中的所有内部可观测值，并将它们的所有值传递给输出可观测值。只有当所有内部可观测量完成时，返回的输出可观测量才完成。</p><p id="dbe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何由内部可观测量发出的错误都会立即导致由返回的可观测量发出的错误。</p><p id="5ab6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0dcd" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { map, mergeAll } from "rxjs/operators";</span><span id="ce7b" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3);<br/>const higherOrderObservable = of$.pipe(map(val =&gt; of("a", "b", "c")));<br/>const result = higherOrderObservable.pipe(mergeAll());<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="cdd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将每个发射值从<code class="fe lb lc ld le b">of$</code>可观察值映射到<code class="fe lb lc ld le b">of(“a”, “b”, “c”)</code>可观察值。</p><p id="36c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe lb lc ld le b">mergeAll</code>操作符订阅所有的<code class="fe lb lc ld le b">of(“a”, “b”, “c”)</code>观察值，然后订阅每个观察值，然后发出每个观察值的值。</p><p id="317c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9849" class="mq lg iq le b gy mr ms l mt mu">a<br/>b<br/>c<br/>a<br/>b<br/>c<br/>a<br/>b<br/>c</span></pre><p id="4435" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自<code class="fe lb lc ld le b">console.log</code>。</p><p id="94e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过向<code class="fe lb lc ld le b">mergeAll</code>操作符传递一个数字来改变<code class="fe lb lc ld le b">concurrency</code>。</p><p id="770a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9544" class="mq lg iq le b gy mr ms l mt mu">import { of, interval } from "rxjs";<br/>import { map, mergeAll, take } from "rxjs/operators";</span><span id="93e2" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3);<br/>const higherOrderObservable = of$.pipe(<br/>  map(val =&gt; interval(1000).pipe(take(2)))<br/>);<br/>const result = higherOrderObservable.pipe(mergeAll(1));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="fdc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让<code class="fe lb lc ld le b">mergeAll</code>订阅从<code class="fe lb lc ld le b">map</code>操作符的回调中返回的每个子可观察值，这将使我们:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="280c" class="mq lg iq le b gy mr ms l mt mu">0<br/>1<br/>0<br/>1<br/>0<br/>1</span></pre><p id="60ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自<code class="fe lb lc ld le b">console.log</code>。</p><p id="0a0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以将1改为5，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="822e" class="mq lg iq le b gy mr ms l mt mu">import { of, interval } from "rxjs";<br/>import { map, mergeAll, take } from "rxjs/operators";</span><span id="2e1d" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3);<br/>const higherOrderObservable = of$.pipe(<br/>  map(val =&gt; interval(1000).pipe(take(2)))<br/>);<br/>const result = higherOrderObservable.pipe(mergeAll(5));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="e856" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="80eb" class="mq lg iq le b gy mr ms l mt mu">(3) 0<br/>(3) 1</span></pre><p id="2ea4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并发订阅时从<code class="fe lb lc ld le b">console.log</code>输出。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5f98d13da325ece909b905a12dea250a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KeoKMGGk0dXIlTCt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@andyjh07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andy Holmes</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0771" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">开始于</h1><p id="f070" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">startsWith</code>返回一个可观察对象，在它开始从源可观察对象发出项目之前，发出我们想要发出的项目。</p><p id="d544" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个参数，这是一个<code class="fe lb lc ld le b">array</code>项，我们希望在返回的可观察对象的源可观察值之前发出这些项。</p><p id="2cf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="eb39" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { startWith } from "rxjs/operators";</span><span id="5f1e" class="mq lg iq le b gy mv ms l mt mu">of(1)<br/>  .pipe(startWith("foo", "bar"))<br/>  .subscribe(x =&gt; console.log(x));</span></pre><p id="dc8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="439f" class="mq lg iq le b gy mr ms l mt mu">foo<br/>bar<br/>1</span></pre><p id="36a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe lb lc ld le b">console.log</code>输出。</p><h1 id="6560" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">withLatestFrom</h1><p id="782f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">withLatestFrom</code>运算符将源可观测值与其他可观测值组合在一起，创建一个可观测值，仅当源发出时，该可观测值才根据各自的最新值计算得出。</p><p id="1061" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个参数列表，这是一个可以用来组合值的可观察对象。</p><p id="e6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7b70" class="mq lg iq le b gy mr ms l mt mu">import { fromEvent, interval } from "rxjs";<br/>import { withLatestFrom } from "rxjs/operators";</span><span id="19b5" class="mq lg iq le b gy mv ms l mt mu">const clicks = fromEvent(window, "click");<br/>const timer = interval(1000);<br/>const result = clicks.pipe(withLatestFrom(timer));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="0d69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lb lc ld le b">fromEvent</code>操作符跟踪浏览器标签的点击。然后我们通过使用<code class="fe lb lc ld le b">withLatestFrom</code>操作符将<code class="fe lb lc ld le b">timer</code>发出的结果与它结合起来。</p><p id="25be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<code class="fe lb lc ld le b">result</code>可观察对象将发出数组，将来自<code class="fe lb lc ld le b">clicks</code>可观察对象的<code class="fe lb lc ld le b">MouseEvent</code>对象作为第一个值，将来自<code class="fe lb lc ld le b">timer</code>可观察对象的数字作为第二个值。</p><p id="1b83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">exhaust</code>算子通过在前一个内部可观测量未完成时丢弃内部可观测量，将高阶可观测量转换为一阶可观测量。</p><p id="37c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">mergeAll</code>将高阶可观测量转换为一阶可观测量，一阶可观测量同时传递内部可观测量发出的所有值。</p><p id="1033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">startsWith</code>在源可观察对象开始发出值之前，返回发出我们想要发出的项目的可观察对象。</p><p id="f765" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">withLatestFrom</code>运算符将源可观测值与另一个可观测值组合起来，并返回一个可观测值，该可观测值发出来自两者的最新值。</p></div></div>    
</body>
</html>