<html>
<head>
<title>Vue.js Lifecycle Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js生命周期挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vuejs-lifecycle-hooks-7ddf74732b38?source=collection_archive---------8-----------------------#2020-10-05">https://javascript.plainenglish.io/vuejs-lifecycle-hooks-7ddf74732b38?source=collection_archive---------8-----------------------#2020-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9ad63872e21d0acb42074a3001c2a2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*QmT23iWAgVNe76Jp81kXYA.jpeg"/></div></div></figure><p id="e065" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，你将学习并理解<strong class="jx io"> Vue.js生命周期挂钩</strong>。您还将深入了解组件是如何在幕后创建和销毁的。</p><p id="e53a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生命周期挂钩是几乎所有前端框架的入口点，很好地理解组件何时被创建、安装、更新和销毁对于理解库的反应性是必不可少的。</p><p id="f6b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">理解Vue.js中的生命周期挂钩相当容易。下图展示了Vue.js组件的整个生命周期。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/8014b988103b5197833030b36aedfcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*auByFHd6tZlHMUGZ.jpg"/></div></figure><p id="6b32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">观察生命周期挂钩在<a class="ae ky" href="https://www.wrappixel.com/templates/category/vuejs-templates/" rel="noopener ugc nofollow" target="_blank"> vue模板</a>编译的不同阶段是如何变化的。</p><p id="8e03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据Vue.js文档，每个Vue实例在创建时都要经历一系列初始化步骤。—例如，它需要设置数据观察、编译模板、将实例挂载到DOM，并在数据发生变化时更新DOM。同时，它还运行名为<strong class="jx io">生命周期挂钩</strong>的功能，让用户有机会在特定阶段添加自己的代码。</p><h1 id="e8a4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Vue创造了钩子</h1><h1 id="9052" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">创建挂钩之前</h1><p id="f996" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">beforeCreated挂钩是初始化阶段的第一个挂钩，它在实例创建之前被触发，因此在这种状态下不会设置反应性。这意味着我们不能访问或更新数据。如果有来自后端API的数据，在beforeCreated钩子中调用它将返回undefined。参见示例。</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="9fa9" class="mh la in md b gy mi mj l mk ml">&lt;script&gt;<br/>  export default {<br/>    beforeCreated(){<br/>      console.log(data);<br/>      //This will return undefined <br/>    }<br/>  }<br/>&lt;/script&gt;</span></pre><h1 id="56c1" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">创建的挂钩</h1><p id="d683" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">创建组件时会触发创建的挂钩，在这里我们可以访问组件的数据并创建反应性。然而，模板和虚拟DOM还没有挂载到这个钩子中。请参见下面的示例:</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="e505" class="mh la in md b gy mi mj l mk ml">&lt;script&gt;<br/>  export default {<br/>    data(){<br/>      return{<br/>        message: "I am learning Vue lifecycle hooks"<br/>      }<br/>    },</span><span id="eca3" class="mh la in md b gy mm mj l mk ml">    computed:{<br/>      messageChange(){<br/>        console.log(`This will look up to ${this.message} for changes`);<br/>        return this.messages <br/>      }<br/>    },<br/>    <br/>    created(){<br/>      this.message = "now the message is changed";<br/>      console.log(`messageChange will be updated since reactivity is present`);<br/>    }<br/>  }<br/>&lt;/script&gt;</span></pre><h1 id="a8c7" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Vue安装挂钩</h1><h1 id="6e1b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">安装前挂钩</h1><p id="7335" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">beforeMount挂钩在虚拟DOM的初始呈现和模板或呈现函数的编译之前被触发。不推荐在服务器端渲染时使用这个钩子，渲染后不能调用它。参见示例:</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="8dc6" class="mh la in md b gy mi mj l mk ml">&lt;script&gt;<br/>  export default {<br/>    beforeMount(){<br/>      console.log(`${this.el} is about to be mount`);<br/>    }<br/>&lt;/script&gt;</span></pre><h1 id="e343" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">安装钩</h1><p id="81fb" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">挂载的钩子全反应建立，模板，渲染DOM (via。这个。$el)。</p><p id="1f78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">据报道，安装挂钩是最常用的生命周期挂钩。大多数人用它来获取组件的数据(我推荐使用<strong class="jx io">创建的钩子</strong>)。参见示例:</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="0326" class="mh la in md b gy mi mj l mk ml">&lt;template&gt;<br/>  &lt;p&gt;Text inside a component&lt;/p&gt;<br/>&lt;/template&gt;</span><span id="db10" class="mh la in md b gy mm mj l mk ml">&lt;script&gt;<br/>  export default {<br/>    mounted(){<br/>      console.log(this.$el.textContent);<br/>      //This will return the text from the template <br/>    }<br/>&lt;/script&gt;</span></pre><h1 id="593c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Vue更新挂钩</h1><p id="bdc3" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">每当组件使用的反应属性发生变化时，或者通过用户输入导致组件重新呈现时，都会触发更新挂钩。它们的更新钩子允许你挂钩到组件的<strong class="jx io">观察-计算-渲染循环</strong>。</p><p id="f3d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想知道组件何时重新渲染，可以使用它。要定位反应组件的状态，请改为计算属性或观察器。</p><h1 id="5a51" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">更新前挂钩</h1><p id="059d" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">beforeUpdate挂钩在组件重新呈现之前触发，它在组件中的数据发生变化时启动。这是在渲染之前跟踪反应组件状态的好地方。参见示例:</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="0c1f" class="mh la in md b gy mi mj l mk ml">&lt;script&gt;<br/>  export default {<br/>    data(){<br/>      n: 1,<br/>    },<br/>    <br/>    beforeUpdate(){<br/>      console.log(this.n) //sets the value of n to 300 after 1,500 seconds;<br/>    },<br/>    <br/>    created(){<br/>      setTimeOut(() =&gt; {<br/>        this.n = 300<br/>      }, 1500);<br/>    }<br/>&lt;/script&gt;</span></pre><h1 id="b41c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">更新的挂钩</h1><p id="fa75" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">在数据更改导致虚拟DOM被重新呈现和修补之后，更新的钩子被调用。当这个钩子被调用时，组件的DOM将被更新，所以您可以在这里执行依赖于DOM的操作。然而，在大多数情况下，你应该避免改变钩子内部的状态。为了对状态变化做出反应，通常最好使用一个<a class="ae ky" href="https://vuejs.org/v2/api/#computed" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">计算属性</strong> </a>或<a class="ae ky" href="https://vuejs.org/v2/api/#watch" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">观察器</strong> </a>来代替。</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="9a1e" class="mh la in md b gy mi mj l mk ml">&lt;template&gt;<br/>  &lt;p ref="dom-element"&gt;{{name}}&lt;/p&gt;<br/>&lt;/template&gt;</span><span id="cefd" class="mh la in md b gy mm mj l mk ml">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      name: "Emmanuel Etukudo"<br/>    }<br/>  },</span><span id="f71d" class="mh la in md b gy mm mj l mk ml">  updated() {<br/>    // Track update on the DOM element.<br/>    console.log(this.$refs['dom-element'].textContent === this.name)<br/>  },</span><span id="1c15" class="mh la in md b gy mm mj l mk ml">  created() {<br/>    setTimeout(() =&gt; {<br/>      this.name = "John Doe"<br/>    }, 1000)<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><h1 id="02a3" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">破坏钩</h1><p id="56cf" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">销毁挂钩用于在组件被销毁时执行操作，例如移除基于组件的事件。当组件被从DOM中移除时，它们就会被删除。</p><h1 id="c7b5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">销毁挂钩前</h1><p id="bd20" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">销毁Vue实例之前触发beforeDestroy挂钩。在这个阶段，实例仍然是完全正常的。</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="f52e" class="mh la in md b gy mi mj l mk ml">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      accessToken: localStorage.getItem('accessToken'),<br/>    }<br/>  },<br/></span><span id="bae8" class="mh la in md b gy mm mj l mk ml">  beforeDestroy() {<br/>    // Remove the token.<br/>    localStorage.removeItem('accessToken');<br/>  },  <br/>}<br/>&lt;/script&gt;</span></pre><h1 id="3d01" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">毁坏的钩子</h1><p id="3f20" class="pw-post-body-paragraph jv jw in jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">销毁书是在销毁Vue实例后触发的。当这个钩子被调用时，Vue实例的所有指令都被解除绑定，所有事件监听器都被移除，所有子Vue实例也都被销毁。</p><pre class="ku kv kw kx gt mc md me mf aw mg bi"><span id="1d31" class="mh la in md b gy mi mj l mk ml">&lt;script&gt;<br/>export default {<br/>  destroyed() {<br/>    console.log(this) // Nothing is left to log<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="a080" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有另外两个钩子没有在本文中捕获，它们是保持活动状态的钩子<strong class="jx io">激活</strong> &amp; <strong class="jx io">去激活。</strong>你可以在Vue文档<a class="ae ky" href="https://vuejs.org/v2/guide/instance.html" rel="noopener ugc nofollow" target="_blank">网站</a>上查找。谢谢你的阅读，请留下你的评论，我会喜欢你的。</p></div></div>    
</body>
</html>