<html>
<head>
<title>React Patterns — Creating Reusable Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应模式——创建可重用组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-patterns-creating-reusable-components-f7b9f299a5da?source=collection_archive---------8-----------------------#2020-06-20">https://javascript.plainenglish.io/react-patterns-creating-reusable-components-f7b9f299a5da?source=collection_archive---------8-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e5ed9f0834e7d0c99c50c3e49f6f3815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1AMi3qeYpLaMDUx-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@cadop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mathew Schwartz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="124c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何通过创建可重用的组件来清理React代码。</p><h1 id="07ed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建组件</h1><p id="ea3b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用功能组件来创建组件。</p><p id="0fc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a3f9" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";</span><span id="4c4e" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  return &lt;button&gt;click me&lt;/button&gt;;<br/>}</span></pre><p id="3be4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个带有按钮的组件。</p><p id="3882" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以创建一个类组件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9ded" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  render() {<br/>    return &lt;button&gt;click me&lt;/button&gt;;<br/>  }<br/>}</span></pre><p id="8259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们做同样的事情。</p><h1 id="cb8b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">差异</h1><p id="1ff9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">尽管功能组件和类组件做同样的事情，但它们之间的差别是很大的。</p><h1 id="2052" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">小道具</h1><p id="75c2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">功能组件具有从组件的参数中获取的属性。</p><p id="cc96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类组件可以使用<code class="fe mt mu mv mj b">this.props</code>访问道具。</p><p id="765e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在一个函数组件中，我们有一个带有属性的对象参数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2fa6" class="mn lc iq mj b gy mo mp l mq mr">const Button = ({ text }) =&gt; {<br/>  return &lt;button&gt;{text}&lt;/button&gt;;<br/>};</span></pre><p id="c921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">text</code>是<code class="fe mt mu mv mj b">props</code>参数的一个属性，它有适当的值。</p><p id="1a69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在类组件中，我们可以编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c277" class="mn lc iq mj b gy mo mp l mq mr">class Button extends React.Component {<br/>  render() {<br/>    return &lt;button&gt;{this.props.text}&lt;/button&gt;<br/>  }<br/>}</span></pre><p id="f189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mt mu mv mj b">render</code>方法来呈现带有<code class="fe mt mu mv mj b">this.props.text</code>的按钮，该按钮具有相同的<code class="fe mt mu mv mj b">text</code>属性值。</p><p id="7d88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">getDefaultProps</code>来设置默认道具。</p><p id="2046" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e08e" class="mn lc iq mj b gy mo mp l mq mr">Button.defaultProps = {<br/>  text: "click me"<br/>};</span></pre><p id="aa65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这适用于类和函数组件。</p><p id="eb58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将<code class="fe mt mu mv mj b">text</code>道具的值设置为<code class="fe mt mu mv mj b">'click me'</code>。</p><p id="2fcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以通过使用<code class="fe mt mu mv mj b">prop-types</code>包来设置道具类型。</p><p id="7e68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a6ae" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";<br/>import PropTypes from "prop-types";</span><span id="3278" class="mn lc iq mj b gy ms mp l mq mr">const Button = ({ text }) =&gt; {<br/>  return &lt;button&gt;{text}&lt;/button&gt;;<br/>};</span><span id="36b9" class="mn lc iq mj b gy ms mp l mq mr">Button.propTypes = {<br/>  text: PropTypes.<!-- -->string<br/>};</span></pre><p id="1dfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们验证了<code class="fe mt mu mv mj b">text</code>属性必须是一个字符串。</p><h1 id="0d6d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">状态</h1><p id="f46a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了存储状态，我们可以在函数组件中使用<code class="fe mt mu mv mj b">useState</code>钩子，在类组件中使用<code class="fe mt mu mv mj b">this.state</code>。</p><p id="52ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9abb" class="mn lc iq mj b gy mo mp l mq mr">import React, { useState } from "react";</span><span id="6b98" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  const [msg, setMsg] = useState("foo");<br/>  return &lt;p&gt;{msg}&lt;/p&gt;;<br/>}</span></pre><p id="db4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有用<code class="fe mt mu mv mj b">useState</code>钩子创建的<code class="fe mt mu mv mj b">msg</code>状态。</p><p id="d3e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以用<code class="fe mt mu mv mj b">setMsg</code>更新<code class="fe mt mu mv mj b">msg</code>的值。</p><p id="698f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在类组件中，我们可以编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3332" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";</span><span id="d426" class="mn lc iq mj b gy ms mp l mq mr">export default class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      msg: "foo"<br/>    };<br/>  }</span><span id="eb1d" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return &lt;p&gt;{this.state.msg}&lt;/p&gt;;<br/>  }<br/>}</span></pre><p id="24f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在构造函数中设置状态，而不是使用<code class="fe mt mu mv mj b">useState</code>钩子。</p><h1 id="5785" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">绑定到此</h1><p id="81e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于类组件，我们必须将事件处理程序绑定到正确的<code class="fe mt mu mv mj b">this</code>以便我们可以使用它。</p><p id="630d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不必在功能组件中引用<code class="fe mt mu mv mj b">this</code>。</p><p id="8829" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在函数组件中，我们编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e0da" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";</span><span id="e556" class="mn lc iq mj b gy ms mp l mq mr">export default function App() {<br/>  const onClick = () =&gt; {<br/>    console.log("clicked");<br/>  };</span><span id="993f" class="mn lc iq mj b gy ms mp l mq mr">  return &lt;p onClick={onClick}&gt;hello&lt;/p&gt;;<br/>}</span></pre><p id="f4be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不必引用<code class="fe mt mu mv mj b">this</code>来运行点击处理程序。</p><p id="773d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，在类组件中，我们必须编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6f84" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";</span><span id="73a6" class="mn lc iq mj b gy ms mp l mq mr">export default class App extends React.Component {<br/>  onClick() {<br/>    console.log("clicked");<br/>  }</span><span id="57c0" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return &lt;p onClick={this.onClick.bind(this)}&gt;hello&lt;/p&gt;;<br/>  }<br/>}</span></pre><p id="fda3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须调用<code class="fe mt mu mv mj b">bind</code>来改变<code class="fe mt mu mv mj b">onClick</code>方法中的<code class="fe mt mu mv mj b">this</code>，这样我们就可以运行处理程序了。</p><h1 id="8c5a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无状态功能组件</h1><p id="8e61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">无状态功能组件是没有状态的功能组件。</p><p id="4da4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它让我们获得道具和渲染组件，而无需任何状态。</p><p id="89da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b2dc" class="mn lc iq mj b gy mo mp l mq mr">const Button = ({ text }) =&gt; {<br/>  return &lt;button&gt;{text}&lt;/button&gt;;<br/>};</span></pre><p id="c5fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个无状态的函数组件，因为它需要一个属性<code class="fe mt mu mv mj b">text</code>并呈现它。</p><h1 id="bf66" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">道具和背景</h1><p id="9c72" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过编写以下内容来定义带有验证的道具:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="021c" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";<br/>import PropTypes from "prop-types";</span><span id="c496" class="mn lc iq mj b gy ms mp l mq mr">const Button = ({ text }) =&gt; {<br/>  return &lt;button&gt;{text}&lt;/button&gt;;<br/>};</span><span id="cceb" class="mn lc iq mj b gy ms mp l mq mr">Button.propTypes = {<br/>  text: PropTypes.<!-- -->string<br/>};</span></pre><p id="9fd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接受具有上下文的第二个参数的函数组件。</p><h1 id="7bc2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这</h1><p id="14fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">无状态函数组件中不需要<code class="fe mt mu mv mj b">this</code>。</p><h1 id="fd20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">状态</h1><p id="0e97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">无状态功能组件没有状态。</p><p id="6e9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们只能接收道具和上下文。</p><h1 id="7163" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生命周期</h1><p id="3659" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">无状态功能组件中没有生命周期方法。</p><p id="f726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是呈现return语句中的组件。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a24c2cb2358d58084b4a90d751fd5415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4EkvBMk0JdGiCxpJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zmachacek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zdeněk Macháček</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e4cc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考文献</h1><p id="0067" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">无状态函数组件可以有引用。</p><p id="391f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3c59" class="mn lc iq mj b gy mo mp l mq mr">import React, { useRef } from "react";</span><span id="3e13" class="mn lc iq mj b gy ms mp l mq mr">const Input = () =&gt; {<br/>  const ref = useRef();</span><span id="8b82" class="mn lc iq mj b gy ms mp l mq mr">  const focus = () =&gt; ref.current.focus();<br/>  return (<br/>    &lt;&gt;<br/>      &lt;input ref={ref} /&gt;<br/>      &lt;button onClick={focus}&gt;focus&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="4fba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe mt mu mv mj b">useRef</code>钩子来创建一个ref。</p><p id="fdd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">current</code>属性有DOM方法，我们可以调用它们。</p><p id="0b39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">focus</code>功能聚焦输入。</p><p id="686e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们点击聚焦，我们聚焦输入。</p><h1 id="2151" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4cd5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用类和函数组件来创建组件。</p><p id="1245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是等价的，但是功能组件没有生命周期方法或者需要引用<code class="fe mt mu mv mj b">this</code>。</p></div></div>    
</body>
</html>