<html>
<head>
<title>MongoDB Realm + GraphQL (Insert One document and Search)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB Realm + GraphQL(插入一个文档并进行搜索)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-mongodb-atlas-graphql-from-a-react-web-app-insert-one-and-search-360cc15cb6fa?source=collection_archive---------4-----------------------#2020-11-02">https://javascript.plainenglish.io/how-to-use-mongodb-atlas-graphql-from-a-react-web-app-insert-one-and-search-360cc15cb6fa?source=collection_archive---------4-----------------------#2020-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c6d3ce1dca50804951a8e815205d70d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUc6iSd4r6GN4RPtlNJvqw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@aperturevintage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Aperture Vintage</a> on <a class="ae jz" href="https://unsplash.com/s/photos/zen-rocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6289" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，我开始了一个个人兼职项目，在这个项目中，我需要创建一个数据库并使用他们的数据。</p><p id="a8cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我喜欢在我的副业项目上进行实验，所以我决定使用一些熟悉的和一些新的技术。</p><p id="fefd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">整个堆栈将是:</p><ul class=""><li id="46aa" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">做出反应。JS &amp; Apollo客户端</li><li id="6331" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">https://graphql.org</li><li id="0695" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">MongoDB(使用无服务器的Mongo Atlas + MongoDB Realm服务)[https://realm.mongodb.com]</li></ul><p id="8fde" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我熟悉w/ React，Mongo和新的部分是GraphQL和整个“无服务器”的Mongo Atlas。</p><p id="41a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一系列的文章中，我将尽力收集那些不琐碎的或者在这个过程中给我带来困惑的事情。</p><h2 id="a3e0" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated"><strong class="ak">这个系列是关于什么的？</strong></h2><p id="7244" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated"><strong class="kc io">在接下来的系列文章</strong>中，我会解释:</p><ol class=""><li id="e557" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mk le lf lg bi translated">插入一个。使用参数获取一个或多个文档。</li><li id="125f" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">更新一个并删除一个文档</li><li id="6d09" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">插入许多并得到所有重复错误。(自定义功能)</li><li id="2840" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">丰富从客户端发送的有效负载(自定义功能)</li><li id="f3c3" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">作为Apollo客户机的替代方案，我将使用vanilla JS和fetch()来认证、登录和执行对数据库的单个查询。</li></ol><h2 id="ce3e" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated"><strong class="ak">不会做</strong></h2><p id="2dc8" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">解释如何建立一个ReactJs项目。</p><p id="3ef8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解释如何在MongoDB领域中创建BD。</p><p id="08bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解释GraphQL的基础知识。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><p id="03c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">这篇文章</strong>将解释如何使用params简单地执行一个突变(insertOne)和两个简单的查询(Get One和Get Many)。</p><p id="67b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个地方都将发生变化。</p><ol class=""><li id="b81b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mk le lf lg bi translated">在MongoDB平台领域中</li><li id="0cc0" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">在我们的反应代码中</li></ol><p id="4f61" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，您需要为您的集合定义一个模式，以避免未定义的道具出现错误。我们的系列是关于运动表现的。</p><p id="49cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在你的领域应用中实现。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/605f24cfe5fcb2550873c9609dc894a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5H23e78aS-alXoyxJB9q7Q.png"/></div></div></figure><p id="f99c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是我们集合的(简化)模式。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6c00" class="lm ln in my b gy nc nd l ne nf">{<br/>  "title": "performance",<br/>  "properties": {<br/>    "_id": {<br/>      "bsonType": "objectId"<br/>    },<br/>    "athleteName": {<br/>      "bsonType": "string"<br/>    },<br/>    "competition": {<br/>      "bsonType": "string"<br/>    },<br/>    "date": {<br/>      "bsonType": "date"<br/>    }<br/>    "discipline": {<br/>      "bsonType": "string"<br/>    },<br/>    "id": {<br/>      "bsonType": "string"<br/>    }<br/>  }<br/>}</span></pre><h2 id="fd7f" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">创建一个文档</h2><p id="60fc" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">在您定义了一个模式之后，您可以使用graph QL“Explorer”右边的“Docs”来查看所有可用的查询和变化。在Explorer中，您可以试验并创建应用程序所需的请求和响应。对于我们的情况，突变的一个版本是:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/4a31a9a48a398563d94d044a077a1702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xp9w0Ih1qtJ62a17Xkjomg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Explanation of GraphQL Explorer Structure using our example.</figcaption></figure><p id="a951" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经准备好了变异，我们需要从我们的React应用程序进行调用。</p><p id="a8e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将突变添加到我们的<strong class="kc io"><em class="nh">operations . graph QL</em></strong>文件中，</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4a1a" class="lm ln in my b gy nc nd l ne nf">mutation createPerformance(<em class="nh">$data</em>: <em class="nh">PerformanceInsertInput</em>!) {<br/> insertOnePerformance(<em class="nh">data</em>: $data) { _id }<br/>}</span></pre><p id="b127" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在控制台中执行以下命令。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="f6a2" class="lm ln in my b gy nc nd l ne nf"><strong class="my io"><em class="nh">$ </em></strong><em class="nh">npm run generate </em></span></pre><p id="b1b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="nh">(详情:</em> </strong> <a class="ae jz" href="https://graphql-code-generator.com/docs/getting-started/installation" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="nh">安装| GraphQL代码生成器</em></strong></a><strong class="kc io"><em class="nh">)</em></strong></p><p id="601f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的命令将自动创建我们突变和查询所需的适当类型(在<em class="nh"> types.ts </em>中)和钩子(在<em class="nh"> graphql-operations.ts </em>中)。</p><p id="b4ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经准备好了钩子，我们可以在我们的组件中调用它们。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h2 id="5317" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">检索文档</h2><p id="5113" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">太好了。现在我们可以创建表演了，我们可以发出请求并获取一些。这里我们有两个选择。要么根据其属性检索一个特定的文档，要么进行“类似搜索”调用，检索符合我们标准的所有文档。</p><p id="9f0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于这两种情况，步骤(再次)是相同的。</p><ol class=""><li id="a4cd" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mk le lf lg bi translated">我们在MongoDB Explorer中解决了我们的查询。</li><li id="5cf8" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">我们将查询复制到我们的<strong class="kc io"><em class="nh">operations . graph QL</em></strong>文件中，并执行<strong class="kc io"><em class="nh">$ NPM run generate</em></strong><em class="nh">命令。</em></li><li id="5354" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">我们将逻辑移到组件中，就像我们在创建场景中所做的一样。</li></ol><h2 id="c4ed" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">检索一个文档</h2><p id="08ee" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">从第一个例子开始，我们希望<strong class="kc io">检索一个特定的文档</strong>。当然，我们可以使用非常具体和狭窄的搜索来完成它，但最常见的场景是使用其特定的<strong class="kc io"> <em class="nh"> _id、</em> </strong>，这是由MongoDB本身定义的，并且是唯一的。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/35fe2aa927f9dd3f79810b2602bb40bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ne20-2B5sXYzLlSyvzwV5A.png"/></div></div></figure><p id="60da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nh">在我们的例子中，要注意赋值参数的名称。在我们的应用程序中，我们有两个不同的id。“id”和“_id”。第一个是我们业务定义的，你可以忽略。“_id”是唯一的。如果你不熟悉GraphQL中params的定义，可以查看他们的文档(</em><a class="ae jz" href="https://graphql.org" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://graphql.org</em></a><em class="nh">)。</em></p><p id="25fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经有了我们的查询并生成了我们的钩子(<em class="nh">通过npm run generate </em>)我们可以在我们的组件中使用它。在这里，我们决定采用不同的方法。我们直接使用了钩子，并从响应中析构了<em class="nh"> { loading } </em>，以便在我们的render方法中使用它来检查何时收到了响应。然后，我们处理承诺的onComplete()和onError()，以便采取相应的行动。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="f03d" class="lm ln in bd lo lp lq dn lr ls lt dp lu kl lv lw lx kp ly lz ma kt mb mc md me bi translated">检索许多文档</h2><p id="e872" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">如果我们想要<strong class="kc io">获得更多符合特定标准的文档，</strong>我们将使用<em class="nh">几乎</em>相同的查询。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/8cf39f0f7dec05272f45ff722203c2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kil56kK8k9RCHii4feG35Q.png"/></div></div></figure><p id="0ef8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，现在，我们使用复数形式的查询<strong class="kc io"> (performances) </strong>来代替performance。这种差异还伴随着其他一些变化。</p><ol class=""><li id="cfb1" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx mk le lf lg bi translated">我们需要[Performance]类型的响应(带有性能的数组)，而不是单个性能文档。</li><li id="d490" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx mk le lf lg bi translated">在这种情况下，我们有两个额外的输入参数。<strong class="kc io"> <em class="nh">限制</em> </strong>，它限制了结果的大小，还有<strong class="kc io"> <em class="nh"> sortBy </em> </strong>，它允许我们按特定的属性进行排序。</li></ol><p id="c7ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GraphQL Explorer在自动完成方面非常有帮助，它会向您建议用于排序的可用值，但是请记住，您将所有这些值<em class="nh">都放在types.ts文件中，该文件是通过您的操作自动生成的。</em></p><p id="0e0f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">组件内部的用法与单个文档的查询完全相同。</p><p id="0fa2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">结论</strong></p><p id="0bdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">向Mongo DB Atlas提交文档相对容易。也可以搜索单个或一组结果。</p><p id="d9a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下面的帖子中，我将解释如何更新或删除一个现有的文档。</p><p id="50c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">敬请期待</p></div></div>    
</body>
</html>