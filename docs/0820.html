<html>
<head>
<title>Introduction to Dynamic Programming — Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程导论——记忆化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-dynamic-programming-memoization-3fb2236dd5db?source=collection_archive---------6-----------------------#2019-12-16">https://javascript.plainenglish.io/introduction-to-dynamic-programming-memoization-3fb2236dd5db?source=collection_archive---------6-----------------------#2019-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a9e06b16312202246569c19ab7e1af32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEefuhe0spN6FoX1DHXToQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Introduction to Dynamic Programming — <strong class="bd jd">Memoization</strong></figcaption></figure><div class=""/><p id="d435" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">动态编程仅仅意味着通过简单的递归优化你的代码。这个想法是存储子问题的结果，并在以后需要做同样的计算时重用它。</p><p id="6c15" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看动态编程是如何通过使用记忆化来提高程序效率的。我们将编写寻找“第n个”<a class="ae lk" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契数</a>的程序来实现这一点。</p><blockquote class="ll lm ln"><p id="d8b8" class="kd ke lo kf b kg kh ki kj kk kl km kn lp kp kq kr lq kt ku kv lr kx ky kz la ij bi translated"><strong class="kf jh">斐波那契问题——一般方法</strong></p></blockquote><p id="3766" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了我们大多数人解决斐波那契数问题的一般方法。这里我们有一个函数fib(n ),它接受一个参数“n ”,并给出斐波那契数列中第n个元素的输出。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/ba90620aa9bd66f074ad6abf8f546c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*8cxjU7FSPSYSe5FHe42bNw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fibonaci Program General Approach.</figcaption></figure><p id="eab0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要您试图计算较小的“n”值的斐波那契数，上面的代码就可以很好地工作。然而，对于较大的“n”值，需要更多的时间来执行。这是不同“n”值所用时间的比较。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/5afa4edfbdad18124b58900c1eee26e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*KPoScUmPMZlyjVO3DKmhIg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Time taken for execution before Memoization.</figcaption></figure><blockquote class="ll lm ln"><p id="c132" class="kd ke lo kf b kg kh ki kj kk kl km kn lp kp kq kr lq kt ku kv lr kx ky kz la ij bi translated"><strong class="kf jh">斐波那契问题——记忆方法</strong></p></blockquote><p id="dfa9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是重写的斐波那契数问题的方法，稍作修改。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/2687746adead59cf70af9d6c9f4a1a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWJexhLFn2cpyGFvNLnuiA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Fibonacci Program with Memoization.</figcaption></figure><p id="f132" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的程序和我们的第一个程序完全一样，但是执行时间更快。函数<strong class="kf jh"> fibMemoization </strong>接受两个参数，“n”和“prevValues”，默认设置为空数组。</p><p id="eb3d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次调用递归函数时，我们都会传递一个额外的参数，这个参数存储了之前计算的Fibonacci值。这个优点？让我们在程序执行时间里看看。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/c28384eea3a419f735ec57dde9a5b0f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*jgiD8L2FZ8NlhzqV96j8fg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Time taken for execution after Memoization.</figcaption></figure><p id="66e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以很明显，性能提高了。但是我们做了什么才到达那里呢？让我们以使用or第一种方法和第二种方法计算第5个斐波那契元素为例。</p><p id="feb6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一种方法中，为了计算<strong class="kf jh"> fib(5)，</strong>必须经历至少重复一次的多次迭代。例如，fib(0)至少重复4次，如下图所示。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a4cc4252b6bf0edb794d39985dfd1aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*yEUY-3dh_7OxL7zn47ia8A.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">General Iterations in calculating Fibonacci number at 5-th position.</figcaption></figure><p id="6b98" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在第二种方法中，由于我们在计算下一个迭代值之前传递先前计算的值，所以可以消除大量的迭代，如下所示。</p><figure class="lt lu lv lw gt is gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/038736f77c94463841851699d2f44a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*Gu3jIdofz3uMJgHd7EUuxw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Elimination of iterations using memoization.</figcaption></figure><blockquote class="ll lm ln"><p id="e4e8" class="kd ke lo kf b kg kh ki kj kk kl km kn lp kp kq kr lq kt ku kv lr kx ky kz la ij bi translated"><strong class="kf jh">结论</strong></p></blockquote><p id="c7ce" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lo">记忆化是一种通过权衡你的</em> <strong class="kf jh"> <em class="lo">空间</em> </strong> <em class="lo">来达到</em> <strong class="kf jh"> <em class="lo">时间效率的方式。</em> </strong> <em class="lo">所以应该只在你知道同一个函数被递归调用多次的时候使用。否则，你最终交易的</em> <strong class="kf jh"> <em class="lo">空间和时间都毫无效率可言。</em> </strong></p></div></div>    
</body>
</html>