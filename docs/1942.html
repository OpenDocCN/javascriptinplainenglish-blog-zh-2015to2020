<html>
<head>
<title>React token-based authentication module with Axios Interceptors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Axios拦截器的React基于令牌的身份验证模块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/all-in-one-tutorial-on-how-to-create-the-authentication-part-of-your-react-app-2530e7435629?source=collection_archive---------0-----------------------#2020-05-06">https://javascript.plainenglish.io/all-in-one-tutorial-on-how-to-create-the-authentication-part-of-your-react-app-2530e7435629?source=collection_archive---------0-----------------------#2020-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="49ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何创建React应用程序的身份验证部分的一体化教程。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4cc517ffea8b3be1c4f69479378f676e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hDoa0krSMPrsYj51qzxLQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo from pexels.com</figcaption></figure><h1 id="d7db" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">OAuth 2.0授权框架</h1><p id="d3ae" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在我们开始之前，必须介绍身份验证令牌的定义和用法，即访问令牌和刷新令牌。</p><h2 id="e476" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><strong class="ak">访问令牌</strong></h2><p id="1ab3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">访问令牌用于基于令牌的身份验证，以允许访问API。用户成功验证和授权自己后，将收到访问令牌。然后这些令牌在调用API时作为凭证传递。一个<em class="mv">访问</em>令牌通知API它的持有者被授权<em class="mv">访问</em>API，并且如果它们落在<a class="ae mw" href="https://oauth.net/2/scope/" rel="noopener ugc nofollow" target="_blank">授权期间被授予的范围</a>内，则执行特定的动作。</p><h2 id="72c9" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><strong class="ak">刷新令牌</strong></h2><p id="7626" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">基本上，刷新令牌用于获取新的访问令牌。刷新令牌的寿命通常比访问令牌的寿命长得多。当用户的访问令牌过期或无效时使用它，以便用户可以通过获取新的访问令牌来重新获得访问权。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="d229" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><strong class="ak">我将在本教程中使用</strong> <a class="ae mw" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">轴</strong></a><strong class="ak"/></h2><p id="910d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Axios是一个JavaScript库，用于从Node.js发出HTTP请求，或者从支持ES6 Promise API的浏览器发出XMLHttpRequests。这里有一篇完整的文章解释使用Axios的好处。</p><h2 id="504c" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated">Axios拦截器:</h2><p id="dc1f" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">拦截器用于以某种实现某种全局错误处理方案的方式修改请求头。</p><p id="9901" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如果请求失败，可以通过拦截任何请求来处理错误，如果请求符合某些<em class="mv">错误</em>条件，则执行一些代码。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="7219" class="mj kw iq nk b gy no np l nq nr">axiosInstance.interceptors.response.use(<br/>  response =&gt; { return response; }, error =&gt; {<br/>    if (errorSatifiesConditions(error)) {<br/>      return doSomething().then({....<br/>      // could be to resend original request <br/>      )} <br/>    }  else {<br/>      doSomethingElse()...</span></pre></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="b6b0" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><a class="ae mw" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">了解</a>React hooks—React v 16，2019年2月—</h2><p id="eecc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在本教程中，我将使用React钩子，即:useState和useContext。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="8344" class="kv kw iq bd kx ky ns la lb lc nt le lf jw nu jx lh jz nv ka lj kc nw kd ll lm bi translated">我们开始吧</h1><p id="7072" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我将向您简要介绍身份认证模块的运行和服务方式，然后，我将它分解为更小的组件，以便您了解所有内容。</p><h1 id="1888" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">解释逻辑</h1><p id="6f85" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">第一步是用户输入URL。如果这个用户以前登录过，你的应用程序应该检查<em class="mv"> localStorage </em>。</p><ul class=""><li id="977a" class="nx ny iq lp b lq ne lt nf lw nz ma oa me ob mi oc od oe of bi translated"><strong class="lp ir">答——如果在<em class="mv"> localStorage、</em> </strong>中有关于用户的信息，你的React应用将继续查看用户的access_token是否仍然有效。<br/> <em class="mv">如果</em> <code class="fe og oh oi nk b"><em class="mv">access_token</em></code> <em class="mv">处于活动状态，则</em>用户准备就绪，并成功通过认证。<br/> <em class="mv">如果</em> <code class="fe og oh oi nk b"><em class="mv">access_token</em></code> <em class="mv">过期，</em>您的应用程序应该发送一个<code class="fe og oh oi nk b">refreshToken</code>请求并获得一个新的<code class="fe og oh oi nk b">access_token</code></li><li id="4f65" class="nx ny iq lp b lq oj lt ok lw ol ma om me on mi oc od oe of bi translated"><strong class="lp ir"> B-如果<em class="mv"> localStorage、</em> </strong>中没有关于用户的信息，你的<strong class="lp ir"> <em class="mv"> </em> </strong>应用程序应该将用户重定向到一个登录页面，在那里他们可以给出用户名和密码(或注册页面)。</li></ul><p id="94b8" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">负责A的功能是<code class="fe og oh oi nk b">getUser()</code>，做B的功能是<code class="fe og oh oi nk b">login(username, password)</code>。</p><p id="6f79" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated"><strong class="lp ir">所以，</strong> <strong class="lp ir">主要思路是</strong>，一旦app启动，app调用<code class="fe og oh oi nk b">getUser()</code>要么认证用户，要么不认证。<br/>如果不是，则应用程序使用用户凭证调用<code class="fe og oh oi nk b">login</code>，并且<code class="fe og oh oi nk b">login</code>函数调用<code class="fe og oh oi nk b">getUser</code>来获取<code class="fe og oh oi nk b">currUser</code>信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/12c1a0d90f46ef911b628b39b7fc9c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*702e1Nixoa-A4lH2__fpiQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo from pexels.com</figcaption></figure><h1 id="ed18" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">为了让它更容易</h1><h2 id="e7ec" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><em class="op"> constants.js </em></h2><p id="5d3a" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">创建一个包含所有常量的constants.js文件，这样您就不必在每次调用端点时都键入常量。<br/>有了<code class="fe og oh oi nk b">axios.create</code>就更抽象<em class="mv">更容易使用。<br/> <strong class="lp ir"> my_app是axios实例</strong>。</em></p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="2e31" class="mj kw iq nk b gy no np l nq nr">import axios from "axios";</span><span id="d56c" class="mj kw iq nk b gy oq np l nq nr">export const URL = "https://your/url.com";<br/>export const API_URL = "https://your/api/url.com";<br/>export const my_app = axios.create({baseURL: API_URL});</span></pre><h1 id="fa5a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">设置对API的调用— <em class="op"> auth.js </em></h1><p id="8395" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">创建一个包含所有函数的auth.js文件。</p><h2 id="645f" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><code class="fe og oh oi nk b"><em class="op">1. refreshToken</em></code></h2><p id="c7e2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对刷新端点的基本调用。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="802e" class="mj kw iq nk b gy no np l nq nr">const refreshToken = () =&gt; {</span><span id="ced6" class="mj kw iq nk b gy oq np l nq nr">  let currUser = JSON.parse(localStorage.getItem("my_app_user"));</span><span id="33b9" class="mj kw iq nk b gy oq np l nq nr">  let getUserFormData = new FormData();</span><span id="0183" class="mj kw iq nk b gy oq np l nq nr">  getUserFormData.append("grant_type", "refresh_token");</span><span id="159b" class="mj kw iq nk b gy oq np l nq nr">  getUserFormData.append("refresh_token", currUser.refresh_token);</span><span id="6d41" class="mj kw iq nk b gy oq np l nq nr">  return new Promise((resolve, reject) =&gt; {</span><span id="c8bc" class="mj kw iq nk b gy oq np l nq nr">    my_app</span><span id="3edc" class="mj kw iq nk b gy oq np l nq nr">    .post(`${URL}/token/url/`, getUserFormData, {</span><span id="1094" class="mj kw iq nk b gy oq np l nq nr">      headers: {</span><span id="726b" class="mj kw iq nk b gy oq np l nq nr">        Authorization: "Basic {secret_key}"</span><span id="9337" class="mj kw iq nk b gy oq np l nq nr">      }</span><span id="29c3" class="mj kw iq nk b gy oq np l nq nr">    })</span><span id="92b4" class="mj kw iq nk b gy oq np l nq nr">    .then(async response =&gt; {</span><span id="033c" class="mj kw iq nk b gy oq np l nq nr">      resolve(response);</span><span id="582f" class="mj kw iq nk b gy oq np l nq nr">    })</span><span id="fbc0" class="mj kw iq nk b gy oq np l nq nr">    .catch(error =&gt; {</span><span id="7926" class="mj kw iq nk b gy oq np l nq nr">      reject(error);</span><span id="4d20" class="mj kw iq nk b gy oq np l nq nr">    });</span><span id="e36d" class="mj kw iq nk b gy oq np l nq nr">  });</span><span id="6af4" class="mj kw iq nk b gy oq np l nq nr">};</span></pre><h2 id="ff58" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated">2.<code class="fe og oh oi nk b"><em class="op">getUser</em></code></h2><p id="9b7b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe og oh oi nk b">getUser</code> <em class="mv"> </em>负责检查<em class="mv"> localStorage </em>中是否存储有用户。如果没有找到，它返回null。</p><p id="aca6" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如果它在<em class="mv"> localStorage </em> <strong class="lp ir"> <em class="mv">，</em> </strong>中找到一个用户，它会获取该用户的<code class="fe og oh oi nk b">access_token </code>上次刷新的日期，并从当前时间中减去该日期，然后将其与<code class="fe og oh oi nk b">access_token</code>的到期时间进行比较。如果它仍然有效，它继续并获得<code class="fe og oh oi nk b">currUser</code>信息。</p><p id="b636" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如果无效，它调用<code class="fe og oh oi nk b">refreshToken</code>端点并用新的接入点替换它，并重置<em class="mv"> localStorage </em>中<code class="fe og oh oi nk b">currUser</code>中的<code class="fe og oh oi nk b">lastRefresh</code>。你不应该忘记用新的访问令牌替换axios实例的头。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="714d" class="mj kw iq nk b gy no np l nq nr">my_app.defaults.headers.common["Authorization"] =<br/>"Bearer " + currUser.access_token;</span></pre><p id="2bda" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated"><strong class="lp ir"> Axios拦截器:<br/> </strong>您将使用Axios拦截器拦截任何请求，如果请求失败，错误状态代码代表过期的访问令牌(通常:401，错误消息不同)。这意味着授权失败，因为<code class="fe og oh oi nk b">access_token</code>已经过期。<br/>在这种情况下，您需要发送一个<code class="fe og oh oi nk b"><em class="mv">refreshToken</em></code>请求，然后用从<code class="fe og oh oi nk b"><em class="mv">refreshToken</em></code>请求中带回的新的有效<code class="fe og oh oi nk b">access_token </code>重新发送一开始失败的请求。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="a113" class="mj kw iq nk b gy no np l nq nr">my_app.interceptors.response.use(</span><span id="0f65" class="mj kw iq nk b gy oq np l nq nr">response =&gt; { return response; },</span><span id="2de9" class="mj kw iq nk b gy oq np l nq nr">error =&gt; {</span><span id="c4e6" class="mj kw iq nk b gy oq np l nq nr">if (error.response.status === 401 &amp;&amp; error.response.message === "blablabla") {</span><span id="e788" class="mj kw iq nk b gy oq np l nq nr">return refreshToken().then({....</span><span id="20ed" class="mj kw iq nk b gy oq np l nq nr">// resend original request</span></pre><p id="4c12" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">最后，如果<code class="fe og oh oi nk b">login</code>或<code class="fe og oh oi nk b"> getUserInfo</code>或<code class="fe og oh oi nk b">refreshToken</code>请求失败，您应该注销并从<em class="mv"> localStorage </em>中删除<code class="fe og oh oi nk b">currUser</code>，因为这样更安全，并且会将用户重定向到登录页面。您也可以在这里处理特定类型的错误。比如特定网络错误等等。</p><p id="5bc8" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">一个<code class="fe og oh oi nk b">refreshToken</code>请求可能失败的一个原因是<code class="fe og oh oi nk b">refresh_token</code>已经过期的罕见情况。请求令牌的生存期相对来说比<code class="fe og oh oi nk b">access_token</code>长得多，但是它仍然有可能过期，在这种情况下，您应该使用前面提到的<code class="fe og oh oi nk b">logout</code>将用户重定向到登录页面。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="5f49" class="mj kw iq nk b gy no np l nq nr">const getUser = () =&gt; {</span><span id="b5d8" class="mj kw iq nk b gy oq np l nq nr">  let currUser = JSON.parse(localStorage.getItem("my_app_user"));</span><span id="86d1" class="mj kw iq nk b gy oq np l nq nr">  if (!currUser) {<br/>    // if no user in localStorage then the user must enter their      credentials to proceed</span><span id="fa4a" class="mj kw iq nk b gy oq np l nq nr">    return Promise.resolve(null);</span><span id="1de1" class="mj kw iq nk b gy oq np l nq nr">  }</span><span id="ae6b" class="mj kw iq nk b gy oq np l nq nr">  // get the expiry time of the current access token and measure   whether it expired or not</span><span id="f1c7" class="mj kw iq nk b gy oq np l nq nr">  let currDate = new Date();</span><span id="8120" class="mj kw iq nk b gy oq np l nq nr">  let diff = currDate.getTime() - currUser.lastRefresh;</span><span id="b6a6" class="mj kw iq nk b gy oq np l nq nr">  if (diff &gt;= currUser["expires_in"] * 1000) {</span><span id="8c56" class="mj kw iq nk b gy oq np l nq nr">    // access token expired need to refresh token</span><span id="86d2" class="mj kw iq nk b gy oq np l nq nr">    // you could just call refreshToken I just typed it in so you could see it clearer</span><span id="3c61" class="mj kw iq nk b gy oq np l nq nr">    // call refreshToken()</span><span id="612e" class="mj kw iq nk b gy oq np l nq nr">    // if success, update currUser with the new access_token and save this instant to be the last_refresh (for future refresh) and update axios headers</span><span id="c2a8" class="mj kw iq nk b gy oq np l nq nr">    // if fail logout()</span><span id="f15c" class="mj kw iq nk b gy oq np l nq nr">  } else {</span><span id="d957" class="mj kw iq nk b gy oq np l nq nr">  // Do not need refresh</span><span id="efce" class="mj kw iq nk b gy oq np l nq nr">  my_app.defaults.headers.common["Authorization"] =<br/>"Bearer " + currUser.access_token;</span><span id="4f38" class="mj kw iq nk b gy oq np l nq nr">  my_app.interceptors.response.use(</span><span id="3bf0" class="mj kw iq nk b gy oq np l nq nr">  response =&gt; {</span><span id="998e" class="mj kw iq nk b gy oq np l nq nr">    return response;</span><span id="73ba" class="mj kw iq nk b gy oq np l nq nr">  },</span><span id="33a7" class="mj kw iq nk b gy oq np l nq nr">  error =&gt; {</span><span id="21c7" class="mj kw iq nk b gy oq np l nq nr">    if (error.response.status === 401 &amp;&amp; some other condition that sprecifies an expir state){</span><span id="0231" class="mj kw iq nk b gy oq np l nq nr">    // 401 is Unauthorized error</span><span id="55e4" class="mj kw iq nk b gy oq np l nq nr">    // which means that this request failed</span><span id="b4e9" class="mj kw iq nk b gy oq np l nq nr">    // what we need to do is send a refresh request then resend the same request</span><span id="dd32" class="mj kw iq nk b gy oq np l nq nr">    // that failed but with the new access point.</span><span id="f917" class="mj kw iq nk b gy oq np l nq nr">    // We can do this automatically using axios interceptors</span><span id="ca35" class="mj kw iq nk b gy oq np l nq nr">    return refreshToken()</span><span id="6c8d" class="mj kw iq nk b gy oq np l nq nr">    .then(response =&gt; {<br/>    <br/>      // update currUser with new access_token</span><span id="7d10" class="mj kw iq nk b gy oq np l nq nr">      // Set default headers to have authorization the access token as authorization for future requests</span><span id="c4e1" class="mj kw iq nk b gy oq np l nq nr">      // Get the original that failed due to 401 and resend it</span><span id="e5e0" class="mj kw iq nk b gy oq np l nq nr">      // with the new access token</span><span id="d372" class="mj kw iq nk b gy oq np l nq nr">      const config = error.config;</span><span id="6751" class="mj kw iq nk b gy oq np l nq nr">      config.headers.Authorization =</span><span id="52b9" class="mj kw iq nk b gy oq np l nq nr">      "Bearer " + response.data.access_token;</span><span id="aaff" class="mj kw iq nk b gy oq np l nq nr">      // Resending original request</span><span id="8ece" class="mj kw iq nk b gy oq np l nq nr">      return new Promise((resolve, reject) =&gt; {</span><span id="e8a0" class="mj kw iq nk b gy oq np l nq nr">      my_app</span><span id="db8c" class="mj kw iq nk b gy oq np l nq nr">      .request(config)</span><span id="710b" class="mj kw iq nk b gy oq np l nq nr">      .then(response =&gt; { resolve(response); })</span><span id="9d14" class="mj kw iq nk b gy oq np l nq nr">      .catch(error =&gt; { reject(error); });</span><span id="7200" class="mj kw iq nk b gy oq np l nq nr">      });</span><span id="6233" class="mj kw iq nk b gy oq np l nq nr">    })</span><span id="0ba6" class="mj kw iq nk b gy oq np l nq nr">    .catch(error =&gt; { // just logout() if anything goes wrong});<br/>    }</span><span id="26e1" class="mj kw iq nk b gy oq np l nq nr">    logout();</span><span id="5b28" class="mj kw iq nk b gy oq np l nq nr">    return new Promise((resolve, reject) =&gt; { reject(error); });</span><span id="061e" class="mj kw iq nk b gy oq np l nq nr">    }</span><span id="cfd2" class="mj kw iq nk b gy oq np l nq nr">  );</span><span id="bea3" class="mj kw iq nk b gy oq np l nq nr">  // finally get user </span><span id="341a" class="mj kw iq nk b gy oq np l nq nr">  return my_app.get("/users/current/url").catch(error =&gt; {</span><span id="234f" class="mj kw iq nk b gy oq np l nq nr">    logout();</span><span id="0f64" class="mj kw iq nk b gy oq np l nq nr">    throw error;</span><span id="bb0b" class="mj kw iq nk b gy oq np l nq nr">   });<br/>  }<br/>};</span></pre><h2 id="f88d" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated">3.<code class="fe og oh oi nk b"><em class="op">login</em></code></h2><p id="f5c2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这个函数简单地获取用户名和密码，并将它们和密钥一起发送过来进行身份验证。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="3947" class="mj kw iq nk b gy no np l nq nr">const login = (username, password) =&gt; {</span><span id="15fd" class="mj kw iq nk b gy oq np l nq nr">  let loginFormData = new FormData();</span><span id="3038" class="mj kw iq nk b gy oq np l nq nr">  loginFormData.append("grant_type", "password");</span><span id="423b" class="mj kw iq nk b gy oq np l nq nr">  loginFormData.append("username", username);</span><span id="cae3" class="mj kw iq nk b gy oq np l nq nr">  loginFormData.append("password", password);</span><span id="f6bd" class="mj kw iq nk b gy oq np l nq nr">  return new Promise((resolve, reject) =&gt; {</span><span id="f7f1" class="mj kw iq nk b gy oq np l nq nr">    axios</span><span id="8f91" class="mj kw iq nk b gy oq np l nq nr">    .post(`${URL}/token/url`, loginFormData, {</span><span id="573b" class="mj kw iq nk b gy oq np l nq nr">    headers: { Authorization: "Basic {secret_key}" }</span><span id="fe28" class="mj kw iq nk b gy oq np l nq nr">    })</span><span id="6f0e" class="mj kw iq nk b gy oq np l nq nr">    .then(async response =&gt; {</span><span id="3c48" class="mj kw iq nk b gy oq np l nq nr">      response.data.lastRefresh = new Date().getTime();</span><span id="5bf9" class="mj kw iq nk b gy oq np l nq nr">      localStorage.setItem("my_app_user", JSON.stringify(response.data));</span><span id="dd8c" class="mj kw iq nk b gy oq np l nq nr">      getUser()</span><span id="4039" class="mj kw iq nk b gy oq np l nq nr">      .then(response =&gt; { resolve(response); })</span><span id="5801" class="mj kw iq nk b gy oq np l nq nr">      .catch(error =&gt; { reject(error); });  </span><span id="e1e9" class="mj kw iq nk b gy oq np l nq nr">      })</span><span id="9765" class="mj kw iq nk b gy oq np l nq nr">      .catch(error =&gt; { reject(error); });</span><span id="3432" class="mj kw iq nk b gy oq np l nq nr">      });</span><span id="c9aa" class="mj kw iq nk b gy oq np l nq nr">    };</span></pre><h2 id="da94" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated">4.<code class="fe og oh oi nk b">logout</code></h2><p id="3a30" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">基本上只是从<em class="mv">本地存储器</em>中删除<code class="fe og oh oi nk b">currUser</code>。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="65ba" class="mj kw iq nk b gy no np l nq nr">const logout = () =&gt; {</span><span id="817b" class="mj kw iq nk b gy oq np l nq nr">  localStorage.removeItem("my_app_user");</span><span id="1f57" class="mj kw iq nk b gy oq np l nq nr">  return Promise.resolve();</span><span id="3f70" class="mj kw iq nk b gy oq np l nq nr">};</span></pre><h2 id="9171" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><em class="op"> 5。认证上下文</em></h2><p id="80f7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这个上下文将一直保存你的用户变量。从<code class="fe og oh oi nk b">user</code>你就能知道。</p><ol class=""><li id="999e" class="nx ny iq lp b lq ne lt nf lw nz ma oa me ob mi or od oe of bi translated">无论是否有用户登录。</li><li id="1a65" class="nx ny iq lp b lq oj lt ok lw ol ma om me on mi or od oe of bi translated">用户信息。</li></ol><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="8b39" class="mj kw iq nk b gy no np l nq nr">import React, { createContext, useState } from "react";</span><span id="d09f" class="mj kw iq nk b gy oq np l nq nr">import auth from "../helpers/auth";</span><span id="bef2" class="mj kw iq nk b gy oq np l nq nr">import LoadingPage from "../components/LoadingPage";</span><span id="e170" class="mj kw iq nk b gy oq np l nq nr">export const AuthenticationContext = createContext();</span><span id="260c" class="mj kw iq nk b gy oq np l nq nr">const AuthenticationContextProvider = props =&gt; {</span><span id="e7b5" class="mj kw iq nk b gy oq np l nq nr">  const [user, setUser] = useState(null);</span><span id="d9c0" class="mj kw iq nk b gy oq np l nq nr">  const [fetched, setFetched] = useState(false);</span><span id="f89e" class="mj kw iq nk b gy oq np l nq nr">  const login = (username, password) =&gt; {</span><span id="b28e" class="mj kw iq nk b gy oq np l nq nr">    return auth.login(username, password).then(data =&gt; {</span><span id="6935" class="mj kw iq nk b gy oq np l nq nr">    setUser(data.data);</span><span id="c37b" class="mj kw iq nk b gy oq np l nq nr">});</span><span id="186a" class="mj kw iq nk b gy oq np l nq nr">};</span><span id="a48b" class="mj kw iq nk b gy oq np l nq nr">const logout = async () =&gt; {</span><span id="83f9" class="mj kw iq nk b gy oq np l nq nr">  setUser(null);</span><span id="aac5" class="mj kw iq nk b gy oq np l nq nr">  await auth.logout();</span><span id="50f3" class="mj kw iq nk b gy oq np l nq nr">};</span><span id="d6c9" class="mj kw iq nk b gy oq np l nq nr">const getUser = async () =&gt; {</span><span id="0b44" class="mj kw iq nk b gy oq np l nq nr">  const user = await auth.getUser();</span><span id="89f6" class="mj kw iq nk b gy oq np l nq nr">  setUser(user ? user.data : null);</span><span id="2818" class="mj kw iq nk b gy oq np l nq nr">};</span><span id="1b74" class="mj kw iq nk b gy oq np l nq nr">if (!fetched) {</span><span id="476d" class="mj kw iq nk b gy oq np l nq nr">  getUser().then(() =&gt; setFetched(true));</span><span id="54db" class="mj kw iq nk b gy oq np l nq nr">}</span><span id="766b" class="mj kw iq nk b gy oq np l nq nr">if (!fetched) {</span><span id="9fdc" class="mj kw iq nk b gy oq np l nq nr">  return &lt;LoadingPage /&gt;;</span><span id="3e9f" class="mj kw iq nk b gy oq np l nq nr">}</span><span id="c8d7" class="mj kw iq nk b gy oq np l nq nr">return (</span><span id="2a00" class="mj kw iq nk b gy oq np l nq nr">  &lt;AuthenticationContext.Provider</span><span id="bfe5" class="mj kw iq nk b gy oq np l nq nr">  value={{</span><span id="e3dc" class="mj kw iq nk b gy oq np l nq nr">    user,</span><span id="db8e" class="mj kw iq nk b gy oq np l nq nr">    login,</span><span id="5fba" class="mj kw iq nk b gy oq np l nq nr">    logout,</span><span id="0004" class="mj kw iq nk b gy oq np l nq nr">    getUser,</span><span id="3740" class="mj kw iq nk b gy oq np l nq nr">    setUser</span><span id="b080" class="mj kw iq nk b gy oq np l nq nr">  }}</span><span id="e406" class="mj kw iq nk b gy oq np l nq nr">  &gt;</span><span id="2e38" class="mj kw iq nk b gy oq np l nq nr">    {props.children}</span><span id="0bef" class="mj kw iq nk b gy oq np l nq nr">  &lt;/AuthenticationContext.Provider&gt;</span><span id="a11d" class="mj kw iq nk b gy oq np l nq nr">  );</span><span id="69cd" class="mj kw iq nk b gy oq np l nq nr">};</span><span id="1ef3" class="mj kw iq nk b gy oq np l nq nr">export { AuthenticationContextProvider };</span></pre><p id="3464" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated"><code class="fe og oh oi nk b"><strong class="lp ir">fetched</strong></code> <strong class="lp ir">让你知道你已经尝试获取</strong> <code class="fe og oh oi nk b">currUser</code>，如果找到，用户信息将在<code class="fe og oh oi nk b">user</code>中，否则将为空。</p><p id="7461" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">下面是启动之前解释过的授权过程的部分代码。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="cf41" class="mj kw iq nk b gy no np l nq nr">if (!fetched) {</span><span id="cfce" class="mj kw iq nk b gy oq np l nq nr">  getUser().then(() =&gt; setFetched(true));</span><span id="2763" class="mj kw iq nk b gy oq np l nq nr">}</span></pre><h2 id="793a" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated">6 <em class="op">。最后一步</em></h2><p id="81c1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这一步是您的<strong class="lp ir">认证开关</strong>，它根据上下文中的<code class="fe og oh oi nk b">user</code>将用户重定向到经过认证的页面或未经认证的登录页面。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="dd7c" class="mj kw iq nk b gy no np l nq nr">const { user } = useContext(AuthenticationContext);</span><span id="704b" class="mj kw iq nk b gy oq np l nq nr">return user ? &lt;AuthenticatedApp /&gt; : &lt;UnauthenticatedApp /&gt;;</span></pre><h2 id="3ed3" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated">重要说明</h2><p id="662c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">将您的路线和路由器放在<code class="fe og oh oi nk b">Authenticatedapp</code>中会大大简化您的路线选择；如果用户成功通过身份验证，他们将被重定向到他们键入的URL的相应路由，而不是您手动进行路由。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><blockquote class="os ot ou"><p id="9046" class="ln lo mv lp b lq ne jr ls lt nf ju lv ov ng ly lz ow nh mc md ox ni mg mh mi ij bi translated"><strong class="lp ir">最后</strong>，这是一个完整的基于令牌的React认证教程。我希望你已经学会了。如果你有任何问题，请不要犹豫地问。</p><p id="1b09" class="ln lo mv lp b lq ne jr ls lt nf ju lv ov ng ly lz ow nh mc md ox ni mg mh mi ij bi translated">你会在这个<a class="ae mw" href="https://github.com/SalmaGhoneim/React-token-based-authentication-module-with-Axios-Interceptors-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到所有的代码文件。</p></blockquote></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="970a" class="mj kw iq bd kx mk ml dn lb mm mn dp lf lw mo mp lh ma mq mr lj me ms mt ll mu bi translated"><strong class="ak">简明英语笔记</strong></h2><p id="629b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae mw" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="lp ir">JavaScript in Plain English</strong></a>，<a class="ae mw" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="lp ir">AI in Plain English</strong></a>，<a class="ae mw" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="lp ir">UX in Plain English</strong></a>，<a class="ae mw" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="lp ir">Python in Plain English</strong></a><strong class="lp ir"/>—谢谢，继续学习！</p><p id="79f0" class="pw-post-body-paragraph ln lo iq lp b lq ne jr ls lt nf ju lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae mw" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">submissions @ plain English . io</strong></a><strong class="lp ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>