<html>
<head>
<title>Using the JavaScript History API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript历史API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-javascript-history-api-589948f05b18?source=collection_archive---------11-----------------------#2020-11-07">https://javascript.plainenglish.io/using-the-javascript-history-api-589948f05b18?source=collection_archive---------11-----------------------#2020-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6c58" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让读者更顺畅地浏览JavaScript增强的网站</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/151167bd9fb4677e63ad9d925aa66a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6kBxUGymvez3aDm9"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kylejglenn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kyle Glenn</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="932c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">历史简史</h2><p id="952b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">后退按钮是网络的“撤销”，实际上是仅次于超链接的杀手锏。后退按钮的可用性和简单性使得链接跟踪成为一种廉价的、非破坏性的操作。后退按钮鼓励读者多浏览。</p><p id="3efc" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在JavaScript出现之前，后退按钮的作用很简单:返回上一页，即URL。这是字面上的意思，但是客户端技术的进步现在让我们质疑页面是什么，它与URL的对应程度如何。</p><p id="eb7e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">例如，考虑一个包含选项卡式界面的页面，其中一组链接显示内容的不同部分。这些是独立的“页面”吗？浏览器历史，包括后退按钮，应该如何在它们之间导航？</p><h2 id="5438" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">重估历史</h2><p id="bb4e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">很明显，对于JavaScript增强的页面，我们需要一些额外的细微差别来处理历史。令人欣慰的是，<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" rel="noopener ugc nofollow" target="_blank">历史Web API </a>可以帮上忙。<code class="fe mq mr ms mt b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/History" rel="noopener ugc nofollow" target="_blank">History</a></code>界面不仅允许以编程方式浏览浏览器历史，它还包含修改历史的方法，包括在历史堆栈中每个条目旁边存储额外的自定义状态。</p><p id="ae31" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe mq mr ms mt b">replaceState()</code>方法允许更新历史中当前页面的条目，以响应客户端可能发生的其他事件:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="8e4e" class="kw kx iq mt b gy my mz l na nb">history.replaceState(<em class="nc">stateObj</em>, <em class="nc">title</em>, [<em class="nc">url</em>])</span></pre><h1 id="a5a5" class="nd kx iq bd ky ne nf ng lb nh ni nj le jw nk jx li jz nl ka lm kc nm kd lq nn bi translated">短期变化</h1><p id="203a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">对于只涉及特定导航实例的完全瞬时状态的更改，使用历史的<em class="nc"> stateObj </em>参数来保持一致性。在这个取自我自己的站点的例子中，我跟踪了一个表当前被排序的列:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="51e8" class="kw kx iq mt b gy my mz l na nb">table.addEventListener("click", function(ev) {<br/>    var index;</span><span id="6885" class="kw kx iq mt b gy no mz l na nb">    if (ev.target.parentNode.parentNode.parentNode.tagName<br/>        == 'THEAD'<br/>    ) {<br/>        ev.preventDefault();<br/>        index = siblingIndex(ev.target.parentNode);<br/>        sortRows(table, index);<br/><strong class="mt ir">        history.replaceState({ "sort": index }, "");</strong><br/>    }<br/>}</span></pre><p id="e057" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">注意<em class="nc"> title </em>参数是必需的，即使为空，但是<em class="nc"> url </em>可以省略。</p><p id="6d0b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在页面加载时，状态被读取，并相应地采取行动:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="1940" class="kw kx iq mt b gy my mz l na nb">window.addEventListener("load", function(ev) {<br/>    if (history.state &amp;&amp; history.state.hasOwnProperty("sort")) {<br/>        sortRows(table, history.state.sort);<br/>    }<br/>});</span></pre><p id="6c19" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我使用<code class="fe mq mr ms mt b">if (history.state.hasOwnProperty("sort"))</code>而不是更简单的<code class="fe mq mr ms mt b">if (history.state)</code>来避免在存储第一列的<code class="fe mq mr ms mt b">0</code>索引时出现假阴性。</p><h1 id="2345" class="nd kx iq bd ky ne nf ng lb nh ni nj le jw nk jx li jz nl ka lm kc nm kd lq nn bi translated">稍微长期一点</h1><p id="e2a8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">请注意，上面的示例没有对您在对表格进行排序时所查看的URL进行任何更改。这可能没问题，但是如果您希望新状态作为一个独立的页面存在，您可能还需要修改URL。</p><p id="eff0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这种方法的一个潜在用途是引入链接。如果您希望读者能够对您的表进行排序，然后将结果视图标记为书签，或者从其他地方链接到该特定视图，那么最好提供一个唯一的URL来表示该状态。这是我在自己的网站上使用的<a class="ae kv" href="https://bobbyjack.me/2020/03/16/all-switch-purchases" rel="noopener ugc nofollow" target="_blank">方法；尝试对表格进行排序，导航到其中一个游戏标题，然后使用后退按钮返回。</a></p><p id="d71d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这一次，我们可以使用URL参数将排序状态数据从历史的state对象移动到URL本身:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="60be" class="kw kx iq mt b gy my mz l na nb">table.addEventListener("click", function(ev) {<br/>    var index<strong class="mt ir">, url</strong>;</span><span id="6d98" class="kw kx iq mt b gy no mz l na nb">    if (ev.target.parentNode.parentNode.parentNode.tagName<br/>        == 'THEAD'<br/>    ) {<br/>        ev.preventDefault();<br/>        index = siblingIndex(ev.target.parentNode);<br/>        sortRows(table, index);<br/><strong class="mt ir">        url = new URL(window.location);<br/>        url.searchParams.set("sort", index);<br/>        history.replaceState(null, "", url);</strong><br/>    }<br/>}</span></pre><p id="e5a0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">创建一个<code class="fe mq mr ms mt b">URL</code>对象是为了使搜索参数处理更加容易。该url然后作为可选的第三个参数发送给<code class="fe mq mr ms mt b">replaceState()</code>。对此状态的操作类似于前面的示例:</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="ac0f" class="kw kx iq mt b gy my mz l na nb">window.addEventListener("load", function(ev) {<br/>    var sort;<br/>    var url = new URL(window.location);<br/>        <br/>    if (sort = url.searchParams.get("sort")) {<br/>        sortRows(table, parseInt(sort));<br/>    }<br/>});</span></pre><p id="4243" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">逻辑本质上是相同的(获取任何现有的状态，根据它对表进行排序)，但是这次在状态的存储方式上有一个重要的区别:URL参数总是字符串，所以我们需要首先对列索引进行<code class="fe mq mr ms mt b">parseInt()</code>。</p><p id="d5f0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这一次，当我们按不同的列对表进行排序时，URL将发生变化(这是调用replaceState的副作用)。但是，请注意，它不会在历史堆栈中创建任何额外的条目:我们正在替换当前条目，而不是添加到历史中。在实践中，这意味着如果你已经点击了几列来依次排序，你不必一直点击“返回”来返回到上一页。历史记录中只存储最近的url。</p><h1 id="108c" class="nd kx iq bd ky ne nf ng lb nh ni nj le jw nk jx li jz nl ka lm kc nm kd lq nn bi translated">更长期和持久</h1><p id="cb5e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果您希望更持久地存储这类信息，或者在全局基础上存储，可以使用History API的替代方法。例如，您的站点可能包含许多表，每个表都共享一个相似的结构，如果读者按特定的列对一个表进行排序，您可能希望该选择适用于所有表。</p><p id="6d45" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">长期的选择包括在静态站点上进行客户端处理的本地存储(甚至是cookies ),甚至是后端服务器上的全面数据库存储。</p><p id="30eb" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">无论您选择哪种方法，都要考虑当读者与页面上的某个元素进行交互，离开，然后返回到他们可能认为的“同一页面”时会发生什么。</p><p id="87ba" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="lu ir">！</strong></p></div></div>    
</body>
</html>