<html>
<head>
<title>The only React Router set-up you will ever need</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您需要的唯一React路由器设置</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-only-react-router-set-up-you-will-ever-need-9f36ddee03a5?source=collection_archive---------1-----------------------#2020-01-12">https://javascript.plainenglish.io/the-only-react-router-set-up-you-will-ever-need-9f36ddee03a5?source=collection_archive---------1-----------------------#2020-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文旨在构建4个常见的路由需求<strong class="jp ir"> </strong>，为您的React web应用程序提供一个坚如磐石的路由基础设施。</p><p id="2fe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的承诺是，在您阅读结束时，我们会提供一个干净、可扩展的路由基础设施，它具有以下特性:</p><ul class=""><li id="b5d5" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">向页面添加布局</li><li id="e2ba" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">嵌套路线</li><li id="55f2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">保护路由，添加授权</li><li id="2774" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">将道具传递给组件</li></ul><h1 id="0c7e" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">概观</h1><p id="1191" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如果你正在工作或曾经在前端工作，我愿意打赌，你曾经搜索过任何上述路由功能。我知道我有。</p><p id="f89d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单的谷歌搜索可以很容易地产生构建这些功能的解决方案。但是根据我的经验，这些解决方案在孤立的情况下工作得很好，这还不够好。</p><p id="feaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章背后的动机是统一每个特性的工程。创建一个强大的无冲突扩展的路由基础设施，这样您就可以专注于前端真正重要的事情。</p><blockquote class="md"><p id="c29c" class="me mf iq bd mg mh mi mj mk ml mm kk dk translated">使<div>居中</div></p></blockquote><h1 id="1aa5" class="kz la iq bd lb lc ld le lf lg lh li lj lk mn lm ln lo mo lq lr ls mp lu lv lw bi translated">让我们建造一些东西</h1><p id="ec14" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了查看基础设施的运行情况，我们将使用它构建一个简单的React web应用程序。</p><p id="5872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">**完整源代码<a class="ae mq" href="https://github.com/marxlow/react-router-layout-guide" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mc">此处</em> </strong> </a></p><p id="15b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有5个步骤，每个步骤都在前一个步骤的基础上增加一个额外的功能。</p><p id="8aab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，如果你不熟悉React路由器的官方网站<a class="ae mq" href="https://reacttraining.com/react-router/web/api/Route" rel="noopener ugc nofollow" target="_blank">这里</a>，我建议你复习一下React路由器的<code class="fe mr ms mt mu b">&lt;Route&gt;</code>组件。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b559ea33bce9bbb584a8e512d0f58740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*PxFbkEX557g47LYTG0OeSg.gif"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">The end product of what we will be building. (focus on its routing)</figcaption></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="e544" class="no la iq bd lb np nq dn lf nr ns dp lj jy nt nu ln kc nv nw lr kg nx ny lv nz bi translated">1.基本路由</h2><p id="a07c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们将首先为一个简单的登录和仪表板页面构建路由。</p><pre class="mw mx my mz gt oa mu ob oc aw od bi"><span id="ef99" class="no la iq mu b gy oe of l og oh">import { Router, Route, Switch, Redirect } from "react-router-dom";<br/>import LoginPage from './pages/LoginPage';<br/>import DashboardPage from './pages/DashboardPage';</span><span id="456f" class="no la iq mu b gy oi of l og oh">&lt;Router&gt;<br/>  &lt;Switch&gt;<br/>    &lt;Route exact path="/login" component={LoginPage}<br/>    &lt;Route exact path="/dashboard" component={DashboardPage}<br/>  &lt;/Switch&gt;<br/>&lt;/Route&gt;</span></pre><p id="ccd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没有太多的事情发生。不出所料，任何匹配<code class="fe mr ms mt mu b">path</code>道具的URL都会呈现我们的<code class="fe mr ms mt mu b">component</code>。例如，“/log in”URL将呈现我们的LoginPage组件—很好！</p><p id="278a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的仪表板和登录页面现在有不同的布局，如下所示。假设我们想要添加一个新的“/settings”页面，其布局与我们的仪表板页面(右图)相同。应该怎么做？</p><div class="mw mx my mz gt ab cb"><figure class="oj na ok ol om on oo paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><img src="../Images/e2940506673e11247ed0e3932d8fb10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*H2eZp58GMNmoPWcd_1VWwQ.png"/></div></figure><figure class="oj na ot ol om on oo paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><img src="../Images/7326fae35e64926156cd16f7033ab8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*XPMwldU7wtK_0qyTxZaXtw.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk ou di ov ow">Login &amp; Dashboard page</figcaption></figure></div></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="e7ab" class="no la iq bd lb np nq dn lf nr ns dp lj jy nt nu ln kc nv nw lr kg nx ny lv nz bi translated">2.添加布局</h2><p id="3fc6" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们可以轻松地将仪表板组件中的代码复制到新的设置组件中。但是这不仅违反了DRY(不要重复自己)原则，而且也是非常不可扩展的。想象一下，每次为需要布局的新页面复制相同的代码。</p><p id="e7f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好的方法是使布局可重用。</p><p id="30d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将布局结构从<code class="fe mr ms mt mu b">DashboardPage</code>重构到它自己的组件中，我们可以将它作为父组件来包装所有需要它的子组件，如下所示:</p><p id="e9ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(我将其命名为<code class="fe mr ms mt mu b">AuthLayout.js</code>,因为这些页面稍后需要授权)</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi ox"><img src="../Images/5daf7eb7bb4957c4854552fd7514b205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIdZrLKP5n1tIE3npOYrSg.png"/></div></div></figure><p id="cc4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建好布局组件后，下一个挑战是找到如何以及在哪里用它包装页面。</p><p id="8cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现最好的方法是使用<code class="fe mr ms mt mu b">&lt;Route/&gt;</code>中的<code class="fe mr ms mt mu b">render</code>道具。<code class="fe mr ms mt mu b">render</code>接收一个函数，当我们的URL与<code class="fe mr ms mt mu b">path</code>中的字符串匹配时，该函数运行并返回一个组件。更多信息请点击<a class="ae mq" href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/Route.md#render-func" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="8cb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意下面的第27–30行，它用<code class="fe mr ms mt mu b">AuthLayout</code>组件包装了我们的页面(<code class="fe mr ms mt mu b">SettingPage</code>和<code class="fe mr ms mt mu b">DashboardPage</code>):</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi oy"><img src="../Images/066d78d16d9f52960279ec96ba281422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xx3hHbLoN4FGdTAj2xaQYA.png"/></div></div></figure><p id="c663" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mc">你会注意到什么:</em></p><ul class=""><li id="5dcb" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">在我们的<code class="fe mr ms mt mu b">pages</code>常量中，我们可以很容易地控制每个页面的布局。这意味着我们无需重写任何代码就可以支持多种布局。</li><li id="aa9f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们没有在Route中使用<code class="fe mr ms mt mu b">component={}</code> prop来呈现我们的页面组件，因为我们想将它们包装在我们的父布局组件中。</li><li id="bb0d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们不会失去任何力量，因为我们仍然可以使用我们的路线道具(比赛，位置，历史)</li></ul><p id="0441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们已经在页面中实现了一致的布局("/Settings" &amp; "/Dashboard ")。</p><p id="ae3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这些页面不受保护，任何未登录的用户仍然可以访问它们。接下来我们要做的是将未经验证的用户重定向回我们的登录页面。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="3cf5" class="no la iq bd lb np nq dn lf nr ns dp lj jy nt nu ln kc nv nw lr kg nx ny lv nz bi translated">3.保护路线</h2><p id="3061" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">谢天谢地，我们仍然可以在<code class="fe mr ms mt mu b">AuthLayout.js</code>中访问我们的路线道具(历史)。认识到这一点后，解决方案变得非常简单。</p><p id="4cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将我们的布局组件变成一个看门人，并在我们的<code class="fe mr ms mt mu b">componentDidMount</code>函数中将任何未经授权的用户发送到登录页面，如下所示:</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi oz"><img src="../Images/5838c3172f77a1fe329ca5b886c5b5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9v-RO9cYlw8DvACo1cVCmQ.png"/></div></div></figure><p id="051e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个实现的美妙之处不仅仅在于它的简单，还在于我们如何从页面组件中抽象出授权的责任。我们只需要在布局层次做一次，而不是在每个页面组件中检查权限，干！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="7c44" class="no la iq bd lb np nq dn lf nr ns dp lj jy nt nu ln kc nv nw lr kg nx ny lv nz bi translated">4.嵌套路线</h2><p id="df52" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">拥有许多页面的足够大的应用程序最终需要嵌套一些“路由”。有许多方法可以做到这一点，但我们必须找到一种可以平稳集成到我们当前基础架构中的方法。</p><p id="3460" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何将“/设置”页面嵌套到“/仪表板”中。这里的目标是呈现带有URL的设置页面:“/dashboard/settings”。</p><p id="5244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输入嵌套的<code class="fe mr ms mt mu b">&lt;Switch&gt;</code>组件——因为当一个URL匹配其“<code class="fe mr ms mt mu b">path</code>”时，一个<code class="fe mr ms mt mu b">&lt;Route&gt;</code>“返回”一个组件，我们可以在返回的组件中嵌套另一个<code class="fe mr ms mt mu b">&lt;Switch&gt;</code>,以进一步导航任何具有“/dashboard/…”URL模式的URL。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi pa"><img src="../Images/d584f604c4b9d051d4457ad889946797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q57F7Gib-Ajrcn4cL2jOLw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">In diagrams: How nested &lt;Switch&gt; works</figcaption></figure><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi pb"><img src="../Images/096ce5a4e96af83843d3241a139c4446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEa-ecKHk2yjHM6KTnZ2cA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk">In code: How nested &lt;Switch&gt; works</figcaption></figure><p id="4dc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mc">你会注意到什么:</em></p><ul class=""><li id="4db1" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><code class="fe mr ms mt mu b">exact</code>必须在第一层<code class="fe mr ms mt mu b">&lt;Switch&gt;</code>关闭，并在最后一层(第二层)打开。</li><li id="b34e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><code class="fe mr ms mt mu b">AuthLayout</code>仍从第一层开始打。这意味着我们不会失去之前的访问控制，仍然可以保持我们的布局！</li><li id="af1c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们已经创建了一个新的组件<code class="fe mr ms mt mu b">/dashboardPage/index.js</code>，负责路由任何匹配“/dashboard/*”模式的URL</li><li id="2361" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们重构了<code class="fe mr ms mt mu b">SettingsPage.js</code> → <code class="fe mr ms mt mu b">/dashboardPage/SettingsView.js</code></li><li id="c9bc" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们重构了<code class="fe mr ms mt mu b">DashboardPage.js</code> → <code class="fe mr ms mt mu b">/dashboardPage/DashboardView.js</code></li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="3475" class="no la iq bd lb np nq dn lf nr ns dp lj jy nt nu ln kc nv nw lr kg nx ny lv nz bi translated">5.将道具传递给组件</h2><p id="898c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">无论您的用例是什么，这都是将全局或存储级数据传递给组件的便捷方式。</p><p id="d49f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人使用它，这样页面组件就不用一直连接到redux。例如，不是将<code class="fe mr ms mt mu b">/dashboardPage/SettingsView.js</code>和<code class="fe mr ms mt mu b">/dashboardPage/DashboardView.js</code>都连接到redux。我只有父节点<code class="fe mr ms mt mu b">/dashboardPage/index.js</code>连接到redux，并将全局属性传递给这些组件。</p><p id="3980" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有一个“用户”变量，我们想把它作为道具传递给我们的<code class="fe mr ms mt mu b">DashboardView</code>组件。</p><pre class="mw mx my mz gt oa mu ob oc aw od bi"><span id="47a3" class="no la iq mu b gy oe of l og oh">const DashboardPage = ({ user }) =&gt; (<br/>  &lt;Switch&gt;<br/>    &lt;Route exact path="/dashboard" component={DashboardView} /&gt;<br/>  &lt;/Switch&gt;<br/>);</span></pre><p id="4ced" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一个更高阶的组件<code class="fe mr ms mt mu b">RouteWithProps.js</code>(一个接受一个组件并返回一个新组件的函数)，将我所说的“extraProps”传递给我们的组件。</p><p id="9a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，它取代了前面的<code class="fe mr ms mt mu b">&lt;Route/&gt;</code>→<code class="fe mr ms mt mu b">&lt;RouteWithProps/&gt;</code>,将“用户”向下传递到<code class="fe mr ms mt mu b">DashboardView.js</code>。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi pc"><img src="../Images/62b592c9342beee05268c499570e8a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rps1CLNKEadKTFgb8xvKkg.png"/></div></div></figure><p id="a9ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mc">你会注意到什么:</em></p><ul class=""><li id="740f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><code class="fe mr ms mt mu b">&lt;Route/&gt;</code>的道具也可以用来传入道具，而不仅仅是用来添加早期的布局。</li><li id="fa91" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我们必须传递<code class="fe mr ms mt mu b">exact</code> &amp; <code class="fe mr ms mt mu b">path</code>到<code class="fe mr ms mt mu b">RouteWithProps</code>，它们是<code class="fe mr ms mt mu b">&lt;Route/&gt;</code>道具，所以路由不会改变。</li></ul><h1 id="287d" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="c42b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">**再次完整源代码<a class="ae mq" href="https://github.com/marxlow/react-router-layout-guide" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mc">此处</em> </strong> </a></p><p id="1039" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，这种路由基础设施对于中小型应用程序来说非常有用。它并不完美，这里有一些更大的问题:</p><ul class=""><li id="8cef" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">[嵌套路由]如果你有一个单独的“404”页面，注意你必须显式地写代码在第二层路由<em class="mc">再次</em>重定向。</li><li id="55cd" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">[Layout]从“/Dashboard”→“/Settings”导航到新的URL将再次重新呈现您的布局。也就是说，你的布局的<code class="fe mr ms mt mu b">componentDidMount</code>函数经常重新运行，如果处理不好，这可能会很昂贵。</li></ul><p id="55da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完美的基础设施在我看来是不存在的。一个好的工程师会为正确的工作选择正确的工具。我希望我的写作为你的工具箱增加了一个，即使你现在不使用它。</p><p id="7abb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我一直在寻找改进的方法，所以请告诉我你的想法。感谢您的阅读！</p></div></div>    
</body>
</html>