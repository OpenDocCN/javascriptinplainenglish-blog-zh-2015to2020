<html>
<head>
<title>Testing local storage with testing library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用测试库测试本地存储</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-local-storage-with-testing-library-580f74e8805b?source=collection_archive---------0-----------------------#2019-11-20">https://javascript.plainenglish.io/testing-local-storage-with-testing-library-580f74e8805b?source=collection_archive---------0-----------------------#2019-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e807" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用测试库测试同步和异步情况下本地存储的变化。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/1d1d61b61e47593858171536696e19a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zbFEL0uO-WUYue7V"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@erdaest?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Erda Estremera</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cbca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">嗨，大家好，最近我有点挣扎，试图用测试库为本地存储产生一些测试。我在网上找到的例子很少，或者对于普通读者或知识很少或没有知识的人来说有点混乱。</p><p id="947c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">经过反复研究，我想出了一个我认为可以接受的解决方案。在深入研究代码之前，让我们回顾一下基础知识。</p><h2 id="59e2" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">本地存储是什么？</h2><p id="898f" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">本地存储是一种允许访问存储对象的属性，该存储对象允许保存在会话之间持续存在且没有到期日期的键/值对。</p><p id="a394" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">storage对象公开了get、set和remove Item方法，这些方法允许从本地存储中读取、添加和移除项。</p><h2 id="cb81" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">怎么考？</h2><p id="5f31" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">这里主要是通过嘲讽上面提到的方法。</p><p id="117b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以通过使用Object.defineProperty()来修改本地存储方法并向它们传递模拟函数。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Mocking local storage</figcaption></figure><p id="c2c6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如您所见，我们用jest.fn()替换了getItem和setItem的实现。现在我们可以自由地访问window.localStorage.getItem并对其进行断言。</p><p id="2eed" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="mt">你可能想知道这个可写的东西有什么用，对吗？</em></p><p id="cc04" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">writable属性允许通过使用赋值运算符随意将值重新分配给该属性。这意味着，如果我们决定要在defineProperty方法之外访问localStorage.setItem并修改其内容，我们可以这样做。</p><p id="7f20" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有了这些信息，让我们在React组件中排队，并使用测试库测试它。</p><h2 id="f802" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">该组件</h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Local storage component</figcaption></figure><p id="2bdc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面，您可以看到一个利用useLocalStorage定制钩子的功能组件。(查看https://usehooks.com/useLocalStorage/<a class="ae kw" href="https://usehooks.com/useLocalStorage/" rel="noopener ugc nofollow" target="_blank">了解更多信息和定制挂钩)。</a></p><p id="54f2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该组件有一个接收存储在本地存储上的名称的输入和一个更新本地存储的onChange事件。为了增加乐趣和难度，我们添加了接收端点的fetch函数，并使用axios发出get请求，将响应数据保存到本地存储中。</p><h2 id="1311" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">测试</h2><p id="5051" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">我们将涵盖以下测试案例:</p><ol class=""><li id="d7a6" class="mu mv iq kz b la lb ld le lg mw lk mx lo my ls mz na nb nc bi translated">在呈现时，应该调用本地存储getItem。</li><li id="bfd2" class="mu mv iq kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">在输入文本改变时，我们应该用新的文本调用本地存储setItem。</li><li id="7b9f" class="mu mv iq kz b la nd ld ne lg nf lk ng lo nh ls mz na nb nc bi translated">单击按钮时，我们应该向端点发出get请求，并将响应存储在本地存储上。</li></ol><p id="5813" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，让我们模拟我们的依赖和设置或测试</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Mocking dependencies and setting tests up</figcaption></figure><p id="8d5c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">正如你在上面的要点中看到的，我们模仿axios get方法返回一个承诺，并利用jest beforeEach函数在每个测试用例之前重新定义我们的本地存储模拟。</p><p id="61b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">完成设置后，测试应该很简单。</p><h2 id="e2a3" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">在渲染时，应该调用本地存储getItem。</h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Assert getItem call</figcaption></figure><p id="f562" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个测试用例是三个中最简单的。我们所要做的就是呈现我们的组件，并断言我们模拟的getItem被调用。</p><h2 id="b141" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">在输入文本改变时，我们应该用新的文本调用本地存储setItem</h2><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Assert setItem is called on input change</figcaption></figure><p id="b09a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个测试用例需要与我们的组件进行交互，以便能够验证是否调用了setItem。我们通过呈现组件并提取其queryByPlaceholderText方法来实现这一点，并利用它来访问我们的输入。有了输入组件，我们现在可以使用测试库fireEvent来更改它的值。</p><p id="7e55" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">剩下的就简单了，我们断言我们的setItem被调用了一次，然后，我们检查这个调用是否使用了预期的键/值对。</p><h2 id="4ed7" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">单击按钮时，我们应该向端点发出get请求，并将响应存储在本地存储上。</h2><p id="101c" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">这个测试更棘手，因为它处理异步内容，幸运的是我们已经模拟了axios get方法总是返回给定的字符串。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Assert network request is made and setItem is called</figcaption></figure><p id="4eb7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要做的第一件事是启动我们的异步请求。这一部分可以通过让我们的按钮a触发一个点击事件来完成。现在，我们不希望在确认异步请求已经结束之前就完成断言。既然我们知道完成请求后，我们的输入值会发生变化，那么我们可以使用waitForElement和getByDisplayValue来等待被嘲讽的值出现。</p><p id="5213" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">之后，我们可以成功地做我们的断言，并且一切正常。</p><p id="1ac0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在你可以检查我们完整的测试文件</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Complete local storage test</figcaption></figure><p id="442a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你也可以在Codesandbox上使用它</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ni ms l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Play around on Codesandbox</figcaption></figure><h2 id="974c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">结论</h2><p id="a28d" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">正如你可以看到的测试，本地存储可以毫不费力，或者它可以是一个耳朵。这完全取决于你如何对待它。</p><p id="3121" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我希望这篇文章有助于最终消除您对本地存储测试以及为此使用测试库的疑虑。</p><p id="ce4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你有任何问题，你可以在推特上找到我，地址是@danieljcafonso</p><p id="1db9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我希望你喜欢并关注下一期指南。</p></div></div>    
</body>
</html>