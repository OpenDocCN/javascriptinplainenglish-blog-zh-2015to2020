<html>
<head>
<title>Algorithms 101: Jewels and Stones in Ruby and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:红宝石和JavaScript中的宝石</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-jewels-and-stones-in-ruby-and-javascript-c22fce37ad2b?source=collection_archive---------1-----------------------#2019-10-02">https://javascript.plainenglish.io/algorithms-101-jewels-and-stones-in-ruby-and-javascript-c22fce37ad2b?source=collection_archive---------1-----------------------#2019-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="564a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉LeetCode，第9集，计算字符串中的字符数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c5ecbdffaebd639affa3d48f26f4a634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNBa6bZNyzgYf2bx_0i1mg.png"/></div></div></figure><p id="2f91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我的下一个简单的LeetCode挑战，我找到了这个，它涉及到在字符串中查找字母的出现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/860b2e958956db363a39b9362fa41681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5FrXx9Ljq5F2rOeJRGm4w.png"/></div></div></figure><p id="7362" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我正试图提高我的JavaScript技能，所以我想从那里开始，但是我无法抗拒Ruby，对于像这样的简单任务来说，Ruby确实更直观。</p><p id="94b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们正试图计算我们的S，或石头串，包含了多少次来自J的字母，我们的珠宝串。</p><p id="a815" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Ruby中:</p><p id="1fb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们来设置一个计数器:<code class="fe lo lp lq lr b">counter = 0</code></p><p id="a8e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后将我们的J字符串拆分成一个数组，这样我们就可以轻松地迭代数组的元素:</p><p id="034f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">array = j.split(‘’)</code></p><p id="706d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，每当计数器在我们的“s”字符串中找到任何数组元素时，我们就递增它:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="e082" class="lw lx iq lr b gy ly lz l ma mb">array.each do |el|<br/>  counter += s.count(el) <br/>end</span></pre><p id="aba7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们返回计数器。一起:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="7b0a" class="lw lx iq lr b gy ly lz l ma mb">def num_jewels_in_stones(j, s)<br/>    counter = 0<br/>    array = j.split('')<br/>    <br/>    array.each do |el|<br/>        counter += s.count(el) <br/>    end</span><span id="4d2e" class="lw lx iq lr b gy mc lz l ma mb">    counter<br/>end</span></pre><p id="12b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还不错！它的速度非常快，内存使用量也非常低:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/5bac1bd9e6d0c19fafc224cfcd89f9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1cQpij3zC5hYW5B4LaSBQ.png"/></div></div></figure><h1 id="944c" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">如果javaScript有那么简单就好了…</h1><p id="c58e" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">不打算撒谎。在js中使用相同的逻辑是一件痛苦的事情。</p><p id="5f8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您仍然设置了一个计数器，并且仍然搜索S包含J中的一个字符的次数——但是语法比较沉闷。</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="764e" class="lw lx iq lr b gy ly lz l ma mb"><br/>var numJewelsInStones = function(J, S) {<br/>    let counter = 0;<br/>   // iterate here<br/>    return counter;<br/>};</span></pre><p id="5b75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是JavaScript中迭代的基本模式:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="7043" class="lw lx iq lr b gy ly lz l ma mb">for (let i = 0; i &lt; S.length; i++) {<br/>     if(J.indexOf(S.charAt(i)) !== -1)<br/>         counter++;<br/>    }</span></pre><p id="147c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们打开它。</p><ul class=""><li id="a6fc" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">在第一行中，我们设置了一个值“I ”,这样我们就可以遍历S字符串的每个字符。</li><li id="99bf" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">在第二行中，我们检查S中的字符在J中是否有索引(即它是否包含在J字符串中)。如果是的话，我们增加我们的计数器。</li><li id="3b4a" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">注意:如果J不包含我们正在寻找的字符，charAt()方法将返回<code class="fe lo lp lq lr b">-1</code>。如果这个字符的索引不等于负一，我们实际上是在说，如果找到了这个字符。有时候这个也写成:<code class="fe lo lp lq lr b">if(J.indexOf(S.charAt(i)) ≥ 0 )</code>。这只是一个看起来更干净的说法<code class="fe lo lp lq lr b">!= -1</code>。</li></ul><p id="5841" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一起:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="3668" class="lw lx iq lr b gy ly lz l ma mb">var numJewelsInStones = function(J, S) {<br/>    let counter = 0;<br/>    for (let i = 0; i &lt; S.length; i++) {<br/>        if(J.indexOf(S.charAt(i)) !== -1)<br/>            counter++;<br/>    }<br/>    return counter;<br/>};</span></pre><p id="0ce7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不算太寒酸:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/d33e1d3c0ee9aff245535cf064fbf43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qS7sI23h2r97PnMGj7gVIA.png"/></div></div></figure><h1 id="a465" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">用forEach()清理它</h1><p id="fd44" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">javaScript有一个forEach()方法，可以让您跳过</p><p id="2e33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">for(let i= 0; i &lt; array.length; i++)</code>语法。</p><p id="754f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">语法是:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="91b8" class="lw lx iq lr b gy ly lz l ma mb">array.forEach(element =&gt; {<br/> // do something with element<br/>})<!-- -->;</span></pre><p id="745d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您不能在字符串上使用它，但是您可以将字符串拆分成一个数组，并像这样使用它:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="f3c1" class="lw lx iq lr b gy ly lz l ma mb">var numJewelsInStones = function(J, S) {<br/>    let counter = 0;<br/>    S.split('').forEach(element =&gt; {<br/>        J.indexOf(element) &gt;= 0 ? counter ++ : counter <br/>});</span><span id="b107" class="lw lx iq lr b gy mc lz l ma mb">return counter;<br/>};</span></pre><p id="86c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，在第4行，我们使用了一个三元运算符:<code class="fe lo lp lq lr b">:</code></p><p id="b7b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它是这样工作的:</p><p id="12e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">condition met ? do this : otherwise do that</code></p><p id="fd5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这最后一个函数看起来稍微干净一点，并且和之前的函数有相同的属性。</p><h1 id="39b4" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">迅速的</h1><p id="37dc" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">如果你真的想加快速度，你可以试试这个来自<a class="ae np" href="https://leetcode.com/jsscripter/" rel="noopener ugc nofollow" target="_blank"> jssScripter </a>的一行程序:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="f8f6" class="lw lx iq lr b gy ly lz l ma mb">const numJewelsInStones = (J, S) =&gt; S.split('').filter(char =&gt; J.indexOf(char) !== -1).length;</span></pre><p id="8910" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们打开它。</p><p id="ad75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们仍然把S字符串拆分成一个数组。只是这一次，我们要过滤它——对于S的每个字符，如果在J中找到它，我们要返回该字符(同样，如果它的indexOf不等于-1)。一旦我们收集了这些字符，我们用. length对它们进行计数。</p><p id="b395" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它更快一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a950901c54d5cdfe2bac220501f3225e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPXU---Zwlf2rHkb3YRvqg.png"/></div></div></figure><h1 id="5a09" class="me lx iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">但是请注意，Ruby要快得多。</h1><p id="ddfb" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">Ruby解决方案再次统计:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/5bac1bd9e6d0c19fafc224cfcd89f9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1cQpij3zC5hYW5B4LaSBQ.png"/></div></div></figure><p id="d2b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nr">接下来:</em> <a class="ae np" href="https://medium.com/javascript-in-plain-english/algorithms-101-birthday-chocolate-in-javascript-f5fcbd639bf3" rel="noopener"> <em class="nr">算法101 #10、JavaScript中的生日巧克力</em> </a></p><p id="a07d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nr">以防你错过:</em> <a class="ae np" href="https://medium.com/javascript-in-plain-english/algorithms-101-best-time-to-buy-and-sell-stock-in-javascript-7a2249b29495" rel="noopener"> <em class="nr">算法101 #8、JavaScript中买卖股票的最佳时间</em> </a></p><p id="3150" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">版权所有琼·印第安纳·琳斯2019</p></div></div>    
</body>
</html>