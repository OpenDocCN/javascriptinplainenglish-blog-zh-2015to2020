<html>
<head>
<title>React Native Car Parking Finder App UI Clone #6: Implementing Modal View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React本地汽车停车查找器应用程序UI克隆#6:实现模态视图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-car-parking-finder-app-ui-clone-6-implementing-modal-view-6216af0e9278?source=collection_archive---------4-----------------------#2019-11-02">https://javascript.plainenglish.io/react-native-car-parking-finder-app-ui-clone-6-implementing-modal-view-6216af0e9278?source=collection_archive---------4-----------------------#2019-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4ab924e16d9a3198b6b0faa96c2d0ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XGPPBZgL_ym8Jz-4.png"/></div></div></figure><p id="4f64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本教程是我们React原生停车App UI克隆系列的第六部分。在<a class="ae kt" href="https://kriss.io/react-native-car-parking-finder-app-ui-clone-5-header-section/" rel="noopener ugc nofollow" target="_blank">的最后一部分</a>中，我们成功地实现了地图屏幕中的标题部分，并组织了我们的代码。在教程系列的这一部分，我们将从上一部分停止的地方继续。因此，建议通读本教程系列的所有前几部分，以便全面了解该项目的进展情况。</p><p id="2f60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果有人想从头开始学习，这个教程系列的所有部分都可以在下面找到:</p><ul class=""><li id="9976" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><a class="ae kt" href="https://kriss.io/react-native-car-parking-finder-app-ui-clone-1-map-view/" rel="noopener ugc nofollow" target="_blank"> React原生汽车泊车查询应用UI克隆# 1:地图视图</a></li><li id="f9b4" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://kriss.io/react-native-car-parking-finder-app-ui-clone-2-scrolling-swiping-transition/" rel="noopener ugc nofollow" target="_blank">React Native Car Parking Finder App UI克隆# 2:滚动/滑动过渡</a></li><li id="db9b" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://kriss.io/react-native-car-parking-finder-app-ui-clone-3-parking-spot-cards/" rel="noopener ugc nofollow" target="_blank"> Building React原生汽车停车查找器App UI克隆# 3:停车点卡</a></li><li id="81da" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://kriss.io/react-native-car-parking-finder-app-ui-clone-4-map-markers/" rel="noopener ugc nofollow" target="_blank">React Native Car Parking Finder App UI Clone # 4:地图标记</a></li><li id="b8c4" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><a class="ae kt" href="https://kriss.io/react-native-car-parking-finder-app-ui-clone-4-map-markers/" rel="noopener ugc nofollow" target="_blank"> R </a></li></ul><p id="1988" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前所述，本教程系列的动机来自于<a class="ae kt" href="https://www.instamobile.io/app-templates/react-native-store-locator-app-template/" rel="noopener ugc nofollow" target="_blank"> React Native商店定位器应用程序模板</a>，它为我们提供了一个用React Native编写的动态、完全编码的初学者工具包，任何人都可以使用它来构建自己的商店定位器React Native应用程序或启动自己的创业。第五部分也是YouTube视频教程中的编码实现和设计的延续，由<a class="ae kt" href="https://www.youtube.com/watch?v=CuMR9kRZJCw&amp;list=PLNRPou200YIeu4UllJkv8-Ca19Ld_eOay&amp;index=8" rel="noopener ugc nofollow" target="_blank"> React UI Kit </a>为汽车停车查找器应用程序UI克隆。视频教程似乎使用快速编码风格来交付不同UI部分的实现，这对于任何开发人员，尤其是初学者来说可能难以理解。然而，本教程对每个UI部分的实现给出了逐步的指导。因此，读者可以放松下来，花时间学习和实现UI。</p><h2 id="9055" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated"><strong class="ak">概述</strong></h2><p id="b2c9" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">在本系列教程的第六部分中，我们将实现一个模型，用不同的UI部分显示停车卡部分的扩展信息。想法是安装react-native-modal包并将其集成到地图屏幕中。然后，我们将配置模态，以使它看起来像在实际应用程序中。最后，我们将在模态视图中实现不同的部分，并对它们进行样式化。</p><p id="3d06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mg">那么，让我们开始吧！！</em></p><h2 id="7073" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">安装模块包</h2><p id="9bf3" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">这里我们将把<a class="ae kt" href="https://github.com/react-native-community/react-native-modal" rel="noopener ugc nofollow" target="_blank"> react-native-modal </a>包安装到我们的项目中。这个软件包提供了一个增强的，动画的和可定制的反应原生模型。这个包的主要目的是通过添加动画和样式定制选项来扩展原来的react-native <code class="fe mh mi mj mk b">Modal</code>组件，同时仍然提供一个简单的API。现在，为了将这个包安装到我们的项目中，我们需要运行以下命令:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3718" class="li lj in mk b gy mt mu l mv mw">expo install react-native-modal</span></pre><p id="f795" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们需要在Map.js文件中将这个包作为<code class="fe mh mi mj mk b">Modal</code>组件导入，如下面的代码片段所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2617" class="li lj in mk b gy mt mu l mv mw">import Modal from 'react-native-modal';</span></pre><h2 id="bfef" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">实现模式</h2><p id="9bcc" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">在这一步中，我们将在地图屏幕中实现模态。为此，我们需要定义一个名为<code class="fe mh mi mj mk b">activeModal</code>的状态来处理模态的打开和关闭。应该如下面的代码片段所示定义<code class="fe mh mi mj mk b">activeModal</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b070" class="li lj in mk b gy mt mu l mv mw">state = {<br/>    hours: {},<br/>    active : null,<br/>    activeModal : null<br/>  }</span></pre><p id="0911" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要在按下停车卡上的购买按钮时激活模式。为此，我们需要更改<code class="fe mh mi mj mk b">TouchableOpacity</code>组件的<code class="fe mh mi mj mk b">onPress</code>事件中<code class="fe mh mi mj mk b">activeModal</code>的状态，如下面的代码片段所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b23f" class="li lj in mk b gy mt mu l mv mw">&lt;TouchableOpacity style={styles.buy} onPress={() =&gt; this.setState({ activeModal: item })}&gt;<br/>                  &lt;View style={styles.buyTotal}&gt; <br/>                    &lt;Text style={styles.buyTotalPrice}&gt;${item.price *2}&lt;/Text&gt;<br/>                    &lt;Text style={{ color : theme.COLORS.white}}&gt;{item.price}x{hours[item.id]} hrs&lt;/Text&gt;<br/>                  &lt;/View&gt;<br/>                  &lt;View style={styles.buyButton}&gt;<br/>                    &lt;Text style={{fontSize: 25, color : theme.COLORS.white}}&gt;&gt;&lt;/Text&gt;<br/>                  &lt;/View&gt;<br/>              &lt;/TouchableOpacity&gt;</span></pre><p id="8241" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们刚刚实现了一个打开模态的触发器，但是还没有实现实际的<code class="fe mh mi mj mk b">Modal</code>组件。所以现在，我们要实现实际的模态。</p><h2 id="9f5c" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated"><strong class="ak">定义模态的新功能</strong></h2><p id="0325" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">这里，我们将定义一个名为<code class="fe mh mi mj mk b">renderModal()</code>的新函数。该函数将返回带有<code class="fe mh mi mj mk b">Modal</code>组件的模板。下面的代码片段提供了该函数的整体实现:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="376b" class="li lj in mk b gy mt mu l mv mw">renderModal(){<br/>     const {activeModal} = this.state;<br/><br/>     if (!activeModal) return null;     <br/>     <br/>     return(<br/>       &lt;Modal<br/>        isVisible<br/>        onBackButtonPress={() =&gt; this.setState({ activeModal: null })}<br/>        onBackdropPress={() =&gt; this.setState({ activeModal: null })}<br/>       &gt;<br/>         &lt;View style={styles.modal}&gt;<br/>           &lt;Text&gt;{activeModal.title}&lt;/Text&gt;<br/>         &lt;/View&gt;<br/>       &lt;/Modal&gt;<br/>     )<br/>   }</span></pre><p id="ebd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，在<code class="fe mh mi mj mk b">renderModal()</code>方法中，我们从状态变量中定义了<code class="fe mh mi mj mk b">activeModal</code>常量。然后，如果<code class="fe mh mi mj mk b">activeModal</code>状态为空，则<code class="fe mh mi mj mk b">renderModal()</code>函数将返回null，这将不会在应用程序屏幕上显示模态。但是，如果<code class="fe mh mi mj mk b">activeModal</code>状态不为空，该函数将返回带有<code class="fe mh mi mj mk b">Modal</code>组件的模板。这里的<code class="fe mh mi mj mk b">Modal</code>组件配置了不同的道具。</p><p id="b5e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mh mi mj mk b">isVisible</code>道具用于在屏幕上显示模态。在<code class="fe mh mi mj mk b">Modal</code>组件的<code class="fe mh mi mj mk b">onBackButtonPress</code>和<code class="fe mh mi mj mk b">onBackdropPress</code>事件中，我们已经将<code class="fe mh mi mj mk b">activeModal</code>状态更改为空，以便在屏幕上隐藏模态。我们还将一些<code class="fe mh mi mj mk b">View</code>组件包装<code class="fe mh mi mj mk b">Text</code>组件与一些内联样式集成在一起。</p><p id="687f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要调用Map.js文件的<code class="fe mh mi mj mk b">render()</code>函数中的<code class="fe mh mi mj mk b">renderModal()</code>方法，如下面的代码片段所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7b77" class="li lj in mk b gy mt mu l mv mw">render(){<br/>   return(<br/>  …………<br/>           {this.renderParkings()}<br/>           {this.renderModal()}<br/>      &lt;/View&gt;<br/><br/>   )<br/>}</span></pre><p id="2624" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，下面的代码片段提供了在<code class="fe mh mi mj mk b"> renderModal()</code>函数中使用的所需样式:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7c52" class="li lj in mk b gy mt mu l mv mw">modal : {<br/>    backgroundColor : theme.COLORS.white<br/>  }</span></pre><p id="fb97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ff166954428ccc307592996457b9c6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*FLNFXTL_mV-ZLPey.gif"/></div></figure><p id="5b34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，一个模态出现在屏幕上。但是modal太小了，为了让modal更吸引人，我们需要配置更多的道具和样式。</p><h2 id="f076" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated"><strong class="ak">配置模态属性和样式</strong></h2><p id="6e7e" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">这里，我们将为<code class="fe mh mi mj mk b">Modal</code>组件配置一些额外的道具和样式。为此，我们需要使用以下代码片段中的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="64f0" class="li lj in mk b gy mt mu l mv mw">renderModal(){<br/>     const {activeModal} = this.state;<br/><br/>     if (!activeModal) return null;     <br/>     <br/>     return(<br/>       &lt;Modal<br/>        isVisible<br/>        useNativeDriver<br/>        style={styles.modalContainer}<br/>        onBackButtonPress={() =&gt; this.setState({ activeModal: null })}<br/>        onBackdropPress={() =&gt; this.setState({ activeModal: null })}<br/>        onSwipeComplete={() =&gt; this.setState({ activeModal: null })}<br/>        <br/>       &gt;<br/>         &lt;View style={styles.modal}&gt;<br/>           &lt;Text&gt;{activeModal.title}&lt;/Text&gt;<br/>         &lt;/View&gt;<br/>       &lt;/Modal&gt;<br/>     )<br/>   }</span></pre><p id="89c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们包含了一个名为<code class="fe mh mi mj mk b">useNativeDriver</code>的道具，它使用本地驱动配置和属性来处理Modal的工作。我们还包含了一个将<code class="fe mh mi mj mk b">activeModal</code>状态更改为null的<code class="fe mh mi mj mk b">inSwipeComplete</code>事件。然后，我们还为下面的代码片段中提供的<code class="fe mh mi mj mk b">Modal</code>组件提供了一个样式属性:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3836" class="li lj in mk b gy mt mu l mv mw">modalContainer: {<br/>    margin: 0,<br/>    justifyContent: 'flex-end',<br/>  },<br/>  modal: {<br/>    height: height * 0.75,<br/>    backgroundColor: theme.COLORS.white,<br/>  },</span></pre><p id="5245" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/82bcddf01abd33b54629e00c983aea38.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*Y3irE867dwSft_E9.gif"/></div></figure><p id="8048" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所见，<code class="fe mh mi mj mk b">Modal</code>组件现在覆盖了屏幕下部的一半以上。</p><h2 id="2969" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">添加模态内容</h2><p id="7555" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">现在，我们将在模态视图中添加一些内容。我们已经添加了当我们在每个停车位按下购买按钮时打开模式的触发器。触发时，我们将<code class="fe mh mi mj mk b">activeModal</code>状态设置为来自<code class="fe mh mi mj mk b">parkingsSpots</code>数据数组的特定停车点数据。现在，我们将使用存储在<code class="fe mh mi mj mk b">activeModal</code>状态中的值，以便将不同的停车位信息添加到模型中。为此，我们需要在<code class="fe mh mi mj mk b">renderModal</code>函数中使用以下代码片段中的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8f8c" class="li lj in mk b gy mt mu l mv mw">renderModal(){<br/>     const {activeModal , hours} = this.state;<br/><br/>     if (!activeModal) return null;     <br/>     <br/>     return(<br/>       &lt;Modal<br/>        isVisible<br/>        useNativeDriver<br/>        style={styles.modalContainer}<br/>        onBackButtonPress={() =&gt; this.setState({ activeModal: null })}<br/>        onBackdropPress={() =&gt; this.setState({ activeModal: null })}<br/>        onSwipeComplete={() =&gt; this.setState({ activeModal: null })}<br/>        <br/>       &gt;<br/>         &lt;View style={styles.modal}&gt;<br/>           &lt;View&gt;<br/>            &lt;Text&gt;{activeModal.title}&lt;/Text&gt;<br/>           &lt;/View&gt;<br/>           &lt;View&gt;<br/>              &lt;Text&gt;{activeModal.description}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View style={{flexDirection : 'row'}}&gt;<br/>              &lt;Text&gt;{activeModal.price}&lt;/Text&gt;<br/>              &lt;Text&gt;{activeModal.rating}&lt;/Text&gt;<br/>              &lt;Text&gt;{activeModal.distance}&lt;/Text&gt;<br/>              &lt;Text&gt;{activeModal.free}/{activeModal.total}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View&gt;<br/>              &lt;Text&gt;Choose your Booking Period&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View&gt;<br/>                &lt;TouchableOpacity style={styles.buy}&gt;<br/>                    &lt;View style={styles.buyTotal}&gt; <br/>                      &lt;Text style={styles.buyTotalPrice}&gt;${activeModal.price *2}&lt;/Text&gt;<br/>                      &lt;Text style={{ color : theme.COLORS.white}}&gt;{activeModal.price}x{hours[activeModal.id]} hrs&lt;/Text&gt;<br/>                    &lt;/View&gt;<br/>                    &lt;View style={styles.buyButton}&gt;<br/>                      &lt;Text style={{fontSize: 25, color : theme.COLORS.white}}&gt;&gt;&lt;/Text&gt;<br/>                    &lt;/View&gt;<br/>                &lt;/TouchableOpacity&gt;<br/>            &lt;/View&gt;<br/>         &lt;/View&gt;<br/>         <br/>       &lt;/Modal&gt;<br/>     )<br/>   }</span></pre><p id="81cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们添加了不同的<code class="fe mh mi mj mk b">View</code>和<code class="fe mh mi mj mk b">Text</code>组件来显示<code class="fe mh mi mj mk b">parkingsSpots</code>数据数组中的信息。我们还使用了<code class="fe mh mi mj mk b">TouchableOpacity</code>组件，它包装了模态中最终购买按钮的<code class="fe mh mi mj mk b">View</code>和<code class="fe mh mi mj mk b">Text</code>组件。组件被绑定到不同的样式，这些样式在下面的代码片段中提供:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="09bd" class="li lj in mk b gy mt mu l mv mw">modal: {<br/>    flexDirection: 'column',<br/>    height: height * 0.75,<br/>    padding: theme.SIZES.base * 2,<br/>    backgroundColor: theme.COLORS.white,<br/>    borderTopLeftRadius: theme.SIZES.base,<br/>    borderTopRightRadius: theme.SIZES.base,<br/>  },</span></pre><p id="bf07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/c3e9b464de3625feb9ebce87963d39a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*KZ2Mo4DYX3tCMlw_.gif"/></div></figure><p id="9383" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，一些内容已经出现在屏幕上，但位置不当。现在，我们需要正确地设计它们的样式，以使模态内容看起来像实际应用程序一样吸引人。</p><p id="b09f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们还可以注意到，我们在模态内容中添加了额外的<code class="fe mh mi mj mk b">distance</code>和<code class="fe mh mi mj mk b">description</code>数据。但是这些数据不包含在<code class="fe mh mi mj mk b">parkingsSpots</code>数据数组中。因此，我们需要首先包括这一点。</p><h2 id="c9e5" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">添加附加数据</h2><p id="c861" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">这里，我们将把<code class="fe mh mi mj mk b">distance</code>和<code class="fe mh mi mj mk b">description</code>数据添加到<code class="fe mh mi mj mk b">parkingsSpots</code>数据数组中的每一项，如下面的代码片段所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5883" class="li lj in mk b gy mt mu l mv mw">const parkingsSpots = [<br/>  {<br/>    id: 1,<br/>    title: 'Parking 1',<br/>    price: 5,<br/>    rating: 4.2,<br/>    spots: 20,<br/>    free: 10,<br/>    coordinate: {<br/>      latitude: 37.78735,<br/>      longitude: -122.4334,<br/>    },<br/>    distance : 2.5,<br/>    description: `Description about this parking lot<br/><br/>Open year 2018<br/>Secure with CTV`,<br/>  },<br/>  {<br/>    id: 2,<br/>    title: 'Parking 2',<br/>    price: 7,<br/>    rating: 3.8,<br/>    spots: 25,<br/>    free: 20,<br/>    coordinate: {<br/>      latitude: 37.78845,<br/>      longitude: -122.4344,<br/>    },<br/>    distance : 3.5,<br/>    description: `Description about this parking lot<br/><br/>Open year 2018<br/>Secure with CTV`,<br/>  },<br/>  {<br/>    id: 3,<br/>    title: 'Parking 3',<br/>    price: 10,<br/>    rating: 4.9,<br/>    spots: 50,<br/>    free: 25,<br/>    coordinate: {<br/>      latitude: 37.78615,<br/>      longitude: -122.4314,<br/>    },<br/>    distance : 1,<br/>    description: `Description about this parking lot<br/><br/>Open year 2018<br/>Secure with CTV`,<br/>  },<br/>];</span></pre><h2 id="8cd1" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">设计内容的样式</h2><p id="3494" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">这里，我们将对<code class="fe mh mi mj mk b">Modal</code>组件中的组件进行样式化，以使模态内容看起来像在实际应用程序中一样。为此，我们需要使用以下代码片段中的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8d64" class="li lj in mk b gy mt mu l mv mw">&lt;Modal<br/>        isVisible<br/>        useNativeDriver<br/>        style={styles.modalContainer}<br/>        onBackButtonPress={() =&gt; this.setState({ activeModal: null })}<br/>        onBackdropPress={() =&gt; this.setState({ activeModal: null })}<br/>        onSwipeComplete={() =&gt; this.setState({ activeModal: null })}<br/>        <br/>       &gt;<br/>         &lt;View style={styles.modal}&gt;<br/>          &lt;View&gt;<br/>            &lt;Text style={{ fontSize: theme.SIZES.font * 1.5 }}&gt;<br/>              {activeModal.title}<br/>            &lt;/Text&gt;<br/>          &lt;/View&gt;<br/>          &lt;View style={{ paddingVertical: theme.SIZES.base }}&gt;<br/>            &lt;Text style={{ color: theme.COLORS.gray, fontSize: theme.SIZES.font * 1.1 }}&gt;<br/>              {activeModal.description}<br/>            &lt;/Text&gt;<br/>          &lt;/View&gt;<br/>          &lt;View style={styles.modalInfo}&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}&gt;<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; ${activeModal.price}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; {activeModal.rating}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}&gt;<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; {activeModal.distance}km&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}&gt;<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; {activeModal.free}/{activeModal.spots}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>          &lt;/View&gt;<br/>          &lt;View style={styles.modalHours}&gt;<br/>            &lt;Text style={{ textAlign: 'center', fontWeight: '500' }}&gt;Choose your Booking Period:&lt;/Text&gt;<br/>          &lt;/View&gt;<br/>          &lt;View&gt;<br/>            &lt;TouchableOpacity style={styles.payBtn}&gt;<br/>              &lt;Text style={styles.payText}&gt;<br/>                Proceed to pay ${activeModal.price * hours[activeModal.id]}<br/>              &lt;/Text&gt;<br/>              &lt;FontAwesome name='angle-right' size={theme.SIZES.icon * 1.75} color={theme.COLORS.white} /&gt;<br/>            &lt;/TouchableOpacity&gt;<br/>          &lt;/View&gt;<br/>        &lt;/View&gt;<br/>         <br/>       &lt;/Modal&gt;</span></pre><p id="8654" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们添加了不同的内联样式属性以及来自<code class="fe mh mi mj mk b">StyleSheet</code>组件的样式。下面的代码片段提供了<code class="fe mh mi mj mk b">StyleSheet</code>组件所需的样式:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bd9b" class="li lj in mk b gy mt mu l mv mw">modalInfo: {<br/>    flexDirection: 'row',<br/>    justifyContent: 'space-evenly',<br/>    paddingVertical: theme.SIZES.base,<br/>    borderTopWidth: 1,<br/>    borderBottomWidth: 1,<br/>    borderTopColor: theme.COLORS.overlay,<br/>    borderBottomColor: theme.COLORS.overlay,<br/>  },<br/> modalHours: {<br/>    paddingVertical: height * 0.11,<br/>  },<br/> payBtn: {<br/>    borderRadius: 6,<br/>    flexDirection: 'row',<br/>    alignItems: 'center',<br/>    justifyContent: 'space-between',<br/>    padding: theme.SIZES.base * 1.5,<br/>    backgroundColor: theme.COLORS.red,<br/>  },<br/>  payText: {<br/>    fontWeight: '600',<br/>    fontSize: theme.SIZES.base * 1.5,<br/>    color: theme.COLORS.white,<br/>  }</span></pre><p id="fe1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d46013aa72ac344116e432057d78c748.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*lsGknWKXnMu8evkn.gif"/></div></figure><p id="75fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，我们已经将所有组件放置在适当的位置，这使得模型看起来更有吸引力。现在，我们需要添加图标到模态。</p><h2 id="903e" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">添加图标</h2><p id="95c7" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">这里，我们将把图标添加到模式内容中相应的UI部分。我们已经从世博会客户提供的vector-icons包中导入了<code class="fe mh mi mj mk b">Ionicons</code>包。现在，我们将包含<code class="fe mh mi mj mk b">Ionicons</code>组件，如下面的代码片段所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5b90" class="li lj in mk b gy mt mu l mv mw">&lt;View style={styles.modalInfo}&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}&gt;<br/>              &lt;Ionicons name='ios-pricetag' size={theme.SIZES.icon * 1.1} color={theme.COLORS.gray} /&gt;<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; ${activeModal.price}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}&gt;<br/>              &lt;Ionicons name='ios-star' size={theme.SIZES.icon * 1.1} color={theme.COLORS.gray} /&gt;<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; {activeModal.rating}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}&gt;<br/>              &lt;Ionicons name='ios-pin' size={theme.SIZES.icon * 1.1} color={theme.COLORS.gray} /&gt;<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; {activeModal.distance}km&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>            &lt;View style={[styles.parkingIcon, {justifyContent: 'flex-start'} ]}&gt;<br/>              &lt;Ionicons name='ios-car' size={theme.SIZES.icon * 1.3} color={theme.COLORS.gray} /&gt;<br/>              &lt;Text style={{ fontSize: theme.SIZES.icon * 1.15 }}&gt; {activeModal.free}/{activeModal.spots}&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>          &lt;/View&gt;</span></pre><p id="2b82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们已经为<code class="fe mh mi mj mk b">Ionicons</code>组件提供了大小和颜色属性。道具是根据我们的来自theme.js文件的<code class="fe mh mi mj mk b">COLORS</code>和<code class="fe mh mi mj mk b">SIZES</code>变量。</p><p id="61ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/c7690c1bb4326fd975446f5d0a74e109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*1DIFZWwsewoIl7dA.png"/></div></figure><p id="fa00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，在我们的模态视图中有图标。但是我们可以看到“选择您的预订期”部分有所遗漏。在这一部分，我们需要像在停车位卡中一样添加小时部分。</p><h2 id="86d1" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">将小时部分添加到模式</h2><p id="e614" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">在这里，我们只是将小时部分添加到modal中。我们将使用下面的<code class="fe mh mi mj mk b">Text</code>组件添加此部分，该组件具有“选择您的预订期”文本，如下面的代码片段所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fdfc" class="li lj in mk b gy mt mu l mv mw">&lt;View style={styles.modalHours}&gt;<br/>            &lt;Text style={{ textAlign: 'center', fontWeight: '500' }}&gt;Choose your Booking Period:&lt;/Text&gt;<br/>            &lt;View style={styles.modalHoursDropdown}&gt;<br/>              &lt;Text style={{ color: theme.COLORS.gray }}&gt;5:00 hrs&lt;/Text&gt;<br/>            &lt;/View&gt;<br/>          &lt;/View&gt;</span></pre><p id="2c15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，<code class="fe mh mi mj mk b">View</code>组件用显示小时的文本包装了<code class="fe mh mi mj mk b">Text</code>组件。下面的代码片段提供了所需的样式:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8d8d" class="li lj in mk b gy mt mu l mv mw">modalHours: {<br/>    paddingVertical: height * 0.15,<br/>  },<br/>  modalHoursDropdown: {<br/>    flexDirection: 'row',<br/>    justifyContent: 'center',<br/>    alignItems: 'center',<br/>    paddingVertical: theme.SIZES.base,<br/>  },</span></pre><p id="b15a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ab162afb2f75c5510820da627da6db7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*pTvj768lfA0kIKmN.gif"/></div></figure><p id="ef8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，在我们的模式中有小时部分。至此，我们已经结束了这部分的教程。</p><p id="928c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们成功地在地图屏幕上实现了模态。</p><h2 id="6223" class="li lj in bd lk ll lm dn ln lo lp dp lq kg lr ls lt kk lu lv lw ko lx ly lz ma bi translated">结论</h2><p id="da6a" class="pw-post-body-paragraph jv jw in jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">本教程是React原生汽车停车查找器App UI克隆教程系列的第六部分。在这一部分中，我们从本系列教程的第四部分中停止的地方继续。在教程的这一部分，我们学习了如何设置<strong class="jx io"> react-native-modal </strong>包，以便在我们的地图屏幕中实现模型。我们还学习了如何配置模态组件，以便使它看起来和转换更好。然后，我们还深入了解了如何在模态组件中添加不同的UI部分。最后，我们成功地实现了模态视图，就像在实际的应用程序设计中一样。</p><p id="d82b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列教程的下一部分，我们将在停车卡部分实现一个时间下拉菜单。</p></div></div>    
</body>
</html>