<html>
<head>
<title>6 Differences Every JavaScript Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个JavaScript开发人员都应该知道的6个区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dont-get-confused-by-these-6-javascript-terms-665b9bca016e?source=collection_archive---------8-----------------------#2020-10-26">https://javascript.plainenglish.io/dont-get-confused-by-these-6-javascript-terms-665b9bca016e?source=collection_archive---------8-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="74b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过了解这些功能和关键词之间的区别来确定工作面试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/301f7b70dd88d412e2b8ef9bea14c3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vSNWcKWXB6mCO475"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@dexezekiel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dex Ezekiel</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9e4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript有很多听起来和执行类似动作的函数和保留字，许多开发人员互换使用这些术语，却不知道它们之间的重要区别。</p><p id="3050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这不完全是他们的错，因为JavaScript不断引入更好的方法来执行操作，但是为了向后兼容，他们倾向于在旧函数旁边添加新函数，而不是删除执行相同功能的已有函数。</p><p id="acae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在2015年之前，只有一种方法来声明变量，那就是使用关键字<code class="fe ls lt lu lv b">var</code>。没有<code class="fe ls lt lu lv b">let</code>或<code class="fe ls lt lu lv b">const </code>。</p><p id="8bee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">面试官很想知道候选人是否了解这些最新的进展，以测试候选人的知识有多新、多深，以及他/她对执行类似操作的JavaScipt术语的掌握程度。</p><p id="f3aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是你在下一次技术面试中应该知道的6个区别。</p><h2 id="a61a" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">1.let vs var</h2><p id="6301" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><code class="fe ls lt lu lv b">let</code>和<code class="fe ls lt lu lv b">var</code>都是在声明变量时使用的关键字。虽然<code class="fe ls lt lu lv b">var </code>和<code class="fe ls lt lu lv b">let</code>都用于JavaScript中的变量声明，但还是有区别的。</p><p id="a37f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript从2015年ES6版本发布后才开始支持<code class="fe ls lt lu lv b">let </code>，而<code class="fe ls lt lu lv b">var </code>之前就存在了，并且是在<code class="fe ls lt lu lv b">let</code>出现之前声明变量的唯一方式。</p><p id="6e95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个区别是变量作用域，即程序的哪些部分可以访问和使用它。<code class="fe ls lt lu lv b">var</code>是函数作用域，<code class="fe ls lt lu lv b">let</code>使用块作用域。</p><p id="37e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解，我将分享一个相关的例子。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="18df" class="lw lx iq lv b gy my mz l na nb">var a=10;<br/>function myFun(){<br/>for (var i = 0; i &lt; 2; i++) {     <br/>console.log(`Inside the loop: ${i}`); <br/>} <br/>console.log(`Outside the loop: ${i}`);<br/>}<br/>myFun();<br/>console.log(i)</span></pre><p id="ba8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下内容的输出将是:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="9749" class="lw lx iq lv b gy my mz l na nb">Inside the loop: 0</span><span id="7683" class="lw lx iq lv b gy nc mz l na nb">Inside the loop: 1</span><span id="a34e" class="lw lx iq lv b gy nc mz l na nb">Outside the loop: 2</span><span id="24a6" class="lw lx iq lv b gy nc mz l na nb">error: Uncaught ReferenceError: i is not define</span></pre><p id="8f8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，我们甚至可以在for循环之外的同一个函数中使用变量<code class="fe ls lt lu lv b">i</code>的值。这是因为它是使用var声明的，这意味着它将遵循函数作用域。由于变量<code class="fe ls lt lu lv b">a</code>是在函数外部定义的，我们可以在全局范围内使用它。</p><p id="7608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们来看看<code class="fe ls lt lu lv b">let</code>的范围。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="2434" class="lw lx iq lv b gy my mz l na nb">for (let i = 0; i &lt; 2; i++) {<br/>    console.log(`Inside the loop: ${i}`);<br/>}</span><span id="2b85" class="lw lx iq lv b gy nc mz l na nb">console.log(`Outside the loop: ${i}`);</span></pre><p id="75e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="a96f" class="lw lx iq lv b gy my mz l na nb">Inside the loop: 0<br/>Inside the loop: 1<br/>error: Uncaught ReferenceError: i is not defined</span></pre><p id="693f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是不同的，因为<code class="fe ls lt lu lv b">let</code>遵循块范围，这意味着它只能在声明它的for循环中看到和使用，而不能在此之外。</p><p id="786e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到一个更详细的例子<a class="ae kv" href="https://www.geeksforgeeks.org/difference-between-var-and-let-in-javascript/" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="167c" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">2.静止与扩散</h2><p id="ede9" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">rest和spread操作符在语法上看起来非常相似。但两者都用于执行本质上完全相反的操作。</p><p id="df2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个好的开发人员应该能够停止差异，并知道何时使用rest和spread运算符。</p><p id="1c1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们不知道可能收到的参数数量时，在接受参数时使用Rest运算符。</p><p id="f7e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑下面的例子:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="a650" class="lw lx iq lv b gy my mz l na nb">function sumAll(...args) { // args is the name for the array<br/>  let sum = 0;</span><span id="37b7" class="lw lx iq lv b gy nc mz l na nb">  for (let arg of args) <br/>     sum += arg;</span><span id="9e43" class="lw lx iq lv b gy nc mz l na nb">  return sum;<br/>}</span><span id="56f6" class="lw lx iq lv b gy nc mz l na nb">console.log( sumAll(5) ); // 5<br/>console.log( sumAll(5, 10) ); // 15<br/>console.log( sumAll(5, 10, 15) ); //30</span></pre><p id="6216" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用rest操作符接受未知数量的参数，如<code class="fe ls lt lu lv b">…args</code>所示，其中“args”是数组名。</p><p id="daae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管展开运算符在语法上看起来相似，但它们的行为却不同。spread运算符允许数组/字符串/对象扩展成一个参数列表。</p><p id="2ebb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，它服务于与rest操作符完全相反的目的。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="784f" class="lw lx iq lv b gy my mz l na nb">const arr = ["2", "3", "4"];<br/>const newArr = ["1", ...arr];<br/>console.log(newArr)</span></pre><p id="8a2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在数组<code class="fe ls lt lu lv b">arr</code>上使用了spread操作符，将数组的元素添加到名为<code class="fe ls lt lu lv b">newArr</code>的新数组中。我们的代码片段将把<code class="fe ls lt lu lv b">[“1”,”2”,”3”,”4”]</code>记录到控制台。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="4c3b" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">3.函数与方法</h2><p id="f37b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">大多数程序员交替使用术语“函数”和“方法”,但是存在一个微妙但明显的区别。</p><p id="7826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，一切都被认为是一个对象。字符串是对象，数组也是对象。函数是一个对象，而方法是属于另一个对象的函数。</p><p id="ddef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，要调用一个方法，我们需要引用它所属的对象，有时也称为“接收者”对象，而对于函数，我们可以直接调用函数。</p><p id="d367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道这可能会令人困惑，但希望下面的代码片段能让你有一个清晰的理解。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="3116" class="lw lx iq lv b gy my mz l na nb">var myObject= {<br/>  myMethod: function() {<br/>    console.log("Method");<br/>  }<br/>};<br/>myObject.myMethod;<br/>         <br/>var myFunction = ()=&gt;{ <br/>    console.log("function)<br/>}<br/>myFunction();</span></pre><p id="88fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要调用<code class="fe ls lt lu lv b">myMethod()</code>，我们必须首先引用<code class="fe ls lt lu lv b">myObject</code>，在本例中，T5是声明方法的对象。另一方面，我们可以在没有任何对象引用的情况下调用<code class="fe ls lt lu lv b">myFunction()</code>。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="76e3" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">4.切片与拼接</h2><p id="0308" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">切片和拼接是对数组执行某些操作的方法。作为一名开发人员，当我开始我的编码之旅时，我总是认为他们执行相同的操作，只有最小的差异。</p><p id="e665" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这两种方法非常不同，尽管它们听起来很相似。简而言之，切片方法可以比作字符串的“子串”方法。slice方法检索数组的元素，并接受两个参数——要检索的元素的起始和结束索引。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="382d" class="lw lx iq lv b gy my mz l na nb">const arr = ["Christmas", "Halloween", "New Year"];</span><span id="e657" class="lw lx iq lv b gy nc mz l na nb">console.log(arr.slice(0,2)) // --&gt; ["Christmas","Halloween"]<br/>console.log(arr) // --&gt; ["Christmas", "Halloween", "New Year"]</span></pre><p id="a429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我让控制台再次记录数组“arr”的原因是为了强调slice方法对原始数组没有任何影响。</p><p id="0951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，拼接方法接受更多的参数并影响原始数组。</p><p id="fdae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拼接方法执行阵列中元素的移除和替换。拼接方法至少采用2个参数，即开始索引和要从该开始索引中删除的元素数量。</p><p id="6e8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，您可以将您想要插入的值作为参数传递。您传递的值将被添加到您作为第一个参数提供的开始索引之后。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="3ab4" class="lw lx iq lv b gy my mz l na nb">const arr = ["Christmas", "Halloween", "New Year"];</span><span id="22b6" class="lw lx iq lv b gy nc mz l na nb">console.log(arr.splice(0,1))<br/>console.log(arr);<br/>arr.splice(0,1,"Chistmas");<br/>console.log(arr)</span></pre><p id="3d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述代码片段的输出如下所示:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="0f77" class="lw lx iq lv b gy my mz l na nb">["Christmas"]</span><span id="8b9a" class="lw lx iq lv b gy nc mz l na nb">["Halloween","New Year"]</span><span id="6e4f" class="lw lx iq lv b gy nc mz l na nb">["Chistmas","New Year"]</span></pre><p id="5515" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您仔细观察，您可以看到拼接方法返回它已移除的元素，如第一个控制台日志所示，其中它返回数组的第一个元素。</p><p id="8a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个收获是，当我们第二次记录数组时，我们看到拼接方法确实从原始数组中移除了第一个元素。</p><p id="3b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，切片和拼接方法用于完全不同的目的。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="3fd6" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">5.三重等号(===)对双等号(==)</h2><p id="363e" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">了解这两者之间的区别非常有用，不仅在面试中，在构建复杂的应用程序时也是如此。JavaScript的优势之一是类型推断，它可以为我们确定类型。</p><p id="4a56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们将数字1存储在一个变量中，它会自动确定它是一个数字，如果我们尝试将“1”存储在一个变量中，它可以推断类型是String。</p><p id="1dfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这种初学者友好的方法受到欢迎，但有时我们需要匹配类型，以获得无错误和健壮的代码。</p><p id="ce3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是知道三倍和两倍等号之间的区别的地方。三重等号等于匹配类型以及值，而双等号正好匹配值。如下面提供的代码片段所示:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="99c9" class="lw lx iq lv b gy my mz l na nb">let number = 1234;</span><span id="e5af" class="lw lx iq lv b gy nc mz l na nb">let stringNumber = '1234';</span><span id="ed24" class="lw lx iq lv b gy nc mz l na nb">console.log(number == stringNumber); <em class="nk">//true</em></span><span id="9126" class="lw lx iq lv b gy nc mz l na nb">console.log(number === stringNumber);  <em class="nk">//false</em></span></pre><p id="4849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，“1234”是一个字符串，而1234是一个数字。tripe运算符符号根据类型以及所示进行区分，而double等号只匹配值，而不匹配类型。</p><p id="77c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，当练习JavaScript的<a class="ae kv" href="https://medium.com/javascript-in-plain-english/5-modern-practices-of-javascript-that-every-developer-should-know-1a61dc9a6ee0" rel="noopener">现代规则</a>时，大多数林挺软件会将双等号标记为不良练习的警告。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="4ac4" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">6.Map与forEach方法</h2><p id="7e70" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">使用这两种方法可以帮您省去很多麻烦，同时也有利于可读性。虽然<code class="fe ls lt lu lv b">map()</code>和<code class="fe ls lt lu lv b">forEach()</code>都在阵列上工作，但它们都用于不同的目的。</p><p id="bbae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种方法都将一个函数作为参数，并将该函数应用于数组的每个元素。然而，它们返回不同的值。forEach方法总是返回未定义的，而map方法在执行该函数后返回一个新的数组。</p><p id="2b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这个原因，<code class="fe ls lt lu lv b">map()</code>变成了可链接的，也就是说，你可以在它后面附加其他的方法，比如<code class="fe ls lt lu lv b">sort()</code>和<code class="fe ls lt lu lv b">reduce()</code>。这对于forEach方法是不可能的，因为它返回一个未定义的值。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="e197" class="lw lx iq lv b gy my mz l na nb">var arr= [3,2,1];<br/>var doubled= arr.map(currentValue =&gt; currentValue*2).sort();<br/>console.log(doubled) // --&gt; [2,4,6]</span><span id="c1c6" class="lw lx iq lv b gy nc mz l na nb">var Val= arr.forEach(x=&gt;x*x)<br/>console.log(Val) // --&gt; undefined</span><span id="e98d" class="lw lx iq lv b gy nc mz l na nb">console.log(arr) //--&gt; [3,2,1]</span></pre><p id="f506" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码片段中，我们在数组“arr”上使用了<code class="fe ls lt lu lv b">map()</code>，还链接了<code class="fe ls lt lu lv b">sort()</code>方法，并将结果数组存储在“doubled”中。</p><p id="d54a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们使用<code class="fe ls lt lu lv b"> forEach()</code>对数组的每个元素求平方，并将返回值存储在变量‘Val’中，如控制台日志所示，该变量包含一个未定义的值。</p><p id="4bf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，为了强调没有任何东西影响原始数组，我也记录了它。</p><p id="a1a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，仅仅因为您可以使用<code class="fe ls lt lu lv b">map()</code>来执行forEach方法的任务以及更多任务，并不会削弱forEach方法的价值。forEach方法为for循环提供了一个简单的替代方法，如下所示:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="0d29" class="lw lx iq lv b gy my mz l na nb">var arr= [3,2,1];<br/>for(let i=0;i&lt;arr.length;i++)<br/>    console.log(arr[i]**2);</span><span id="1cb4" class="lw lx iq lv b gy nc mz l na nb">console.log('-------------')<br/>arr.forEach(x=&gt;console.log(x**2))</span></pre><p id="30b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出如下所示:</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="ead0" class="lw lx iq lv b gy my mz l na nb">9</span><span id="eae5" class="lw lx iq lv b gy nc mz l na nb">4</span><span id="00a4" class="lw lx iq lv b gy nc mz l na nb">1</span><span id="e319" class="lw lx iq lv b gy nc mz l na nb">-------------</span><span id="570a" class="lw lx iq lv b gy nc mz l na nb">9</span><span id="baa8" class="lw lx iq lv b gy nc mz l na nb">4</span><span id="f6b0" class="lw lx iq lv b gy nc mz l na nb">1</span></pre><p id="09f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您只想遍历元素而不需要存储新形成的数组，那么使用forEach方法是最好的方法，否则您可以使用map方法。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="754d" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">最后的想法</h2><p id="ebfe" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">JavaScript正在发展以满足市场创造的新需求。掌握这样一种流行的语言可以深刻地影响你的程序员生涯。</p><p id="1bed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，保持与JavaScript领域的最新发展保持联系变得越来越重要，这有助于让你的职业生涯走上正轨。有些方法听起来和执行起来类似，比如forEach和Map方法，但是有细微的差别，一个熟练的开发人员应该能够利用这些差别。</p><p id="99a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，了解一些最广泛使用的方法和操作者的差异和用例，对于破解技术性工作面试并获得相对于其他人的优势至关重要。</p><p id="9745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>