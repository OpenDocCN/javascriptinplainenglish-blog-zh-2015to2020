<html>
<head>
<title>Magnificent Tricks Of Spread Operator In JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中扩展运算符的精彩技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-es6-the-spread-operator-197cfb7c46ad?source=collection_archive---------3-----------------------#2020-01-02">https://javascript.plainenglish.io/javascript-es6-the-spread-operator-197cfb7c46ad?source=collection_archive---------3-----------------------#2020-01-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ac7b60692e1d7a6af6d6354c0baf6038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a5qLzDED5oYUva4YOeqsyQ.png"/></div></div></figure><h1 id="cbd8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是传播算子？</h1><p id="2ab4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">JavaScript ES6版本带来了一系列新的工具和实用程序。一个这样的新特性是<strong class="kv io">传播算子</strong>。</p><p id="21e2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">运算符的形状是三个连续的点，记为:<code class="fe lw lx ly lz b">...</code></p><p id="40b3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">它允许iterable在应该有0+个参数的地方扩展。</strong></p><p id="064d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您可以对数组和对象使用spread运算符。您可以在不同的情况下使用它们:扩展数组或对象、组合或合并数组和对象、克隆数组和对象以及使用数学函数。</p><p id="5a1f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">没有上下文，定义是很难的。让我们探索一些不同的使用案例:</p><h1 id="8c38" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">扩展数组或对象:</h1><p id="36b8" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">使用新元素或以其他名称扩展数组或对象向数组或对象添加元素或属性以及对数组的操作(按下-取消移动):</p><h2 id="0f41" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">数组:</h2><p id="0adf" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">示例1:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="de07" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">示例2:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="7f73" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">对象:</h2><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="d9be" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">另一个例子:</h2><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="61ba" class="ma jw in lz b gy mw mx l my mz">pickau = {…pickau, hp: 45} ;</span><span id="753a" class="ma jw in lz b gy na mx l my mz">console.log(pickau)</span><span id="016b" class="ma jw in lz b gy na mx l my mz"><strong class="lz io">//Output:</strong>{ name: “pickau” , hp: 40 }</span></pre><h1 id="ee8f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">组合或合并数组和对象:</h1><p id="e200" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">假设我们有两个不同来源的列表，我们希望将这两个来源组合起来，形成一个列表:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="b6cd" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">克隆阵列和对象:</h1><h2 id="d816" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">克隆阵列:</h2><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="30df" class="ma jw in lz b gy mw mx l my mz">const arr = [‘1’, ‘2’, ‘3’];</span><span id="9073" class="ma jw in lz b gy na mx l my mz">const cloneArr = […arr];</span><span id="668c" class="ma jw in lz b gy na mx l my mz">console.log(cloneArr);</span></pre><h2 id="2360" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated"><strong class="ak">永远不要克隆下面的代码:</strong></h2><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="1c79" class="ma jw in lz b gy mw mx l my mz">const arr = [‘1’, ‘2’, ‘3’];</span><span id="2432" class="ma jw in lz b gy na mx l my mz">const cloneArr = arr;</span><span id="c8af" class="ma jw in lz b gy na mx l my mz">console.log(cloneArr);</span></pre><h2 id="20ca" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated"><strong class="ak">为什么？</strong></h2><p id="7368" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kv io">因为JS中的</strong>数组是引用值，所以当你试图用=来复制它时它只会复制对原始数组的引用而不会复制数组的值，所以如果你会做下面的代码:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="a0c4" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated"><strong class="ak">对象克隆:</strong></h2><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="e4eb" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">与数学函数一起使用</h1><p id="e298" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">JavaScript有一个<code class="fe lw lx ly lz b">Math</code>对象，它包含几个方法来操作一组数据，即数据列表。</p><p id="0fa6" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">假设我们想从列表的前三个数字中获取最大值:</p><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="9a7c" class="ma jw in lz b gy mw mx l my mz">let<!-- --> arr = [<!-- -->10<!-- -->, <!-- -->23<!-- -->, <!-- -->83<!-- -->, <!-- -->-1<!-- -->, <!-- -->92<!-- -->, <!-- -->-33<!-- -->, <!-- -->76<!-- -->, <!-- -->29<!-- -->, <!-- -->76<!-- -->, <!-- -->100<!-- -->, <!-- -->644<!-- -->, <!-- -->-633<!-- -->];</span><span id="fe5f" class="ma jw in lz b gy na mx l my mz">Math<!-- -->.max(arr[<!-- -->0<!-- -->], arr[<!-- -->1<!-- -->], arr[<!-- -->2<!-- -->]);</span></pre><p id="dc22" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果我们想得到一个列表中所有数字的最大值呢？如果列表有n个条目呢？我们肯定不会要<code class="fe lw lx ly lz b">arr[0], arr[1]... arr[1000]</code>。</p><p id="561a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">扩展运算符提供了一个更简洁的解决方案:</p><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="80ed" class="ma jw in lz b gy mw mx l my mz">let<!-- --> arr = [<!-- -->10<!-- -->, <!-- -->23<!-- -->, <!-- -->83<!-- -->, <!-- -->-1<!-- -->, <!-- -->92<!-- -->, <!-- -->-33<!-- -->, <!-- -->76<!-- -->, <!-- -->29<!-- -->, <!-- -->76<!-- -->, <!-- -->100<!-- -->, <!-- -->644<!-- -->, <!-- -->-633<!-- -->];</span><span id="33b8" class="ma jw in lz b gy na mx l my mz">Math<!-- -->.max(...arr);</span></pre><p id="32c4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">spread运算符与Math.min()很好地结合在一起，用于查找数组中的最小数字:</p><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="31b0" class="ma jw in lz b gy mw mx l my mz">let<!-- --> arr = [<!-- -->10<!-- -->, <!-- -->23<!-- -->, <!-- -->83<!-- -->, <!-- -->-1<!-- -->, <!-- -->92<!-- -->, <!-- -->-33<!-- -->, <!-- -->76<!-- -->, <!-- -->29<!-- -->, <!-- -->76<!-- -->, <!-- -->100<!-- -->, <!-- -->644<!-- -->, <!-- -->-633<!-- -->];</span><span id="b013" class="ma jw in lz b gy na mx l my mz">Math<!-- -->.min(...arr);</span></pre><p id="5de9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我建议欧洲大学<a class="ae nb" href="https://click.linksynergy.com/fs-bin/click?id=GGg4no0HUcA&amp;offerid=871625.130&amp;subid=0&amp;type=4" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">在线学位</strong> </a>课程的读者，他们中的许多人都是<a class="ae nb" href="https://click.linksynergy.com/fs-bin/click?id=GGg4no0HUcA&amp;offerid=871625.130&amp;subid=0&amp;type=4" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">免费的。</strong> </a></p><h1 id="4663" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">接受函数中任意数量的参数:</h1><p id="e63a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果您不知道在一个arrow函数中需要接受多少个参数，您可以使用带有“rest”参数的spread运算符来实现这一点:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="812f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">一些与传播有关的技巧:</strong></h1><h2 id="b2c5" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">1-第一个</h2><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="b592" class="ma jw in lz b gy mw mx l my mz">let greet = ['Hello', 'World'];</span><span id="8bdb" class="ma jw in lz b gy na mx l my mz">console.log(greet); <em class="nc">// Without spread operator</em></span><span id="9107" class="ma jw in lz b gy na mx l my mz">console.log(…greet); <em class="nc">// Using spread operator</em></span><span id="4047" class="ma jw in lz b gy na mx l my mz">/* If we run this code we’ll see the following:</span><span id="10e6" class="ma jw in lz b gy na mx l my mz">[‘Hello’, ‘World’]</span><span id="44c7" class="ma jw in lz b gy na mx l my mz">Hello World */</span></pre><h2 id="7e51" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">2秒钟技巧:</h2><p id="61b2" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有时，我们可能需要将一个字符串转换成一个字符列表。我们可以对这个用例使用扩展运算符:</p><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="d1c3" class="ma jw in lz b gy mw mx l my mz">let greetings = “hello”;</span><span id="7f50" class="ma jw in lz b gy na mx l my mz">let chars = […greetings];</span><span id="1ba5" class="ma jw in lz b gy na mx l my mz">console.log(chars);</span><span id="b7d9" class="ma jw in lz b gy na mx l my mz">/*If we run this code, we’ll be greeted with:</span><span id="e55c" class="ma jw in lz b gy na mx l my mz">[ ‘h’, ‘e’, ‘l’, ‘l’, ‘o’ ] */</span></pre><h2 id="0888" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">3-组织属性</h2><p id="4195" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有时属性并没有按照我们需要的顺序排列。使用一些技巧，我们可以将属性推到列表的顶部，或者将它们移到底部。</p><p id="35af" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">要将<code class="fe lw lx ly lz b">id</code>移动到第一个位置，在展开<code class="fe lw lx ly lz b">object</code>之前将<code class="fe lw lx ly lz b">id: undefined</code>添加到新对象。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="77e4" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">第四招:</h2><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="1020" class="ma jw in lz b gy mw mx l my mz">let arr1 = [‘arbok’,’kfc’,’mack’];</span><span id="1fb1" class="ma jw in lz b gy na mx l my mz">let arr2 = [‘sfdsdfs’, ‘tyutyu’, ‘bnmbn’ ]</span><span id="812c" class="ma jw in lz b gy na mx l my mz">arr1 = [arr1, …arr2];</span><span id="faf7" class="ma jw in lz b gy na mx l my mz">//output: [Array(3), “sfdsdfs”, “tyutyu”, “bnmbn”]</span><span id="1b37" class="ma jw in lz b gy na mx l my mz">arr1 = […arr1, arr2];</span><span id="e34a" class="ma jw in lz b gy na mx l my mz">//output: [“arbok”, “kfc”, “mack”, Array(3)]</span></pre><h2 id="2c24" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">第五招:</h2><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="a821" class="ma jw in lz b gy mw mx l my mz">let obj1 = {name: ‘John’, email: ‘john@example.com’ };</span><span id="6a75" class="ma jw in lz b gy na mx l my mz">let obj2 = {name: ‘Michael’, email: ‘Michael@example.com’}</span><span id="568a" class="ma jw in lz b gy na mx l my mz">obj1 = {obj1, …obj2};</span><span id="17f4" class="ma jw in lz b gy na mx l my mz">console.log(obj1)</span><span id="9779" class="ma jw in lz b gy na mx l my mz">//Output: {obj1: {…}, name: “Michael”, email: “Michael@example.com”}</span><span id="4918" class="ma jw in lz b gy na mx l my mz">obj1 = { …obj2, obj1 };</span><span id="db61" class="ma jw in lz b gy na mx l my mz">console.log(obj1)</span><span id="94ee" class="ma jw in lz b gy na mx l my mz">//output: {name: "Michael", email: "Michael@example.com", obj1: {…}}</span></pre><h1 id="d728" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">浅层拷贝和深层拷贝:</h1><p id="0a1a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">请注意<code class="fe lw lx ly lz b">spread</code>在复制数组时只深入一层。因此，如果你试图复制一个多维数组，你将不得不使用其他替代方法。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1f12" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">🤓这是我学到的一件有趣的事。浅拷贝意味着第一层被拷贝，更深的层被<strong class="kv io">引用</strong>。</p><h2 id="6a0f" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">问题是</h2><p id="4de3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">扩展语法和<code class="fe lw lx ly lz b">Object.assign()</code>方法只能对对象进行浅层复制。这意味着被复制对象内部的深层嵌套值被放在那里，只是作为对源对象的引用。</p><h2 id="a70d" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">错误的解决方案</h2><p id="6329" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在网上你会发现许多错误的建议:</p><ol class=""><li id="63e4" class="nd ne in kv b kw lr la ls le nf li ng lm nh lq ni nj nk nl bi translated">使用Object.create():</li></ol><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="b5f2" class="ma jw in lz b gy mw mx l my mz">const copied = Object.create(original)</span></pre><p id="dc34" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这里<code class="fe lw lx ly lz b">original</code>对象被用作<code class="fe lw lx ly lz b">copied</code>的<strong class="kv io">原型</strong>。</p><p id="37b3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它看起来很好，但在引擎盖下，它不是:</p><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="dda1" class="ma jw in lz b gy mw mx l my mz">const original = {<br/>  name: 'Fiesta'<br/>}<br/>const copied = Object.create(original)<br/>copied.name //Fiesta</span><span id="fd8d" class="ma jw in lz b gy na mx l my mz">original.hasOwnProperty('name') //true<br/>copied.hasOwnProperty('name') //false</span></pre><p id="4c57" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">2.JSON序列化:</p><p id="f6bc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这只有在你没有任何内部对象和函数，只有值的情况下才有效。</p><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="f7de" class="ma jw in lz b gy mw mx l my mz">const cloned = JSON.parse(JSON.stringify(original))</span></pre><p id="6a88" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是你会有以下副作用:</p><p id="f181" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您将<strong class="kv io">失去</strong>任何在JSON中没有等价类型的JavaScript属性，比如<code class="fe lw lx ly lz b">Function</code>或<code class="fe lw lx ly lz b">Infinity</code>。分配给<code class="fe lw lx ly lz b">undefined</code>的任何属性都将被<code class="fe lw lx ly lz b">JSON.stringify</code>忽略，导致它们在克隆对象上丢失。</p><p id="9374" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">此外，一些对象被转换为字符串，例如Date对象(同样，不考虑时区，默认为UTC)。</p><h1 id="88f3" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">那么我们如何用正确的方法克隆一个物体呢？</h1><h2 id="cc59" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">1-使用<a class="ae nb" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">Lodash</a>T21【克隆】和<a class="ae nb" href="https://www.npmjs.com/package/lodash.clonedeep" rel="noopener ugc nofollow" target="_blank">克隆深度</a></h2><p id="74dd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Lodash有两个不同的功能，允许你做浅层拷贝和深层拷贝。这些是<code class="fe lw lx ly lz b">clone</code>和<code class="fe lw lx ly lz b">clonedeep</code>。</p><p id="0b20" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">Lodash有一个很好的特性:<strong class="kv io">你可以在你的项目中单独导入单个函数</strong>来减少依赖的大小。</p><p id="53e3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">看看下面的例子就明白了:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="d963" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated">2-使用不变性助手库:</h2><p id="b0ad" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">对对象的副本进行变异，而不更改原始源。</p><p id="2fbd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">通过NPM设置</p><pre class="mm mn mo mp gt ms lz mt mu aw mv bi"><span id="df39" class="ma jw in lz b gy mw mx l my mz">npm install immutability-helper --save</span></pre><p id="3c92" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们可以通过NPM得到这个图书馆:<code class="fe lw lx ly lz b">npm install immutability-helper --save</code>。<br/>要深度复制我们的对象，我们可以使用immutanbility-helper中可用的<code class="fe lw lx ly lz b">update()</code>方法，将我们要复制的对象作为第一个参数传递，将要更改的实际数据作为第二个参数传递:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5849" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你喜欢读这篇文章，并且想支持我成为一名作家，你可以<a class="ae nb" href="http://buymeacoffee.com/kirillibrahim" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">请我喝杯咖啡！</strong> </a></p><p id="78b8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你喜欢我的内容，我活跃在Twitter<a class="ae nb" href="https://twitter.com/IbraKirill" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">@ IbraKirill</strong></a>。</p><p id="f6e0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你想深入研究JavaScript，我可以建议你看一下<a class="ae nb" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.1586988&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fjavascript-bible%2F" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">JavaScript圣经教程</strong> </a>，或者看一下<a class="ae nb" href="https://click.linksynergy.com/link?id=GGg4no0HUcA&amp;offerid=507388.1345036&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fthe-complete-javascript-development-course-%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">完整的现代JavaScript教程</strong> </a>。</p><h2 id="7f15" class="ma jw in bd jx mb mc dn kb md me dp kf le mf mg kj li mh mi kn lm mj mk kr ml bi translated"><strong class="ak">用简单英语写的JavaScript的注释:</strong></h2><p id="d621" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae nb" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>