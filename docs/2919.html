<html>
<head>
<title>A Deeper Look at Angular Template Driven Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解角度模板驱动的表单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-deeper-look-at-angular-template-driven-form-ffd7d4856679?source=collection_archive---------0-----------------------#2020-08-06">https://javascript.plainenglish.io/a-deeper-look-at-angular-template-driven-form-ffd7d4856679?source=collection_archive---------0-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/130485653fd08bf05c27c56c314f8a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVPUvwMMRAxyK_k5bdALEg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="fa60" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">探索以最简单的方式创建复杂表单的方法</h2></div><h1 id="0795" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">介绍</h1><p id="7f59" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated"><strong class="lk jc">表单</strong>是互联网上广泛使用的工具，知道如何处理用户输入<strong class="lk jc">是每个优秀的web开发人员都应该具备的技能</strong>。</p><p id="39e6" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated"><strong class="lk jc">处理表单从来都不容易</strong>，尤其是如果你在<strong class="lk jc">企业开发</strong>中工作，那里有更复杂的场景，你有大量的用户输入。</p><p id="557a" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">每个表单密集型应用程序<strong class="lk jc">都必须回答以下问题</strong>:</p><ul class=""><li id="a4fa" class="mj mk jb lk b ll me lo mf lr ml lv mm lz mn md mo mp mq mr bi translated"><strong class="lk jc">全局跟踪表单状态</strong></li><li id="c36c" class="mj mk jb lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated"><strong class="lk jc">处理输入控件的有效性</strong></li><li id="8b0f" class="mj mk jb lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated"><strong class="lk jc">显示用户友好的错误信息，以便用户知道如何解决问题</strong></li></ul><p id="9983" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">Angular通过使用框架风格的方法解决了与表单复杂性相关的问题，给出了两种创建表单的方法:<strong class="lk jc">模板驱动</strong>或<strong class="lk jc">反应式</strong>。</p><p id="2ff9" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">在这篇文章中，我们将深入了解模板驱动方法，这是在Angular中创建表单最快最简单的方法。</p><h1 id="c288" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">角度模板驱动的表单</h1><blockquote class="mx"><p id="0f21" class="my mz jb bd na nb nc nd ne nf ng md dk translated">模板驱动表单是用一种方法创建的表单，其中输入控件的数据和行为是在模板级别声明和管理的</p></blockquote><p id="13e0" class="pw-post-body-paragraph li lj jb lk b ll nh kc ln lo ni kf lq lr nj lt lu lv nk lx ly lz nl mb mc md ij bi translated">使用这个指令<strong class="lk jc">构建的表单只能在端到端测试</strong>中进行测试，因为这需要一个<strong class="lk jc"> DOM </strong>的存在，但是这种机制仍然非常有用，并且易于理解。</p><h1 id="e737" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">快速浏览如何使用模板驱动的表单</h1><h2 id="ba68" class="nm kr jb bd ks nn no dn kw np nq dp la lr nr ns lc lv nt nu le lz nv nw lg nx bi translated">启用模板驱动的表单</h2><p id="8af7" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">要开始在Angular <strong class="lk jc">中使用表单，我们需要在我们的应用程序模块</strong>中显式导入它们:</p><figure class="ny nz oa ob gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="2c28" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">我们的第一个模板驱动表单</h1><p id="9a51" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">让我们来看一个<strong class="lk jc">基本表单模板，它模拟了一个真实的工作登录过程</strong>，请求用户插入一些信息:</p><figure class="ny nz oa ob gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4446" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们在这里做的是用<strong class="lk jc">两个控件</strong>，用户名和密码声明一个简单的表单，这两个控件都是<strong class="lk jc">必填字段</strong> ( <em class="oe">标有</em> <code class="fe of og oh oi b"><em class="oe">required</em></code> <em class="oe">属性</em>)。</p><p id="a009" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">一旦用户填写了所有请求的输入，提交按钮将被启用。</p><p id="ab42" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">当用户单击submit按钮时，在模板表单顶部声明的关联方法<code class="fe of og oh oi b"><em class="oe">(ngSubmit)="onSubmitForm()"</em></code>将被触发，您可以在这里编写逻辑来发送用于身份验证的数据。</p><p id="815b" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">在Angular中制作一个工作模板驱动的表单<strong class="lk jc">非常简单快速</strong>，但是如果你想创建更复杂的解决方案，你需要理解<strong class="lk jc">这种类型的表单声明是如何工作的</strong>所以在接下来的章节中跟随我来解锁。</p><h1 id="91e5" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">NgModel验证功能</h1><p id="8c61" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">决定组件变量和模板中发生的事情之间的链接的关键是<code class="fe of og oh oi b">[(ngModel)]</code>，这种符号强调两个表单控件与一个视图模型变量双向绑定，简称为<code class="fe of og oh oi b">user</code>。</p><p id="2685" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">更重要的是，当用户点击一个必填字段时，<strong class="lk jc">该字段显示为红色，直到用户输入一些内容。</strong></p><p id="c299" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">Angular实际上是在为我们跟踪三个表单字段状态，并将下面的CSS类应用到表单及其控件中:</p><ul class=""><li id="8f02" class="mj mk jb lk b ll me lo mf lr ml lv mm lz mn md mo mp mq mr bi translated"><strong class="lk jc">触动</strong>或<strong class="lk jc">未触动</strong></li><li id="bf21" class="mj mk jb lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated"><strong class="lk jc">有效</strong>或<strong class="lk jc">无效</strong></li><li id="9856" class="mj mk jb lk b ll ms lo mt lr mu lv mv lz mw md mo mp mq mr bi translated"><strong class="lk jc">洁净的</strong>或<strong class="lk jc">肮脏的</strong></li></ul><blockquote class="oj ok ol"><p id="2d58" class="li lj oe lk b ll me kc ln lo mf kf lq om mg lt lu on mh lx ly oo mi mb mc md ij bi translated">这些CSS状态类对于设计表单错误状态非常有用。</p></blockquote><p id="fa69" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">Angular实际上也在跟踪整个表单的有效性状态，用它来启用/禁用提交按钮。</p><h1 id="195c" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">这一切的逻辑一定在控制器里，对吧？</h1><p id="369f" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">让我们看看与视图相关联的控制器<strong class="lk jc">，看看所有这些表单逻辑是如何实现的:</strong></p><figure class="ny nz oa ob gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="63b2" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们只有一个视图模型对象<code class="fe of og oh oi b">user</code>的声明，和一个<code class="fe of og oh oi b">ngSubmit</code>使用的事件处理程序。</p><p id="c0d0" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">跟踪表单错误和注册验证器的所有非常有用的功能都由我们<strong class="lk jc">负责，没有任何特殊的配置</strong>。</p><h1 id="dffd" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">那Angular是怎么做到的呢？</h1><p id="a2ae" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">其工作方式是，有一组隐式定义的表单指令应用于视图。</p><blockquote class="mx"><p id="4a3f" class="my mz jb bd na nb nc nd ne nf ng md dk translated">Angular将自动对表单应用一个表单级指令，创建一个<code class="fe of og oh oi b">FormGroup</code>，并将其链接到表单。</p></blockquote><blockquote class="oj ok ol"><p id="c64f" class="li lj oe lk b ll nh kc ln lo ni kf lq om nj lt lu on nk lx ly oo nl mb mc md ij bi translated">如果出于某种原因你不想要这个，你可以通过添加<code class="fe of og oh oi b">ngNoForm</code>作为表单属性来禁用这个功能。</p></blockquote><p id="a837" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">此外，每个输入还将被应用一个向控件组注册自身的指令，如果像<code class="fe of og oh oi b">required</code>或<code class="fe of og oh oi b">maxlength</code>这样的元素被应用到输入，验证器将被注册。</p><p id="46b0" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated"><code class="fe of og oh oi b">[(ngModel)]</code>的存在也将在表单和用户模型之间创建一个双向绑定<strong class="lk jc">，所以你不需要手动将表单中的值分配给你的局部变量。</strong></p><p id="d200" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">这就是为什么这被称为模板驱动的表单，因为验证和绑定都是在模板的层次上以声明的方式<strong class="lk jc">建立的。</strong></p><h1 id="f1b5" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">如果我们不需要双向绑定，只需要字段初始化呢？</h1><p id="cbf8" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">有时候我们只想创建一个表单并初始化它，但不一定要做双向绑定。</p><p id="0090" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们可能希望让用户填写表单并按submit，然后才获得最新的值。</p><p id="df83" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们可以通过使用简单的<code class="fe of og oh oi b">[ngModel]</code>语法来做到这一点:</p><figure class="ny nz oa ob gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d466" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">这将允许我们通过填写用户对象的字段来初始化表单:</p><figure class="ny nz oa ob gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="61d6" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">如果我们不需要字段初始化，还能得到验证吗？</h1><p id="f9c9" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">表单不需要初始值，只需要验证。</p><p id="0230" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">如果我们只想获得<code class="fe of og oh oi b">ngModel</code>的验证功能，而不需要初始化值或双向绑定，我们可以使用下面的语法:</p><figure class="ny nz oa ob gt is"><div class="bz fp l di"><div class="oc od l"/></div></figure><h1 id="6eb3" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">使用模板驱动表单的利弊</h1><p id="80c7" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们在这篇文章中做的例子非常简单，如果我们有更复杂的表单要做，我们还必须考虑如何阅读。</p><blockquote class="mx"><p id="381e" class="my mz jb bd na nb nc nd ne nf ng md dk translated">当我们在一个字段中添加越来越多的validator标签，或者开始添加复杂的跨字段验证时，表单的可读性就会降低。</p></blockquote><p id="678d" class="pw-post-body-paragraph li lj jb lk b ll nh kc ln lo ni kf lq lr nj lt lu lv nk lx ly lz nl mb mc md ij bi translated">这种处理表单的方式的优点是它的简单性，这对于构建大范围的表单来说可能绰绰有余。</p><p id="1a63" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">不利的一面是，<strong class="lk jc">表单验证逻辑无法进行单元测试</strong>。</p><p id="08bf" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">测试这种逻辑的唯一方法是使用浏览器运行<strong class="lk jc">端到端测试，例如使用像<code class="fe of og oh oi b">PhantomJs</code>这样的无头浏览器。</strong></p><p id="1b95" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">一天，一位教授告诉我:</p><blockquote class="mx"><p id="05cf" class="my mz jb bd na nb nc nd ne nf ng md dk translated">“如果市场上同时存在两种类似的东西，那么这意味着它们提供不同的解决方案，解决不同的问题”</p></blockquote><p id="173d" class="pw-post-body-paragraph li lj jb lk b ll nh kc ln lo ni kf lq lr nj lt lu lv nk lx ly lz nl mb mc md ij bi translated">确切地说，Angular有两种处理表单的方法:模板驱动的方法，也就是本文的方法，或者使用反应式表单。</p><p id="6e47" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">如果模板驱动的方法非常简单和直观，那么<strong class="lk jc">反应式表单可以让你控制表单声明的所有方面</strong>。</p><p id="8537" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated"><em class="oe">那么为什么不一直使用反应式呢？</em></p><p id="0bc4" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">因为反应式表单是一种更复杂的处理表单的方式，当我们需要管理的输入控件很少时，我们不需要这种深度。</p><p id="3711" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们在本文中制作的登录表单是一个很好的例子<strong class="lk jc">，这种情况下<strong class="lk jc">模板驱动的方法是最好的</strong>，我们只有两个输入和一个按钮来提交数据，所有的凭证都自动写入我们的组件变量中，我们只需要调用API来进行身份验证。</strong></p><blockquote class="oj ok ol"><p id="682c" class="li lj oe lk b ll me kc ln lo mf kf lq om mg lt lu on mh lx ly oo mi mb mc md ij bi translated">另一方面，如果我们制作了一个注册表单，它通常有许多不同类型的字段，那么用反应方式声明表单会更好。</p></blockquote><h1 id="4f71" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">从函数式编程角度的一些想法</h1><p id="896a" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">模板驱动的表单并没有错，但是从<strong class="lk jc">编程技术的角度来看，</strong>双向绑定是一种促进可变性的解决方案。</p><blockquote class="mx"><p id="a020" class="my mz jb bd na nb nc nd ne nf ng md dk translated">每个表单都有一个状态，可以通过许多不同的交互来更新，由应用程序开发人员来管理该状态并防止它被破坏。</p></blockquote><p id="5687" class="pw-post-body-paragraph li lj jb lk b ll nh kc ln lo ni kf lq lr nj lt lu lv nk lx ly lz nl mb mc md ij bi translated">这对于非常大的表单来说很难做到，并且会引入一类潜在的bug。</p><h1 id="d643" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">摘要</h1><p id="6993" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">模板驱动的表单是一个很好的方式来处理有角度的表单。</p><p id="9d00" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">使用这种方法，模型是由模板中的指令创建的，而不是在组件上显式创建的。</p><p id="09af" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated"><code class="fe of og oh oi b">ngForm</code>指令自动附加到<code class="fe of og oh oi b">&lt;form&gt;</code>并创建一个顶级<code class="fe of og oh oi b">FormGroup</code>。</p><p id="1837" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们学习了如何使用<code class="fe of og oh oi b">ngModel</code>指令，它如何为我们创建<code class="fe of og oh oi b">FormControl</code>实例，以及我们如何使用它在组件上实现到域模型的双向数据绑定。</p><h1 id="22e8" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">相关链接</h1><p id="f5d6" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">如果你想了解更多关于角形的知识，Victor Savkin在Angular Air 的<a class="ae op" href="https://www.youtube.com/watch?v=NuZKwcPmis8" rel="noopener ugc nofollow" target="_blank">播客将详细介绍这两种形式和<br/>T5。</a></p><p id="c5ad" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">这篇<a class="ae op" href="http://victorsavkin.com/post/108837493941/better-support-for-functional-programming-in" rel="noopener ugc nofollow" target="_blank">博客文章</a>给出了Angular如何更好地支持函数式反应式编程技术的高级概述。</p><p id="da41" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">如果你想详细学习角形，这里有一个很好的Youtube视频，你可以跟着看。</p><p id="fa73" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated"><strong class="lk jc"> <em class="oe">感谢阅读，快乐编码！</em> </strong></p><figure class="ny nz oa ob gt is"><div class="bz fp l di"><div class="oq od l"/></div></figure><h2 id="6b8c" class="nm kr jb bd ks nn no dn kw np nq dp la lr nr ns lc lv nt nu le lz nv nw lg nx bi translated">简单英语的JavaScript</h2><p id="a05a" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae op" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jc">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="lk jc">！</strong></p></div></div>    
</body>
</html>