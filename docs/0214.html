<html>
<head>
<title>Object.create: JavaScript Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Object.create: JavaScript继承</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-inheritance-with-object-create-958b921e9d81?source=collection_archive---------0-----------------------#2019-08-19">https://javascript.plainenglish.io/javascript-inheritance-with-object-create-958b921e9d81?source=collection_archive---------0-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fc48" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Object.create理解JavaScript继承</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f25948d50efe15d0a836a9b5a5c8ee01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C729DKGr1ARAcFnCNc9Sig.jpeg"/></div></div></figure><p id="69cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用“<strong class="kt ir"> Object.create </strong>”是在JavaScript中创建继承模型的最基本方法。<strong class="kt ir"> Object.create </strong>可用于以现有对象为原型创建一个新对象。现有对象可用作原型，使得现有对象的所有属性可用于新对象。</p><p id="4b94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们来详细看看这个方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/5b8bc1e669e9b148030192bc87eb324b" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/5b8bc1e669e9b148030192bc87eb324b</a></figcaption></figure><p id="129c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，我们使用“<strong class="kt ir"> Object.create </strong>”来创建一个新的对象。由于我们没有给新对象添加任何属性或方法，因此，对象“new object”仍然是空的，没有方法或属性。</p><p id="f0b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">见下图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/e2f75a7bc4acec7de8ef0493e4b89d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*3ChASDqj9BaACMe5L7VLZw.png"/></div></figure><p id="e0a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的输出显示，新创建的对象没有可用的属性。它仍然不包含任何方法或属性。</p><p id="ca44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，我们将“userInfo”对象作为参数传递给“Object.create”函数。“userInfo”对象包含“姓名”、“年龄”、“职务”和“薪金”属性及其值。<strong class="kt ir">让我们看看将“userInfo”作为参数传递给函数的影响。</strong></p><h1 id="dd19" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">我们可以使用新对象访问这些属性吗？</strong></h1><p id="d007" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">当我们使用“<strong class="kt ir"> Object.create </strong>创建一个对象时，作为参数传递的对象被<strong class="kt ir">添加到创建的新对象</strong>的“原型”链中。当用户试图从创建的新对象中访问属性时，<strong class="kt ir">它寻找新对象可用的原型链</strong>。JavaScript对象可以使用<strong class="kt ir">“_ _ proto _ _”</strong>属性遍历“原型”链。传递给Object.create函数的<strong class="kt ir">“userInfo”对象被添加到新对象的“__proto__”属性中。让我们看看如何访问这个对象的原型链。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/dc9dd6925ced2dbd63ffb3e30c9ad09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sr0ZVacvrZ_a6P2KGT16CQ.png"/></div></div></figure><p id="850e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们试图使用“newObject”访问属性“name”时，它首先查找该对象可用的属性。因为我们没有给这个对象添加任何属性，所以它使用对象引用“<strong class="kt ir"> __proto__ 【T21”)遍历到“原型”链。“<strong class="kt ir"> __proto__ </strong>”属性指向“userInfo”对象的引用。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/dc9dd6925ced2dbd63ffb3e30c9ad09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sr0ZVacvrZ_a6P2KGT16CQ.png"/></div></div></figure><p id="78e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于属性“name”在由属性“<strong class="kt ir"> __proto__ </strong>”指向的对象中是可用的，所以我们可以使用新创建的对象来访问属性“name”。属性“姓名”、“年龄”、“职务”和“薪水”可用于使用原型链的新对象。</p><p id="bcb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，它表示父子关系:如果在被引用的对象中找不到该属性，它将遍历其原型链以在父对象中找到该属性/方法。如果属性/方法在原型链中可用，我们可以访问这些属性和方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/a63de8b111afb98ea7625e7f35dca306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*CT0mK3RFLGl6ritfGQvCJw.png"/></div></figure><p id="64ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面几行代码中，我们使用的是“=== ”;它声明“<strong class="kt ir"> userInfo.name </strong>”和“<strong class="kt ir"> newObject。__proto__name </strong>"指向相同的内存位置。</p><h1 id="b8eb" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">原型链的访问方法</h1><p id="5c4c" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">到目前为止，我们已经讨论了从原型链中访问属性。我们还可以访问原型链中可用的方法。让我们借助一个例子来看看。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/d4774188752ba32d82b04797935a73db" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/d4774188752ba32d82b04797935a73db</a></figcaption></figure><h1 id="d602" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">覆盖原型链的值</h1><p id="892a" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">“name”属性在新创建的对象的原型链中可用。我们可以将同名的属性添加到新对象中。当我们将具有相同名称的属性添加到新对象中时，它会被添加到新对象的属性中。如果用户试图访问/修改“name”属性，它引用添加到对象的属性，而不是从原型链访问name属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/2eb401b5098b466c14d6d56762172ebf" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/2eb401b5098b466c14d6d56762172ebf</a></figcaption></figure><p id="4848" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的代码中，我们可以看到我们正在向新创建的对象添加属性。在这种情况下，对象将拥有自己可用的新属性，它将访问/修改自己的属性，而不是引用父属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/42d1c5d7c232ca497183c2adc8ff8996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNphuWZ_IvFdZUf0tr5F4Q.png"/></div></div></figure><p id="5937" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上图中，我们可以看到“name”属性被添加到新创建的对象“newObject”中。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="3e7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看这种方法的<strong class="kt ir">优缺点</strong>:</p><p id="0f45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">object . create的优点</strong></p><p id="9368" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1。“userInfo”对象可用的所有方法和属性也可用于创建的新对象，因为它是原型链的一部分。我们可以使用这种方法，利用<strong class="kt ir">功能和属性的可重用性。</strong></strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/7b048bf92cc01aa126a306b78432b559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJ_EYQ9EW4_okjVyrVETXQ.png"/></div></div></figure><p id="ada1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2。</strong>属性通过原型链变得可用，因此对象不需要消耗更多的内存空间来保存现有的函数和属性。不消耗单独的存储空间。因此这些方法和属性可以重用。</p><p id="f673" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 3。</strong>当我们有一些分层数据表示和/或如果我们需要显示从源对象到目的对象的一些继承特征时，该方法提供了功能和属性的可重用性</p><p id="15f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">“object . create”的缺点</strong></p><p id="9075" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1。</strong>新创建的对象不会创建单独的属性。修改源对象的属性也会修改新对象可用的数据。</p><p id="268b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发者可以假设该属性属于所创建的新对象。修改源对象中的属性或函数会反映在目标/新创建的对象中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d3c5df4e541b34cce0506e408a76ce8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*xL73lWypikwzPimRvcmuOA.png"/></div></figure><p id="6fb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果希望使用“Object.create”创建的每个对象都有一个专用的“name”属性，则需要为新创建的对象显式添加一个属性。在下面的代码中，我们为新创建的对象添加了一个单独的属性。所以，在这种情况下，它不会从原型链中访问“name”数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk"><a class="ae lt" href="https://gist.github.com/Mayankgupta688/c08b4c7f35e818f922f09ff6e1032350" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/c08b4c7f35e818f922f09ff6e1032350</a></figcaption></figure><p id="98c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.<strong class="kt ir">不会为对象</strong>创建深层副本</p><p id="cbcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它<strong class="kt ir">不创建深层拷贝；</strong>对象遵循继承的概念。所以新对象<strong class="kt ir">不包含单独的属性和方法</strong>。属性和方法是从继承链中的父级访问的。</p><p id="57a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ne">更多内容请看</em><a class="ae lt" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir"><em class="ne">plain English . io</em></strong></a></p></div></div>    
</body>
</html>