<html>
<head>
<title>Scaling your services: Understanding the Service Discovery and Service Mesh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展您的服务:了解服务发现和服务网格</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-the-service-discovery-and-service-mesh-f1ee3a628c76?source=collection_archive---------4-----------------------#2020-10-14">https://javascript.plainenglish.io/understanding-the-service-discovery-and-service-mesh-f1ee3a628c76?source=collection_archive---------4-----------------------#2020-10-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="158a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当今时代，大家都在说微服务。微服务架构的旅程从一个整体开始。在一个整体中，我们将我们的整个应用打包成一个单元，我们将它作为一个应用来开发和部署。单个存储库中的大量代码，难以维护和扩展。为了处理与monolith相关的问题，有一个通用的解决方案，即将monolith拆分为多个可管理的独立服务，并在需要时分别进行扩展。这些较小的服务被称为微服务。</p><p id="7db3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看传统的独石，看看有什么好的。比方说，我们的monolith有4个模块——A、B、C和d。现在，无论何时A想要与B通话，都非常容易。这只是一个函数调用，因为A将能够调用B的公共方法，因为它们是同一个应用程序的一部分。但是这种系统存在许多问题，例如:</p><ol class=""><li id="50b7" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">如果模块A有bug，代码无法编译。这将导致我们的整个服务瘫痪</li><li id="d6ef" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">如果模块A上的负载比模块B大得多，我们就无法独立扩展模块A。</li><li id="557d" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">模块A的发布依赖于模块B的发布</li></ol><p id="a03a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，建议将我们的monoliths分成更小的服务。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/bbc53211ed66e954f7f9fef8b91f8983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QyBFgJyIeRE-6nPoyGr0NQ.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Figure 1 — Splitting a monolith into smaller services</figcaption></figure><p id="0821" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在分布式设置中，我们必须面对许多挑战，比如模块A如何与模块b交互。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/dfffd3b7e86318efd0867d47083d7e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*zmZ3MkYYUAPksfSH5AZ66g.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Figure 2 — Services communicating via a load balancer</figcaption></figure><p id="e917" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个问题的一个更简单的解决方案是服务A将通过负载均衡器与服务B对话。但是这种方法有以下问题:</p><ol class=""><li id="e2d2" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">负载平衡器将是单点故障</li><li id="cb2a" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">我们将在应用程序中对负载平衡器的URL进行硬编码，这也是一种不好的做法</li><li id="8118" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">请求必须经过额外的跳跃，因为请求将总是通过负载平衡器</li></ol><p id="db2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更好的方法似乎是引入ServiceRegistry。服务注册表将保存所有服务的IP。如果存在服务B的3个实例，服务注册中心将拥有服务B的3个实例的IP地址。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi ln"><img src="../Images/698a4c252f13f49cb990d7729da1e752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBCmkPlVT8RXNVdq_InA_A.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Figure 3- Introduction of ServiceRegistry</figcaption></figure><p id="0e18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看具有ServiceRegistry的基础架构:</p><ol class=""><li id="8676" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">每当服务联机时，它都会向ServiceRegistry注册自己</li><li id="14e5" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">每当一个服务上线时，它向ServiceRegistry请求其他服务的IP，无论它将联系谁</li><li id="0555" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">每隔一段时间，ServiceRegistery将使用与其他服务相关的信息更新服务</li></ol><p id="cb65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上图中，ServiceRegistry看起来像是一个单点故障，但ServiceRegistry通常由许多服务器组成，数据在这些服务器之间复制。</p><p id="5e45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了完成这一切，所有服务都需要一种与ServiceRegistry通信的方式。一个常见的解决方案是有一个边车。每项服务都会安装一个边车。sidecar将拥有关于ServiceRegistry的信息。sidecar将与ServiceRegistry通信，并将为应用程序提供所需服务的IP。边车将作为代理。现在，所有进出特定服务的请求都通过sidecar。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/2a105efb5f7febfa92f5b5845b193794.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*ZqME_yl-Ali4okuj8kIRGQ.png"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Figure 4- Every Service has a sidecar along with it</figcaption></figure><p id="7def" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与其他体系结构相比，这种体系结构将解决以下优点:</p><ol class=""><li id="9dd4" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">服务A将直接与服务B交互，从而减少网络延迟</li><li id="2e8d" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">边车还将实现断路和重试机制</li><li id="e3d4" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">现在我们的系统中没有单点故障</li></ol><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lp"><img src="../Images/b5d525183f151ef70b58a964d7faace4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYxxS7TaQhtQ11QpltGRfw.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Figure 4</figcaption></figure><p id="247e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在我们的整体如图5所示，服务之间的交互也将是无缝的。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lq"><img src="../Images/3daa8de905d54c290c3b47c9ea9f979b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WctU37-uhod15R3FzasnTQ.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Figure 5</figcaption></figure><p id="aae7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以用来实现上述体系结构的几种常用工具是哈希公司的领事、网飞·爱德华卡等。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lr"><img src="../Images/57ce07e5a9234f217cf8df9d5a138a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RaOpx0l0e0P15QvD4akOZg.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Figure 6 — How a ServiceMesh looks when having 1000’s of services</figcaption></figure><p id="e3fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在优步、亚马逊、网飞等系统中。服务数量太高，即系统有100到1000个微服务。因此，上面的架构看起来像一个网状结构。因此，这种模式被称为<strong class="jm io">服务网状架构</strong>。</p></div></div>    
</body>
</html>