<html>
<head>
<title>JavaScript Type Checking with Flow — More Utility Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流进行JavaScript类型检查—更多实用程序类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-type-checking-with-flow-more-utility-types-28ab1d326772?source=collection_archive---------6-----------------------#2020-02-23">https://javascript.plainenglish.io/javascript-type-checking-with-flow-more-utility-types-28ab1d326772?source=collection_archive---------6-----------------------#2020-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1ac5d2f41df583685a8254e18a7a2677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pAKepo9Jhuc_2ord"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sickle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sergey Pesterev</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7a86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flow是一个由脸书开发的类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="03af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究Flow内置的更多实用程序类型。</p><h1 id="ea8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$NonMaybeType <t/></h1><p id="5212" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$NonMaybeType&lt;T&gt;</code>将类型<code class="fe me mf mg mh b">T</code>转换为非可能类型。这意味着我们不能将<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>赋给这个实用程序类型返回的类型的任何属性。</p><p id="45a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="56b3" class="mq lc iq mh b gy mr ms l mt mu">type MaybeAge = ?number;<br/>type Age = $NonMaybeType&lt;MaybeAge&gt;;<br/>let age: Age = 1;</span></pre><p id="d0d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能将<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>分配给任何类型为<code class="fe me mf mg mh b">Age</code>的对象:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d10c" class="mq lc iq mh b gy mr ms l mt mu">let age2: Age = null;</span></pre><p id="810b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码会给出一个错误。</p><h1 id="6892" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">$ObjMap&lt;T, F&gt;</code></h1><p id="f23c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$ObjMap&lt;T, F&gt;</code>返回一个通过函数类型<code class="fe me mf mg mh b">F</code>映射对象类型<code class="fe me mf mg mh b">T</code>的类型。</p><p id="bd89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有一个映射函数的类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d5c3" class="mq lc iq mh b gy mr ms l mt mu">type ExtractReturnType = &lt;V&gt;(() =&gt; V) =&gt; V;</span></pre><p id="b881" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有下面的运行函数的函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="27d6" class="mq lc iq mh b gy mr ms l mt mu">function run&lt;O: Object&gt;(o: O): $ObjMapi&lt;O, ExtractReturnType&gt;{<br/>  return Object.keys(o).map(key =&gt; o[key]());<br/>}</span></pre><p id="54d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么假设我们有以下对象:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0636" class="mq lc iq mh b gy mr ms l mt mu">const o = {<br/>  a: () =&gt; 1,<br/>  b: () =&gt; 'foo'<br/>};</span></pre><p id="69ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以得到<code class="fe me mf mg mh b">o</code>对象的方法的返回类型如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0335" class="mq lc iq mh b gy mr ms l mt mu">(run(o).a: number);<br/>(run(o).b: string);</span></pre><h1 id="a5f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$ObjMapi <t f=""/></h1><p id="e871" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$ObjMapi&lt;T, F&gt;</code>与<code class="fe me mf mg mh b">$ObjMap&lt;T, F&gt;</code>相似，但<code class="fe me mf mg mh b">F</code>将被对象类型<code class="fe me mf mg mh b">T</code>的元素的键和值类型调用。</p><p id="dd6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="70d4" class="mq lc iq mh b gy mr ms l mt mu">type ExtractReturnType = &lt;V&gt;(() =&gt; V) =&gt; V;<br/>function run&lt;O: Object&gt;(o: O): $ObjMapi&lt;O, ExtractReturnType&gt;{<br/>  return Object.keys(o).map(key =&gt; o[key]());<br/>}<br/>const o = {<br/>  a: () =&gt; 1,<br/>  b: () =&gt; 'foo'<br/>};</span></pre><p id="34ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到为<code class="fe me mf mg mh b">a</code>和<code class="fe me mf mg mh b">b</code>返回的以下类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6a7b" class="mq lc iq mh b gy mr ms l mt mu">(run(o).a: { k: 'a', v: number });<br/>(run(o).b: { k: 'b', v: string });</span></pre><p id="7ed4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，<code class="fe me mf mg mh b">k</code>是<code class="fe me mf mg mh b">o</code>的键值，<code class="fe me mf mg mh b">v</code>是<code class="fe me mf mg mh b">o</code>键值的对应值。</p><h1 id="affc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$TupleMap <t f=""/></h1><p id="5070" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$TupleMap&lt;T, F&gt;</code>采用类似元组或数组的迭代类型<code class="fe me mf mg mh b">T</code>和函数类型<code class="fe me mf mg mh b">F</code>，并返回通过将迭代中的每个值映射为类型<code class="fe me mf mg mh b">F</code>的函数而获得的迭代类型。</p><p id="be56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这和JavaScript中在数组中调用<code class="fe me mf mg mh b">map</code>是一样的。</p><p id="eeb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1cd4" class="mq lc iq mh b gy mr ms l mt mu">type ExtractReturnType = &lt;V&gt;(() =&gt; V) =&gt; V</span><span id="f7b4" class="mq lc iq mh b gy mv ms l mt mu">function run&lt;A, I: Array&lt;() =&gt; A&gt;&gt;(iter: I): $TupleMap&lt;I, ExtractReturnType&gt; {<br/>  return iter.map(fn =&gt; fn());<br/>}</span><span id="741e" class="mq lc iq mh b gy mv ms l mt mu">const arr = [() =&gt; 1, () =&gt; 2];<br/>(run(arr)[0]: number);<br/>(run(arr)[1]: number);</span></pre><p id="d189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，<code class="fe me mf mg mh b">arr</code>数组中每个函数的返回类型必须相同。否则，我们会得到一个错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/045ef44af0ecedc04e9750f124b22db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GY0SPW6lA21aJmKs"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fezbot2000?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fezbot2000</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="80e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">$Call&lt;F, T...&gt;</code></h1><p id="ce5a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$Call&lt;F, T…&gt;</code>是一种类型，它导致调用带有0个或更多参数<code class="fe me mf mg mh b">T...</code>的类型为<code class="fe me mf mg mh b">F</code>的函数。这类似于在运行时调用一个函数，但返回的是类型。</p><p id="dcbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e2e6" class="mq lc iq mh b gy mr ms l mt mu">type Add = (number, number) =&gt; string;<br/>type Sum = $Call&lt;Add, number, number&gt;;<br/>let x: Sum = '1';</span></pre><p id="62e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，假设我们有<code class="fe me mf mg mh b">Add</code>类型，这是一个接受2个数字并返回一个字符串的函数类型。我们用它创造了一种新的类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be55" class="mq lc iq mh b gy mr ms l mt mu">type Sum = $Call&lt;Add, number, number&gt;;</span></pre><p id="9e48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">Sum</code>类型是一个字符串。</p><p id="38bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1ca0" class="mq lc iq mh b gy mr ms l mt mu">const add = (a: number, b: number) =&gt; (a + b).toString();<br/>type Add = (number, number) =&gt; string;<br/>type Sum = $Call&lt;typeof add, number, number&gt;;<br/>let x: Sum = '1';</span></pre><p id="3daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，这对于在不实际调用函数的情况下获取函数的返回类型很有用。</p><h1 id="dc8c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Class&lt;T&gt;</code></h1><p id="3f7d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Class&lt;T&gt;</code>用于将类型传入一个类。它让我们可以创建一个可以接受多种类型的泛型类。</p><p id="d43e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，给定以下类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a21" class="mq lc iq mh b gy mr ms l mt mu">class Foo&lt;T&gt;{<br/>  foo: T;<br/>  constructor(foo: T){<br/>    this.foo = foo;<br/>  }</span><span id="d3ad" class="mq lc iq mh b gy mv ms l mt mu">  getFoo(): T {<br/>    return this.foo;<br/>  }<br/>}</span></pre><p id="58bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来创建多个类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7b8" class="mq lc iq mh b gy mr ms l mt mu">type NumFoo = Foo&lt;number&gt;;<br/>type StringFoo = Foo&lt;string&gt;;</span></pre><p id="b946" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以实例化这些类，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7084" class="mq lc iq mh b gy mr ms l mt mu">let numFoo: NumFoo = new Foo&lt;number&gt;(1);<br/>let stringFoo: StringFoo = new Foo&lt;string&gt;('abc');</span></pre><h1 id="93ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$Shape <t/></h1><p id="d21b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$Shape&lt;T&gt;</code>是包含<code class="fe me mf mg mh b">T</code>中属性子集的类型。</p><p id="1449" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，给定<code class="fe me mf mg mh b">Person</code>类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="07c7" class="mq lc iq mh b gy mr ms l mt mu">type Person = {<br/>  name: string,<br/>  age: number<br/>}</span></pre><p id="cffb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以如下使用<code class="fe me mf mg mh b">$Shape&lt;T&gt;</code>类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f2f2" class="mq lc iq mh b gy mr ms l mt mu">const age: $Shape&lt;Person&gt; = { age: 10 };</span></pre><p id="a4b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们没有在分配的对象中包含<code class="fe me mf mg mh b">name</code>属性。</p><p id="a7a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">$Shape&lt;T&gt;</code>与<code class="fe me mf mg mh b">T</code>不同，它的所有字段都标记为可选。<code class="fe me mf mg mh b">$Shape&lt;T&gt;</code>可以铸入<code class="fe me mf mg mh b">T</code>。例如，我们之前定义的<code class="fe me mf mg mh b">age</code>常量可以转换如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="46a9" class="mq lc iq mh b gy mr ms l mt mu">(age: Person);</span></pre><h1 id="583d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">美元出口<t/></h1><p id="8cdc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$Exports&lt;T&gt;</code>让我们从另一个文件导入类型。例如，以下内容是相同的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3379" class="mq lc iq mh b gy mr ms l mt mu">import typeof * as T from './math';<br/>type T = $Exports&lt;'./math'&gt;;</span></pre><p id="1682" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Flow中，我们为具有方法的对象提供了特定的实用程序类型，以返回方法类型。此外，我们有一个类型，用于将具有相同返回类型的函数的可迭代对象映射到每个函数的返回类型。</p><p id="f337" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，还有用于定义泛型类的<code class="fe me mf mg mh b">Class&lt;T&gt;</code>实用类型，用于获取类型<code class="fe me mf mg mh b">T</code>的属性子集作为其自身类型的<code class="fe me mf mg mh b">$Shape&lt;T&gt;</code>类型。</p><p id="5c97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有用于在不调用的情况下检索<code class="fe me mf mg mh b">F</code>的返回类型的<code class="fe me mf mg mh b">$Call&lt;F, T,...&gt;</code>。</p><p id="826f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们有从另一个文件获取类型的<code class="fe me mf mg mh b">$Exports&lt;T&gt;</code>类型。</p></div></div>    
</body>
</html>