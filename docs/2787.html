<html>
<head>
<title>React Tips — Fix Common Errors, Multiple Classes, and Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React提示—修复常见错误、多个类和上下文API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-fix-common-errors-multiple-classes-and-context-api-f9fb834960b4?source=collection_archive---------15-----------------------#2020-07-23">https://javascript.plainenglish.io/react-tips-fix-common-errors-multiple-classes-and-context-api-f9fb834960b4?source=collection_archive---------15-----------------------#2020-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f09fac3d1f81ea0d2f4855f8122232c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v_NIZ_ZFWuau5wXx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@juanencalada?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Juan Encalada</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3fad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="de41" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向React组件添加多个类</h1><p id="ec74" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">classnames</code>包向React组件添加多个类。</p><p id="0964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在<code class="fe me mf mg mh b">render</code>方法或函数组件中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bcfd" class="mq lc iq mh b gy mr ms l mt mu">const liClasses = classNames({<br/>  'main-class': true,<br/>  'active': props.active<br/>});</span><span id="7c73" class="mq lc iq mh b gy mv ms l mt mu">return (&lt;li className={liClasses}&gt;{props.name}&lt;/li&gt;);</span></pre><p id="c504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用模板文字来做同样的事情。</p><p id="bb84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0cb2" class="mq lc iq mh b gy mr ms l mt mu">&lt;input className={`form-control rounded ${this.state.valid ? '' : 'error'}`} /&gt;</span></pre><h1 id="e916" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复“不变冲突:对象作为反应子对象无效”错误</h1><p id="aeb2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过确保在包装组件的开始和结束标记之间有字符串或组件来修复错误。</p><p id="d1e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们要呈现一个字符串，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="acf2" class="mq lc iq mh b gy mr ms l mt mu">return (<br/>  &lt;Item href={routeString}&gt;<br/>    {breadcrumbElement}<br/>  &lt;/Item&gt;<br/>)</span></pre><p id="1c44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">breadcrumbElement</code>是反应元素或成分。</p><p id="08a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用字符串替换元素或组件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b1ec" class="mq lc iq mh b gy mr ms l mt mu">return (<br/>  &lt;Item href={routeString}&gt;<br/>    hello world<br/>  &lt;/Item&gt;<br/>)</span></pre><p id="ae6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一个数组，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1389" class="mq lc iq mh b gy mr ms l mt mu">const photosList = photos.map((photo, i) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>       &lt;img src={photo.url} alt={photos.description} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>});</span><span id="db68" class="mq lc iq mh b gy mv ms l mt mu">return (<br/>  {photosList}<br/>);</span></pre><p id="942b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都在类组件或函数的<code class="fe me mf mg mh b">render</code>方法内部。</p><p id="472d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个表达式，通过调用返回img元素的回调函数<code class="fe me mf mg mh b">map</code>,将<code class="fe me mf mg mh b">photos</code>数组呈现为图像。</p><p id="33b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在我们的<code class="fe me mf mg mh b">return</code>语句中返回它。</p><h1 id="122a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复了“一个组件正在将一个文本类型的非受控输入更改为受控”错误</h1><p id="d950" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过用状态设置输入的<code class="fe me mf mg mh b">value</code>属性来修复错误。</p><p id="2ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了设置状态，我们向<code class="fe me mf mg mh b">onChange</code>属性传递一个事件处理程序，以便在输入值改变时设置状态。</p><p id="7bff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d343" class="mq lc iq mh b gy mr ms l mt mu">&lt;input <br/>  className="input" <br/>  type="text" <br/>  value={this.state.name || ""} <br/>  name="name" <br/>  placeholder="name" <br/>  onChange={this.onChange}<br/>/&gt;</span></pre><p id="e5da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么在我们的<code class="fe me mf mg mh b">onChange</code>方法中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2d9d" class="mq lc iq mh b gy mr ms l mt mu">onChange(event){<br/>  const { name, value } = event.target;<br/>  this.setState(prevState =&gt; {<br/>    prevState.fields[name] =  value;<br/>    return {<br/>      fields: prevState.fields<br/>    };<br/>  });<br/>};</span></pre><p id="b086" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从<code class="fe me mf mg mh b">event.target</code>中获得<code class="fe me mf mg mh b">name</code>和<code class="fe me mf mg mh b">value</code>属性。</p><p id="38af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用回调调用<code class="fe me mf mg mh b">setState</code>，将新值与现有的状态对象合并。</p><h1 id="242c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">两个反应组件通信</h1><p id="c8b4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React组件进行通信的场景有几个。</p><p id="5141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最常见的就是亲子沟通。</p><p id="67e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a032" class="mq lc iq mh b gy mr ms l mt mu">const Child = ({ onClick }) =&gt; (<br/>  &lt;div onClick={() =&gt; onClick(42)}&gt;<br/>    Click me<br/>  &lt;/div&gt;<br/>);</span><span id="bad9" class="mq lc iq mh b gy mv ms l mt mu">class Parent extends React.Component {<br/>  onClick(value){<br/>    console.log(value);<br/>  };</span><span id="0ec5" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;Child onClick={this.onClick}/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="de18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">Parent</code>中的<code class="fe me mf mg mh b">onClick</code>方法传递给<code class="fe me mf mg mh b">Child</code>组件。</p><p id="6e9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从参数<code class="fe me mf mg mh b">props</code>中得到道具的<code class="fe me mf mg mh b">onClick</code>。</p><p id="b2d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将它传递给<code class="fe me mf mg mh b">onClick</code>回调函数，在那里我们用一个值调用它。</p><p id="383e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">console.log</code>将运行。</p><p id="7818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要在具有其他关系的组件之间进行通信，我们可以使用上下文API。</p><p id="a091" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c1b0" class="mq lc iq mh b gy mr ms l mt mu">const AppContext = React.createContext(null)</span><span id="7e6e" class="mq lc iq mh b gy mv ms l mt mu">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;AppContext.Provider value={{ language: "en" }}&gt;<br/>        &lt;div&gt;<br/>          &lt;Foo&gt;<br/>            &lt;Bar&gt;<br/>              &lt;Baz /&gt;<br/>            &lt;/Bar&gt;<br/>          &lt;/Foo&gt;<br/>        &lt;/div&gt;<br/>      &lt;/AppContext.Provider&gt;<br/>    )<br/>  }<br/>};</span><span id="355b" class="mq lc iq mh b gy mv ms l mt mu">const Baz = () =&gt; (<br/>  &lt;AppContext.Consumer&gt;<br/>    {({language}) =&gt; &lt;div&gt;{language}&lt;/div&gt;}<br/>  &lt;/AppContext.Consumer&gt;<br/>);</span></pre><p id="3dc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">React.createContext</code>来创建上下文。</p><p id="1eca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">AppContext.Provider</code>将数据传递给<code class="fe me mf mg mh b">AppContext.Provider</code>中的任何组件。</p><p id="c178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">value</code>道具拥有我们可以在其他地方访问的数据。</p><p id="62f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们的<code class="fe me mf mg mh b">Baz</code>组件在我们的上下文提供者内部，我们可以使用<code class="fe me mf mg mh b">AppContext.Consumer</code>来获取数据并呈现它。</p><p id="f075" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在里面有一个回调函数来从我们传递给<code class="fe me mf mg mh b">value</code>的对象中获取<code class="fe me mf mg mh b">language</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/645b95e5d43a5fa7c9b5fcdd1bcb1dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pEiGooQSyHNdxTto"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lightupphotos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cristina Anne Costello</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9a00" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8b77" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用模板字符串或<code class="fe me mf mg mh b">classnames</code>包向一个组件添加多个类。</p><p id="fd69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以直接在父组件和子组件之间进行通信。</p><p id="3c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以使用上下文API在任何组件之间进行通信。</p><p id="8cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">各种错误可以通过快速修复来解决。</p><h1 id="9442" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="ab8f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>