<html>
<head>
<title>V8 engine and Inline Caching in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的V8引擎和内联缓存</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/v8-engine-and-inline-caching-in-javascript-fef80054a551?source=collection_archive---------1-----------------------#2019-06-08">https://javascript.plainenglish.io/v8-engine-and-inline-caching-in-javascript-fef80054a551?source=collection_archive---------1-----------------------#2019-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="972e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在JavaScript领域，内联缓存是一个很少讨论的话题，但是编写优化的代码是非常重要的。</h2></div><p id="0920" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始什么是内联缓存之前，我们需要知道为什么我们需要内联缓存。是的，我们需要缓存来加快速度，这我们都知道。好了，下一部分是内联缓存是如何发挥作用的？内联缓存的历史可以追溯到Google V8引擎。</p><p id="83c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个JavaScript引擎名为SpiderMonkey，是为Netscape Navigator构建的，它只是一个读取和执行源代码的解释器。2004年，当谷歌推出一款新应用时；谷歌地图。对于JavaScript和各地的开发者来说，这是一个游戏改变者。一个非常非常缓慢的游戏改变者。由于JavaScript引擎只是费力地处理所有这些代码，浏览器陷入了困境。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/8c12f7d5c2f54ef90615b6937c1e224c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOAFFA4THxtbKburZCOTAA.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://www.pexels.com/@junior-teixeira-1064069?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Junior Teixeira </a>from <a class="ae lr" href="https://www.pexels.com/photo/semi-opened-laptop-computer-turned-on-on-table-2047905/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><blockquote class="ls lt lu"><p id="6718" class="kf kg lv kh b ki kj jr kk kl km ju kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">为了克服这种缓慢，谷歌建立了自己的引擎——V8，现在为Chrome和Node.js提供动力。在V8之前，JavaScript更像是一种解释语言，但谷歌将该语言从解释语言改为JIT编译语言。V8有2个编译器，全代码和曲轴。Full-Codegen将JavaScript直接解析为机器代码，不需要中间语言，允许它更快地开始执行。一个叫做曲轴的JIT编译器为热方法产生优化的代码。这意味着在同一个V8程序中，不同级别的优化代码同时并存。<br/> <strong class="kh ir">曲轴才是速度真正的来源。</strong></p></blockquote><p id="f541" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们继续我们的主题，即<strong class="kh ir">内联缓存</strong>。对于内联缓存，我们来看一个代码片段。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lz"><img src="../Images/82a1059c02f81a91d6cf1acfad2b6172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91tK2rV7Ci_KIKQ7MMwYoQ.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Inline Caching</figcaption></figure><p id="21c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来分析一下上面的代码是做什么的。我们创建一个函数，它接受一个参数并返回模板字符串。接下来，我们创建一个带有关键字——名字和姓氏——的用户名对象。现在，我们用UserName对象的参数多次调用函数printUserName。</p><p id="c499" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，V8引擎或许多其他JavaScript引擎所做的是，首先它们像您所期望的那样正常运行函数。但是，经过一段时间后，当函数被重复调用时，他们会认为或表现得很聪明，只是将重复的函数调用等同于函数返回的内容，以节省时间并提高效率或速度。在这种情况下，它们等于</p><blockquote class="ls lt lu"><p id="648f" class="kf kg lv kh b ki kj jr kk kl km ju kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated"><strong class="kh ir"> printUserName(用户名)=“你好John Doe”</strong></p></blockquote><p id="83e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这被称为内联缓存。因此，这整个内联缓存的要点是，在知道引擎或编译器将如何处理代码的情况下，编写更好、更高效的代码。我们应该编写代码，让机器知道我们想做什么。</p></div></div>    
</body>
</html>