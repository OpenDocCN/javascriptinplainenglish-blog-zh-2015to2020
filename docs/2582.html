<html>
<head>
<title>JavaScript Tips — Listeners, Sorting, and Nested Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript提示—侦听器、排序和嵌套对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-tips-listeners-sorting-and-nested-objects-a81a9755fe65?source=collection_archive---------11-----------------------#2020-07-06">https://javascript.plainenglish.io/javascript-tips-listeners-sorting-and-nested-objects-a81a9755fe65?source=collection_archive---------11-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6270e2e939d808ccdae49af6155fd7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xU83VtBF4x9HqXKl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@martin_schmidli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin Schmidli</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="009e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="c69a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">addEventListener vs onclick</h1><p id="664e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">addEventListener</code>和<code class="fe me mf mg mh b">onclick</code>是等价的。</p><p id="c94c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以使用<code class="fe me mf mg mh b">addEventListener</code>来监听来自多个DOM元素的事件。</p><p id="7087" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3917" class="mq lc iq mh b gy mr ms l mt mu">element.addEventListener('click', () =&gt; { <br/>  //...<br/>}, false);</span></pre><p id="b0b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以听听<code class="fe me mf mg mh b">element</code>的<code class="fe me mf mg mh b">click</code>事件。</p><p id="ba30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="070f" class="mq lc iq mh b gy mr ms l mt mu">element.onclick = () =&gt;<br/>  //...<br/>}</span></pre><p id="5a0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">做同样的事情。</p><p id="01c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">event</code>对象来监听多个事件。</p><p id="7f05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="261a" class="mq lc iq mh b gy mr ms l mt mu">element.addEventListener('click', (event) =&gt; { <br/>  //...<br/>}, false);</span></pre><p id="d6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">event</code>对象从<code class="fe me mf mg mh b">element</code>的子元素中获取事件数据，并检查动作。</p><h1 id="5ea9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从字符串中去除所有非数字字符</h1><p id="24d6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">replace</code>方法从字符串中去掉所有非数字字符。</p><p id="9bfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cd10" class="mq lc iq mh b gy mr ms l mt mu">const s = "123 abc".replace(/[^\d.-]/g, ''); </span></pre><p id="65c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">^\d</code>来查找所有非数字字符。</p><p id="88db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加<code class="fe me mf mg mh b">g</code>标签来搜索字符串中模式的所有实例。</p><h1 id="909a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何按日期属性对数组排序</h1><p id="e580" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要按<code class="fe me mf mg mh b">Date</code>属性对数组进行排序，我们可以使用<code class="fe me mf mg mh b">sort</code>方法。</p><p id="0741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="03a4" class="mq lc iq mh b gy mr ms l mt mu">array.sort((a, b) =&gt; {<br/>  return new Date(b.date) - new Date(a.date);<br/>});</span></pre><p id="db29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将日期字符串转换成<code class="fe me mf mg mh b">Date</code>实例，然后减去它们得到排序顺序。</p><p id="5d41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样做，因为减法操作符将把<code class="fe me mf mg mh b">Date</code>实例转换成时间戳，时间戳是整数。</p><h1 id="e083" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按值对对象属性进行排序</h1><p id="00c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了按值对对象属性进行排序，我们可以用<code class="fe me mf mg mh b">sort</code>方法按值对键进行排序。</p><p id="5adb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7709" class="mq lc iq mh b gy mr ms l mt mu">const list = {"baz": 200, "me": 75, "foo": 116, "bar": 15};<br/>keysSorted = Object.keys(list).sort((a, b) =&gt; {<br/>  return list[a] - list[b];<br/>})<br/>console.log(keysSorted);</span></pre><p id="2446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有了<code class="fe me mf mg mh b">list</code>对象。</p><p id="0220" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个数组<code class="fe me mf mg mh b">Object.keys</code>来获取密钥。</p><p id="0ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在返回的数组上调用<code class="fe me mf mg mh b">sort</code>。</p><h1 id="a751" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Moment.js转换为日期对象</h1><p id="12f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">toDate</code>方法将力矩对象转换成<code class="fe me mf mg mh b">Date</code>对象。</p><p id="f898" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="51d2" class="mq lc iq mh b gy mr ms l mt mu">moment().toDate();</span></pre><h1 id="5fbe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试嵌套JavaScript对象键是否存在</h1><p id="4e54" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用递归函数来检查一个键。</p><p id="2d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7624" class="mq lc iq mh b gy mr ms l mt mu">const checkNested = (obj, level,  ...rest) =&gt; {<br/>  if (obj === undefined) {<br/>     return false;<br/>  }<br/>  <br/>  if (rest.length === 0 &amp;&amp; obj.hasOwnProperty(level)) {<br/>    return true;<br/>  }  <br/>  return checkNested(obj[level], ...rest)<br/>}</span></pre><p id="83f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查<code class="fe me mf mg mh b">obj</code>是否是<code class="fe me mf mg mh b">undefined</code>，如果是则返回<code class="fe me mf mg mh b">false</code>，因为在我们到达路径的终点之前是<code class="fe me mf mg mh b">undefined</code>。</p><p id="172b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们检查是否没有剩余的参数，并检查带有键<code class="fe me mf mg mh b">level</code>的属性是否存在。</p><p id="3013" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果存在，那么我们返回<code class="fe me mf mg mh b">true</code>。</p><p id="7dfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们通过移动到较低的级别再次调用<code class="fe me mf mg mh b">checkNested</code>函数。</p><p id="840e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4c59" class="mq lc iq mh b gy mr ms l mt mu">checkNested(foo, 'level1', 'level2', 'bar'); </span></pre><p id="a9b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查<code class="fe me mf mg mh b">foo.level1.level2.bar</code>是否存在。</p><p id="0c86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使我们的生活更容易，我们也可以使用<code class="fe me mf mg mh b">?.</code>可选链接操作符:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2de3" class="mq lc iq mh b gy mr ms l mt mu">const value = obj?.level1?.level2?.level3</span></pre><p id="2329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不存在任何中间层，它将返回<code class="fe me mf mg mh b">undefined</code>。</p><h1 id="4b47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Javascript播放音频</h1><p id="1649" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用音频元素的<code class="fe me mf mg mh b">play</code>方法用JavaScript播放音频。</p><p id="6cb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0e63" class="mq lc iq mh b gy mr ms l mt mu">const audio = new Audio('audio.mp3');<br/>audio.play();</span></pre><p id="ba22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="421b" class="mq lc iq mh b gy mr ms l mt mu">document.getElementById('audioPlayer').play();</span></pre><h1 id="3baa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用JavaScript定义一个类</h1><p id="5544" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用两种方式定义一个类。</p><p id="c360" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建一个构造函数或者使用类语法。</p><p id="1dfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2253" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}</span></pre><p id="9a79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个<code class="fe me mf mg mh b">Person</code>构造函数。</p><p id="a797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，为了添加方法，我们编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d336" class="mq lc iq mh b gy mr ms l mt mu">Person.prototype.greet = function() {<br/>  console.log(`hello ${this.name}`);<br/>}</span></pre><p id="a593" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用类语法来做同样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0274" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="ce66" class="mq lc iq mh b gy mv ms l mt mu">  greet<!-- -->() {<br/>    console.log(`hello ${ this.name }`);<br/>  }<br/>}</span></pre><p id="ea33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在类中定义实例方法，而不是给<code class="fe me mf mg mh b">prototype</code>添加一个属性。</p><p id="b57e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它更干净，静态分析可以检查它的语法。</p><p id="87e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于来自基于类的语言的人来说也更容易理解。</p><p id="1b1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两种方式都是一样的。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/4a27f23ecf1e336066b8ed51512e0c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SZ32NmB81PZo1w9-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@andreaelphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrea Lightfoot</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fb25" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="bac8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用多种方式定义类。</p><p id="bcc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过使用可选的链接操作符或我们自己的函数来测试嵌套对象键的存在。</p><p id="3d5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有各种各样的方法来分类。</p><h2 id="d4f1" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="1431" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">找到它们订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>