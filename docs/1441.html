<html>
<head>
<title>Lifting State in React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件中的提升状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-components-lifting-state-up-59175b9efc9e?source=collection_archive---------8-----------------------#2020-03-16">https://javascript.plainenglish.io/react-components-lifting-state-up-59175b9efc9e?source=collection_archive---------8-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/15c74a611bdad594b1ed2e5987392311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bZseLQTXTcBYNxu2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fr3nks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Frank</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="35b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="9262" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究提升状态的原理。</p><h1 id="7e1d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提升状态</h1><p id="8947" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该把任何共享的状态提升到它们最接近的共同祖先。</p><p id="0487" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，一个状态可以通过props传递给多个子组件来共享。</p><p id="270c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想构建一个用于转换长度的计算器，我们可以编写以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="720d" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="1b4d" class="mn lc iq mj b gy ms mp l mq mr">class LengthInput extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    const { length } = this.props;<br/>    this.state = { length };<br/>  }<br/>  handleChange(e) {<br/>    this.props.onChange(e);<br/>  }</span><span id="ad0a" class="mn lc iq mj b gy ms mp l mq mr">  componentWillReceiveProps(props) {<br/>    const { length } = props;<br/>    this.setState({ length });<br/>  }</span><span id="6d2b" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    const { unit } = this.props;<br/>    return (<br/>      &lt;&gt;<br/>        &lt;label&gt;Length ({unit})&lt;/label&gt;<br/>        &lt;input<br/>          value={this.state.length}<br/>          onChange={this.handleChange.bind(this)}<br/>          placeholder={this.props.unit}<br/>        /&gt;<br/>        &lt;br /&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span><span id="61e0" class="mn lc iq mj b gy ms mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { lengthInMeter: 0, lengthInFeet: 0 };<br/>  }</span><span id="9b26" class="mn lc iq mj b gy ms mp l mq mr">  handleMeterChange(e) {<br/>    this.setState({ lengthInMeter: +e.target.value });<br/>    this.setState({ lengthInFeet: +e.target.value * 3.28 });<br/>  }</span><span id="01a9" class="mn lc iq mj b gy ms mp l mq mr">  handleFeetChange(e) {<br/>    this.setState({ lengthInFeet: +e.target.value });<br/>    this.setState({ lengthInMeter: +e.target.value / 3.28 });<br/>  }</span><span id="d9cf" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;LengthInput<br/>          length={this.state.lengthInMeter}<br/>          onChange={this.handleMeterChange.bind(this)}<br/>          unit="meter"<br/>        /&gt;<br/>        &lt;LengthInput<br/>          length={this.state.lengthInFeet}<br/>          onChange={this.handleFeetChange.bind(this)}<br/>          unit="feet"<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="3eaf" class="mn lc iq mj b gy ms mp l mq mr">const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="2705" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个长度转换器，当我们在米字段中键入时，它将米转换为英尺，反之亦然。</p><p id="a0aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的是将长度保存在<code class="fe mt mu mv mj b">App</code>组件中。这就是为什么这个原理被称为提升状态。</p><p id="a131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们在<code class="fe mt mu mv mj b">App</code>组件中保留了长度，所以我们必须将它们传递给<code class="fe mt mu mv mj b">LengthInput</code>组件。</p><p id="df7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们向他们传递道具。此外，我们传入单元，并将更改处理程序函数传递给我们的<code class="fe mt mu mv mj b">LengthInput</code>组件，这样它们就可以更新<code class="fe mt mu mv mj b">App</code>组件中的状态。</p><p id="379c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">handleFeetChange</code>和<code class="fe mt mu mv mj b">handleMeterChange</code>功能中，我们根据<code class="fe mt mu mv mj b">LengthInput</code>组件中输入的值设置状态。</p><p id="f03a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在两个函数中调用<code class="fe mt mu mv mj b">this.setState</code>来设置状态。每次调用<code class="fe mt mu mv mj b">setState</code>时，都会调用<code class="fe mt mu mv mj b">render</code>，以便将最新状态传递给我们的<code class="fe mt mu mv mj b">LengthInput</code>组件。</p><p id="910c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">LengthInput</code>组件中，我们有<code class="fe mt mu mv mj b">componentWillReceiveProps</code>钩子，它将获得最新的属性值，然后相应地设置<code class="fe mt mu mv mj b">length</code>状态。</p><p id="8ca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">this.state.length</code>设置为<code class="fe mt mu mv mj b">LengthInput</code>中<code class="fe mt mu mv mj b">input</code>元素的值，因此将显示输入的值。</p><p id="87dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将状态提升到父组件的好处是我们只需要保存状态的一个副本。此外，我们不必在不同的子组件中重复处理状态。</p><p id="ad31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入值保持同步，因为它们是从同一状态计算的。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/715283a7234b79ec3efd7e207c08e713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ua78AHc171esQKzt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fr3nks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Frank</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="af87" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a067" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当编写React应用程序时，建议我们将子组件之间的共享状态移动到它们的父组件中。这叫做提升状态。</p><p id="a34c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望这样做，这样我们就不必重复处理子组件中的数据，并且我们只有一个真实的来源。</p><p id="2cf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以将数据和功能作为道具传递给子组件。这样，父组件中的函数可以从子组件中调用。</p><p id="fe3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用从props传来的最新值更新子组件的状态，我们可以使用<code class="fe mt mu mv mj b">componentWillReceiveProps</code>钩子从props更新状态。</p></div></div>    
</body>
</html>